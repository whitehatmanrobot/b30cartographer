    *pulXlate,
    RECTL    *prclTrg,
    POINTL   *pptlSrc,
    ULONG    ulDRAWBLTDEF
)
{
    POINTL ptlSrc, ptlDest;
    SIZEL  sizl;
    PPDEV  ppdev;
    BYTE*  pjSrc;
    DWORD* pjHostData;
    LONG   lDelta, lExtra, lLeadIn, i, n, tileSize, maxStripeWidth;


    // Determine the source type and adjust the source offset.
    if (psoSrc->iType == STYPE_DEVBITMAP)
    {
        // Source is a device bitmap.
        PDSURF pdsurf = (PDSURF) psoSrc->dhsurf;
        ptlSrc.x = pptlSrc->x + pdsurf->ptl.x;
        ptlSrc.y = pptlSrc->y + pdsurf->ptl.y;
        ppdev = pdsurf->ppdev;
    }
    else
    {
        // Source is the screen.
        ptlSrc.x = pptlSrc->x;
        ptlSrc.y = pptlSrc->y;
        ppdev = (PPDEV) psoSrc->dhpdev;
    }

    // Determine the destination type and adjust the destination offset.
    if (psoTrg->iType == STYPE_DEVBITMAP)
    {
        PDSURF pdsurf = (PDSURF) psoTrg->dhsurf;
        ptlDest.x = prclTrg->left + pdsurf->ptl.x;
        ptlDest.y = prclTrg->top + pdsurf->ptl.y;
    }
    else
    {
        ptlDest.x = prclTrg->left;
        ptlDest.y = prclTrg->top;
    }

    // We only support color translations in 8-bpp.
    if (ppdev->iBitmapFormat != BMF_8BPP)
    {
        return FALSE;
    }

    // Calculate the size of the blit.
    sizl.cx = prclTrg->right - prclTrg->left;
    sizl.cy = prclTrg->bottom - prclTrg->top;


    // Calculate the screen address.
    pjSrc = ppdev->pjScreen + ptlSrc.x + ptlSrc.y * ppdev->lDeltaScreen;
    lDelta = ppdev->lDeltaScreen;
    pjHostData = (DWORD*) ppdev->pLgREGS->grHOSTDATA;

    // Wait for the hardware to become idle.
    while (LLDR_SZ(grSTATUS) != 0) ;

    // DWORD align the source.
    lLeadIn = (DWORD)pjSrc & 3;
    pjSrc -= lLeadIn;
    n = (sizl.cx + lLeadIn + 3) >> 2;

    // Test for overlapping.
    if (ptlSrc.y < ptlDest.y)
    {
        // Negative direction.
        pjSrc += (sizl.cy - 1) * lDelta;
        ptlDest.y += sizl.cy - 1;
        lDelta = -lDelta;
		REQUIRE(9);
        LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x90200000, 0);
    }
    else if (ptlSrc.y > ptlDest.y)
    {
        // Positive direction.
		REQUIRE(9);
        LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
    }
    else
    {
        // Maybe horizontal overlap, punt call to GDI anyway.
        return(FALSE);
    }

    #if ! DRIVER_5465
        // Get the number of extra DWORDS per line for the HOSTDATA hardware
        // bug.
        if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx, lLeadIn, ptlDest.x) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE. 
                // Punt till we can figure it out.
                return FALSE; 
            }
            lExtra =
                ExtraDwordTable[MAKE_HD_INDEX(sizl.cx, lLeadIn, ptlDest.x)];
        }
        else
            lExtra = 0;
    #endif

    // Start the blit.
    LL_OP1_MONO(lLeadIn, 0);
    LL_OP0(ptlDest.x, ptlDest.y);
    LL_BLTEXT(sizl.cx, sizl.cy);

    while (sizl.cy--)
    {
		BYTE *p = pjSrc;
		BYTE pixel[4];

        for (i = 0; i < n; i++)
        {
            pixel[0] = (BYTE) pulXlate[p[0]];
            pixel[1] = (BYTE) pulXlate[p[1]];
            pixel[2] = (BYTE) pulXlate[p[2]];
            pixel[3] = (BYTE) pulXlate[p[3]];
			p += 4;
			REQUIRE(1);
            *pjHostData = *(DWORD*) pixel;
        }

        #if !DRIVER_5465
            // Now, write the extra DWORDS.
			REQUIRE(lExtra);
            for (i = 0; i < lExtra; i++)
            {
                LL32(grHOSTDATA[i], 0);
            }
        #endif

        // Next line.
        pjSrc += lDelta;
    }

    // Return okay.
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\fillpath.c ===
/******************************************************************************\
*
* $Workfile:   FILLPATH.C  $
*
* Contains the DrvFillPath routine.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/FILLPATH.C  $
*
*    Rev 1.14   Mar 04 1998 15:24:00   frido
* Added new shadow macros.
*
*    Rev 1.13   Nov 03 1997 15:26:36   frido
* Added REQUIRE macros.
*
*    Rev 1.12   08 Apr 1997 12:24:28   einkauf
*
* add SYNC_W_3D to coordinate MCD/2D HW access
*
*    Rev 1.11   21 Mar 1997 11:41:44   noelv
*
* Combined do_flag and sw_test_flag into point_switch
*
*    Rev 1.10   17 Dec 1996 17:04:26   SueS
* Added test for writing to log file based on cursor at (0,0).  Added
* more information to the log file.
*
*    Rev 1.9   26 Nov 1996 10:46:10   noelv
* Changed DBG LEVEL.
*
*    Rev 1.8   26 Nov 1996 10:24:10   SueS
* Changed WriteLogFile parameters for buffering.
*
*    Rev 1.7   13 Nov 1996 15:58:52   SueS
* Changed WriteFile calls to WriteLogFile.
*
*    Rev 1.6   06 Sep 1996 14:46:24   noelv
*
* Updated NULL driver code for 4.0
*
*    Rev 1.5   20 Aug 1996 11:03:32   noelv
* Bugfix release from Frido 8-19-96
*
*    Rev 1.2   17 Aug 1996 15:32:30   frido
* #1244 - Fixed brush rotation for off-screen bitmaps.
* Added new comment header.
* Cleaned up some code.
*
\******************************************************************************/

#include "precomp.h"

BOOL CacheMono(PPDEV ppdev, PRBRUSH pRbrush);
BOOL Cache4BPP(PPDEV ppdev, PRBRUSH pRbrush);
BOOL CacheDither(PPDEV ppdev, PRBRUSH pRbrush);
BOOL CacheBrush(PPDEV ppdev, PRBRUSH pRbrush);

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit signed
// LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// Int32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies two
// 32-bit LONGs to produce a 64-bit LONGLONG result.  I use it because it is
// much faster than 64x64 multiplies.

#define UInt64Div32To32(a, b)                                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define TAKING_ALLOC_STATS  0

#define NUM_BUFFER_POINTS   96      // Maximum number of points in a path for
                                    // which we'll attempt to join all the path
                                    // records so that the path may still be
                                    // drawn by FastFill

#if TAKING_ALLOC_STATS
    ULONG BufferHitInFillpath  = 0;
    ULONG BufferMissInFillpath = 0;
#endif

#if LOG_CALLS
    VOID LogFillPath(ULONG acc, PPDEV ppdev, SURFOBJ* pso);
#else
    #define LogFillPath(acc, ppdev, pso)
#endif

// Describe a single non-horizontal edge of a path to fill.
typedef struct _EDGE {
    PVOID pNext;
    INT   iScansLeft;
    INT   X;
    INT   Y;
    INT   iErrorTerm;
    INT   iErrorAdjustUp;
    INT   iErrorAdjustDown;
    INT   iXWhole;
    INT   iXDirection;
    INT   iWindingDirection;
} EDGE, *PEDGE;

// Maximum number of rects we'll fill per call to the fill code.
#define MAX_PATH_RECTS  50
#define RECT_BYTES      (MAX_PATH_RECTS * sizeof(RECTL))
#define EDGE_BYTES      (TMP_BUFFER_SIZE - RECT_BYTES)
#define MAX_EDGES       (EDGE_BYTES/sizeof(EDGE))

#define FILLPATH_DBG_LEVEL 1

// MIX translation table. Translates a mix 1-16, into an old style ROP 0-255.
extern BYTE gaMix[];

VOID  AdvanceAETEdges(EDGE* pAETHead);
VOID  XSortAETEdges(EDGE* pAETHead);
VOID  MoveNewEdges(EDGE* pGETHead, EDGE* pAETHead, INT iCurrentY);
EDGE* AddEdgeToGET(EDGE* pGETHead, EDGE* pFreeEdge, POINTFIX* ppfxEdgeStart,
                                   POINTFIX* ppfxEdgeEnd, RECTL* pClipRect);
BOOL  ConstructGET(EDGE* pGETHead, EDGE* pFreeEdges, PATHOBJ* ppo,
                                   PATHDATA* pd, BOOL bMore, RECTL* pClipRect);
VOID  AdjustErrorTerm(INT* pErrorTerm, INT iErrorAdjustUp,
                                          INT iErrorAdjustDown, INT yJump, INT* pXStart,
                                          INT iXDirection);

extern BYTE Rop2ToRop3[];

BYTE gajRop[] =
{
    0x00, 0xff, 0xb2, 0x4d, 0xd4, 0x2b, 0x66, 0x99,
    0x90, 0x6f, 0x22, 0xdd, 0x44, 0xbb, 0xf6, 0x09,
    0xe8, 0x17, 0x5a, 0xa5, 0x3c, 0xc3, 0x8e, 0x71,
    0x78, 0x87, 0xca, 0x35, 0xac, 0x53, 0x1e, 0xe1,
    0xa0, 0x5f, 0x12, 0xed, 0x74, 0x8b, 0xc6, 0x39,
    0x30, 0xcf, 0x82, 0x7d, 0xe4, 0x1b, 0x56, 0xa9,
    0x48, 0xb7, 0xfa, 0x05, 0x9c, 0x63, 0x2e, 0xd1,
    0xd8, 0x27, 0x6a, 0x95, 0x0c, 0xf3, 0xbe, 0x41,
    0xc0, 0x3f, 0x72, 0x8d, 0x14, 0xeb, 0xa6, 0x59,
    0x50, 0xaf, 0xe2, 0x1d, 0x84, 0x7b, 0x36, 0xc9,
    0x28, 0xd7, 0x9a, 0x65, 0xfc, 0x03, 0x4e, 0xb1,
    0xb8, 0x47, 0x0a, 0xf5, 0x6c, 0x93, 0xde, 0x21,
    0x60, 0x9f, 0xd2, 0x2d, 0xb4, 0x4b, 0x06, 0xf9,
    0xf0, 0x0f, 0x42, 0xbd, 0x24, 0xdb, 0x96, 0x69,
    0x88, 0x77, 0x3a, 0xc5, 0x5c, 0xa3, 0xee, 0x11,
    0x18, 0xe7, 0xaa, 0x55, 0xcc, 0x33, 0x7e, 0x81,
    0x80, 0x7f, 0x32, 0xcd, 0x54, 0xab, 0xe6, 0x19,
    0x10, 0xef, 0xa2, 0x5d, 0xc4, 0x3b, 0x76, 0x89,
    0x68, 0x97, 0xda, 0x25, 0xbc, 0x43, 0x0e, 0xf1,
    0xf8, 0x07, 0x4a, 0xb5, 0x2c, 0xd3, 0x9e, 0x61,
    0x20, 0xdf, 0x92, 0x6d, 0xf4, 0x0b, 0x46, 0xb9,
    0xb0, 0x4f, 0x02, 0xfd, 0x64, 0x9b, 0xd6, 0x29,
    0xc8, 0x37, 0x7a, 0x85, 0x1c, 0xe3, 0xae, 0x51,
    0x58, 0xa7, 0xea, 0x15, 0x8c, 0x73, 0x3e, 0xc1,
    0x40, 0xbf, 0xf2, 0x0d, 0x94, 0x6b, 0x26, 0xd9,
    0xd0, 0x2f, 0x62, 0x9d, 0x04, 0xfb, 0xb6, 0x49,
    0xa8, 0x57, 0x1a, 0xe5, 0x7c, 0x83, 0xce, 0x31,
    0x38, 0xc7, 0x8a, 0x75, 0xec, 0x13, 0x5e, 0xa1,
    0xe0, 0x1f, 0x52, 0xad, 0x34, 0xcb, 0x86, 0x79,
    0x70, 0x8f, 0xc2, 0x3d, 0xa4, 0x5b, 0x16, 0xe9,
    0x08, 0xf7, 0xba, 0x45, 0xdc, 0x23, 0x6e, 0x91,
    0x98, 0x67, 0x2a, 0xd5, 0x4c, 0xb3, 0xfe, 0x01
};


/******************************Public*Routine******************************\
* DrvFillPath
*
* Fill the specified path with the specified brush and ROP.  This routine
* detects single convex polygons, and will call to separate faster convex
* polygon code for those cases.  This routine also detects polygons that
* are really rectangles, and handles those separately as well.
*
* Note: Multiple polygons in a path cannot be treated as being disjoint;
*       the fill must consider all the points in the path.  That is, if the
*       path contains multiple polygons, you cannot simply draw one polygon
*       after the other (unless they don't overlap).
*
* Note: This function is optional, but is recommended for good performance.
*       To get GDI to call this function, not only do you have to
*       HOOK_FILLPATH, you have to set GCAPS_ALTERNATEFILL and/or
*       GCAPS_WINDINGFILL.
*
\**************************************************************************/

BOOL DrvFillPath(
SURFOBJ*    pso,
PATHOBJ*    ppo,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
MIX         mix,
FLONG       flOptions)
{
    BYTE jClipping;     // clipping type
    EDGE *pCurrentEdge;
    EDGE AETHead;       // dummy head/tail node & sentinel for Active Edge Table
    EDGE *pAETHead;     // pointer to AETHead
    EDGE GETHead;       // dummy head/tail node & sentinel for Global Edge Table
    EDGE *pGETHead;     // pointer to GETHead
    EDGE *pFreeEdges;   // pointer to memory free for use to store edges
    ULONG ulNumRects;   // # of rectangles to draw currently in rectangle list
    RECTL *prclRects;   // pointer to start of rectangle draw list
    INT iCurrentY;      // scan line for which we're currently scanning out the
                        //  fill

    ULONG        uRop;       // Hardware foreground mix value
    ULONG        uRopb;       // Hardware background mix value
    ULONG        avec;                  // A-vector notation for ternary rop
    ULONG        iSolidColor;       // Copy of pbo->iSolidColor
    FNFILL      *pfnFill;           // Points to appropriate fill routine
    BOOL         bRealizeTransparent; // Need a transparent realization for Rop

    BOOL         bSolid;
    BOOL         bMore;
    PATHDATA     pd;
    RECTL        ClipRect;
    PDEV        *ppdev;

    BOOL         bRetVal=FALSE;     // FALSE until proven TRUE
    BOOL         bMemAlloced=FALSE; // FALSE until proven TRUE

    FLONG        flFirstRecord;
    POINTFIX*    pptfxTmp;
    ULONG        cptfxTmp;
    POINTFIX     aptfxBuf[NUM_BUFFER_POINTS];
    ULONG        ulBltDef = 0x1000;


    #if NULL_PATH
    {
            if (pointer_switch)    return(TRUE);
    }
    #endif

    DISPDBG((FILLPATH_DBG_LEVEL,"DrvFillPath\n"));

    // Set up the clipping
    if (pco == (CLIPOBJ *) NULL) {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    } else {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    if (jClipping != DC_TRIVIAL) {
        if (jClipping != DC_RECT) {
            DISPDBG((FILLPATH_DBG_LEVEL,"Complex Clipping Early Out\n"));
            #if LOG_CALLS
                ppdev = (PDEV*) pso->dhpdev;
                LogFillPath(2,  ppdev, NULL);
            #endif
            goto ReturnFalse;  // there is complex clipping; let GDI fill the path
        }
        // Clip to the clip rectangle
        ClipRect = pco->rclBounds;
    } else {
        // So the y-clipping code doesn't do any clipping
        // /16 so we don't blow the values out when we scale up to GIQ
        ClipRect.top = (LONG_MIN + 1) / 16; // +1 to avoid compiler problem
        ClipRect.bottom = LONG_MAX / 16;
    }

    // There's nothing to do if there are only one or two points
    if (ppo->cCurves <= 2) {
        DISPDBG((FILLPATH_DBG_LEVEL,"Nothing to do out\n"));
        #if LOG_CALLS
            ppdev = (PDEV*) pso->dhpdev;
            LogFillPath(0,  ppdev, pso);
        #endif
        goto ReturnTrue;
    }

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:
         // This is where to put device bit maps
    ppdev = (PDEV*) pso->dhpdev;

    SYNC_W_3D(ppdev);

    if (pso->iType == STYPE_DEVBITMAP)
    {
        PDSURF pdsurf = (PDSURF) pso->dhsurf;

        if ( pdsurf->pso && !bCreateScreenFromDib(ppdev, pdsurf) )
        {
                LogFillPath(4,  ppdev, NULL);
                return(EngFillPath(pdsurf->pso, ppo, pco, pbo, pptlBrush, mix,
                                                           flOptions));
        }
        ppdev->ptlOffset = pdsurf->ptl;
    }
    else
    {
        ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;
    }

    pfnFill = vMmFillSolid;
    uRop = Rop2ToRop3[mix & 0xF];
    uRopb = Rop2ToRop3[(mix >> 8) & 0xF];
    bSolid = ((pbo == NULL) || (pbo->iSolidColor != -1));

    //
    // Make it simple and punt this one until later
    //
    avec = gajRop[uRop];
    if ((uRop != uRopb) && !bSolid)
    {
           DISPDBG((FILLPATH_DBG_LEVEL, "ROPs it Fore=%x Back=%x ROP3=%x\n", uRop, uRopb, ROP3MIX(uRop, uRopb)));
                uRop = ROP3MIX(uRop, uRopb);
                avec = gajRop[uRop];
                if (avec & AVEC_NEED_SOURCE)
              {
              // Use the implicit mask in the brush object.
              // Note pre-align mask (as if "anchored")

              if (!bSetMask(ppdev, pbo, pptlBrush, &ulBltDef))
              {
                  DISPDBG((FILLPATH_DBG_LEVEL, "Set Mask Failed"));
                  LogFillPath(5,  ppdev, NULL);
                  return FALSE;
              }
                  }


    }

    iSolidColor = 0;                    // Assume we won't need a pattern
    bRealizeTransparent = FALSE;
    if (avec & AVEC_NEED_PATTERN)
    {
                  iSolidColor = pbo->iSolidColor;
        if (pbo->iSolidColor == -1)
        {
            bRealizeTransparent = (uRop != uRopb);
            if (pbo->pvRbrush == NULL)
            {
                pbo->pvRbrush = BRUSHOBJ_pvGetRbrush(pbo);
                if (pbo->pvRbrush == NULL)
                {
                    DISPDBG((FILLPATH_DBG_LEVEL,"Could Not Get Brush\n"));
                    LogFillPath(6,  ppdev, NULL);
                    return(FALSE);
                }
            }
            pfnFill = vMmFillPatFast;
        }
                else
                        ulBltDef |= (BD_OP2 * IS_SOLID);         // Or in 0x0007
    }

    if (avec & AVEC_NEED_DEST)
                ulBltDef |= (BD_OP0 * IS_VRAM);  // Or in 0x0100

    // Enumerate path here first time to check for special
    // cases (rectangles and monotone polygons)

    // It is too difficult to determine interaction between
    // multiple paths, if there is more than one, skip this

    bMore = PATHOBJ_bEnum(ppo, &pd);

    if (jClipping == DC_TRIVIAL)
    {
        // Try going through the fast non-complex fill code.  We'll have
        // to realize the brush first if we're going to handle a pattern:

        if (iSolidColor == -1)
        {
#ifdef S3
        #if !FASTFILL_PATTERNS
            goto SkipFastFill;
        #else
            // We handle patterns in 'pfnFastFill' only if we can use the S3
            // hardware patterns.
            if (!(ppdev->flCaps & CAPS_HW_PATTERNS))
                goto SkipFastFill;

            // Note: prb->pbe will be NULL and prb->ptlBrushOrg.x will be -1 the
            //       first time an RBRUSH is used.  So we have to check the
            //       alignment *before* dereferencing prb->pbe...

            if ((rbc.prb->ptlBrushOrg.x != pptlBrush->x + ppdev->xOffset) ||
                (rbc.prb->ptlBrushOrg.y != pptlBrush->y + ppdev->yOffset) ||
                (rbc.prb->apbe[IBOARD(ppdev)]->prbVerify != rbc.prb)      ||
                (rbc.prb->bTransparent != bRealizeTransparent))
            {
                vMmFastPatRealize(ppdev, pbo, pptlBrush,
                                         bRealizeTransparent);

            }
        #endif
#endif

            // Realize the brush
            if (!SetBrush(ppdev, &ulBltDef, pbo, pptlBrush))
            {
                 DISPDBG((FILLPATH_DBG_LEVEL,"Could Not Set Brush\n"));
                 LogFillPath(6,  ppdev, NULL);
                 return FALSE;
            }
        }

        if (bMore)
        {
            // FastFill only knows how to take a single contiguous buffer
            // of points.  Unfortunately, GDI sometimes hands us paths
            // that are split over multiple path data records.  Convex
            // figures such as Ellipses, Pies and RoundRects are almost
            // always given in multiple records.  Since probably 90% of
            // multiple record paths could still be done by FastFill, for
            // those cases we simply copy the points into a contiguous
            // buffer...

            // First make sure that the entire path would fit in the
            // temporary buffer, and make sure the path isn't comprised
            // of more than one subpath:

            if ((ppo->cCurves >= NUM_BUFFER_POINTS) ||
                (pd.flags & PD_ENDSUBPATH))
                goto SkipFastFill;

            pptfxTmp = &aptfxBuf[0];

            RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);

            pptfxTmp     += pd.count;
            cptfxTmp      = pd.count;
            flFirstRecord = pd.flags;       // Remember PD_BEGINSUBPATH flag

            do {
                bMore = PATHOBJ_bEnum(ppo, &pd);

                RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);
                cptfxTmp += pd.count;
                pptfxTmp += pd.count;
            } while (!(pd.flags & PD_ENDSUBPATH));

            // Fake up the path data record:

            pd.pptfx  = &aptfxBuf[0];
            pd.count  = cptfxTmp;
            pd.flags |= flFirstRecord;

            // If there's more than one subpath, we can't call FastFill:

            if (bMore)
                goto SkipFastFill;
        }

                  ppdev->uBLTDEF = ulBltDef;
        if (bMmFastFill(ppdev, pd.count, pd.pptfx, uRop,
                                 uRopb, iSolidColor, pbo))
        {
            LogFillPath(0,  ppdev, pso);
            return(TRUE);
        }
    }

SkipFastFill:

    // Set up working storage in the temporary buffer

    prclRects = (RECTL*) ppdev->pvTmpBuffer; // storage for list of rectangles to draw

    if (!bMore) {

        RECTL *rectangle;
        INT cPoints = pd.count;

        // The count can't be less than three, because we got all the edges
        // in this subpath, and above we checked that there were at least
        // three edges

        // If the count is four, check to see if the polygon is really a
        // rectangle since we can really speed that up. We'll also check for
        // five with the first and last points the same, because under Win 3.1,
        // it was required to close polygons

        if ((cPoints == 4) ||
           ((cPoints == 5) &&
            (pd.pptfx[0].x == pd.pptfx[4].x) &&
            (pd.pptfx[0].y == pd.pptfx[4].y))) {

            rectangle = prclRects;

      /* we have to start somewhere so assume that most
         applications specify the top left point  first

         we want to check that the first two points are
         either vertically or horizontally aligned.  if
         they are then we check that the last point [3]
         is either horizontally or  vertically  aligned,
         and finally that the 3rd point [2] is  aligned
         with both the first point and the  last  point */

#define FIX_SHIFT 4L
#define FIX_MASK (- (1 << FIX_SHIFT))

         rectangle->top   = pd.pptfx[0].y - 1 & FIX_MASK;
         rectangle->left  = pd.pptfx[0].x - 1 & FIX_MASK;
         rectangle->right = pd.pptfx[1].x - 1 & FIX_MASK;

         if (rectangle->left ^ rectangle->right) {
            if (rectangle->top  ^ (pd.pptfx[1].y - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->left ^ (pd.pptfx[3].x - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->right ^ (pd.pptfx[2].x - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[2].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;
         }
         else {
            if (rectangle->top ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[1].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[2].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->right = pd.pptfx[2].x - 1 & FIX_MASK;
            if (rectangle->right ^ (pd.pptfx[3].x - 1 & FIX_MASK))
                goto not_rectangle;
         }

      /* if the left is greater than the right then
         swap them so the blt code doesn't wig  out */

         if (rectangle->left > rectangle->right) {
            FIX temp;

            temp = rectangle->left;
            rectangle->left = rectangle->right;
            rectangle->right = temp;
         }
         else {

         /* if left == right there's nothing to draw */

            if (rectangle->left == rectangle->right)
            {
               LogFillPath(0,  ppdev, pso);
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->left  = (rectangle->left  >> FIX_SHIFT) + 1;
         rectangle->right = (rectangle->right >> FIX_SHIFT) + 1;

         if (rectangle->top > rectangle->bottom) {
            FIX temp;

            temp = rectangle->top;
            rectangle->top = rectangle->bottom;
            rectangle->bottom = temp;
         }
         else {
            if (rectangle->top == rectangle->bottom)
            {
               LogFillPath(0,  ppdev, pso);
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->top    = (rectangle->top    >> FIX_SHIFT) + 1;
         rectangle->bottom = (rectangle->bottom >> FIX_SHIFT) + 1;

         // Finally, check for clipping
         if (jClipping == DC_RECT) {
            // Clip to the clip rectangle
            if (!bIntersect(rectangle, &ClipRect, rectangle))
            {
                // Totally clipped, nothing to do
                LogFillPath(0,  ppdev, pso);
                goto ReturnTrue;
            }
         }

      /* if we get here then the polygon is a rectangle,
         set count to 1 and  goto  bottom  to  draw  it */

         ulNumRects = 1;
         goto draw_remaining_rectangles;
      }

not_rectangle:

        ;

    }

    // Do we have enough memory for all the edges?
    // LATER does cCurves include closure?
    if (ppo->cCurves > MAX_EDGES) {
#if TAKING_ALLOC_STATS
            BufferMissInFillpath++;
#endif
        //
        // try to allocate enough memory
        //
#ifdef WINNT_VER40
        pFreeEdges = (EDGE *) MEM_ALLOC(0, (ppo->cCurves * sizeof(EDGE)), ALLOC_TAG);
#else
        pFreeEdges = (EDGE *) MEM_ALLOC(LMEM_FIXED, (ppo->cCurves * sizeof(EDGE)));
#endif

        if (pFreeEdges == NULL)
        {
            LogFillPath(1,  ppdev, NULL);
            goto ReturnFalse;  // too many edges; let GDI fill the path
        }
        else
        {
            bMemAlloced = TRUE;
        }
    }
    else {
#if TAKING_ALLOC_STATS
            BufferHitInFillpath++;
#endif
        pFreeEdges = (EDGE*) ((BYTE*) ppdev->pvTmpBuffer + RECT_BYTES);
            // use our handy temporary buffer (it's big enough)
    }

    // Initialize an empty list of rectangles to fill
    ulNumRects = 0;

    // Enumerate the path edges and build a Global Edge Table (GET) from them
    // in YX-sorted order.
    pGETHead = &GETHead;
    if (!ConstructGET(pGETHead, pFreeEdges, ppo, &pd, bMore, &ClipRect))
    {
        LogFillPath(7,  ppdev, NULL);
        goto ReturnFalse;  // outside GDI's 2**27 range
    }

    // Create an empty AET with the head node also a tail sentinel
    pAETHead = &AETHead;
    AETHead.pNext = pAETHead;  // mark that the AET is empty
    AETHead.X = 0x7FFFFFFF;    // this is greater than any valid X value, so
                               //  searches will always terminate

    // Top scan of polygon is the top of the first edge we come to
    iCurrentY = ((EDGE *)GETHead.pNext)->Y;

    // Loop through all the scans in the polygon, adding edges from the GET to
    // the Active Edge Table (AET) as we come to their starts, and scanning out
    // the AET at each scan into a rectangle list. Each time it fills up, the
    // rectangle list is passed to the filling routine, and then once again at
    // the end if any rectangles remain undrawn. We continue so long as there
    // are edges to be scanned out
    while (1) {

        // Advance the edges in the AET one scan, discarding any that have
        // reached the end (if there are any edges in the AET)
        if (AETHead.pNext != pAETHead) {
            AdvanceAETEdges(pAETHead);
        }

        // If the AET is empty, done if the GET is empty, else jump ahead to
        // the next edge in the GET; if the AET isn't empty, re-sort the AET
        if (AETHead.pNext == pAETHead) {
            if (GETHead.pNext == pGETHead) {
                // Done if there are no edges in either the AET or the GET
                break;
            }
            // There are no edges in the AET, so jump ahead to the next edge in
            // the GET
            iCurrentY = ((EDGE *)GETHead.pNext)->Y;
        } else {
            // Re-sort the edges in the AET by X coordinate, if there are at
            // least two edges in the AET (there could be one edge if the
            // balancing edge hasn't yet been added from the GET)
            if (((EDGE *)AETHead.pNext)->pNext != pAETHead) {
                XSortAETEdges(pAETHead);
            }
        }

        // Move any new edges that start on this scan from the GET to the AET;
        // bother calling only if there's at least one edge to add
        if (((EDGE *)GETHead.pNext)->Y == iCurrentY) {
            MoveNewEdges(pGETHead, pAETHead, iCurrentY);
        }

        // Scan the AET into rectangles to fill (there's always at least one
        // edge pair in the AET)
        pCurrentEdge = AETHead.pNext;   // point to the first edge
        do {

            INT iLeftEdge;

            // The left edge of any given edge pair is easy to find; it's just
            // wherever we happen to be currently
            iLeftEdge = pCurrentEdge->X;

            // Find the matching right edge according to the current fill rule
            if ((flOptions & FP_WINDINGMODE) != 0) {

                INT iWindingCount;

                // Do winding fill; scan across until we've found equal numbers
                // of up and down edges
                iWindingCount = pCurrentEdge->iWindingDirection;
                do {
                    pCurrentEdge = pCurrentEdge->pNext;
                    iWindingCount += pCurrentEdge->iWindingDirection;
                } while (iWindingCount != 0);
            } else {
                // Odd-even fill; the next edge is the matching right edge
                pCurrentEdge = pCurrentEdge->pNext;
            }

            // See if the resulting span encompasses at least one pixel, and
            // add it to the list of rectangles to draw if so
            if (iLeftEdge < pCurrentEdge->X) {

                // We've got an edge pair to add to the list to be filled; see
                // if there's room for one more rectangle
                if (ulNumRects >= MAX_PATH_RECTS) {
                    // No more room; draw the rectangles in the list and reset
                    // it to empty

                                                        ppdev->uBLTDEF = ulBltDef;
                    (*pfnFill)(ppdev, ulNumRects, prclRects, uRop,
                               uRopb, pbo, pptlBrush);

                    // Reset the list to empty
                    ulNumRects = 0;
                }

                // Add the rectangle representing the current edge pair
                if (jClipping == DC_RECT) {
                    // Clipped
                    // Clip to left
                    prclRects[ulNumRects].left = max(iLeftEdge, ClipRect.left);
                    // Clip to right
                    prclRects[ulNumRects].right =
                            min(pCurrentEdge->X, ClipRect.right);
                    // Draw only if not fully clipped
                    if (prclRects[ulNumRects].left <
                            prclRects[ulNumRects].right) {
                        prclRects[ulNumRects].top = iCurrentY;
                        prclRects[ulNumRects].bottom = iCurrentY+1;
                        ulNumRects++;
                    }
                }
                else
                {
                    // Unclipped
                    prclRects[ulNumRects].top = iCurrentY;
                    prclRects[ulNumRects].bottom = iCurrentY+1;
                    prclRects[ulNumRects].left = iLeftEdge;
                    prclRects[ulNumRects].right = pCurrentEdge->X;
                    ulNumRects++;
                }
            }
        } while ((pCurrentEdge = pCurrentEdge->pNext) != pAETHead);

        iCurrentY++;    // next scan
    }

/* draw the remaining rectangles,  if there are any */

draw_remaining_rectangles:

    if (ulNumRects > 0) {
                  ppdev->uBLTDEF = ulBltDef;
        (*pfnFill)(ppdev, ulNumRects, prclRects, uRop, uRopb,
                   pbo, pptlBrush);
    }

    LogFillPath(0,  ppdev, pso);

ReturnTrue:
    bRetVal = TRUE; // done successfully

ReturnFalse:

    // bRetVal is originally false.  If you jumped to ReturnFalse from somewhere,
    // then it will remain false, and be returned.

    if (bMemAlloced)
    {
        //
        // we did allocate memory, so release it
        //
        MEMORY_FREE (pFreeEdges);
    }

    return(bRetVal);
}

// Advance the edges in the AET to the next scan, dropping any for which we've
// done all scans. Assumes there is at least one edge in the AET.
VOID AdvanceAETEdges(EDGE *pAETHead)
{
    EDGE *pLastEdge, *pCurrentEdge;

    pLastEdge = pAETHead;
    pCurrentEdge = pLastEdge->pNext;
    do {

        // Count down this edge's remaining scans
        if (--pCurrentEdge->iScansLeft == 0) {
            // We've done all scans for this edge; drop this edge from the AET
            pLastEdge->pNext = pCurrentEdge->pNext;
        } else {
            // Advance the edge's X coordinate for a 1-scan Y advance
            // Advance by the minimum amount
            pCurrentEdge->X += pCurrentEdge->iXWhole;
            // Advance the error term and see if we got one extra pixel this
            // time
            pCurrentEdge->iErrorTerm += pCurrentEdge->iErrorAdjustUp;
            if (pCurrentEdge->iErrorTerm >= 0) {
                // The error term turned over, so adjust the error term and
                // advance the extra pixel
                pCurrentEdge->iErrorTerm -= pCurrentEdge->iErrorAdjustDown;
                pCurrentEdge->X += pCurrentEdge->iXDirection;
            }

            pLastEdge = pCurrentEdge;
        }
    } while ((pCurrentEdge = pLastEdge->pNext) != pAETHead);
}

// X-sort the AET, because the edges may have moved around relative to
// one another when we advanced them. We'll use a multipass bubble
// sort, which is actually okay for this application because edges
// rarely move relative to one another, so we usually do just one pass.
// Also, this makes it easy to keep just a singly-linked list. Assumes there
// are at least two edges in the AET.
VOID XSortAETEdges(EDGE *pAETHead)
{
    BOOL bEdgesSwapped;
    EDGE *pLastEdge, *pCurrentEdge, *pNextEdge;

    do {

        bEdgesSwapped = FALSE;
        pLastEdge = pAETHead;
        pCurrentEdge = pLastEdge->pNext;
        pNextEdge = pCurrentEdge->pNext;

        do {
            if (pNextEdge->X < pCurrentEdge->X) {

                // Next edge is to the left of the current edge; swap them
                pLastEdge->pNext = pNextEdge;
                pCurrentEdge->pNext = pNextEdge->pNext;
                pNextEdge->pNext = pCurrentEdge;
                bEdgesSwapped = TRUE;
                pCurrentEdge = pNextEdge;   // continue sorting before the edge
                                            //  we just swapped; it might move
                                            //  farther yet
            }
            pLastEdge = pCurrentEdge;
            pCurrentEdge = pLastEdge->pNext;
        } while ((pNextEdge = pCurrentEdge->pNext) != pAETHead);
    } while (bEdgesSwapped);
}

// Moves all edges that start on the current scan from the GET to the AET in
// X-sorted order. Parameters are pointer to head of GET and pointer to dummy
// edge at head of AET, plus current scan line. Assumes there's at least one
// edge to be moved.
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY)
{
    EDGE *pCurrentEdge = pAETHead;
    EDGE *pGETNext = pGETHead->pNext;

    do {

        // Scan through the AET until the X-sorted insertion point for this
        // edge is found. We can continue from where the last search left
        // off because the edges in the GET are in X sorted order, as is
        // the AET. The search always terminates because the AET sentinel
        // is greater than any valid X
        while (pGETNext->X > ((EDGE *)pCurrentEdge->pNext)->X) {
            pCurrentEdge = pCurrentEdge->pNext;
        }

        // We've found the insertion point; add the GET edge to the AET, and
        // remove it from the GET
        pGETHead->pNext = pGETNext->pNext;
        pGETNext->pNext = pCurrentEdge->pNext;
        pCurrentEdge->pNext = pGETNext;
        pCurrentEdge = pGETNext;    // continue insertion search for the next
                                    //  GET edge after the edge we just added
        pGETNext = pGETHead->pNext;

    } while (pGETNext->Y == iCurrentY);
}





// Build the Global Edge Table from the path. There must be enough memory in
// the free edge area to hold all edges. The GET is constructed in Y-X order,
// and has a head/tail/sentinel node at pGETHead.

BOOL ConstructGET(
   EDGE     *pGETHead,
   EDGE     *pFreeEdges,
   PATHOBJ  *ppo,
   PATHDATA *pd,
   BOOL      bMore,
   RECTL    *pClipRect)
{
   POINTFIX pfxPathStart;    // point that started the current subpath
   POINTFIX pfxPathPrevious; // point before the current point in a subpath;
                              //  starts the current edge

/* Create an empty GET with the head node also a tail sentinel */

   pGETHead->pNext = pGETHead; // mark that the GET is empty
   pGETHead->Y = 0x7FFFFFFF;   // this is greater than any valid Y value, so
                                //  searches will always terminate

/* PATHOBJ_vEnumStart is implicitly  performed  by  engine
   already and first path  is  enumerated  by  the  caller */

next_subpath:

/* Make sure the PATHDATA is not empty (is this necessary) */

   if (pd->count != 0) {

   /* If first point starts a subpath, remember it as such
      and go on to the next point,   so we can get an edge */

      if (pd->flags & PD_BEGINSUBPATH) {

      /* the first point starts the subpath;   remember it */


         pfxPathStart    = *pd->pptfx; /* the subpath starts here          */
         pfxPathPrevious = *pd->pptfx; /* this points starts the next edge */
         pd->pptfx++;                  /* advance to the next point        */
         pd->count--;                  /* count off this point             */
      }


   /* add edges in PATHDATA to GET,  in Y-X  sorted  order */

      while (pd->count--) {
        if ((pFreeEdges =
            AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious, pd->pptfx,
                         pClipRect)) == NULL) {
            goto ReturnFalse;
        }
        pfxPathPrevious = *pd->pptfx; /* current point becomes previous   */
        pd->pptfx++;                  /* advance to the next point        */
      }


   /* If last point ends the subpath, insert the edge that
      connects to first point  (is this built in already?) */

      if (pd->flags & PD_ENDSUBPATH) {
         if ((pFreeEdges = AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious,
                                   &pfxPathStart, pClipRect)) == NULL) {
            goto ReturnFalse;
        }
      }
   }

/* the initial loop conditions preclude a do, while or for */

   if (bMore) {
       bMore = PATHOBJ_bEnum(ppo, pd);
       goto next_subpath;
   }

    return(TRUE);   // done successfully

ReturnFalse:
    return(FALSE);  // failed
}

// Adds the edge described by the two passed-in points to the Global Edge
// Table, if the edge spans at least one pixel vertically.
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge,
        POINTFIX *ppfxEdgeStart, POINTFIX *ppfxEdgeEnd, RECTL *pClipRect)
{
    INT iYStart, iYEnd, iXStart, iXEnd, iYHeight, iXWidth;
    INT yJump, yTop;

    // Set the winding-rule direction of the edge, and put the endpoints in
    // top-to-bottom order
    iYHeight = ppfxEdgeEnd->y - ppfxEdgeStart->y;
    if (iYHeight == 0) {
        return(pFreeEdge);  // zero height; ignore this edge
    } else if (iYHeight >= 0) {
        iXStart = ppfxEdgeStart->x;
        iYStart = ppfxEdgeStart->y;
        iXEnd = ppfxEdgeEnd->x;
        iYEnd = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = 1;
    } else {
        iYHeight = -iYHeight;
        iXEnd = ppfxEdgeStart->x;
        iYEnd = ppfxEdgeStart->y;
        iXStart = ppfxEdgeEnd->x;
        iYStart = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = -1;
    }

    if (iYHeight & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    // Set the error term and adjustment factors, all in GIQ coordinates for
    // now
    iXWidth = iXEnd - iXStart;
    if (iXWidth >= 0) {
        // Left to right, so we change X as soon as we move at all
        pFreeEdge->iXDirection = 1;
        pFreeEdge->iErrorTerm = -1;
    } else {
        // Right to left, so we don't change X until we've moved a full GIQ
        // coordinate
        iXWidth = -iXWidth;
        pFreeEdge->iXDirection = -1;
        pFreeEdge->iErrorTerm = -iYHeight;
    }

    if (iXWidth & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    if (iXWidth >= iYHeight) {
        // Calculate base run length (minimum distance advanced in X for a 1-
        // scan advance in Y)
        pFreeEdge->iXWhole = iXWidth / iYHeight;
        // Add sign back into base run length if going right to left
        if (pFreeEdge->iXDirection == -1) {
            pFreeEdge->iXWhole = -pFreeEdge->iXWhole;
        }
        pFreeEdge->iErrorAdjustUp = iXWidth % iYHeight;
    } else {
        // Base run length is 0, because line is closer to vertical than
        // horizontal
        pFreeEdge->iXWhole = 0;
        pFreeEdge->iErrorAdjustUp = iXWidth;
    }
    pFreeEdge->iErrorAdjustDown = iYHeight;

    // Calculate the number of pixels spanned by this edge, accounting for
    // clipping

    // Top true pixel scan in GIQ coordinates
    // Shifting to divide and multiply by 16 is okay because the clip rect
    // always contains positive numbers
    yTop = max(pClipRect->top << 4, (iYStart + 15) & ~0x0F);
    pFreeEdge->Y = yTop >> 4;    // initial scan line on which to fill edge

    // Calculate # of scans to actually fill, accounting for clipping
    if ((pFreeEdge->iScansLeft = min(pClipRect->bottom, ((iYEnd + 15) >> 4))
            - pFreeEdge->Y) <= 0) {

        return(pFreeEdge);  // no pixels at all are spanned, so we can
                            // ignore this edge
    }

    // If the edge doesn't start on a pixel scan (that is, it starts at a
    // fractional GIQ coordinate), advance it to the first pixel scan it
    // intersects. Ditto if there's top clipping. Also clip to the bottom if
    // needed

    if (iYStart != yTop) {
        // Jump ahead by the Y distance in GIQ coordinates to the first pixel
        // to draw
        yJump = yTop - iYStart;

        // Advance x the minimum amount for the number of scans traversed
        iXStart += pFreeEdge->iXWhole * yJump;

        AdjustErrorTerm(&pFreeEdge->iErrorTerm, pFreeEdge->iErrorAdjustUp,
                        pFreeEdge->iErrorAdjustDown, yJump, &iXStart,
                        pFreeEdge->iXDirection);
    }
    // Turn the calculations into pixel rather than GIQ calculations

    // Move the X coordinate to the nearest pixel, and adjust the error term
    // accordingly
    // Dividing by 16 with a shift is okay because X is always positive
    pFreeEdge->X = (iXStart + 15) >> 4; // convert from GIQ to pixel coordinates

    // LATER adjust only if needed (if prestepped above)?
    if (pFreeEdge->iXDirection == 1) {
        // Left to right
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                (((iXStart + 15) & ~0x0F) - iXStart);
    } else {
        // Right to left
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                ((iXStart - 1) & 0x0F);
    }

    // Scale the error term down 16 times to switch from GIQ to pixels.
    // Shifts work to do the multiplying because these values are always
    // non-negative
    pFreeEdge->iErrorTerm >>= 4;

    // Insert the edge into the GET in YX-sorted order. The search always ends
    // because the GET has a sentinel with a greater-than-possible Y value
    while ((pFreeEdge->Y > ((EDGE *)pGETHead->pNext)->Y) ||
            ((pFreeEdge->Y == ((EDGE *)pGETHead->pNext)->Y) &&
            (pFreeEdge->X > ((EDGE *)pGETHead->pNext)->X))) {
        pGETHead = pGETHead->pNext;
    }

    pFreeEdge->pNext = pGETHead->pNext; // link the edge into the GET
    pGETHead->pNext = pFreeEdge;

    return(++pFreeEdge);    // point to the next edge storage location for next
                            //  time
}

// Adjust the error term for a skip ahead in y. This is in ASM because there's
// a multiply/divide that may involve a larger than 32-bit value.

void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection)
{
#if defined(_X86_) || defined(i386)
    // Adjust the error term up by the number of y coordinates we'll skip
    //*pErrorTerm += iErrorAdjustUp * yJump;
    _asm    mov ebx,pErrorTerm
    _asm    mov eax,iErrorAdjustUp
    _asm    mul yJump
    _asm    add eax,[ebx]
    _asm    adc edx,-1      // the error term starts out negative

    // See if the error term turned over even once while skipping
    //if (*pErrorTerm >= 0) {
    _asm    js  short NoErrorTurnover

        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        // NumAdjustDowns = (*pErrorTerm / iErrorAdjustDown) + 1;
        _asm    div iErrorAdjustDown
        _asm    inc eax
        // Note that EDX is the remainder; (EDX - iErrorAdjustDown) is where
        // the error term ends up ultimately

        // Advance x appropriately for the # of times the error term
        // turned over
        // if (iXDirection == 1) {
        //     *pXStart += NumAdjustDowns;
        // } else {
        //     *pXStart -= NumAdjustDowns;
        // }
        _asm    mov ecx,pXStart
        _asm    cmp iXDirection,1
        _asm    jz  short GoingRight
        _asm    neg eax
GoingRight:
        _asm    add [ecx],eax

        // Adjust the error term down to its proper post-skip value
        // *pErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
        _asm    sub edx,iErrorAdjustDown
        _asm    mov eax,edx     // put into EAX for storing to pErrorTerm next
        // }
NoErrorTurnover:
        _asm    mov [ebx],eax
#else
    LONGLONG llErrorTerm;
    INT NumAdjustDowns;

    llErrorTerm = *pErrorTerm;

    // Adjust the error term up by the number of y coordinates we'll skip
    llErrorTerm += Int32x32To64(iErrorAdjustUp,yJump);

    // See if the error term turned over even once while skipping
    if (llErrorTerm >= 0) {
        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        NumAdjustDowns = (UInt64Div32To32(llErrorTerm,iErrorAdjustDown)) + 1;

        // Advance x appropriately for the # of times the error term
        // turned over
        if (iXDirection == 1) {
            *pXStart += NumAdjustDowns;
        } else {
            *pXStart -= NumAdjustDowns;
        }

        // Adjust the error term down to its proper post-skip value
        llErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
    }

    *pErrorTerm = (INT) llErrorTerm;
#endif
}

//--------------------------------------------------------------------------//
//                                                                          //
//  bSetMask()                                                              //
//  Used by DrvFillPath //
//  to setup the chip to use the current mask.                      //
//  We don't set the BLTDEF register directly here.  We set a local copy,   //
//  which the calling routine will further modify befor writing it to       //
//  the chip.                                                               //
//                                                                          //
//--------------------------------------------------------------------------//
BOOL bSetMask(
         PPDEV  ppdev,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    ULONG  *bltdef)
{
    PRBRUSH pRbrush = 0;
    USHORT patoff_x, patoff_y;

    DISPDBG((FILLPATH_DBG_LEVEL, "bSetMask - Entry\n"));

         // Guard against a solid brush (pen) in case the caller didn't
         if ((pbo ==NULL) || (pbo->iSolidColor != -1))
                 {
                 RIP("bSetMask - solid mask!\n");
                 *bltdef |= BD_OP1_IS_SRAM_MONO;
                 REQUIRE(4);
                 LL_FGCOLOR(0xFFFFFFFF, 2);  // totally
                 LL_BGCOLOR(0xFFFFFFFF, 2);      // foreground
                 return (TRUE);
                 }
    else if (pbo->pvRbrush != NULL)
            {
                pRbrush = pbo->pvRbrush;
        }
    else
    {
                pRbrush = BRUSHOBJ_pvGetRbrush(pbo);
                // Fail if we do not handle the brush.

                if (pRbrush == NULL)
                                {
                           DISPDBG((FILLPATH_DBG_LEVEL, "pRbrush is NULL\n"));
            return (FALSE);
                           }
    }

    //
    // Set pattern offset.
    // NT specifies patttern offset as which pixel on the screen to align
    // with pattern(0,0).  Laguna specifies pattern offset as which pixel
    // of the pattern to align with screen(0,0).  Only the lowest three
    // bits are significant, so we can ignore any overflow when converting.
    // Also, even though PATOFF is a reg_16, we can't do byte wide writes
    // to it.  We have to write both PATOFF.pt.X and PATOFF.pt.Y in a single
    // 16 bit write.
    //
#if 1 //#1244
        patoff_x = (USHORT)(-(pptlBrush->x + ppdev->ptlOffset.x) & 7);
        patoff_y = (USHORT)(-(pptlBrush->y + ppdev->ptlOffset.y) & 7);
#else
    patoff_x = 8 - (BYTE)(pptlBrush->x & 0x07);
    patoff_y = 8 - (BYTE)(pptlBrush->y & 0x07);
#endif
        REQUIRE(1);
    LL16 (grPATOFF.w, ((patoff_y << 8) | patoff_x ));

        //
        // What kind of brush is it?
        //
        if (pRbrush->iType == BRUSH_MONO) // Monochrome brush.
        {
                DISPDBG((FILLPATH_DBG_LEVEL, "bSetMask: Using monochrome brush.\n"));
                #define mb ((MC_ENTRY*)(((BYTE*)ppdev->Mtable) + pRbrush->cache_slot))
                if (mb->iUniq != pRbrush->iUniq)
                {
                        CacheMono(ppdev, pRbrush);
                }

                // Load the fg and bg color registers.
                REQUIRE(6);
                LL_FGCOLOR(0xFFFFFFFF, 0);
                LL_BGCOLOR(0x00000000, 0);

                LL32(grOP2_opMRDRAM, pRbrush->cache_xy);
                *bltdef |= 0x00D0;
                return(TRUE);
        }
        else if (pRbrush->iType == BRUSH_4BPP) // 4-bpp brush.
        {
                DISPDBG((FILLPATH_DBG_LEVEL, "bSetMask: Using 4-bpp brush.\n"));
                #define xb ((XC_ENTRY*)(((BYTE*)ppdev->Xtable) + pRbrush->cache_slot))
                if (xb->iUniq != pRbrush->iUniq)
                {
                        Cache4BPP(ppdev, pRbrush);
                }
                REQUIRE(2);
                LL32(grOP2_opMRDRAM, pRbrush->cache_xy);
                *bltdef |= 0x0090;
                return(TRUE);
        }
        else if (pRbrush->iType == BRUSH_DITHER) // Dither brush.
        {
                DISPDBG((FILLPATH_DBG_LEVEL, "bSetMask: Using dither brush.\n"));
                #define db ((DC_ENTRY*)(((BYTE*)ppdev->Dtable) + pRbrush->cache_slot))
                if (db->ulColor != pRbrush->iUniq)
                {
                        CacheDither(ppdev, pRbrush);
                }
                REQUIRE(2);
                LL32(grOP2_opMRDRAM, pRbrush->cache_xy);
                *bltdef |= 0x0090;
                return(TRUE);
        }
        else // Color brush.
        {
                DISPDBG((FILLPATH_DBG_LEVEL, "bSetMask: Using color brush.\n"));
                #define cb ((BC_ENTRY*)(((BYTE*)ppdev->Ctable) + pRbrush->cache_slot))
                if (cb->brushID != pRbrush)
                {
                        CacheBrush(ppdev, pRbrush);
                }
                REQUIRE(2);
                LL32(grOP2_opMRDRAM, pRbrush->cache_xy);
                *bltdef |= 0x0090;
                return(TRUE);
        }

        DISPDBG((FILLPATH_DBG_LEVEL, "SetMask Ret False\n"));
    return FALSE;
}

#if LOG_CALLS

extern long lg_i;
extern char lg_buf[256];

void LogFillPath(
ULONG     acc,
PPDEV     ppdev,
SURFOBJ *pso
)
{

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    lg_i = sprintf(lg_buf,"DrvFillPath: ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    // Did we realize it?  If not, why?
    switch (acc)
    {
        case  0: lg_i = sprintf(lg_buf,"(ACCL) Id=%p", pso);             break;
        case  1: lg_i = sprintf(lg_buf,"(Punted - Too many edges) ");    break;
        case  2: lg_i = sprintf(lg_buf,"(Punted - Complex clipping) ");  break;
        case  3: lg_i = sprintf(lg_buf,"(Punted - S3) ");                break;
        case  4: lg_i = sprintf(lg_buf,"(Punted - DevBmp on host) ");    break;
        case  5: lg_i = sprintf(lg_buf,"(Punted - Failed mask) ");       break;
        case  6: lg_i = sprintf(lg_buf,"(Punted - Failed brush) ");      break;
        case  7: lg_i = sprintf(lg_buf,"(Punted - Edge table failed) "); break;
        default: lg_i = sprintf(lg_buf,"(STATUS UNKNOWN) ");             break;
    }
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    lg_i = sprintf(lg_buf,"\r\n");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\host2scn.c ===
/*============================ Module Header ==========================*\
*
* Module Name: HOST2SCN.c
* Author: Noel VanHook
* Date: Oct. 10, 1995
* Purpose: Handles HOST to SCREEN BLTs
*
* Copyright (c) 1995 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/HOST2SCN.C  $
*
*    Rev 1.7   Mar 04 1998 15:27:16   frido
* Added new shadow macros.
*
*    Rev 1.6   Nov 03 1997 15:43:52   frido
* Added REQUIRE and WRITE_STRING macros.
*
\*=====================================================================*/


#include "precomp.h"

#if BUS_MASTER

extern ULONG ulXlate[16]; // See COPYBITS.C


/*****************************************************************************\
 *                                                                                                                                                       *
 *                                                                      8 - B P P                                                                *
 *                                                                                                                                                       *
\*****************************************************************************/

/*****************************************************************************\
 * BusMasterBufferedHost8ToDevice
 *
 * This routine performs a HostToScreen or HostToDevice blit. The host data
 * can be either monochrome, 4-bpp, or 8-bpp. Color translation is supported.
 *
 * Host data is read from the host bitmap and stored in a common buffer.
 * The HOSTXY unit on the chip is used to transfer the data from the common
 * buffer to the screen.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL BusMasterBufferedHost8ToDevice(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlDest, ptlSrc;
        SIZEL  sizl;
        PPDEV  ppdev;
        PBYTE  pBits;
        LONG   lDelta, i, j, n, lLeadIn, lExtra;
        ULONG  *pulXlate;
        FLONG  flXlate;
    ULONG  CurrentBuffer,
           BufPhysAddr;
    long   ScanLinesPerBuffer,
           ScanLinesThisBuffer;
    PDWORD pHostData;

        // Calculate the source offset.
        ptlSrc.x = pptlSrc->x;
        ptlSrc.y = pptlSrc->y;

    //
    // If the destination is a device bitmap, then our destination coordinates
    // are relative the the upper left corner of the bitmap.  The chip expects
    // destination coordinates relative to to screen(0,0).
    //
        // Determine the destination type and calculate the destination offset.
    //
        if (psoTrg->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF) psoTrg->dhsurf;

                ptlDest.x = prclTrg->left + pdsurf->ptl.x;
                ptlDest.y = prclTrg->top + pdsurf->ptl.y;
                ppdev = pdsurf->ppdev;
        }
        else
        {
                ptlDest.x = prclTrg->left;
                ptlDest.y = prclTrg->top;
                ppdev = (PPDEV) psoTrg->dhpdev;
        }

        // Calculate the size of the blit.
    sizl.cx = prclTrg->right - prclTrg->left;
    sizl.cy = prclTrg->bottom - prclTrg->top;

    //
        // Get the source variables and offset into source bits.
    // point pBits at the first scan line in the source.
    //
        lDelta = psoSrc->lDelta;
        pBits = (PBYTE)psoSrc->pvScan0 + (ptlSrc.y * lDelta);

        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
                pulXlate = XLATEOBJ_piVector(pxlo);
        }
    else
    {
        // Some kind of translation we don't handle.
        return FALSE;
    }


        // -----------------------------------------------------------------------
    //
        //      Test for monochrome source.
    //
        // ------------------------------------------------------------------------
        if (psoSrc->iBitmapFormat == BMF_1BPP)
        {
                ULONG  bgColor, fgColor;
                PDWORD pHostData = (PDWORD) ppdev->pLgREGS->grHOSTDATA;

                // Set background and foreground colors.
                if (pulXlate == NULL)
                {
                        bgColor = 0x00000000;
                        fgColor = 0xFFFFFFFF;
                }
                else
                {
                        bgColor = pulXlate[0];
                        fgColor = pulXlate[1];

                        // Expand the colors.
                        bgColor |= bgColor << 8;
                        fgColor |= fgColor << 8;
                        bgColor |= bgColor << 16;
                        fgColor |= fgColor << 16;
                }

                //
                // Special case: when we are expanding monochrome sources and we
                // already have a colored brush, we must make sure the monochrome color
                // translation can be achived by setting the saturation bit (expanding
                // 0's to 0 and 1's to 1). If the monochrome source also requires color
                // translation, we simply punt this blit back to GDI.
                //
                if (ulDRAWBLTDEF & 0x00040000)
                {
                        if ( (bgColor == 0x00000000) && (fgColor == 0xFFFFFFFF) )
                        {
                                // Enable saturation for source (OP1).
                                ulDRAWBLTDEF |= 0x00008000;
                        }
                        #if SOLID_CACHE
                        else if ( ((ulDRAWBLTDEF & 0x000F0000) == 0x00070000) &&
                                          ppdev->Bcache )
                        {
                                CacheSolid(ppdev);
                                ulDRAWBLTDEF ^= (0x00070000 ^ 0x00090000);
                                REQUIRE(4);
                                LL_BGCOLOR(bgColor, 2);
                                LL_FGCOLOR(fgColor, 2);
                        }
                        #endif
                        else
                        {
                                // Punt this call to the GDI.
                                return(FALSE);
                        }
                }
                else
                {
                        REQUIRE(4);
                        LL_BGCOLOR(bgColor, 2);
                        LL_FGCOLOR(fgColor, 2);
                }

                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we must setup the source phase.
                lLeadIn = ptlSrc.x & 31;
                pBits += (ptlSrc.x >> 3) & ~3;
                n = (sizl.cx + lLeadIn + 31) >> 5;

                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                REQUIRE(10);
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 0);

                // Start the blit.
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // Copy all the bits to the screen, 32-bits at a time. We don't have to
                // worry about crossing any boundary since NT is always DWORD aligned.
                while (sizl.cy--)
                {
                        WRITE_STRING(pBits, n);
                        pBits += lDelta;
                }

                // Disable the swizzle bit in the grCONTROL register.
                ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
        }

        //      -----------------------------------------------------------------------
    //
        //      Test for 4-bpp source.
    //
        //      -----------------------------------------------------------------------
        else if (psoSrc->iBitmapFormat == BMF_4BPP)
        {
                // Calculate the source parameters. We are going to BYTE adjust the
                // source, so we also set the source phase.
                lLeadIn = ptlSrc.x & 1;
                pBits += ptlSrc.x >> 1;
                n = sizl.cx + (ptlSrc.x & 1);

                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
                lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx, lLeadIn, ptlDest.x)];

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // If there is no translation table, use the default translation table.
                if (pulXlate == NULL)
                {
                        pulXlate = ulXlate;
                }

                // Now we are ready to copy all the pixels to the hardware.
                while (sizl.cy--)
                {
                        BYTE  *p = pBits;
                        BYTE  data[4];

                        // First, we convert 4 pixels at a time to create a 32-bit value to
                        // write to the hardware.
                        for (i = n; i >= 4; i -= 4)
                        {
                                data[0] = (BYTE) pulXlate[p[0] >> 4];
                                data[1] = (BYTE) pulXlate[p[0] & 0x0F];
                                data[2] = (BYTE) pulXlate[p[1] >> 4];
                                data[3] = (BYTE) pulXlate[p[1] & 0x0F];
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], *(DWORD *)data);
                                p += 2;
                        }

                        // Now, write any remaining pixels.
                        switch (i)
                        {
                                case 1:
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], pulXlate[p[0] >> 4]);
                                        break;

                                case 2:
                                        data[0] = (BYTE) pulXlate[p[0] >> 4];
                                        data[1] = (BYTE) pulXlate[p[0] & 0x0F];
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *(DWORD *)data);
                                        break;

                                case 3:
                                        data[0] = (BYTE) pulXlate[p[0] >> 4];
                                        data[1] = (BYTE) pulXlate[p[0] & 0x0F];
                                        data[2] = (BYTE) pulXlate[p[1] >> 4];
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *(DWORD *)data);
                                        break;
                        }

                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }

                        // Next line.
                        pBits += lDelta;
                }
        }


        //      -----------------------------------------------------------------------
    //
        //      Source is in same color depth as screen (8 bpp).
    //
        //      -----------------------------------------------------------------------
        else
        {
        DISPDBG((1, " * * * * Doing bus mastered SRCCPY. * * * * \n"));

                // If we have invalid translation flags, punt the blit.
                if (flXlate & 0x10)
                        return(FALSE);


        //
        // pBits points to the first host bitmap scan line that will
        // be part of the BLT.
        // This function relies on the fact that in NT land, scanlines always
        // begin on a DWORD boundry in system memory.
        //
        ASSERTMSG( ((((ULONG)pBits) % 4) == 0),
                   "Scanline doesn't begin on a DWORD boundry.\n");

        // Now point pBits at the first host bitmap pixel to be
        // transferred to the screen.
                pBits += ptlSrc.x;   // pBits = First pixel of source bitmap.

        //
        // The Intel CPU doesn't like to transfer unaligned DWORDs.
        //
        // Just because the first pixel in a host bitmap scan line
        // is DWORD aligned, doesn't mean that the first source pixel
        // in this BLT is DWORD alinged.  We may be starting with
        // pixel 3 or something.
        // If our first pixel is in the middle of a DWORD, we need to know
        // where in the DWORD it lives.
        //   For example:
        //   If our first pixel is 0, then it lives at the start of a DWORD.
        //   If our first pixel is 3, then it lives at byte 3 in the DWORD.
        //   If our first pixel is 6, then it lives at byte 2 in the DWORD.
        //
                lLeadIn = (DWORD)pBits & 3;


        // If the first pixel of the source data doesn't fall on a
        // DWORD boundry, adjust it to the left until it does.
        // We can do this because of the ASSERT we made above.
        // We will instruct the chip to ignore the 'lead in' pixels
        // at the start of each scan line.
                pBits -= lLeadIn;


        // Now figure out how many dwords there are in each scan line.
                n = (sizl.cx + lLeadIn + 3) >> 2;


        //
        // We will split the BLT into pieces that can fit into our common
        // buffer.  We are guarenteed by the miniport that each buffer is big
        // enough to fit at least one scan line.
        //
        // One optimization is if bitmap pitch = blt width, glue the
        // scan lines together.
        //
        ScanLinesPerBuffer = ppdev->BufLength / (n*4);
        CurrentBuffer = 1;

        //
        // Now BLT the bitmap one buffer at a time.
        //

        // Enable the HOST XY unit.
        LL32(grHXY_HOST_CRTL_3D, 1);
        LL32(grHXY_BASE1_OFFSET1_3D, 0);

        // Setup the Laguna registers.
        REQUIRE(4);
        LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
        LL_OP1_MONO(lLeadIn, 0);

        while (1) // Each loop transfers one buffer.
        {
            DISPDBG((1, "    Filling buffer.\n"));

            //
            // Select the buffer we will use for this BLT.
            //
            if (CurrentBuffer)
            {
                        pHostData = (PDWORD) ppdev->Buf1VirtAddr;
                BufPhysAddr = (ULONG) ppdev->Buf1PhysAddr;
            }
            else
            {
                        pHostData = (PDWORD) ppdev->Buf2VirtAddr;
                BufPhysAddr = (ULONG) ppdev->Buf2PhysAddr;
            }


            // Is there enough bitmap left to fill an entire buffer?
            if (ScanLinesPerBuffer > sizl.cy)
                ScanLinesThisBuffer = sizl.cy; // No.
            else
                ScanLinesThisBuffer = ScanLinesPerBuffer;


            //
            // Now fill the buffer with bitmap data.
            //
            j = ScanLinesThisBuffer; // Counter for scan lines.


                // Test for color translation.
                if (pulXlate == NULL)
                    {
                            while (j--)  // Loop for each scan line.
                            {
                                // Copy all data in 32-bit. We don't have to worry about
                                // crossing any boundaries, since within NT everything is
                                // DWORD aligned.
                                #if defined(i386) && INLINE_ASM
                                        _asm
                                        {
                                                mov             edi, pHostData
                                                mov             esi, pBits
                                                mov             ecx, n
                                                rep     movsd
                                        }
                                #else
                                        for (i = 0; i < n; i++)
                                                pHostData[i] = pBits[i];
                                #endif

                                // Next line in source.
                                pBits += lDelta;

                    // Next line in buffer.
                    pHostData += n;
                        }
                }
                else
                {
                                DWORD *p;
                        while (j--)  // Loop for each scan line.
                        {
                    // p = pointer to source scan line
                                p = (DWORD *)pBits;

                    // Copy the scan line one DWORD at a time.
                                for (i = 0; i < n; i++)
                                {

                                    // We copy 4 pixels to fill an entire 32-bit DWORD.
                                        union
                                        {
                                            BYTE  byte[4];
                            DWORD dw;
                        } hostdata;

                        // Read a DWORD from the source.
                        hostdata.dw = *p++;

                        // Color convert it.
                                        hostdata.byte[0] = (BYTE) pulXlate[hostdata.byte[0]];
                                        hostdata.byte[1] = (BYTE) pulXlate[hostdata.byte[1]];
                                        hostdata.byte[2] = (BYTE) pulXlate[hostdata.byte[2]];
                                        hostdata.byte[3] = (BYTE) pulXlate[hostdata.byte[3]];

                        // Write it to the buffer.
                                        *pHostData++ =  hostdata.dw;
                                }

                                // Move to next line in source.
                                pBits += lDelta;
                        }
                }

            //
            // The common buffer is full, now BLT it.
            //

            //
            // Wait until HOST XY unit goes idle.
            //
            DISPDBG((1, "    Waiting for HOSTXY idle.\n"));
            do {
                i = LLDR_SZ (grPF_STATUS_3D);
            } while (i & 0x80);

            //
            // Wait until 2D unit goes idle.
            //
            DISPDBG((1, "    Waiting for 2D idle.\n"));
            do {
                i = LLDR_SZ (grSTATUS);
            } while (i);


            //
            // Program 2D Blitter.
            //
            DISPDBG((1, "    Blitting buffer.\n"));

                // Start the blit.
                REQUIRE(5);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, ScanLinesThisBuffer);


            //
            // Program HostXY unit.
            //

            // Write host address page.
            LL32(grHXY_BASE1_ADDRESS_PTR_3D, (BufPhysAddr&0xFFFFF000));

            // Write host address offset.
            LL32(grHXY_BASE1_OFFSET0_3D, (BufPhysAddr&0x00000FFF));


            if (0)
            {
               // Write the length of the host data (in bytes)
               // This starts the Host XY unit.
               LL32(grHXY_BASE1_LENGTH_3D, (n*ScanLinesThisBuffer*4));
            }
            else
            {
                int i;
                PDWORD BufVirtAddr;

                if (CurrentBuffer)
                    BufVirtAddr = (PDWORD) ppdev->Buf1VirtAddr;
                else
                    BufVirtAddr = (PDWORD) ppdev->Buf2VirtAddr;

                                WRITE_STRING(BufVirtAddr, n * ScanLinesThisBuffer);
            }

            //
            // Get ready to do the next buffer.
            //

            //
            // Wait until HOST XY unit goes idle.
            //
            DISPDBG((1, "    Waiting for HOSTXY idle.\n"));
            do {
                i = LLDR_SZ (grPF_STATUS_3D);
            } while (i & 0x80);

            //
            // Wait until 2D unit goes idle.
            //
            DISPDBG((1, "    Waiting for 2D idle.\n"));
            do {
                i = LLDR_SZ (grSTATUS);
            } while (i);

            //
            // Subtract the amount we're doing in this buffer from the
            // total amount we have to do.
            //
            sizl.cy -= ScanLinesThisBuffer;
            ptlDest.y += ScanLinesThisBuffer;

            //
            // Have we done the entire host bitmap?
            //
            if (sizl.cy == 0)
                break;

            DISPDBG((1, "    Swapping buffers.\n"));

            // Swap buffers.
            // CurrentBuffer = !(CurrentBuffer);
            if (CurrentBuffer)
                CurrentBuffer = 0;
            else
                CurrentBuffer = 1;


        } // End loop.  Do next buffer.

        //
        // Wait until HOST XY unit goes idle.
        //
        DISPDBG((1, "    Waiting for final idle.\n"));
        do {
                i = LLDR_SZ (grPF_STATUS_3D);
        } while (i & 0x80);

        DISPDBG((1, "    Done.\n"));
   }
   return(TRUE);
}



























#if 0

#define H2S_DBG_LEVEL    1

//
// In an attempt to trace the problems with the FIFO, we supply a few
// macros that will allow us to easily try different FIFO stratagies.
//

//
// Certian parts of our driver are optimized for the i386.
// They have slower counterparts for non i386 machines.
//
#if defined(i386)
    #define USE_DWORD_CAST       1 // i386 can address a DWORD anywhere.
    #define USE_REP_MOVSD        0 // We could use a bit of in-line assembler.
#else
    #define USE_DWORD_CAST       0
    #define USE_REP_MOVSD        0
#endif

//
// All the BLT functions take the same parameters.
//
typedef BOOL BLTFN(
        PPDEV     ppdev,
        RECTL*    DestRect,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        CLIPOBJ*  pco);


//
// Top level BLT functions.
//
BLTFN   MonoHostToScreen;
BLTFN   Color8HostToScreen, Color16HostToScreen,
        Color24HostToScreen, Color32HostToScreen;

//
// Clipping stuff
//
VOID BltClip(
        PPDEV     ppdev,
        CLIPOBJ*  pco,
        RECTL*    DestRect,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        BLTFN*    pDoBlt);

//
// Bottom level BLT functions.
//
BLTFN   HW1HostToScreen, HW8HostToScreen, HW16HostToScreen, HW32HostToScreen;

//
// 8 bpp HostToScreen helper functions.
//
VOID DoAlignedH2SBlt(
        PPDEV   ppdev,
        ULONG   ulDstX,   ULONG ulDstY,
        ULONG   ulExtX,   ULONG ulExtY,
        UCHAR   *pucData, ULONG deltaX);

VOID DoNarrowH2SBlt(
        PPDEV ppdev,
        ULONG ulDstX,     ULONG ulDstY,
        ULONG ulExtX,     ULONG ulExtY,
        UCHAR *pucImageD, ULONG deltaX);

//
// Driver profiling stuff.
// Gets compiled out in a free bulid.
// Declaring puntcode as a global violates display driver rules, but the
// emulator was chock full of globals anyway, and besides we won't ever
// release a version with this enabled.
//
#if PROFILE_DRIVER
    void DumpInfo(int acc, PPDEV ppdev, SURFOBJ* psoSrc, SURFOBJ* psoDest,
        ULONG fg_rop, ULONG bg_rop, CLIPOBJ*  pco, BRUSHOBJ* pbo,       XLATEOBJ* pxlo);
    extern int puntcode;
    #define PUNTCODE(x) puntcode = x;
#else
    #define DumpInfo(acc,ppdev,psoSrc,psoDest,fg_rop,bg_rop,pco,pbo,pxlo)
    #define PUNTCODE(x)
#endif

// *************************************************************************
//
// MonoHostToScreen()
//
//      Handles Monochrome Host to screen blts.
//      Called by op1BLT() and op1op2BLT
//      op1BLT() calls this routine with pbo = NULL.
//      op1op2BLT calls it with pbo = current brush.
//
//      This is the top level function.  This function verifies parameters,
//      and decides if we should punt or not.
//
//      The BLT is then handed off to the clipping function.  The clipping
//      function is also given a pointer to the lower level BLT function
//      HW1HostToScreen(), which will complete the clipped BLT.
//
//      This function is the last chance to decide to punt.  The clipping
//      functions and the lower level HW1HostToScreen() function aren't
//      allowed to punt.
//
//      Return TRUE if we can do the BLT,
//      Return FALSE to punt it back to GDI.
//
// *************************************************************************
BOOL MonoHostToScreen(
        PPDEV     ppdev,
        RECTL*    prclDest,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        CLIPOBJ*  pco)
{
    PULONG pulXlate;
    ULONG  fg, bg, bltdef = 0x1160;

    DISPDBG(( H2S_DBG_LEVEL,"DrvBitBlt: MonoHostToScreen Entry.\n"));

    //
    // Make sure source is a standard top-down bitmap.
    //
    if ( (psoSrc->iType != STYPE_BITMAP)     ||
         (!(psoSrc->fjBitmap & BMF_TOPDOWN))  )
        { PUNTCODE(4);    return FALSE; }

    //
    // We don't do brushes with mono src.
    //
    if (pbo)
        { PUNTCODE(7);  return FALSE; }


    //
    // Handle color translation.
    //
    if (pxlo == NULL) // Mono source requires translation.
    {
        PUNTCODE(6);
        return FALSE;
    }
    else if (pxlo->flXlate & XO_TRIVIAL)
    {
        // For trivial translation we don't need a Xlate table.
        fg = 1;
        bg = 0;
    }
    else
    {
        // Get the Xlate table.
        if (pxlo->flXlate & XO_TABLE)
                pulXlate = pxlo->pulXlate;
        else if (pxlo->iSrcType == PAL_INDEXED)
            {
                    pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle.
            return FALSE;
        }

        // Translate the colors.
            fg = ExpandColor(pulXlate[1],ppdev->ulBitCount);
        bg = ExpandColor(pulXlate[0],ppdev->ulBitCount);
    }
    REQUIRE(4);
    LL_FGCOLOR(fg, 2);
    LL_BGCOLOR(bg, 2);

    //
    // Turn swizzle on.
    //
    ppdev->grCONTROL |= SWIZ_CNTL;
         LL16(grCONTROL, ppdev->grCONTROL);

    //
    // Set function and ROP code.
    //
    LL_DRAWBLTDEF(((DWORD)bltdef << 16) | fg_rop, 2);

    //
    // Clip the BLT.
    // The clipping function will call HW1HostToScreen() to finish the BLT.
    //
    if ((pco == 0) || (pco->iDComplexity==DC_TRIVIAL))
        HW1HostToScreen(ppdev, prclDest, psoSrc, pptlSrc,
                 pbo, pptlBrush, fg_rop, pxlo, pco);
    else
        BltClip(ppdev, pco, prclDest, psoSrc, pptlSrc,
                        pbo, pptlBrush, fg_rop, pxlo, &HW1HostToScreen);

    //
    // Turn swizzle off
    //
    ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
    LL16(grCONTROL, ppdev->grCONTROL);

    return TRUE;
}




// ************************************************************************* //
//                                                                           //
// HW1HostToScreen()                                                         //
//                                                                           //
//  This function is responsible for actually talking to the chip.           //
//  At this point we are required to handle the BLT, so we must return TRUE. //
//  All decisions as to whether to punt or not must be made in the top level //
//  function MonoHostToScreen().                                             //
//                                                                           //
//  This function is called from BltClip() through a pointer set by          //
//  MonoHostToScreen().                                                      //
//                                                                           //
// ************************************************************************* //
BOOL HW1HostToScreen(
        PPDEV     ppdev,
        RECTL*    prclDest,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        CLIPOBJ*  pco)
{
    INT    x, y, i;
    INT    bltWidth, bltHeight, phase;
    PBYTE  psrc;
    DWORD hostdata;
    char *phd = (char *)&hostdata;

    DISPDBG(( H2S_DBG_LEVEL,"DrvBitBlt: HW1HostToScreen Entry.\n"));


    // Calculate BLT size in pixels.
    bltWidth  = (prclDest->right - prclDest->left);
    bltHeight = (prclDest->bottom - prclDest->top);


    //
    // Phase
    // For 1bpp sources, we must be concerned with phase.
    // Phase is the number of pixels to skip in the first dword
    // of a scan line.  For instance, if our BLT has a Src_X of 10,
    // we take our first dword starting at second byte in the src
    // scan line, and set our phase to 2 to indicate that we skip
    // the first two pixels.
    //
    phase = pptlSrc->x % 8;
    REQUIRE(7);
    LL_OP1_MONO(phase,0);

    //
    // Calculate blt width in BYTESs.
    // When calculating the number of BYTES per line, we need to
    // include the unused pixels at the start of the first BYTE
    //
    bltWidth += phase;

    // Divide bltWidth by 8 pixels per BYTE.
    // Account for extra partial BYTE if bltWidth isn't evenly
    // divisible by 8.
    bltWidth =  (bltWidth+7) / 8;

    //
    // Set psrc to point to first pixel in source.
    //
    psrc =  psoSrc->pvScan0;               // Start of surface.
    psrc += (psoSrc->lDelta * pptlSrc->y); // Start of scanline.
    psrc += (pptlSrc->x / 8);              // Starting pixel in scanline.

    // Set up the chip.
        LL_OP0 (prclDest->left, prclDest->top);
    LL_BLTEXT ((prclDest->right - prclDest->left), bltHeight);


    // For each scan line in the source rectangle.
    for (y=0; y<bltHeight; ++y)
    {
        //
        // Supply the HOSTDATA for this scan line.
        // We do this by reading it one byte at a time, and packing it into a
        // DWORD, which we write to the chip when it gets full.
        // It sound's inefficent, but a general purpose solution that
        // does only aligned DWORD accesses on both the host and the chip would
        // require lots of special casing around the first and last DWORD.
        // Combine that with the fact that most Mono-to-Color BLTS are
        // less than 2 dwords wide, and this simpler solution becomes
        // more attractive.
        //
#if 1
        WRITE_STRING(psrc, (bltWidth + 3) / 4);
#else
        i=0;        // counter to tell us when our DWORD is full.
        hostdata=0; // The DWORD we will be filling with hostdata.
                    // pdh is a char pointer that points to the start
                    // of the dword we are filling up.

        for (x=0; x<bltWidth; )   // For each byte in the scan line...
        {
          #if (USE_DWORD_CAST)
            if ( (x + 4) <= bltWidth)
            {

                REQUIRE(1);
                LL32 (grHOSTDATA[0], *(DWORD*)(&psrc[x]));
                x += 4;
            }
            else
          #endif
            {
                phd[i++] = psrc[x];  // Store this byte.

                if (i == 4) // We have a full DWORD of data, write it to the chip.
                {
                    REQUIRE(1);
                    LL32 (grHOSTDATA[0], hostdata);
                    i=0;
                    hostdata=0;
                }
                ++x;
            }
        }

        // Write the last partial DWORD.
        if (i != 0)
                REQUIRE(1);
                LL32 (grHOSTDATA[0], hostdata);
#endif

        // Move down one scanline in source.
        psrc += psoSrc->lDelta;
    }

    return TRUE;
}



// ************************************************************************* //
//                                                                           //
// Color8HostToScreen()                                                      //
//                                                                           //
//      Handles 8 bpp Host to screen blts.                                   //
//                                                                           //
//      Called by op1BLT() and op1op2BLT                                     //
//      op1BLT() calls this routine with pbo = NULL.                         //
//      op1op2BLT calls it with pbo = current brush.                         //
//                                                                           //
//      This is the top level function.  This function verifies parameters,  //
//      and decides if we should punt or not.                                //
//                                                                           //
//      The BLT is then handed off to the clipping function.  The clipping   //
//      function is also given a pointer to the lower level BLT function     //
//      HW8HostToScreen(), which will complete the clipped BLT.              //
//                                                                           //
//      This function is the last chance to decide to punt.  The clipping    //
//      functions and the lower level HW8HostToScreen() function aren't      //
//      allowed to punt.                                                     //
//                                                                           //
//      Return TRUE if we can do the BLT,                                    //
//      Return FALSE to punt it back to GDI.                                 //
//                                                                           //
//                                                                           //
// ************************************************************************* //
BOOL Color8HostToScreen(
        PPDEV     ppdev,
        RECTL*    prclDest,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        CLIPOBJ*  pco)
{
    ULONG bltdef = 0x1120; // RES=fb, OP0=fb OP1=host

    DISPDBG(( H2S_DBG_LEVEL, "DrvBitBlt: Color8HostToScreen Entry.\n"));

    //
    //  We don't handle src with a different color depth than the screen
    //
    if (psoSrc->iBitmapFormat != ppdev->iBitmapFormat)
    {
        PUNTCODE(13);
        return FALSE;
    }

    //
    // Translation type must be nothing or trivial.
    // We don't handle Xlates for color source.
    //
    if (!((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
    {
        PUNTCODE(5);
        return FALSE;
    }

    //
    // Make sure source is a standard top-down bitmap.
    //
    if ( (psoSrc->iType != STYPE_BITMAP)     ||
         (!(psoSrc->fjBitmap & BMF_TOPDOWN))  )
    {
        PUNTCODE(4);
        return FALSE;
    }

    //
    // Set up the brush if there is one.
    //
    if (pbo)
    {
        if (SetBrush(ppdev, &bltdef, pbo, pptlBrush) == FALSE)
        {
            PUNTCODE(8);
            return FALSE;
        }
    }

    //
    // Function and ROP code.
    //
    REQUIRE(1);
    LL_DRAWBLTDEF((bltdef << 16) | fg_rop, 2);

    //
    // Turn swizzle off.
    //
    ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
    LL16(grCONTROL, ppdev->grCONTROL);

    //
    // Clip the BLT.
    // The clipping function will call HW8HostToScreen() to finish the BLT.
    //
    if ((pco == 0) || (pco->iDComplexity==DC_TRIVIAL))
        HW8HostToScreen(ppdev, prclDest, psoSrc, pptlSrc,
                 pbo, pptlBrush, fg_rop, pxlo, pco);
    else
        BltClip(ppdev, pco, prclDest, psoSrc, pptlSrc,
                        pbo, pptlBrush, fg_rop, pxlo, &HW8HostToScreen);

    return (TRUE);
}


// *************************************************************************
//
// HW8HostToScreen()
//
//  This function is responsible for actually talking to the chip.
//  At this point we are required to handle the BLT, so we must return TRUE.
//  All decisions as to whether to punt or not must be made in the top level
//  function Color8HostToScreen().
//
//  This function is called from BltClip() through a pointer set by
//  Color8HostToScreen().
//
/*

    This routine does host to screen BLTs using DWORD aligned
    reads on the host whenever possible.

    The general plan is to split the BLT into up to three stripes.

    The first stripe is used if the BLT doesn't begin on a DWORD
    boundry.
    This stripe is < 1 DWORD wide and uses CHAR accesses on
    the host, and a single DWORD write to the screen, with the
    source phase set to indicated which bytes are valid.

    The second stripe is a middle stripe that both starts and ends
    on DWORD boundries.  This stripe will make up the bulk of large BLTs,
    but for narrow BLTs, it may not be used at all.

    The third stripe is used if the BLT doesn't end on a DWORD boundry.
    It is implimented much the way the first stripe is.

    One thing to consider is the scan line length of the bitmap on
    the host.  We can ignore bitmaps with an odd scan line length
    since Windows requires that all bitmaps have an even scan line
    length.  That leaves two interesting cases:

       1) Bitmaps with a scan line length that is DWORD divisable.
           (even WORD length)

       2) Bitmaps with a scan line lenght that is *not* DWORD divisable.
           (odd WORD length)

     For case one, the above plan works nicely.  It handles the host data
     one byte at a time until it reaches the first DWORD boundry, then
     it handles the data one DWORD at a time, until there is less than
     one DWORD of data left, and then handles the last couple of bytes
     one byte at a time.

     For case two, however, the plan only works for odd scan lines.
     When BLTing the large "aligned" block in the middle of the BLT,
     the odd scan lines will all align nicely on DWORD boundries,
     but the even scan lines will be "off" by one word.  While this
     is not optimal, it "almost" optimal, and is easier than an
     optimal solution, and will work even on a Power PC.

     The code looks something like this:

        if (BLT is 4 bytes wide or less)
        {
            Read host one byte at a time, pack it into DWORDS, and
            write it to the chip.
        }
        else
        {
            if (left edge of the source doesn't align to a DWORD address)
            {
                Split the BLT at the first DWORD boundry on the source.

                BLT the left part like it was an under-4-byte-wide BLT.
                    (see above)

                Adjust BLT source, destination and extents to exclude
                    the stripe just done.
            }

            //
            // Now we know that the left edge of source aligns to a
            // DWORD boundry on the host.
            //

            if (right edge of source doesn't align to a DWORD address)
            {
                Split off a stripe to the right of the last DWORD
                boundry, and use an under-4-byte-wide BLT on it.

                Adjust BLT extent to exclude the stripe just done.
            }


            //
            // Anything left over will always DWORD aligned on both edges.
            //

            if (there is any part of the BLT left over)
            {
                do an ALINGED BLT.
            }

        }

        All Done!

*/
//
// *************************************************************************

BOOL HW8HostToScreen(
        PPDEV     ppdev,
        RECTL*    prclDest,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        CLIPOBJ*  pco)
{
    PBYTE  psrc;
    DWORD *pdsrc;
    UCHAR *pucData;
    ULONG  temp, x, y,
           ulExtX, ulExtY,
           ulDstX, ulDstY;


    DISPDBG(( H2S_DBG_LEVEL, "DrvBitBlt: HW8HostToScreen Entry.\n"));

    //
    // Calculate BLT size in pixels.
    //
    ulDstX = prclDest->left;
        ulDstY = prclDest->top;
    ulExtX = (prclDest->right - prclDest->left);
    ulExtY = (prclDest->bottom - prclDest->top);


    //
    // Get the address of the upper left source pixel.
    //
    pucData =  psoSrc->pvScan0;               // Start of surface.
    pucData += (psoSrc->lDelta * pptlSrc->y); // Start of scanline.
    pucData += (pptlSrc->x * ppdev->iBytesPerPixel);  // Starting pixel.



    //
    // if the BLT is 4 or less bytes wide, just do it.
    //
    if (ulExtX <= 4)
    {
        // Do the BLT and exit.
        DoNarrowH2SBlt( ppdev,
                        ulDstX, ulDstY,
                        ulExtX, ulExtY,
                        pucData, psoSrc->lDelta);

        return TRUE;
    }


    //
    // Is the left edge DWORD aligned?
    //
    temp = ((ULONG)pucData) % 4;
    if ( temp != 0)     // No.
    {
        ULONG ulLeftStripeExtX;

        //
        // Blt the unaligned left edge.
        //
        ulLeftStripeExtX = (4 - temp);
        DoNarrowH2SBlt( ppdev,
                        ulDstX, ulDstY,
                        ulLeftStripeExtX, ulExtY,
                        pucData, psoSrc->lDelta);

        //
        // Adjust BLT parameters to exclude the part we just did.
        //
        ulDstX = ulDstX + ulLeftStripeExtX;
        ulExtX  = ulExtX  - ulLeftStripeExtX;
        pucData = pucData + ulLeftStripeExtX;

    }


    //
    // Is the right edge DWORD aligned?
    //
    temp = ((ULONG)(pucData + ulExtX)) % 4;
    if (temp != 0)                  // No.
    {
        ULONG   ulMiddleStripeExtX,
                ulRightStripeExtX,
                ulRightStripeDstX;
        UCHAR * pucRightStripeData;


        //
        // Break the BLT into a middle (aligned) stripe and a
        // right (unaligned) stripe.
        // The middle stripe could be 0 width.
        //
        ulRightStripeExtX = temp;
        ulMiddleStripeExtX = ulExtX - ulRightStripeExtX;
        ulRightStripeDstX = ulDstX + ulMiddleStripeExtX;
        pucRightStripeData = pucData + ulMiddleStripeExtX;

        //
        // BLT the right (unaligned) stripe.
        //
        DoNarrowH2SBlt( ppdev,
                        ulRightStripeDstX, ulDstY,
                        ulRightStripeExtX, ulExtY,
                        pucRightStripeData, psoSrc->lDelta);

        //
        // Adjust BLT parameters to exclude the right stripe we just did.
        //
        ulExtX = ulMiddleStripeExtX;
    }

    //
    // If anything remains, it is aligned to a DWORD boundry
    // on the HOST and is an multiple of 4 wide.
    //

    if (ulExtX != 0)
    {
        DoAlignedH2SBlt
            (ppdev, ulDstX, ulDstY, ulExtX, ulExtY, pucData, psoSrc->lDelta);
    }

    return TRUE;
}



//****************************************************************************
//
//   DoNarrowBlt()  --  Does an 8bpp BLT that is no more than 4 pixels wide
//
//****************************************************************************
VOID DoNarrowH2SBlt(
        PPDEV ppdev,
        ULONG ulDstX,
        ULONG ulDstY,
        ULONG ulExtX,
        ULONG ulExtY,
        UCHAR *pucImageD,
        ULONG deltaX)
{
    ULONG  usDataIncrement = deltaX,
           usSrcPhase = 0,
           ulY;
    UCHAR  *pucData = pucImageD;
    union
    {
        ULONG ul;
        struct
        {
            unsigned char c0;
            unsigned char c1;
            unsigned char c2;
            unsigned char c3;
        } b;
    } hostdata;

    DISPDBG(( (H2S_DBG_LEVEL), "DrvBitBlt: Entry to DoNarrowH2SBlt.\n"));

    REQUIRE(7);
    LL_OP1(usSrcPhase,0);
    LL_OP0 (ulDstX, ulDstY);
    LL_BLTEXT (ulExtX, ulExtY);

    //
    // Since there are only 4 possible x extents,
    // we will handle each seperatly for maximum speed.
    //
    switch (ulExtX)
    {
        case 1:
            for (ulY = 0; ulY < ulExtY; ulY++)
            {
                #if USE_DWORD_CAST // Intel x86 can do DWORD access anywhere.
                    REQUIRE(1);
                    LL32 (grHOSTDATA[0], ((ULONG)pucData[0]) );
                #else
                    hostdata.ul = 0;
                    hostdata.b.c0 = pucData[0];
                    REQUIRE(1);
                    LL32 (grHOSTDATA[0], hostdata.ul );
                #endif

                pucData += usDataIncrement; // Move to next scan line.
            } // End for each scan line.
            break;

        case 2:
            for (ulY = 0; ulY < ulExtY; ulY++)
            {
                #if USE_DWORD_CAST // Intel x86 can do DWORD access anywhere.
                    REQUIRE(1);
                    LL32 (grHOSTDATA[0], (ULONG)(*((unsigned short *) pucData)) );
                #else
                    hostdata.ul = 0;
                    hostdata.b.c1 = pucData[1];
                    hostdata.b.c0 = pucData[0];
                    REQUIRE(1);
                    LL32 (grHOSTDATA[0], hostdata.ul );
                #endif

                pucData += usDataIncrement; // Move to next scan line.
            } // End for each scan line.
            break;

        case 3:
            for (ulY = 0; ulY < ulExtY; ulY++)
            {
                hostdata.ul = 0;
                hostdata.b.c2 = pucData[2];
                hostdata.b.c1 = pucData[1];
                hostdata.b.c0 = pucData[0];
                REQUIRE(1);
                LL32 (grHOSTDATA[0], hostdata.ul );

                pucData += usDataIncrement; // Move to next scan line.
            } // End for each scan line.
            break;

        case 4:
            for (ulY = 0; ulY < ulExtY; ulY++)
            {
                #if USE_DWORD_CAST // Intel x86 can do DWORD access anywhere.
                    REQUIRE(1);
                    LL32 (grHOSTDATA[0], (*((unsigned long *) pucData)) );
                #else
                    hostdata.b.c3 = pucData[3];
                    hostdata.b.c2 = pucData[2];
                    hostdata.b.c1 = pucData[1];
                    hostdata.b.c0 = pucData[0];
                    REQUIRE(1);
                    LL32 (grHOSTDATA[0], hostdata.ul );
                #endif

                pucData += usDataIncrement; // Move to next scan line.
            } // End for each scan line.
            break;
    } // End switch.
}





//****************************************************************************
//
// DoAlignedH2SBlt()
//
// Does an aligned 8bpp BLT.
// On entry Source will always be aligned to a DWORD boundry and
// X extent will always be a DWORD multiple.
//
//****************************************************************************

VOID DoAlignedH2SBlt(
        PPDEV   ppdev,
        ULONG   ulDstX,
        ULONG   ulDstY,
        ULONG   ulExtX,
        ULONG   ulExtY,
        UCHAR   *pucData,
        ULONG   deltaX)

{
    ULONG       ulX, ulY, i, num_extra, ulNumDwords,
                usDataIncrement, usSrcPhase;
    void *pdst = (void *)ppdev->pLgREGS->grHOSTDATA;

    DISPDBG(( (H2S_DBG_LEVEL), "DrvBitBlt: Entry to DoAlignedH2SBlt.\n"));

    ulNumDwords = ulExtX / 4;
    usDataIncrement = deltaX;
    usSrcPhase = 0;


    //
    // We have a bug in the chip that causes it to require extra data under
    // certian conditions.  We use a look-up table to see how much extra
    // data this BLT will require for each scanline.
    //
    i = MAKE_HD_INDEX(ulExtX, usSrcPhase, ulDstX);
    num_extra =  ExtraDwordTable [i];


    //
    // Set up the chip.
    //
    REQUIRE(7);
    LL_OP1 (usSrcPhase,0);
    LL_OP0 (ulDstX, ulDstY);
    LL_BLTEXT (ulExtX, ulExtY);


    //
    // Supply the HOSTDATA.
    // We keep the decision about whether we have to work
    // around the HOSTDATA bug *outside* of the loop, even though
    // that means keeping two copies of it.
    //

    if (num_extra) // Do we have to deal with the HostData bug?
    {
        //
        // Yes, append extra DWORDs to the end of each scan line.
        //

        for (ulY = 0; ulY < ulExtY; ulY++) // for each scan line.
        {
            // Write the data for this scan line.
                WRITE_STRING(pucData, ulNumDwords);

            // Write extra data to get around chip bug.
            REQUIRE(num_extra);
            for (i=0; i<num_extra; ++i)
                LL32 (grHOSTDATA[0], 0);

            // Move to next scan line.
            pucData += usDataIncrement;

        } // End for each scan line.
    }
    else
    {
        //
        // No need to worry about the HOSTDATA bug,
        // Just blast the data out there.
        //

        for (ulY = 0; ulY < ulExtY; ulY++) // for each scan line.
        {
            // Write the data for this scan line.
                WRITE_STRING(pucData, ulNumDwords);

            // Move to next scan line.
            pucData += usDataIncrement;

        } // End for each scan line.
    }
}




// ===========================================================================
//
// Color16HostToScreen
//
//      Handles 16 bpp Host to screen blts.
//
//      Called by op1BLT() and op1op2BLT
//      op1BLT() calls this routine with pbo = NULL.
//      op1op2BLT calls it with pbo = current brush.
//
//      This is the top level function.  This function verifies parameters,
//      and decides if we should punt or not.
//
//      The BLT is then handed off to the clipping function.  The clipping
//      function is also given a pointer to the lower level BLT function
//      HW16HostToScreen(), which will complete the clipped BLT.
//
//      This function is the last chance to decide to punt.  The clipping
//      functions and the lower level HW16HostToScreen() function aren't
//      allowed to punt.
//
//      Return TRUE if we can do the BLT,
//      Return FALSE to punt it back to GDI.
//
// ===========================================================================
BOOL Color16HostToScreen(
        PPDEV     ppdev,
        RECTL*    prclDest,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        CLIPOBJ*  pco)
{
    PULONG pulXlate;
    ULONG  bltdef = 0x1120; // RES=fb, OP0=fb OP1=host

    DISPDBG(( H2S_DBG_LEVEL, "DrvBitBlt: Color16HostToScreen Entry.\n"));

    //
    //  We don't handle src with a different color depth than the screen
    //
    if (psoSrc->iBitmapFormat != ppdev->iBitmapFormat)
    {
        PUNTCODE(13);
        return FALSE;
    }

    //
    // Get the source translation type.
    // We don't handle Xlates for color source.
    //
    if (!((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
    {
        PUNTCODE(5);
        return FALSE;
    }

    //
    // Make sure source is a standard top-down bitmap.
    //
    if ( (psoSrc->iType != STYPE_BITMAP)     ||
         (!(psoSrc->fjBitmap & BMF_TOPDOWN))  )
    {
        PUNTCODE(4);
        return FALSE;
    }

    //
    // Set up the brush if there is one.
    //
    if (pbo)
        if (SetBrush(ppdev, &bltdef, pbo, pptlBrush) == FALSE)
        {
            PUNTCODE(8);
            return FALSE;
        }


    //
    // Turn swizzle off.
    //
    ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
    LL16(grCONTROL, ppdev->grCONTROL);

    //
    // BLTDEF, and rop code.
    //
    REQUIRE(1);
    LL_DRAWBLTDEF((bltdef << 16) | fg_rop, 2);

    //
    // Clip the BLT.
    // The clipping function will call HW16HostToScreen() to finish the BLT.
    //
    if ((pco == 0) || (pco->iDComplexity==DC_TRIVIAL))
        HW16HostToScreen(ppdev, prclDest, psoSrc, pptlSrc,
                 pbo, pptlBrush, fg_rop, pxlo, pco);
    else
        BltClip(ppdev, pco, prclDest, psoSrc, pptlSrc,
                        pbo, pptlBrush, fg_rop, pxlo, &HW16HostToScreen);

    return TRUE;
}

// ===========================================================================
//
// HW16HostToScreen
//
//  This function is responsible for actually talking to the chip.
//  At this point we are required to handle the BLT, so we must return TRUE.
//  All decisions as to whether to punt or not must be made in the top level
//  function Color16HostToScreen().
//
//  This function is called from BltClip() through a pointer set by
//  Color16HostToScreen().                                                           //
//
//  Since scan lines are WORD aligned by GDI, that means
//  all pixels will be WORD aligned by GDI, so the only thing
//  we need to be concerned about is if there are a even or an odd
//  number of WORDS per scan line.
//
// ===========================================================================
BOOL HW16HostToScreen(
        PPDEV     ppdev,
        RECTL*    prclDest,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        CLIPOBJ*  pco)
{
    ULONG  bltWidth, bltHeight,
           x, y, i, odd,
           num_dwords, num_extra;
    PBYTE  psrc;
    DWORD *pdsrc;
    UCHAR *pucData;
    ULONG SrcPhase = 0;
    void *pHOSTDATA = (void *)ppdev->pLgREGS->grHOSTDATA;


    DISPDBG(( H2S_DBG_LEVEL, "DrvBitBlt: HW16HostToScreen Entry.\n"));

    //
    // Set psrc to point to first pixel in source.
    //
    psrc =  psoSrc->pvScan0;               // Start of surface.
    psrc += (psoSrc->lDelta * pptlSrc->y); // Start of scanline.
    psrc += (pptlSrc->x * ppdev->iBytesPerPixel);  // Starting pixel in scanline.


    //
    // Set source phase
    //
    REQUIRE(7);
    LL_OP1 (SrcPhase,0);


    //
    // Set DEST x,y
    //
    LL_OP0 (prclDest->left, prclDest->top);


    //
    // Set the X and Y extents, and do the BLT.
    // Calculate BLT size in pixels.
    //
    bltWidth = (prclDest->right - prclDest->left);
    bltHeight = (prclDest->bottom - prclDest->top);
    DISPDBG(( H2S_DBG_LEVEL, "DrvBitBlt: BLT width is %d pixels.\n",bltWidth));
    LL_BLTEXT (bltWidth, bltHeight);


    //
    // The chip has a bug in it that causes us to have to write extra HOSTDATA
    // under certian conditions.
    //
    i = MAKE_HD_INDEX((bltWidth*2), SrcPhase, (prclDest->left*2));
    num_extra =  ExtraDwordTable [i];
    DISPDBG(( H2S_DBG_LEVEL, "DrvBitBlt: BLT requires %d extra HOSTDATA writes.\n",num_extra));

    //
    // Now we supply the HOSTDATA for each scan line.
    //

    for (y=0; y<bltHeight; ++y)
    {
                WRITE_STRING(psrc, ((bltWidth + 1) / 2);

        //
        // Add any extra hostdata we need to get around the hostdata bug.
        //
        REQUIRE(num_extra);
        for (i=0; i<num_extra; ++i)
                LL32 (grHOSTDATA[0], 0);

        // Move down one scanline in source.
        psrc += psoSrc->lDelta;
    }

    return TRUE;

}







// ===========================================================================
//
// Color24HostToScreen
//
//      Handles 24 bpp Host to screen blts.
//
//      Called by op1BLT() and op1op2BLT
//      op1BLT() calls this routine with pbo = NULL.
//      op1op2BLT calls it with pbo = current brush.
//
//      This is the top level function.  This function verifies parameters,
//      and decides if we should punt or not.
//
//      The BLT is then handed off to the clipping function.  The clipping
//      function is also given a pointer to the lower level BLT function
//      HW24HostToScreen(), which will complete the clipped BLT.
//
//      This function is the last chance to decide to punt.  The clipping
//      functions and the lower level HW24HostToScreen() function aren't
//      allowed to punt.
//
//      Return TRUE if we can do the BLT,
//      Return FALSE to punt it back to GDI.
//
// ===========================================================================
BOOL Color24HostToScreen(
        PPDEV     ppdev,
        RECTL*    prclDest,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        CLIPOBJ*  pco)
{

    //
    // I'm not even going to try this.
    // I've got better things to do with my time.
    //

    DISPDBG(( H2S_DBG_LEVEL, "DrvBitBlt: Color24HostToScreen Entry.\n"));
    PUNTCODE(17);
    return FALSE;
}






// ===========================================================================
//
// Color32HostToScreen
//
//      Handles 32 bpp Host to screen blts.
//
//      Called by op1BLT() and op1op2BLT
//      op1BLT() calls this routine with pbo = NULL.
//      op1op2BLT calls it with pbo = current brush.
//
//      This is the top level function.  This function verifies parameters,
//      and decides if we should punt or not.
//
//      The BLT is then handed off to the clipping function.  The clipping
//      function is also given a pointer to the lower level BLT function
//      HW24HostToScreen(), which will complete the clipped BLT.
//
//      This function is the last chance to decide to punt.  The clipping
//      functions and the lower level HW24HostToScreen() function aren't
//      allowed to punt.
//
//      Return TRUE if we can do the BLT,
//      Return FALSE to punt it back to GDI.
//
// ===========================================================================
BOOL Color32HostToScreen(
        PPDEV     ppdev,
        RECTL*    prclDest,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        CLIPOBJ*  pco)
{
    PULONG pulXlate;
    ULONG  bltdef = 0x1120; // RES=fb, OP0=fb OP1=host

    return FALSE;     // There are some unresolved issues here.

    DISPDBG(( H2S_DBG_LEVEL, "DrvBitBlt:  Color32HostToScreen Entry.\n"));

    //
    //  We don't handle src with a different color depth than the screen
    //
    if (psoSrc->iBitmapFormat != ppdev->iBitmapFormat)
    {
        PUNTCODE(13);   return FALSE;
    }

    //
    // Get the source translation type.
    // We don't handle Xlates for color source.
    //
    if (!((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
    {
        PUNTCODE(5);    return FALSE;
    }

    //
    // Make sure source is a standard top-down bitmap.
    //
    if ( (psoSrc->iType != STYPE_BITMAP)     ||
         (!(psoSrc->fjBitmap & BMF_TOPDOWN))  )
    {
        PUNTCODE(4);    return FALSE;
    }

    //
    // Set up the brush if there is one.
    //
    if (pbo)
        if (SetBrush(ppdev, &bltdef, pbo, pptlBrush) == FALSE)
        {
            PUNTCODE(8);
            return FALSE;
        }

    //
    // Source phase.
    //
    //LL16 (grOP1_opRDRAM.pt.X, (WORD)0);
    REQUIRE(4);
    LL_OP1(0,0);

    //
    // Turn swizzle off.
    //
    ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
         LL16(grCONTROL, ppdev->grCONTROL);

    //
    // BLTDEF, and rop code.
    //
    LL_DRAWBLTDEF((bltdef << 16) | fg_rop, 2);

    //
    // Clip the BLT.
    // The clipping function will call HW16HostToScreen() to finish the BLT.
    //
    if ((pco == 0) || (pco->iDComplexity==DC_TRIVIAL))
        HW32HostToScreen(ppdev, prclDest, psoSrc, pptlSrc,
                 pbo, pptlBrush, fg_rop, pxlo, pco);
    else
        BltClip(ppdev, pco, prclDest, psoSrc, pptlSrc,
                        pbo, pptlBrush, fg_rop, pxlo, &HW32HostToScreen);

    return TRUE;
}// ===========================================================================
//
// HW32HostToScreen
//
//  This function is responsible for actually talking to the chip.
//  At this point we are required to handle the BLT, so we must return TRUE.
//  All decisions as to whether to punt or not must be made in the top level
//  function Color32HostToScreen().
//
//  This function is called from BltClip() through a pointer set by
//  Color326HostToScreen().
//
// ===========================================================================
BOOL HW32HostToScreen(
        PPDEV     ppdev,
        RECTL*    prclDest,
        SURFOBJ*  psoSrc,
        POINTL*   pptlSrc,
        BRUSHOBJ* pbo,
        POINTL*   pptlBrush,
        ULONG      fg_rop,
        XLATEOBJ* pxlo,
        CLIPOBJ*  pco)
{
    ULONG  x, y, i,
           bltWidth, bltHeight,
           num_dwords, num_extra;
    PBYTE  psrc;
    DWORD *pdsrc;
    UCHAR *pucData;
    ULONG SrcPhase = 0;
    void *pHOSTDATA = (void *)ppdev->pLgREGS->grHOSTDATA;


    DISPDBG(( H2S_DBG_LEVEL, "DrvBitBlt: HW32HostToScreen Entry.\n"));

    //
    // Set psrc to point to first pixel in source.
    //
    psrc =  psoSrc->pvScan0;               // Start of surface.
    psrc += (psoSrc->lDelta * pptlSrc->y); // Start of scanline.
    psrc += (pptlSrc->x * ppdev->iBytesPerPixel);  // Starting pixel in scanline.


    //
    // Set DEST x,y
    //
    REQUIRE(5);
    LL_OP0 (prclDest->left, prclDest->top);


    //
    // Set the X and Y extents, and do the BLT.
    // Calculate BLT size in pixels.
    //
    bltWidth = (prclDest->right - prclDest->left);
    bltHeight = (prclDest->bottom - prclDest->top);
    LL_BLTEXT (bltWidth, bltHeight);


    //
    // Now we supply the HOSTDATA.
    // 1 pixel per DWORD.  This is easy.
    //

    //
    // The chip has a bug in it that causes us to have to write extra HOSTDATA
    // under certian conditions.
    //
    i = MAKE_HD_INDEX((bltWidth*4), SrcPhase, (prclDest->left*4));
    num_extra =  ExtraDwordTable [i];
    DISPDBG(( H2S_DBG_LEVEL, "DrvBitBlt: BLT requires %d extra HOSTDATA writes.\n",num_extra));


    // Supply HOSTDATA for each scan line.
    for (y=0; y<bltHeight; ++y)
    {
                WRITE_STRING(psrc, bltWidth);


        //
        // Add any extra hostdata we need to get around the hostdata bug.
        //
        REQUIRE(num_extra);
        for (i=0; i<num_extra; ++i)
                LL32 (grHOSTDATA[0], 0);


        // Move down one scanline in source.
        psrc += psoSrc->lDelta;
    }

    return TRUE;

}

#endif // 0
#endif // BUS_MASTER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\init.c ===
/******************************Module*Header*******************************\
*
* Module Name: init.c
* Author: Goran Devic, Mark Einkauf
* Purpose: Initialize Laguna3D 3D engine
*
* Copyright (c) 1997 Cirrus Logic, Inc.
*
\**************************************************************************/

/*********************************************************************
*   Include Files
**********************************************************************/

#include "precomp.h"
#include "mcdhw.h"               


extern DWORD _InitDisplayList( PDEV *ppdev, DWORD dwListLen );

/*********************************************************************
*   Local Macros
**********************************************************************/

// Set the register and the cache in LL_State to a specific value
#define SETREG(Offset,Reg,Value) \
    *(ppdev->LL_State.pRegs + (Offset)) = ppdev->LL_State.Reg = (Value); /*inp(0x80); inp(0x80)*/

// setreg, no cache: do not cache state for this register
#define SETREG_NC(reg, value)     \
    (*(ppdev->LL_State.pRegs + reg) = value); /*inp(0x80); inp(0x80)*/

// Clears the range of registers
#define CLEAR_RANGE( StartReg, EndReg ) \
    memset( (void *)(ppdev->LL_State.pRegs + (StartReg)), 0, ((EndReg) - (StartReg)+1)*4 )
 

/*********************************************************************
*   Local Variables
**********************************************************************/


/*********************************************************************
*   Local Functions
**********************************************************************/

DWORD LL_InitLib( PDEV *ppdev )
{
    int i, j, error_code;

    // =========== REGISTER SETTINGS ==============

    // Set all 3D registers in the order
    CLEAR_RANGE( X_3D, DU_ORTHO_ADD_3D );// Clear 3D interpolators

    SETREG_NC( WIDTH1_3D, 0x10000 );    // Init polyengine reg WIDTH1_3D to 1

    CLEAR_RANGE( A_3D, DA_ORTHO_3D );   // Clear 3D interpolators

    SETREG_NC( CONTROL_MASK_3D, 0 );    // Enable writes

    SETREG_NC( CONTROL0_3D, 0 ); 

    CLEAR_RANGE( COLOR_MIN_BOUNDS_3D, COLOR_MAX_BOUNDS_3D );
    ppdev->LL_State.rColor_Min_Bounds = 0;
    ppdev->LL_State.rColor_Max_Bounds = 0;

    SETREG_NC( CONTROL1_3D, 0 );

    // Set Base0 address register:
    //  * Color buffer X offset
    //  * Color buffer location in RDRAM
    //  * Z buffer location in RDRAM
    //  * Textures in RDRAM
    //  * Pattern offset of 0
    //
    SETREG_NC( BASE0_ADDR_3D, 0 );
    
    // Set Base1 address register:
    //  * Color buffer Y offset to 0
    //  * Z buffer Y offset to 0
    //
    SETREG_NC( BASE1_ADDR_3D, 0 );

    // Set texture control register:
    //  * Texture U, V masks to 16
    //  * Texture U, V wraps
    //  * Texel mode temporarily to 0
    //  * Texel lookop to no lookup
    //  * Texture data is lighting source
    //  * Filtering disabled
    //  * Texture polarity of type 0
    //  * Texture masking diasabled
    //  * Texture mask function to Write mask
    //  * Address mux to 0
    //  * CLUT offset to 0
    //
    SETREG_NC( TX_CTL0_3D, 0 );

    SETREG_NC( TX_XYBASE_3D, 0 );
    SETREG_NC( TX_CTL1_3D, 0 );         // Set tex color bounds

#if DRIVER_5465
    // FUTURE: verify that filter set of mask_thresh=0,step_bilinear=smooth_bilinear=0,frac=0x7 is OK
    SETREG_NC( TX_CTL2_3D, (0x7 << 24) ); // Set tex color bounds and filter to true bilinear
#else // DRIVER_5465
    SETREG_NC( TX_CTL2_3D, 0);          // Set tex color bounds
#endif // DRIVER_5465

    SETREG_NC( COLOR0_3D, 0 );         
    SETREG_NC( COLOR1_3D, 0 );  
    
    // Don't write Z_Collide - will cause interrupt...        
    //SETREG_NC( Z_COLLIDE_3D, 0 );   

    CLEAR_RANGE( STATUS0_3D, PATTERN_RAM_7_3D );

    SETREG_NC( X_CLIP_3D, 0 );   
    SETREG_NC( Y_CLIP_3D, 0 );   

    SETREG_NC( TEX_SRAM_CTRL_3D, 0 );   // Set a 2D ctrl reg


    // =========== HOST XY UNIT REGISTERS ==============
    SETREG_NC( HXY_HOST_CTRL_3D, 0 );
    SETREG_NC( HXY_BASE0_ADDRESS_PTR_3D, 0 );
    SETREG_NC( HXY_BASE0_START_XY_3D, 0 ); 
    SETREG_NC( HXY_BASE0_EXTENT_XY_3D, 0 );
    SETREG_NC( HXY_BASE1_ADDRESS_PTR_3D, 0 );
    SETREG_NC( HXY_BASE1_OFFSET0_3D, 0 );
    SETREG_NC( HXY_BASE1_LENGTH_3D, 0 );

    SETREG_NC( MAILBOX0_3D, 0 ); 
    SETREG_NC( MAILBOX1_3D, 0 ); 
    SETREG_NC( MAILBOX2_3D, 0 ); 
    SETREG_NC( MAILBOX3_3D, 0 ); 

    // =========== PREFETCH UNIT REGISTERS ==============
    SETREG_NC( PF_CTRL_3D, 0);          // Disable Prefetch
    SETREG_NC( PF_BASE_ADDR_3D, 0 );    // Set prefetch base reg

    SETREG_NC( PF_INST_3D, IDLE );      // Write IDLE instruction

    SETREG_NC( PF_DEST_ADDR_3D, 0 );    // Set prefetch dest address
    SETREG_NC( PF_FB_SEG_3D, 0 );       // Set frame segment reg


    SETREG_NC( PF_STATUS_3D, 0 );       // Reset Display_List_Switch

    // FUTURE - Host Master Control hardcoded to single read/write
    #if 0
    ppdev->LL_State.fSingleRead = ppdev->LL_State.fSingleWrite = 1;

    SETREG_NC( HOST_MASTER_CTRL_3D,     // Set host master control
        (ppdev->LL_State.fSingleRead << 1) | ppdev->LL_State.fSingleWrite );
    #endif

    SETREG_NC( PF_CTRL_3D, 0x19);       // Fetch on request

    // Initialize display list (displist.c)
    //
    if( (error_code = _InitDisplayList( ppdev, SIZE_TEMP_DL )) != LL_OK )
        return( error_code );
    
    // the 4x4 pattern from LL3D - thought to be best for 3 bit dither
    ppdev->LL_State.dither_array.pat[0] = 0x04150415;
    ppdev->LL_State.dither_array.pat[1] = 0x62736273; 
    ppdev->LL_State.dither_array.pat[2] = 0x15041504; 
    ppdev->LL_State.dither_array.pat[3] = 0x73627362; 
    ppdev->LL_State.dither_array.pat[4] = 0x04150415; 
    ppdev->LL_State.dither_array.pat[5] = 0x62736273; 
    ppdev->LL_State.dither_array.pat[6] = 0x15041504; 
    ppdev->LL_State.dither_array.pat[7] = 0x73627362;

    ppdev->LL_State.dither_x_offset = 0;
    ppdev->LL_State.dither_y_offset = 0;

	ppdev->LL_State.pattern_ram_state 	= PATTERN_RAM_INVALID;

    return( LL_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\mcd.c ===
/******************************Module*Header*******************************\
* Module Name: mcd.c
*
* Main file for the Cirrus Logic 546X OpenGL MCD driver.  This file contains
* the entry points needed for an MCD driver.
*
* (based on mcd.c from NT4.0 DDK)
*
* Copyright (c) 1996 Microsoft Corporation
* Copyright (c) 1997 Cirrus Logic, Inc.
\**************************************************************************/

#include "precomp.h"
#include <excpt.h>
                                
//#define DBGBRK

// uncomment the following to force render directly to visible frame
//#define FORCE_SINGLE_BUF

#if 0   // 1 here to avoid tons of prints for each texture load
#define MCDBG_PRINT_TEX
#else
#define MCDBG_PRINT_TEX MCDBG_PRINT
#endif


#include "mcdhw.h"
#include "mcdutil.h"
#include "mcdmath.h"

BOOL MCDrvInfo(MCDSURFACE *pMCDSurface, MCDDRIVERINFO *pMCDDriverInfo)
{
    MCDBG_PRINT( "MCDrvInfo\n");

    pMCDDriverInfo->verMajor = MCD_VER_MAJOR;
    pMCDDriverInfo->verMinor = MCD_VER_MINOR;
    pMCDDriverInfo->verDriver = 0x10000;
    strcpy(pMCDDriverInfo->idStr, "Cirrus Logic 546X-Laguna3D (Cirrus Logic)");
    pMCDDriverInfo->drvMemFlags = 0; // if not 0, can't fail any part of MCDrvDraw
    pMCDDriverInfo->drvBatchMemSizeMax = 128000; // if 0, a default is used

    return TRUE;
}


#define TOTAL_PIXEL_FORMATS (2 * 2)     // double-buffers * z-buffers

// Base color pixel formats

static DRVPIXELFORMAT drvFormats[] = { {8,   3, 3, 2, 0,    5, 2, 0, 0},// best except drawpix fails
//static DRVPIXELFORMAT drvFormats[] = { {8,   3, 3, 2, 0,    0, 3, 6, 0}, // change for drawpix at 8bpp (wrong for all else)
                                       {16,  5, 5, 5, 0,   10, 5, 0, 0},
                                       {16,  5, 6, 5, 0,   11, 5, 0, 0},
                                       {24,  8, 8, 8, 0,   16, 8, 0, 0},                   
                                       {32,  8, 8, 8, 0,   16, 8, 0, 0},
                                     };


LONG MCDrvDescribePixelFormat(MCDSURFACE *pMCDSurface, LONG iPixelFormat,
                              ULONG nBytes, MCDPIXELFORMAT *pMCDPixelFormat,
                              ULONG flags)
{
    BOOL zEnabled;
    BOOL doubleBufferEnabled;
    DRVPIXELFORMAT *pDrvPixelFormat;
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;


    MCDBG_PRINT( "MCDrvDescribePixelFormat, ipixf=%d devid=%x\n",iPixelFormat,ppdev->dwLgDevID);

    // return 0 here if no support at current bpp
    if (ppdev->iBitmapFormat == BMF_24BPP) return 0;
    // PDR 10892 - IBM doesn't like how OpenGL's stealing of the palette affects desktop colors
    //  Due to MCD design, there's no way around it in 8bpp, so we won't accelerate 8bpp
    //  Note that the 8bpp support has been left intact should we ever decide to reverse this decision
    //  To enable 8bpp, just remove the following line
    if (ppdev->iBitmapFormat == BMF_8BPP) return 0;

    if (!pMCDPixelFormat) 
    {
        if (ppdev->iBitmapFormat == BMF_8BPP)
        {
            // for 8bpp, at hi-res with z enabled, it's quite possible z pitch
            // requirement will exceed pitch, and MCDrvAllocBuffers will fail
            // in that case, the CopyTexture part of mustpass.c will fail, even
            // though punted to software.  Otto Berkes of Microsoft agrees this
            // could be an acceptable WHQL failure, but MS would need to verify
            // the bug is in their code.  Until then, the following is needed
            // to pass WHQL ;(   
            // This says we don't support z buffering for hires 8bpp
            if (ppdev->cxScreen >= 1152)	// frido: this used to be >= 1280
                return (TOTAL_PIXEL_FORMATS>>1);
            else
                return TOTAL_PIXEL_FORMATS;
        }
        else
        {
            return TOTAL_PIXEL_FORMATS;
        }
    }

    
    if (iPixelFormat > TOTAL_PIXEL_FORMATS)
        return 0;

    iPixelFormat--;
        
    //     - see what possible vals for dwFlags is
    //     - looks like TOTAL_PIXEL_FORMATS is independent of color depths
    //          i.e. given a format like 332, how many permutations are supported
    //              - z, single/double, stencil, overlay, texture?
    zEnabled = iPixelFormat >= (TOTAL_PIXEL_FORMATS / 2);
    doubleBufferEnabled = (iPixelFormat % (TOTAL_PIXEL_FORMATS / 2) ) >=
                          (TOTAL_PIXEL_FORMATS / 4);


    // NOTE: PFD_ defines are in \msdev\include\wingdi.h

    pMCDPixelFormat->nSize = sizeof(MCDPIXELFORMAT);
    pMCDPixelFormat->dwFlags = PFD_SWAP_COPY;
    if (doubleBufferEnabled)
        pMCDPixelFormat->dwFlags |= PFD_DOUBLEBUFFER;
    pMCDPixelFormat->iPixelType = PFD_TYPE_RGBA;

    MCDBG_PRINT( " DPIXFMT - no early ret: ppdev->bmf=%d zen=%d dbuf=%d ppd->flg=%x\n",ppdev->iBitmapFormat,zEnabled,doubleBufferEnabled,ppdev->flGreen);

    // FUTURE: miniport only supports 888,565,indexed modes.  Need 1555 mode as well?
    // FUTURE:   also, miniport 8 bit indexed supports set nbit rgb=6 each, not 332?
    // FUTURE:   I'll use the MGA stuff which had 332 for indexed, which is same a 5464 CGL.
    // FUTURE:   See ChoosePixelFormat in Win32 SDK - input is pixel depth only (8/16/24/32)
    switch (ppdev->iBitmapFormat) {
        default:
        case BMF_8BPP:
            // Need the palette.  This will mess up the desktop, but OpenGL looks good
            pDrvPixelFormat = &drvFormats[0];
            pMCDPixelFormat->dwFlags |= (PFD_NEED_SYSTEM_PALETTE | PFD_NEED_PALETTE);
            break;
        case BMF_16BPP:
        #ifdef _5464_1555_SUPPORT
            if (ppdev->flGreen != 0x7e0)    // not 565
                pDrvPixelFormat = &drvFormats[1];
            else
        #endif //def _5464_1555_SUPPORT
                pDrvPixelFormat = &drvFormats[2];
            break;
        // NOTE: We never get this far if 24bpp                
        case BMF_32BPP:
            pDrvPixelFormat = &drvFormats[4];
            break;
    }

    pMCDPixelFormat->cColorBits  = pDrvPixelFormat->cColorBits;
    pMCDPixelFormat->cRedBits    = pDrvPixelFormat->rBits;
    pMCDPixelFormat->cGreenBits  = pDrvPixelFormat->gBits;
    pMCDPixelFormat->cBlueBits   = pDrvPixelFormat->bBits;
    pMCDPixelFormat->cAlphaBits  = pDrvPixelFormat->aBits;
    pMCDPixelFormat->cRedShift   = pDrvPixelFormat->rShift;
    pMCDPixelFormat->cGreenShift = pDrvPixelFormat->gShift;
    pMCDPixelFormat->cBlueShift  = pDrvPixelFormat->bShift;
    pMCDPixelFormat->cAlphaShift = pDrvPixelFormat->aShift;

    if (zEnabled)
    {
        pMCDPixelFormat->cDepthBits       = 16;
        pMCDPixelFormat->cDepthBufferBits = 16;
        pMCDPixelFormat->cDepthShift      = 16;
    }
    else
    {
        pMCDPixelFormat->cDepthBits       = 0;
        pMCDPixelFormat->cDepthBufferBits = 0;
        pMCDPixelFormat->cDepthShift      = 0;
    }

    // FUTURE: cl546x stencil support could be added here

    pMCDPixelFormat->cStencilBits = 0;

    pMCDPixelFormat->cOverlayPlanes = 0;
    pMCDPixelFormat->cUnderlayPlanes = 0;
    pMCDPixelFormat->dwTransparentColor = 0;

    return TOTAL_PIXEL_FORMATS;
}

BOOL MCDrvDescribeLayerPlane(MCDSURFACE *pMCDSurface,
                             LONG iPixelFormat, LONG iLayerPlane,
                             ULONG nBytes, MCDLAYERPLANE *pMCDLayerPlane,
                             ULONG flags)
{
    MCDBG_PRINT( "MCDrvDescribeLayerPlane\n");

    return FALSE;
}


LONG MCDrvSetLayerPalette(MCDSURFACE *pMCDSurface, LONG iLayerPlane,
                          BOOL bRealize, LONG cEntries, COLORREF *pcr)
{
    MCDBG_PRINT( "MCDrvSetLayerPalette\n");

    return FALSE;
}                                                                    

HDEV  MCDrvGetHdev(MCDSURFACE *pMCDSurface)
{
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;

    MCDBG_PRINT( "MCDrvGetHdev\n");

    return ppdev->hdevEng;
}


ULONG MCDrvCreateContext(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc, 
                         MCDRCINFO *pRcInfo)
{
    DEVRC *pRc;
    MCDWINDOW *pMCDWnd = pMCDSurface->pWnd;
    DEVWND *pDevWnd;
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;
    DRVPIXELFORMAT *pDrvPixelFormat;
    MCDVERTEX *pv;
    BOOL zEnabled;
    BOOL doubleBufferEnabled;
    ULONG i, maxVi;

    MCDBG_PRINT( "MCDrvCreateContext\n");

    // We only support window surfaces:

    if (! (pMCDSurface->surfaceFlags & MCDSURFACE_HWND) )
        return FALSE;

    // no support on pre-5464 devices
    if (ppdev->dwLgDevID == CL_GD5462)
        return FALSE;

    if ((pMCDRc->iPixelFormat > TOTAL_PIXEL_FORMATS) ||
        (pMCDRc->iPixelFormat < 0)) {
        MCDBG_PRINT( "MCDrvCreateContext: bad pixel format\n");
        return FALSE;
    }

    // We don't support overlay planes:

    if (pMCDRc->iLayerPlane)
        return FALSE;

    pRc = pMCDRc->pvUser = (DEVRC *)MCDAlloc(sizeof(DEVRC));

    if (!pRc) {
        MCDBG_PRINT("MCDrvCreateContext: couldn't allocate DEVRC\n");
        return FALSE;
    }

#ifdef DBGBRK
    DBGBREAKPOINT();
#endif

    zEnabled = (pMCDRc->iPixelFormat - 1) >= (TOTAL_PIXEL_FORMATS / 2);
    doubleBufferEnabled = ((pMCDRc->iPixelFormat - 1) % (TOTAL_PIXEL_FORMATS / 2) ) >=
                          (TOTAL_PIXEL_FORMATS / 4);

    pRc->zBufEnabled = zEnabled;
    pRc->backBufEnabled = doubleBufferEnabled;

    // If we're not yet tracking this window, allocate the per-window DEVWND
    // structure for maintaining per-window info such as front/back/z buffer 
    // resources:

    if (!pMCDWnd->pvUser) {
        pDevWnd = pMCDWnd->pvUser = (DEVWND *)MCDAlloc(sizeof(DEVWND));
        if (!pDevWnd) {
            MCDFree(pMCDRc->pvUser);
            pMCDRc->pvUser = NULL;
            MCDBG_PRINT("MCDrvCreateContext: couldn't allocate DEVWND");
            return FALSE;
        }
        pDevWnd->createFlags = pMCDRc->createFlags;
        pDevWnd->iPixelFormat = pMCDRc->iPixelFormat;
        // init ptrs so we know back and z buffers don't exist yet
        pDevWnd->pohZBuffer = NULL;
        pDevWnd->pohBackBuffer = NULL;
        pDevWnd->dispUnique = ppdev->iUniqueness;
    } else {

        // We already have a per-window DEVWND structure tracking this window.
        // In this case, do a sanity-check on the pixel format for this
        // context, since a window's pixel format can not change once it has been
        // set (by the first context bound to the window).  So, if the pixel
        // format for the incoming context doesn't match the current pixel 
        // format for the window, we have to fail context creation:

        pDevWnd = pMCDWnd->pvUser;

        if (pDevWnd->iPixelFormat != pMCDRc->iPixelFormat) {
            MCDFree(pMCDRc->pvUser);
            pMCDRc->pvUser = NULL;
            MCDBG_PRINT("MCDrvCreateContext: mismatched pixel formats, window = %d, context = %d",
                        pDevWnd->iPixelFormat, pMCDRc->iPixelFormat);
            return FALSE;
        }
    }

    pRc->pEnumClip = pMCDSurface->pWnd->pClip;

    // Set up our color scale values so that color components are
    // normalized to 0..7fffff

    // NOTE: MGA normalizes colors to 0..7f,ffff -> 5464 needs 0->ff,ffff

    // We also need to make sure we don't fault due to bad FL data as well...
    try {

    if (pRcInfo->redScale != (MCDFLOAT)0.0)
        pRc->rScale = (MCDFLOAT)(0xffffff) / pRcInfo->redScale;
    else
        pRc->rScale = (MCDFLOAT)0.0;

    if (pRcInfo->greenScale != (MCDFLOAT)0.0)
        pRc->gScale = (MCDFLOAT)(0xffffff) / pRcInfo->greenScale;
    else
        pRc->gScale = (MCDFLOAT)0.0;

    if (pRcInfo->blueScale != (MCDFLOAT)0.0)
        pRc->bScale = (MCDFLOAT)(0xffffff) / pRcInfo->blueScale;
    else
        pRc->bScale = (MCDFLOAT)0.0;

    if (pRcInfo->alphaScale != (MCDFLOAT)0.0)
        pRc->aScale = (MCDFLOAT)(0xffff00) / pRcInfo->alphaScale;
    else
        pRc->aScale = (MCDFLOAT)0.0;

    } except (EXCEPTION_EXECUTE_HANDLER) {

        MCDBG_PRINT("!!Exception in MCDrvCreateContext!!");
        return FALSE;
    }    

    pRc->zScale = (MCDFLOAT)65535.0;

    pRc->pickNeeded = TRUE;         // We'll definitely need to re-pick
                                    // our rendering functions
    // Initialize the pColor pointer in the clip buffer:

    for (i = 0, pv = &pRc->clipTemp[0],
         maxVi = sizeof(pRc->clipTemp) / sizeof(MCDVERTEX);
         i < maxVi; i++, pv++) {
        pv->pColor = &pv->colors[__MCD_FRONTFACE];
    }

    // Set up those rendering functions which are state-invariant:
    pRc->clipLine = __MCDClipLine;
    pRc->clipTri = __MCDClipTriangle;
    pRc->clipPoly = __MCDClipPolygon;
    pRc->doClippedPoly = __MCDDoClippedPolygon;

    pRc->viewportXAdjust = pRcInfo->viewportXAdjust;
    pRc->viewportYAdjust = pRcInfo->viewportYAdjust;

#ifdef TEST_REQ_FLAGS
    pRcInfo->requestFlags = MCDRCINFO_NOVIEWPORTADJUST |
                            MCDRCINFO_Y_LOWER_LEFT |
                            MCDRCINFO_DEVCOLORSCALE |
                            MCDRCINFO_DEVZSCALE;

    pRcInfo->redScale = (MCDFLOAT)1.0;
    pRcInfo->greenScale = (MCDFLOAT)1.0;
    pRcInfo->blueScale = (MCDFLOAT)1.0;
    pRcInfo->alphaScale = (MCDFLOAT)1.0;

    pRcInfo->zScale = 0.99991;
#endif

    pRc->dwControl0 = 0;
    pRc->Control0.Alpha_Mode = LL_ALPHA_INTERP;   // alpha blend and fog both use interpolated alpha
    pRc->Control0.Light_Src_Sel = LL_LIGHTING_INTERP_RGB; // use poly engine output for light source
    switch( ppdev->iBitmapFormat )
    {
        case BMF_8BPP:  pRc->Control0.Pixel_Mode = PIXEL_MODE_332;  break;
        case BMF_16BPP: pRc->Control0.Pixel_Mode = PIXEL_MODE_565;  break;
      //case BMF_24BPP: - 3d engine has no support for 24 bit 
        case BMF_32BPP: pRc->Control0.Pixel_Mode = PIXEL_MODE_A888; break;
    }

    pRc->dwTxControl0=0;
#if DRIVER_5465
    pRc->TxControl0.UV_Precision = 1;
#endif
    pRc->TxControl0.Tex_Mask_Polarity = 1;  // non-zero mask bit in texel will draw
    

    pRc->dwTxXYBase=0;
    pRc->dwColor0=0;

    SETREG_NC( CONTROL0_3D,     pRc->dwControl0 );
    SETREG_NC( TX_CTL0_3D,      pRc->dwTxControl0 );
    SETREG_NC( TX_XYBASE_3D,    pRc->dwTxXYBase );
    SETREG_NC( COLOR0_3D,       pRc->dwColor0 );         

    pRc->pLastDevWnd                    = NULL;
    pRc->pLastTexture                   = TEXTURE_NOT_LOADED;
    pRc->fNumDraws                      = (float)0.0;
    pRc->punt_front_w_windowed_z        = FALSE;
    ppdev->LL_State.pattern_ram_state   = PATTERN_RAM_INVALID;
    ppdev->pLastDevRC                   = (ULONG)NULL;
    ppdev->NumMCDContexts++;

    MCDBG_PRINT( "MCDrvCreateContext - returns successfully\n");
    return TRUE;

}


VOID FASTCALL __MCDDummyProc(DEVRC *pRc)
{
    MCDBG_PRINT( "MCDDummyProc (render support routine)\n");
}

ULONG MCDrvDeleteContext(MCDRC *pRc, DHPDEV dhpdev)
{
    PDEV *ppdev = (PDEV *)dhpdev;

    MCDBG_PRINT( "MCDrvDeleteContext, num contexts left after this delete = %d\n",ppdev->NumMCDContexts-1);

    WAIT_HW_IDLE(ppdev);

    if (pRc->pvUser) {
        MCDFree(pRc->pvUser);
        pRc->pvUser = NULL;
    }

    if (ppdev->NumMCDContexts>0) ppdev->NumMCDContexts--;

    return (ULONG)TRUE;
}


ULONG MCDrvBindContext(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc)
{
    DEVWND *pDevWnd = (DEVWND *)(pMCDSurface->pWnd->pvUser);
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;

    DEVRC *pRc = pMCDRc->pvUser;

    MCDBG_PRINT( "MCDrvBindContext\n");

    // OK, this is a new binding, so create the per-window structure and
    // set the pixel format:

    if (!pDevWnd) {

        pDevWnd = pMCDSurface->pWnd->pvUser = (DEVWND *)MCDAlloc(sizeof(DEVWND));
        if (!pDevWnd) {
            MCDBG_PRINT( "MCDrvBindContext: couldn't allocate DEVWND");
            return FALSE;
        }
        pDevWnd->createFlags = pMCDRc->createFlags;
        pDevWnd->iPixelFormat = pMCDRc->iPixelFormat;
        // init ptrs so we know back and z buffers don't exist yet
        pDevWnd->pohZBuffer = NULL;
        pDevWnd->pohBackBuffer = NULL;

        pDevWnd->dispUnique = ppdev->iUniqueness;

        return TRUE;
    }

    if (pMCDRc->iPixelFormat != pDevWnd->iPixelFormat) {
        MCDBG_PRINT( "MCDrvBindContext: tried to bind unmatched pixel formats");
        return FALSE;
    }

    // 5464 doesn't need this....
    //HWUpdateBufferPos(pMCDSurface->pWnd, pMCDSurface->pso, TRUE);

    return TRUE;
}                                                                               


ULONG MCDrvAllocBuffers(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc)
{                                                                       
    DEVRC *pRc = (DEVRC *)pMCDRc->pvUser;
    MCDWINDOW *pMCDWnd = pMCDSurface->pWnd;
    DEVWND *pDevWnd = (DEVWND *)(pMCDSurface->pWnd->pvUser);
    BOOL bZBuffer = (pDevWnd->pohZBuffer != NULL);
    BOOL bBackBuffer = (pDevWnd->pohBackBuffer != NULL);
    ULONG ret;
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;

    MCDBG_PRINT( "MCDrvAllocBuffers\n");


    // Reject the call if we've already done an allocation for this window:

    if ((bZBuffer || bBackBuffer) &&
        ((DEVWND *)pMCDWnd->pvUser)->dispUnique == GetDisplayUniqueness((PDEV *)pMCDSurface->pso->dhpdev)) {

        MCDBG_PRINT( "MCDrvAllocBuffers - realloc attempt\n");
        ret =  (bZBuffer == pRc->zBufEnabled) &&                     
               (bBackBuffer == pRc->backBufEnabled);
        MCDBG_PRINT( "MCDrvAllocBuffers ret=%d\n",ret);
        return ret;
    }

    // Update the display resolution uniqueness for this window:

    ((DEVWND *)pMCDWnd->pvUser)->dispUnique = GetDisplayUniqueness((PDEV *)pMCDSurface->pso->dhpdev);

    // indicate in DEVWND if z,back buffers wanted in case window size increase such that 
    //  re-alloc in MCDrvTrackWindow fails, and later window reduced so that buffers would fit
    //  without this, there's no way for DEVWND to remember what buffers are really wanted
    //  if some intermediate re-alloc fails.
    pDevWnd->bDesireZBuffer = pRc->zBufEnabled;
    pDevWnd->bDesireBackBuffer = pRc->backBufEnabled;

    ret = (ULONG)HWAllocResources(pMCDSurface->pWnd, pMCDSurface->pso,
                                   pRc->zBufEnabled, pRc->backBufEnabled);

    pDevWnd->dwBase0 = 0;
    pDevWnd->dwBase1 = 0;

    // setup 546x buffer pointers to z and back buffers here
    if (pRc->zBufEnabled && !pDevWnd->pohZBuffer) 
        ret=FALSE;
    else if (pRc->zBufEnabled) {
        // FUTURE: z buffer location assumed to be in RDRAM - if buffer in system, need to change setup
        // FUTURE:  see setup in LL_SetZBuffer in l3d\source\control.c

        pDevWnd->Base1.Z_Buffer_Y_Offset = pDevWnd->pohZBuffer->aligned_y >> 5;

        // MCD_QST2: if global full screen z buffer, clearing affects context established earlier.
        // MCD_QST2: IS THAT OK?
        // init z buffer to all 0xFF's, since GL z compare typically GL_LESS
        // NOTE that size is not full buffer size, since alignment restrictions may force top of 
        //    actual buffer to be down from top
        memset( ppdev->pjScreen + (pDevWnd->pohZBuffer->y * ppdev->lDeltaScreen),
                0xff, 
                ((pDevWnd->pohZBuffer->y+pDevWnd->pohZBuffer->sizey)    //size = end...
                  -pDevWnd->pohZBuffer->aligned_y)                      //       minus top...
                  * ppdev->lDeltaScreen );                              //       times pitch
    }

    if (pRc->backBufEnabled && !pDevWnd->pohBackBuffer) 
        ret=FALSE;
    else if (pRc->backBufEnabled) {

#ifndef FORCE_SINGLE_BUF
        pDevWnd->Base1.Color_Buffer_Y_Offset = pDevWnd->pohBackBuffer->aligned_y >> 5;
        pDevWnd->Base0.Color_Buffer_X_Offset = pDevWnd->pohBackBuffer->aligned_x >> 6;
#endif  // ndef FORCE_SINGLE_BUF

    }

    if (ret)
    {
        if (pDevWnd->pohBackBuffer && pDevWnd->pohZBuffer) 
        {
            // both buffers alloc'd
          	MCDBG_PRINT("FB at %x, FBlen=%x, FBhi=%x start OffSc at %x, Z offset = %x, backbuf offset = %x\n",
                 ppdev->pjScreen,ppdev->lTotalMem,ppdev->cyScreen,ppdev->pjOffScreen,
                 pDevWnd->pohZBuffer->aligned_y,pDevWnd->pohBackBuffer->aligned_y);
        }
        else if (pDevWnd->pohBackBuffer) 
        {
            // only back buffer alloc'd
          	MCDBG_PRINT("FB at %x, FBlen=%x, FBhi=%x start OffSc at %x, NO ZBUF, backbuf offset = %x\n",
                 ppdev->pjScreen,ppdev->lTotalMem,ppdev->cyScreen,ppdev->pjOffScreen,
                 pDevWnd->pohBackBuffer->aligned_y);
        }
        else if (pDevWnd->pohZBuffer) 
        {
            // only Z buffer alloc'd
          	MCDBG_PRINT("FB at %x, FBlen=%x, FBhi=%x start OffSc at %x, Z offset = %x, NO BACKBUF\n",
                 ppdev->pjScreen,ppdev->lTotalMem,ppdev->cyScreen,ppdev->pjOffScreen,
                 pDevWnd->pohZBuffer->aligned_y);
        }
        else
        {
            // no buffers alloc'd
          	MCDBG_PRINT("FB at %x, FBlen=%x, FBhi=%x start OffSc at %x, NO ZBUF , NO BACKBUF\n",
                 ppdev->pjScreen,ppdev->lTotalMem,ppdev->cyScreen,ppdev->pjOffScreen);
        }
        
        SETREG_NC( BASE0_ADDR_3D, pDevWnd->dwBase0 );   
        SETREG_NC( BASE1_ADDR_3D, pDevWnd->dwBase1 );   

        pRc->pLastDevWnd = pDevWnd;

        MCDBG_PRINT( "MCDrvAllocBuffers ret=%d\n",ret);
    }
    else
    {
        pRc->pLastDevWnd = NULL;
    }

    return ret;
}


ULONG MCDrvGetBuffers(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc,
                      MCDBUFFERS *pMCDBuffers)
{
    DEVRC *pRc = (DEVRC *)pMCDRc->pvUser;
    MCDWINDOW *pMCDWnd = pMCDSurface->pWnd;
    DEVWND *pDevWnd = (DEVWND *)(pMCDSurface->pWnd->pvUser);
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;

    MCDBG_PRINT("MCDrvGetBuffers");

    MCD_CHECK_BUFFERS_VALID(pMCDSurface, pRc, FALSE);

    pMCDBuffers->mcdFrontBuf.bufFlags = MCDBUF_ENABLED;
    pMCDBuffers->mcdFrontBuf.bufOffset =
        (pMCDWnd->clientRect.top * ppdev->lDeltaScreen) +
        (pMCDWnd->clientRect.left * ppdev->iBytesPerPixel);
    pMCDBuffers->mcdFrontBuf.bufStride = ppdev->lDeltaScreen;

    if (pDevWnd->bValidBackBuffer) {
        pMCDBuffers->mcdBackBuf.bufFlags = MCDBUF_ENABLED;

        if ((ppdev->cDoubleBufferRef == 1) || (pMCDWnd->pClip->c == 1))
            pMCDBuffers->mcdBackBuf.bufFlags |= MCDBUF_NOCLIP;
#ifndef FORCE_SINGLE_BUF
        if (ppdev->pohBackBuffer == pDevWnd->pohBackBuffer) {
            // offset from screen origin
            pMCDBuffers->mcdBackBuf.bufOffset =
                (pMCDWnd->clientRect.top * ppdev->lDeltaScreen) +
                (pMCDWnd->clientRect.left * ppdev->iBytesPerPixel) + pDevWnd->backBufferOffset;
        } else {
            // offset from window origin
            pMCDBuffers->mcdBackBuf.bufOffset =  pDevWnd->backBufferOffset;
        }
#else  // FORCE_SINGLE_BUF
        pMCDBuffers->mcdBackBuf.bufOffset = pMCDBuffers->mcdFrontBuf.bufOffset;
#endif // FORCE_SINGLE_BUF

    } else {
        pMCDBuffers->mcdBackBuf.bufFlags = 0;
    }

    pMCDBuffers->mcdBackBuf.bufStride = ppdev->lDeltaScreen;


    if (pDevWnd->bValidZBuffer) {
        pMCDBuffers->mcdDepthBuf.bufFlags = MCDBUF_ENABLED;

        if ((ppdev->cZBufferRef == 1) || (pMCDWnd->pClip->c == 1))
            pMCDBuffers->mcdDepthBuf.bufFlags |= MCDBUF_NOCLIP;

        if (ppdev->pohZBuffer == pDevWnd->pohZBuffer) {
            // offset from screen origin
            // NOTE: the mult by 2 below is because Z is always 2 byte/pix
            pMCDBuffers->mcdDepthBuf.bufOffset =
                (pMCDWnd->clientRect.top * ppdev->lDeltaScreen) +
                (pMCDWnd->clientRect.left * 2) + pDevWnd->zBufferOffset;

        } else {
            // offset from window origin
            // NOTE: the mult by 2 below is because Z is always 2 byte/pix
            pMCDBuffers->mcdDepthBuf.bufOffset = pDevWnd->zBufferOffset;
        }

    } else {
        pMCDBuffers->mcdDepthBuf.bufFlags = 0;
    }

    //NOTE: z stride same as frame stride on 546x
    pMCDBuffers->mcdDepthBuf.bufStride = ppdev->lDeltaScreen;

    return (ULONG)TRUE;
}


ULONG MCDrvSwap(MCDSURFACE *pMCDSurface, ULONG flags)
{
    MCDWINDOW *pWnd;
    ULONG cClip;
    RECTL *pClip;
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;
    DEVWND *pDevWnd = (DEVWND *)(pMCDSurface->pWnd->pvUser);

    MCDBG_PRINT("MCDrvSwap");

    pWnd = pMCDSurface->pWnd;

    // If we're not tracking this window, just return...

    if (!pWnd) {
        MCDBG_PRINT("MCDrvSwap: trying to swap an untracked window");\
        return FALSE;
    }

    if (!pDevWnd) {
        MCDBG_PRINT("MCDrvSwap: NULL buffers.");\
        return FALSE;
    }

    if (!pDevWnd->bValidBackBuffer) {
        MCDBG_PRINT("MCDrvSwap: back buffer invalid");
        return FALSE;
    }

    if (pDevWnd->dispUnique != GetDisplayUniqueness(ppdev)) {
        MCDBG_PRINT("MCDrvSwap: resolution changed but not updated");
        return FALSE;
    }

    // Just return if we have nothing to swap:
    //
    //      - no visible rectangle
    //      - per-plane swap, but none of the specified planes
    //        are supported by driver

    if (!(cClip = pWnd->pClipUnscissored->c) ||
        (flags && !(flags & MCDSWAP_MAIN_PLANE)))
        return TRUE;

#ifndef FORCE_SINGLE_BUF
    for (pClip = &pWnd->pClipUnscissored->arcl[0]; cClip; cClip--,
         pClip++)
    {
        // Do the fill:
        HW_COPY_RECT(pMCDSurface, pClip);
    }
#endif // ndef FORCE_SINGLE_BUF

    return (ULONG)TRUE;
}


ULONG MCDrvState(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc, MCDMEM *pMCDMem,
                     UCHAR *pStart, LONG length, ULONG numStates)
{ 
    DEVRC *pRc = (DEVRC *)pMCDRc->pvUser;
    MCDSTATE *pState = (MCDSTATE *)pStart;
    MCDSTATE *pStateEnd = (MCDSTATE *)(pStart + length);

    MCDBG_PRINT("MCDrvState");

    MCD_CHECK_RC(pRc);

    while (pState < pStateEnd) {

        if (((UCHAR *)pStateEnd - (UCHAR *)pState) < sizeof(MCDSTATE)) {
            MCDBG_PRINT("MCDrvState: buffer too small");
            return FALSE;
        }

        switch (pState->state) {
            case MCD_RENDER_STATE:
                if (((UCHAR *)pState + sizeof(MCDRENDERSTATE)) >
                    (UCHAR *)pStateEnd)
                    return FALSE;

                memcpy(&pRc->MCDState, &pState->stateValue,
                       sizeof(MCDRENDERSTATE));

                // Flag the fact that we need to re-pick the 
                // rendering functions:

                pRc->pickNeeded = TRUE;
                pRc->MCDState.zOffsetUnits *= (float)100.0;

                pState = (MCDSTATE *)((UCHAR *)pState + sizeof(MCDSTATE_RENDER));
                break;

            case MCD_PIXEL_STATE:
                // Not accelerated in this driver, so we can ignore this state
                // (which implies that we do not need to set the pick flag).
                // FUTURE: MCDPIXELSTATE ignored - used by MCDDraw/Read/CopyPixels
                // FUTURE: MGA doesn't accelerate - 546x may want to some day

                pState = (MCDSTATE *)((UCHAR *)pState + sizeof(MCDSTATE_PIXEL));
                break;

            case MCD_SCISSOR_RECT_STATE:
                // Not needed in this driver, so we can ignore this state
                // (which implies that we do not need to set the pick flag).
                // FUTURE: MCDSCISSORRECTSTATE ignored - not mentioned in MCD spec
                // FUTURE: MGA doesn't accelerate - 546x may want to some day???

                pState = (MCDSTATE *)((UCHAR *)pState + sizeof(MCDSTATE_SCISSOR_RECT));
                break;
    
            case MCD_TEXENV_STATE:

                if (((UCHAR *)pState + sizeof(MCDSTATE_TEXENV)) >
                    (UCHAR *)pStateEnd)
                    return FALSE;

                memcpy(&pRc->MCDTexEnvState, &pState->stateValue,
                       sizeof(MCDTEXENVSTATE));

                // Flag the fact that we need to re-pick the 
                // rendering functions:

                pRc->pickNeeded = TRUE;

                pState = (MCDSTATE *)((UCHAR *)pState + sizeof(MCDSTATE_TEXENV));
                break;
                
            default:
                MCDBG_PRINT("MCDrvState: Unrecognized state %d.", pState->state);
                return FALSE;
        }
    }

    return (ULONG)TRUE;
}


ULONG MCDrvViewport(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc,
                    MCDVIEWPORT *pMCDViewport)
{
    DEVRC *pRc = (DEVRC *)pMCDRc->pvUser;

    MCDBG_PRINT("MCDrvViewport");

    MCD_CHECK_RC(pRc);

    pRc->MCDViewport = *pMCDViewport;

    return (ULONG)TRUE;
}


VOID MCDrvTrackWindow(WNDOBJ *pWndObj, MCDWINDOW *pMCDWnd, ULONG flags)
{
    SURFOBJ *pso = pWndObj->psoOwner;
    PDEV *ppdev = (PDEV *)pso->dhpdev;

    MCDBG_PRINT( "MCDrvTrackWindow, flags=%x\n",flags);

    //
    // Note: pMCDWnd is NULL for surface notifications, so if needed
    // they should be handled before this check:
    //

    if (!pMCDWnd)
        return;

    if (!pMCDWnd->pvUser) {
        MCDBG_PRINT("MCDrvTrackWindow: NULL pDevWnd");
        return;
    }

    // MCD_QST2: should we reset more than ppdev->LL_State.pRegs at top of TrackWindow
    // MCD_QST2:        when uniqueness has changed?? - see CLMCDInit in enable.c
  	ppdev->LL_State.pRegs = (DWORD *)ppdev->pLgREGS;

    WAIT_HW_IDLE(ppdev);

    switch (flags) {
        case WOC_DELETE:

            MCDBG_PRINT("MCDrvTrackWindow: WOC_DELETE");

            // If the display resoultion has changed, the resources we had 
            // bound to the tracked window are gone, so don't try to delete
            // the back- and z-buffer resources which are no longer present:
            if (((DEVWND *)pMCDWnd->pvUser)->dispUnique == GetDisplayUniqueness((PDEV *)(pso->dhpdev)))
            {
                HWFreeResources(pMCDWnd, pso);
            }

            MCDFree((VOID *)pMCDWnd->pvUser);
            pMCDWnd->pvUser = NULL;

            break;

        case WOC_RGN_CLIENT:

            // The resources we had  bound to the tracked window have moved,
            // so update them:
            MCDBG_PRINT("MCDrvTrackWindow: WOC_RGN_CLIENT");

            {
                DEVWND *pWnd = (DEVWND *)pMCDWnd->pvUser;
                BOOL bZBuffer = pWnd->bDesireZBuffer;
                BOOL bBackBuffer = pWnd->bDesireBackBuffer;
                PDEV *ppdev = (PDEV *)pso->dhpdev;
                ULONG height = pMCDWnd->clientRect.bottom - pMCDWnd->clientRect.top;
                ULONG width = pMCDWnd->clientRect.right - pMCDWnd->clientRect.left;
                BOOL bWindowBuffer = 
                    (bZBuffer && !ppdev->pohZBuffer) ||
                    (bBackBuffer && !ppdev->pohBackBuffer);

                // If the window is using a window-sized back/z resource, we need to  
                // reallocate it if there has been a size change (or if reset)
                int need_new_resources = 
                       ((((height != pWnd->allocatedBufferHeight) ||
                          (width  != pWnd->allocatedBufferWidth)) &&
                          bWindowBuffer) || (pWnd->dispUnique != GetDisplayUniqueness(ppdev))) ? 1 : 0;

                if (need_new_resources)
                {

                    // free current resources (unless reset, in which case resources are already gone)
                    if (pWnd->dispUnique == GetDisplayUniqueness(ppdev))
                    {
                        MCDBG_PRINT("    WOC_RGN_CLIENT: freeing resources");
                        HWFreeResources(pMCDWnd, pso);
                    }
                    else
                    {
                        // recent reset, so associate new uniqueness with current window
                        pWnd->dispUnique = GetDisplayUniqueness((PDEV *)pso->dhpdev);
                    }
                
                    MCDBG_PRINT("    WOC_RGN_CLIENT: alloc'ing new resources");

                    if ( HWAllocResources(pMCDWnd, pso, bZBuffer, bBackBuffer) )
                    {
                        MCDBG_PRINT("    WOC_RGN_CLIENT: alloc of new resources WORKED");
                        // setup 546x buffer pointers to z and back buffers here
                        if (pWnd->pohZBuffer) 
                        {
                            // FUTURE: z buffer location assumed to be in RDRAM - if buffer in system, need to change setup
                            // FUTURE:  see setup in LL_SetZBuffer in l3d\source\control.c

                            pWnd->Base1.Z_Buffer_Y_Offset = pWnd->pohZBuffer->aligned_y >> 5;

                            // init z buffer to all 0xFF's, since GL z compare typically GL_LESS
                            memset( ppdev->pjScreen + (pWnd->pohZBuffer->aligned_y * ppdev->lDeltaScreen),
                                    0xff, 
                                    pWnd->pohZBuffer->sizey * ppdev->lDeltaScreen );
                        }

                        if (pWnd->pohBackBuffer) 
                        {
                    #ifndef FORCE_SINGLE_BUF
                            pWnd->Base1.Color_Buffer_Y_Offset = pWnd->pohBackBuffer->aligned_y >> 5;
                            pWnd->Base0.Color_Buffer_X_Offset = pWnd->pohBackBuffer->aligned_x >> 6;
                    #endif  // ndef FORCE_SINGLE_BUF
                        }

                        // FUTURE: MCDrvTrackWindow should set base ptrs via Host3DData port to keep sync
                        SETREG_NC( BASE0_ADDR_3D, pWnd->dwBase0 );   
                        SETREG_NC( BASE1_ADDR_3D, pWnd->dwBase1 );   
                    }
                    else
                    {
                        MCDBG_PRINT("    WOC_RGN_CLIENT: alloc of new resources FAILED");
                    }
                }
            }
            break;

        default:
            break;
    }

    return;
}

ULONG MCDrvCreateMem(MCDSURFACE *pMCDSurface, MCDMEM *pMCDMem)
{
    MCDBG_PRINT("MCDrvCreateMem");
    return (ULONG)TRUE;
}


ULONG MCDrvDeleteMem(MCDMEM *pMCDMem, DHPDEV dhpdev)
{
    MCDBG_PRINT("MCDrvDeleteMem");
    return (ULONG)TRUE;
}


#define TIME_STAMP_TEXTURE(pRc,pTexCtlBlk) pTexCtlBlk->fLastDrvDraw=pRc->fNumDraws;

#define FAIL_ALL_DRAWING    0
#define FORCE_SYNC          0


BOOL __MCDTextureSetup(PDEV *ppdev, DEVRC *pRc)
{
    MCDTEXTURESTATE *pTexState;

    if (pRc->pLastTexture->dwTxCtlBits & CLMCD_TEX_BOGUS)
    {
        MCDBG_PRINT("Attempting to use bogus texture, ret false in __MCDTextureSetup");
        return FALSE; 
    }        

    VERIFY_TEXTUREDATA_ACCESSIBLE(pRc->pLastTexture->pTex);
    VERIFY_TEXTURELEVEL_ACCESSIBLE(pRc->pLastTexture->pTex);

    pTexState= (MCDTEXTURESTATE *)&pRc->pLastTexture->pTex->pMCDTextureData->textureState;
    
    MCDFREE_PRINT("internalFormat = %x", pRc->pLastTexture->pTex->pMCDTextureData->level->internalFormat);

    if (((pTexState->minFilter == GL_NEAREST) || 
         (pTexState->minFilter == GL_LINEAR)) &&
        ((pTexState->magFilter == GL_NEAREST) ||
         (pTexState->magFilter == GL_LINEAR)))
    {
        // no filtering, or linear filtering, 5465 can do this...
    }
    else
    {
        // mipmapping - should punt on 5465
        // However, some apps use mipmapping extensively (like GLQuake) and punting
        //   mipmapping makes them run very slow.  Conformance test runs in a small
        //   window, so only punt if window small.
        // Yes, this is a bit shady, but 5466 and following will have this fixed.
        //   Nobody will likely notice the problem until the 5466 is out
        if ( (pRc->pMCDSurface->pWnd->clientRect.bottom - 
              pRc->pMCDSurface->pWnd->clientRect.top) < 110) 
        {
            return FALSE; 
        }
    }

    if ( pRc->Control0.Frame_Scaling_Enable &&
        ((pRc->MCDState.blendDst == GL_ONE_MINUS_SRC_COLOR) &&
         !pRc->pLastTexture->bNegativeMap) ||
        ((pRc->MCDState.blendDst == GL_SRC_COLOR) &&
          pRc->pLastTexture->bNegativeMap) )
    {
        // must invert the map 
        MCDFREE_PRINT("inverting map for framescaling");
        pRc->pLastTexture->bNegativeMap = !pRc->pLastTexture->bNegativeMap;

        if (pRc->pLastTexture->bNegativeMap &&
           (pRc->pLastTexture->pTex->pMCDTextureData->level->internalFormat!=GL_LUMINANCE) &&
           (pRc->pLastTexture->pTex->pMCDTextureData->level->internalFormat!=GL_LUMINANCE_ALPHA))
        {
            // FUTURE2: only LUMINANCE formats support inverted maps - should add all formats
            MCDFREE_PRINT("MCDrvDraw: negative map not supported -punt");
            // toggle back to original state - can use this texture when not frame scaling
            pRc->pLastTexture->bNegativeMap = !pRc->pLastTexture->bNegativeMap;
            return FALSE; 
        }

        pRc->pLastTexture->pohTextureMap = NULL;    // set to force reload

    }
    if (pRc->privateEnables & __MCDENABLE_TEXTUREMASKING)
    {
    #ifdef STRICT_CONFORMANCE 
    // should punt here, but GLQuake does this & nonpunt OK visually
        if (!pRc->pLastTexture->bAlphaInTexture)
        {
            MCDFREE_PRINT("MCDrvDraw: alpha test, but no alpha in texture-punt");
            return FALSE; 
        }
    #endif // def STRICT_CONFORMANCE

        // alphatest and frame scaling mutually exclusive 
        //  (for now - may be some situtations where they're enabled together)

        // masking only meaningful if texture has alpha    
        if (pRc->pLastTexture->bAlphaInTexture && !pRc->pLastTexture->bMasking )
        {
            MCDFREE_PRINT("reformat for Masking");
            pRc->pLastTexture->bMasking = TRUE;
            pRc->pLastTexture->pohTextureMap = NULL;// set to force reload
        }                                            
    }
    else if ( pRc->pLastTexture->bMasking )
    {
        // no alpha test, so reformat map if currently set for alpha test
        MCDFREE_PRINT("reformat for NON-Masking");
        pRc->pLastTexture->bMasking = FALSE;
        pRc->pLastTexture->pohTextureMap = NULL;    // set to force reload
    }

    // Null pohTexture means texture must be loaded before use
    // also - must load before setting regs, since x/y loc determined
    //  by loader must be known before registers setup.
    if (!pRc->pLastTexture->pohTextureMap)
    {
       // if load fails, punt     
       if (! __MCDLoadTexture(ppdev, pRc) ) 
       {
            MCDFREE_PRINT("MCDrvDraw: texture load failed-punt");
            return FALSE; 
       }         
    }

    // setup for new texture - punt if requirements beyond hw
    if ( ! __MCDSetTextureRegisters(pRc) )
    {
        MCDFREE_PRINT("MCDrvDraw: texture regset failed-punt");
        return FALSE; 
    }   
    
    return TRUE; 
                                                                                       
}

#if 1 // 0 here for NULL MCDrvDraw - for measuring "Upper limit" performance

ULONG MCDrvDraw(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc, MCDMEM *prxExecMem,
                UCHAR *pStart, UCHAR *pEnd)
{
    MCDCOMMAND *pCmd = (MCDCOMMAND *)pStart;
    MCDCOMMAND *pCmdNext;
    DEVRC *pRc = (DEVRC *)pMCDRc->pvUser;
    DEVWND *pDevWnd = (DEVWND *)(pMCDSurface->pWnd->pvUser);
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;
    DWORD  regtemp;

    CHOP_ROUND_ON();

    MCDBG_PRINT("MCDrvDraw");

#if TEST_3D_NO_DRAW
    CHOP_ROUND_OFF();
    return (ULONG)0;
#endif

    // Make sure we have both a valid RC and window structure:

    if (!pRc || !pDevWnd)
        goto DrawExit;

    pRc->ppdev = ppdev;

#if FAIL_ALL_DRAWING
    goto DrawExit;
#endif

    //
    // If the resolution has changed and we have not yet updated our
    // buffers, fail the call gracefully since the client won't be
    // able to perform any software simulations at this point either.
    // This applies to any of the other drawing functions as well (such
    // as spans and clears).
    //

    if (pDevWnd->dispUnique != GetDisplayUniqueness(pRc->ppdev)) {

        MCDBG_PRINT("MCDrvDraw: invalid (changed) resolution");
    
        CHOP_ROUND_OFF();
        return (ULONG)0;
    }

    if (pRc != (DEVRC *)ppdev->pLastDevRC) ContextSwitch(pRc);

    if ((pRc->zBufEnabled && !pDevWnd->bValidZBuffer) ||
        (pRc->backBufEnabled && !pDevWnd->bValidBackBuffer)) {

        MCDBG_PRINT("MCDrvDraw has invalid buffers");

        goto DrawExit;
    }

    if (pRc->pickNeeded) {
        __MCDPickRenderingFuncs(pRc, pDevWnd);
        __MCDPickClipFuncs(pRc);
        pRc->pickNeeded = FALSE;
    }

    // If we're completely clipped, return success:
    pRc->pEnumClip = pMCDSurface->pWnd->pClip;

    if (!pRc->pEnumClip->c) {
        
        CHOP_ROUND_OFF();
        if (ppdev->LL_State.pDL->pdwNext != ppdev->LL_State.pDL->pdwStartOutPtr)
        {
            // Make sure all buffered data sent 
            //(__MCDPickRenderingFuncs may have buffered control reg writes)
            _RunLaguna(ppdev,ppdev->LL_State.pDL->pdwNext);
        }

        return (ULONG)0;
    }

    // return here if we can't draw any primitives:
    if (pRc->allPrimFail) {
        goto DrawExit;
    }

    // Set these up in the device's RC so we can just pass a single pointer
    // to do everything:

    pRc->pMCDSurface = pMCDSurface;
    pRc->pMCDRc = pMCDRc;

    if ((pMCDSurface->pWnd->clientRect.left < 0) ||
        (pMCDSurface->pWnd->clientRect.top  < 0))
    {
        // primitive x or y might be negative - hw can't handle, so fail all
        goto DrawExit;
    }
    else        
    {
        int winrelative = FALSE;

        pRc->xOffset = -pRc->viewportXAdjust;
        pRc->yOffset = -pRc->viewportYAdjust;

        // if draw to back buffer, and back buffer is window-sized (not full screen)
        //  then coordinates to hardware must be relative to window origin, not
        //  relative to screen.  Clip rectangles given are always relative to screen origin,
        //  so may need to adjust.
        if ((pRc->MCDState.drawBuffer == GL_BACK) &&
            (pRc->ppdev->pohBackBuffer != pDevWnd->pohBackBuffer))
        {
            pRc->AdjClip.left  = -pMCDSurface->pWnd->clientRect.left;
            pRc->AdjClip.right = -pMCDSurface->pWnd->clientRect.left;
            pRc->AdjClip.top   = -pMCDSurface->pWnd->clientRect.top;
            pRc->AdjClip.bottom= -pMCDSurface->pWnd->clientRect.top;
            winrelative = TRUE;
        }
        else
        {
            pRc->AdjClip.left  = 0;
            pRc->AdjClip.right = 0;
            pRc->AdjClip.top   = 0;
            pRc->AdjClip.bottom= 0;

            // coordinates to hardware will be screen relative, so add window offset
            pRc->xOffset += pMCDSurface->pWnd->clientRect.left;
            pRc->yOffset += pMCDSurface->pWnd->clientRect.top;
        }

        // floating pt versions
        pRc->fxOffset = (float)((LONG)pRc->xOffset);
        pRc->fyOffset = (float)((LONG)pRc->yOffset);

        // Subtract of .5(almost) from y's before triangle
        // setup make triangles match MSFT SW exactly.
        // Can't just subtract .5 since coords could then be made
        // negative - so add 1, the subtract .5.  Starting
        // Y in triangle setup code will have 1 subtracted to offset
        pRc->fyOffset += (float)MCD_CONFORM_ADJUST - __MCD_ALMOST_HALF;

    }

    // increment the time stamp
    pRc->fNumDraws+=(float)1.0;

    pRc->pMemMin = pStart;
    pRc->pvProvoking = (MCDVERTEX *)pStart;     // bulletproofing
    pRc->pMemMax = pEnd - sizeof(MCDVERTEX);

    // warm up the hardware for drawing primitives:
    HW_INIT_DRAWING_STATE(pMCDSurface, pMCDSurface->pWnd, pRc);

    // If we have a single clipping rectangle, set it up in the hardware once
    // for this batch:
                                         
    if (pRc->pEnumClip->c == 1)
        (*pRc->HWSetupClipRect)(pRc, &pRc->pEnumClip->arcl[0]);

    // Now, loop through the commands and process the batch:
    try {

        if (!(pRc->privateEnables & (__MCDENABLE_PG_STIPPLE|__MCDENABLE_LINE_STIPPLE)))
        {
            // polygon stipple and line stipple both off

            if ((ppdev->LL_State.pattern_ram_state != DITHER_LOADED) &&
                (pRc->privateEnables & __MCDENABLE_DITHER))
            {
                DWORD *pdwNext = ppdev->LL_State.pDL->pdwNext;
                int i;

                *pdwNext++ = write_register( PATTERN_RAM_0_3D, 8 );
                for( i=0; i<8; i++ )
                    *pdwNext++ = ppdev->LL_State.dither_array.pat[i];                                                  

                ppdev->LL_State.pDL->pdwNext = pdwNext;
                ppdev->LL_State.pattern_ram_state = DITHER_LOADED;
            }

            while (pCmd && (UCHAR *)pCmd < pEnd) {

                volatile ULONG command = pCmd->command;

    	      //MCDBG_PRINT("MCDrvDraw: command = %x ",command);

                // Make sure we can read at least the command header:

                if ((pEnd - (UCHAR *)pCmd) < sizeof(MCDCOMMAND))
                    goto DrawExit;

                if (command <= GL_POLYGON) {  // simple bounds check - GL_POLYGON is max command

                    if (pCmd->flags & MCDCOMMAND_RENDER_PRIMITIVE)								 
        		    {
                        if (pRc->privateEnables & __MCDENABLE_TEXTURE)
                        {
                            if (pCmd->textureKey == TEXTURE_NOT_LOADED)
                            {
        	    		        MCDBG_PRINT("MCDrvDraw: texturing, but texture not loaded - PUNT...");
        	    		        MCDFREE_PRINT("MCDrvDraw: texturing, but texture not loaded - PUNT...");
                                goto DrawExit;
                            }
                            else
                            {
                                                    
                                // if texture different than last time, or if texture not loaded
                                //  (could have been updated since last MCDrvDraw which would have force it
                                //   to be unloaded)
                                if ( (pRc->pLastTexture != (LL_Texture *)pCmd->textureKey) ||
                                     !pRc->pLastTexture->pohTextureMap)
                                {
                                    pRc->pLastTexture = (LL_Texture *)pCmd->textureKey;
                                    TIME_STAMP_TEXTURE(pRc,pRc->pLastTexture); // time stamp before load
                                    if (!__MCDTextureSetup(ppdev, pRc)) goto DrawExit;
                                }
                                else
                                {
                                    TIME_STAMP_TEXTURE(pRc,pRc->pLastTexture);
                                }

                            }
                        }
                         
      			     // MCDBG_PRINT("MCDrvDraw: non-stippled path... rendering....");
                        pCmdNext = (*pRc->primFunc[command])(pRc, pCmd);
    				}
                    else
    				{
    			     // MCDBG_PRINT("MCDrvDraw: non-stippled path... not rendering....");
                        pCmdNext = pCmd->pNextCmd;
    				}

                    if (pCmdNext == pCmd)
                    {
                        MCDFREE_PRINT("MCDrvDraw: pCmdNext == pCmd-punt");
                        goto DrawExit;           // primitive failed
                    }
                    if (!(pCmd = pCmdNext)) {    // we're done with the batch
                        CHOP_ROUND_OFF();

                        if (ppdev->LL_State.pDL->pdwNext != ppdev->LL_State.pDL->pdwStartOutPtr)
                        {
                            // we should rarely get here - only for case of lots of 
                            // consecutive stuffed culled or clipped causing no primitives to
                            // be sent to HW - in such case, setup info, clip, context
                            // switch etc. could stack up and overflow buffer unless
                            // we make sure all is dumped here...
                            // Recall primitive render procs will dump whole queue before they return
                            _RunLaguna(ppdev,ppdev->LL_State.pDL->pdwNext);
                        }
    #if FORCE_SYNC
                        HW_WAIT_DRAWING_DONE(pRc);
    #endif
                        return (ULONG)0;
                    }
                }
            }

        }
        else
        {

            // polygon stipple AND/OR line stipple on - may need to reload pattern ram between primitives
            while (pCmd && (UCHAR *)pCmd < pEnd) {

                volatile ULONG command = pCmd->command;

    	      //MCDBG_PRINT("MCDrvDraw: command = %x ",command);

                // Make sure we can read at least the command header:

                if ((pEnd - (UCHAR *)pCmd) < sizeof(MCDCOMMAND))
                    goto DrawExit;

                if (command <= GL_POLYGON) {  // simple bounds check - GL_POLYGON is max command

                    if (pCmd->flags & MCDCOMMAND_RENDER_PRIMITIVE)								 
        		    {
                        // FUTURE: move all this pattern toggle to routine that is called indirectly
                        // FUTURE: with ptr to proc being reset by prior pattern ram load, etc.
                        LL_Pattern *Pattern=0;
                        int pat_inc = 1;
                        int pattern_bytes = 0;

                        if (command >= GL_TRIANGLES)
                        {
                            // area primitive - if stippled, may need to reload pattern  
                            if (pRc->privateEnables & __MCDENABLE_PG_STIPPLE)
                            {
                                pattern_bytes = 8;
                                if (ppdev->LL_State.pattern_ram_state != AREA_PATTERN_LOADED)
                                {
                                    ppdev->LL_State.pattern_ram_state = AREA_PATTERN_LOADED;
                                    Pattern = &(pRc->fill_pattern);
                                    // pat_inc remains 1;
                            	}
                            }
                        }
                        else
                        {
                            // line primitive - if stippled, may need to reload pattern (OK for points though don't care) 
                            if ( (pRc->privateEnables & __MCDENABLE_LINE_STIPPLE) &&
                                 (command != GL_POINTS) )
                            {
                                // fill 8 word ram with same word so we get right pattern regardless
                                // of pattern_y_offset that may be set in base0 reg for proper pg stipple
                                pattern_bytes = 8; 
                                if (ppdev->LL_State.pattern_ram_state != LINE_PATTERN_LOADED)
                                {
                                    ppdev->LL_State.pattern_ram_state = LINE_PATTERN_LOADED;
                                    Pattern = &(pRc->line_style);
                                    pat_inc = 0; // don't increment through source pattern
                                }
                            }
                        }

                        if ((ppdev->LL_State.pattern_ram_state != DITHER_LOADED) &&
                            !pattern_bytes && (pRc->privateEnables & __MCDENABLE_DITHER))
                        {
                      	    ppdev->LL_State.pattern_ram_state = DITHER_LOADED;
                            Pattern = &(ppdev->LL_State.dither_array);                                                  
                            pattern_bytes = 8;
                            // pat_inc remains 1;
                        }

                        if (Pattern)
                        {
                            DWORD *pdwNext = ppdev->LL_State.pDL->pdwNext;
                            int i;

                            *pdwNext++ = write_register( PATTERN_RAM_0_3D, pattern_bytes );
                            for( i=0; pattern_bytes>0; i+=pat_inc, pattern_bytes-- )
                                *pdwNext++ = Pattern->pat[ i ];

                            // leave data queued for now, primitive render procs will send
                            ppdev->LL_State.pDL->pdwNext = pdwNext;
                        }

                        if (pRc->privateEnables & __MCDENABLE_TEXTURE)
                        {
                            if (pCmd->textureKey == TEXTURE_NOT_LOADED)
                            {
        	    		        MCDBG_PRINT("MCDrvDraw: texturing, but texture not loaded - PUNT...");
                                goto DrawExit;
                            }
                            else
                            {
                                // if texture different than last time, or if texture not loaded
                                //  (could have been updated since last MCDrvDraw which would have force it
                                //   to be unloaded)
                                if ( (pRc->pLastTexture != (LL_Texture *)pCmd->textureKey) ||
                                     !pRc->pLastTexture->pohTextureMap)
                                {
                                    pRc->pLastTexture = (LL_Texture *)pCmd->textureKey;
                                    TIME_STAMP_TEXTURE(pRc,pRc->pLastTexture); // time stamp before load
                                    if (!__MCDTextureSetup(ppdev, pRc)) goto DrawExit;
                                }
                                else
                                {
                                    TIME_STAMP_TEXTURE(pRc,pRc->pLastTexture);
                                }


                            }
                        }

      			     // MCDBG_PRINT("MCDrvDraw: stippled path... rendering....");
                        pCmdNext = (*pRc->primFunc[command])(pRc, pCmd);
    				}
                    else
    				{
    			     // MCDBG_PRINT("MCDrvDraw: stippled path... not rendering....");
                        pCmdNext = pCmd->pNextCmd;
    				}

                    if (pCmdNext == pCmd)
                        goto DrawExit;           // primitive failed
                    if (!(pCmd = pCmdNext)) {    // we're done with the batch
                        CHOP_ROUND_OFF();

                        if (ppdev->LL_State.pDL->pdwNext != ppdev->LL_State.pDL->pdwStartOutPtr)
                        {
                            // we should rarely get here - only for case of lots of 
                            // consecutive stuffed culled or clipped causing no primitives to
                            // be sent to HW - in such case, setup info, clip, context
                            // switch etc. could stack up and overflow buffer unless
                            // we make sure all is dumped here...
                            // Recall primitive render procs will dump whole queue before they return
                            _RunLaguna(ppdev,ppdev->LL_State.pDL->pdwNext);
                        }

    #if FORCE_SYNC
                        HW_WAIT_DRAWING_DONE(pRc);
    #endif
                        return (ULONG)0;
                    }
                }
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {

        MCDBG_PRINT("!!Exception in MCDrvDraw!!");

        // will fall through to DrawExit condition below...
    }

    // ERROR (or Punt) CONDITION
DrawExit:

    MCDFREE_PRINT("*****************************************************");
    MCDFREE_PRINT("************* PUNTING in MCDrvDraw ******************");
    MCDFREE_PRINT("*****************************************************");

    if (ppdev->LL_State.pDL->pdwNext != ppdev->LL_State.pDL->pdwStartOutPtr)
    {
        // we should rarely get here - only for case of lots of 
        // consecutive stuff culls or clips causing no primitives to
        // be sent to HW - in such case, setup info, clip, context
        // switch etc. could stack up and overflow buffer unless
        // we make sure all is dumped here...
        _RunLaguna(ppdev,ppdev->LL_State.pDL->pdwNext);
    }

    // restore the hardware state:
    CHOP_ROUND_OFF();
    HW_WAIT_DRAWING_DONE(pRc);

    return (ULONG)pCmd;    // some sort of overrun has occurred
}

#else // NULL MCDrvDraw

ULONG MCDrvDraw(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc, MCDMEM *prxExecMem,
                UCHAR *pStart, UCHAR *pEnd)
{
    MCDCOMMAND *pCmd = (MCDCOMMAND *)pStart;
    MCDCOMMAND *pCmdNext;

    try {
        // Now, loop through the commands and process the batch:
        while (pCmd && (UCHAR *)pCmd < pEnd) {

            pCmdNext = pCmd->pNextCmd;

            if (!(pCmd = pCmdNext)) {    // we're done with the batch
                return (ULONG)0;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {

        MCDBG_PRINT("!!Exception in NULL Version of MCDrvDraw!!");

    }

    return (ULONG)pCmd;    // some sort of overrun has occurred
}

#endif // NULL MCDrvDraw

ULONG MCDrvClear(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc, ULONG buffers)
{
    DEVRC *pRc = (DEVRC *)pMCDRc->pvUser;
    MCDWINDOW *pWnd;
    ULONG cClip;
    RECTL *pClip;

    MCDBG_PRINT("MCDrvClear");

    MCD_CHECK_RC(pRc);

    pWnd = pMCDSurface->pWnd;

    MCD_CHECK_BUFFERS_VALID(pMCDSurface, pRc, TRUE);

    pRc->ppdev = (PDEV *)pMCDSurface->pso->dhpdev;

#if FAIL_ALL_DRAWING
    return TRUE;
#endif

    if (buffers & ~(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT |
                    GL_ACCUM_BUFFER_BIT | GL_STENCIL_BUFFER_BIT)) {
        MCDBG_PRINT("MCDrvClear: attempted to clear buffer of unknown type");
        return FALSE;
    }

    if ((buffers & GL_DEPTH_BUFFER_BIT) && (!pRc->zBufEnabled))
    {
        MCDBG_PRINT("MCDrvClear: clear z requested with z-buffer disabled.");
        HW_WAIT_DRAWING_DONE(pRc);
        return FALSE;
    }

    if (buffers & (GL_ACCUM_BUFFER_BIT | GL_STENCIL_BUFFER_BIT)) {
        MCDBG_PRINT("MCDrvClear: attempted to clear accum or stencil buffer");
        return FALSE;
    }

    // Return if we have nothing to clear:
    if (!(cClip = pWnd->pClip->c))
        return TRUE;

    // We have to protect against bad clear colors since this can
    // potentially cause an FP exception:
    try {
        for (pClip = &pWnd->pClip->arcl[0]; cClip; cClip--,
             pClip++)
        {
            // Do the fill:

            HW_FILL_RECT(pMCDSurface, pRc, pClip, buffers);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {

        MCDBG_PRINT("!!Exception in MCDrvClear!!");
        return FALSE;        
    }

#if FORCE_SYNC
    HW_WAIT_DRAWING_DONE(pRc);
#endif                                   

    return (ULONG)TRUE;
}


ULONG MCDrvSpan(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc, MCDMEM *pMCDMem,
                MCDSPAN *pMCDSpan, BOOL bRead)
{
    DEVRC *pRc = (DEVRC *)pMCDRc->pvUser;
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;
    UCHAR *pScreen;
    UCHAR *pPixels;
    MCDWINDOW *pWnd;
    DEVWND *pDevWnd;
    LONG xLeftOrg, xLeft, xRight, y;
    LONG bufferYBias;
    ULONG bytesNeeded;
    ULONG cjHwPel;
    int  winoffset = FALSE;

    MCD_CHECK_RC(pRc);

    pWnd = pMCDSurface->pWnd;

    // Return if we have nothing to clip:

    if (!pWnd->pClip->c)
        return TRUE;

    // Fail if number of pixels is negative:

    if (pMCDSpan->numPixels < 0) {
        MCDBG_PRINT("MCDrvSpan: numPixels < 0");
        return FALSE;
    }

    MCD_CHECK_BUFFERS_VALID(pMCDSurface, pRc, TRUE);

    pDevWnd = (DEVWND *)pWnd->pvUser;

    xLeft = xLeftOrg = (pMCDSpan->x + pWnd->clientRect.left);
    xRight = (xLeft + pMCDSpan->numPixels);
    y = pMCDSpan->y + pWnd->clientRect.top;

    // Early-out spans which are not visible:

    if ((y < pWnd->clipBoundsRect.top) ||
        (y >= pWnd->clipBoundsRect.bottom))
        return TRUE;

    xLeft   = max(xLeft, pWnd->clipBoundsRect.left);
    xRight  = min(xRight, pWnd->clipBoundsRect.right);

    // Return if empty:

    if (xLeft >= xRight)
        return TRUE;

    cjHwPel = ppdev->iBytesPerPixel;

    pScreen = ppdev->pjScreen;

    switch (pMCDSpan->type) {
        case MCDSPAN_FRONT:
            // pScreen remains the same
            break;

        case MCDSPAN_BACK:
            pScreen += pDevWnd->backBufferOffset;
            if (ppdev->pohBackBuffer != pDevWnd->pohBackBuffer) winoffset = TRUE;
            break;

        case MCDSPAN_DEPTH:
            cjHwPel = 2;
            pScreen += pDevWnd->zBufferOffset;
            if (ppdev->pohZBuffer != pDevWnd->pohZBuffer) winoffset = TRUE;
            break;

        default:
            MCDBG_PRINT("MCDrvReadSpan: Unrecognized buffer %d", pMCDSpan->type);
            return FALSE;
    }

    if (winoffset)
    {
        // offset from window origin, remove client rectangle offsets applied above
        y     -= pWnd->clientRect.top;
        xLeft -= pWnd->clientRect.left;
        xLeftOrg -= pWnd->clientRect.left;
        xRight-= pWnd->clientRect.left;
    }

    // add offset to top of framebuffer, and offset within selected buffer
    pScreen += (y * ppdev->lDeltaScreen) + (xLeft * cjHwPel);

    bytesNeeded = pMCDSpan->numPixels * cjHwPel;

    // Make sure we don't read past the end of the buffer:

    if (((char *)pMCDSpan->pPixels + bytesNeeded) >               
        ((char *)pMCDMem->pMemBase + pMCDMem->memSize)) {
        MCDBG_PRINT("MCDrvSpan: Buffer too small");
        return FALSE;
    }

    WAIT_HW_IDLE(ppdev);

    pPixels = pMCDSpan->pPixels;

  //MCDBG_PRINT("MCDrvSpan: read %d, (%d, %d) type %d *ppix=%x, bytes=%d", bRead, pMCDSpan->x, pMCDSpan->y, pMCDSpan->type, *pPixels, bytesNeeded);

    if (bRead) {

        if (xLeftOrg != xLeft) // compensate for clip rectangle
            pPixels = (UCHAR *)pMCDSpan->pPixels + ((xLeft - xLeftOrg) * cjHwPel);

        RtlCopyMemory(pPixels, pScreen, (xRight - xLeft) * cjHwPel);

    } else {
        LONG xLeftClip, xRightClip, yClip;
        RECTL *pClip;
        RECTL AdjClip;
        ULONG cClip;

        for (pClip = &pWnd->pClip->arcl[0], cClip = pWnd->pClip->c; cClip;
             cClip--, pClip++)
        {
            UCHAR *pScreenClip;

            if (winoffset)
            {
                AdjClip.left    = pClip->left   - pWnd->clientRect.left;
                AdjClip.right   = pClip->right  - pWnd->clientRect.left;
                AdjClip.top     = pClip->top    - pWnd->clientRect.top;
                AdjClip.bottom  = pClip->bottom - pWnd->clientRect.top;
            }
            else
            {
                AdjClip.left    = pClip->left;
                AdjClip.right   = pClip->right;
                AdjClip.top     = pClip->top;
                AdjClip.bottom  = pClip->bottom;
            }                

            // Test for trivial cases:

            if (y < AdjClip.top)
                break;

            // Determine trivial rejection for just this span

            if ((xLeft >= AdjClip.right) ||
                (y >= AdjClip.bottom) ||
                (xRight <= AdjClip.left))
                continue;

            // Intersect current clip rect with the span:

            xLeftClip   = max(xLeft, AdjClip.left);
            xRightClip  = min(xRight, AdjClip.right);

            if (xLeftClip >= xRightClip)
                continue;

            if (xLeftOrg != xLeftClip)
                pPixels = (UCHAR *)pMCDSpan->pPixels +
                          ((xLeftClip - xLeftOrg) * cjHwPel);

            pScreenClip = pScreen + ((xLeftClip - xLeft) * cjHwPel);

            // Write the span:
            RtlCopyMemory(pScreenClip, pPixels, (xRightClip - xLeftClip) * cjHwPel);
        }
    }

    return (ULONG)TRUE;
}


ULONG MCDrvSync (MCDSURFACE *pMCDSurface, MCDRC *pRc)
{
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;
    MCDBG_PRINT( "MCDrvSync\n");

    WAIT_HW_IDLE(ppdev);
    
    return FALSE;
}
ULONG /* FASTCALL */ MCDrvDummyDrvDrawPixels (MCDSURFACE *pMcdSurface, MCDRC *pRc,
                                    ULONG width, ULONG height, ULONG format,
                                    ULONG type, VOID *pPixels, BOOL packed)
{
    MCDBG_PRINT( "MCDrvDummyDrvDrawPixels\n");
    return FALSE;
}
ULONG /* FASTCALL */ MCDrvDummyDrvReadPixels (MCDSURFACE *pMcdSurface, MCDRC *pRc,
                                    LONG x, LONG y, ULONG width, ULONG height, ULONG format,
                                    ULONG type, VOID *pPixels)
{
    MCDBG_PRINT( "MCDrvDummyDrvReadPixels\n");
    return FALSE;
}
ULONG /* FASTCALL */ MCDrvDummyDrvCopyPixels (MCDSURFACE *pMcdSurface, MCDRC *pRc,
                                    LONG x, LONG y, ULONG width, ULONG height, ULONG type)
{
    MCDBG_PRINT( "MCDrvDummyDrvCopyPixels\n");
    return FALSE;
}
ULONG /* FASTCALL */ MCDrvDummyDrvPixelMap (MCDSURFACE *pMcdSurface, MCDRC *pRc,
                                  ULONG mapType, ULONG mapSize, VOID *pMap)
{
    MCDBG_PRINT( "MCDrvDummyDrvPixelMap\n");
    return FALSE;
}

#define RECORD_TEXTURE_STATE(pTexCtlBlk,pTexState)                                              \
{                                                                                               \
    pTexCtlBlk->dwTxCtlBits |= (pTexState->sWrapMode==GL_CLAMP) ? CLMCD_TEX_U_SATURATE : 0;     \
    pTexCtlBlk->dwTxCtlBits |= (pTexState->tWrapMode==GL_CLAMP) ? CLMCD_TEX_V_SATURATE : 0;     \
    /* caller verifies we're not mipmapping and sets up to punt if we are*/                     \
    /* MCD_NOTE: only 1 filter on Laguna, not min/mag, so set filter on if either on */         \
    /* MCD_NOTE:    may need to punt in case min!=mag for 100% compliance */                    \
    /* MCD_NOTE:    MSFT said using LINEAR for both OK if 1 LINEAR, 1 NEAREST */                \
    pTexCtlBlk->dwTxCtlBits |= (pTexState->minFilter==GL_LINEAR) ? CLMCD_TEX_FILTER : 0;        \
    pTexCtlBlk->dwTxCtlBits |= (pTexState->magFilter==GL_LINEAR) ? CLMCD_TEX_FILTER : 0;        \
}


ULONG MCDrvCreateTexture(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc, MCDTEXTURE *pTex)
{
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;
    DEVRC *pRc =  (DEVRC *)pMCDRc->pvUser;
    MCDMIPMAPLEVEL *level;
    MCDTEXTURESTATE *pTexState;
    LL_Texture     *pTexCtlBlk; 
    SIZEL           mapsize;

    MCDFREE_PRINT("MCDrvCreateTexture");

    // initialize to FAIL condition
    pTex->textureKey = TEXTURE_NOT_LOADED;

    VERIFY_TEXTUREDATA_ACCESSIBLE(pTex);

    pTexState= (MCDTEXTURESTATE *)&pTex->pMCDTextureData->textureState;

    VERIFY_TEXTURELEVEL_ACCESSIBLE(pTex);

    level = pTex->pMCDTextureData->level;

    if ((level[0].width != 0) && (level[0].height != 0) &&
        (level[0].border == 0) &&                                                        // punt if bordered
        (level[0].widthImage <= 512) && (level[0].heightImage <= 512))                   // punt if too big
    {
        MCDBG_PRINT_TEX("width, height         = %ld %ld", level[0].width, level[0].height);
        MCDBG_PRINT_TEX("internalFormat        = 0x%08lx", level[0].internalFormat );
        MCDBG_PRINT_TEX("\t%s",
            (level[0].internalFormat == GL_ALPHA            ) ? "GL_ALPHA            " :
            (level[0].internalFormat == GL_RGB              ) ? "GL_RGB              " :
            (level[0].internalFormat == GL_RGBA             ) ? "GL_RGBA             " :
            (level[0].internalFormat == GL_LUMINANCE        ) ? "GL_LUMINANCE        " :
            (level[0].internalFormat == GL_LUMINANCE_ALPHA  ) ? "GL_LUMINANCE_ALPHA  " :
            (level[0].internalFormat == GL_INTENSITY        ) ? "GL_INTENSITY        " :
            (level[0].internalFormat == GL_BGR_EXT          ) ? "GL_BGR_EXT          " :
            (level[0].internalFormat == GL_BGRA_EXT         ) ? "GL_BGRA_EXT         " :
            (level[0].internalFormat == GL_COLOR_INDEX8_EXT ) ? "GL_COLOR_INDEX8_EXT " :
            (level[0].internalFormat == GL_COLOR_INDEX16_EXT) ? "GL_COLOR_INDEX16_EXT" :
                                                                 "unknown");

        if ( !(pTexCtlBlk = (LL_Texture *)MCDAlloc(sizeof(LL_Texture))) )
        {
            MCDBG_PRINT("  create texture failed -> MCDAlloc of LL_Texture failed ");
            return FALSE;
        }

        // add new texture control block to global list (visible to all contexts)
        ppdev->pLastTexture->next = pTexCtlBlk;
        pTexCtlBlk->prev = ppdev->pLastTexture;
        pTexCtlBlk->next = NULL;
        ppdev->pLastTexture = pTexCtlBlk;

        pTexCtlBlk->pohTextureMap = NULL;   // texture not loaded yet
        pTexCtlBlk->bNegativeMap  = FALSE;  // set TRUE to load 1-R,1-G,1-B
        pTexCtlBlk->bMasking      = FALSE;  // set TRUE to load in 1555 or 1888 mode for alphatest (masking)
        pTexCtlBlk->pTex = pTex;            // ptr to user's texture description

        // give new texture highest priority
        TIME_STAMP_TEXTURE(pRc,pTexCtlBlk);

        // scale by priority - 1.0 is max, 0.0 is min
        pTexCtlBlk->fLastDrvDraw *= pTex->pMCDTextureData->textureObjState.priority;

        // set key MCD will use in MCDrvDraw to select this texture
        pTex->textureKey = (ULONG)pTexCtlBlk;
        pTexCtlBlk->dwTxCtlBits = 0;
        RECORD_TEXTURE_STATE(pTexCtlBlk,pTexState)

        // Store the texture properties in the fields
        //
        pTexCtlBlk->fWidth  = (float)level[0].widthImage;
        pTexCtlBlk->fHeight = (float)level[0].heightImage;
      //pTexCtlBlk->bLookupOffset = 0;

        // if texture has alpha, it needs to be used in alpha equation, as well as
        // in generation of original source color - so really 2 levels of alpha equations
        // HW only has 1 level, so must punt if blending on
        if ( (level[0].internalFormat == GL_BGRA_EXT)       ||
             (level[0].internalFormat == GL_RGBA)           ||
             (level[0].internalFormat == GL_ALPHA)          ||
             (level[0].internalFormat == GL_INTENSITY)      ||
             (level[0].internalFormat == GL_LUMINANCE_ALPHA) )
            pTexCtlBlk->bAlphaInTexture = TRUE;
        else
            pTexCtlBlk->bAlphaInTexture = FALSE;

        if (level[0].widthImage >= 16)
        {
            pTexCtlBlk->bSizeMask  =  level[0].widthLog2-4;       // convert 16->0, 32->1, etc...
            mapsize.cx = level[0].widthImage;
        }
        else
        {
            // width < 16 - set it to 16 anyway, will stretch to 16 at end of this routine
            pTexCtlBlk->bSizeMask  =  0;
            mapsize.cx = 16;
            pTexCtlBlk->fWidth  = (float)16.0;
        }

        if (level[0].heightImage >= 16)
        {
            pTexCtlBlk->bSizeMask |= (level[0].heightLog2-4)<<4;  // convert 16->0, 32->1, etc...
            mapsize.cy = level[0].heightImage;
        }
        else
        {
            // height < 16 - set it to 16 anyway, will stretch to 16 at end of this routine
            // pTexCtlBlk->bSizeMask remains the same
            mapsize.cy = 16;
            pTexCtlBlk->fHeight = (float)16.0;
        }

    }
    else
    {
        MCDBG_PRINT_TEX("  create texture failed -> some parm beyond hw caps, no attempt to alloc ");
        MCDBG_PRINT_TEX("       width, height         = %ld %ld", level[0].width, level[0].height);
        MCDBG_PRINT_TEX("       border                = %ld",     level[0].border         );
        MCDBG_PRINT_TEX("  WILL ALLOC CTL BLOCK AND TAG AS BOGUS");

        // allocate control block, but tag as bogus to force all MCDrvDraw's with this
        // texture to punt.
        // Apparently, failing CreateTexture can lead to a bug in MCD above the driver.
        //   It looks like when CreateTexture fails, MCD may send a key for a texture
        //   that was earlier deleted.
        // Will fix this by never failing CreateTexture, but setting bogus condition
        //   so that we never render with it.

        if ( !(pTexCtlBlk = (LL_Texture *)MCDAlloc(sizeof(LL_Texture))) )
        {
            MCDBG_PRINT("  create texture failed -> MCDAlloc of LL_Texture failed ");
            return FALSE;
        }

        // add new texture control block to global list (visible to all contexts)
        ppdev->pLastTexture->next = pTexCtlBlk;
        pTexCtlBlk->prev = ppdev->pLastTexture;
        pTexCtlBlk->next = NULL;
        ppdev->pLastTexture = pTexCtlBlk;

        pTexCtlBlk->dwTxCtlBits = CLMCD_TEX_BOGUS;

        pTexCtlBlk->pohTextureMap = NULL;   // texture not loaded yet
        pTexCtlBlk->pTex = pTex;            // ptr to user's texture description

        // set key MCD will use in MCDrvDraw to select this texture
        pTex->textureKey = (ULONG)pTexCtlBlk;
    }

    return TRUE;
}

ULONG MCDrvUpdateSubTexture(MCDSURFACE *pMCDSurface, MCDRC *pRc, 
                            MCDTEXTURE *pTex, ULONG lod, RECTL *pRect)
{
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;
    LL_Texture *pTexCtlBlk;
    
    MCDBG_PRINT_TEX("MCDrvUpdateSubTexture");
    
    CHK_TEX_KEY(pTex);

    // simply free texture map - will force it to be reloaded before next use
    //
    if (pTex->textureKey != TEXTURE_NOT_LOADED)
    {
        pTexCtlBlk = (LL_Texture *)pTex->textureKey;

        // free off screen memory allocated for texture, if texture currently loaded
        if (pTexCtlBlk->pohTextureMap)
        {
            ppdev->pFreeOffScnMem(ppdev, pTexCtlBlk->pohTextureMap);
            pTexCtlBlk->pohTextureMap = NULL;
        }

    }

    return TRUE;
}


ULONG MCDrvUpdateTexturePalette(MCDSURFACE *pMCDSurface, MCDRC *pRc, 
                                MCDTEXTURE *pTex, ULONG start, 
                                ULONG numEntries)
{
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;
    LL_Texture *pTexCtlBlk;

    MCDBG_PRINT_TEX("MCDrvUpdateTexturePalette");

    CHK_TEX_KEY(pTex);

    VERIFY_TEXTUREDATA_ACCESSIBLE(pTex);
    VERIFY_TEXTURELEVEL_ACCESSIBLE(pTex);

    // make sure palette will be used before we trouble ourselves to take action
    if ((pTex->pMCDTextureData->level->internalFormat==GL_COLOR_INDEX8_EXT) ||
        (pTex->pMCDTextureData->level->internalFormat==GL_COLOR_INDEX16_EXT))
    {
        // simply free texture map - will force it to be reloaded before next use
        // when reloaded, new palette will be used
        if (pTex->textureKey != TEXTURE_NOT_LOADED)
        {
            pTexCtlBlk = (LL_Texture *)pTex->textureKey;

            // free off screen memory allocated for texture, if texture currently loaded
            if (pTexCtlBlk->pohTextureMap)
            {
                ppdev->pFreeOffScnMem(ppdev, pTexCtlBlk->pohTextureMap);
                pTexCtlBlk->pohTextureMap = NULL;
            }
        }
    }

    return TRUE;
}


ULONG MCDrvUpdateTexturePriority(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc, 
                                 MCDTEXTURE *pTex)
{
    LL_Texture *pTexCtlBlk;
    DEVRC *pRc = pMCDRc->pvUser;

    MCDBG_PRINT_TEX("MCDrvUpdateTexturePriority");

    CHK_TEX_KEY(pTex);

    VERIFY_TEXTUREDATA_ACCESSIBLE(pTex);
    
    pTexCtlBlk = (LL_Texture *)pTex->textureKey;

    // give new texture highest priority...
    TIME_STAMP_TEXTURE(pRc,pTexCtlBlk);

    // ....then scale by new priority - 1.0 is max, 0.0 is min
    pTexCtlBlk->fLastDrvDraw *= pTex->pMCDTextureData->textureObjState.priority;

    return TRUE;
}


ULONG MCDrvUpdateTextureState(MCDSURFACE *pMCDSurface, MCDRC *pMCDRc, 
                              MCDTEXTURE *pTex)
{
    DEVRC *pRc = (DEVRC *)pMCDRc->pvUser;
    LL_Texture      *pTexCtlBlk;
    MCDTEXTURESTATE *pTexState;

    MCDBG_PRINT_TEX("MCDrvUpdateTextureState");

    CHK_TEX_KEY(pTex);

    VERIFY_TEXTUREDATA_ACCESSIBLE(pTex);

    pTexCtlBlk = (LL_Texture *)pTex->textureKey;

    pTexState = (MCDTEXTURESTATE *)&pTex->pMCDTextureData->textureState;

    // turn off all control bits - while preserving the "bogus" indicator
    pTexCtlBlk->dwTxCtlBits &= CLMCD_TEX_BOGUS;

    RECORD_TEXTURE_STATE(pTexCtlBlk,pTexState)

    // if last texture was this one, reset so next use will force regs to be reloaded
    if ( pRc->pLastTexture==pTexCtlBlk ) pRc->pLastTexture=NULL;

    return TRUE;
}


ULONG MCDrvTextureStatus(MCDSURFACE *pMCDSurface, MCDRC *pRc, 
                         MCDTEXTURE *pTex)
{
    MCDBG_PRINT_TEX("MCDrvTextureStatus");

    CHK_TEX_KEY(pTex);

    if (pTex->textureKey == TEXTURE_NOT_LOADED)
    {
        return FALSE;
    }
    else
    {
        return MCDRV_TEXTURE_RESIDENT;
    }

}

ULONG MCDrvDeleteTexture(MCDTEXTURE *pTex, DHPDEV dhpdev)
{
    PDEV *ppdev = (PDEV *)dhpdev;
    LL_Texture     *pTexCtlBlk; 
    
    MCDBG_PRINT_TEX("MCDrvDeleteTexture");

    CHK_TEX_KEY(pTex);

    MCDBG_PRINT("    key = %x " , pTex->textureKey);

    if (pTex->textureKey != TEXTURE_NOT_LOADED)
    {
        pTexCtlBlk = (LL_Texture *)pTex->textureKey;

        // free off screen memory allocated for texture, if texture currently loaded
        if (pTexCtlBlk->pohTextureMap)
        {
            MCDFREE_PRINT("  MCDrvDeleteTexture, FREEING....size = %x by %x", 
                        (LONG)pTexCtlBlk->fHeight,
                        (LONG)pTexCtlBlk->fWidth);
            ppdev->pFreeOffScnMem(ppdev, pTexCtlBlk->pohTextureMap);
            pTexCtlBlk->pohTextureMap = NULL;
        }
           
        // Remove from global list of texture control blocks...
        //
        // if there's not a next link, this is last one
        if ( !pTexCtlBlk->next )
        {
            // this was last block, so now "prev" is last block
            ppdev->pLastTexture = pTexCtlBlk->prev;
            pTexCtlBlk->prev->next = NULL;
        }
        else
        {
            // there will always be a prev link for this block, and we now know
            //  there is a next block, so make "prev's" next point to what was
            //  this block's next;
            pTexCtlBlk->prev->next = pTexCtlBlk->next;

            // "next's" prev ptr pointed to this block, which is going away
            //  so make it point to this block's prev
            pTexCtlBlk->next->prev = pTexCtlBlk->prev;
        }

        // set "bogus" bit before freeing, in case MCD tries to use key after delete
        pTexCtlBlk->dwTxCtlBits = CLMCD_TEX_BOGUS;

        // now discard the block                                   
        MCDFree((UCHAR *)pTexCtlBlk);

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL MCDrvGetEntryPoints(MCDSURFACE *pMCDSurface, MCDDRIVER *pMCDDriver)
{

    MCDBG_PRINT( "MCDrvGetEntryPoints\n");

    if (pMCDDriver->ulSize < sizeof(MCDDRIVER))
        return FALSE;

 // Required functions (always)
    pMCDDriver->pMCDrvInfo = MCDrvInfo;
    pMCDDriver->pMCDrvDescribePixelFormat = MCDrvDescribePixelFormat;
    pMCDDriver->pMCDrvCreateContext = MCDrvCreateContext;
    pMCDDriver->pMCDrvDeleteContext = MCDrvDeleteContext;
    pMCDDriver->pMCDrvBindContext = MCDrvBindContext;
    pMCDDriver->pMCDrvDraw = MCDrvDraw;
    pMCDDriver->pMCDrvClear = MCDrvClear;
    pMCDDriver->pMCDrvState = MCDrvState; 
    pMCDDriver->pMCDrvSpan = MCDrvSpan;
    pMCDDriver->pMCDrvTrackWindow = MCDrvTrackWindow;
    pMCDDriver->pMCDrvAllocBuffers = MCDrvAllocBuffers;

 // Required for NT only
    pMCDDriver->pMCDrvGetHdev = MCDrvGetHdev;

 // Required functions (conditionally)
    // required for double-buffered pixel formats
    pMCDDriver->pMCDrvSwap = MCDrvSwap;
    // required for clipping
    pMCDDriver->pMCDrvViewport = MCDrvViewport;

 // Optional functions
    // if no entry for MCDrvDescribeLayerPlane, MCD will not call driver for layer plane stuff
//  pMCDDriver->pMCDrvSetLayerPalette = MCDrvSetLayerPalette;
//  pMCDDriver->pMCDrvDescribeLayerPlane = MCDrvDescribeLayerPlane;
    pMCDDriver->pMCDrvCreateMem = MCDrvCreateMem;
    pMCDDriver->pMCDrvDeleteMem = MCDrvDeleteMem;
    pMCDDriver->pMCDrvGetBuffers = MCDrvGetBuffers;
    pMCDDriver->pMCDrvSync = MCDrvSync;
    pMCDDriver->pMCDrvCreateTexture = MCDrvCreateTexture;
    pMCDDriver->pMCDrvDeleteTexture = MCDrvDeleteTexture;
    pMCDDriver->pMCDrvUpdateSubTexture = MCDrvUpdateSubTexture;
    pMCDDriver->pMCDrvUpdateTexturePalette = MCDrvUpdateTexturePalette;
    pMCDDriver->pMCDrvUpdateTexturePriority = MCDrvUpdateTexturePriority;
    pMCDDriver->pMCDrvUpdateTextureState = MCDrvUpdateTextureState;
    pMCDDriver->pMCDrvTextureStatus = MCDrvTextureStatus;
//  pMCDDriver->pMCDrvDrawPixels = MCDrvDummyDrvDrawPixels;
//  pMCDDriver->pMCDrvReadPixels = MCDrvDummyDrvReadPixels;
//  pMCDDriver->pMCDrvCopyPixels = MCDrvDummyDrvCopyPixels;
//  pMCDDriver->pMCDrvPixelMap = MCDrvDummyDrvPixelMap;
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\mcdclip.c ===
/******************************Module*Header*******************************\
* Module Name: mcdclip.c
*
* Contains the line and polygon clipping routines for an MCD driver.
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#include "mcdhw.h"
#include "mcdutil.h"
#include "mcdmath.h"

MCDCOORD __MCD_frustumClipPlanes[6] = {
    {(MCDFLOAT) 1.0, (MCDFLOAT) 0.0, (MCDFLOAT) 0.0, (MCDFLOAT) 1.0 }, // left
    {(MCDFLOAT)-1.0, (MCDFLOAT) 0.0, (MCDFLOAT) 0.0, (MCDFLOAT) 1.0 }, // right
    {(MCDFLOAT) 0.0, (MCDFLOAT) 1.0, (MCDFLOAT) 0.0, (MCDFLOAT) 1.0 }, // bottom
    {(MCDFLOAT) 0.0, (MCDFLOAT)-1.0, (MCDFLOAT) 0.0, (MCDFLOAT) 1.0 }, // top
    {(MCDFLOAT) 0.0, (MCDFLOAT) 0.0, (MCDFLOAT) 1.0, (MCDFLOAT) 1.0 }, // zNear
    {(MCDFLOAT) 0.0, (MCDFLOAT) 0.0, (MCDFLOAT)-1.0, (MCDFLOAT) 1.0 }, // zFar
};


////////////////////////////////////////////////////////////////////////
// Clipping macros used to build clip functions below.
////////////////////////////////////////////////////////////////////////


#define __MCD_CLIP_POS(v, a, b, t) \
    v->clipCoord.x = t*(a->clipCoord.x - b->clipCoord.x) + b->clipCoord.x;  \
    v->clipCoord.y = t*(a->clipCoord.y - b->clipCoord.y) + b->clipCoord.y;  \
    v->clipCoord.z = t*(a->clipCoord.z - b->clipCoord.z) + b->clipCoord.z;  \
    v->clipCoord.w = t*(a->clipCoord.w - b->clipCoord.w) + b->clipCoord.w

// Note that we compute the values needed for both "cheap" fog only...

#define __MCD_CLIP_FOG(v, a, b, t) \
    v->fog = t * (a->fog - b->fog) + b->fog;

#define __MCD_CLIP_COLOR(v, a, b, t) \
    v->colors[__MCD_FRONTFACE].r = t*(a->colors[__MCD_FRONTFACE].r      \
        - b->colors[__MCD_FRONTFACE].r) + b->colors[__MCD_FRONTFACE].r; \
    v->colors[__MCD_FRONTFACE].g = t*(a->colors[__MCD_FRONTFACE].g      \
        - b->colors[__MCD_FRONTFACE].g) + b->colors[__MCD_FRONTFACE].g; \
    v->colors[__MCD_FRONTFACE].b = t*(a->colors[__MCD_FRONTFACE].b      \
        - b->colors[__MCD_FRONTFACE].b) + b->colors[__MCD_FRONTFACE].b; \
    v->colors[__MCD_FRONTFACE].a = t*(a->colors[__MCD_FRONTFACE].a      \
        - b->colors[__MCD_FRONTFACE].a) + b->colors[__MCD_FRONTFACE].a

#define __MCD_CLIP_BACKCOLOR(v, a, b, t) \
    v->colors[__MCD_BACKFACE].r = t*(a->colors[__MCD_BACKFACE].r        \
        - b->colors[__MCD_BACKFACE].r) + b->colors[__MCD_BACKFACE].r;   \
    v->colors[__MCD_BACKFACE].g = t*(a->colors[__MCD_BACKFACE].g        \
        - b->colors[__MCD_BACKFACE].g) + b->colors[__MCD_BACKFACE].g;   \
    v->colors[__MCD_BACKFACE].b = t*(a->colors[__MCD_BACKFACE].b        \
        - b->colors[__MCD_BACKFACE].b) + b->colors[__MCD_BACKFACE].b;   \
    v->colors[__MCD_BACKFACE].a = t*(a->colors[__MCD_BACKFACE].a        \
        - b->colors[__MCD_BACKFACE].a) + b->colors[__MCD_BACKFACE].a

#define __MCD_CLIP_INDEX(v, a, b, t) \
    v->colors[__MCD_FRONTFACE].r = t*(a->colors[__MCD_FRONTFACE].r      \
        - b->colors[__MCD_FRONTFACE].r) + b->colors[__MCD_FRONTFACE].r

#define __MCD_CLIP_BACKINDEX(v, a, b, t) \
    v->colors[__MCD_BACKFACE].r = t*(a->colors[__MCD_BACKFACE].r        \
        - b->colors[__MCD_BACKFACE].r) + b->colors[__MCD_BACKFACE].r

#define __MCD_CLIP_TEXTURE(v, a, b, t) \
    v->texCoord.x = t*(a->texCoord.x - b->texCoord.x) + b->texCoord.x; \
    v->texCoord.y = t*(a->texCoord.y - b->texCoord.y) + b->texCoord.y;
#ifdef CLIP_TEXTURE_XFORM
    v->texCoord.z = t*(a->texCoord.z - b->texCoord.z) + b->texCoord.z; \
    v->texCoord.w = t*(a->texCoord.w - b->texCoord.w) + b->texCoord.w
#endif

////////////////////////////////////////////////////////////////////////
// Clipping functions to clip vertices:
////////////////////////////////////////////////////////////////////////

static VOID FASTCALL Clip(MCDVERTEX *dst, const MCDVERTEX *a,
                          const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
}

static VOID FASTCALL ClipC(MCDVERTEX *dst, const MCDVERTEX *a, 
                           const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_COLOR(dst,a,b,t);
}

static VOID FASTCALL ClipI(MCDVERTEX *dst, const MCDVERTEX *a, 
                           const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_INDEX(dst,a,b,t);
}

static VOID FASTCALL ClipBC(MCDVERTEX *dst, const MCDVERTEX *a, 
                            const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_COLOR(dst,a,b,t);
    __MCD_CLIP_BACKCOLOR(dst,a,b,t);
}

static VOID FASTCALL ClipBI(MCDVERTEX *dst, const MCDVERTEX *a, 
                            const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_INDEX(dst,a,b,t);
    __MCD_CLIP_BACKINDEX(dst,a,b,t);
}

static VOID FASTCALL ClipT(MCDVERTEX *dst, const MCDVERTEX *a, 
                           const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_TEXTURE(dst,a,b,t);
}

static VOID FASTCALL ClipIT(MCDVERTEX *dst, const MCDVERTEX *a, 
                            const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_INDEX(dst,a,b,t);
    __MCD_CLIP_TEXTURE(dst,a,b,t);
}

static VOID FASTCALL ClipBIT(MCDVERTEX *dst, const MCDVERTEX *a, 
                             const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_INDEX(dst,a,b,t);
    __MCD_CLIP_BACKINDEX(dst,a,b,t);
    __MCD_CLIP_TEXTURE(dst,a,b,t);
}

static VOID FASTCALL ClipCT(MCDVERTEX *dst, const MCDVERTEX *a, 
                            const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_COLOR(dst,a,b,t);
    __MCD_CLIP_TEXTURE(dst,a,b,t);
}


static VOID FASTCALL ClipBCT(MCDVERTEX *dst, const MCDVERTEX *a, 
                             const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_COLOR(dst,a,b,t);
    __MCD_CLIP_BACKCOLOR(dst,a,b,t);
    __MCD_CLIP_TEXTURE(dst,a,b,t);
}

static VOID FASTCALL ClipF(MCDVERTEX *dst, const MCDVERTEX *a, 
                           const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_FOG(dst,a,b,t);
}

static VOID FASTCALL ClipIF(MCDVERTEX *dst, const MCDVERTEX *a, 
                            const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_INDEX(dst,a,b,t);
    __MCD_CLIP_FOG(dst,a,b,t);
}

static VOID FASTCALL ClipCF(MCDVERTEX *dst, const MCDVERTEX *a, 
                            const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_COLOR(dst,a,b,t);
    __MCD_CLIP_FOG(dst,a,b,t);
}

static VOID FASTCALL ClipBCF(MCDVERTEX *dst, const MCDVERTEX *a, 
                             const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_COLOR(dst,a,b,t);
    __MCD_CLIP_BACKCOLOR(dst,a,b,t);
    __MCD_CLIP_FOG(dst,a,b,t);
}

static VOID FASTCALL ClipBIF(MCDVERTEX *dst, const MCDVERTEX *a, 
                             const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_INDEX(dst,a,b,t);
    __MCD_CLIP_BACKINDEX(dst,a,b,t);
    __MCD_CLIP_FOG(dst,a,b,t);
}

static VOID FASTCALL ClipFT(MCDVERTEX *dst, const MCDVERTEX *a, 
                            const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_FOG(dst,a,b,t);
    __MCD_CLIP_TEXTURE(dst,a,b,t);
}

static VOID FASTCALL ClipIFT(MCDVERTEX *dst, const MCDVERTEX *a, 
                             const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_INDEX(dst,a,b,t);
    __MCD_CLIP_FOG(dst,a,b,t);
    __MCD_CLIP_TEXTURE(dst,a,b,t);
}

static VOID FASTCALL ClipBIFT(MCDVERTEX *dst, const MCDVERTEX *a, 
                              const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_INDEX(dst,a,b,t);
    __MCD_CLIP_BACKINDEX(dst,a,b,t);
    __MCD_CLIP_FOG(dst,a,b,t);
    __MCD_CLIP_TEXTURE(dst,a,b,t);
}


static VOID FASTCALL ClipCFT(MCDVERTEX *dst, const MCDVERTEX *a, 
                             const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_COLOR(dst,a,b,t);
    __MCD_CLIP_FOG(dst,a,b,t);
    __MCD_CLIP_TEXTURE(dst,a,b,t);
}

static VOID FASTCALL ClipBCFT(MCDVERTEX *dst, const MCDVERTEX *a, 
                              const MCDVERTEX *b, MCDFLOAT t)
{
    __MCD_CLIP_POS(dst,a,b,t);
    __MCD_CLIP_COLOR(dst,a,b,t);
    __MCD_CLIP_BACKCOLOR(dst,a,b,t);
    __MCD_CLIP_FOG(dst,a,b,t);
    __MCD_CLIP_TEXTURE(dst,a,b,t);
}

static VOID (FASTCALL *clipProcs[20])(MCDVERTEX*, const MCDVERTEX*, 
                                      const MCDVERTEX*, MCDFLOAT) =
{
    Clip,   ClipI,   ClipC,   ClipBI,   ClipBC,
    ClipF,  ClipIF,  ClipCF,  ClipBIF,  ClipBCF,
    ClipT,  ClipIT,  ClipCT,  ClipBIT,  ClipBCT,
    ClipFT, ClipIFT, ClipCFT, ClipBIFT, ClipBCFT,
};


VOID FASTCALL __MCDPickClipFuncs(DEVRC *pRc)
{
    LONG line = 0, poly = 0;
    BOOL twoSided = (pRc->MCDState.enables & MCD_LIGHTING_ENABLE) &&
	            (pRc->MCDState.twoSided);

    if (pRc->MCDState.shadeModel != GL_FLAT) {
	    line = 2;
        poly = (twoSided ? 4 : 2);
    }

    if (pRc->privateEnables & __MCDENABLE_FOG)
    {
	    line += 5;
	    poly += 5;
    }

    if (pRc->MCDState.textureEnabled)
    {
	    line += 10;
    	poly += 10;
    }

    pRc->lineClipParam = clipProcs[line];
    pRc->polyClipParam = clipProcs[poly];
}


////////////////////////////////////////////////////////////////////////
// The real primitive clippers:
////////////////////////////////////////////////////////////////////////

/*
** The following is a discussion of the math used to do edge clipping against
** a clipping plane.
** 
**     P1 is an end point of the edge
**     P2 is the other end point of the edge
** 
**     Q = t*P1 + (1 - t)*P2
**     That is, Q lies somewhere on the line formed by P1 and P2.
** 
**     0 <= t <= 1
**     This constrains Q to lie between P1 and P2.
** 
**     C is the plane equation for the clipping plane
** 
**     D1 = P1 dot C
**     D1 is the distance between P1 and C.  If P1 lies on the plane
**     then D1 will be zero.  The sign of D1 will determine which side
**     of the plane that P1 is on, with negative being outside.
** 
**     D2 = P2 dot C
**     D2 is the distance between P2 and C.  If P2 lies on the plane
**     then D2 will be zero.  The sign of D2 will determine which side
**     of the plane that P2 is on, with negative being outside.
** 
** Because we are trying to find the intersection of the P1 P2 line
** segment with the clipping plane we require that:
** 
**     Q dot C = 0
** 
** Therefore
** 
**     (t*P1 + (1 - t)*P2) dot C = 0
** 
**     (t*P1 + P2 - t*P2) dot C = 0
** 
**     t*P1 dot C + P2 dot C - t*P2 dot C = 0
** 
** Substituting D1 and D2 in
** 
**     t*D1 + D2 - t*D2 = 0                      
** 
** Solving for t
** 
**     t = -D2 / (D1 - D2)
** 
**     t = D2 / (D2 - D1)
*/


static LONG clipToPlane(DEVRC *pRc, MCDVERTEX **iv, LONG niv,
                        MCDVERTEX **ov, MCDCOORD *plane)
{
    LONG i, nout, generated;
    MCDVERTEX *s, *p, *newVertex, *temp;
    MCDFLOAT pDist, sDist, t;
    MCDFLOAT zero = ZERO;
    VOID (FASTCALL *clip)(MCDVERTEX*, const MCDVERTEX*, const MCDVERTEX*, MCDFLOAT);

    nout = 0;
    generated = 0;
    temp = pRc->pNextClipTemp;
    clip = pRc->polyClipParam;

    s = iv[niv-1];
    sDist = (s->clipCoord.x * plane->x) + (s->clipCoord.y * plane->y) +
	    (s->clipCoord.z * plane->z) + (s->clipCoord.w * plane->w);
    for (i = 0; i < niv; i++) {
	p = iv[i];
	pDist = (p->clipCoord.x * plane->x) + (p->clipCoord.y * plane->y) +
		(p->clipCoord.z * plane->z) + (p->clipCoord.w * plane->w);
	if (pDist >= zero) {
	    /* p is inside the clipping plane half space */
	    if (sDist >= zero) {
		/* s is inside the clipping plane half space */
		*ov++ = p;
		nout++;
	    } else {
		/* s is outside the clipping plane half space */
		t = pDist / (pDist - sDist);
		newVertex = temp++;
		(*clip)(newVertex, s, p, t);
                newVertex->flags = s->flags;
                newVertex->clipCode = s->clipCode | __MCD_CLIPPED_VTX;
		*ov++ = newVertex;
		*ov++ = p;
		nout += 2;

		if (++generated >= 3) {
		    /* Toss the non-convex polygon */
		    return 0;
		}
	    }
	} else {
	    /* p is outside the clipping plane half space */
	    if (sDist >= zero) {
		/*
		** s is inside the clipping plane half space
		**
		** NOTE: To avoid cracking in polygons with shared
		** clipped edges we always compute "t" from the out
		** vertex to the in vertex.  The above clipping code gets
		** this for free (p is in and s is out).  In this code p
		** is out and s is in, so we reverse the t computation
		** and the argument order to __MCDDoClip.
		*/
		t = sDist / (sDist - pDist);
		newVertex = temp++;
		(*clip)(newVertex, p, s, t);
		newVertex->flags = s->flags | MCDVERTEX_EDGEFLAG;
                newVertex->clipCode = p->clipCode | __MCD_CLIPPED_VTX;
		*ov++ = newVertex;
		nout++;

		if (++generated >= 3) {
		    /* Toss the non-convex polygon */
		    return 0;
		}
	    } else {
		/* both points are outside */
	    }
	}
	s = p;
	sDist = pDist;
    }
    pRc->pNextClipTemp = temp;
    return nout;
}

/* 
** Identical to clipToPlane(), except that the clipping is done in eye
** space.
*/
static LONG clipToPlaneEye(DEVRC *pRc, MCDVERTEX **iv, LONG niv,
			   MCDVERTEX **ov, MCDCOORD *plane)
{
    LONG i, nout, generated;
    MCDVERTEX *s, *p, *newVertex, *temp;
    MCDFLOAT pDist, sDist, t;
    MCDFLOAT zero = __MCDZERO;
    VOID (FASTCALL *clip)(MCDVERTEX*, const MCDVERTEX*, const MCDVERTEX*, MCDFLOAT);

    nout = 0;
    generated = 0;
    temp = pRc->pNextClipTemp;
    clip = pRc->polyClipParam;

    s = iv[niv-1];
    sDist = (s->eyeCoord.x * plane->x) +
	    (s->eyeCoord.y * plane->y) +
	    (s->eyeCoord.z * plane->z) +
	    (s->eyeCoord.w * plane->w);
    for (i = 0; i < niv; i++) {
	p = iv[i];
	pDist = (p->eyeCoord.x * plane->x) +
		(p->eyeCoord.y * plane->y) +
		(p->eyeCoord.z * plane->z) +
		(p->eyeCoord.w * plane->w);
	if (pDist >= zero) {
	    /* p is inside the clipping plane half space */
	    if (sDist >= zero) {
		/* s is inside the clipping plane half space */
		*ov++ = p;
		nout++;
	    } else {
		/* s is outside the clipping plane half space */
		t = pDist / (pDist - sDist);
		newVertex = temp++;
		(*clip)(newVertex, s, p, t);
		newVertex->eyeCoord.x = t*(s->eyeCoord.x - p->eyeCoord.x) + p->eyeCoord.x;
		newVertex->eyeCoord.y = t*(s->eyeCoord.y - p->eyeCoord.y) + p->eyeCoord.y;
		newVertex->eyeCoord.z = t*(s->eyeCoord.z - p->eyeCoord.z) + p->eyeCoord.z;
		newVertex->eyeCoord.w = t*(s->eyeCoord.w - p->eyeCoord.w) + p->eyeCoord.w;
		newVertex->flags = s->flags;
                newVertex->clipCode = s->clipCode | __MCD_CLIPPED_VTX;
		*ov++ = newVertex;
		*ov++ = p;
		nout += 2;

		if (++generated >= 3) {
		    /* Toss the non-convex polygon */
		    return 0;
		}
	    }
	} else {
	    /* p is outside the clipping plane half space */
	    if (sDist >= zero) {
		/*
		** s is inside the clipping plane half space
		**
		** NOTE: To avoid cracking in polygons with shared
		** clipped edges we always compute "t" from the out
		** vertex to the in vertex.  The above clipping code gets
		** this for free (p is in and s is out).  In this code p
		** is out and s is in, so we reverse the t computation
		** and the argument order to __MCDDoClip.
		*/
		t = sDist / (sDist - pDist);
		newVertex = temp++;
		(*clip)(newVertex, p, s, t);
		newVertex->eyeCoord.x = t*(p->eyeCoord.x - s->eyeCoord.x) + s->eyeCoord.x;
		newVertex->eyeCoord.y = t*(p->eyeCoord.y - s->eyeCoord.y) + s->eyeCoord.y;
		newVertex->eyeCoord.z = t*(p->eyeCoord.z - s->eyeCoord.z) + s->eyeCoord.z;
		newVertex->eyeCoord.w = t*(p->eyeCoord.w - s->eyeCoord.w) + s->eyeCoord.w;
		newVertex->flags = s->flags | MCDVERTEX_EDGEFLAG;
                newVertex->clipCode = p->clipCode | __MCD_CLIPPED_VTX;
		*ov++ = newVertex;
		nout++;

		if (++generated >= 3) {
		    /* Toss the non-convex polygon */
		    return 0;
		}
	    } else {
		/* both points are outside */
	    }
	}
	s = p;
	sDist = pDist;
    }
    pRc->pNextClipTemp = temp;
    return nout;
}

/*
** Each clipping plane can add at most one vertex to a convex polygon (it may
** remove up to all of the vertices).  The clipping will leave a polygon
** convex.  Because of this the maximum number of verticies output from
** the clipToPlane procedure will be total number of clip planes (assuming
** each plane adds one new vertex) plus the original number of verticies
** (3 since this if for triangles).
*/

#define __MCD_TOTAL_CLIP_PLANES 6 + MCD_MAX_USER_CLIP_PLANES
#define __MCD_MAX_POLYGON_CLIP_SIZE     256

#define	__MCD_MAX_CLIP_VERTEX (__MCD_TOTAL_CLIP_PLANES + __MCD_MAX_POLYGON_CLIP_SIZE)


void FASTCALL __MCDDoClippedPolygon(DEVRC *pRc, MCDVERTEX **iv, LONG nout,
                                    ULONG allClipCodes)
{
    MCDVERTEX *ov[__MCD_TOTAL_CLIP_PLANES][__MCD_MAX_CLIP_VERTEX];
    MCDVERTEX **ivp;
    MCDVERTEX **ovp;
    MCDVERTEX *p0, *p1, *p2;
    MCDCOORD *plane;
    LONG i;
    MCDFLOAT one;
    VOID (FASTCALL *rt)(DEVRC*, MCDVERTEX*, MCDVERTEX*, MCDVERTEX*);
    MCDFLOAT llx, lly, urx, ury;
    MCDFLOAT winx, winy;
    ULONG clipCodes;

    /*
    ** Reset nextClipTemp pointer for any new verticies that are generated
    ** during the clipping.
    */

    pRc->pNextClipTemp = &pRc->clipTemp[0];

    ivp = &iv[0];

    /*
    ** Check each of the clipping planes by examining the allClipCodes
    ** mask. Note that no bits will be set in allClipCodes for clip
    ** planes that are not enabled.
    */
    if (allClipCodes) {

	/* Now clip against the clipping planes */
	ovp = &ov[0][0];

	/* 
	** Do user clip planes first, because we will maintain eye coordinates
	** only while doing user clip planes.  They are ignored for the 
	** frustum clipping planes.
	*/
	clipCodes = (allClipCodes >> 6) & __MCD_USER_CLIP_MASK;
	if (clipCodes) {
	    plane = &pRc->MCDState.userClipPlanes[0];
	    do {
		if (clipCodes & 1) {
		    nout = clipToPlaneEye(pRc, ivp, nout, ovp, plane);
		    if (nout < 3) {
			return;
		    }
		    ivp = ovp;
		    ovp += __MCD_MAX_CLIP_VERTEX;
		}
		clipCodes >>= 1;
		plane++;
	    } while (clipCodes);
	}

	allClipCodes &= MCD_CLIP_MASK;
	if (allClipCodes) {
	    plane = &__MCD_frustumClipPlanes[0];
	    do {
		if (allClipCodes & 1) {
		    nout = clipToPlane(pRc, ivp, nout, ovp, plane);
		    if (nout < 3) {
			return;
		    }
		    ivp = ovp;
		    ovp += __MCD_MAX_CLIP_VERTEX;
		}
		allClipCodes >>= 1;
		plane++;
	    } while (allClipCodes);
	}

	/*
	** Calculate final screen coordinates.  Next phase of polygon
	** processing assumes that window coordinates are already computed.
	*/

	ovp = ivp;
	one = __MCDONE;

	llx = pRc->MCDViewport.xCenter - pRc->MCDViewport.xScale;
	urx = pRc->MCDViewport.xCenter + pRc->MCDViewport.xScale;

	if (pRc->MCDViewport.yScale > 0) {
	    lly = pRc->MCDViewport.yCenter - pRc->MCDViewport.yScale;
	    ury = pRc->MCDViewport.yCenter + pRc->MCDViewport.yScale;
	} else {
	    lly = pRc->MCDViewport.yCenter + pRc->MCDViewport.yScale;
	    ury = pRc->MCDViewport.yCenter - pRc->MCDViewport.yScale;
	}

	for (i = nout; --i >= 0; ) {
	    MCDFLOAT wInv;
        
	    p0 = *ovp++;
    
        // change to original DDK code - only recompute windowCoord data if
        // this vertex actually an intersection found during clipping.
        // Or is one that had non-zero clipcode - meaning window coords may not be correct
        // If this is an original unclipped vertex, then windowCoord data should
        // be OK as is, and don't want to recompute.  Recomputing can give
        // slightly different result than original.  When neighboring triangles
        // share a vertex, if 1 triangle clipped, and the other not, the clipped
        // one's unclipped vertices can be altered slightly by this computation,
        // resulting in cracks when subpixel-precision triangle rendering is enabled.
        // __MCD_CLIPPED_VTX is OR'd into clipcode for vertices resulting from clip
        //  so clipCode is non-zero
        if (p0->clipCode)
        {
    	    if (p0->clipCoord.w == (MCDFLOAT) 0.0)
    		wInv = (MCDFLOAT) 0.0; 
    	    else 
    		wInv = one / p0->clipCoord.w;

    	    winx = p0->clipCoord.x * pRc->MCDViewport.xScale * wInv + 
                       pRc->MCDViewport.xCenter;

    	    winy = p0->clipCoord.y * pRc->MCDViewport.yScale * wInv + 
                       pRc->MCDViewport.yCenter;

    	    /* 
    	    ** Check if these window coordinates are legal.  At this 
    	    ** point, it is quite possible that they are not.  Trivially
    	    ** pull them into the legal viewport region if necessary.
    	    */

    	    if (winx < llx) winx = llx;
    	    else if (winx > urx) winx = urx;
    	    if (winy < lly) winy = lly;
    	    else if (winy > ury) winy = ury;

    	    p0->windowCoord.x = winx;
    	    p0->windowCoord.y = winy;
    	    p0->windowCoord.z = p0->clipCoord.z * pRc->MCDViewport.zScale * wInv + 
                                    pRc->MCDViewport.zCenter;
    	    p0->windowCoord.w = wInv;
        }
	}
    }

    /*
    ** Subdivide the clipped polygon into triangles.  Only convex polys
    ** are supported so this is okay to do.  Non-convex polys will do
    ** something odd here, but thats the clients fault.
    */
    p0 = *ivp++;
    p1 = *ivp++;
    p2 = *ivp++;
    rt = pRc->renderTri;
    if (nout == 3) {
	(*rt)(pRc, p0, p1, p2);
    } else {
	for (i = 0; i < nout - 2; i++) {
	    ULONG t1, t2;
	    if (i == 0) {
		/*
		** Third edge of first sub-triangle is always non-boundary
		*/
		t1 = p2->flags & MCDVERTEX_EDGEFLAG;
		p2->flags &= ~MCDVERTEX_EDGEFLAG;
		(*rt)(pRc, p0, p1, p2);
		p2->flags |= t1;
	    } else
	    if (i == nout - 3) {
		/*
		** First edge of last sub-triangle is always non-boundary
		*/
		t1 = p0->flags & MCDVERTEX_EDGEFLAG;
		p0->flags &= ~MCDVERTEX_EDGEFLAG;
		(*rt)(pRc, p0, p1, p2);
		p0->flags |= t1;
	    } else {
		/*
		** Interior sub-triangles have the first and last edge
		** marked non-boundary
		*/

		t1 = p0->flags & MCDVERTEX_EDGEFLAG;
		t2 = p2->flags & MCDVERTEX_EDGEFLAG;
		p0->flags &= ~MCDVERTEX_EDGEFLAG;
		p2->flags &= ~MCDVERTEX_EDGEFLAG;
		(*rt)(pRc, p0, p1, p2);
		p0->flags |= t1;
		p2->flags |= t2;
	    }
	    p1 = p2;
	    p2 = (MCDVERTEX *) *ivp++;
	}
    }
}


VOID FASTCALL __MCDClipPolygon(DEVRC *pRc, MCDVERTEX *v0, LONG nv)
{
    MCDVERTEX *iv[__MCD_MAX_POLYGON_CLIP_SIZE];

    MCDVERTEX **ivp;
    LONG i;
    ULONG andCodes, orCodes;

    pRc->pvProvoking = v0;

    /*
    ** Generate array of addresses of the verticies.  And all the
    ** clip codes together while we are at it.
    */
    ivp = &iv[0];
    andCodes = 0;
    orCodes = 0;
    for (i = nv; --i >= 0; ) {
	andCodes &= v0->clipCode;
	orCodes |= v0->clipCode;
	*ivp++ = v0++;
    }

    if (andCodes != 0) {
	/*
	** Trivially reject the polygon.  If andCodes is non-zero then
	** every vertex in the polygon is outside of the same set of
	** clipping planes (at least one).
	*/
	return;
    }
    __MCDDoClippedPolygon(pRc, &iv[0], nv, orCodes);
}

void FASTCALL __MCDClipTriangle(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b,
                                MCDVERTEX *c, ULONG orCodes)
{
    MCDVERTEX *iv[3];

    iv[0] = a;
    iv[1] = b;
    iv[2] = c;

    __MCDDoClippedPolygon(pRc, &iv[0], 3, orCodes);
}


////////////////////////////////////////////////////////////////////////
// Line clipping:
////////////////////////////////////////////////////////////////////////

//
// Clip a line against the frustum clip planes and any user clipping planes.
// If an edge remains after clipping then compute the window coordinates
// and invoke the renderer.
//
// Notice:  This algorithim is an example of an implementation that is
// different than what the spec says.  This is equivalent in functionality
// and meets the spec, but doesn't clip in eye space.  This clipper clips
// in NTVP (clip) space.
//
// Trivial accept/reject has already been dealt with.
//

VOID FASTCALL __MCDClipLine(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b,
                           BOOL bResetLine)
{
    MCDVERTEX *provokingA = a;
    MCDVERTEX *provokingB = b;
    MCDVERTEX np1, np2;
    MCDCOORD *plane;
    ULONG needs, allClipCodes, clipCodes;
    VOID (FASTCALL *clip)(MCDVERTEX*, const MCDVERTEX*, const MCDVERTEX*, MCDFLOAT);
    MCDFLOAT zero;
    MCDFLOAT winx, winy;
    MCDFLOAT vpXCenter, vpYCenter, vpZCenter;
    MCDFLOAT vpXScale, vpYScale, vpZScale;
    MCDVIEWPORT *vp;
    MCDFLOAT x, y, z, wInv;

    allClipCodes = a->clipCode | b->clipCode;

    /*
    ** For each clipping plane that something is out on, clip
    ** check the verticies.  Note that no bits will be set in
    ** allClipCodes for clip planes that are not enabled.
    */
    zero = __MCDZERO;
    clip = pRc->lineClipParam;

    /* 
    ** Do user clip planes first, because we will maintain eye coordinates
    ** only while doing user clip planes.  They are ignored for the
    ** frustum clipping planes.
    */
    clipCodes = (allClipCodes >> 6) & __MCD_USER_CLIP_MASK;
    if (clipCodes) {
        plane = &pRc->MCDState.userClipPlanes[0];
        do {
            /*
            ** See if this clip plane has anything out of it.  If not,
            ** press onward to check the next plane.  Note that we
            ** shift this mask to the right at the bottom of the loop.
            */
            if (clipCodes & 1) {
                MCDFLOAT t, d1, d2;

                d1 = (plane->x * a->eyeCoord.x) + 
                     (plane->y * a->eyeCoord.y) +
                     (plane->z * a->eyeCoord.z) + 
                     (plane->w * a->eyeCoord.w);
                d2 = (plane->x * b->eyeCoord.x) + 
                     (plane->y * b->eyeCoord.y) +
                     (plane->z * b->eyeCoord.z) + 
                     (plane->w * b->eyeCoord.w);
                if (d1 < zero) {
                    /* a is out */
                    if (d2 < zero) {
                        /* a & b are out */
                        return;
                    }

                    /*
                    ** A is out and B is in.  Compute new A coordinate
                    ** clipped to the plane.
                    */
                    t = d2 / (d2 - d1);
                    (*clip)(&np1, a, b, t);
                    (&np1)->eyeCoord.x = 
                        t*(a->eyeCoord.x - b->eyeCoord.x) + b->eyeCoord.x;
                    (&np1)->eyeCoord.y = 
                        t*(a->eyeCoord.y - b->eyeCoord.y) + b->eyeCoord.y;
                    (&np1)->eyeCoord.z = 
                        t*(a->eyeCoord.z - b->eyeCoord.z) + b->eyeCoord.z;
                    (&np1)->eyeCoord.w = 
                        t*(a->eyeCoord.w - b->eyeCoord.w) + b->eyeCoord.w;
                    a = &np1;
                    a->flags = b->flags;

                    if (pRc->MCDState.shadeModel == GL_FLAT)
                    {
                        COPY_COLOR(a->colors[0], provokingA->colors[0]);
                    }

                } else {
                    /* a is in */
                    if (d2 < zero) {
                        /*
                        ** A is in and B is out.  Compute new B
                        ** coordinate clipped to the plane.
                        **
                        ** NOTE: To avoid cracking in polygons with
                        ** shared clipped edges we always compute "t"
                        ** from the out vertex to the in vertex.  The
                        ** above clipping code gets this for free (b is
                        ** in and a is out).  In this code b is out and a
                        ** is in, so we reverse the t computation and the
                        ** argument order to (*clip).
                        */
                        t = d1 / (d1 - d2);
                        (*clip)(&np2, b, a, t);
                        (&np2)->eyeCoord.x =
                            t*(b->eyeCoord.x - a->eyeCoord.x) + a->eyeCoord.x;
                        (&np2)->eyeCoord.y =
                            t*(b->eyeCoord.y - a->eyeCoord.y) + a->eyeCoord.y;
                        (&np2)->eyeCoord.z =
                            t*(b->eyeCoord.z - a->eyeCoord.z) + a->eyeCoord.z;
                        (&np2)->eyeCoord.w =
                            t*(b->eyeCoord.w - a->eyeCoord.w) + a->eyeCoord.w;
                        b = &np2;
                        b->flags = a->flags;

                        if (pRc->MCDState.shadeModel == GL_FLAT)
                        {
                            COPY_COLOR(b->colors[0], provokingB->colors[0]);
                        }

                    } else {
                        /* A and B are in */
                    }
                }
            }
            plane++;
            clipCodes >>= 1;
        } while (clipCodes);
    }

    allClipCodes &= MCD_CLIP_MASK;
    if (allClipCodes) {
        plane = &__MCD_frustumClipPlanes[0];
        do {
            /*
            ** See if this clip plane has anything out of it.  If not,
            ** press onward to check the next plane.  Note that we
            ** shift this mask to the right at the bottom of the loop.
            */
            if (allClipCodes & 1) {
                MCDFLOAT t, d1, d2;

                d1 = (plane->x * a->clipCoord.x) + (plane->y * a->clipCoord.y) +
                     (plane->z * a->clipCoord.z) + (plane->w * a->clipCoord.w);
                d2 = (plane->x * b->clipCoord.x) + (plane->y * b->clipCoord.y) +
                     (plane->z * b->clipCoord.z) + (plane->w * b->clipCoord.w);
                if (d1 < zero) {
                    /* a is out */
                    if (d2 < zero) {
                        /* a & b are out */
                        return;
                    }

                    /*
                    ** A is out and B is in.  Compute new A coordinate
                    ** clipped to the plane.
                    */
                    t = d2 / (d2 - d1);
                    (*clip)(&np1, a, b, t);
                    a = &np1;
                    a->flags = b->flags;

                    if (pRc->MCDState.shadeModel == GL_FLAT)
                    {
                        COPY_COLOR(a->colors[0], provokingA->colors[0]);
                    }

                } else {
                    /* a is in */
                    if (d2 < zero) {
                        /*
                        ** A is in and B is out.  Compute new B
                        ** coordinate clipped to the plane.
                        **
                        ** NOTE: To avoid cracking in polygons with
                        ** shared clipped edges we always compute "t"
                        ** from the out vertex to the in vertex.  The
                        ** above clipping code gets this for free (b is
                        ** in and a is out).  In this code b is out and a
                        ** is in, so we reverse the t computation and the
                        ** argument order to (*clip).
                        */
                        t = d1 / (d1 - d2);
                        (*clip)(&np2, b, a, t);
                        b = &np2;
                        b->flags = a->flags;

                        if (pRc->MCDState.shadeModel == GL_FLAT)
                        {
                            COPY_COLOR(b->colors[0], provokingB->colors[0]);
                        }

                    } else {
                        /* A and B are in */
                    }
                }
            }
            plane++;
            allClipCodes >>= 1;
        } while (allClipCodes);
    }

    vp = &pRc->MCDViewport;
    vpXCenter = vp->xCenter;
    vpYCenter = vp->yCenter;
    vpZCenter = vp->zCenter;
    vpXScale = vp->xScale;
    vpYScale = vp->yScale;
    vpZScale = vp->zScale;

    /* Compute window coordinates for both vertices. */
    wInv = __MCDONE / a->clipCoord.w;
    x = a->clipCoord.x; 
    y = a->clipCoord.y; 
    z = a->clipCoord.z;
    winx = x * vpXScale * wInv + vpXCenter;
    winy = y * vpYScale * wInv + vpYCenter;
    a->windowCoord.z = z * vpZScale * wInv + vpZCenter;
    a->windowCoord.w = wInv;
    a->windowCoord.x = winx;
    a->windowCoord.y = winy;

    wInv = __MCDONE / b->clipCoord.w;
    x = b->clipCoord.x; 
    y = b->clipCoord.y; 
    z = b->clipCoord.z;
    winx = x * vpXScale * wInv + vpXCenter;
    winy = y * vpYScale * wInv + vpYCenter;
    b->windowCoord.z = z * vpZScale * wInv + vpZCenter;
    b->windowCoord.w = wInv;
    b->windowCoord.x = winx;
    b->windowCoord.y = winy;

    /* Validate line state */
    if (pRc->MCDState.shadeModel == GL_FLAT) {

        // Add the vertices then restore the b color pointer
        //
        // Note that although b is the only new vertex, up
        // to two vertices can be added because each new vertex
        // generated by clipping must be added.  For a line where
        // both endpoints are out of the clipping region, both
        // an entry and an exit vertex must be added
        if (provokingA->clipCode != 0)
        {
            // a was out so a new vertex was added at the point of
            // entry
            bResetLine = TRUE;
        }
        // b is always added since either:
        // b was in and is new so it needs to be added
        // b was out so a new vertex was added at the exit point

        (*pRc->renderLine)(pRc, a, b, bResetLine);
        
    } else {

        if (provokingA->clipCode != 0)
        {
            bResetLine = TRUE;
        }
        (*pRc->renderLine)(pRc, a, b, bResetLine);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\lines.c ===
#include "precomp.h"

///////////////////////////////////////////////////////////////////////

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// UUInt32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit ULONGs to produce a 64-bit DWORDLONG result.
//
// UInt64By32To32 is our own macro to divide a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// UInt64Mod32To32 is our own macro to modulus a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// 64 bit divides are usually very expensive.  Since it's very rare
// that we'll get lines where the upper 32 bits of the 64 bit result
// are used, we can almost always use 32-bit ULONG divides.  We still
// must correctly handle the larger cases:

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define UInt64Mod32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) % (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) % (ULONG)(b)))

#define SWAPL(x,y,t)        {t = x; x = y; y = t;}

FLONG gaflRound[] = {
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // no flips
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_V
    FL_V_ROUND_DOWN,                   // FL_FLIP_V | FL_FLIP_D
    FL_V_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE
    0xbaadf00d,                        // FL_FLIP_SLOPE_ONE | FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE | FL_FLIP_V
    0xbaadf00d                         // FL_FLIP_SLOPE_ONE | FL_FLIP_V | FL_FLIP_D
};

BOOL bIntegerLine(PDEV*, ULONG, ULONG, ULONG, ULONG);
BOOL bHardwareLine(PDEV*, POINTFIX*, POINTFIX*);

/******************************Public*Routine******************************\
* BOOL bLines(ppdev, pptfxFirst, pptfxBuf, cptfx, pls,
*                   prclClip, apfn[], flStart)
*
* Computes the DDA for the line and gets ready to draw it.  Puts the
* pixel data into an array of strips, and calls a strip routine to
* do the actual drawing.
*
* Doing NT Lines Right
* --------------------
*
* In NT, all lines are given to the device driver in fractional
* coordinates, in a 28.4 fixed point format.  The lower 4 bits are
* fractional for sub-pixel positioning.
*
* Note that you CANNOT! just round the coordinates to integers
* and pass the results to your favorite integer Bresenham routine!!
* (Unless, of course, you have such a high resolution device that
* nobody will notice -- not likely for a display device.)  The
* fractions give a more accurate rendering of the line -- this is
* important for things like our Bezier curves, which would have 'kinks'
* if the points in its polyline approximation were rounded to integers.
*
* Unfortunately, for fractional lines there is more setup work to do
* a DDA than for integer lines.  However, the main loop is exactly
* the same (and can be done entirely with 32 bit math).
*
* If You've Got Hardware That Does Bresenham
* ------------------------------------------
*
* A lot of hardware limits DDA error terms to 'n' bits.  With fractional
* coordinates, 4 bits are given to the fractional part, letting
* you draw in hardware only those lines that lie entirely in a 2^(n-4)
* by 2^(n-4) pixel space.
*
* And you still have to correctly draw those lines with coordinates
* outside that space!  Remember that the screen is only a viewport
* onto a 28.4 by 28.4 space -- if any part of the line is visible
* you MUST render it precisely, regardless of where the end points lie.
* So even if you do it in software, somewhere you'll have to have a
* 32 bit DDA routine.
*
* Our Implementation
* ------------------
*
* We employ a run length slice algorithm: our DDA calculates the
* number of pixels that are in each row (or 'strip') of pixels.
*
* We've separated the running of the DDA and the drawing of pixels:
* we run the DDA for several iterations and store the results in
* a 'strip' buffer (which are the lengths of consecutive pixel rows of
* the line), then we crank up a 'strip drawer' that will draw all the
* strips in the buffer.
*
* We also employ a 'half-flip' to reduce the number of strip
* iterations we need to do in the DDA and strip drawing loops: when a
* (normalized) line's slope is more than 1/2, we do a final flip
* about the line y = (1/2)x.  So now, instead of each strip being
* consecutive horizontal or vertical pixel rows, each strip is composed
* of those pixels aligned in 45 degree rows.  So a line like (0, 0) to
* (128, 128) would generate only one strip.
*
* We also always draw only left-to-right.
*
* Styled lines may have arbitrary style patterns.  We specially
* optimize the default patterns (and call them 'masked' styles).
*
* The DDA Derivation
* ------------------
*
* Here is how I like to think of the DDA calculation.
*
* We employ Knuth's "diamond rule": rendering a one-pixel-wide line
* can be thought of as dragging a one-pixel-wide by one-pixel-high
* diamond along the true line.  Pixel centers lie on the integer
* coordinates, and so we light any pixel whose center gets covered
* by the "drag" region (John D. Hobby, Journal of the Association
* for Computing Machinery, Vol. 36, No. 2, April 1989, pp. 209-229).
*
* We must define which pixel gets lit when the true line falls
* exactly half-way between two pixels.  In this case, we follow
* the rule: when two pels are equidistant, the upper or left pel
* is illuminated, unless the slope is exactly one, in which case
* the upper or right pel is illuminated.  (So we make the edges
* of the diamond exclusive, except for the top and left vertices,
* which are inclusive, unless we have slope one.)
*
* This metric decides what pixels should be on any line BEFORE it is
* flipped around for our calculation.  Having a consistent metric
* this way will let our lines blend nicely with our curves.  The
* metric also dictates that we will never have one pixel turned on
* directly above another that's turned on.  We will also never have
* a gap; i.e., there will be exactly one pixel turned on for each
* column between the start and end points.  All that remains to be
* done is to decide how many pixels should be turned on for each row.
*
* So lines we draw will consist of varying numbers of pixels on
* successive rows, for example:
*
*       ******
*             *****
*                  ******
*                        *****
*
* We'll call each set of pixels on a row a "strip".
*
* (Please remember that our coordinate space has the origin as the
* upper left pixel on the screen; postive y is down and positive x
* is right.)
*
* Device coordinates are specified as fixed point 28.4 numbers,
* where the first 28 bits are the integer coordinate, and the last
* 4 bits are the fraction.  So coordinates may be thought of as
* having the form (x, y) = (M/F, N/F) where F is the constant scaling
* factor F = 2^4 = 16, and M and N are 32 bit integers.
*
* Consider the line from (M0/F, N0/F) to (M1/F, N1/F) which runs
* left-to-right and whose slope is in the first octant, and let
* dM = M1 - M0 and dN = N1 - N0.  Then dM >= 0, dN >= 0 and dM >= dN.
*
* Since the slope of the line is less than 1, the edges of the
* drag region are created by the top and bottom vertices of the
* diamond.  At any given pixel row y of the line, we light those
* pixels whose centers are between the left and right edges.
*
* Let mL(n) denote the line representing the left edge of the drag
* region.  On pixel row j, the column of the first pixel to be
* lit is
*
*       iL(j) = ceiling( mL(j * F) / F)
*
* Since the line's slope is less than one:
*
*       iL(j) = ceiling( mL([j + 1/2] F) / F )
*
* Recall the formula for our line:
*
*       n(m) = (dN / dM) (m - M0) + N0
*
*       m(n) = (dM / dN) (n - N0) + M0
*
* Since the line's slope is less than one, the line representing
* the left edge of the drag region is the original line offset
* by 1/2 pixel in the y direction:
*
*       mL(n) = (dM / dN) (n - F/2 - N0) + M0
*
* From this we can figure out the column of the first pixel that
* will be lit on row j, being careful of rounding (if the left
* edge lands exactly on an integer point, the pixel at that
* point is not lit because of our rounding convention):
*
*       iL(j) = floor( mL(j F) / F ) + 1
*
*             = floor( ((dM / dN) (j F - F/2 - N0) + M0) / F ) + 1
*
*             = floor( F dM j - F/2 dM - N0 dM + dN M0) / F dN ) + 1
*
*                      F dM j - [ dM (N0 + F/2) - dN M0 ]
*             = floor( ---------------------------------- ) + 1
*                                   F dN
*
*                      dM j - [ dM (N0 + F/2) - dN M0 ] / F
*             = floor( ------------------------------------ ) + 1       (1)
*                                     dN
*
*             = floor( (dM j + alpha) / dN ) + 1
*
* where
*
*       alpha = - [ dM (N0 + F/2) - dN M0 ] / F
*
* We use equation (1) to calculate the DDA: there are iL(j+1) - iL(j)
* pixels in row j.  Because we are always calculating iL(j) for
* integer quantities of j, we note that the only fractional term
* is constant, and so we can 'throw away' the fractional bits of
* alpha:
*
*       beta = floor( - [ dM (N0 + F/2) - dN M0 ] / F )                 (2)
*
* so
*
*       iL(j) = floor( (dM j + beta) / dN ) + 1                         (3)
*
* for integers j.
*
* Note if iR(j) is the line's rightmost pixel on row j, that
* iR(j) = iL(j + 1) - 1.
*
* Similarly, rewriting equation (1) as a function of column i,
* we can determine, given column i, on which pixel row j is the line
* lit:
*
*                       dN i + [ dM (N0 + F/2) - dN M0 ] / F
*       j(i) = ceiling( ------------------------------------ ) - 1
*                                       dM
*
* Floors are easier to compute, so we can rewrite this:
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F
*       j(i) = floor( ----------------------------------------------- ) - 1
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F - dM
*            = floor( ---------------------------------------------------- )
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 - 1 ] / F
*            = floor( ---------------------------------------- )
*                                       dM
*
* We can once again wave our hands and throw away the fractional bits
* of the remainder term:
*
*       j(i) = floor( (dN i + gamma) / dM )                             (4)
*
* where
*
*       gamma = floor( [ dM (N0 + F/2) - dN M0 - 1 ] / F )              (5)
*
* We now note that
*
*       beta = -gamma - 1 = ~gamma                                      (6)
*
* To draw the pixels of the line, we could evaluate (3) on every scan
* line to determine where the strip starts.  Of course, we don't want
* to do that because that would involve a multiply and divide for every
* scan.  So we do everything incrementally.
*
* We would like to easily compute c , the number of pixels on scan j:
*                                  j
*
*    c  = iL(j + 1) - iL(j)
*     j
*
*       = floor((dM (j + 1) + beta) / dN) - floor((dM j + beta) / dN)   (7)
*
* This may be rewritten as
*
*    c  = floor(i    + r    / dN) - floor(i  + r  / dN)                 (8)
*     j          j+1    j+1                j    j
*
* where i , i    are integers and r  < dN, r    < dN.
*        j   j+1                   j        j+1
*
* Rewriting (7) again:
*
*    c  = floor(i  + r  / dN + dM / dN) - floor(i  + r  / dN)
*     j          j    j                          j    j
*
*
*       = floor((r  + dM) / dN) - floor(r  / dN)
*                 j                      j
*
* This may be rewritten as
*
*    c  = dI + floor((r  + dR) / dN) - floor(r  / dN)
*     j                j                      j
*
* where dI + dR / dN = dM / dN, dI is an integer and dR < dN.
*
* r  is the remainder (or "error") term in the DDA loop: r  / dN
*  j                                                      j
* is the exact fraction of a pixel at which the strip ends.  To go
* on to the next scan and compute c    we need to know r   .
*                                  j+1                  j+1
*
* So in the main loop of the DDA:
*
*    c  = dI + floor((r  + dR) / dN) and r    = (r  + dR) % dN
*     j                j                  j+1     j
*
* and we know r  < dN, r    < dN, and dR < dN.
*              j        j+1
*
* We have derived the DDA only for lines in the first octant; to
* handle other octants we do the common trick of flipping the line
* to the first octant by first making the line left-to-right by
* exchanging the end-points, then flipping about the lines y = 0 and
* y = x, as necessary.  We must record the transformation so we can
* undo them later.
*
* We must also be careful of how the flips affect our rounding.  If
* to get the line to the first octant we flipped about x = 0, we now
* have to be careful to round a y value of 1/2 up instead of down as
* we would for a line originally in the first octant (recall that
* "In the case where two pels are equidistant, the upper or left
* pel is illuminated...").
*
* To account for this rounding when running the DDA, we shift the line
* (or not) in the y direction by the smallest amount possible.  That
* takes care of rounding for the DDA, but we still have to be careful
* about the rounding when determining the first and last pixels to be
* lit in the line.
*
* Determining The First And Last Pixels In The Line
* -------------------------------------------------
*
* Fractional coordinates also make it harder to determine which pixels
* will be the first and last ones in the line.  We've already taken
* the fractional coordinates into account in calculating the DDA, but
* the DDA cannot tell us which are the end pixels because it is quite
* happy to calculate pixels on the line from minus infinity to positive
* infinity.
*
* The diamond rule determines the start and end pixels.  (Recall that
* the sides are exclusive except for the left and top vertices.)
* This convention can be thought of in another way: there are diamonds
* around the pixels, and wherever the true line crosses a diamond,
* that pel is illuminated.
*
* Consider a line where we've done the flips to the first octant, and the
* floor of the start coordinates is the origin:
*
*        +-----------------------> +x
*        |
*        | 0                     1
*        |     0123456789abcdef
*        |
*        |   0 00000000?1111111
*        |   1 00000000 1111111
*        |   2 0000000   111111
*        |   3 000000     11111
*        |   4 00000    ** 1111
*        |   5 0000       ****1
*        |   6 000           1***
*        |   7 00             1  ****
*        |   8 ?                     ***
*        |   9 22             3         ****
*        |   a 222           33             ***
*        |   b 2222         333                ****
*        |   c 22222       3333                    **
*        |   d 222222     33333
*        |   e 2222222   333333
*        |   f 22222222 3333333
*        |
*        | 2                     3
*        v
*        +y
*
* If the start of the line lands on the diamond around pixel 0 (shown by
* the '0' region here), pixel 0 is the first pel in the line.  The same
* is true for the other pels.
*
* A little more work has to be done if the line starts in the
* 'nether-land' between the diamonds (as illustrated by the '*' line):
* the first pel lit is the first diamond crossed by the line (pixel 1 in
* our example).  This calculation is determined by the DDA or slope of
* the line.
*
* If the line starts exactly half way between two adjacent pixels
* (denoted here by the '?' spots), the first pixel is determined by our
* round-down convention (and is dependent on the flips done to
* normalize the line).
*
* Last Pel Exclusive
* ------------------
*
* To eliminate repeatedly lit pels between continuous connected lines,
* we employ a last-pel exclusive convention: if the line ends exactly on
* the diamond around a pel, that pel is not lit.  (This eliminates the
* checks we had in the old code to see if we were re-lighting pels.)
*
* The Half Flip
* -------------
*
* To make our run length algorithm more efficient, we employ a "half
* flip".  If after normalizing to the first octant, the slope is more
* than 1/2, we subtract the y coordinate from the x coordinate.  This
* has the effect of reflecting the coordinates through the line of slope
* 1/2.  Note that the diagonal gets mapped into the x-axis after a half
* flip.
*
* How Many Bits Do We Need, Anyway?
* ---------------------------------
*
* Note that if the line is visible on your screen, you must light up
* exactly the correct pixels, no matter where in the 28.4 x 28.4 device
* space the end points of the line lie (meaning you must handle 32 bit
* DDAs, you can certainly have optimized cases for lesser DDAs).
*
* We move the origin to (floor(M0 / F), floor(N0 / F)), so when we
* calculate gamma from (5), we know that 0 <= M0, N0 < F.  And we
* are in the first octant, so dM >= dN.  Then we know that gamma can
* be in the range [(-1/2)dM, (3/2)dM].  The DDI guarantees us that
* valid lines will have dM and dN values at most 31 bits (unsigned)
* of significance.  So gamma requires 33 bits of significance (we store
* this as a 64 bit number for convenience).
*
* When running through the DDA loop, r  + dR can have a value in the
*                                     j
* range 0 <= r  < 2 dN; thus the result must be a 32 bit unsigned value.
*             j
*
* Testing Lines
* -------------
*
* To be NT compliant, a display driver must exactly adhere to GIQ,
* which means that for any given line, the driver must light exactly
* the same pels as does GDI.  This can be tested using the Guiman tool
* provided elsewhere in the DDK, and 'ZTest', which draws random lines
* on the screen and to a bitmap, and compares the results.
*
* If You've Got Line Hardware
* ---------------------------
*
* If your hardware already adheres to GIQ, you're all set.  Otherwise
* you'll want to look at the S3 sample code and read the following:
*
* 1) You'll want to special case integer-only lines, since they require
*    less processing time and are more common (CAD programs will probably
*    only ever give integer lines).  GDI does not provide a flag saying
*    that all lines in a path are integer lines; consequently, you will
*    have to explicitly check every line.
*
* 2) You are required to correctly draw any line in the 28.4 device
*    space that intersects the viewport.  If you have less than 32 bits
*    of significance in the hardware for the Bresenham terms, extremely
*    long lines would overflow the hardware.  For such (rare) cases, you
*    can fall back to strip-drawing code (or if your display is a frame
*    buffer, fall back to the engine).
*
* 3) If you can explicitly set the Bresenham terms in your hardware, you
*    can draw non-integer lines using the hardware.  If your hardware has
*    'n' bits of precision, you can draw GIQ lines that are up to 2^(n-5)
*    pels long (4 bits are required for the fractional part, and one bit is
*    used as a sign bit).  Note that integer lines don't require the 4
*    fractional bits, so if you special case them as in 1), you can do
*    integer lines that are up to 2^(n - 1) pels long.  See the
*    'bHardwareLine' routine for an example.
*
\**************************************************************************/

BOOL bLines(
PDEV*	   ppdev,
POINTFIX*  pptfxFirst,  // Start of first line
POINTFIX*  pptfxBuf,    // Pointer to buffer of all remaining lines
RUN*       prun,        // Pointer to runs if doing complex clipping
ULONG      cptfx,       // Number of points in pptfxBuf or number of runs
                        // in prun
LINESTATE* pls,         // Colour and style info
RECTL*     prclClip,    // Pointer to clip rectangle if doing simple clipping
PFNSTRIP   apfn[],      // Array of strip functions
FLONG      flStart)     // Flags for each line, which is a combination of:
                        //      FL_SIMPLE_CLIP
                        //      FL_COMPLEX_CLIP
                        //      FL_STYLED
                        //      FL_LAST_PEL_INCLUSIVE
                        //        - Should be set only for all integer lines,
                        //          and can't be used with FL_COMPLEX_CLIP
{
    ULONG     M0;
    ULONG     dM;
    ULONG     N0;
    ULONG     dN;
    ULONG     dN_Original;
    FLONG     fl;
    LONG      x;
    LONG      y;

    LONGLONG  llBeta;
    LONGLONG  llGamma;
    LONGLONG  dl;
    LONGLONG  ll;

    ULONG     ulDelta;

    ULONG     x0;
    ULONG     y0;
    ULONG     x1;
    ULONG     cStylePels;    // Major length of line in pixels for styling
    ULONG     xStart;
    POINTL    ptlStart;
    STRIP     strip;
    PFNSTRIP  pfn;
    LONG      cPels;
    LONG*     plStrip;
    LONG*     plStripEnd;
    LONG      cStripsInNextRun;

    POINTFIX* pptfxBufEnd = pptfxBuf + cptfx; // Last point in path record
    STYLEPOS  spThis;                         // Style pos for this line

    do {

/***********************************************************************\
* Start the DDA calculations.                                           *
\***********************************************************************/

        M0 = (LONG) pptfxFirst->x;
        dM = (LONG) pptfxBuf->x;

        N0 = (LONG) pptfxFirst->y;
        dN = (LONG) pptfxBuf->y;

        fl = flStart;

	// Check for non-clipped, non-styled integer endpoint lines

        if ((fl & (FL_CLIP | FL_STYLED)) == 0)
        {
            // Special-case integer end-point lines:

#ifdef S3
#if !defined(i386)

	    if (((M0 | dM | N0 | dN) & (F - 1)) == 0)
            {
                if (bIntegerLine(ppdev, M0, N0, dM, dN))
                {
                    goto Next_Line;
                }
            }
            else

#endif
#endif

            // Check for fractional endpoint lines that are small enough
            // to use the hardware DDA:
#ifdef S3
            if (bHardwareLine(ppdev, pptfxFirst, pptfxBuf))
            {
                goto Next_Line;
            }
#endif
        }
	
        if ((LONG) M0 > (LONG) dM)
        {
        // Ensure that we run left-to-right:

            register ULONG ulTmp;
            SWAPL(M0, dM, ulTmp);
            SWAPL(N0, dN, ulTmp);
            fl |= FL_FLIP_H;
        }

    // Compute the delta dx.  The DDI says we can never have a valid delta
    // with a magnitued more than 2^31 - 1, but GDI never actually checks
    // its transforms.  So we have to check for this case to avoid overflow:

        dM -= M0;
        if ((LONG) dM < 0)
        {
            goto Next_Line;
        }

        if ((LONG) dN < (LONG) N0)
        {
        // Line runs from bottom to top, so flip across y = 0:

            N0 = -(LONG) N0;
            dN = -(LONG) dN;
            fl |= FL_FLIP_V;
        }

        dN -= N0;

        if ((LONG) dN < 0)
        {
            goto Next_Line;
        }

    // We now have a line running left-to-right, top-to-bottom from (M0, N0)
    // to (M0 + dM, N0 + dN):

        if (dN >= dM)
        {
            if (dN == dM)
            {
            // Have to special case slopes of one:

                fl |= FL_FLIP_SLOPE_ONE;
            }
            else
            {
            // Since line has slope greater than 1, flip across x = y:

                register ULONG ulTmp;
                SWAPL(dM, dN, ulTmp);
                SWAPL(M0, N0, ulTmp);
                fl |= FL_FLIP_D;
            }
        }

        fl |= gaflRound[(fl & FL_ROUND_MASK) >> FL_ROUND_SHIFT];

        x = LFLOOR((LONG) M0);
        y = LFLOOR((LONG) N0);

        M0 = FXFRAC(M0);
        N0 = FXFRAC(N0);

    // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ]:

        llGamma = UInt32x32To64(dM, N0 + F/2) - UInt32x32To64(M0, dN);
        if (fl & FL_V_ROUND_DOWN)   // Adjust so y = 1/2 rounds down
        {
            llGamma--;
        }

        llGamma >>= FLOG2;
        llBeta = ~llGamma;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.                  *
\***********************************************************************/

    // The toughest part of GIQ is determining the start and end pels.
    //
    // Our approach here is to calculate x0 and x1 (the inclusive start
    // and end columns of the line respectively, relative to our normalized
    // origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
    // start point is easily calculated by plugging x0 into our line equation
    // (which takes care of whether y = 1/2 rounds up or down in value)
    // getting y0, and then undoing the normalizing flips to get back
    // into device space.
    //
    // We look at the fractional parts of the coordinates of the start and
    // end points, and call them (M0, N0) and (M1, N1) respectively, where
    // 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
    // to determine x0:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 ........?xxxxxxx
    //   |   1 ..........xxxxxx
    //   |   2 ...........xxxxx
    //   |   3 ............xxxx
    //   |   4 .............xxx
    //   |   5 ..............xx
    //   |   6 ...............x
    //   |   7 ................
    //   |   8 ................
    //   |   9 ......**........
    //   |   a ........****...x
    //   |   b ............****
    //   |   c .............xxx****
    //   |   d ............xxxx    ****
    //   |   e ...........xxxxx        ****
    //   |   f ..........xxxxxx
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one require a special case for both the start
    // and end.  For example, if the line ends such that (M1, N1) is (9, 1),
    // the line has gone exactly through (8, 0) -- which may be considered
    // to be part of 'x' because of rounding!  So slopes of exactly slope
    // one going through (8, 0) must also be considered as belonging in 'x'.
    //
    // For lines that go left-to-right, we have the following grid:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 xxxxxxxx?.......
    //   |   1 xxxxxxx.........
    //   |   2 xxxxxx..........
    //   |   3 xxxxx...........
    //   |   4 xxxx............
    //   |   5 xxx.............
    //   |   6 xx..............
    //   |   7 x...............
    //   |   8 x...............
    //   |   9 x.....**........
    //   |   a xx......****....
    //   |   b xxx.........****
    //   |   c xxxx............****
    //   |   d xxxxx...........    ****
    //   |   e xxxxxx..........        ****
    //   |   f xxxxxxx.........
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 0.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) - 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one must be handled similarly to the right-to-
    // left case.

        {

        // Calculate x0, x1

            ULONG N1 = FXFRAC(N0 + dN);
	    ULONG M1 = FXFRAC(M0 + dM);

	    x1 = LFLOOR(M0 + dM);

            if (fl & FL_LAST_PEL_INCLUSIVE)
            {
            // It sure is easy to compute the first pel when lines have only
            // integer coordinates and are last-pel inclusive:

                x0 = 0;
                y0 = 0;

            // Last-pel inclusive lines that are exactly one pixel long
            // have a 'delta-x' and 'delta-y' equal to zero.  The problem is
            // that our clip code assumes that 'delta-x' is always non-zero
            // (since it never happens with last-pel exclusive lines).  As
            // an inelegant solution, we simply modify 'delta-x' in this
            // case -- because the line is exactly one pixel long, changing
            // the slope will obviously have no effect on rasterization.

                if (x1 == 0)
                {
                    dM      = 1;
                    llGamma = 0;
                    llBeta  = ~llGamma;
                }
            }
            else
            {
                if (fl & FL_FLIP_H)
                {
                // ---------------------------------------------------------------
                // Line runs right-to-left:  <----

                // Compute x1:

                    if (N1 == 0)
                    {
                        if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                        {
                            x1++;
                        }
                    }
                    else if (abs((LONG) (N1 - F/2)) + M1 > F)
                    {
                        x1++;
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((N1 > 0) && (M1 == N1 + 8))
                            x1++;

                    // Don't you love special cases?  Is this a rhetorical question?

                        if ((N0 > 0) && (M0 == N0 + 8))
                        {
                            x0      = 2;
                            ulDelta = dN;
                            goto right_to_left_compute_y0;
                        }
                    }

                // Compute x0:

                    x0      = 1;
                    ulDelta = 0;
                    if (N0 == 0)
                    {
                        if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                        {
                            x0      = 2;
                            ulDelta = dN;
                        }
                    }
                    else if (abs((LONG) (N0 - F/2)) + M0 > F)
                    {
                        x0      = 2;
                        ulDelta = dN;
                    }


                // Compute y0:

                right_to_left_compute_y0:

                    y0 = 0;
                    ll = llGamma + (LONGLONG) ulDelta;

                    if (ll >= (LONGLONG) (2 * dM - dN))
                        y0 = 2;
                    else if (ll >= (LONGLONG) (dM - dN))
                        y0 = 1;
                }
                else
                {
                // ---------------------------------------------------------------
                // Line runs left-to-right:  ---->

                // Compute x1:

                    if (!(fl & FL_LAST_PEL_INCLUSIVE))
                        x1--;

                    if (M1 > 0)
                    {
                        if (N1 == 0)
                        {
                            if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                                x1++;
                        }
                        else if (abs((LONG) (N1 - F/2)) <= (LONG) M1)
                        {
                            x1++;
                        }
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((M1 > 0) && (N1 == M1 + 8))
                            x1--;

                        if ((M0 > 0) && (N0 == M0 + 8))
                        {
                            x0 = 0;
                            goto left_to_right_compute_y0;
                        }
                    }

                // Compute x0:

                    x0 = 0;
                    if (M0 > 0)
                    {
                        if (N0 == 0)
                        {
                            if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                                x0 = 1;
                        }
                        else if (abs((LONG) (N0 - F/2)) <= (LONG) M0)
                        {
                            x0 = 1;
                        }
                    }

                // Compute y0:

                left_to_right_compute_y0:

                    y0 = 0;
                    if (llGamma >= (LONGLONG) (dM - (dN & (-(LONG) x0))))
                    {
                        y0 = 1;
                    }
                }
            }
        }

        cStylePels = x1 - x0 + 1;
        if ((LONG) cStylePels <= 0)
            goto Next_Line;

        xStart = x0;

/***********************************************************************\
* Complex clipping.                                                     *
\***********************************************************************/

        if (fl & FL_COMPLEX_CLIP)
        {
            dN_Original = dN;

        Continue_Complex_Clipping:

            if (fl & FL_FLIP_H)
            {
            // Line runs right-to-left <-----

                x0 = xStart + cStylePels - prun->iStop - 1;
                x1 = xStart + cStylePels - prun->iStart - 1;
            }
            else
            {
            // Line runs left-to-right ----->

                x0 = xStart + prun->iStart;
                x1 = xStart + prun->iStop;
            }

            prun++;

        // Reset some variables we'll nuke a little later:

            dN          = dN_Original;
            pls->spNext = pls->spComplex;

        // No overflow since large integer math is used.  Both values
        // will be positive:

            dl = UInt32x32To64(x0, dN) + llGamma;

        // y0 = dl / dM:

            y0 = UInt64Div32To32(dl, dM);

            ASSERTDD((LONG) y0 >= 0, "y0 weird: Goofed up end pel calc?");
        }

/***********************************************************************\
* Simple rectangular clipping.                                          *
\***********************************************************************/

        if (fl & FL_SIMPLE_CLIP)
        {
            ULONG y1;
            LONG  xRight;
            LONG  xLeft;
            LONG  yBottom;
            LONG  yTop;

        // Note that y0 and y1 are actually the lower and upper bounds,
        // respectively, of the y coordinates of the line (the line may
        // have actually shrunk due to first/last pel clipping).
        //
        // Also note that x0, y0 are not necessarily zero.

            RECTL* prcl = &prclClip[(fl & FL_RECTLCLIP_MASK) >>
                                    FL_RECTLCLIP_SHIFT];

        // Normalize to the same point we've normalized for the DDA
        // calculations:

            xRight  = prcl->right  - x;
            xLeft   = prcl->left   - x;
            yBottom = prcl->bottom - y;
            yTop    = prcl->top    - y;

            if (yBottom <= (LONG) y0 ||
                xRight  <= (LONG) x0 ||
                xLeft   >  (LONG) x1)
            {
            Totally_Clipped:

                if (fl & FL_STYLED)
                {
                    pls->spNext += cStylePels;
                    if (pls->spNext >= pls->spTotal2)
                        pls->spNext %= pls->spTotal2;
                }

                goto Next_Line;
            }

            if ((LONG) x1 >= xRight)
                x1 = xRight - 1;

        // We have to know the correct y1, which we haven't bothered to
        // calculate up until now.  This multiply and divide is quite
        // expensive; we could replace it with code similar to that which
        // we used for computing y0.
        //
        // The reason why we need the actual value, and not an upper
        // bounds guess like y1 = LFLOOR(dM) + 2 is that we have to be
        // careful when calculating x(y) that y0 <= y <= y1, otherwise
        // we can overflow on the divide (which, needless to say, is very
        // bad).

            dl = UInt32x32To64(x1, dN) + llGamma;

        // y1 = dl / dM:

            y1 = UInt64Div32To32(dl, dM);

            if (yTop > (LONG) y1)
                goto Totally_Clipped;

            if (yBottom <= (LONG) y1)
            {
                y1 = yBottom;
                dl = UInt32x32To64(y1, dM) + llBeta;

            // x1 = dl / dN:

                x1 = UInt64Div32To32(dl, dN);
            }

        // At this point, we've taken care of calculating the intercepts
        // with the right and bottom edges.  Now we work on the left and
        // top edges:

            if (xLeft > (LONG) x0)
            {
                x0 = xLeft;
                dl = UInt32x32To64(x0, dN) + llGamma;

            // y0 = dl / dM;

                y0 = UInt64Div32To32(dl, dM);

                if (yBottom <= (LONG) y0)
                    goto Totally_Clipped;
            }

            if (yTop > (LONG) y0)
            {
                y0 = yTop;
                dl = UInt32x32To64(y0, dM) + llBeta;

            // x0 = dl / dN + 1;

                x0 = UInt64Div32To32(dl, dN) + 1;

                if (xRight <= (LONG) x0)
                    goto Totally_Clipped;
            }

            ASSERTDD(x0 <= x1, "Improper rectangle clip");
        }

/***********************************************************************\
* Done clipping.  Unflip if necessary.                                 *
\***********************************************************************/

        ptlStart.x = x + x0;
        ptlStart.y = y + y0;

        if (fl & FL_FLIP_D)
        {
            register LONG lTmp;
            SWAPL(ptlStart.x, ptlStart.y, lTmp);
        }


        if (fl & FL_FLIP_V)
        {
            ptlStart.y = -ptlStart.y;
        }

        cPels = x1 - x0 + 1;

/***********************************************************************\
* Style calculations.                                                   *
\***********************************************************************/

        if (fl & FL_STYLED)
        {
            STYLEPOS sp;

            spThis       = pls->spNext;
            pls->spNext += cStylePels;

            {
                if (pls->spNext >= pls->spTotal2)
                    pls->spNext %= pls->spTotal2;

                if (fl & FL_FLIP_H)
                    sp = pls->spNext - x0 + xStart;
                else
                    sp = spThis + x0 - xStart;

                ASSERTDD(fl & FL_STYLED, "Oops");

            // Normalize our target style position:

                if ((sp < 0) || (sp >= pls->spTotal2))
                {
                    sp %= pls->spTotal2;

                // The modulus of a negative number is not well-defined
                // in C -- if it's negative we'll adjust it so that it's
                // back in the range [0, spTotal2):

                    if (sp < 0)
                        sp += pls->spTotal2;
                }

            // Since we always draw the line left-to-right, but styling is
            // always done in the direction of the original line, we have
            // to figure out where we are in the style array for the left
            // edge of this line.

                if (fl & FL_FLIP_H)
                {
                // Line originally ran right-to-left:

                    sp = -sp;
                    if (sp < 0)
                        sp += pls->spTotal2;

                    pls->ulStyleMask = ~pls->ulStartMask;
                    pls->pspStart    = &pls->aspRtoL[0];
                    pls->pspEnd      = &pls->aspRtoL[pls->cStyle - 1];
                }
                else
                {
                // Line originally ran left-to-right:

                    pls->ulStyleMask = pls->ulStartMask;
                    pls->pspStart    = &pls->aspLtoR[0];
                    pls->pspEnd      = &pls->aspLtoR[pls->cStyle - 1];
                }

                if (sp >= pls->spTotal)
                {
                    sp -= pls->spTotal;
                    if (pls->cStyle & 1)
                        pls->ulStyleMask = ~pls->ulStyleMask;
                }

                pls->psp = pls->pspStart;
                while (sp >= *pls->psp)
                    sp -= *pls->psp++;

                ASSERTDD(pls->psp <= pls->pspEnd,
                        "Flew off into NeverNeverLand");

                pls->spRemaining = *pls->psp - sp;
                if ((pls->psp - pls->pspStart) & 1)
                    pls->ulStyleMask = ~pls->ulStyleMask;
            }
        }

        plStrip    = &strip.alStrips[0];
        plStripEnd = &strip.alStrips[STRIP_MAX];    // Is exclusive
        cStripsInNextRun   = 0x7fffffff;

	strip.ptlStart = ptlStart;

#ifdef S3
//
//	We cannot due diagonal lines without a DDA.  Therefore don't let it happen
//

        if (2 * dN > dM &&
            !(fl & FL_STYLED))
        {
        // Do a half flip!  Remember that we may doing this on the
        // same line multiple times for complex clipping (meaning the
        // affected variables should be reset for every clip run):

            fl |= FL_FLIP_HALF;

            llBeta  = llGamma - (LONGLONG) ((LONG) dM);
            dN = dM - dN;
            y0 = x0 - y0;       // Note this may overflow, but that's okay
        }
#endif

    // Now, run the DDA starting at (ptlStart.x, ptlStart.y)!

        strip.flFlips = fl;
        pfn           = apfn[(fl & FL_STRIP_MASK) >> FL_STRIP_SHIFT];

    // Now calculate the DDA variables needed to figure out how many pixels
    // go in the very first strip:

        {
            register LONG  i;
            register ULONG dI;
            register ULONG dR;
                     ULONG r;

            if (dN == 0)
                i = 0x7fffffff;
            else
            {
                dl = UInt32x32To64(y0 + 1, dM) + llBeta;

                ASSERTDD(dl >= 0, "Oops!");

            // i = (dl / dN) - x0 + 1;
            // r = (dl % dN);

                i = UInt64Div32To32(dl, dN);
                r = UInt64Mod32To32(dl, dN);
                i = i - x0 + 1;

                dI = dM / dN;
                dR = dM % dN;               // 0 <= dR < dN

                ASSERTDD(dI > 0, "Weird dI");
            }

            ASSERTDD(i > 0 && i <= 0x7fffffff, "Weird initial strip length");
            ASSERTDD(cPels > 0, "Zero pel line");

/***********************************************************************\
* Run the DDA!                                                          *
\***********************************************************************/

            while(TRUE)
            {
                cPels -= i;
                if (cPels <= 0)
                    break;

                *plStrip++ = i;

                if (plStrip == plStripEnd)
                {
                    strip.cStrips = plStrip - &strip.alStrips[0];
                    (*pfn)(ppdev, &strip, pls);
                    plStrip = &strip.alStrips[0];
                }

                i = dI;
                r += dR;

                if (r >= dN)
                {
                    r -= dN;
                    i++;
                }
            }

            *plStrip++ = cPels + i;

            strip.cStrips = plStrip - &strip.alStrips[0];
            (*pfn)(ppdev, &strip, pls);


        }

    Next_Line:

        if (fl & FL_COMPLEX_CLIP)
        {
            cptfx--;
            if (cptfx != 0)
                goto Continue_Complex_Clipping;

            break;
        }
        else
        {
            pptfxFirst = pptfxBuf;
            pptfxBuf++;
        }

    } while (pptfxBuf < pptfxBufEnd);

    return(TRUE);

}


#ifdef S3
//////////////////////////////////////////////////////////////////////////
// General defines for bHardwareLine

#define HW_FLIP_D           0x0001L     // Diagonal flip
#define HW_FLIP_V           0x0002L     // Vertical flip
#define HW_FLIP_H           0x0004L     // Horizontal flip
#define HW_FLIP_SLOPE_ONE   0x0008L     // Normalized line has exactly slope one
#define HW_FLIP_MASK        (HW_FLIP_D | HW_FLIP_V | HW_FLIP_H)

#define HW_X_ROUND_DOWN     0x0100L     // x = 1/2 rounds down in value
#define HW_Y_ROUND_DOWN     0x0200L     // y = 1/2 rounds down in value

LONG gaiDir[] = { 0, 1, 7, 6, 3, 2, 4, 5 };

FLONG gaflHardwareRound[] = {
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        |
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    //           |        | FLIP_V |
    HW_Y_ROUND_DOWN,                    //           |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    //           | FLIP_H |        |
    HW_X_ROUND_DOWN,                    //           | FLIP_H |        | FLIP_D
    0,                                  //           | FLIP_H | FLIP_V |
    0,                                  //           | FLIP_H | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE |        |        |
    0xffffffff,                         // SLOPE_ONE |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE |        | FLIP_V |
    0xffffffff,                         // SLOPE_ONE |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H |        |
    0xffffffff,                         // SLOPE_ONE | FLIP_H |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H | FLIP_V |
    0xffffffff                          // SLOPE_ONE | FLIP_H | FLIP_V | FLIP_D
};

//////////////////////////////////////////////////////////////////////////
// S3 specific defines

#define DEFAULT_DRAW_CMD (DRAW_LINE | DRAW | DIR_TYPE_XY | MULTIPLE_PIXELS | \
                          WRITE | LAST_PIXEL_OFF)

LONG gaiDrawCmd[] = {
    DEFAULT_DRAW_CMD | PLUS_X | PLUS_Y |       0,   // Octant 0
    DEFAULT_DRAW_CMD | PLUS_X | PLUS_Y | MAJOR_Y,   // Octant 1
    DEFAULT_DRAW_CMD | PLUS_X |      0 |       0,   // Octant 7
    DEFAULT_DRAW_CMD | PLUS_X |      0 | MAJOR_Y,   // Octant 6
    DEFAULT_DRAW_CMD | 0      | PLUS_Y |       0,   // Octant 3
    DEFAULT_DRAW_CMD | 0      | PLUS_Y | MAJOR_Y,   // Octant 2
    DEFAULT_DRAW_CMD | 0      |      0 |       0,   // Octant 4
    DEFAULT_DRAW_CMD | 0      |      0 | MAJOR_Y,   // Octant 5
};

// The S3's hardware can have 13 bits of significance for the error and
// step terms:

#define NUM_DDA_BITS 13

/******************************Public*Routine******************************\
* BOOL bHardwareLine(ppdev, pptfxStart, pptfxEnd)
*
* This routine is useful for folks who have line drawing hardware where
* they can explicitly set the Bresenham terms -- they can use this routine
* to draw fractional coordinate GIQ lines with the hardware.
*
* Fractional coordinate lines require an extra 4 bits of precision in the
* Bresenham terms.  For example, if your hardware has 13 bits of precision
* for the terms, you can only draw GIQ lines up to 255 pels long using this
* routine.
*
* Input:
*   pptfxStart  - Points to GIQ coordinate of start of line
*   pptfxEnd    - Points to GIQ coordinate of end of line
*   NUM_DDA_BITS- The number of bits of precision your hardware can support.
*
* Output:
*   returns     - TRUE if the line was drawn.
*                 FALSE if the line is too long, and the strips code must be
*                 used.
*
* DDALINE:
*   iDir        - Direction of the line, as an octant numbered as follows:
*
*                    \ 5 | 6 /
*                     \  |  /
*                    4 \ | / 7
*                       \ /
*                   -----+-----
*                       /|\
*                    3 / | \ 0
*                     /  |  \
*                    / 2 | 1 \
*
*   ptlStart    - Start pixel of line.
*   cPels       - # of pels in line.  *NOTE* You must check if this is <= 0!
*   dMajor      - Major axis delta.
*   dMinor      - Minor axis delta.
*   lErrorTerm  - Error term.
*
* What you do with the last 3 terms may be a little tricky.  They are
* actually the terms for the formula of the normalized line
*
*                     dMinor * x + (lErrorTerm + dMajor)
*       y(x) = floor( ---------------------------------- )
*                                  dMajor
*
* where y(x) is the y coordinate of the pixel to be lit as a function of
* the x-coordinate.
*
* Every time the line advances one in the major direction 'x', dMinor
* gets added to the current error term.  If the resulting value is >= 0,
* we know we have to move one pixel in the minor direction 'y', and
* dMajor must be subtracted from the current error term.
*
* If you're trying to figure out what this means for your hardware, you can
* think of the DDALINE terms as having been computed equivalently as
* follows:
*
*     dMinor     = 2 * (minor axis delta)
*     dMajor     = 2 * (major axis delta)
*     lErrorTerm = - (major axis delta) - fixup
*
* That is, if your documentation tells you that for integer lines, a
* register is supposed to be initialized with the value
* '2 * (minor axis delta)', you'll actually use dMinor.
*
* Example: Setting up the 8514
*
*     AXSTPSIGN is supposed to be the axial step constant register, defined
*     as 2 * (minor axis delta).  You set:
*
*           AXSTPSIGN = dMinor
*
*     DGSTPSIGN is supposed to be the diagonal step constant register,
*     defined as 2 * (minor axis delta) - 2 * (major axis delta).  You set:
*
*           DGSTPSIGN = dMinor - dMajor
*
*     ERR_TERM is supposed to be the adjusted error term, defined as
*     2 * (minor axis delta) - (major axis delta) - fixup.  You set:
*
*           ERR_TERM = lErrorTerm + dMinor
*
* Implementation:
*
*     You'll want to special case integer lines before calling this routine
*     (since they're very common, take less time to the computation of line
*     terms, and can handle longer lines than this routine because 4 bits
*     aren't being given to the fraction).
*
*     If a GIQ line is too long to be handled by this routine, you can just
*     use the slower strip routines for that line.  Note that you cannot
*     just fail the call -- you must be able to accurately draw any line
*     in the 28.4 device space when it intersects the viewport.
*
* Testing:
*
*     Use Guiman, or some other test that draws random fractional coordinate
*     lines and compares them to what GDI itself draws to a bitmap.
*
\**************************************************************************/

BOOL bHardwareLine(
PDEV*     ppdev,
POINTFIX* pptfxStart,       // Start of line
POINTFIX* pptfxEnd)         // End of line
{
    FLONG fl;    // Various flags
    ULONG M0;    // Normalized fractional unit x start coordinate (0 <= M0 < F)
    ULONG N0;    // Normalized fractional unit y start coordinate (0 <= N0 < F)
    ULONG M1;    // Normalized fractional unit x end coordinate (0 <= M1 < F)
    ULONG N1;    // Normalized fractional unit x end coordinate (0 <= N1 < F)
    ULONG dM;    // Normalized fractional unit x-delta (0 <= dM)
    ULONG dN;    // Normalized fractional unit y-delta (0 <= dN <= dM)
    LONG  x;     // Normalized x coordinate of origin
    LONG  y;     // Normalized y coordinate of origin
    LONG  x0;    // Normalized x offset from origin to start pixel (inclusive)
    LONG  y0;    // Normalized y offset from origin to start pixel (inclusive)
    LONG  x1;    // Normalized x offset from origin to end pixel (inclusive)
    LONG  lGamma;// Bresenham error term at origin
    LONG  cPels; // Number of pixels in line

/***********************************************************************\
* Normalize line to the first octant.
\***********************************************************************/

    fl = 0;

    M0 = pptfxStart->x;
    dM = pptfxEnd->x;

    if ((LONG) dM < (LONG) M0)
    {
    // Line runs from right to left, so flip across x = 0:

        M0 = -(LONG) M0;
        dM = -(LONG) dM;
        fl |= HW_FLIP_H;
    }

// Compute the delta.  The DDI says we can never have a valid delta
// with a magnitude more than 2^31 - 1, but the engine never actually
// checks its transforms.  To ensure that we'll never puke on our shoes,
// we check for that case and simply refuse to draw the line:

    dM -= M0;
    if ((LONG) dM < 0)
        return(FALSE);

    N0 = pptfxStart->y;
    dN = pptfxEnd->y;

    if ((LONG) dN < (LONG) N0)
    {
    // Line runs from bottom to top, so flip across y = 0:

        N0 = -(LONG) N0;
        dN = -(LONG) dN;
        fl |= HW_FLIP_V;
    }

// Compute another delta:

    dN -= N0;
    if ((LONG) dN < 0)
        return(FALSE);

    if (dN >= dM)
    {
        if (dN == dM)
        {
        // Have to special case slopes of one:

            fl |= HW_FLIP_SLOPE_ONE;
        }
        else
        {
        // Since line has slope greater than 1, flip across x = y:

            register ULONG ulTmp;
            ulTmp = dM; dM = dN; dN = ulTmp;
            ulTmp = M0; M0 = N0; N0 = ulTmp;
            fl |= HW_FLIP_D;
        }
    }

// Figure out if we can do the line in hardware, given that we have a
// limited number of bits of precision for the Bresenham terms.
//
// Remember that one bit has to be kept as a sign bit:

    if ((LONG) dM >= (1L << (NUM_DDA_BITS - 1)))
        return(FALSE);

    fl |= gaflHardwareRound[fl];

/***********************************************************************\
* Calculate the error term at pixel 0.
\***********************************************************************/

    x = LFLOOR((LONG) M0);
    y = LFLOOR((LONG) N0);

    M0 = FXFRAC(M0);
    N0 = FXFRAC(N0);

// NOTE NOTE NOTE: If this routine were to handle any line in the 28.4
// space, it will overflow its math (the following part requires 36 bits
// of precision)!  But we get here for lines that the hardware can handle
// (see the expression (dM >= (1L << (NUM_DDA_BITS - 1))) above?), so if
// cBits is less than 28, we're safe.
//
// If you're going to use this routine to handle all lines in the 28.4
// device space, you will HAVE to make sure the math doesn't overflow,
// otherwise you won't be NT compliant!  (See 'bHardwareLine' for an example
// how to do that.  You don't have to worry about this if you simply
// default to the strips code for long lines, because those routines
// already do the math correctly.)

// Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ].  Note
// that M0 and N0 have at most 4 bits of significance (and if the
// arguments are properly ordered, on a 486 each multiply would be no
// more than 13 cycles):

    lGamma = (N0 + F/2) * dM - M0 * dN;

    if (fl & HW_Y_ROUND_DOWN)
        lGamma--;

    lGamma >>= FLOG2;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.
\***********************************************************************/

// The toughest part of GIQ is determining the start and end pels.
//
// Our approach here is to calculate x0 and x1 (the inclusive start
// and end columns of the line respectively, relative to our normalized
// origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
// start point is easily calculated by plugging x0 into our line equation
// (which takes care of whether y = 1/2 rounds up or down in value)
// getting y0, and then undoing the normalizing flips to get back
// into device space.
//
// We look at the fractional parts of the coordinates of the start and
// end points, and call them (M0, N0) and (M1, N1) respectively, where
// 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
// to determine x0:
//
//   +-----------------------> +x
//   |
//   | 0                     1
//   |     0123456789abcdef
//   |
//   |   0 ........?xxxxxxx
//   |   1 ..........xxxxxx
//   |   2 ...........xxxxx
//   |   3 ............xxxx
//   |   4 .............xxx
//   |   5 ..............xx
//   |   6 ...............x
//   |   7 ................
//   |   8 ................
//   |   9 ......**........
//   |   a ........****...x
//   |   b ............****
//   |   c .............xxx****
//   |   d ............xxxx    ****
//   |   e ...........xxxxx        ****
//   |   f ..........xxxxxx
//   |
//   | 2                     3
//   v
//
//   +y
//
// This grid accounts for the appropriate rounding of GIQ and last-pel
// exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
// on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
// depending on what flips have been done to normalize the line.
//
// For the end point, if (M1, N1) lands on an 'x', x1 =
// floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
// floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
// depending on what flips have been done to normalize the line.
//
// Lines of exactly slope one require a special case for both the start
// and end.  For example, if the line ends such that (M1, N1) is (9, 1),
// the line has gone exactly through (8, 0) -- which may be considered
// to be part of 'x' because of rounding!  So slopes of exactly slope
// one going through (8, 0) must also be considered as belonging in 'x'
// when an x value of 1/2 is supposed to round up in value.

// Calculate x0, x1:

    N1 = FXFRAC(N0 + dN);
    M1 = FXFRAC(M0 + dM);

    x1 = LFLOOR(M0 + dM);

// Line runs left-to-right:

// Compute x1:

    x1--;
    if (M1 > 0)
    {
        if (N1 == 0)
        {
            if (LROUND(M1, fl & HW_X_ROUND_DOWN))
                x1++;
        }
        else if (abs((LONG) (N1 - F/2)) <= (LONG) M1)
        {
            x1++;
        }
    }

    if ((fl & (HW_FLIP_SLOPE_ONE | HW_X_ROUND_DOWN))
           == (HW_FLIP_SLOPE_ONE | HW_X_ROUND_DOWN))
    {
    // Have to special-case diagonal lines going through our
    // the point exactly equidistant between two horizontal
    // pixels, if we're supposed to round x=1/2 down:

        if ((M1 > 0) && (N1 == M1 + 8))
            x1--;

        if ((M0 > 0) && (N0 == M0 + 8))
        {
            x0 = 0;
            goto left_to_right_compute_y0;
        }
    }

// Compute x0:

    x0 = 0;
    if (M0 > 0)
    {
        if (N0 == 0)
        {
            if (LROUND(M0, fl & HW_X_ROUND_DOWN))
                x0 = 1;
        }
        else if (abs((LONG) (N0 - F/2)) <= (LONG) M0)
        {
            x0 = 1;
        }
    }

left_to_right_compute_y0:

/***********************************************************************\
* Calculate the start pixel.
\***********************************************************************/

// We now compute y0 and adjust the error term.  We know x0, and we know
// the current formula for the pixels to be lit on the line:
//
//                     dN * x + lGamma
//       y(x) = floor( --------------- )
//                           dM
//
// The remainder of this expression is the new error term at (x0, y0).
// Since x0 is going to be either 0 or 1, we don't actually have to do a
// multiply or divide to compute y0.  Finally, we subtract dM from the
// new error term so that it is in the range [-dM, 0).

    y0      = 0;
    lGamma += (dN & (-x0));
    lGamma -= dM;
    if (lGamma >= 0)
    {
        y0      = 1;
        lGamma -= dM;
    }

// Undo our flips to get the start coordinate:

    x += x0;
    y += y0;

    if (fl & HW_FLIP_D)
    {
        register LONG lTmp;
        lTmp = x; x = y; y = lTmp;
    }

    if (fl & HW_FLIP_V)
    {
        y = -y;
    }

    if (fl & HW_FLIP_H)
    {
        x = -x;
    }

/***********************************************************************\
* Return the Bresenham terms:
\***********************************************************************/

    // iDir       = gaiDir[fl & HW_FLIP_MASK];
    // ptlStart.x = x;
    // ptlStart.y = y;
    // cPels      = x1 - x0 + 1;  // NOTE: You'll have to check if cPels <= 0!
    // dMajor     = dM;
    // dMinor     = dN;
    // lErrorTerm = lGamma;

/***********************************************************************\
* Draw the line.  S3 specific code follows:
\***********************************************************************/

    cPels = x1 - x0 + 1;
    if (cPels > 0)
    {
        IO_FIFO_WAIT(ppdev, 7);

        IO_CUR_X(ppdev, x);
        IO_CUR_Y(ppdev, y);
        IO_MAJ_AXIS_PCNT(ppdev, cPels);
        IO_AXSTP(ppdev, dN);
        IO_DIASTP(ppdev, dN - dM);
        IO_ERR_TERM(ppdev, dN + lGamma);
        IO_CMD(ppdev, gaiDrawCmd[fl & HW_FLIP_MASK]);
    }

    return(TRUE);
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\lineto.c ===
/******************************************************************************\
*
* $Workfile:   lineto.c  $
*
* Contents:
* This file contains the DrvLineTo function and line drawing code for the
* CL-GD546x chips.
*
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/lineto.c  $
*
*    Rev 1.19   Mar 04 1998 15:27:54   frido
* Added new shadow macros.
*
*    Rev 1.18   Feb 27 1998 15:43:14   frido
* Roll back of 1.16.
* Removed sloped lines.
*
*    Rev 1.17   Feb 26 1998 17:16:32   frido
* Removed diagonal line drawing.
* Optimized horizontal and vertical line drawing.
*
*    Rev 1.16   Jan 26 1998 09:59:12   frido
* A complete rewrite. Ported most code from Alpine NT driver (I already did
* most of the work for that driver) and fixed all bugs in it.
*
*    Rev 1.15   Nov 03 1997 15:46:04   frido
* Added REQUIRE macros.
*
*    Rev 1.14   08 Apr 1997 12:25:36   einkauf
*
* add SYNC_W_3D to coordinat MCD/2D hw access
*
*
*    Rev 1.13   21 Mar 1997 11:43:20   noelv
*
* Combined 'do_flag' and 'sw_test_flag' together into 'pointer_switch'
*
*    Rev 1.12   04 Feb 1997 10:38:34   SueS
* Added another ifdef to the punt condition, because there's a hardware
* bug in the 2D clip engine.
*
*    Rev 1.11   27 Jan 1997 13:08:36   noelv
* Don't compile hardware clipping for 5464 chip.
*
*    Rev 1.10   27 Jan 1997 07:58:06   SueS
* Punt for the 5462/64.  There was a problem with clipping on the 62.
*
*    Rev 1.9   23 Jan 1997 15:25:34   SueS
* Added support for hardware clipping in the 5465.  For all 546x family,
* punt on complex clipping.
*
*    Rev 1.8   10 Jan 1997 17:23:48   SueS
* Reenabled DrvLineTo.  Modified clipping function.  Added boundary
* condition tests.
*
*    Rev 1.7   08 Jan 1997 14:40:48   SueS
* Temporarily punt on all DrvLineTo calls.
*
*    Rev 1.6   08 Jan 1997 09:33:24   SueS
* Punt in DrvLineTo for complex clipping.
*
*    Rev 1.5   06 Jan 1997 10:32:06   SueS
* Modified line drawing functions so that clipping is applied properly, and
* so that pixels for lines with y as the driving axis drawn from top to
* bottom will now be calculated correctly.  Changed debug statements to hex.
*
*    Rev 1.4   26 Nov 1996 10:43:02   noelv
* Changed debug level.
*
*    Rev 1.3   26 Nov 1996 10:01:22   noelv
*
* Changed Debug prints.
*
*    Rev 1.2   06 Sep 1996 15:16:26   noelv
* Updated NULL driver for 4.0
*
*    Rev 1.1   28 Aug 1996 17:25:04   noelv
* Added #IFDEF to prevent this file from being compiled into 3.51 driver.
*
*    Rev 1.0   20 Aug 1996 11:38:46   noelv
* Initial revision.
*
*    Rev 1.0   18 Aug 1996 22:52:18   frido
* Ported from CL-GD5446 code.
*
\******************************************************************************/

#include "PreComp.h"
#define LINETO_DBG_LEVEL        1

#define LEFT    0x01
#define RIGHT   0x02
#define TOP             0x04
#define BOTTOM  0x08

extern BYTE Rop2ToRop3[];
extern USHORT mixToBLTDEF[];

//
// This file isn't used in NT 3.51
//
#ifndef WINNT_VER35

/******************************************************************************\
*
* Function:     DrvLineTo
*
* This function draws a line between any two points.  This function only draws
* lines in solid colors and are just 1 pixel wide.  The end-point is not drawn.
*
* Parameters:   pso                     Pointer to surface.
*                               pco                     Pointer to CLIPOBJ.
*                               pbo                     Pointer to BRUSHOBJ.
*                               x1                      Starting x-coordinate.
*                               y1                      Starting y-coordinate.
*                               x2                      Ending x-coordinate.
*                               y2                      Ending y-coordinate.
*                               prclBounds      Pointer to an unclipped bounding rectangle.
*                               mix                     Mix to perform on the destination.
*
* Returns:      TRUE if the line has been drawn, FALSE otherwise.
*
\******************************************************************************/
BOOL DrvLineTo(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
LONG      x1,
LONG      y1,
LONG      x2,
LONG      y2,
RECTL*    prclBounds,
MIX       mix)
{
        PDEV*   ppdev;
        ULONG   ulColor;
        BYTE    iDComplexity;
        LONG    dx, dy;
        BYTE    bCode1 = 0, bCode2 = 0;
        RECTL   rclClip1, rclClip2;

        #if NULL_LINETO
        {
                if (pointer_switch)
                {
                        return(TRUE);
                }
        }
        #endif

        DISPDBG((LINETO_DBG_LEVEL, "DrvLineTo: %x,%x - %x,%x\n", x1, y1, x2, y2));
        ppdev = (PDEV*) pso->dhpdev;

        SYNC_W_3D(ppdev);

        if (pso->iType == STYPE_DEVBITMAP)
        {
                DSURF* pdsurf = (DSURF*) pso->dhsurf;
                // If the device bitmap is located in memory, try copying it back to
                // off-screen.
                if ( pdsurf->pso && !bCreateScreenFromDib(ppdev, pdsurf) )
                {
                        return(EngLineTo(pdsurf->pso, pco, pbo, x1, y1, x2, y2, prclBounds,
                                        mix));
                }
                ppdev->ptlOffset = pdsurf->ptl;
        }
        else
        {
                ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;
        }

        // Punt complex clipping.
        iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;
        if (iDComplexity == DC_COMPLEX)
        {
                DISPDBG((LINETO_DBG_LEVEL, "  Complex clipping: punt\n"));
                return(FALSE);
        }

        // Set line deltas.
        dx = x2 - x1;
        dy = y2 - y1;

        // We only handle horizontal and vertical lines.
        if ( (dx != 0) && (dy != 0) )
        {
                return(FALSE);
        }

        // Test for zero deltas.
        if ( (dx == 0) && (dy == 0) )
        {
                return(TRUE);
        }

        // Clip the coordinates.
        if (iDComplexity == DC_RECT)
        {
                // Set clipping rectangles.
                rclClip1.left   = pco->rclBounds.left;
                rclClip1.top    = pco->rclBounds.top;
                rclClip1.right  = pco->rclBounds.right - 1;
                rclClip1.bottom = pco->rclBounds.bottom - 1;

                rclClip2.left   = pco->rclBounds.left - 1;
                rclClip2.top    = pco->rclBounds.top - 1;
                rclClip2.right  = pco->rclBounds.right;
                rclClip2.bottom = pco->rclBounds.bottom;

                // Set line flags.
                if (x1 < rclClip1.left)   bCode1 |= LEFT;
                if (y1 < rclClip1.top)    bCode1 |= TOP;
                if (x1 > rclClip1.right)  bCode1 |= RIGHT;
                if (y1 > rclClip1.bottom) bCode1 |= BOTTOM;

                if (x2 < rclClip2.left)   bCode2 |= LEFT;
                if (y2 < rclClip2.top)    bCode2 |= TOP;
                if (x2 > rclClip2.right)  bCode2 |= RIGHT;
                if (y2 > rclClip2.bottom) bCode2 |= BOTTOM;

                if ((bCode1 & bCode2) != 0)
                {
                        // The line is completely clipped.
                        return(TRUE);
                }

                // Vertical line.
                if (dx == 0)
                {
                        if (bCode1 & TOP)
                        {
                                y1 = rclClip1.top;
                        }
                        else if (bCode1 & BOTTOM)
                        {
                                y1 = rclClip1.bottom;
                        }

                        if (bCode2 & TOP)
                        {
                                y2 = rclClip2.top;
                        }
                        else if (bCode2 & BOTTOM)
                        {
                                y2 = rclClip2.bottom;
                        }
                }

                // Horizontal line.
                else
                {
                        if (bCode1 & LEFT)
                        {
                                x1 = rclClip1.left;
                        }
                        else if (bCode1 & RIGHT)
                        {
                                x1 = rclClip1.right;
                        }

                        if (bCode2 & LEFT)
                        {
                                x2 = rclClip2.left;
                        }
                        else if (bCode2 & RIGHT)
                        {
                                x2 = rclClip2.right;
                        }
                }

                if (bCode1 | bCode2)
                {
                        // Recalculate line deltas.
                        dx = x2 - x1;
                        dy = y2 - y1;
                }
        }

        // Get the color from the brush.
        ASSERTMSG(pbo, "Null brush in DrvLineTo!\n");
        ulColor = pbo->iSolidColor;

        REQUIRE(9);

        // If we have a color here we need to setup the hardware.
        if (ulColor != 0xFFFFFFFF)
        {
                // Expand the color.
                switch (ppdev->ulBitCount)
                {
                        case 8:
                                ulColor |= ulColor << 8;
                        case 16:
                                ulColor |= ulColor << 16;
                }
                LL_BGCOLOR(ulColor, 2);

                // Convert mix to ternary ROP.
                ppdev->uRop    = Rop2ToRop3[mix & 0xF];
                ppdev->uBLTDEF = mixToBLTDEF[mix & 0xF];
        }
        LL_DRAWBLTDEF((ppdev->uBLTDEF << 16) | ppdev->uRop, 2);

        // Horizontal line.
        if (dy == 0)
        {
                if (dx > 0)
                {
                        // From left to right.
//above                 REQUIRE(5);
                        LL_OP0(x1 + ppdev->ptlOffset.x, y1 + ppdev->ptlOffset.y);
                        LL_BLTEXT(dx, 1);
                }
                else
                {
                        // From right to left.
//above                 REQUIRE(5);
                        LL_OP0(x2 + 1 + ppdev->ptlOffset.x, y2 + ppdev->ptlOffset.y);
                        LL_BLTEXT(-dx, 1);
                }
        }

        // Vertical line.
        else
        {
                if (dy > 0)
                {
                        // From top to bottom.
//above                 REQUIRE(5);
                        LL_OP0(x1 + ppdev->ptlOffset.x, y1 + ppdev->ptlOffset.y);
                        LL_BLTEXT(1, dy);
                }
                else
                {
                        // From bottom to top.
//above                 REQUIRE(5);
                        LL_OP0(x2 + ppdev->ptlOffset.x, y2 + 1 + ppdev->ptlOffset.y);
                        LL_BLTEXT(1, -dy);
                }
        }

        return(TRUE);
}

#endif // !WINNT_VER35
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\logfile.c ===
/*****************************************************************************
******************************************************************************
*
*                ******************************************
*                * Copyright (c) 1996, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna I (CL-GD546x) - 
*
* FILE:     logfile.c
*
* AUTHOR:   Sue Schell
*
* DESCRIPTION:
*           This file contains routines that create and write to 
*           the log file, used for debugging and testing purposes
*           only.
*
* MODULES:
*           CreateLogFile()
*           WriteLogFile()
*           CloseLogFile()
*
* REVISION HISTORY:
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/logfile.c  $
* 
*    Rev 1.5   21 Mar 1997 11:43:58   noelv
* 
* Combined LOG_WRITES LOG_CALLS and LOG_QFREE together into ENABLE_LOG_FILE
* 
*    Rev 1.4   17 Dec 1996 16:43:32   SueS
* On a CloseLogFile call, dump the current buffer to the file.
* 
*    Rev 1.3   05 Dec 1996 08:49:24   SueS
* Added function to help with formatting strings for DirectDraw logging.
* 
*    Rev 1.2   03 Dec 1996 11:37:36   SueS
* Removed extraneous semicolon left over from testing.
* 
*    Rev 1.1   26 Nov 1996 10:50:42   SueS
* Instead of sending a single string of text at a time, buffer up the
* requests to the miniport.  The buffer is currently 4K.  Added a
* CloseLogFile function.
* 
*    Rev 1.0   13 Nov 1996 17:03:36   SueS
* Initial revision.
* 
****************************************************************************
****************************************************************************/

/////////////////////
//  Include Files  //
/////////////////////
#include "precomp.h"
#include "clioctl.h"

///////////////
//  Defines  //
///////////////
#define BUFFER_SIZE 0x1000

///////////////////////////
//  Function Prototypes  //
///////////////////////////
#if ENABLE_LOG_FILE

    HANDLE CreateLogFile(
        HANDLE hDriver,
        PDWORD Index);

    BOOL WriteLogFile(
        HANDLE hDriver,
        LPVOID lpBuffer,
        DWORD BytesToWrite,
        PCHAR TextBuffer,
        PDWORD Index);

    BOOL CloseLogFile(
        HANDLE hDriver,
        PCHAR TextBuffer,
        PDWORD Index);

    void DDFormatLogFile(
        LPSTR szFormat, ...);


//
// Used by sprintf to build strings.
//
char lg_buf[256];
long lg_i;

///////////////////////////////////////////////////////////////////////////////
//
//  HANDLE CreateLogFile(HANDLE hDriver, PDWORD Index)
//
//  Parameters:
//      hDriver - the handle to the miniport driver
//      Index - pointer to the index into the text buffer sent to the miniport
//
//  Return:
//      the handle of the just-opened log file
//
//  Notes:
//
//      This function posts a message to the miniport driver to 
//      tell it to open the log file.
//
///////////////////////////////////////////////////////////////////////////////
HANDLE CreateLogFile(
    HANDLE hDriver,        // handle to miniport driver
    PDWORD Index           // size of text buffer
)
{
DWORD BytesReturned;

    // Initialize the buffer pointer
    *Index = 0;

    // Tell the miniport driver to open the log file
    if (DEVICE_IO_CTRL(hDriver,
                       IOCTL_CL_CREATE_LOG_FILE,
                       NULL,
                       0,
                       NULL,
                       0,
                       &BytesReturned,
                       NULL))
        return((HANDLE)-1);
    else
        return((HANDLE)0);

}

                                

///////////////////////////////////////////////////////////////////////////////
//
//  BOOL WriteLogFile(HANDLE hDriver, LPVOID lpBuffer, DWORD BytesToWrite,
//                    PCHAR TextBuffer, PDWORD Index)
//
//  Parameters:
//      hDriver - the handle to the miniport driver
//      lpBuffer - pointer to data to write to file
//      BytesToWrite - number of bytes to write
//      TextBuffer - the buffer eventually sent to the miniport
//      Index - size of TextBuffer
//
//  Return:
//      TRUE - the DeviceIoControl call succeeded
//      FALSE - the DeviceIoControl call failed
//
//  Notes:
//
//      This function posts a message to the miniport driver to 
//      tell it to write the input buffer to the log file.  It waits
//      until it has a full text buffer before doing so.
//
///////////////////////////////////////////////////////////////////////////////
BOOL WriteLogFile(
    HANDLE hDriver,        // handle to miniport driver
    LPVOID lpBuffer,       // pointer to data to write to file
    DWORD BytesToWrite,    // number of bytes to write
    PCHAR TextBuffer,      // buffer sent to miniport
    PDWORD Index           // size of buffer
)
{
DWORD BytesReturned;
BOOLEAN Status = TRUE;

   // Do we have room in the buffer?
   if (BytesToWrite + *Index >= BUFFER_SIZE - 1)
   {

      // No, we're full - it's time to send the message
      // Tell the miniport driver to write to the log file

      Status = DEVICE_IO_CTRL(hDriver,
                       IOCTL_CL_WRITE_LOG_FILE,
                       TextBuffer,
                       *Index,
                       NULL,
                       0,
                       &BytesReturned,
                       NULL);

      // Reset the buffer
      *TextBuffer = 0;
      *Index = 0;

   }

   // Add to the buffer and bump the count
   RtlMoveMemory(TextBuffer+*Index, lpBuffer, BytesToWrite);
   *Index += BytesToWrite;
   *(TextBuffer+*Index) = 0;

   return(Status);

}


///////////////////////////////////////////////////////////////////////////////
//
//  HANDLE CloseLogFile(HANDLE hDriver)
//
//  Parameters:
//      hDriver - the handle to the miniport driver
//
//  Return:
//      TRUE - the DeviceIoControl call succeeded
//      FALSE - the DeviceIoControl call failed
//
//  Notes:
//
//      This function sends the current buffer to the miniport driver
//      to tell it to write to the logfile immediately.
//
///////////////////////////////////////////////////////////////////////////////
BOOL CloseLogFile(
    HANDLE hDriver,        // handle to miniport driver
    PCHAR TextBuffer,      // buffer sent to miniport
    PDWORD Index           // size of buffer
)
{
DWORD BytesReturned;
BOOLEAN Status;

   // Dump the buffer contents
   // Tell the miniport driver to write to the log file

   Status = DEVICE_IO_CTRL(hDriver,
                       IOCTL_CL_WRITE_LOG_FILE,
                       TextBuffer,
                       *Index,
                       NULL,
                       0,
                       &BytesReturned,
                       NULL);

   // Reset the buffer
   *TextBuffer = 0;
   *Index = 0;

   return(Status);

}


///////////////////////////////////////////////////////////////////////////////
//
//  void DDFormatLogFile(LPSTR szFormat, ...)
//
//  Parameters:
//      szFormat - format and string to be printed to log file
//
//  Return:
//      none
//
//  Notes:
//
//      This function formats a string according to the specified format
//      into the global string variable used to write to the log file.
//
///////////////////////////////////////////////////////////////////////////////
void DDFormatLogFile(
   LPSTR szFormat, ...)
{

   lg_i = vsprintf(lg_buf, szFormat, (LPVOID)(&szFormat+1));
   return;
   
}

#endif    // ENABLE_LOG_FILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\mcdhw.h ===
/******************************Module*Header*******************************\
* Module Name: mcdhw.h
*
* Driver-specific structures and defines for the Cirrus Logic 546X MCD driver.
*
* (based on mcdhw.h from NT4.0 DDK)
*
* Copyright (c) 1996 Microsoft Corporation
* Copyright (c) 1997 Cirrus Logic, Inc.
*
\**************************************************************************/

#ifndef _MCDHW_H
#define _MCDHW_H

#if DBG
    #define FASTCALL 
#else
    #ifdef _X86_
    #define FASTCALL    __fastcall
    #else
    #define FASTCALL 
    #endif
#endif

#define	ASM_ACCEL         1     // Enable/disable asm code

#define __MCD_USER_CLIP_MASK	((1 << MCD_MAX_USER_CLIP_PLANES) - 1)

// track original vertices unaffected by clip to enable recomputation
//  of windowCoords, since this can introduce imprecision 
// will use clipCode member of MCDVERTEX for this flag, so position
//  should be one not used by a real clip code
#define __MCD_CLIPPED_VTX       (1 << (MCD_MAX_USER_CLIP_PLANES+6)) 

#define __MCD_CW          0
#define __MCD_CCW         1

#define __MCD_FRONTFACE   MCDVERTEX_FRONTFACE
#define __MCD_BACKFACE    MCDVERTEX_BACKFACE
#define __MCD_NOFACE      -1

#define __MCDENABLE_TWOSIDED	0x0001

// use same bits as Opcode word for Cirrus 546x 3D engine
#define __MCDENABLE_Z	            0x00002000  // same as LL_Z_BUFFER in LL3D
#define __MCDENABLE_SMOOTH          0x00001000  // same as LL_GOURAUD in LL3D
#define __MCDENABLE_DITHER          0x00200000  // same as LL_DITHER in LL3D
#define __MCDENABLE_PG_STIPPLE      0x00080000  // same as LL_STIPPLE in LL3D
#define __MCDENABLE_TEXTURE         0x00020000  // same as LL_TEXTURE in LL3D
#define __MCDENABLE_PERSPECTIVE     0x00010000  // same as LL_PERSPECTIVE in LL3D
#define __MCDENABLE_LIGHTING        0x00040000  // same as LL_LIGHTING in LL3D

#define __MCDENABLE_BLEND           0x00000002  // no map to LL_ equivalent
#define __MCDENABLE_FOG             0x00000004  // no map to LL_ equivalent
#define __MCDENABLE_1D_TEXTURE      0x00000008  // no map to LL_ equivalent
#define __MCDENABLE_LINE_STIPPLE    0x00000010  // no map to LL_STIPPLE since pg/line stipple independent
#define __MCDENABLE_TEXTUREMASKING  0x00000020  // no map to LL_ equivalent

#define PATTERN_RAM_INVALID				0
#define AREA_PATTERN_LOADED				1
#define STIPPLE_LOADED					2
#define DITHER_LOADED					3
#define LINE_PATTERN_LOADED				4

#define CLMCD_TEX_BOGUS             0x10000000  // Texture is bogus - always punt 

// default texture key - remains this if load fails, otherwise is address of texture
//      control block, so make sure < 0x80000000 so won't be valid kernel space address
#define TEXTURE_NOT_LOADED              0

#define MCD_CONFORM_ADJUST      1

typedef LONG MCDFIXED;

typedef struct _RGBACOLOR {
    MCDFIXED r, g, b, a;
} RGBACOLOR;

#define SWAP_COLOR(p)\
{\
    MCDFLOAT tempR, tempG, tempB;\
\
    tempR = (p)->colors[0].r;\
    (p)->colors[0].r = (p)->colors[1].r;\
    (p)->colors[1].r = tempR;\
\
    tempG = (p)->colors[0].g;\
    (p)->colors[0].g = (p)->colors[1].g;\
    (p)->colors[1].g = tempG;\
\
    tempB = (p)->colors[0].b;\
    (p)->colors[0].b = (p)->colors[1].b;\
    (p)->colors[1].b = tempB;\
}

#define SAVE_COLOR(temp, p)\
{\
    temp.r = (p)->colors[0].r;\
    temp.g = (p)->colors[0].g;\
    temp.b = (p)->colors[0].b;\
}

#define RESTORE_COLOR(temp, p)\
{\
    (p)->colors[0].r = temp.r;\
    (p)->colors[0].g = temp.g;\
    (p)->colors[0].b = temp.b;\
}

#define COPY_COLOR(pDst, pSrc)\
{\
    pDst.r = pSrc.r;\
    pDst.g = pSrc.g;\
    pDst.b = pSrc.b;\
}

#define MCDCLAMPCOUNT(value) ((ULONG)(value) & 0x00007fff)

#define MCDFIXEDRGB(fixColor, fltColor)\
    fixColor.r = (MCDFIXED)(fltColor.r * pRc->rScale);\
    fixColor.g = (MCDFIXED)(fltColor.g * pRc->gScale);\
    fixColor.b = (MCDFIXED)(fltColor.b * pRc->bScale);

typedef struct _DRVPIXELFORMAT {
    UCHAR cColorBits;
    UCHAR rBits;
    UCHAR gBits;
    UCHAR bBits;
    UCHAR aBits;
    UCHAR rShift;
    UCHAR gShift;
    UCHAR bShift;
    UCHAR aShift;
} DRVPIXELFORMAT;

typedef struct _DEVWND {
    ULONG createFlags;              // (RC) creation flags
    LONG iPixelFormat;              // pixel format ID for this window
    ULONG dispUnique;               // display resolution uniqueness

    ULONG frontBufferPitch;         // pitch in bytes
    ULONG allocatedBufferHeight;    // Same for back and z on Millenium
    ULONG allocatedBufferWidth;     // 546x supports window width < screen width

    BOOL bDesireBackBuffer;         // back buffer wanted
    BOOL bValidBackBuffer;          // back buffer validity
    ULONG backBufferBase;           // byte offset to start of back buffer pool
    ULONG backBufferBaseY;          // y value for start of back buffer pool
    ULONG backBufferOffset;         // byte offset to start of back buffer
    ULONG backBufferY;              // y value for start of active back buffer
    ULONG backBufferPitch;          // back buffer pitch in bytes

    BOOL bDesireZBuffer;            // z buffer wanted
    BOOL bValidZBuffer;             // z buffer validity
    ULONG zBufferBase;              // byte offset to start of z buffer pool
    ULONG zBufferBaseY;             // y value for start of z buffer pool
    ULONG zBufferOffset;            // byte offset to start of z buffer
    ULONG zPitch;                   // z buffer pitch in bytes

    POFMHDL pohBackBuffer;          // ofscreen pools
    POFMHDL pohZBuffer;

    union {
        TBase0Reg Base0;            // Base0_addr_3d register shadow
        DWORD dwBase0;
    };

    union {
        TBase1Reg Base1;            // Base1_addr_3d register shadow
        DWORD dwBase1;
    };

} DEVWND;

typedef struct _DEVRC DEVRC;

// recip table to support up to 2K x 2K resolution
//#define LAST_FRECIP 2048

typedef struct _DEVRC
{
    MCDRENDERSTATE MCDState;
    MCDTEXENVSTATE MCDTexEnvState;
    MCDVIEWPORT MCDViewport;
    MCDSURFACE *pMCDSurface;    // Valid for primitives only
    MCDRC *pMCDRc;              // Valid for primitives only
    PDEV* ppdev;                // Valid for primitives only
    ENUMRECTS *pEnumClip;       // Valid for primitives only
    
    MCDVERTEX *pvProvoking;     // provoking vertex
    UCHAR *pMemMax;             // command-buffer memory bounds
    UCHAR *pMemMin;

    LONG iPixelFormat;          // valid pixel format ID for this RC

    // storage and pointers for clip processing:

    MCDVERTEX clipTemp[6 + MCD_MAX_USER_CLIP_PLANES];
    MCDVERTEX *pNextClipTemp;
    VOID (FASTCALL *lineClipParam)(MCDVERTEX*, const MCDVERTEX*, const MCDVERTEX*, MCDFLOAT);
    VOID (FASTCALL *polyClipParam)(MCDVERTEX*, const MCDVERTEX*, const MCDVERTEX*, MCDFLOAT);

    // Rendering functions:

    VOID (FASTCALL *renderPoint)(DEVRC *pRc, MCDVERTEX *pv);
    VOID (FASTCALL *renderLine)(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL resetLine);
    VOID (FASTCALL *renderTri)(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, MCDVERTEX *pv3);
    VOID (FASTCALL *clipLine)(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL bResetLine);
    VOID (FASTCALL *clipTri)(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, MCDVERTEX *pv3, ULONG clipFlags);
    VOID (FASTCALL *clipPoly)(DEVRC *pRc, MCDVERTEX *pv, ULONG numVert);
    VOID (FASTCALL *doClippedPoly)(DEVRC *pRc, MCDVERTEX **pv, ULONG numVert, ULONG clipFlags);
    VOID (FASTCALL *renderPointX)(DEVRC *pRc, MCDVERTEX *pv);
    VOID (FASTCALL *renderLineX)(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL resetLine);
    VOID (FASTCALL *renderTriX)(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, MCDVERTEX *pv3);

// Primitive-rendering function table:

    MCDCOMMAND * (FASTCALL *primFunc[10])(DEVRC *pRc, MCDCOMMAND *pCommand);

// Internal table of rendering functions:

    VOID (FASTCALL *drawPoint)(DEVRC *pRc, MCDVERTEX *pv);
    VOID (FASTCALL *drawLine)(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL resetLine);
    VOID (FASTCALL *drawTri)(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, MCDVERTEX *pv3, int linear_ok);

// Rendering helper functions:

    VOID (FASTCALL *HWSetupClipRect)(DEVRC *pRc, RECTL *pRect);

    BOOL allPrimFail;           // TRUE is the driver can't draw *any*
                                // primitives for current state
    BOOL pickNeeded;
    BOOL resetLineStipple;

    ULONG polygonFace[2];       // front/back face tables
    ULONG polygonMode[2];

    MCDFLOAT halfArea;
    MCDFLOAT dxAC;
    MCDFLOAT dxAB;
    MCDFLOAT dxBC;
    MCDFLOAT dyAC;
    MCDFLOAT dyAB;
    MCDFLOAT dyBC;
    LONG cullFlag;
    MCDFLOAT dzdx, dzdy;
    MCDFIXED fxdzdx, fxdzdy;
    ULONG xOffset, yOffset;
    MCDFLOAT fxOffset, fyOffset;
    LONG viewportXAdjust;
    LONG viewportYAdjust;

    BOOL zBufEnabled;
    BOOL backBufEnabled;

    ULONG privateEnables;

    MCDFLOAT rScale;
    MCDFLOAT gScale;
    MCDFLOAT bScale;
    MCDFLOAT aScale;
    MCDFLOAT zScale;

    float texture_height;
    float texture_bias; // 0 if NEAREST, -0.5 if LINEAR - not a kludge, see OpenGL 1.1 Spec, p 96
    float texture_width;

    DWORD   dwPolyOpcode;
    DWORD   dwLineOpcode;
    DWORD   dwPointOpcode;

    DEVWND  *pLastDevWnd;

    union {
        TControl0Reg Control0;      // Control 0 register shadow
        DWORD dwControl0;
    };

    union {
        TTxCtl0Reg TxControl0;      // Tx_Ctl0_3D register shadow
        DWORD dwTxControl0;
    };

    union {
        TTxXYBaseReg TxXYBase;      // Tx_XYBase_3D register shadow
        DWORD dwTxXYBase;
    };

    DWORD dwColor0;                 // Current value of COLOR_REG0_3D reg

	LL_Pattern	line_style;		
	LL_Pattern	fill_pattern;

    LL_Texture *pLastTexture;       // Used to cache textures

    float      fNumDraws;           // how many MCDrvDraws executed since CreateContext

    DWORD      punt_front_w_windowed_z;


    BYTE       bAlphaTestRef;       // alpha test reference, scaled to 8 bits        

    RECTL      AdjClip;
    
} DEVRC;


// External declarations

MCDCOMMAND * FASTCALL __MCDPrimDrawPoints(DEVRC *pRc, MCDCOMMAND *pCmd);
MCDCOMMAND * FASTCALL __MCDPrimDrawLines(DEVRC *pRc, MCDCOMMAND *pCmd);
MCDCOMMAND * FASTCALL __MCDPrimDrawLineLoop(DEVRC *pRc, MCDCOMMAND *pCmd);
MCDCOMMAND * FASTCALL __MCDPrimDrawLineStrip(DEVRC *pRc, MCDCOMMAND *pCmd);
MCDCOMMAND * FASTCALL __MCDPrimDrawTriangles(DEVRC *pRc, MCDCOMMAND *pCmd);
MCDCOMMAND * FASTCALL __MCDPrimDrawTriangleStrip(DEVRC *pRc, MCDCOMMAND *pCmd);
MCDCOMMAND * FASTCALL __MCDPrimDrawTriangleFan(DEVRC *pRc, MCDCOMMAND *pCmd);
MCDCOMMAND * FASTCALL __MCDPrimDrawQuads(DEVRC *pRc, MCDCOMMAND *pCmd);
MCDCOMMAND * FASTCALL __MCDPrimDrawQuadStrip(DEVRC *pRc, MCDCOMMAND *pCmd);
MCDCOMMAND * FASTCALL __MCDPrimDrawPolygon(DEVRC *pRc, MCDCOMMAND *_pCmd);
MCDCOMMAND * FASTCALL __MCDPrimDrawStub(DEVRC *pRc, MCDCOMMAND *_pCmd);

// High-level rendering functions:

VOID __MCDPickRenderingFuncs(DEVRC *pRc, DEVWND *pDevWnd);

VOID FASTCALL __MCDRenderPoint(DEVRC *pRc, MCDVERTEX *pv);
VOID FASTCALL __MCDRenderFogPoint(DEVRC *pRc, MCDVERTEX *pv);
VOID FASTCALL __MCDRenderGenPoint(DEVRC *pRc, MCDVERTEX *pv);

VOID FASTCALL __MCDRenderLine(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL resetLine);
VOID FASTCALL __MCDRenderGenLine(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL resetLine);

VOID FASTCALL __MCDRenderFlatTriangle(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, MCDVERTEX *pv3);
VOID FASTCALL __MCDRenderSmoothTriangle(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, MCDVERTEX *pv3);
VOID FASTCALL __MCDRenderGenTriangle(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, MCDVERTEX *pv3);

// Low-level drawing functions:

VOID FASTCALL __MCDPointBegin(DEVRC *pRc);

VOID FASTCALL __MCDFillTriangle(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, MCDVERTEX *pv3, int linear_ok);
VOID FASTCALL __MCDPerspTxtTriangle(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, MCDVERTEX *pv3, int linear_ok);

// Clipping functions:

VOID FASTCALL __MCDPickClipFuncs(DEVRC *pRc);
VOID FASTCALL __MCDClipLine(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b,
                            BOOL bResetLine);
VOID FASTCALL __MCDClipTriangle(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b,
                                MCDVERTEX *c, ULONG orClipCode);
VOID FASTCALL __MCDClipPolygon(DEVRC *pRc, MCDVERTEX *v0, LONG nv);
VOID FASTCALL __MCDDoClippedPolygon(DEVRC *pRc, MCDVERTEX **iv, LONG nout,
                                    ULONG allClipCodes);
VOID FASTCALL __HWAdjustLeftEdgeRGBZ(DEVRC *pRc, MCDVERTEX *p,
                                     MCDFLOAT fdxLeft, MCDFLOAT fdyLeft,
                                     MCDFLOAT xFrac, MCDFLOAT yFrac,
                                     MCDFLOAT xErr);
VOID FASTCALL __HWAdjustRightEdge(DEVRC *pRc, MCDVERTEX *p,
                                  MCDFLOAT fdxRight, MCDFLOAT fdyRight, 
                                  MCDFLOAT xErr);
VOID FASTCALL __MCDCalcDeltaRGBZ(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b,
                                 MCDVERTEX *c);
MCDFLOAT FASTCALL __MCDGetZOffsetDelta(DEVRC *pRc);

// Fog function

VOID __MCDCalcFogColor(DEVRC *pRc, MCDVERTEX *a, MCDCOLOR *pResult, MCDCOLOR *pColor);

// NOTE: dummy function - should be removed when development complete

VOID FASTCALL __MCDDummyProc(DEVRC *pRc);

#endif //ndef _MCDHW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\mcdline.c ===
/******************************Module*Header*******************************\
* Module Name: mcdline.c
*
* Contains all of the line-rendering routines for the Cirrus Logic 546X MCD driver.
*
* (based on mcdline.c from NT4.0 DDK)
*
* Copyright (c) 1996 Microsoft Corporation
* Copyright (c) 1997 Cirrus Logic, Inc.
\**************************************************************************/

#include "precomp.h"
#include "mcdhw.h"       
#include "mcdutil.h"
#include "mcdmath.h"

//#undef CHECK_FIFO_FREE
//#define CHECK_FIFO_FREE 

#define EXCHANGE(i,j)               \
{                                   \
    ptemp=i;                        \
    i=j; j=ptemp;                   \
}


VOID FASTCALL __MCDRenderLine(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b, BOOL resetLine)
{
    ULONG clipNum;
    RECTL *pClip;

	LONG lCoord;

    PDEV *ppdev = pRc->ppdev;
    unsigned int *pdwNext = ppdev->LL_State.pDL->pdwNext;
	void *ptemp; // for EXCHANGE and ROTATE_L macros

	// output queue stuff...
    DWORD *pSrc;
    DWORD *pDest = ppdev->LL_State.pRegs + HOST_3D_DATA_PORT;
    DWORD *pdwStart = ppdev->LL_State.pDL->pdwStartOutPtr;

    DWORD dwFlags=0;		// MCD_TEMP - dwflags initialized to 0
    DWORD *dwOrig;          /* Temp display list  pointer    */
    DWORD dwOpcode;         // Built opcode
    float frecip_step;
    float v1red,v1grn,v1blu;
	LONG ax, bx, ay, by;

    // FUTURE - do something with resetLine input to line render proc

    if ((clipNum = pRc->pEnumClip->c) > 1) {
        pClip = &pRc->pEnumClip->arcl[0];
    	SET_HW_CLIP_REGS(pRc,pdwNext);
        pClip++;
    }

	// window coords are float values, and need to have 
	// viewportadjust (MCDVIEWPORT) values subtracted to get to real screen space

	// color values are 0->1 floats and must be multiplied by scale values (MCDRCINFO)
	// to get to nbits range (scale = 0xff for 8 bit, 0x7 for 3 bit, etc.)

	// Z values are 0->1 floats and must be multiplied by zscale values (MCDRCINFO)


    // Exchange the pointers to vertices if the second point
    // of the line is above the first one
    //
    pRc->pvProvoking = a;   // keep track of original first for possible flat shading
    if( a->windowCoord.y > b->windowCoord.y )
    {
        EXCHANGE(a,b);
    }


    // Store the first address for the opcode
    //
    dwOrig = pdwNext;

    pdwNext += 3;
    
    // Start with a plain line instruction (no modifiers)
    // and assume same color.  Also add three words for DDA
    // line parameters + count (they can not be avoided)
    //
    dwOpcode = LINE | SAME_COLOR | (2+3);
    
    // Set flags as requested from the dwFlags field of a batch.
    // These bits have 1-1 correspondence to their instruction 
    // counterparts.
    //
    // Flags : LL_DITHER     - Use dither pattern
    //         LL_PATTERN    - Draw pattern
    //         LL_STIPPLE    - Use stipple mask
    //         LL_LIGHTING   - Do lighting
    //         LL_Z_BUFFER   - Use Z buffer
    //         FETCH_COLOR   - Appended for alpha blending
    //         LL_GOURAUD    - Use Gouraud shading
    //         LL_TEXTURE    - Texture mapping
    //

    /*
    dwOpcode |= dwFlags & 
    ( LL_DITHER   | LL_PATTERN  | LL_STIPPLE 
    | LL_LIGHTING | LL_Z_BUFFER | FETCH_COLOR 
    | LL_GOURAUD  | LL_TEXTURE );
    */
    dwOpcode |= pRc->privateEnables & (__MCDENABLE_SMOOTH|__MCDENABLE_Z);

    if (pRc->privateEnables & __MCDENABLE_LINE_STIPPLE)                        
    {
        dwOpcode |= LL_STIPPLE;
    }
    else
    {
        // can dither only if no stipple
        dwOpcode |= (pRc->privateEnables & __MCDENABLE_DITHER) ;
    }        

    if( !(dwFlags & LL_SAME_COLOR) )
    {
        register DWORD color;


        // Clear same_color flag
        //
        dwOpcode ^= LL_SAME_COLOR;
    
        // If the line is shaded, the starting color that should
        // be set is the topmost point (pVert1)
        if (pRc->privateEnables & __MCDENABLE_SMOOTH) 
        {
            v1red = a->colors[0].r * pRc->rScale;
            *pdwNext = FTOL(v1red);

            v1grn = a->colors[0].g * pRc->gScale;
            v1blu = a->colors[0].b * pRc->bScale;
            *(pdwNext+1) = FTOL(v1grn);
            *(pdwNext+2) = FTOL(v1blu);

            dwOpcode += 3;
            pdwNext += 3;
        }
        else
        {
            MCDCOLOR *pColor = &pRc->pvProvoking->colors[0];

            *pdwNext = FTOL(pColor->r * pRc->rScale);

            *(pdwNext+1) = FTOL(pColor->g * pRc->gScale);
            *(pdwNext+2) = FTOL(pColor->b * pRc->bScale);

            dwOpcode += 3;
            pdwNext += 3;

        }

    }


    // Set the parameters of a line slope and count
    // Note: line can only go down, so dy is always positive
    //
    {
        int dx, dy, abs_dx, xdir;

        // Well ordered points - set starting point1 coords
        // using a pointer to the origin of the instruction
        //

        ax = FTOL(a->windowCoord.x);
	    lCoord = ax + pRc->xOffset;	   
        *(dwOrig+1) = (DWORD) (lCoord << 16 );

        ay = FTOL(a->windowCoord.y);
	    lCoord = ay + pRc->yOffset;	   
        *(dwOrig+2) = (DWORD) (lCoord << 16 );

        bx = FTOL(b->windowCoord.x);
        by = FTOL(b->windowCoord.y);

        // dx = x2 - x1,
        // dy = y2 - y1 (always positive)
        //
        dx = bx - ax;
        dy = by - ay;

        // NOTE that dx and dy are in 32.0 format (LL3D has them in 16.16)
        //       so math below differs from LL3D

        // make sure dx is positive, and setup xdir needed for x major since we're
        //  already doing the compare here to prevent having to do again for x major case
        if (dx < 0)
        {
            abs_dx = -dx;
            xdir = 0xffff0000;
        }
        else
        {
            abs_dx = dx;
            xdir = 0x00010000;
        }

        if( abs_dx > dy )
        {
            // X-major
            //

            // compute slope with positive dx
            frecip_step = ppdev->frecips[abs_dx];

            *(pdwNext + 0) = xdir;
            *(pdwNext + 1) = abs_dx;
         // *(pdwNext + 2) = (double)dy / (double)ABS(dx) * 65536.0;
            *(pdwNext + 2) = FTOL(dy * frecip_step * (float)65536.0); // equivalent to above
        }
        else
        {
            // Y-major
            //
            frecip_step = ppdev->frecips[dy];

            *(pdwNext + 1) = dy;          // Positive count always, by virtue of earlier EXCHANGE
            *(pdwNext + 2) = 0x10000;     // dy = 1
         // *(pdwNext + 0) = (double)dx / (double)dy * 65536.0;
            *(pdwNext + 0) = FTOL(dx * frecip_step * (float)65536.0);      // equivalent to above
        }

        pdwNext += 3;
    }
    
    if (pRc->privateEnables & __MCDENABLE_SMOOTH) 
    {
        float tmp;

        // Calculate and set the color gradients
        //
        tmp = ((b->colors[0].r * pRc->rScale) - v1red) * frecip_step;
        *pdwNext++ = FTOL(tmp);

        tmp = ((b->colors[0].g * pRc->gScale) - v1grn) * frecip_step;
        *pdwNext++ = FTOL(tmp);

        tmp = ((b->colors[0].b * pRc->bScale) - v1blu) * frecip_step;
        *pdwNext++ = FTOL(tmp);

        // Increase count field by 6 for DR_MAIN_3D, DG_MAIN_3D,
        // DB_MAIN_3D and DR_ORTHO_3D, DG_ORTHO_3D, DB_ORTHO_3D
        //
        dwOpcode += 3;
    }


    if( pRc->privateEnables & __MCDENABLE_Z)
    {
        float fdz_main = (b->windowCoord.z - a->windowCoord.z) * pRc->zScale * frecip_step;

        *pdwNext++ = FTOL(a->windowCoord.z * pRc->zScale);
        *pdwNext++ = FTOL(fdz_main);

        // Increase count field by 2 for Z_3D, DZ_MAIN_3D 
        //
        dwOpcode += 2;
    }


#if 0
    if( dwFlags & LL_TEXTURE )
    {
    ...
    ...
    ...
    }


#endif
    if (pRc->privateEnables & (__MCDENABLE_BLEND|__MCDENABLE_FOG)) 
    {
        float v1alp,tmp;

        if (pRc->privateEnables & __MCDENABLE_BLEND) 
        {
            // recall that if both blending and fog active, all prims punted back to software
            v1alp = a->colors[0].a * pRc->aScale;
            *(pdwNext+0) = FTOL(v1alp);
            tmp = ((b->colors[0].a * pRc->aScale) - v1alp) * frecip_step;
            *(pdwNext+1) = FTOL(tmp);
        }
        else
        {
            v1alp = a->fog * (float)16777215.0; // convert from 0->1.0 val to 0->ff.ffff val
            *(pdwNext+0) = FTOL(v1alp);
            tmp = ((b->fog * (float)16777215.0) - v1alp) * frecip_step;
            *(pdwNext+1) = FTOL(tmp);
        }

        *(pdwNext+0) &= 0x00ffff00;// bits 31->24 and 7->0 reserved
        *(pdwNext+1) &= 0xffffff00;// bits 7->0 reserved
        
        dwOpcode += ( FETCH_COLOR | ALPHA + 2 );
        pdwNext += 2;

	}

    // Store the final opcode
    //
    *dwOrig = dwOpcode;

    while (--clipNum) {
        int len = (dwOpcode & 0x3F) + 1;    // num words for line primitive
        SET_HW_CLIP_REGS(pRc,pdwNext)
        pClip++;

        // dump same line regs again to draw while clipping against occlusion rectangle
        pSrc = dwOrig;
        
        while( len-- ) *pdwNext++ = *pSrc++;                                      
    }


		// output queued data here....
#if 0 // FUTURE - enable queueing algorithm - just outputting everything for now
    OUTPUT_COPROCMODE_QUEUE
#else // 0
    {
	    pSrc  = pdwStart;                                                             
        while (pSrc != pdwNext)                                                   
        {                                                                         
            /* Get the amount of data for this opcode */                          
            int len = (*pSrc & 0x3F) + 1;                                             

            USB_TIMEOUT_FIX(ppdev)
                                                                                  
            while( len-- ) *pDest = *pSrc++;                                      
                                                                                  
        }                                                                         
                                                                                  
    }                       
    
#endif // 0

    ppdev->LL_State.pDL->pdwNext = ppdev->LL_State.pDL->pdwStartOutPtr = pdwStart;

}


VOID FASTCALL __MCDRenderGenLine(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL resetLine)
{
    // MGA and S3 MCD's have no code in this proc
    MCDBG_PRINT("__MCDRenderGenLine - EMPTY ROUTINE");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\mcdnabl.c ===
/******************************Module*Header*******************************\
*
* Module Name: enable.c
* Author: Mark Einkauf
* Purpose: Interface to display driver
*
* Copyright (c) 1997 Cirrus Logic, Inc.
*
\**************************************************************************/

#include "precomp.h"
#include "mcdhw.h"
#include "mcdutil.h"



// Called by display driver from DrvAssertMode
// Need to free any textures in video memory, since video memory is 
// about to be reconfigured

VOID AssertModeMCD(
PDEV*   ppdev,
BOOL    bEnabled)
{
    LL_Texture *pTexCtlBlk;

    MCDBG_PRINT("AssertModeMCD");

    pTexCtlBlk = ppdev->pFirstTexture->next;
    while (pTexCtlBlk)
    {
        if (pTexCtlBlk->pohTextureMap)
        {
            ppdev->pFreeOffScnMem(ppdev, pTexCtlBlk->pohTextureMap);
            pTexCtlBlk->pohTextureMap = NULL;
        }
        pTexCtlBlk = pTexCtlBlk->next;
    }

}


MCDRVGETENTRYPOINTSFUNC CLMCDInit(PPDEV ppdev)
{
    int i;
    
    ppdev->cZBufferRef = (LONG) NULL;
    ppdev->cDoubleBufferRef = (LONG) NULL;
    ppdev->pMCDFilterFunc = (MCDENGESCFILTERFUNC) NULL;
    ppdev->pohBackBuffer = (POFMHDL) NULL;
    ppdev->pohZBuffer = (POFMHDL) NULL;
    ppdev->pAssertModeMCD = AssertModeMCD;

	// set pRegs to top of memory mapped register space
	ppdev->LL_State.pRegs = (DWORD *)ppdev->pLgREGS;

    LL_InitLib(ppdev);  // initialize 3d state

    // floating point reciprocal table
    ppdev->frecips[0]=(float)0.0;
    for ( i=1; i<=LAST_FRECIP; i++)
    {
        ppdev->frecips[i]= (float)1.0 / (float)i;
    }

    // alloc first (dummy) texture control block
    ppdev->pFirstTexture = ppdev->pLastTexture = (LL_Texture *)MCDAlloc(sizeof(LL_Texture));

    if ( ppdev->pFirstTexture ) 
    {
        ppdev->pFirstTexture->prev = ppdev->pFirstTexture->next = NULL;
        ppdev->pFirstTexture->pohTextureMap = NULL;
    }

    return(MCDrvGetEntryPoints);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\mcdprim.c ===
/******************************Module*Header*******************************\
* Module Name: mcdprim.c
*
* These routines process the OpenGL rendering commands that appear in an
* MCDrvDraw() batch.  Note that the only OpenGL primitive which is invalid
* is LineLoop.  This gets decomposed by the caller into a LineStrip command.
*
* Copyright (c) 1996 Microsoft Corporation
* Copyright (c) 1997 Cirrus Logic, Inc.
\**************************************************************************/

#include "precomp.h"

#include "mcdhw.h"
#include "mcdutil.h"

#define MEMCHECK_VERTEX(p)\
    if (((UCHAR *)p < pRc->pMemMin) ||\
        ((UCHAR *)p > pRc->pMemMax)) {\
        MCDBG_PRINT("Invalid MCD vertex pointer!");\
        return NULL;\
    }

////////////////////////////////////////////////////////////////////////
//
// The functions below are local rendering-helper functions which call
// the real rendering routines in the driver.
//
////////////////////////////////////////////////////////////////////////


// MCD_NOTE: Confusing routine name - this is static to this proc, not to be confused
// MCD_NOTE:    with global routine of same name in mcdpoint.c

VOID static FASTCALL __MCDRenderPoint(DEVRC *pRc, MCDVERTEX *v)
{
    if (v->clipCode == 0)
	(*pRc->renderPoint)(pRc, v);
}

VOID static FASTCALL __MCDRenderLine(DEVRC *pRc, MCDVERTEX *v0,
                                     MCDVERTEX *v1, BOOL bResetLine)
{
    if (v0->clipCode | v1->clipCode)
    {
	/*
	 * The line must be clipped more carefully.  Cannot
	 * trivially accept the lines.
	 *
	 * If anding the codes is non-zero then every vertex
	 * in the line is outside of the same set of clipping
	 * planes (at least one).  Trivially reject the line.  
	 */
	if ((v0->clipCode & v1->clipCode) == 0)
	    (*pRc->clipLine)(pRc, v0, v1, bResetLine);
    }
    else
    {
	// Line is trivially accepted so render it
        (*pRc->renderLine)(pRc, v0, v1, bResetLine);
    }
}

VOID static FASTCALL __MCDRenderTriangle(DEVRC *pRc, MCDVERTEX *v0, 
                                         MCDVERTEX *v1, MCDVERTEX *v2)
{
    ULONG orCodes;

    /* Clip check */
    orCodes = v0->clipCode | v1->clipCode | v2->clipCode;
    if (orCodes)
    {
	/* Some kind of clipping is needed.
	 *
	 * If anding the codes is non-zero then every vertex
	 * in the triangle is outside of the same set of
	 * clipping planes (at least one).  Trivially reject
	 * the triangle.
	 */
	if (!(v0->clipCode & v1->clipCode & v2->clipCode))
	    (*pRc->clipTri)(pRc, v0, v1, v2, orCodes);
    }
    else
    {
	(*pRc->renderTri)(pRc, v0, v1, v2);
    }
}

VOID static FASTCALL __MCDRenderQuad(DEVRC *pRc, MCDVERTEX *v0, 
                                     MCDVERTEX *v1, MCDVERTEX *v2, MCDVERTEX *v3)
{
// Vertex ordering is important.  Line stippling uses it.

    ULONG savedTag;

    /* Render the quad as two triangles */
    savedTag = v2->flags & MCDVERTEX_EDGEFLAG;
    v2->flags &= ~MCDVERTEX_EDGEFLAG;
    (*pRc->renderTri)(pRc, v0, v1, v2);
    v2->flags |= savedTag;
    savedTag = v0->flags & MCDVERTEX_EDGEFLAG;
    v0->flags &= ~MCDVERTEX_EDGEFLAG;
    (*pRc->renderTri)(pRc, v2, v3, v0);
    v0->flags |= savedTag;
}

VOID static FASTCALL __MCDRenderClippedQuad(DEVRC *pRc, MCDVERTEX *v0, 
                                            MCDVERTEX *v1, MCDVERTEX *v2, MCDVERTEX *v3)
{
    ULONG orCodes;

    orCodes = v0->clipCode | v1->clipCode | v2->clipCode | v3->clipCode;

    if (orCodes)
    {
	/* Some kind of clipping is needed.
	 *
	 * If anding the codes is non-zero then every vertex
	 * in the quad is outside of the same set of
	 * clipping planes (at least one).  Trivially reject
	 * the quad.
	 */
        if (!(v0->clipCode & v1->clipCode & v2->clipCode & v3->clipCode))
        {
            /* Clip the quad as a polygon */
            MCDVERTEX *iv[4];

            iv[0] = v0;
            iv[1] = v1;
            iv[2] = v2;
            iv[3] = v3;
            (pRc->doClippedPoly)(pRc, &iv[0], 4, orCodes);
        }
    }
    else
    {
	__MCDRenderQuad(pRc, v0, v1, v2, v3);
    }
}

////////////////////////////////////////////////////////////////////////
//
// The functions below handle the processing of all of the primitives
// which may appear in an MCDCOMMAND.  This includes all of the OpenGL
// primitives, with the exception of line loops which are handled as
// line strips.
//
////////////////////////////////////////////////////////////////////////


MCDCOMMAND * FASTCALL __MCDPrimDrawPoints(DEVRC *pRc, MCDCOMMAND *pCmd)
{
    LONG i, nIndices;
    MCDVERTEX *pv;
    VOID (FASTCALL *rp)(DEVRC *pRc, MCDVERTEX *v);

    unsigned int *pdwNext = pRc->ppdev->LL_State.pDL->pdwNext;

    // do this once here, instead of in renderpoint proc
    *pdwNext++ = write_register( Y_COUNT_3D, 1 );
    *pdwNext++ = 0;
    *pdwNext++ = write_register( WIDTH1_3D, 1 );
    *pdwNext++ = 0x10000;

    // render proc will output from startoutptr, not from pdwNext, 
    // so this will be sent in proc called below
    pRc->ppdev->LL_State.pDL->pdwNext = pdwNext;

// Index mapping is always identity in Points.

//    ASSERTOPENGL(!pa->aIndices, "Index mapping must be identity\n");

    if (pCmd->clipCodes)
	rp = __MCDRenderPoint;
    else
	rp = pRc->renderPoint;

    // Render the points:

    pv = pCmd->pStartVertex;
    MEMCHECK_VERTEX(pv);
    i = pCmd->numIndices;
    MEMCHECK_VERTEX(pv + (i - 1));

    for (; i > 0; i--, pv++)
	(*rp)(pRc, pv);

    return pCmd->pNextCmd;
}


MCDCOMMAND * FASTCALL __MCDPrimDrawLines(DEVRC *pRc, MCDCOMMAND *pCmd)
{
    LONG i, iLast2;
    UCHAR *pIndices;
    MCDVERTEX *pv, *pv0, *pv1;
    VOID (FASTCALL *rl)(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL bResetLine);

    iLast2 = pCmd->numIndices - 2;
    pv     = pCmd->pStartVertex;
    rl = pCmd->clipCodes ? __MCDRenderLine : pRc->renderLine;

    if (!(pIndices = pCmd->pIndices))
    {
	// Identity mapping

        MEMCHECK_VERTEX(pv);
        MEMCHECK_VERTEX(pv + (iLast2 + 1));
   
	for (i = 0; i <= iLast2; i += 2)
	{
	    /* setup for rendering this line */

            // pRc->resetLineStipple = TRUE;

	    (*rl)(pRc, &pv[i], &pv[i+1], TRUE);
	}
    }
    else
    {
        pv1 = &pv[pIndices[0]];
        MEMCHECK_VERTEX(pv1);

	for (i = 0; i <= iLast2; i += 2)
	{
            pv0 = pv1;
            pv1 = &pv[pIndices[i+1]];
            MEMCHECK_VERTEX(pv1);

	    /* setup for rendering this line */

            // pRc->resetLineStipple = TRUE;

	    (*rl)(pRc, pv0, pv1, TRUE);
	}
    }

    return pCmd->pNextCmd;
}


MCDCOMMAND * FASTCALL __MCDPrimDrawLineLoop(DEVRC *pRc, MCDCOMMAND *pCmd)
{
    // NOTE:
    // Line loops are always converted tp line strips at the OpenGL
    // API level.  This routine is currently not used.

    MCDBG_PRINT("MCDPrimLineLoop: Invalid MCD command!");

    return pCmd->pNextCmd;
}


MCDCOMMAND * FASTCALL __MCDPrimDrawLineStrip(DEVRC *pRc, MCDCOMMAND *pCmd)
{
    LONG i, iLast;
    UCHAR *pIndices;
    MCDVERTEX *pv, *pv0, *pv1;
    MCDVERTEX *vOld;
    VOID (FASTCALL *rl)(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL bResetLine);

    iLast = pCmd->numIndices - 1;
    pv    = pCmd->pStartVertex;
    rl = pCmd->clipCodes ? __MCDRenderLine : pRc->renderLine;
    if (iLast <= 0)
	return pCmd->pNextCmd;

    /*
    if (pCmd->flags & MCDCOMMAND_RESET_STIPPLE)
        pRc->resetLineStipple = TRUE;
    */

    if (!(pIndices = pCmd->pIndices))
    {
	// Identity mapping
	// Add first line segment (NOTE: 0, 1)
       
        MEMCHECK_VERTEX(pv);
        MEMCHECK_VERTEX(pv + iLast);

	(*rl)(pRc, &pv[0], &pv[1], TRUE);

	// Add subsequent line segments (NOTE: i, i+1)
	for (i = 1; i < iLast; i++) {
	    (*rl)(pRc, &pv[i], &pv[i+1], FALSE);
        }
    }
    else
    {
	// Add first line segment (NOTE: 0, 1)

        pv0 = &pv[pIndices[0]];
        pv1 = &pv[pIndices[1]];
	(*rl)(pRc, pv0, pv1, TRUE);

	// Add subsequent line segments (NOTE: i, i+1)

	for (i = 1; i < iLast; i++) {
            pv0 = pv1;
            pv1 = &pv[pIndices[i+1]];
            MEMCHECK_VERTEX(pv1);
	    (*rl)(pRc, pv0, pv1, FALSE);
        }
    }

    return pCmd->pNextCmd;
}


MCDCOMMAND * FASTCALL __MCDPrimDrawTriangles(DEVRC *pRc, MCDCOMMAND *pCmd)
{
    LONG i, iLast3;
    UCHAR *pIndices;
    MCDVERTEX *pv, *pv0, *pv1, *pv2;
    VOID (FASTCALL *rt)(DEVRC *pRc, MCDVERTEX *v0, MCDVERTEX *v1, MCDVERTEX *v2);

    iLast3 = pCmd->numIndices - 3;
    pv     = pCmd->pStartVertex;
    if (pCmd->clipCodes)
	rt = __MCDRenderTriangle;
    else
	rt = pRc->renderTri;


    if (!(pIndices = pCmd->pIndices))
    {
	// Identity mapping

        MEMCHECK_VERTEX(pv);
        MEMCHECK_VERTEX(pv + (iLast3 + 2));

	for (i = 0; i <= iLast3; i += 3)
	{
	    /* setup for rendering this triangle */

            // pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = &pv[i+2];

	    /* Render the triangle (NOTE: i, i+1, i+2) */
	    (*rt)(pRc, &pv[i], &pv[i+1], &pv[i+2]);
	}
    }
    else
    {
	for (i = 0; i <= iLast3; i += 3)
	{
	    /* setup for rendering this triangle */

            pv0 = &pv[pIndices[i  ]];
            pv1 = &pv[pIndices[i+1]];
            pv2 = &pv[pIndices[i+2]];

            MEMCHECK_VERTEX(pv0);
            MEMCHECK_VERTEX(pv1);
            MEMCHECK_VERTEX(pv2);

            // pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = pv2;

	    /* Render the triangle (NOTE: i, i+1, i+2) */
	    (*rt)(pRc, pv0, pv1, pv2);
	}
    }

    return pCmd->pNextCmd;
}


MCDCOMMAND * FASTCALL __MCDPrimDrawTriangleStrip(DEVRC *pRc, MCDCOMMAND *pCmd)
{
    LONG i, iLast3;
    UCHAR *pIndices;
    MCDVERTEX *pv, *pv0, *pv1, *pv2;
    VOID (FASTCALL *rt)(DEVRC *pRc, MCDVERTEX *v0, MCDVERTEX *v1, MCDVERTEX *v2);

    iLast3 = pCmd->numIndices - 3;
    pv     = pCmd->pStartVertex;
    if (pCmd->clipCodes)
	rt = __MCDRenderTriangle;
    else
	rt = pRc->renderTri;

    if (iLast3 < 0)
	return pCmd->pNextCmd;

    if (!(pIndices = pCmd->pIndices))
    {
	// Identity mapping

        MEMCHECK_VERTEX(pv);
        MEMCHECK_VERTEX(pv + (iLast3 + 2));

        pv[0].flags |= MCDVERTEX_EDGEFLAG;
        pv[1].flags |= MCDVERTEX_EDGEFLAG;

	for (i = 0; i <= iLast3; i++)
	{
	    /* setup for rendering this triangle */

            // pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = &pv[i+2];
            pv[i+2].flags |= MCDVERTEX_EDGEFLAG;

	    /* Render the triangle (NOTE: i, i+1, i+2) */
	    (*rt)(pRc, &pv[i], &pv[i+1], &pv[i+2]);

	    if (++i > iLast3)
		break;

            // pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = &pv[i+2];
            pv[i+2].flags |= MCDVERTEX_EDGEFLAG;

	    /* Render the triangle (NOTE: i+1, i, i+2) */
	    (*rt)(pRc, &pv[i+1], &pv[i], &pv[i+2]);
	}
    }
    else
    {

	pv1 = &pv[pIndices[0]];
        MEMCHECK_VERTEX(pv1);
        pv1->flags |= MCDVERTEX_EDGEFLAG;

	pv2 = &pv[pIndices[1]];
        MEMCHECK_VERTEX(pv2);
        pv2->flags |= MCDVERTEX_EDGEFLAG;

	for (i = 0; i <= iLast3; i++)
	{
	    /* setup for rendering this triangle */

            // pRc->resetLineStipple = TRUE;

            pv0 = pv1;
            pv1 = pv2;

            pv2 = &pv[pIndices[i+2]];
            MEMCHECK_VERTEX(pv2);
	    pv2->flags |= MCDVERTEX_EDGEFLAG;

            // pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = pv2;

	    /* Render the triangle (NOTE: i, i+1, i+2) */
	    (*rt)(pRc, pv0, pv1, pv2);

	    if (++i > iLast3)
		break;

            pv0 = pv1;
            pv1 = pv2;

            pv2 = &pv[pIndices[i+2]];
            MEMCHECK_VERTEX(pv2);
	    pv2->flags |= MCDVERTEX_EDGEFLAG;

	    /* setup for rendering this triangle */

            // pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = pv2;

	    /* Render the triangle (NOTE: i+1, i, i+2) */
	    (*rt)(pRc, pv1, pv0, pv2);
	}
    }

    return pCmd->pNextCmd;
}


MCDCOMMAND * FASTCALL __MCDPrimDrawTriangleFan(DEVRC *pRc, MCDCOMMAND *pCmd)
{
    LONG i, iLast2;
    UCHAR *pIndices;
    MCDVERTEX *pv, *pv0, *pv1, *pv2;
    VOID (FASTCALL *rt)(DEVRC *pRc, MCDVERTEX *v0, MCDVERTEX *v1, MCDVERTEX *v2);

    iLast2 = pCmd->numIndices - 2;
    pv     = pCmd->pStartVertex;
    if (pCmd->clipCodes)
	rt = __MCDRenderTriangle;
    else
	rt = pRc->renderTri;

    if (iLast2 <= 0)
	return pCmd->pNextCmd;

    if (!(pIndices = pCmd->pIndices))
    {
	// Identity mapping

        MEMCHECK_VERTEX(pv);
        MEMCHECK_VERTEX(pv + (iLast2 + 1));

        pv[0].flags |= MCDVERTEX_EDGEFLAG;
        pv[1].flags |= MCDVERTEX_EDGEFLAG;

	for (i = 1; i <= iLast2; i++)
	{
	    /* setup for rendering this triangle */

            // pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = &pv[i+1];
            pv[i+1].flags |= MCDVERTEX_EDGEFLAG;

	    /* Render the triangle (NOTE: 0, i, i+1) */
	    (*rt)(pRc, &pv[0], &pv[i], &pv[i+1]);
	}
    }
    else
    {
	// Initialize first 2 vertices so we can start rendering the tfan
	// below.  The edge flags are not modified by our lower level routines.

        pv0 = &pv[pIndices[0]];
        MEMCHECK_VERTEX(pv0);
	pv0->flags |= MCDVERTEX_EDGEFLAG;

        pv2 = &pv[pIndices[1]];
        MEMCHECK_VERTEX(pv2);
	pv2->flags |= MCDVERTEX_EDGEFLAG;

	for (i = 1; i <= iLast2; i++)
	{
            pv1 = pv2;

            pv2 = &pv[pIndices[i+1]];
            MEMCHECK_VERTEX(pv2);
            pv2->flags |= MCDVERTEX_EDGEFLAG;

	    /* setup for rendering this triangle */
            // pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = pv2;

	    /* Render the triangle (NOTE: 0, i, i+1) */
	    (*rt)(pRc, pv0, pv1, pv2);
	}
    }

    return pCmd->pNextCmd;    
}


MCDCOMMAND * FASTCALL __MCDPrimDrawQuads(DEVRC *pRc, MCDCOMMAND *pCmd)
{
    LONG i, iLast4;
    UCHAR *pIndices;
    MCDVERTEX *pv, *pv0, *pv1, *pv2, *pv3;
    VOID (FASTCALL *rq)(DEVRC *pRc, MCDVERTEX *v0, MCDVERTEX *v1, MCDVERTEX *v2,
                        MCDVERTEX *v3);

    iLast4 = pCmd->numIndices - 4;
    pv     = pCmd->pStartVertex;

    if (pCmd->clipCodes)
	rq = __MCDRenderClippedQuad;
    else
	rq = __MCDRenderQuad;

    if (!(pIndices = pCmd->pIndices))
    {

        MEMCHECK_VERTEX(pv);
        MEMCHECK_VERTEX(pv + (iLast4 + 3));

	// Identity mapping
	for (i = 0; i <= iLast4; i += 4)
	{
            // pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = &pv[i+3];

	    /* Render the quad (NOTE: i, i+1, i+2, i+3) */
	    (*rq)(pRc, &pv[i], &pv[i+1], &pv[i+2], &pv[i+3]);
	}
    }
    else
    {
	for (i = 0; i <= iLast4; i += 4)
	{

            pv0 = &pv[pIndices[i  ]];
            pv1 = &pv[pIndices[i+1]];
            pv2 = &pv[pIndices[i+2]];
            pv3 = &pv[pIndices[i+3]];

            MEMCHECK_VERTEX(pv0);
            MEMCHECK_VERTEX(pv1);
            MEMCHECK_VERTEX(pv2);
            MEMCHECK_VERTEX(pv3);


            // pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = pv3;

	    /* Render the quad (NOTE: i, i+1, i+2, i+3) */
	    (*rq)(pRc, pv0, pv1, pv2, pv3);
	}
    }

    return pCmd->pNextCmd;
}


MCDCOMMAND * FASTCALL __MCDPrimDrawQuadStrip(DEVRC *pRc, MCDCOMMAND *pCmd)
{
    ULONG i, iLast4;
    UCHAR *pIndices;
    MCDVERTEX *pv, *pv0, *pv1, *pv2, *pv3;
    VOID (FASTCALL *rq)(DEVRC *pRc, MCDVERTEX *v0, MCDVERTEX *v1, MCDVERTEX *v2,
	MCDVERTEX *v3);

    iLast4 = pCmd->numIndices - 4;
    pv     = pCmd->pStartVertex;
    if (pCmd->clipCodes)
	rq = __MCDRenderClippedQuad;
    else
	rq = __MCDRenderQuad;

    if (iLast4 < 0)
	return pCmd->pNextCmd;

    // Vertex ordering is important.  Line stippling uses it.

    if (!(pIndices = pCmd->pIndices))
    {
	// Identity mapping

        MEMCHECK_VERTEX(pv);
        MEMCHECK_VERTEX(pv + (iLast4 + 3));

        pv[0].flags |= MCDVERTEX_EDGEFLAG;
        pv[1].flags |= MCDVERTEX_EDGEFLAG;

	for (i = 0; i <= iLast4; i += 2)
	{
            pv[i+2].flags |= MCDVERTEX_EDGEFLAG;
            pv[i+3].flags |= MCDVERTEX_EDGEFLAG;

	    /* setup for rendering this quad */

            pRc->pvProvoking = &pv[i+3];
            // pRc->resetLineStipple = TRUE;

	    /* Render the quad (NOTE: i, i+1, i+3, i+2) */
	    (*rq)(pRc, &pv[i], &pv[i+1], &pv[i+3], &pv[i+2]);
	}
    }
    else
    {
	// Initialize first 2 vertices so we can start rendering the quad
	// below.  The edge flags are not modified by our lower level routines.

        pv2 = &pv[pIndices[0]];
        MEMCHECK_VERTEX(pv2);
        pv2->flags |= MCDVERTEX_EDGEFLAG;

        pv3 = &pv[pIndices[1]];
        MEMCHECK_VERTEX(pv3);
        pv3->flags |= MCDVERTEX_EDGEFLAG;

	for (i = 0; i <= iLast4; i += 2)
	{

            pv0 = pv2;
            pv1 = pv3;

            pv2 = &pv[pIndices[i+2]];
            MEMCHECK_VERTEX(pv2);
            pv2->flags |= MCDVERTEX_EDGEFLAG;

            pv3 = &pv[pIndices[i+3]];
            MEMCHECK_VERTEX(pv3);
            pv3->flags |= MCDVERTEX_EDGEFLAG;

	    /* setup for rendering this quad */

            // pRc->resetLineStipple = TRUE;
            pRc->pvProvoking = pv3;

	    /* Render the quad (NOTE: i, i+1, i+3, i+2) */

	    (*rq)(pRc, pv0, pv1, pv3, pv2);
	}
    }

    return pCmd->pNextCmd;
}


MCDCOMMAND * FASTCALL __MCDPrimDrawPolygon(DEVRC *pRc, MCDCOMMAND *pCmd)
{

//    ASSERTOPENGL(!pCmd->pIndices, "Index mapping must be identity\n");

    // Reset the line stipple if this is a new polygon:

    /*
    if (pCmd->flags & MCDCOMMAND_RESET_STIPPLE)
        pRc->resetLineStipple = TRUE;
    */

    // Note that the provoking vertex is set in clipPolygon:

    MEMCHECK_VERTEX(pCmd->pStartVertex);
    MEMCHECK_VERTEX(pCmd->pStartVertex + (pCmd->numIndices-1));

    (*pRc->clipPoly)(pRc, pCmd->pStartVertex, pCmd->numIndices);

    return pCmd->pNextCmd;
}





MCDCOMMAND * FASTCALL __MCDPrimDrawStub(DEVRC *pRc, MCDCOMMAND *pCmd)
{
    MCDBG_PRINT("__MCDPrimDrawStub");\

    return pCmd->pNextCmd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\mcdrv.h ===
/******************************Module*Header*******************************\
* Module Name: mcdrv.h
*
* Server-side data structure for MCD driver interface.  These structures and
* values are used by the MCD driver to process calls made to the driver.
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#ifndef _MCDRV_H
#define _MCDRV_H

#define MCD_VER_MAJOR               1
#define MCD_VER_MINOR               0

#define MCD_MAX_USER_CLIP_PLANES    6

#define MCDRV_MEM_BUSY              1
#define MCDRV_MEM_NOT_BUSY          2

typedef ENUMRECTS MCDENUMRECTS;
typedef HANDLE MCDHANDLE;
typedef float MCDFLOAT;
typedef double MCDDOUBLE;

#define MCDENGDLLNAME	"MCDSRV32.DLL"
#define MCDFUNCS RXFUNCS

#define MCDRV_MEM_DMA   0x0001

#define MCDRV_TEXTURE_RESIDENT	0x0001

typedef struct _MCDRIVERINFO {
    ULONG verMajor;
    ULONG verMinor;
    ULONG verDriver;
    CHAR  idStr[200];
    ULONG drvMemFlags;
    ULONG drvBatchMemSizeMax;
} MCDDRIVERINFO;

typedef struct _MCDWINDOW
{
    RECTL clientRect;               // Rectangle describing current window
                                    //   client area
    RECTL clipBoundsRect;           // Bounding rectangle for the individual
                                    //   clipping rectangles
    MCDENUMRECTS *pClip;            // List of rectangles describing the
                                    //   current clip region intersected
                                    //   with the current scissors rectangle
    MCDENUMRECTS *pClipUnscissored; // Unscissored version of above
    VOID *pvUser;
} MCDWINDOW;

// Rendering context

// MCD context createFlags:
//
// MCDCONTEXT_SWAPSYNC          If set, synchronize MCDrvSwap to VSYNC
//                              for a tearless swap (if possible).
//
// MCDCONTEXT_IO_PRIORITY       If set, allow OpenGL to have a higher priority
//                              on the bus (if possible, let OpenGL "hog" the
//                              bus).
//

#define MCDCONTEXT_SWAPSYNC         0x00000001
#define MCDCONTEXT_IO_PRIORITY      0x00000002

typedef struct _MCDRC
{
    LONG iPixelFormat;              // Pixel format for the RC
    LONG iLayerPlane;               // Layer plane for the RC
    ULONG createFlags;              // Creation flags
    ULONG userFlags;                // User-specified flags
    VOID *pvUser;                   // User-specified pointer for expansion
} MCDRC;


#define MCDRCINFO_NOVIEWPORTADJUST   0x0001
#define MCDRCINFO_Y_LOWER_LEFT       0x0002
#define MCDRCINFO_DEVCOLORSCALE      0x0004
#define MCDRCINFO_DEVZSCALE          0x0008

typedef struct _MCRCINFO
{
    ULONG requestFlags;
    MCDFLOAT redScale;
    MCDFLOAT greenScale;
    MCDFLOAT blueScale;
    MCDFLOAT alphaScale;
    MCDDOUBLE zScale;               // This is a double to preserve accuracy
    ULONG depthBufferMax;
    LONG viewportXAdjust;
    LONG viewportYAdjust;
    ULONG reserved[12];
} MCDRCINFO;

// MCD pixel format descriptor

typedef struct _MCDPIXELFORMAT {
    WORD  nSize;
    DWORD dwFlags;                  // Any combination of:
                                    //
                                    //      PFD_DOUBLEBUFFER
                                    //      PFD_NEED_PALETTE
                                    //      PFD_NEED_SYSTEM_PALETTE
                                    //      PFD_SWAP_EXCHANGE
                                    //      PFD_SWAP_COPY
                                    //      PFD_SWAP_LAYER_BUFFERS

    BYTE  iPixelType;               // One of the following:
                                    //
                                    //      PFD_TYPE_RGBA
                                    //      PFD_TYPE_COLORINDEX

    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cDepthBits;               // Number of significant depth bits
    BYTE  cDepthShift;
    BYTE  cDepthBufferBits;         // Element size of depth buffer
                                    // (eg, a depth buffer with cDepthBits = 24
                                    // might have a cDepthBufferBits = 32)
    BYTE  cStencilBits;
    BYTE  cOverlayPlanes;           // Count of up to 15 overlay planes
    BYTE  cUnderlayPlanes;          // Count of up to 15 underlay planes
    DWORD dwTransparentColor;       // If there is an underlay plane, specifies
                                    // transparent color or index.
} MCDPIXELFORMAT;

// MCD layer plane descriptor

typedef struct _MCDLAYERPLANE {
    WORD  nSize;
    WORD  nVersion;
    DWORD dwFlags;                  // Any combination of:
                                    //
                                    //      LPD_SUPPORT_OPENGL
                                    //      LPD_SUPPORT_GDI
                                    //      LPD_DOUBLEBUFFER
                                    //      LPD_STEREO
                                    //      LPD_SWAP_EXCHANGE
                                    //      LPD_SWAP_COPY
                                    //      LPD_TRANSPARANT
                                    //      LPD_SHARE_DEPTH
                                    //      LPD_SHARE_STENCIL
                                    //      LPD_SHARE_ACCUM

    BYTE  iPixelType;               // One of the following:
                                    //
                                    //      LPD_TYPE_RGBA
                                    //      LPD_TYPE_COLORINDEX

    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cAuxBuffers;
    BYTE  iLayerPlane;
    COLORREF crTransparent;

} MCDLAYERPLANE;

//
// Basic rendering types:
//

typedef struct _MCDCOLOR {
    MCDFLOAT r, g, b, a;
} MCDCOLOR;

typedef struct _MCDCOORD {
    MCDFLOAT x, y, z, w;
} MCDCOORD;

// Texture structures:

typedef struct __MCDMIPMAPLEVEL {
    UCHAR *pTexels;                     // pointer to client texture data
    LONG width, height;
    LONG widthImage, heightImage;       // Image dimensions without the border
    MCDFLOAT widthImagef, heightImagef; // Floatin-point versions of above
    LONG widthLog2, heightLog2;         // Log2 of above
    LONG border;                        // Border size
    LONG requestedFormat;               // Requested internal format
    LONG baseFormat;                    // Base format
    LONG internalFormat;                // Actual internal format

    LONG redSize;                       // Component resolution
    LONG greenSize;
    LONG blueSize;
    LONG alphaSize;
    LONG luminanceSize;
    LONG intensitySize;

    ULONG reserved;

} MCDMIPMAPLEVEL;

typedef struct __MCDTEXTURESTATE {

    ULONG sWrapMode;                    // Wrap modes
    ULONG tWrapMode;

    ULONG minFilter;                    // Min/mag filters               
    ULONG magFilter;

    MCDCOLOR borderColor;               // Border color

} MCDTEXTURESTATE;

typedef struct __MCDTEXTUREOBJSTATE {
    ULONG name;                         // "name" of texture object
    MCDFLOAT priority;                  // priority of the texture object
} MCDTEXTUREOBJSTATE;

typedef struct __MCDTEXTUREDATA {
    MCDTEXTURESTATE textureState;
    MCDTEXTUREOBJSTATE textureObjState;
    MCDMIPMAPLEVEL *level;
    ULONG textureDimension;

    // Support for texture palettes:

    ULONG paletteSize;
    RGBQUAD *paletteData;
    ULONG paletteBaseFormat;            // Type of palette data
    ULONG paletteRequestedFormat;

} MCDTEXTUREDATA;

typedef struct _MCDTEXTURE {
    MCDTEXTUREDATA *pMCDTextureData;
    VOID *pSurface;
    ULONG createFlags;
    ULONG textureKey;       // Must be filled in by the driver
    ULONG userFlags;
    VOID *pvUser;
} MCDTEXTURE;


typedef struct _MCDMEM {
    ULONG memSize;
    ULONG createFlags;
    UCHAR *pMemBase;
    ULONG userFlags;
    VOID *pvUser;
} MCDMEM;

typedef struct _MCDSTATE {
    ULONG state;
    ULONG size;
    ULONG stateValue;
} MCDSTATE;

#define MCD_RENDER_STATE            0
#define MCD_PIXEL_STATE             1
#define MCD_SCISSOR_RECT_STATE      2
#define MCD_TEXENV_STATE            3

//
// MCDSTATE_RENDER is derived from the MCDSTATE structure and is used
// to pass all MCD rendering state (MCDALLSTATE) in a single command
// via MCDrvState.
//
// State field names are derived from the GLenum constant names by removing
// the GL_ prefix, replacing the "_" separators with case changes, and
// adding the "Enable" suffix to state enables.
//
// For example:
//
//  GL_FOG_COLOR    becomes     fogColor
//  GL_POINT_SMOOTH becomes     pointSmoothEnable
//
// In addition, there are few multiple values that are accessed via a single
// GLenum.  For example, GL_POLYGON_MODE returns both a front and a back
// polygon mode, so:
//
//  GL_POLYGON_MODE becomes     polygonModeFront *and* polygonModeBack
//

// Enable flags for enables field in MCDALLSTATE

#define MCD_ALPHA_TEST_ENABLE                  (1 <<  0)
#define MCD_BLEND_ENABLE                       (1 <<  1)
#define MCD_INDEX_LOGIC_OP_ENABLE              (1 <<  2)
#define MCD_DITHER_ENABLE                      (1 <<  3)
#define MCD_DEPTH_TEST_ENABLE                  (1 <<  4)
#define MCD_FOG_ENABLE                         (1 <<  5)
#define MCD_LIGHTING_ENABLE                    (1 <<  6)
#define MCD_COLOR_MATERIAL_ENABLE              (1 <<  7) // Not currently used
#define MCD_LINE_STIPPLE_ENABLE                (1 <<  8)
#define MCD_LINE_SMOOTH_ENABLE                 (1 <<  9)
#define MCD_POINT_SMOOTH_ENABLE                (1 << 10)
#define MCD_POLYGON_SMOOTH_ENABLE              (1 << 11)
#define MCD_CULL_FACE_ENABLE                   (1 << 12)
#define MCD_POLYGON_STIPPLE_ENABLE             (1 << 13)
#define MCD_SCISSOR_TEST_ENABLE                (1 << 14)
#define MCD_STENCIL_TEST_ENABLE                (1 << 15)
#define MCD_TEXTURE_1D_ENABLE                  (1 << 16)
#define MCD_TEXTURE_2D_ENABLE                  (1 << 17)
#define MCD_TEXTURE_GEN_S_ENABLE               (1 << 18) // Not currently used
#define MCD_TEXTURE_GEN_T_ENABLE               (1 << 19) // Not currently used
#define MCD_TEXTURE_GEN_R_ENABLE               (1 << 20) // Not currently used
#define MCD_TEXTURE_GEN_Q_ENABLE               (1 << 21) // Not currently used
#define MCD_NORMALIZE_ENABLE                   (1 << 22) // Not currently used
#define MCD_AUTO_NORMAL_ENABLE                 (1 << 23) // Not currently used
#define MCD_POLYGON_OFFSET_POINT_ENABLE        (1 << 24)
#define MCD_POLYGON_OFFSET_LINE_ENABLE         (1 << 25)
#define MCD_POLYGON_OFFSET_FILL_ENABLE         (1 << 26)
#define MCD_COLOR_LOGIC_OP_ENABLE              (1 << 27)

typedef struct _MCDRENDERSTATE {

    // state enables

    ULONG enables;

    // texture state

    BOOL textureEnabled;

    // fog state

    MCDCOLOR fogColor;
    MCDFLOAT fogIndex;
    MCDFLOAT fogDensity;
    MCDFLOAT fogStart;
    MCDFLOAT fogEnd;
    ULONG fogMode;

    // shading model state

    ULONG shadeModel;

    // point drawing state

    MCDFLOAT pointSize;

    // line drawing state

    MCDFLOAT lineWidth;
    USHORT lineStipplePattern;
    SHORT lineStippleRepeat;

    // polygon drawing state

    ULONG cullFaceMode;
    ULONG frontFace;
    ULONG polygonModeFront;
    ULONG polygonModeBack;
    BYTE polygonStipple[4*32];
    MCDFLOAT zOffsetFactor;
    MCDFLOAT zOffsetUnits;

    // stencil test state

    BOOL stencilTestFunc;
    USHORT stencilMask;
    USHORT stencilRef;
    ULONG stencilFail;
    ULONG stencilDepthFail;
    ULONG stencilDepthPass;

    // alpha test state

    ULONG alphaTestFunc;
    MCDFLOAT alphaTestRef;

    // depth test state

    ULONG depthTestFunc;

    // blend state

    ULONG blendSrc;
    ULONG blendDst;

    // logic op state

    ULONG logicOpMode;

    // frame buffer control state

    ULONG drawBuffer;
    ULONG indexWritemask;
    BOOL colorWritemask[4];
    BOOL depthWritemask;      //!!!mcd -- called mask, but really a write enable
    USHORT stencilWritemask;
    MCDCOLOR colorClearValue;
    MCDFLOAT indexClearValue;
    MCDDOUBLE depthClearValue;
    USHORT stencilClearValue;

    // lighting

    BOOL twoSided;

    // clipping control

    MCDCOORD userClipPlanes[MCD_MAX_USER_CLIP_PLANES];

    // hints

    ULONG perspectiveCorrectionHint;
    ULONG pointSmoothHint;
    ULONG lineSmoothHint;
    ULONG polygonSmoothHint;
    ULONG fogHint;

} MCDRENDERSTATE;

typedef struct _MCDSTATE_RENDER {
    ULONG    state;     // must be MCD_RENDER_STATE
    ULONG    size;      // must be sizeof(MCDSTATE_RENDER)
    MCDRENDERSTATE allState;
} MCDSTATE_RENDER;

//
// MCDSTATEPIXEL is a variant of the MCDSTATE structure that is used
// to pass all pixel state (MCDPIXELSTATE) in a single command
// via MCDrvState.
//
// Note: for MCDrvDrawPixels, the MCDUNPACK structure can be overridden by
// the packed parameter to the function.  If set, the source of the data is
// a display list and the structure of the data for that call may be assumed
// to be:
//
//      swapEndian = FALSE
//      lsbFirst   = FALSE
//      lineLength = width (from MCDrvDrawPixels parameter list)
//      skipLines  = 0
//      skipPixels = 0
//      alignment  = 1
//

typedef struct _MCDPIXELTRANSFER {
    MCDFLOAT redScale, greenScale, blueScale, alphaScale, depthScale;
    MCDFLOAT redbias, greenBias, blueBias, aalphaBias, depthBias;
    MCDFLOAT zoomX;
    MCDFLOAT zoomY;

    LONG indexShift;
    LONG indexOffset;

    BOOL mapColor;
    BOOL mapStencil;
} MCDPIXELTRANSFER;

typedef struct _MCDPIXELPACK {
    BOOL swapEndian;
    BOOL lsbFirst;

    LONG lineLength;
    LONG skipLines;
    LONG skipPixels;
    LONG alignment;
} MCDPIXELPACK;

typedef struct _MCDPIXELUNPACK {
    BOOL swapEndian;
    BOOL lsbFirst;

    LONG lineLength;
    LONG skipLines;
    LONG skipPixels;
    LONG alignment;
} MCDPIXELUNPACK;

typedef struct _MCDPIXELSTATE {
    MCDPIXELTRANSFER pixelTransferModes;
    MCDPIXELPACK pixelPackModes;
    MCDPIXELUNPACK pixelUnpackModes;
    ULONG readBuffer;
    MCDCOORD rasterPos;
} MCDPIXELSTATE;

typedef struct _MCDSTATE_PIXEL {
    ULONG    state;     // must be MCD_PIXEL_STATE
    ULONG    size;      // must be sizeof(MCDSTATE_PIXEL)
    MCDPIXELSTATE pixelState;
} MCDSTATE_PIXEL;

//
// MCDSTATE_SCISSOR_RECT is a variant of the MCDSTATE structure
// that is used to pass the scissor rectangle to the MCD driver
// via MCDrvState.
//

typedef struct _MCDSTATE_SCISSOR_RECT {
    ULONG   state;      // must be MCD_SCISSOR_RECT_STATE
    ULONG   size;       // must be sizeof(MCDSTATE_SCISSOR_RECT)
    RECTL   scissorRect;
} MCDSTATE_SCISSOR_RECT;

//
// MCDSTATE_TEXENV is a variant of the MCDSTATE structure that is
// used to pass the texture environment state to the MCD driver
// via MCDrvState.
//

typedef struct _MCDTEXENVSTATE {
    ULONG    texEnvMode;
    MCDCOLOR texEnvColor;
} MCDTEXENVSTATE;

typedef struct _MCDSTATE_TEXENV {
    ULONG   state;      // must be MCD_TEXENV_STATE
    ULONG   size;       // must be sizeof(MCDSTATE_TEXENV)
    MCDTEXENVSTATE texEnvState;
} MCDSTATE_TEXENV;

//
// MCDVIEWPORT is used to pass viewport state to the MCD driver
// via MCDrvViewport.

typedef struct _MCDVIEWPORT {
    MCDFLOAT xScale, xCenter;
    MCDFLOAT yScale, yCenter;
    MCDFLOAT zScale, zCenter;
} MCDVIEWPORT;

//
// MCD surface flags:
//
// MCDSURFACE_HWND              Currently must be set.

#define MCDSURFACE_HWND             0x00000001

typedef struct _MCDSURFACE {
    MCDWINDOW *pWnd;                // Region support
    SURFOBJ *pso;
    WNDOBJ *pwo;
    ULONG reserved[4];
    ULONG surfaceFlags;
} MCDSURFACE;

#define MCDSPAN_FRONT   1
#define MCDSPAN_BACK    2
#define MCDSPAN_DEPTH   3

typedef struct _MCDSPAN {
    LONG x;
    LONG y;
    LONG numPixels;
    ULONG type;
    VOID *pPixels;
} MCDSPAN;

//
// MCDBUF.bufFlags flags:
//
// MCDBUF_ENABLED       If set, direct buffer access is enabled (i.e., the
//                      bufOffset and bufStride values are valid and may
//                      be used to access the buffer).
//
// MCDBUF_NOCLIP        If set, indicates that clipping is not required
//                      for the current state of the window.
//

#define MCDBUF_ENABLED  0x00000001
#define MCDBUF_NOCLIP   0x00000002

typedef struct _MCDBUF {
    ULONG bufFlags;
    LONG  bufOffset;        // offset relative to beginning of framebuffer
    LONG  bufStride;
} MCDBUF;

typedef struct _MCDBUFFERS {
    MCDBUF mcdFrontBuf;
    MCDBUF mcdBackBuf;
    MCDBUF mcdDepthBuf;
} MCDBUFFERS;

//
// MCDrvSwap flags
//

#define MCDSWAP_MAIN_PLANE      0x00000001
#define MCDSWAP_OVERLAY1        0x00000002
#define MCDSWAP_OVERLAY2        0x00000004
#define MCDSWAP_OVERLAY3        0x00000008
#define MCDSWAP_OVERLAY4        0x00000010
#define MCDSWAP_OVERLAY5        0x00000020
#define MCDSWAP_OVERLAY6        0x00000040
#define MCDSWAP_OVERLAY7        0x00000080
#define MCDSWAP_OVERLAY8        0x00000100
#define MCDSWAP_OVERLAY9        0x00000200
#define MCDSWAP_OVERLAY10       0x00000400
#define MCDSWAP_OVERLAY11       0x00000800
#define MCDSWAP_OVERLAY12       0x00001000
#define MCDSWAP_OVERLAY13       0x00002000
#define MCDSWAP_OVERLAY14       0x00004000
#define MCDSWAP_OVERLAY15       0x00008000
#define MCDSWAP_UNDERLAY1       0x00010000
#define MCDSWAP_UNDERLAY2       0x00020000
#define MCDSWAP_UNDERLAY3       0x00040000
#define MCDSWAP_UNDERLAY4       0x00080000
#define MCDSWAP_UNDERLAY5       0x00100000
#define MCDSWAP_UNDERLAY6       0x00200000
#define MCDSWAP_UNDERLAY7       0x00400000
#define MCDSWAP_UNDERLAY8       0x00800000
#define MCDSWAP_UNDERLAY9       0x01000000
#define MCDSWAP_UNDERLAY10      0x02000000
#define MCDSWAP_UNDERLAY11      0x04000000
#define MCDSWAP_UNDERLAY12      0x08000000
#define MCDSWAP_UNDERLAY13      0x10000000
#define MCDSWAP_UNDERLAY14      0x20000000
#define MCDSWAP_UNDERLAY15      0x40000000

// MCDDRIVER structure containing driver functions

typedef LONG     (*MCDRVDESCRIBEPIXELFORMATFUNC)(MCDSURFACE *pMCDSurface, LONG iPixelFormat,
                                                 ULONG nBytes, MCDPIXELFORMAT *pMCDPixelFmt, ULONG flags);
typedef BOOL     (*MCDRVDESCRIBELAYERPLANEFUNC)(MCDSURFACE *pMCDSurface, LONG iPixelFormat,
                                                LONG iLayerPlane, ULONG nBytes, MCDLAYERPLANE *pMCDLayerPlane,
                                                ULONG flags);
typedef LONG     (*MCDRVSETLAYERPALETTEFUNC)(MCDSURFACE *pMCDSurface, LONG iLayerPlane, BOOL bRealize, LONG cEntries, COLORREF *pcr);
typedef BOOL     (*MCDRVINFOFUNC)(MCDSURFACE *pMCDSurface, MCDDRIVERINFO *pMCDDriverInfo);
typedef ULONG    (*MCDRVCREATECONTEXTFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDRCINFO *pDrvRcInfo);
typedef ULONG    (*MCDRVDELETECONTEXTFUNC)(MCDRC *pRc, DHPDEV dhpdev);
typedef ULONG    (*MCDRVCREATETEXTUREFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDTEXTURE *pTex);
typedef ULONG    (*MCDRVUPDATESUBTEXTUREFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDTEXTURE *pTex, 
                                              ULONG lod, RECTL *pRect);
typedef ULONG    (*MCDRVUPDATETEXTUREPALETTEFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDTEXTURE *pTex, 
                                                  ULONG start, ULONG numEntries);
typedef ULONG    (*MCDRVUPDATETEXTUREPRIORITYFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDTEXTURE *pTex);
typedef ULONG    (*MCDRVUPDATETEXTURESTATEFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDTEXTURE *pTex);
typedef ULONG    (*MCDRVTEXTURESTATUSFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDTEXTURE *pTex);
typedef ULONG    (*MCDRVDELETETEXTUREFUNC)(MCDTEXTURE *pTex, DHPDEV dhpdev);
typedef ULONG    (*MCDRVCREATEMEMFUNC)(MCDSURFACE *pMCDSurface, MCDMEM *pMCDMem);
typedef ULONG    (*MCDRVDELETEMEMFUNC)(MCDMEM *pMCDMem, DHPDEV dhpdev);
typedef ULONG    (*MCDRVDRAWFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDMEM *prxExecMem, UCHAR *pStart, UCHAR *pEnd);
typedef ULONG    (*MCDRVCLEARFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, ULONG buffers);
typedef ULONG    (*MCDRVSWAPFUNC)(MCDSURFACE *pMCDSurface, ULONG flags);
typedef ULONG    (*MCDRVSTATEFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDMEM *pMCDMem,
                                   UCHAR *pStart, LONG length, ULONG numStates);
typedef ULONG    (*MCDRVVIEWPORTFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDVIEWPORT *pMCDViewport);
typedef HDEV     (*MCDRVGETHDEVFUNC)(MCDSURFACE *pMCDSurface);
typedef ULONG    (*MCDRVSPANFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDMEM *pMCDMem,
                                  MCDSPAN *pMCDSpan, BOOL bRead);
typedef VOID     (*MCDRVTRACKWINDOWFUNC)(WNDOBJ *pWndObj, MCDWINDOW *pMCDWnd, ULONG flags);
typedef ULONG    (*MCDRVGETBUFFERSFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc, MCDBUFFERS *pMCDBuffers);
typedef ULONG    (*MCDRVALLOCBUFFERSFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc);
typedef ULONG    (*MCDRVBINDCONTEXTFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc);
typedef ULONG    (*MCDRVSYNCFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc);
typedef ULONG    (*MCDRVDRAWPIXELS)(MCDSURFACE *pMcdSurface, MCDRC *pRc,
                                    ULONG width, ULONG height, ULONG format,
                                    ULONG type, VOID *pPixels, BOOL packed);
typedef ULONG    (*MCDRVREADPIXELS)(MCDSURFACE *pMcdSurface, MCDRC *pRc,
                                    LONG x, LONG y, ULONG width, ULONG height, ULONG format,
                                    ULONG type, VOID *pPixels);
typedef ULONG    (*MCDRVCOPYPIXELS)(MCDSURFACE *pMcdSurface, MCDRC *pRc,
                                    LONG x, LONG y, ULONG width, ULONG height, ULONG type);
typedef ULONG    (*MCDRVPIXELMAP)(MCDSURFACE *pMcdSurface, MCDRC *pRc,
                                  ULONG mapType, ULONG mapSize, VOID *pMap);

typedef struct _MCDDRIVER {
    ULONG                           ulSize;
    MCDRVDESCRIBEPIXELFORMATFUNC    pMCDrvDescribePixelFormat;
    MCDRVDESCRIBELAYERPLANEFUNC     pMCDrvDescribeLayerPlane;
    MCDRVSETLAYERPALETTEFUNC        pMCDrvSetLayerPalette;
    MCDRVINFOFUNC                   pMCDrvInfo;
    MCDRVCREATECONTEXTFUNC          pMCDrvCreateContext;
    MCDRVDELETECONTEXTFUNC          pMCDrvDeleteContext;
    MCDRVBINDCONTEXTFUNC            pMCDrvBindContext;
    MCDRVCREATETEXTUREFUNC          pMCDrvCreateTexture;
    MCDRVDELETETEXTUREFUNC          pMCDrvDeleteTexture;
    MCDRVUPDATESUBTEXTUREFUNC       pMCDrvUpdateSubTexture;
    MCDRVUPDATETEXTUREPALETTEFUNC   pMCDrvUpdateTexturePalette;
    MCDRVUPDATETEXTUREPRIORITYFUNC  pMCDrvUpdateTexturePriority;
    MCDRVUPDATETEXTURESTATEFUNC     pMCDrvUpdateTextureState;
    MCDRVTEXTURESTATUSFUNC          pMCDrvTextureStatus;
    MCDRVCREATEMEMFUNC              pMCDrvCreateMem;
    MCDRVDELETEMEMFUNC              pMCDrvDeleteMem;
    MCDRVDRAWFUNC                   pMCDrvDraw;
    MCDRVCLEARFUNC                  pMCDrvClear;
    MCDRVSWAPFUNC                   pMCDrvSwap;
    MCDRVSTATEFUNC                  pMCDrvState;
    MCDRVVIEWPORTFUNC               pMCDrvViewport;
    MCDRVGETHDEVFUNC                pMCDrvGetHdev;
    MCDRVSPANFUNC                   pMCDrvSpan;
    MCDRVTRACKWINDOWFUNC            pMCDrvTrackWindow;
    MCDRVALLOCBUFFERSFUNC           pMCDrvAllocBuffers;
    MCDRVGETBUFFERSFUNC             pMCDrvGetBuffers;
    MCDRVSYNCFUNC                   pMCDrvSync;
    MCDRVDRAWPIXELS                 pMCDrvDrawPixels;
    MCDRVREADPIXELS                 pMCDrvReadPixels;
    MCDRVCOPYPIXELS                 pMCDrvCopyPixels;
    MCDRVPIXELMAP                   pMCDrvPixelMap;
} MCDDRIVER;


//
// Clip codes:
//

#define MCD_CLIP_LEFT           0x00000001
#define MCD_CLIP_RIGHT          0x00000002
#define MCD_CLIP_BOTTOM         0x00000004
#define MCD_CLIP_TOP            0x00000008
#define MCD_CLIP_NEAR           0x00000010
#define MCD_CLIP_FAR            0x00000020
#define MCD_CLIP_MASK           0x0000003f

//
// Vertex flags:
//

#define MCDVERTEX_EDGEFLAG      0x00000001
#define MCDVERTEX_FRONTFACE     0
#define MCDVERTEX_BACKFACE      1

//
// Note: vertex colors are scaled to the color depths reported in the
// pixel format.
//

typedef struct _MCDVERTEX {

    ULONG flags;                // vertex flags
    MCDCOLOR *pColor;           // pointer to active vertex color
    ULONG clipCode;             // clip code
    MCDFLOAT fog;               // fog value (0..1)
    MCDCOORD clipCoord;         // clip-space coordinate
    MCDCOORD windowCoord;       // window coordinate
    MCDCOORD texCoord;          // texture coordinate
    MCDCOORD normal;            // vertex normal
    MCDCOLOR colors[2];         // front and back vertex colors
    MCDCOORD eyeCoord;          // eye coordinate
} MCDVERTEX;

typedef struct _MCDCOMMAND MCDCOMMAND;

#define MCDCOMMAND_RESET_STIPPLE        0x00004000
#define MCDCOMMAND_RENDER_PRIMITIVE     0x00008000
#define MCDCOMMAND_SAME_COLOR           0x00040000

typedef struct _MCDCOMMAND {
    ULONG flags;                // flags for this command
    MCDVERTEX *pEndVertex;
    ULONG reserved2;
    ULONG reserved3;
    ULONG reserved4;
    ULONG reserved5;
    MCDVERTEX *pStartVertex;
    ULONG reserved7;
    ULONG reserved8;
    ULONG reserved9;
    ULONG reserved10;
    ULONG reserved11;
    ULONG reserved12;
    ULONG reserved13;
    ULONG reserved14;
    ULONG command;              // primitive type or command (GL_TRIANGLES, etc.)
    ULONG clipCodes;
    ULONG reserved17;
    ULONG reserved18;
    MCDCOMMAND *pNextCmd;
    ULONG numIndices;
    UCHAR *pIndices;
    ULONG reserved22;
    ULONG textureKey;
} MCDCOMMAND;


// Top-level (global) driver function established at DLL initialization time
// through MCDEngInit(). All other driver functions are obtained through the 
// MCDrvGetEntryPoints funtion:

typedef BOOL (*MCDRVGETENTRYPOINTSFUNC)(MCDSURFACE *pMCDSurface, MCDDRIVER *pMCDDriver);

// MCD Server engine functions:

#define MCDENGINITFUNCNAME      "MCDEngInit"
#define MCDENGESCFILTERNAME     "MCDEngEscFilter"
#define MCDENGSETMEMSTATUSNAME  "MCDEngSetMemStatus"

typedef BOOL (WINAPI *MCDENGINITFUNC)(SURFOBJ *pso, 
                                      MCDRVGETENTRYPOINTSFUNC);

typedef BOOL (WINAPI *MCDENGESCFILTERFUNC)(SURFOBJ *pso, ULONG iEsc,
                                           ULONG cjIn, VOID *pvIn,
                                           ULONG cjOut, VOID *pvOut, 
                                           ULONG *pRetVal);

typedef BOOL (WINAPI *MCDENGSETMEMSTATUSFUNC)(MCDMEM *pMCDMem, ULONG status);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\mcdpoint.c ===
/******************************Module*Header*******************************\
* Module Name: mcdpoint.c
*
* Contains all of the point-rendering routines for the Cirrus Logic 546X MCD driver.
*
* (based on mcdpoint.c from NT4.0 DDK)
*
* Copyright (c) 1996 Microsoft Corporation
* Copyright (c) 1997 Cirrus Logic, Inc.
\**************************************************************************/

#include "precomp.h"
#include "mcdhw.h"
#include "mcdutil.h"
#include "mcdmath.h"

#define TRUNCCOORD(value, intValue)\
    intValue = __MCD_VERTEX_FIXED_TO_INT(__MCD_VERTEX_FLOAT_TO_FIXED(value))




VOID FASTCALL __MCDRenderPoint(DEVRC *pRc, MCDVERTEX *a)
{
    ULONG clipNum;
    RECTL *pClip;

	LONG lCoord;

    PDEV *ppdev = pRc->ppdev;
    unsigned int *pdwNext = ppdev->LL_State.pDL->pdwNext;

	// output queue stuff...
    DWORD *pSrc;
    DWORD *pDest = ppdev->LL_State.pRegs + HOST_3D_DATA_PORT;
    DWORD *pdwStart = ppdev->LL_State.pDL->pdwStartOutPtr;

    DWORD dwFlags=0;		// MCD_TEMP - dwflags initialized to 0
    DWORD *dwOrig;          /* Temp display list  pointer    */
    DWORD dwOpcode;         // Built opcode
	LONG ax, ay;
        
    if ((clipNum = pRc->pEnumClip->c) > 1) {
        pClip = &pRc->pEnumClip->arcl[0];
        SET_HW_CLIP_REGS(pRc,pdwNext)
        pClip++;
    }

	// window coords are float values, and need to have 
	// viewportadjust (MCDVIEWPORT) values subtracted to get to real screen space

	// color values are 0->1 floats and must be multiplied by scale values (MCDRCINFO)
	// to get to nbits range (scale = 0xff for 8 bit, 0x7 for 3 bit, etc.)

	// Z values are 0->1 floats(?) and must be multiplied by zscale(?) values (MCDRCINFO)


#if 0 // FUTURE - need to enable 3d control regs setup for texture
        // Turn on alpha blending if it is required and is not already on
        // Also turn it off if it is on and is not required
        //
        // Note: LL_ALPHA bit should be 1
        //
        if( (dwFlags ^ (LL_State.dwControl0>>15)) & 1 )
        {
            // Alpha enable is bit 15 in control0, so toggle it
            //
            LL_State.dwControl0 ^= 0x00008000;      // bit 15

            *pdwNext++ = write_register( CONTROL0_3D, 1 );
            *pdwNext++ = LL_State.dwControl0;
        }


    #if 0 // MCD never uses alpha_mode 0
        // Set up the da_main, da_ortho registers necessary for
        // constant alpha blending
        // ========
        if( (dwFlags & LL_ALPHA) && (LL_State.Control0.Alpha_Mode == 0) )
        {
            // Check if a new value needs to be set
            //
            if( LL_State.rDA_MAIN != LL_State.AlphaConstSource ||
                LL_State.rDA_ORTHO != LL_State.AlphaConstDest )
            {
                *(pdwNext+0) = write_register( DA_MAIN_3D, 2 );
                *(pdwNext+1) = LL_State.rDA_MAIN = LL_State.AlphaConstSource;
                *(pdwNext+2) = LL_State.rDA_ORTHO = LL_State.AlphaConstDest;

                pdwNext += 3;
            }
        }
    #endif


    // NOTE!!! - caller (MCDPrimDrawPoints) will put this in outlist, which will be sent at end of this proc
 // *pdwNext++ = write_register( Y_COUNT_3D, 1 );
 // *pdwNext++ = 0;

#endif 0 // FUTURE - (end 3d control regs setup for texture)

    // Store the first address for the opcode
    //
    dwOrig = pdwNext;

    // Start with a plain point instruction (no modifiers)
    // and assume same color.  Count=2 for x,y
    //
    dwOpcode = POINT | SAME_COLOR | 2;
    
    // Set flags as requested from the dwFlags field of a batch.
    // These bits have 1-1 correspondence to their instruction 
    // counterparts.
    //
    // Flags : LL_DITHER     - Use dither pattern
    //         LL_PATTERN    - Draw pattern
    //         LL_STIPPLE    - Use stipple mask
    //         LL_LIGHTING   - Do lighting
    //         LL_Z_BUFFER   - Use Z buffer
    //         FETCH_COLOR   - Appended for alpha blending
    //         LL_GOURAUD    - Use Gouraud shading
    //         LL_TEXTURE    - Texture mapping
    //

    /*
    dwOpcode |= dwFlags & 
    ( LL_DITHER   | LL_PATTERN  | LL_STIPPLE 
    | LL_LIGHTING | LL_Z_BUFFER | FETCH_COLOR 
    | LL_GOURAUD  | LL_TEXTURE );
    */
    // no point stippling for OpenGL
    dwOpcode |= pRc->privateEnables & __MCDENABLE_Z ;
    dwOpcode |= pRc->privateEnables & __MCDENABLE_DITHER ;

  //SNAPCOORD(a->windowCoord.x, ax);
    TRUNCCOORD(a->windowCoord.x, ax);
    lCoord = ax + pRc->xOffset;		// adds window offset, removes a000 offset
    *(pdwNext+1) = (DWORD) (lCoord << 16 );

  //SNAPCOORD(a->windowCoord.y, ay);
    TRUNCCOORD(a->windowCoord.y, ay);
	lCoord = ay + pRc->yOffset;		// adds window offset, removes a000 offset
    *(pdwNext+2) = (DWORD) ((lCoord << 16) + 1);

    pdwNext += 3;

    if( !(dwFlags & LL_SAME_COLOR) )
    {
        register DWORD color;

        // Clear same_color flag
        //
        dwOpcode ^= LL_SAME_COLOR;
    
        *pdwNext = FTOL(a->colors[0].r * pRc->rScale);

        *(pdwNext+1) = FTOL(a->colors[0].g * pRc->gScale);
        *(pdwNext+2) = FTOL(a->colors[0].b * pRc->bScale);

        dwOpcode += 3;
        pdwNext += 3;
    }

    if( pRc->privateEnables & __MCDENABLE_Z)
    {

        *pdwNext++ = FTOL(a->windowCoord.z * pRc->zScale);
        dwOpcode += 1;
    }


#if 0
    if( dwFlags & LL_TEXTURE )
    {
    ...
    ...
    ...
    }


#endif
    if (pRc->privateEnables & (__MCDENABLE_BLEND|__MCDENABLE_FOG)) 
    {
        float v1alp;

        if (pRc->privateEnables & __MCDENABLE_BLEND) 
        {
            // recall that if both blending and fog active, all prims punted back to software
            v1alp = a->colors[0].a * pRc->aScale;
        }
        else
        {
            v1alp = a->fog * (float)16777215.0; // convert from 0->1.0 val to 0->ff.ffff val
        }

        *pdwNext++ = FTOL(v1alp) & 0x00ffff00;// bits 31->24 and 7->0 reserved
        
        dwOpcode += ( FETCH_COLOR | ALPHA + 1 );

	}

    // Store the final opcode
    //
    *dwOrig = dwOpcode;

    while (--clipNum) {
        int len = (dwOpcode & 0x3F) + 1;    // num words for line primitive
        SET_HW_CLIP_REGS(pRc,pdwNext)
        pClip++;

        // dump same pt regs again to draw while clipping against occlusion rectangle
        pSrc = dwOrig;
        
        while( len-- ) *pdwNext++ = *pSrc++;                                      
    }

		// output queued data here....
#if 0 // FUTURE - enable queueing algorithm - just outputting everything for now
    OUTPUT_COPROCMODE_QUEUE
#else // 0
    {
	    pSrc  = pdwStart;                                                             
        while (pSrc != pdwNext)                                                   
        {                                                                         
            /* Get the amount of data for this opcode */                          
            int len = (*pSrc & 0x3F) + 1;                                             

            USB_TIMEOUT_FIX(ppdev)
                                                                                  
            while( len-- ) *pDest = *pSrc++;                                      
                                                                                  
        }                                                                         
                                                                                  
    }                       
    
#endif // 0

    ppdev->LL_State.pDL->pdwNext = ppdev->LL_State.pDL->pdwStartOutPtr = pdwStart;
}

VOID FASTCALL __MCDRenderGenPoint(DEVRC *pRc, MCDVERTEX *pv)
{
    // MGA and S3 MCD's have no code in this proc
    MCDBG_PRINT("__MCDRenderGenPoint - EMPTY ROUTINE");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\mcdmath.h ===
/******************************Module*Header*******************************\
* Module Name: mcdmath.h
*
* Various useful defines and macros to do efficient floating-point
* processing for MCD drivers.
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#ifndef _MCDMATH_H
#define _MCDMATH_H

#define CASTINT(a)              (*((LONG *)&(a)))

#define ZERO (MCDFLOAT)0.0

#define __MCDZERO       ZERO
#define __MCDONE        (MCDFLOAT)1.0
#define __MCDHALF       (MCDFLOAT)0.5
#define __MCDFIXSCALE   (MCDFLOAT)65536.0

#define __MCD_MAX_WINDOW_SIZE_LOG2       14
#define __MCD_VERTEX_FIX_POINT   (__MCD_MAX_WINDOW_SIZE_LOG2+1)
#define __MCD_VERTEX_X_FIX      (1 << __MCD_VERTEX_FIX_POINT)
#define __MCD_VERTEX_Y_FIX      __MCD_VERTEX_X_FIX

#define __MCD_FLOAT_MANTISSA_BITS       23
#define __MCD_FLOAT_MANTISSA_SHIFT      0
#define __MCD_FLOAT_EXPONENT_BIAS       127
#define __MCD_FLOAT_EXPONENT_BITS       8
#define __MCD_FLOAT_EXPONENT_SHIFT      23
#define __MCD_FLOAT_SIGN_SHIFT          31

// If the MSB of a FP number is known then float-to-int conversion
// becomes a simple shift and mask
// The value must be positive
#define __MCD_FIXED_FLOAT_TO_INT(flt, shift) \
    ((*(LONG *)&(flt) >> (shift)) & \
     ((1 << (__MCD_FLOAT_MANTISSA_BITS-(shift)))-1) | \
     (1 << (__MCD_FLOAT_MANTISSA_BITS-(shift))))

// Same as above except without the MSB, which can be useful
// for getting unbiased numbers when the bias is only the MSB
// The value must be positive
#define __MCD_FIXED_FLOAT_TO_INT_NO_MSB(flt, shift) \
    ((*(LONG *)&(flt) >> (shift)) & \
     ((1 << (__MCD_FLOAT_MANTISSA_BITS-(shift)))-1))

// Produces the fixed-point form
// The value must be positive
#define __MCD_FIXED_FLOAT_TO_FIXED(flt) \
    ((*(LONG *)&(flt)) & \
     ((1 << (__MCD_FLOAT_MANTISSA_BITS))-1) | \
     (1 << (__MCD_FLOAT_MANTISSA_BITS)))

#define __MCD_FIXED_FLOAT_TO_FIXED_NO_MSB(flt) \
    ((*(LONG *)&(flt)) & \
     ((1 << (__MCD_FLOAT_MANTISSA_BITS))-1))

// The fixed-point fraction as an integer
// The value must be positive
#define __MCD_FIXED_FLOAT_FRACTION(flt, shift) \
    (*(LONG *)&(flt) & ((1 << (shift))-1))

// Converts the fixed-point form to an IEEE float, but still typed
// as an int because a cast to float would cause the compiler to do
// an int-float conversion
// The value must be positive
#define __MCD_FIXED_TO_FIXED_FLOAT(fxed, shift) \
    ((fxed) & ((1 << (__MCD_FLOAT_MANTISSA_BITS))-1) | \
     ((__MCD_FLOAT_EXPONENT_BIAS+(shift)) << __MCD_FLOAT_EXPONENT_SHIFT))
      

#ifdef _X86_
#define __MCD_FLOAT_GTZ(flt)             (*(LONG *)&(flt) > 0)
#define __MCD_FLOAT_LTZ(flt)             (*(LONG *)&(flt) < 0)
#define __MCD_FLOAT_EQZ(flt)             (*(LONG *)&(flt) == 0)
#define __MCD_FLOAT_LEZ(flt)             (*(LONG *)&(flt) <= 0)
#define __MCD_FLOAT_NEQZ(flt)            (*(LONG *)&(flt) != 0)
#define __MCD_FLOAT_EQUAL(f1, f2)        (*(LONG *)&(f1) == *(LONG *)&(f2))
#define __MCD_FLOAT_NEQUAL(f1, f2)       (*(LONG *)&(f1) != *(LONG *)&(f2))
#else
#define __MCD_FLOAT_GTZ(flt)             ((flt) > __MCDZERO)
#define __MCD_FLOAT_LTZ(flt)             ((flt) < __MCDZERO)
#define __MCD_FLOAT_EQZ(flt)             ((flt) == __MCDZERO)
#define __MCD_FLOAT_LEZ(flt)             ((flt) <= __MCDZERO)
#define __MCD_FLOAT_NEQZ(flt)            ((flt) != __MCDZERO)
#define __MCD_FLOAT_EQUAL(f1, f2)        ((f1) == (f2))
#define __MCD_FLOAT_NEQUAL(f1, f2)       ((f1) != (f2))
#endif // _X86_


// Macro to start an FP divide in the FPU, used to overlap a
// divide with integer operations
// Can't just use C because it stores the result immediately
#ifdef _X86_

#define __MCD_FLOAT_SIMPLE_BEGIN_DIVIDE(num, den, result) \
    __asm fld num \
    __asm fdiv den
#define __MCD_FLOAT_SIMPLE_END_DIVIDE(result) \
    __asm fstp DWORD PTR result

//USED
__inline void __MCD_FLOAT_BEGIN_DIVIDE(MCDFLOAT num, MCDFLOAT den,
				      MCDFLOAT *result)
{
    __asm fld num
    __asm fdiv den
}
__inline void __MCD_FLOAT_END_DIVIDE(MCDFLOAT *result)
{
    __asm mov eax, result
    __asm fstp DWORD PTR [eax]   
}
#else
#define __MCD_FLOAT_SIMPLE_BEGIN_DIVIDE(num, den, result) \
    ((result) = (num)/(den))
#define __MCD_FLOAT_SIMPLE_END_DIVIDE(result)
#define __MCD_FLOAT_BEGIN_DIVIDE(num, den, result) (*(result) = (num)/(den))
#define __MCD_FLOAT_END_DIVIDE(result)
#endif // _X86_





#ifdef _X86_

#pragma warning(disable:4035) // Function doesn't return a value

// Convert float to int 15.16
__inline LONG __fastcall FLT_TO_FIX(
    float a)
{
    LARGE_INTEGER li;

    __asm {
	mov     eax, a
	test    eax, 07fffffffh
	jz      RetZero
	add     eax, 08000000h
	mov     a, eax
	fld     a
	fistp   li
	mov     eax, DWORD PTR li
	jmp     Done
    RetZero:
	xor     eax, eax
    Done:
    }
}

// Convert float to int 15.16, can cause overflow exceptions
__inline LONG __fastcall UNSAFE_FLT_TO_FIX(
    float a)
{
    LONG l;

    __asm {
	mov     eax, a
	test    eax, 07fffffffh
	jz      RetZero
	add     eax, 08000000h
	mov     a, eax
	fld     a
	fistp   l
	mov     eax, l
	jmp     Done
    RetZero:
	xor     eax, eax
    Done:
    }
}

// Convert float to int 0.31
__inline LONG __fastcall FLT_FRACTION(
    float a)
{
    LARGE_INTEGER li;

    __asm {
	mov     eax, a
	test    eax, 07fffffffh
	jz      RetZero
	add     eax, 0f800000h
	mov     a, eax
	fld     a
	fistp   li
	mov     eax, DWORD PTR li
	jmp     Done
    RetZero:
	xor     eax, eax
    Done:
    }
}

// Convert float to int 0.31, can cause overflow exceptions
__inline LONG __fastcall UNSAFE_FLT_FRACTION(
    float a)
{
    LONG l;

    __asm {
	mov     eax, a
	test    eax, 07fffffffh
	jz      RetZero
	add     eax, 0f800000h
	mov     a, eax
	fld     a
	fistp   l
	mov     eax, l
	jmp     Done
    RetZero:
	xor     eax, eax
    Done:
    }
}

#pragma warning(default:4035) // Function doesn't return a value

// Convert float*scale to int
__inline LONG __fastcall FLT_TO_FIX_SCALE(
    float a,
    float b)
{
    LARGE_INTEGER li;

    __asm {
	fld     a
	fmul    b
	fistp   li
    }

    return li.LowPart;
}

#define FLT_TO_UCHAR_SCALE(value_in, scale) \
    ((UCHAR)FLT_TO_FIX_SCALE(value_in, scale))

__inline LONG __fastcall FTOL(
    float a)
{
    LARGE_INTEGER li;

    _asm {
	fld     a
	fistp   li
    }

    return li.LowPart;
}

// Can cause overflow exceptions
__inline LONG __fastcall UNSAFE_FTOL(
    float a)
{
    LONG l;

    _asm {
	fld     a
	fistp   l
    }

    return l;
}

// Requires R-G-B to be FP stack 2-1-0
// Requires gc in edx
#define FLT_STACK_RGB_TO_GC_FIXED(rOffset, gOffset, bOffset)                  \
    __asm fld __glVal65536                                                    \
    __asm fmul st(3), st(0)                                                   \
    __asm fmul st(2), st(0)                                                   \
    __asm fmulp st(1), st(0)                                                  \
    __asm fistp DWORD PTR [edx+bOffset]                                       \
    __asm fistp DWORD PTR [edx+gOffset]                                       \
    __asm fistp DWORD PTR [edx+rOffset]                                       

#define CHOP_ROUND_ON() \
    WORD cwSave;                 \
    WORD cwTemp;                 \
				 \
    __asm {                      \
	_asm wait                \
	_asm fstcw   cwSave      \
	_asm wait                \
	_asm mov     ax, cwSave  \
	_asm or      ah,0xc      \
	_asm and     ah,0xfc     \
	_asm mov     cwTemp,ax   \
	_asm fldcw   cwTemp      \
    }

#define CHOP_ROUND_OFF()         \
    __asm {                      \
	_asm wait                \
	_asm fldcw   cwSave      \
    }


#else // _X86_

#define FTOL(value) \
    ((GLint)(value))
#define UNSAFE_FTOL(value) \
    FTOL(value)
#define FLT_TO_FIX_SCALE(value_in, scale) \
    ((GLint)((MCDFLOAT)(value_in) * scale))
#define FLT_TO_UCHAR_SCALE(value_in, scale) \
    ((UCHAR)((GLint)((MCDFLOAT)(value_in) * scale)))
#define FLT_TO_FIX(value_in) \
    ((GLint)((MCDFLOAT)(value_in) * __MCDFIXSCALE))
#define UNSAFE_FLT_TO_FIX(value_in) \
    FLT_TO_FIX(value_in)
#define FLT_FRACTION(f) \
    FTOL((f) * __glVal2147483648)
#define UNSAFE_FLT_FRACTION(f) \
    FLT_FRACTION(f)

#define CHOP_ROUND_ON()
#define CHOP_ROUND_OFF()
#define ASSERT_CHOP_ROUND()

#endif  //_X86_














#define __MCD_VERTEX_FRAC_BITS \
    (__MCD_FLOAT_MANTISSA_BITS-__MCD_VERTEX_FIX_POINT)

//USED
#define __MCD_VERTEX_FRAC_HALF \
    (1 << (__MCD_VERTEX_FRAC_BITS-1))
#define __MCD_VERTEX_FRAC_ONE \
    (1 << __MCD_VERTEX_FRAC_BITS)


// Converts a floating-point window coordinate to integer
#define __MCD_VERTEX_FLOAT_TO_INT(windowCoord) \
    __MCD_FIXED_FLOAT_TO_INT(windowCoord, __MCD_VERTEX_FRAC_BITS)

//USED
// To fixed point
#define __MCD_VERTEX_FLOAT_TO_FIXED(windowCoord) \
    __MCD_FIXED_FLOAT_TO_FIXED(windowCoord)
// And back
#define __MCD_VERTEX_FIXED_TO_FLOAT(fxWindowCoord) \
    __MCD_FIXED_TO_FIXED_FLOAT(fxWindowCoord, __MCD_VERTEX_FRAC_BITS)

//USED
// Fixed-point to integer
#define __MCD_VERTEX_FIXED_TO_INT(fxWindowCoord) \
    ((fxWindowCoord) >> __MCD_VERTEX_FRAC_BITS)

// Returns the fraction from a FP window coordinate as an N
// bit integer, where N depends on the FP mantissa size and the
// FIX size
#define __MCD_VERTEX_FLOAT_FRACTION(windowCoord) \
    __MCD_FIXED_FLOAT_FRACTION(windowCoord, __MCD_VERTEX_FRAC_BITS)

// Scale the fraction to 2^31 for step values
#define __MCD_VERTEX_PROMOTE_FRACTION(frac) \
    ((frac) << (31-__MCD_VERTEX_FRAC_BITS))
#define __MCD_VERTEX_PROMOTED_FRACTION(windowCoord) \
    __MCD_VERTEX_PROMOTE_FRACTION(__MCD_VERTEX_FLOAT_FRACTION(windowCoord))

// Compare two window coordinates.  Since window coordinates
// are fixed-point numbers, they can be compared directly as
// integers
#define __MCD_VERTEX_COMPARE(a, op, b) \
    ((*(LONG *)&(a)) op (*(LONG *)&(b)))


#define SNAPCOORD(value, intValue)\
    intValue = __MCD_VERTEX_FIXED_TO_INT(__MCD_VERTEX_FLOAT_TO_FIXED(value)+\
                                         __MCD_VERTEX_FRAC_HALF);

// match the "ALMOST_HALF" value in SGI sample code (triflat.c)
#define __MCD_ALMOST_HALF ((float) ((float)0x7fff/(float)0x10000))

#endif // _MCDMATH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\mcdrend.c ===
/******************************Module*Header*******************************\
* Module Name: mcdrend.c
*
* This file contains routines to do high-level triangle rendering for the
* Cirrus Logic 546X MCD driver, including culling and face computations.  Note that
* in this driver, we don't use vertex color pointer at all since all pointer
* references need to be checked to avoid the possibility of an invalid
* memory reference.  Instead, we copy the color data in the cases where we
* need to during two-sided operation.  This is not the common case, and even
* in the case where the color data needs to be copied to colors[0] (and back),
* the copy only needs to be done for (on average) half the faces.
*
* Copyright (c) 1996 Microsoft Corporation
* Copyright (c) 1997 Cirrus Logic, Inc.
\**************************************************************************/

#include "precomp.h"
#include "mcdhw.h"
#include "mcdutil.h"
#include "mcdmath.h"

#if _X86_

#define GET_HALF_AREA(pRc, a, b, c)\
\
__asm{ mov     ecx, c                                                                		};\
__asm{ mov     eax, a                                                                		};\
__asm{ mov     ebx, b                                                                		};\
__asm{ mov     edx, pRc                                                              		};\
__asm{ fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.x)][ecx]                                	};\
__asm{ fsub    DWORD PTR [OFFSET(MCDVERTEX.windowCoord.x)][eax]  /* dxAC                     */	};\
__asm{ fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.y)][ecx]                                	};\
__asm{ fsub    DWORD PTR [OFFSET(MCDVERTEX.windowCoord.y)][ebx]  /* dyBC dxAC                */	};\
__asm{ fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.x)][ecx]  /* dxBC dyBC dxAC           */	};\
__asm{ fsub    DWORD PTR [OFFSET(MCDVERTEX.windowCoord.x)][ebx]                                	};\
__asm{ fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.y)][ecx]                                	};\
__asm{ fsub    DWORD PTR [OFFSET(MCDVERTEX.windowCoord.y)][eax]  /* dyAC dxBC dyBC dxAC      */	};\
__asm{ fxch    ST(2)                              	       	 /* dyBC dxBC dyAC dxAC      */	};\
__asm{ fst     DWORD PTR [OFFSET(DEVRC.dyBC)][edx]                                             	};\
__asm{ fmul    ST, ST(3)                               	       	 /* dxACdyBC dxBC dyAC dxAC  */	};\
__asm{ fxch    ST(2)                              	       	 /* dyAC dxBC dxACdyBC dxAC  */	};\
__asm{ fst     DWORD PTR [OFFSET(DEVRC.dyAC)][edx]                                             	};\
__asm{ fmul    ST, ST(1)                               	       	 /* dxBCdyAC dxBC dxACdyBC dxAC */ };\
__asm{ fxch    ST(1)                              	       	 /* dxBC dxBCdyAC dxACdyBC dxAC */ };\
__asm{ fstp    DWORD PTR [OFFSET(DEVRC.dxBC)][edx]               /* dxBCdyAC dxACdyBC dxAC   */ };\
__asm{ fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.x)][ebx]                                 };\
__asm{ fsub    DWORD PTR [OFFSET(MCDVERTEX.windowCoord.x)][eax]  /* dxAB dxBCdyAC dxACdyBC dxAC  */ };\
__asm{ fxch    ST(1)                                             /* dxBCdyAC dxAB dxACdyBC  dxAC */ };\
__asm{ fsubp   ST(2), ST                                         /* dxAB area dxAC */           };\
__asm{ fld     DWORD PTR [OFFSET(MCDVERTEX.windowCoord.y)][ebx]                                	};\
__asm{ fsub    DWORD PTR [OFFSET(MCDVERTEX.windowCoord.y)][eax]  /* dyAB dxAB area  dxAC */     };\
__asm{ fxch    ST(3)                                             /* dxAC dxAB area  dyAB */     };\
__asm{ fstp    DWORD PTR [OFFSET(DEVRC.dxAC)][edx]               /* dxAB area  dyAB */          };\
__asm{ fstp    DWORD PTR [OFFSET(DEVRC.dxAB)][edx]               /* area  dyAB */               };\
__asm{ fstp    DWORD PTR [OFFSET(DEVRC.halfArea)][edx]           /* dyAB */                     };\
__asm{ fstp    DWORD PTR [OFFSET(DEVRC.dyAB)][edx]               /* (empty) */                  };

#else

#define GET_HALF_AREA(pRc, a, b, c)\
    /* Compute signed half-area of the triangle */			    \
    (pRc)->dxAC = (c)->windowCoord.x - (a)->windowCoord.x;		    \
    (pRc)->dxBC = (c)->windowCoord.x - (b)->windowCoord.x;		    \
    (pRc)->dyAC = (c)->windowCoord.y - (a)->windowCoord.y;		    \
    (pRc)->dyBC = (c)->windowCoord.y - (b)->windowCoord.y;		    \
    (pRc)->dxAB = (b)->windowCoord.x - (a)->windowCoord.x;		    \
    (pRc)->dyAB = (b)->windowCoord.y - (a)->windowCoord.y;		    \
                                                                            \
    (pRc)->halfArea = (pRc)->dxAC * (pRc)->dyBC - (pRc)->dxBC * (pRc)->dyAC;

#endif


#define SORT_AND_CULL_FACE(a, b, c, face, ccw)\
{                                                                           \
    LONG reversed;                                                          \
    MCDVERTEX *temp;                                                        \
                                                                            \
                                                                            \
    reversed = 0;                                                           \
    if (__MCD_VERTEX_COMPARE((a)->windowCoord.y, <, (b)->windowCoord.y)) {      \
        if (__MCD_VERTEX_COMPARE((b)->windowCoord.y, <, (c)->windowCoord.y)) {  \
            /* Already sorted */                                            \
        } else {                                                            \
            if (__MCD_VERTEX_COMPARE((a)->windowCoord.y, <, (c)->windowCoord.y)) {\
                temp=(b); (b)=(c); (c)=temp;                                \
		reversed = 1;                                               \
            } else {                                                        \
                temp=(a); (a)=(c); (c)=(b); (b)=temp;                       \
            }                                                               \
        }                                                                   \
    } else {                                                                \
        if (__MCD_VERTEX_COMPARE((b)->windowCoord.y, <, (c)->windowCoord.y)) {  \
            if (__MCD_VERTEX_COMPARE((a)->windowCoord.y, <, (c)->windowCoord.y)) {\
                temp=(a); (a)=(b); (b)=temp;                                \
		reversed = 1;                                               \
            } else {                                                        \
                temp=(a); (a)=(b); (b)=(c); (c)=temp;                       \
            }                                                               \
        } else {                                                            \
            temp=(a); (a)=(c); (c)=temp;                                    \
	    reversed = 1;                                                   \
        }                                                                   \
    }                                                                       \
                                                                            \
    GET_HALF_AREA(pRc, (a), (b), (c));                                      \
                                                                            \
    (ccw) = !__MCD_FLOAT_LTZ(pRc->halfArea);                                \
                                                                            \
    /*                                                                      \
    ** Figure out if face is culled or not.  The face check needs to be     \
    ** based on the vertex winding before sorting.  This code uses the      \
    ** reversed flag to invert the sense of ccw - an xor accomplishes       \
    ** this conversion without an if test.                                  \
    **                                                                      \
    ** 		ccw	reversed		xor                         \
    ** 		---	--------		---                         \
    ** 		0	0			0 (remain !ccw)             \
    ** 		1	0			1 (remain ccw)              \
    ** 		0	1			1 (become ccw)              \
    ** 		1	1			0 (become cw)               \
    */                                                                      \
    (face) = pRc->polygonFace[(ccw) ^ reversed];                            \
    if ((face) == pRc->cullFlag) {                                          \
	/* Culled */                                                        \
	return;                                                             \
    }                                                                       \
}


////////////////////////////////////////////////////////////////////////
//
// VOID FASTCALL __MCDCalcZSlope(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b, MCDVERTEX *c)
//
// Local helper routine to calculate z slopes for z-offseting primitives.
//
////////////////////////////////////////////////////////////////////////

VOID FASTCALL __MCDCalcZSlope(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b, MCDVERTEX *c)
{
    MCDFLOAT oneOverArea, t1, t2, t3, t4;
    MCDFLOAT dzAC, dzBC;

    if (CASTINT(pRc->halfArea) == 0) {
        pRc->dzdx = __MCDZERO;
        pRc->dzdy = __MCDZERO;
        return;
    }

    oneOverArea =  __MCDONE / pRc->halfArea;

    t1 = pRc->dyAC * oneOverArea;
    t2 = pRc->dyBC * oneOverArea;
    t3 = pRc->dxAC * oneOverArea;
    t4 = pRc->dxBC * oneOverArea;

    dzAC = c->windowCoord.z - a->windowCoord.z;
    dzBC = c->windowCoord.z - b->windowCoord.z;
    pRc->dzdx = (dzAC * t2 - dzBC * t1);
    pRc->dzdy = (dzBC * t3 - dzAC * t4);
}


////////////////////////////////////////////////////////////////////////
//
// VOID FASTCALL __MCDGetZOffsetDelta(DEVRC *pRc)
//
// Returns required z offset value for current primitive.  Assumes that
// z deltas are already in RC.
//
////////////////////////////////////////////////////////////////////////


MCDFLOAT FASTCALL __MCDGetZOffsetDelta(DEVRC *pRc)
{
#define FABS(f)  ((MCDFLOAT)fabs((double) (f)))
    MCDFLOAT maxdZ;

    // Find maximum x or y slope:

    if(FABS(pRc->dzdx) > FABS(pRc->dzdy))
        maxdZ = FABS(pRc->dzdx);
    else
        maxdZ = FABS(pRc->dzdy);

    return (pRc->MCDState.zOffsetFactor * maxdZ);
}

////////////////////////////////////////////////////////////////////////
//
// VOID FASTCALL __MCDRenderSmoothTriangle(DEVRC *pRc, MCDVERTEX *a,
//                                         MCDVERTEX *b, MCDVERTEX *c)
//
//
// This is the top-level smooth triangle renderer.
//
////////////////////////////////////////////////////////////////////////

VOID FASTCALL __MCDRenderSmoothTriangle(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b,
                                        MCDVERTEX *c)
{
    LONG ccw, face;
    RECTL *pClip;
    ULONG clipNum;

//  MCDBG_PRINT("__MCDRenderSmoothTriangle");

    SORT_AND_CULL_FACE(a, b, c, face, ccw);
    if (CASTINT(pRc->halfArea) == 0)
        return;

    if ((clipNum = pRc->pEnumClip->c) > 1) {
        pClip = &pRc->pEnumClip->arcl[0];
	(*pRc->HWSetupClipRect)(pRc, pClip++);
    }

    // Pick correct face color and render the triangle:

    if ((pRc->privateEnables & __MCDENABLE_TWOSIDED) &&
        (face == __MCD_BACKFACE))
    {
        SWAP_COLOR(a);
        SWAP_COLOR(b);
        SWAP_COLOR(c);

	(*pRc->drawTri)(pRc, a, b, c, 1);
        while (--clipNum) {
            (*pRc->HWSetupClipRect)(pRc, pClip++);
            (*pRc->drawTri)(pRc, a, b, c, 1);
        }

        SWAP_COLOR(a);
        SWAP_COLOR(b);
        SWAP_COLOR(c);
    }
    else
    {
	(*pRc->drawTri)(pRc, a, b, c, 1);
        while (--clipNum) {
            (*pRc->HWSetupClipRect)(pRc, pClip++);
            (*pRc->drawTri)(pRc, a, b, c, 1);
        }
    }

}


////////////////////////////////////////////////////////////////////////
//
// VOID FASTCALL __MCDRenderGenTriangle(DEVRC *pRc, MCDVERTEX *a,
//                                      MCDVERTEX *b, MCDVERTEX *c)
//
//
// This is the generic triangle-rendering routine.  This is used if either
// of the polygon faces are not GL_FILL.
//
////////////////////////////////////////////////////////////////////////

//!! Fix clipping logic, add startXXX logic

VOID FASTCALL __MCDRenderGenTriangle(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b,
                                     MCDVERTEX *c)
{
    LONG ccw, face;
    MCDVERTEX *oa, *ob, *oc;
    RECTL *pClip;
    ULONG clipNum;
    MCDFLOAT zOffset;
    MCDCOLOR tempA, tempB, tempC;
    ULONG polygonMode;
    BOOL backFace;
    MCDVERTEX *pv;

    MCDBG_PRINT("__MCDRenderGenTriangle");

    /*
    ** Save old vertex pointers in case we end up not doing a fill.
    */

    oa = a; ob = b; oc = c;

    SORT_AND_CULL_FACE(a, b, c, face, ccw);

    if ((clipNum = pRc->pEnumClip->c) > 1) {
        pClip = &pRc->pEnumClip->arcl[0];
	(*pRc->HWSetupClipRect)(pRc, pClip++);
    }

    polygonMode = pRc->polygonMode[face];
    backFace = (pRc->privateEnables & __MCDENABLE_TWOSIDED) &&
               (face == __MCD_BACKFACE);

    // Pick correct face color and render the triangle:

    if (pRc->privateEnables & __MCDENABLE_SMOOTH) {

	if (backFace) {
            SWAP_COLOR(a);
            SWAP_COLOR(b);
            SWAP_COLOR(c);
	}

    } else { // Flat shading

        pv = pRc->pvProvoking;

        if (polygonMode == GL_FILL) {
            if (backFace) {
                SWAP_COLOR(pv);
            }
        } else {

            SAVE_COLOR(tempA, a);
            SAVE_COLOR(tempB, b);
            SAVE_COLOR(tempC, c);

            if (backFace) {
                SWAP_COLOR(pv);
            }

            a->colors[0] = pv->colors[0];
            b->colors[0] = pv->colors[0];
            c->colors[0] = pv->colors[0];
        }
    }

    // Render triangle using the current polygon mode for the face:

    switch (pRc->polygonMode[face]) {
        case GL_FILL:
            if (CASTINT(pRc->halfArea) != 0) {
                (*pRc->drawTri)(pRc, a, b, c, 1);
                while (--clipNum) {
                    (*pRc->HWSetupClipRect)(pRc, pClip++);
                    (*pRc->drawTri)(pRc, a, b, c, 1);
                }
            }
	    break;
        case GL_POINT:

            if (pRc->MCDState.enables & MCD_POLYGON_OFFSET_POINT_ENABLE) {
                __MCDCalcZSlope(pRc, a, b, c);
                zOffset = __MCDGetZOffsetDelta(pRc) + pRc->MCDState.zOffsetUnits;
                oa->windowCoord.z += zOffset;
                ob->windowCoord.z += zOffset;
                oc->windowCoord.z += zOffset;
            }

            {
            unsigned int *pdwNext = pRc->ppdev->LL_State.pDL->pdwNext;

            // set x/y counts for 1 by 1 point
            *pdwNext++ = write_register( Y_COUNT_3D, 1 );
            *pdwNext++ = 0;
            *pdwNext++ = write_register( WIDTH1_3D, 1 );
            *pdwNext++ = 0x10000;

            // render proc will output from startoutptr, not from pdwNext, 
            // so this will be sent in proc called below
            pRc->ppdev->LL_State.pDL->pdwNext = pdwNext;
            }


            if (oa->flags & MCDVERTEX_EDGEFLAG) {
                (*pRc->drawPoint)(pRc, oa);
            }
            if (ob->flags & MCDVERTEX_EDGEFLAG) {
                (*pRc->drawPoint)(pRc, ob);
            }
            if (oc->flags & MCDVERTEX_EDGEFLAG) {
                (*pRc->drawPoint)(pRc, oc);
            }

            if (pRc->MCDState.enables & MCD_POLYGON_OFFSET_POINT_ENABLE) {
                oa->windowCoord.z -= zOffset;
                ob->windowCoord.z -= zOffset;
                oc->windowCoord.z -= zOffset;
            }

            break;

        case GL_LINE:
            if (pRc->MCDState.enables & MCD_POLYGON_OFFSET_LINE_ENABLE) {
                __MCDCalcZSlope(pRc, a, b, c);
                zOffset = __MCDGetZOffsetDelta(pRc) + pRc->MCDState.zOffsetUnits;
                oa->windowCoord.z += zOffset;
                ob->windowCoord.z += zOffset;
                oc->windowCoord.z += zOffset;
            }

           if ((oa->flags & MCDVERTEX_EDGEFLAG) &&
                (ob->flags & MCDVERTEX_EDGEFLAG) &&
                (oc->flags & MCDVERTEX_EDGEFLAG)) {

                (*pRc->drawLine)(pRc, oa, ob, TRUE);
                (*pRc->drawLine)(pRc, ob, oc, 0);
                (*pRc->drawLine)(pRc, oc, oa, 0);

            } else {

                if (oa->flags & MCDVERTEX_EDGEFLAG)
                    (*pRc->drawLine)(pRc, oa, ob, TRUE);
                if (ob->flags & MCDVERTEX_EDGEFLAG)
                    (*pRc->drawLine)(pRc, ob, oc, TRUE);
                if (oc->flags & MCDVERTEX_EDGEFLAG)
                    (*pRc->drawLine)(pRc, oc, oa, TRUE);
            }

            if (pRc->MCDState.enables & MCD_POLYGON_OFFSET_LINE_ENABLE) {
                oa->windowCoord.z -= zOffset;
                ob->windowCoord.z -= zOffset;
                oc->windowCoord.z -= zOffset;
            }

            break;

        default:
            break;
    }

    // Restore original colors if needed:

    if (pRc->privateEnables & __MCDENABLE_SMOOTH) {

	if (backFace) {

            SWAP_COLOR(a);
            SWAP_COLOR(b);
            SWAP_COLOR(c);
	}
    } else { // Flat shading

        if (polygonMode == GL_FILL) {
            if (backFace) {
                SWAP_COLOR(pv);
            }
        } else {

            if (backFace) {
                SWAP_COLOR(pv);
            }

            RESTORE_COLOR(tempA, a);
            RESTORE_COLOR(tempB, b);
            RESTORE_COLOR(tempC, c);
        }
    }
}


////////////////////////////////////////////////////////////////////////
//
// VOID FASTCALL __MCDRenderFlatTriangle(DEVRC *pRc, MCDVERTEX *a,
//                                       MCDVERTEX *b, MCDVERTEX *c)
//
//
// This is the top-level flat-shaded triangle renderer.
//
////////////////////////////////////////////////////////////////////////

VOID FASTCALL __MCDRenderFlatTriangle(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b,
                                      MCDVERTEX *c)
{
    LONG ccw, face;
    RECTL *pClip;
    ULONG clipNum;

//  MCDBG_PRINT("__MCDRenderFlatTriangle");

    SORT_AND_CULL_FACE(a, b, c, face, ccw);
    if (CASTINT(pRc->halfArea) == 0)
        return;

    if ((clipNum = pRc->pEnumClip->c) > 1) {
        pClip = &pRc->pEnumClip->arcl[0];
	(*pRc->HWSetupClipRect)(pRc, pClip++);
    }

    // Pick correct face color and render the triangle:

    if ((pRc->privateEnables & __MCDENABLE_TWOSIDED) &&
        (face == __MCD_BACKFACE))
    {
	MCDVERTEX *pv = pRc->pvProvoking;

        SWAP_COLOR(pv);

	(*pRc->drawTri)(pRc, a, b, c, 1);
        while (--clipNum) {
            (*pRc->HWSetupClipRect)(pRc, pClip++);
            (*pRc->drawTri)(pRc, a, b, c, 1);
        }

        SWAP_COLOR(pv);
    }
    else
    {
	(*pRc->drawTri)(pRc, a, b, c, 1);
        while (--clipNum) {
            (*pRc->HWSetupClipRect)(pRc, pClip++);
            (*pRc->drawTri)(pRc, a, b, c, 1);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\mcdutil.c ===
/******************************Module*Header*******************************\
* Module Name: mcdutil.c
*
* Contains various utility routines for the Cirrus Logic 546X MCD driver such as
* rendering-procedure picking functionality and buffer management.
*
* (based on mcdutil.c from NT4.0 DDK)
*
* Copyright (c) 1996 Microsoft Corporation
* Copyright (c) 1997 Cirrus Logic, Inc.
\**************************************************************************/

#include "precomp.h"
#include "mcdhw.h"
#include "mcdutil.h"
#include "mcdmath.h"
#include "stdio.h"

#ifdef B4_CIRRUS
static ULONG xlatRop[16] = {bop_BLACKNESS,    // GL_CLEAR         0
                            bop_MASKPEN,      // GL_AND           S & D
                            bop_MASKPENNOT,   // GL_AND_REVERSE   S & ~D
                            bop_SRCCOPY,      // GL_COPY          S
                            bop_MASKNOTPEN,   // GL_AND_INVERTED  ~S & D
                            bop_NOP,          // GL_NOOP          D
                            bop_XORPEN,       // GL_XOR           S ^ D
                            bop_MERGEPEN,     // GL_OR            S | D
                            bop_NOTMERGEPEN,  // GL_NOR           ~(S | D)
                            bop_NOTXORPEN,    // GL_EQUIV         ~(S ^ D)
                            bop_NOT,          // GL_INVERT        ~D
                            bop_MERGEPENNOT,  // GL_OR_REVERSE    S | ~D
                            bop_NOTCOPYPEN,   // GL_COPY_INVERTED ~S
                            bop_MERGENOTPEN,  // GL_OR_INVERTED   ~S | D
                            bop_NOTMASKPEN,   // GL_NAND          ~(S & D)
                            bop_WHITENESS,    // GL_SET           1
                        };   
#endif // B4_CIRRUS

// Function prototypes:

VOID FASTCALL HWSetupClipping(DEVRC *pRc, RECTL *pClip);

#define MCD_ALLOC_TAG   'dDCM'

#if DBG

ULONG MCDrvAllocMemSize = 0;

UCHAR *MCDDbgAlloc(UINT size)
{
    UCHAR *pRet;

    if (pRet = (UCHAR *)EngAllocMem(FL_ZERO_MEMORY, size + sizeof(ULONG),
                                    MCD_ALLOC_TAG)) {
        MCDrvAllocMemSize += size;
        *((ULONG *)pRet) = size;
        return (pRet + sizeof(ULONG));
    } else
        return (UCHAR *)NULL;
}

VOID MCDDbgFree(UCHAR *pMem)
{
    if (!pMem) {
        MCDBG_PRINT("MCDFree: Attempt to free NULL pointer.");
        return;
    }

    pMem -= sizeof(ULONG);

    MCDrvAllocMemSize -= *((ULONG *)pMem);

  //MCDBG_PRINT("MCDFree: %x bytes in use.", MCDrvAllocMemSize);

    EngFreeMem((VOID *)pMem);
}


#else


UCHAR *MCDAlloc(UINT size)
{
    return (UCHAR *)EngAllocMem(FL_ZERO_MEMORY, size, MCD_ALLOC_TAG);
}


VOID MCDFree(UCHAR *pMem)
{
    EngFreeMem((VOID *)pMem);
}

#endif /* DBG */

VOID MCDrvDebugPrint(char *pMessage, ...)
{
    va_list ap;
    va_start(ap, pMessage);

    EngDebugPrint("[MCD DRIVER] ", pMessage, ap);
    EngDebugPrint("", "\n", ap);

    va_end(ap);
}

VOID FASTCALL NullRenderPoint(DEVRC *pRc, MCDVERTEX *pv)
{
}

VOID FASTCALL NullRenderLine(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, BOOL bReset)
{
}

VOID FASTCALL NullRenderTri(DEVRC *pRc, MCDVERTEX *pv1, MCDVERTEX *pv2, MCDVERTEX *pv3)
{
}


MCDCOMMAND * FASTCALL FailPrimDraw(DEVRC *pRc, MCDCOMMAND *pCmd)
{
#ifdef B4_CIRRUS
    HW_WAIT_DRAWING_DONE(pRc);
#endif // B4_CIRRUS
    return pCmd;
}

BOOL PickPointFuncs(DEVRC *pRc)
{
    ULONG enables = pRc->MCDState.enables;

    pRc->drawPoint = NULL;   // assume failure

    if (enables & (MCD_POINT_SMOOTH_ENABLE))
        return FALSE;

    if (pRc->MCDState.pointSize != __MCDONE)
        return FALSE;

// First, get high-level rendering functions:

    if (pRc->MCDState.drawBuffer != GL_FRONT_AND_BACK) {
        pRc->renderPoint = __MCDRenderPoint;
    } else {
        pRc->renderPoint = __MCDRenderGenPoint;
    }

// handle any lower-level rendering if needed:

    pRc->drawPoint = pRc->renderPoint;

    return TRUE;
}

BOOL PickLineFuncs(DEVRC *pRc)
{
    ULONG enables = pRc->MCDState.enables;

    pRc->drawLine = NULL;   // assume failure

    if (enables & MCD_LINE_SMOOTH_ENABLE)
        return FALSE;

    if (pRc->MCDState.lineWidth > __MCDONE)
        return FALSE;

// First, get high-level rendering functions:

    if (pRc->MCDState.drawBuffer != GL_FRONT_AND_BACK) {
        pRc->renderLine = __MCDRenderLine;
    } else {
        pRc->renderLine = __MCDRenderGenLine;
    }

// Handle any lower-level rendering if needed:

    pRc->drawLine = pRc->renderLine;

    return TRUE;
}

BOOL PickTriangleFuncs(DEVRC *pRc)
{
    ULONG enables = pRc->MCDState.enables;

    //MCD_NOTE: MGA checked here if should punt on stipple - 546x does that in PickRendering
    //MCD_NOTE:   before this proc is called

    if (enables & (MCD_POLYGON_SMOOTH_ENABLE | 
                   MCD_COLOR_LOGIC_OP_ENABLE))
        return FALSE;

// First, get high-level rendering functions.  If we're not GL_FILL'ing
// both sides of our polygons, use the "generic" function.

    if (((pRc->MCDState.polygonModeFront == GL_FILL) &&
         (pRc->MCDState.polygonModeBack == GL_FILL)) &&
        (pRc->MCDState.drawBuffer != GL_FRONT_AND_BACK)
        ) {
        if (pRc->MCDState.shadeModel == GL_SMOOTH) 
            pRc->renderTri = __MCDRenderSmoothTriangle;
        else
            pRc->renderTri = __MCDRenderFlatTriangle;
    } else {
        pRc->renderTri = __MCDRenderGenTriangle;

        // In this case, we must handle the various fill modes.  We must
        // fail triangle drawing if we can't handle the types of primitives
        // that may have to be drawn.  This logic depends on the line and
        // point pick routines 

        // FUTURE: Sort out 2-sided support

        if (((pRc->MCDState.polygonModeFront == GL_POINT) && (!pRc->drawPoint)) ||
            ((pRc->MCDState.polygonModeFront == GL_LINE) && (!pRc->drawLine)))
            return FALSE;
        if (pRc->privateEnables & __MCDENABLE_TWOSIDED) {
            if (((pRc->MCDState.polygonModeBack == GL_POINT) && (!pRc->drawPoint)) ||
                ((pRc->MCDState.polygonModeBack == GL_LINE) && (!pRc->drawLine)))
                return FALSE;
        }
    }

// Handle lower-level triangle rendering:
    
    //FUTURE:  add ability to configure different parameterization procs?
    if (pRc->privateEnables & __MCDENABLE_PERSPECTIVE)
        pRc->drawTri = __MCDPerspTxtTriangle;
    else
        pRc->drawTri = __MCDFillTriangle;                   

    return TRUE;
}

VOID __MCDPickRenderingFuncs(DEVRC *pRc, DEVWND *pDevWnd)
{
    BOOL bSupportedZFunc = TRUE;
	unsigned int	z_mode, z_comp_mode;		
	unsigned int	punt_all_points = FALSE;
	unsigned int	punt_all_lines = FALSE;
	unsigned int	punt_all_polys = FALSE;
    PDEV           *ppdev = pRc->ppdev;
    DWORD          *pdwNext = ppdev->LL_State.pDL->pdwNext;
    int             control0_set=FALSE;
    ULONG           _MCDStateenables = pRc->MCDState.enables;   // copy we can modify
    int             const_alpha_mode=FALSE;
    int             frame_scale=FALSE;

    pRc->primFunc[GL_POINTS] = __MCDPrimDrawPoints;
    pRc->primFunc[GL_LINES] = __MCDPrimDrawLines;
    pRc->primFunc[GL_LINE_LOOP] = __MCDPrimDrawLineLoop;
    pRc->primFunc[GL_LINE_STRIP] = __MCDPrimDrawLineStrip;
    pRc->primFunc[GL_TRIANGLES] = __MCDPrimDrawTriangles;
    pRc->primFunc[GL_TRIANGLE_STRIP] = __MCDPrimDrawTriangleStrip;
    pRc->primFunc[GL_TRIANGLE_FAN] = __MCDPrimDrawTriangleFan;
    pRc->primFunc[GL_QUADS] = __MCDPrimDrawQuads;
    pRc->primFunc[GL_QUAD_STRIP] = __MCDPrimDrawQuadStrip;
    pRc->primFunc[GL_POLYGON] = __MCDPrimDrawPolygon;

	// normal mode for all conditions except NEVER and ALWAYS
 	z_mode = LL_Z_MODE_NORMAL;

    switch (pRc->MCDState.depthTestFunc) {
        default:
        case GL_NEVER:
			z_mode = LL_Z_MODE_MASK;
			// comp mode is don't care, but set to default anyway
			z_comp_mode = LL_Z_WRITE_GREATER_EQUAL;
            break;
        case GL_LESS:
			z_comp_mode = LL_Z_WRITE_LESS;
            break;
        case GL_EQUAL:
			z_comp_mode = LL_Z_WRITE_EQUAL;
            break;
        case GL_LEQUAL:
			z_comp_mode = LL_Z_WRITE_LESS_EQUAL;
            break;
        case GL_GREATER:
			z_comp_mode = LL_Z_WRITE_GREATER;
            break;
        case GL_NOTEQUAL:
			z_comp_mode = LL_Z_WRITE_NOT_EQUAL;
            break;
        case GL_GEQUAL:
			z_comp_mode = LL_Z_WRITE_GREATER_EQUAL;
            break;
        case GL_ALWAYS:
			z_mode = LL_Z_MODE_ALWAYS;
			// comp mode is don't care, but set to default anyway
			z_comp_mode = LL_Z_WRITE_GREATER_EQUAL;
            break;
    }
    
    // Set up the privateEnables flags:
    pRc->privateEnables = 0;

    if ((pRc->MCDState.twoSided) &&
        (_MCDStateenables & MCD_LIGHTING_ENABLE))
        pRc->privateEnables |= __MCDENABLE_TWOSIDED;        
    if (pDevWnd->bValidZBuffer && 
        (_MCDStateenables & MCD_DEPTH_TEST_ENABLE))
    {
        pRc->privateEnables |= __MCDENABLE_Z;
		if (z_mode == LL_Z_MODE_MASK)
        {
            // GL_NEVER depth test, so ignore all primitives
            pRc->allPrimFail = TRUE;
            return;
        }
        
        // Z enabled, so if draw to front (which is full screen and requires coords relative
        //   to screen origin) and z is windowed (which requires coords relative to window origin),
        //  punt
        if (pRc->MCDState.drawBuffer == GL_FRONT)
        {
            if (pRc->ppdev->pohZBuffer != pDevWnd->pohZBuffer)
            {
                pRc->allPrimFail = TRUE;
                pRc->punt_front_w_windowed_z=TRUE;
                return;
            }
            else
            {
                // reset global punt due to front buf draw with window-size z buffer
                pRc->punt_front_w_windowed_z = FALSE;
            }
        }
        else
        {
            if (pRc->punt_front_w_windowed_z)
            {
                // Drawing to backbuffer after drawing to front was punted.
                // Need to punt back draws as well since pixel-to-pixel compares 
                // of punted front and non-punted back will fail conformance test,
                // since punted result and non-punted are visually equivalent, but not
                // always exactly identical.

                // FUTURE2 : how to fix need to punt when full-screen front and windowed Z:
                // instead of making z buffer exact size as window, make larger such
                // that it starts at a y=16, x=64 boundary - where x/y offsets of
                // the 0,0 location of the window are same as the offsets of the window 
                // from the nearest 16/64 location on the fullscreen buffer.
                // See MCD notes, p 267 for details
                pRc->allPrimFail = TRUE;
                return;
            }
        }

    }
    else
    {
        // reset global punt due to front buf draw with window-size z buffer
        pRc->punt_front_w_windowed_z = FALSE;
    }

    if (pRc->MCDState.shadeModel == GL_SMOOTH)
        pRc->privateEnables |= __MCDENABLE_SMOOTH;
   
    // MCD_NOTE: if stipple and dither active at same time, may need to fail all lines/polys
    // MCD_NOTE:        - for now, we let stipple take precedence (see code in __MCDFillTriangle, etc)
    if (_MCDStateenables & MCD_DITHER_ENABLE)
        pRc->privateEnables |= __MCDENABLE_DITHER;

    pRc->HWSetupClipRect = HWSetupClipping;

    // Even though we're set up to handle this in the primitive pick
    // functions, we'll exit early here since we don't actually handle
    // this in the primitive routines themselves:

    if (pRc->MCDState.drawBuffer == GL_FRONT_AND_BACK) {
        pRc->allPrimFail = TRUE;
        return;
    }
        
    // If we're doing any of the following...
    //    - culling everything 
    //    - not updating any of our buffers
    //    - zmode says never update 
    //    - alpha test says never pass
    //...just return for all primitives:

    if (((_MCDStateenables & MCD_CULL_FACE_ENABLE) &&
         (pRc->MCDState.cullFaceMode == GL_FRONT_AND_BACK)) ||

        ((pRc->MCDState.drawBuffer == GL_NONE) && 
         ((!pRc->MCDState.depthWritemask) || (!pDevWnd->bValidZBuffer))) ||

       ((pRc->privateEnables & __MCDENABLE_Z) && (z_mode == LL_Z_MODE_MASK)) ||

       ((_MCDStateenables & MCD_ALPHA_TEST_ENABLE) && (pRc->MCDState.alphaTestFunc == GL_NEVER))

       ) {
        pRc->renderPoint = NullRenderPoint;
        pRc->renderLine = NullRenderLine;
        pRc->renderTri = NullRenderTri;
        pRc->allPrimFail = FALSE;
        return;
    }

    // Build lookup table for face direction

    switch (pRc->MCDState.frontFace) {
        case GL_CW:
            pRc->polygonFace[__MCD_CW] = __MCD_BACKFACE;
            pRc->polygonFace[__MCD_CCW] = __MCD_FRONTFACE;
            break;
        case GL_CCW:
            pRc->polygonFace[__MCD_CW] = __MCD_FRONTFACE;
            pRc->polygonFace[__MCD_CCW] = __MCD_BACKFACE;
            break;
    }

    // Build lookup table for face filling modes:

    pRc->polygonMode[__MCD_FRONTFACE] = pRc->MCDState.polygonModeFront;
    pRc->polygonMode[__MCD_BACKFACE] = pRc->MCDState.polygonModeBack;

    if (_MCDStateenables & MCD_CULL_FACE_ENABLE)
        pRc->cullFlag = (pRc->MCDState.cullFaceMode == GL_FRONT ? __MCD_FRONTFACE :
                                                                  __MCD_BACKFACE);
    else
        pRc->cullFlag = __MCD_NOFACE;


    // Assume that we fail everything:
        
    pRc->allPrimFail = TRUE;

    // see comment in mcd.hlp on MCDVERTEX - disable fog if texture mapping or gouraud shading
    if (!pRc->MCDState.textureEnabled && (pRc->MCDState.shadeModel == GL_SMOOTH))
    {
        _MCDStateenables &= ~MCD_FOG_ENABLE;
    }


    if ((_MCDStateenables & MCD_FOG_ENABLE) &&
        ((pRc->MCDState.fogMode != GL_LINEAR) || (pRc->MCDState.fogHint == GL_NICEST))) 
    {
        // 546x only does linear fog, so punt otherwise
        // QST2 - if linear fog mode, do we have to punt if foghint GL_NICEST?
        MCDFREE_PRINT("__MCDPick...non linear fog - punt");
        return;
    }

    if (_MCDStateenables & (MCD_COLOR_LOGIC_OP_ENABLE | 
                                 MCD_INDEX_LOGIC_OP_ENABLE |
                                 MCD_SCISSOR_TEST_ENABLE |
                                 MCD_STENCIL_TEST_ENABLE))
    {        
        MCDFREE_PRINT(".. will punt...logic ops or stencil ");
        return;
    }

    if (_MCDStateenables & (MCD_ALPHA_TEST_ENABLE))
    {
        if (pRc->MCDState.alphaTestFunc == GL_ALWAYS)
        {
            // if GL_ALWAYS, it's the same as no alpha test, so turn it off
            _MCDStateenables &= ~MCD_ALPHA_TEST_ENABLE;
        }
        else
        {
            if ((pRc->MCDState.alphaTestFunc == GL_GREATER) &&
                 pRc->MCDState.textureEnabled)
            {
                // only have alpha test support when textured - and even then it's limited
                // store ref scaled by 8 bits for compare to 8 bit alpha in BGRA textures
                pRc->bAlphaTestRef = (BYTE)(pRc->MCDState.alphaTestRef * (float)255.0);
                pRc->privateEnables |= __MCDENABLE_TEXTUREMASKING;        
            }
            else
            {
                MCDFREE_PRINT("AlphaTest, but not ALWAYS,NEVER, or GREATER (or not textured) - punt");
                return;
            }
        }
    }


    // if both blend and fog active, punt all since only one set of interpolators on 546x
    if ( (_MCDStateenables & (MCD_BLEND_ENABLE|MCD_FOG_ENABLE)) == 
                             (MCD_BLEND_ENABLE|MCD_FOG_ENABLE))
    {
        MCDFREE_PRINT(".. will punt...fog and blend ");
        return;
    }        

    if (_MCDStateenables & MCD_BLEND_ENABLE)
    {
        MCDFREE_PRINT("BLENDS: Src=%x Dst=%x",pRc->MCDState.blendSrc,pRc->MCDState.blendDst);
            
        if ((pRc->MCDState.blendSrc == GL_ONE) && 
            (pRc->MCDState.blendDst == GL_ZERO))
        {
            // equivalent to no blending, so shut it off
            _MCDStateenables &= ~MCD_BLEND_ENABLE;
        }
        else if ((pRc->MCDState.blendSrc == GL_ZERO) &&
                 (pRc->MCDState.blendDst == GL_ONE_MINUS_SRC_COLOR))
        {
            // one of GLQuake's favorite modes - requires HW's "Frame Scaling" function
            frame_scale=TRUE;
        }
        else if ((pRc->MCDState.blendSrc == GL_ONE) &&
                 (pRc->MCDState.blendDst == GL_ONE))
        {
            // one of GLQuake's favorite modes - will use CONST blend (set later in this proc)
            const_alpha_mode=TRUE;
            // lines and points don't yet support CONST blend - a simple matter of 
            //   programming to make points and lines work like polys in this regard
            punt_all_points=TRUE;
            punt_all_lines=TRUE;
        }
        else if ((pRc->MCDState.blendSrc != GL_SRC_ALPHA) ||
                 (pRc->MCDState.blendDst != GL_ONE_MINUS_SRC_ALPHA))
        {
            // unsupported mode
            MCDFREE_PRINT("unsupported blendSrc/blendDest");
            return;
        }

    }

    // FUTURE2: now punting if colorWriteMask not 1,1,1,X - should implement w/ color compare func
    if (!(pRc->MCDState.colorWritemask[0] &&
          pRc->MCDState.colorWritemask[1] &&
          pRc->MCDState.colorWritemask[2]))
    {
        MCDFREE_PRINT(".. will punt...write mask ");
        return;
    }


    // WARNING ........
    // WARNING ........
    // WARNING ........
    // Code below MAY set state in shadow regs, so be careful about early return early to punt
    // FROM THIS POINT ON...

    if (pRc->MCDState.textureEnabled)
    {
        // parameterization code for lines/points not done yet
        punt_all_points=TRUE;
        punt_all_lines=TRUE;

        MCDFREE_PRINT("__MCDPick...textures, envmode=%x ",pRc->MCDTexEnvState.texEnvMode);

        // punt if blending and alphatest both enabled - framescale part of blending, 
        //      so this covers punt needed for alphatest and framescaling
        if ((_MCDStateenables & (MCD_BLEND_ENABLE|MCD_ALPHA_TEST_ENABLE)) == 
                                (MCD_BLEND_ENABLE|MCD_ALPHA_TEST_ENABLE))
        {
            MCDFREE_PRINT("__MCDPick...textures, punt since blend & alphatest");
            return;
        }

        if (pRc->MCDState.perspectiveCorrectionHint!=GL_FASTEST)
            pRc->privateEnables |= (__MCDENABLE_TEXTURE|__MCDENABLE_PERSPECTIVE);
        else
            pRc->privateEnables |= __MCDENABLE_TEXTURE;

        // if both 1d and 2d bits same state, 2d is done (or if only 2d bit is on)
        if ((_MCDStateenables & (MCD_TEXTURE_1D_ENABLE|MCD_TEXTURE_2D_ENABLE)) == MCD_TEXTURE_1D_ENABLE)   
        {
            pRc->privateEnables |= __MCDENABLE_1D_TEXTURE;
        }

        if (pRc->MCDTexEnvState.texEnvMode == GL_BLEND)
        {
            // MCD_NOTE2: the following works only for GL_LUMINANCE, GL_LUMINANCE_ALPHA, and
            //              GL_INTENSITY textures.  GL_RGB and GL_RGBA textures will punt (later).

            // if normal blending or fog on and texture blend environment, then must punt since
            //  this requires 2 sets of alpha equations and hw only has 1
            if (_MCDStateenables & (MCD_BLEND_ENABLE|MCD_FOG_ENABLE|MCD_ALPHA_TEST_ENABLE))
            {
                MCDFREE_PRINT("__MCDPick...textures, GL_BLEND and fog|blend|alphatest");
                return;
            }

            // set alpha mode and dest color regs for GL_BLEND texture environment
            if( pRc->Control0.Alpha_Mode != LL_ALPHA_TEXTURE )
            {
                pRc->Control0.Alpha_Mode = LL_ALPHA_TEXTURE;
                control0_set=TRUE;
            }                            

            if( pRc->Control0.Alpha_Dest_Color_Sel != LL_ALPHA_DEST_CONST )
            {
                pRc->Control0.Alpha_Dest_Color_Sel = LL_ALPHA_DEST_CONST;
                control0_set=TRUE;
            }                            

            // load texture env color into color0 register
            pRc->dwColor0  = (FTOL(pRc->MCDTexEnvState.texEnvColor.r * pRc->rScale) & 0xff0000);
            pRc->dwColor0 |= (FTOL(pRc->MCDTexEnvState.texEnvColor.g * pRc->gScale) & 0xff0000) >> 8;
            pRc->dwColor0 |= (FTOL(pRc->MCDTexEnvState.texEnvColor.b * pRc->bScale) & 0xff0000) >> 16;

            *pdwNext++ = write_register( COLOR0_3D, 1 );
            *pdwNext++ = pRc->dwColor0;

            if (!pRc->Control0.Alpha_Blending_Enable)
            {
                pRc->Control0.Alpha_Blending_Enable = TRUE;
                control0_set=TRUE;
            }

        }        
        else if (pRc->MCDTexEnvState.texEnvMode == GL_MODULATE) 
        {
            if (frame_scale)
            {
                MCDFREE_PRINT("__MCDPick...textures, GL_MODULATE and framescaling");
                return;
            }

            pRc->privateEnables |= __MCDENABLE_LIGHTING;

            if( pRc->Control0.Light_Src_Sel != LL_LIGHTING_INTERP_RGB )
            {
                pRc->Control0.Light_Src_Sel = LL_LIGHTING_INTERP_RGB;
                control0_set=TRUE;
            }                            
        }
        // if texEnvMod not blend or modulate, it's either replace or decal - some settings 
        //   req'd at runtime, but not here

        // set so that first primitive will force setup of texture control regs
        pRc->pLastTexture = TEXTURE_NOT_LOADED;

    }
    else
    {
        // if texture not enabled, make sure texture mask disabled
        // this is a bug in 5464 and 5465 hardware
        // Texture enable/disable done only by state change (outside of DrvDraw)
        //   so we don't have to check this per primitive

        if (_MCDStateenables & MCD_ALPHA_TEST_ENABLE)
        {
            pRc->privateEnables &= ~__MCDENABLE_TEXTUREMASKING;        

        #ifdef STRICT_CONFORMANCE
            MCDFREE_PRINT("__MCDPick...alphatest but not textured - punt");
            return;
        #else
            MCDFREE_PRINT("__MCDPick...alphatest but not textured - SHOULD PUNT, BUT WON'T");
        #endif

        }

        if (frame_scale)
        {
            MCDFREE_PRINT("__MCDPick...framescale but not textured - punt");
            return;
        }

        if (pRc->dwTxControl0 & TEX_MASK_EN)
        {
            pRc->dwTxControl0 &= ~TEX_MASK_EN;
            *pdwNext++ = write_register( TX_CTL0_3D, 1 );
            *pdwNext++ = pRc->dwTxControl0;
        }
    }
     
    if (_MCDStateenables & MCD_LINE_STIPPLE_ENABLE)
    {
        if ( (_MCDStateenables & (MCD_BLEND_ENABLE|MCD_FOG_ENABLE)) ||
             (pRc->MCDState.lineStippleRepeat > 2) )
        {
            // if stipple active and alpha (via blend or fog), punt all lines
            // since 5464 has very limited support for this
            // also punt if factor > 2, since pattern is > 32 bits in such cases
            // NOTE that even though stipple and blend won't work as desired, dither and blend
            //      should.  DanW says 5464 has bug so this doesn't look too hot but this should
            //      be fixed in 5465 and following.
        	punt_all_lines = TRUE;
        }
        else
        {
            DWORD linestipple;

            if (pRc->MCDState.lineStippleRepeat == 1)
            {
                // repeat 16bit stipple twice, 
                linestipple = (pRc->MCDState.lineStipplePattern<<16) | pRc->MCDState.lineStipplePattern;
            }
            else
            {
                // double each bit, so 16 bit original becomes 32 bit
                int i;
                linestipple =  0;

                for (i=0; i<16; i++)
                {
                    linestipple |= (((pRc->MCDState.lineStipplePattern>>i) & 1) * 3) << (i*2);
                }

            }

            pRc->line_style.pat[0] = linestipple;

            pRc->privateEnables |= __MCDENABLE_LINE_STIPPLE;

        }
        pRc->ppdev->LL_State.pattern_ram_state  = PATTERN_RAM_INVALID;
    }

    
    if (_MCDStateenables & MCD_POLYGON_STIPPLE_ENABLE)
    {
        if (_MCDStateenables & (MCD_BLEND_ENABLE|MCD_FOG_ENABLE))
        {
            // if stipple active and alpha (via blend or fog), punt all polygons
            // since 5464 has very limited support for this
        	punt_all_polys = TRUE;
        }
        else
        {

            BYTE *pStipple = pRc->MCDState.polygonStipple;
            int i,j;

            for (i=0; i<64; ) {

                // 546x stipple is 16x16, OpenGL's is 32x32, so unless 32x32 pattern
                //    is really a 16x16 pattern repeated 4 times, we have to punt.

                // for 32 bit row of OpenGL pattern, check if byte0=byte2 and byte1=byte3
                if (pStipple[i]   != pStipple[i+2]) break;
                if (pStipple[i+1] != pStipple[i+3]) break;

                // now check if 4 bytes of 32bit row match 4bytes 32 bit row 16 rows down
                if (pStipple[i]   != pStipple[i+(16*4)]) break;
                if (pStipple[i+1] != pStipple[i+(16*4)+1]) break;
                if (pStipple[i+2] != pStipple[i+(16*4)+2]) break;
                if (pStipple[i+3] != pStipple[i+(16*4)+3]) break;

                i+=4;
    
            }

            // if we broke out before all 32 rows processed, HW can't support the pattern
            if (i<64) 
            {
                punt_all_polys=TRUE;
            }
            else
            {
                // pattern is OK - convert to format 546x needs
                unsigned int *pat = (unsigned int *)pRc->fill_pattern.pat;

                // Recall that we already verified that 32x32 pattern is really 4 identical
                // 16x16 blocks.  So take the upper left block and convert to 546x 16x16 pattern
                // NOTE that pattern is loaded such that first byte is lower left
                //    therefore, we start at top of 16x16 section and work down
                i=0;
                j=124;

                #define MIRROR_2(val) ((        ((val)&0x1)<<1) |         ((val)>>1))
                #define MIRROR_4(val) ((MIRROR_2((val)&0x3)<<2) | MIRROR_2((val)>>2))
                #define MIRROR_8(val) ((MIRROR_4((val)&0xf)<<4) | MIRROR_4((val)>>4))

                while (i < 8)
                {	
          		  // row N, in lower half of word
                  // compute mirror image of row, so 0th bit is LSB instead of MSB
                  // therefore we put upper byte in lower and vice versa, and mirror those bytes
          		  pat[i]  = (MIRROR_8(pStipple[j+1])<<8) | (MIRROR_8(pStipple[j]));       
                  j-=4;

                  // row N+1, in upper half of word
                  // compute mirror image of row, so 0th bit is LSB instead of MSB
                  // therefore we put upper byte in lower and vice versa, and mirror those bytes
                  pat[i] |= (MIRROR_8(pStipple[j+1])<<24) | (MIRROR_8(pStipple[j])<<16);
                  j-=4;
                  i++;  
                }    
            }

            pRc->privateEnables |= __MCDENABLE_PG_STIPPLE;
            
        }
        pRc->ppdev->LL_State.pattern_ram_state  = PATTERN_RAM_INVALID;
    }

    if ((z_comp_mode != pRc->Control0.Z_Compare_Mode) ||
        (z_mode != pRc->Control0.Z_Mode))
    {
        pRc->Control0.Z_Compare_Mode = z_comp_mode;
        pRc->Control0.Z_Mode = z_mode;
        control0_set=TRUE;
    }

    if (_MCDStateenables & MCD_BLEND_ENABLE)
    {

        // recall alpha mode only meaningful when alpha opcode bit set for primitive being rendered

        if (frame_scale)
        {
            // "frame scale" type of blend - select light source, and don't enable normal blend
            if( pRc->Control0.Light_Src_Sel != LL_LIGHTING_TEXTURE )
            {
                pRc->Control0.Light_Src_Sel = LL_LIGHTING_TEXTURE;
                control0_set=TRUE;
            }              
        }
        else
        {
            pRc->privateEnables |= __MCDENABLE_BLEND;
        }

        if( pRc->Control0.Alpha_Dest_Color_Sel != LL_ALPHA_DEST_FRAME )
        {
            pRc->Control0.Alpha_Dest_Color_Sel = LL_ALPHA_DEST_FRAME;
            control0_set=TRUE;
        }                            
    }
    else
    {
        // for fog dest_color is const and alpha values are coord's "fog" value
        if (_MCDStateenables & MCD_FOG_ENABLE)
        {
            // FUTURE: determine when to punt on fog
                    
            pRc->privateEnables |= __MCDENABLE_FOG;
            if( pRc->Control0.Alpha_Dest_Color_Sel != LL_ALPHA_DEST_CONST )
            {
                pRc->Control0.Alpha_Dest_Color_Sel = LL_ALPHA_DEST_CONST;
                control0_set=TRUE;
            }                            

            // load fog color into color0 register

            // QST - is fog density applied to fog color, or to fog values(start,end,etc.)?
            pRc->dwColor0  = (FTOL(pRc->MCDState.fogColor.r * pRc->rScale) & 0xff0000);
            pRc->dwColor0 |= (FTOL(pRc->MCDState.fogColor.g * pRc->gScale) & 0xff0000) >> 8;
            pRc->dwColor0 |= (FTOL(pRc->MCDState.fogColor.b * pRc->bScale) & 0xff0000) >> 16;

            *pdwNext++ = write_register( COLOR0_3D, 1 );
            *pdwNext++ = pRc->dwColor0;
        }
    }

    if (pRc->privateEnables & (__MCDENABLE_BLEND|__MCDENABLE_FOG))
    {
        // texture blend may change alpha_mode and alpha_dest_color
        // Note that we will punt before this point if texture blend with normal (blend|fog)
        //  since HW can't do both - if we make it here, we just need normal blend|fog
        if (!const_alpha_mode)
        {
            if( pRc->Control0.Alpha_Mode != LL_ALPHA_INTERP )
            {
                pRc->Control0.Alpha_Mode = LL_ALPHA_INTERP;
                control0_set=TRUE;
            } 
        }
        else
        {
            if( pRc->Control0.Alpha_Mode != LL_ALPHA_CONST )
            {
                pRc->Control0.Alpha_Mode = LL_ALPHA_CONST;
                control0_set=TRUE;
    
                // always SRC=DST=1.0
                *pdwNext++ = write_register( DA_MAIN_3D, 2 );
                *pdwNext++ = 0xff0000;
                *pdwNext++ = 0xff0000;
            } 
        }
    }                                   

    if ( (pRc->privateEnables & (__MCDENABLE_BLEND|__MCDENABLE_FOG)) ||
         ((pRc->privateEnables & __MCDENABLE_TEXTURE) && 
          (pRc->MCDTexEnvState.texEnvMode == GL_BLEND)) )
    {
        if (!pRc->Control0.Alpha_Blending_Enable)
        {
            pRc->Control0.Alpha_Blending_Enable = TRUE;
            control0_set=TRUE;
        }
    }
    else
    {
        // alpha blend not used, so turn off if currently on
        if (pRc->Control0.Alpha_Blending_Enable)
        {
            pRc->Control0.Alpha_Blending_Enable = FALSE;
            control0_set=TRUE;
        }

    }

    if (frame_scale)
    {
        if(!pRc->Control0.Frame_Scaling_Enable )
        {
            pRc->Control0.Frame_Scaling_Enable = TRUE;
            control0_set=TRUE;
        }                            
    }
    else
    {
        if( pRc->Control0.Frame_Scaling_Enable )
        {
            pRc->Control0.Frame_Scaling_Enable = FALSE;
            control0_set=TRUE;
        }                            
    }


    // setup for alpha test here...
    // setup for alpha test here...
    // setup for alpha test here...
    // setup for alpha test here...
    // setup for alpha test here...
    // setup for alpha test here...

    // setup polygon opcode
    pRc->dwPolyOpcode = POLY | 6 | WARP_MODE;
    if (pRc->privateEnables & __MCDENABLE_PG_STIPPLE)
    {
        pRc->dwPolyOpcode |= pRc->privateEnables & 
                    (__MCDENABLE_SMOOTH  | __MCDENABLE_Z |
                     __MCDENABLE_TEXTURE | __MCDENABLE_PERSPECTIVE |
                     __MCDENABLE_LIGHTING |
                     __MCDENABLE_PG_STIPPLE);
    }
    else
    {
        // can dither only if no stipple
        pRc->dwPolyOpcode |= pRc->privateEnables & 
                    (__MCDENABLE_SMOOTH  | __MCDENABLE_Z |
                     __MCDENABLE_TEXTURE | __MCDENABLE_PERSPECTIVE |
                     __MCDENABLE_LIGHTING |
                     __MCDENABLE_DITHER);
    }        

    // setup length and other flags in Opcode
    pRc->dwPolyOpcode += 3; // rgb

    // assume not flat bottom, will decrease if flat bottom at run time
    pRc->dwPolyOpcode += 2; 

    if (pRc->privateEnables & __MCDENABLE_SMOOTH) 
        pRc->dwPolyOpcode += 6; // for rgb, main and ortho slopes - so 6 values

    if( pRc->privateEnables & __MCDENABLE_Z) 
        pRc->dwPolyOpcode += 3;

    // assume linear, will increase if perspective at run time
    if (pRc->privateEnables & __MCDENABLE_TEXTURE)
        pRc->dwPolyOpcode += 6;

    // MCD_QST2  -> do we need FETCH_COLOR for Fog?
    if (pRc->privateEnables & (__MCDENABLE_BLEND|__MCDENABLE_FOG)) 
    {
        if (!const_alpha_mode)
        {
            pRc->dwPolyOpcode += ( FETCH_COLOR | ALPHA + 3 );
        }
        else
        {
            pRc->dwPolyOpcode += ( FETCH_COLOR );
        }

    }

    // frame scaling - must fetch frame color
    if (frame_scale) pRc->dwPolyOpcode += ( FETCH_COLOR );

    // setup line opcode
    pRc->dwLineOpcode = LINE  | 5;
    pRc->dwLineOpcode |= pRc->privateEnables & (__MCDENABLE_SMOOTH|__MCDENABLE_Z);
    if (pRc->privateEnables & __MCDENABLE_LINE_STIPPLE)                        
    {
        pRc->dwLineOpcode |= LL_STIPPLE;
    }
    else
    {
        // can dither only if no stipple
        pRc->dwLineOpcode |= (pRc->privateEnables & __MCDENABLE_DITHER) ;
    }        

    // setup point opcode
    pRc->dwPointOpcode= POINT | 2;
    pRc->dwPointOpcode |= pRc->privateEnables & (__MCDENABLE_Z|__MCDENABLE_DITHER) ;

    if (control0_set)
    {
        *pdwNext++ = write_register( CONTROL0_3D, 1 );
        *pdwNext++ = pRc->dwControl0;
    }

    pRc->allPrimFail = FALSE;

    if (punt_all_points || !PickPointFuncs(pRc)) {
        pRc->primFunc[GL_POINTS] = FailPrimDraw;
    }

    if (punt_all_lines || !PickLineFuncs(pRc)) {
        pRc->primFunc[GL_LINES] = FailPrimDraw;
        pRc->primFunc[GL_LINE_LOOP] = FailPrimDraw;
        pRc->primFunc[GL_LINE_STRIP] = FailPrimDraw;
    }

    if (punt_all_polys || !PickTriangleFuncs(pRc)) {
        pRc->primFunc[GL_TRIANGLES] = FailPrimDraw;
        pRc->primFunc[GL_TRIANGLE_STRIP] = FailPrimDraw;
        pRc->primFunc[GL_TRIANGLE_FAN] = FailPrimDraw;
        pRc->primFunc[GL_QUADS] = FailPrimDraw;
        pRc->primFunc[GL_QUAD_STRIP] = FailPrimDraw;
        pRc->primFunc[GL_POLYGON] = FailPrimDraw;
    }

    // don't send setup info, keep it queued and primitive rendering procs will send
    ppdev->LL_State.pDL->pdwNext=pdwNext;

}

////////////////////////////////////////////////////////////////////////
// Hardware-specific utility functions:
////////////////////////////////////////////////////////////////////////


VOID FASTCALL HWSetupClipping(DEVRC *pRc, RECTL *pClip)
{
    PDEV *ppdev = pRc->ppdev;
    DWORD *pdwNext = ppdev->LL_State.pDL->pdwNext;
    SET_HW_CLIP_REGS(pRc,pdwNext)

    ppdev->LL_State.pDL->pdwNext = pdwNext;

}

VOID HWUpdateBufferPos(MCDWINDOW *pMCDWnd, SURFOBJ *pso, BOOL bForce)
{
}


BOOL HWAllocResources(MCDWINDOW *pMCDWnd, SURFOBJ *pso,
                      BOOL zBufferEnabled,
                      BOOL backBufferEnabled)
{
    DEVWND *pDevWnd = (DEVWND *)pMCDWnd->pvUser;
    PDEV *ppdev = (PDEV *)pso->dhpdev;
    ULONG w, width, height;
    BOOL needFullZBuffer, needFullBackBuffer, tryFullSc;
    BOOL bFullScreen = FALSE;
    POFMHDL pohBackBuffer = NULL;
    POFMHDL pohZBuffer = NULL;
    SIZEL rctsize;
    ULONG alignflag;

    MCDBG_PRINT("HWAllocResources");
                                                
    width = min(pMCDWnd->clientRect.right - pMCDWnd->clientRect.left,
                 (LONG)ppdev->cxScreen);
    height = min(pMCDWnd->clientRect.bottom - pMCDWnd->clientRect.top,
                 (LONG)ppdev->cyScreen);

    // Assume failure:

    pDevWnd->allocatedBufferHeight = 0;
    pDevWnd->bValidBackBuffer = FALSE;
    pDevWnd->bValidZBuffer = FALSE;
    pDevWnd->pohBackBuffer = NULL;
    pDevWnd->pohZBuffer = NULL;

    if ((backBufferEnabled) && (!ppdev->cDoubleBufferRef))
        needFullBackBuffer = TRUE;
    else
        needFullBackBuffer = FALSE;

    if ((zBufferEnabled) && (!ppdev->cZBufferRef))
        needFullZBuffer = TRUE;
    else
        needFullZBuffer = FALSE;

    tryFullSc = TRUE;   // assume we'll try full screen if needed

    // If very little memory would be left after full screen back and z buffer allocations,
    //  any textures would likely be punted - so just allocate per window
    if (needFullBackBuffer || needFullZBuffer)
    {
        // total for fullscreen buffers for front, back, z
        LONG bytes_needed = 3 * ppdev->cyScreen * ppdev->lDeltaScreen;

        // add space for 128 scan lines of texture memory
        bytes_needed += 128 * ppdev->lDeltaScreen;

        if (bytes_needed > ppdev->lTotalMem)
        {
            MCDBG_PRINT("HWAllocResources: FullSc alloc won't leave 128 scans for texture, will try window size alloc");
            tryFullSc = FALSE;
        }
    }

    // NOTE: No need to remove all discardable bitmaps at this point, 
    // AllocOffScnMem will call OFS_DiscardMem as required if more mem reqd

    // If we need a back buffer, first try to allocate a fullscreen one:

    if (needFullBackBuffer && tryFullSc) {

      // Allocate the active video buffer space from the off screen memory
      rctsize.cx = ppdev->cxScreen;
      rctsize.cy = ppdev->cyScreen;
 
      alignflag = MCD_NO_X_OFFSET;         // force block to start at x=0;
      alignflag |= MCD_DRAW_BUFFER_ALLOCATE;  // force 32 scanline boundary
      
      pohBackBuffer = ppdev->pAllocOffScnMem(ppdev, &rctsize, alignflag, NULL);

      if (pohBackBuffer) {
          ppdev->pohBackBuffer = pohBackBuffer;
          ppdev->cDoubleBufferRef = 0;
      } else {
          ppdev->pohBackBuffer = NULL;
      }  

    }

    // If we need a z buffer, first try to allocate a fullscreen z:

    if (needFullZBuffer && tryFullSc) {

      // Allocate the active video buffer space from the off screen memory
      rctsize.cx = ppdev->cxScreen;
      rctsize.cy = ppdev->cyScreen;
 
      alignflag = MCD_NO_X_OFFSET;         // force block to start at x=0;
      alignflag |= MCD_Z_BUFFER_ALLOCATE;   // force 16 bpp allocate for Z on 32 scanline boundary
      pohZBuffer = ppdev->pAllocOffScnMem(ppdev, &rctsize, alignflag, NULL);

      if (pohZBuffer) {
          ppdev->pohZBuffer = pohZBuffer;
          ppdev->cZBufferRef = 0;
      } else {
          ppdev->pohZBuffer = NULL;
        //needFullBackBuffer = FALSE;
      }

    }

    // Check if one of our full-screen allocations failed
    if ( (needFullZBuffer && !pohZBuffer) ||        // fullscreen z tried and failed    OR
         (needFullBackBuffer && !pohBackBuffer) )   // fullscreen back tried and failed
    {

        // Free any resources allocated so far:
        // Note that even if full screen back allocated OK, and room for windowed Z, we
        //  still want to free the back and have both windowed.  This is so that 
        //  offset for both can be relative to window, not relative to screen.
        // If windowed back and Z, and drawing done to front (which by definition is full-screen),
        // we'll have to punt since can't do screen relative for visual (front) and window relative
        // for z.  Hardware has capability for unique y offsets per buffer, but only on 32 
        // scan line boundary.  We could adjust buffers, etc. to make this work, but it is believed
        // that drawing to front with windowed z is rare.  In such a case, the back buffer likely
        // won't exist, so fullscreen alloc for Z should usually have plenty of room.
        if (pohZBuffer) {
            ppdev->pFreeOffScnMem(ppdev, pohZBuffer);
            ppdev->pohZBuffer = NULL;
            ppdev->cZBufferRef = 0;
        }
        if (pohBackBuffer) {
            ppdev->pFreeOffScnMem(ppdev, pohBackBuffer);
            ppdev->pohBackBuffer = NULL;
            ppdev->cDoubleBufferRef = 0;
        }

        // Now, try to allocate per-window resources:

        if (backBufferEnabled) {

            // MCD_NOTE - should try to use window width here?
            rctsize.cx = width;
            rctsize.cy = height;
 
            // don't force block to start at x=0, will increase chance of success
            alignflag = MCD_DRAW_BUFFER_ALLOCATE;  // force 32 scanline boundary
            pohBackBuffer = ppdev->pAllocOffScnMem(ppdev, &rctsize, alignflag, NULL);

            if (!pohBackBuffer) {
                return FALSE;
            }
        }

        if (zBufferEnabled) {

            rctsize.cx = width;
            rctsize.cy = height;
 
            alignflag = MCD_NO_X_OFFSET; // force block to start at x=0; z buffer can't have x offset
            alignflag |= MCD_Z_BUFFER_ALLOCATE; // force 16 bpp allocate for Z
            pohZBuffer = ppdev->pAllocOffScnMem(ppdev, &rctsize, alignflag, NULL);

            if (!pohZBuffer) {
                if (pohBackBuffer)
                    ppdev->pFreeOffScnMem(ppdev, pohBackBuffer);
                return FALSE;
            }
        }

#if DBG
        if (zBufferEnabled)
            MCDBG_PRINT("HWAllocResources: Allocated window-sized z buffer");
        if (backBufferEnabled)
            MCDBG_PRINT("HWAllocResources: Allocated window-sized back buffer");
#endif

    } 
    else
    {
        // Our full-screen allocations worked, or the resources existed
        // already:

        bFullScreen = TRUE;

#if DBG
        if (zBufferEnabled && !ppdev->cZBufferRef)
            MCDBG_PRINT("HWAllocResources: Allocated full-screen z buffer");
        if (backBufferEnabled && !ppdev->cDoubleBufferRef)
            MCDBG_PRINT("HWAllocResources: Allocated full-screen back buffer");
#endif

        if (zBufferEnabled) {
            pohZBuffer = ppdev->pohZBuffer;
            ppdev->cZBufferRef++;
        }

        if (backBufferEnabled) {
            pohBackBuffer = ppdev->pohBackBuffer;
            ppdev->cDoubleBufferRef++;
        }
    }

    pDevWnd->pohBackBuffer = pohBackBuffer;
    pDevWnd->pohZBuffer = pohZBuffer;

    pDevWnd->frontBufferPitch = ppdev->lDeltaScreen;

    // Calculate back buffer variables:

    if (backBufferEnabled) {
        ULONG y;
        ULONG offset;

        // Set up base position, etc.

        pDevWnd->backBufferY = pDevWnd->backBufferBaseY = pohBackBuffer->aligned_y;
        pDevWnd->backBufferOffset = pDevWnd->backBufferBase = 
            (pohBackBuffer->aligned_y * ppdev->lDeltaScreen) + pohBackBuffer->aligned_x;
        pDevWnd->backBufferPitch = ppdev->lDeltaScreen;
        pDevWnd->bValidBackBuffer = TRUE;
    }

    if (zBufferEnabled) {

        ASSERTDD(pohZBuffer->aligned_x == 0,
                 "Z buffer should be 0-aligned");

        pDevWnd->zBufferBaseY = pohZBuffer->aligned_y;
        pDevWnd->zBufferBase = pohZBuffer->aligned_y * ppdev->lDeltaScreen;
        pDevWnd->zBufferOffset = pDevWnd->zBufferBase;

        // QST: Possible problem - if 8 bit frame and 16 bit Z, frame pitch may be less
        // QST:     than needed to accomodate 16 bit z???
        pDevWnd->zPitch = ppdev->lDeltaScreen;
        pDevWnd->bValidZBuffer = TRUE;
    }

    if (bFullScreen)
    {
        pDevWnd->allocatedBufferWidth  = ppdev->cxScreen;
        pDevWnd->allocatedBufferHeight = ppdev->cyScreen;
    }
    else
    {
        pDevWnd->allocatedBufferWidth = width;
        pDevWnd->allocatedBufferHeight = height;
    }

    MCDBG_PRINT("HWAllocResources OK");

    return TRUE;
}


VOID HWFreeResources(MCDWINDOW *pMCDWnd, SURFOBJ *pso)
{
    DEVWND *pDevWnd = (DEVWND *)pMCDWnd->pvUser;
    PDEV *ppdev = (PDEV *)pso->dhpdev;

    if (pDevWnd->pohZBuffer) {
        if (ppdev->cZBufferRef) {
            if (!--ppdev->cZBufferRef) {
                MCDBG_PRINT("MCDrvTrackWindow: Free global z buffer");
                ppdev->pFreeOffScnMem(ppdev, ppdev->pohZBuffer);
                ppdev->pohZBuffer = NULL;

            }
        } else {
            MCDBG_PRINT("MCDrvTrackWindow: Free local z buffer");
            ppdev->pFreeOffScnMem(ppdev, pDevWnd->pohZBuffer);
        }
    }

    if (pDevWnd->pohBackBuffer) {
        if (ppdev->cDoubleBufferRef) {
            if (!--ppdev->cDoubleBufferRef) {
                MCDBG_PRINT("MCDrvTrackWindow: Free global color buffer");
                ppdev->pFreeOffScnMem(ppdev, ppdev->pohBackBuffer);
                ppdev->pohBackBuffer = NULL;
            }
        } else {
            MCDBG_PRINT("MCDrvTrackWindow: Free local color buffer");
            ppdev->pFreeOffScnMem(ppdev, pDevWnd->pohBackBuffer);
        }
    }
}

VOID ContextSwitch(DEVRC *pRc)

{
    DWORD *pdwNext = pRc->ppdev->LL_State.pDL->pdwNext;

    // set control reg0
    *pdwNext++ = write_register( CONTROL0_3D, 1 );
    *pdwNext++ = pRc->dwControl0;

    // set tx control 0, and texture xy base
    *pdwNext++ = write_register( TX_CTL0_3D, 2 );
    *pdwNext++ = pRc->dwTxControl0;
    *pdwNext++ = pRc->dwTxXYBase;

    // set color0
    *pdwNext++ = write_register( COLOR0_3D, 1 );
    *pdwNext++ = pRc->dwColor0;

    // set to trigger next op that touches window to set base0 and base1 regs
    pRc->pLastDevWnd                        = NULL;
    pRc->pLastTexture                       = TEXTURE_NOT_LOADED;
    pRc->ppdev->LL_State.pattern_ram_state  = PATTERN_RAM_INVALID;

    pRc->ppdev->pLastDevRC = (ULONG)pRc;

    pRc->ppdev->LL_State.pDL->pdwNext = pdwNext;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\mcdtri.c ===
/******************************module*header*******************************\
* Module Name: mcdtri.c
*
* Contains the low-level (rasterization) triangle-rendering routines for the
* Cirrus Logic 546X MCD driver.
*
* Copyright (c) 1997 Cirrus Logic, Inc.
\**************************************************************************/

#include "precomp.h" 
#include "mcdhw.h"
#include "mcdutil.h"
#include "mcdmath.h"

#define QUAKEEDGE_FIX
#define FASTER_RECIP_ORTHO


#define HALF                0x08000
#define ONE                 0x10000

#define MCDTRI_PRINT   

//#define MAX_W_RATIO             (float)1.45
#define MAX_W_RATIO             (float)1.80
#define W_RATIO_PERSP_EQ_LINEAR (float)1.03

#define EDGE_SUBDIVIDE_TEST(start,end,WRAMAX,WRBMAX,SPLIT) \
  SPLIT = ((start->windowCoord.w > WRAMAX) || (end->windowCoord.w > WRBMAX)) ? 1 : 0;


#define FIND_MIDPOINT(start, end, mid) {                                                    \
    float   recip;                                                                          \
	mid->windowCoord.x =  (start->windowCoord.x + end->windowCoord.x) * (float)0.5;         \
	mid->windowCoord.y =  (start->windowCoord.y + end->windowCoord.y) * (float)0.5;         \
	mid->windowCoord.z =  (start->windowCoord.z + end->windowCoord.z) * (float)0.5;         \
    mid->colors[0].r = (start->colors[0].r + end->colors[0].r) * (float)0.5;                \
    mid->colors[0].g = (start->colors[0].g + end->colors[0].g) * (float)0.5;                \
    mid->colors[0].b = (start->colors[0].b + end->colors[0].b) * (float)0.5;                \
    mid->colors[0].a = (start->colors[0].a + end->colors[0].a) * (float)0.5;                \
    mid->fog = (start->fog + end->fog) * (float)0.5;                                        \
	mid->windowCoord.w =  (start->windowCoord.w + end->windowCoord.w) * (float)0.5;         \
    recip = (float)0.5/mid->windowCoord.w;  /* pre-mult by .5 for use below */              \
    mid->texCoord.x = recip * (start->texCoord.x * start->windowCoord.w +                   \
                               end->texCoord.x   * end->windowCoord.w);                     \
    mid->texCoord.y = recip * (start->texCoord.y * start->windowCoord.w +                   \
                               end->texCoord.y   * end->windowCoord.w);                     \
}                                                                                           


VOID FASTCALL __MCDSubdivideTriangle(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b, MCDVERTEX *c,
                                     int split12, int split23, int split31, int subdiv_levels)
{

    MCDVERTEX   Vmid12,Vmid23,Vmid31; // 3 possible midpoints

    subdiv_levels++;

    // find midpoint of edges if they need to be split
    if (split12) FIND_MIDPOINT(a,b,((MCDVERTEX *)&Vmid12)); 
    if (split23) FIND_MIDPOINT(b,c,((MCDVERTEX *)&Vmid23)); 
    if (split31) FIND_MIDPOINT(c,a,((MCDVERTEX *)&Vmid31)); 
    
#define SPLIT12 0x4
#define SPLIT23 0x2
#define SPLIT31 0x1

    // from original vertices and any midpoints found above, create a batch of triangles 
    switch ((split12<<2) | (split23<<1) | split31)
    {    
        case SPLIT12:
            // 2 triangles, 1->2 edge was divided
            __MCDPerspTxtTriangle(pRc, a, &Vmid12, c, subdiv_levels);
            __MCDPerspTxtTriangle(pRc, b, &Vmid12, c, subdiv_levels);
            break;

        case SPLIT23:
            // 2 triangles, 2->3 edge was divided
            __MCDPerspTxtTriangle(pRc, b, &Vmid23, a, subdiv_levels);
            __MCDPerspTxtTriangle(pRc, c, &Vmid23, a, subdiv_levels);
            break;

        case SPLIT31:
            // 2 triangles, 3->1 edge was divided
            __MCDPerspTxtTriangle(pRc, c, &Vmid31, b, subdiv_levels);
            __MCDPerspTxtTriangle(pRc, a, &Vmid31, b, subdiv_levels);
            break;

        case (SPLIT12|SPLIT23):
            // 3 triangles, 1->2 and 2->3 edges were divided
            __MCDPerspTxtTriangle(pRc, a, &Vmid23, c, subdiv_levels);
            __MCDPerspTxtTriangle(pRc, a, &Vmid23, &Vmid12, subdiv_levels);
            __MCDPerspTxtTriangle(pRc, &Vmid12, &Vmid23, b, subdiv_levels);
            break;

        case (SPLIT23|SPLIT31):
            // 3 triangles, 2->3 and 3->1 edges were divided
            __MCDPerspTxtTriangle(pRc, a, &Vmid31, b, subdiv_levels);
            __MCDPerspTxtTriangle(pRc, b, &Vmid31, &Vmid23, subdiv_levels);
            __MCDPerspTxtTriangle(pRc, &Vmid23, &Vmid31, c, subdiv_levels);
            break;

        case (SPLIT12|SPLIT31):
            // 3 triangles, 1->2 and 3->1 edges were divided
            __MCDPerspTxtTriangle(pRc, a, &Vmid31, &Vmid12, subdiv_levels);
            __MCDPerspTxtTriangle(pRc, b, &Vmid31, &Vmid12, subdiv_levels);
            __MCDPerspTxtTriangle(pRc, b, &Vmid31, c, subdiv_levels);
            break;

        case (SPLIT12|SPLIT23|SPLIT31):
            // 4 triangles, all 3 edges were divided
            __MCDPerspTxtTriangle(pRc, a, &Vmid31, &Vmid12, subdiv_levels);
            __MCDPerspTxtTriangle(pRc, b, &Vmid23, &Vmid12, subdiv_levels);
            __MCDPerspTxtTriangle(pRc, c, &Vmid31, &Vmid23, subdiv_levels);
            __MCDPerspTxtTriangle(pRc, &Vmid12, &Vmid23, &Vmid31, subdiv_levels);
            break;

        default:
            // original triangle - no subdivisions
            // this routine should never be called for this case, but here's insurance
            __MCDPerspTxtTriangle(pRc, a, b, c, subdiv_levels);
            break;

    } // endswitch

}


#define EXCHANGE(i,j)               \
{                                   \
    ptemp=i;                        \
    i=j; j=ptemp;                   \
}
#define ROTATE_L(i,j,k)             \
{                                   \
    ptemp=j;                        \
    j=k;k=i;i=ptemp;                \
}


#define SORT_Y_ORDER(a,b,c)                             \
{                                                       \
	void *ptemp;                                        \
    if( a->windowCoord.y > b->windowCoord.y )           \
        if( c->windowCoord.y < b->windowCoord.y )       \
            EXCHANGE(a,c)                               \
        else                                            \
            if( c->windowCoord.y < a->windowCoord.y )   \
                ROTATE_L(a,b,c)                         \
            else                                        \
                EXCHANGE(a,b)                           \
    else                                                \
        if( c->windowCoord.y < a->windowCoord.y )       \
            ROTATE_L(c,b,a)                             \
        else                                            \
            if( c->windowCoord.y < b->windowCoord.y )   \
                EXCHANGE(b,c)                           \
}


VOID FASTCALL __MCDPerspTxtTriangle(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b, MCDVERTEX *c, int subdiv_levels)
{
    int split12, split23, split31;
    float w1_times_max = a->windowCoord.w * W_RATIO_PERSP_EQ_LINEAR;
    float w2_times_max = b->windowCoord.w * W_RATIO_PERSP_EQ_LINEAR;
    float w3_times_max = c->windowCoord.w * W_RATIO_PERSP_EQ_LINEAR;

    if ((a->windowCoord.w < w2_times_max) && (b->windowCoord.w < w1_times_max) &&
        (b->windowCoord.w < w3_times_max) && (c->windowCoord.w < w2_times_max) &&
        (c->windowCoord.w < w1_times_max) && (a->windowCoord.w < w3_times_max))
    {
        if (subdiv_levels > 1)
        {
            // this triangle result of subdivision -> must sort in y
            SORT_Y_ORDER(a,b,c)
        }

        __MCDFillTriangle(pRc, a, b, c, TRUE); // ready to render - linear ok
    }
    else
    {
        w1_times_max = a->windowCoord.w * MAX_W_RATIO;
        w2_times_max = b->windowCoord.w * MAX_W_RATIO;
        w3_times_max = c->windowCoord.w * MAX_W_RATIO;

        // determine from w ratios which (if any) edges must be subdivided
        EDGE_SUBDIVIDE_TEST(a,b,w2_times_max,w1_times_max,split12)
        EDGE_SUBDIVIDE_TEST(b,c,w3_times_max,w2_times_max,split23)
        EDGE_SUBDIVIDE_TEST(c,a,w1_times_max,w3_times_max,split31)

        // if we need to subdivide, and we're not already too many levels deep, do it
        //  (since subdivision recursive, must limit it to prevent stack overflow in kernel mode)
        if ((split12 | split23 | split31) && (subdiv_levels < 4))
            __MCDSubdivideTriangle(pRc, a, b, c, split12, split23, split31, subdiv_levels);
        else
        {
            if (subdiv_levels > 1)
            {
                // this triangle result of subdivision -> must sort in y
                SORT_Y_ORDER(a,b,c)
            }
            __MCDFillTriangle(pRc, a, b, c, FALSE); // ready to render - linear NOT ok
        }
    }
}


#define FLT_TYPE                (float)

#define FLOAT_TO_1616           FLT_TYPE 65536.0
#define FIXED_X_ROUND_FACTOR    0x7fff

//#define INTPR(FLOATVAL) FTOL((FLOATVAL) * FLT_TYPE 1000.0)
#define INTPR(FLOATVAL) 0

/*********************************************************************
*   Local Functions
**********************************************************************/
#define RIGHT_TO_LEFT_DIR   0x80000000
#define LEFT_TO_RIGHT_DIR   0

#define EDGE_DISABLE_RIGHT_X    0x20000000
#define EDGE_DISABLE_LEFT_X     0x40000000
#define EDGE_DISABLE_BOTTOM_Y   0x20000000
#define EDGE_DISABLE_TOP_Y      0x40000000

#define EDGE_DISABLE_X      EDGE_DISABLE_RIGHT_X
#define EDGE_DISABLE_Y      0


// macros to convert float to precision equivalent to 16.16 representation

#define PREC_FLOAT      FLOAT_TO_1616

// rounding done by adding 1/2 of 1/65536, since 1/65536 is 16.16 step size
#define PREC_ROUND  ((FLT_TYPE 0.5) / PREC_FLOAT)

#define PREC_1616(inval,outval) {                                                           \
float bias = (inval>=0) ? PREC_ROUND : -PREC_ROUND;                                         \
outval=(float)(FTOL((inval+bias)*PREC_FLOAT)) * ((FLT_TYPE 1.0) / PREC_FLOAT);              \
}

// for positive values that will be used as negative, unconditionally bias it smaller
//  unless it's already too small
#define NEG_PREC_1616(inval,outval) {                                                       \
float bias = (inval>0) ? -PREC_ROUND : 0;                                                   \
outval=(float)(FTOL((inval+bias)*PREC_FLOAT)) * ((FLT_TYPE 1.0) / PREC_FLOAT);              \
}                                                                                        

// convert from float to 16.16 long
#define fix_ieee( val )     FTOL((val) * (float)65536.0)

// convert from float to 8.24 long
#define fix824_ieee( val )  FTOL((val) * (float)16777216.0)

typedef struct {
    float   a1, a2;
    float   b1, b2;
} QUADRATIC;

VOID FASTCALL __MCDFillTriangle(DEVRC *pRc, MCDVERTEX *a, MCDVERTEX *b, MCDVERTEX *c, int linear_ok)
{
    PDEV *ppdev;
    unsigned int *pdwNext;

	// output queue stuff...
    DWORD *pSrc;
    DWORD *pDest;
    DWORD *pdwStart;

    DWORD *pdwOrig;    
    DWORD *pdwColor;
    DWORD dwOpcode; 
    int   count1, count2;
    float frecip_main, frecip_ortho; 
    float fdx_main;
    float ftemp;
    float v1red,v1grn,v1blu;
    float fv2x,fv2y,fv3x,fv3y,fv32y; 

    float aroundy, broundy;

    float fmain_adj, fwidth, fxincrement, finitwidth1, finitwidth2;
    float fdwidth1,fdwidth2;
    
    float awinx, awiny, bwinx, bwiny, cwinx, cwiny;
    int   int_awiny, int_bwiny, int_cwiny;
    float fadjust;

    int   xflags;

	// window coords are float values, and need to have 
	// viewportadjust (MCDVIEWPORT) values subtracted to get to real screen space

	// color values are 0->1 floats and must be multiplied by scale values (MCDRCINFO)
	// to get to nbits range (scale = 0xff for 8 bit, 0x7 for 3 bit, etc.)

	// Z values are 0->1 floats and must be multiplied by zscale values (MCDRCINFO)

    // Caller has already sorted vertices so that a.y <= b.y <= c.y


    // Force flat-top/ flat-bottom right triangles to draw toward the center.
    // if Main is vertical edge, much better chance of alignment at diagonal
	if( a->windowCoord.y == b->windowCoord.y ) {           // Flat top
		if( b->windowCoord.x == c->windowCoord.x ) {
        	void *ptemp;
			EXCHANGE(a, b);
		}
	} else
	if( b->windowCoord.y == c->windowCoord.y ) {			// Flat bottom
		if( a->windowCoord.x == b->windowCoord.x ) {
        	void *ptemp;
			EXCHANGE(b, c);
		}
	}

    MCDTRI_PRINT("v1 = %d %d %d c1=%d %d %d",INTPR(a->windowCoord.x),INTPR(a->windowCoord.y),INTPR(a->windowCoord.z),INTPR(a->colors[0].r),INTPR(a->colors[0].g),INTPR(a->colors[0].b));
    MCDTRI_PRINT("v2 = %d %d %d c2=%d %d %d",INTPR(b->windowCoord.x),INTPR(b->windowCoord.y),INTPR(b->windowCoord.z),INTPR(b->colors[0].r),INTPR(b->colors[0].g),INTPR(b->colors[0].b));
    MCDTRI_PRINT("v3 = %d %d %d c3=%d %d %d",INTPR(c->windowCoord.x),INTPR(c->windowCoord.y),INTPR(c->windowCoord.z),INTPR(c->colors[0].r),INTPR(c->colors[0].g),INTPR(c->colors[0].b));

    awinx = a->windowCoord.x + pRc->fxOffset;
    awiny = a->windowCoord.y + pRc->fyOffset;
    bwinx = b->windowCoord.x + pRc->fxOffset;
    bwiny = b->windowCoord.y + pRc->fyOffset;
    cwinx = c->windowCoord.x + pRc->fxOffset;
    cwiny = c->windowCoord.y + pRc->fyOffset;

    // round y's (don't ever need rounded version of c's y)
    aroundy = FLT_TYPE FTOL(awiny + FLT_TYPE 0.5);
    broundy = FLT_TYPE FTOL(bwiny + FLT_TYPE 0.5);

#if 0
    // Someday, may want to convert floats to 16.16 equivalent precision
    //  I didn't find it necessary, but it's the first thing to try if
    //  a case comes up with holes....
    PREC_1616(awinx,awinx);
    PREC_1616(awiny,awiny);
    PREC_1616(bwinx,bwinx);
    PREC_1616(bwiny,bwiny);
    PREC_1616(cwinx,cwinx);
    PREC_1616(cwiny,cwiny);
#endif

    MCDTRI_PRINT("v1 = %d %d ",INTPR(awinx),INTPR(awiny));
    MCDTRI_PRINT("v2 = %d %d ",INTPR(bwinx),INTPR(bwiny));
    MCDTRI_PRINT("v3 = %d %d ",INTPR(cwinx),INTPR(cwiny));

    fv2x = bwinx - awinx;
    fv2y = bwiny - awiny;
    fv3x = cwinx - awinx;
    fv3y = cwiny - awiny;
    fv32y= cwiny - bwiny;

    // counts are total number of scan lines traversed

    // PERFORMANCE OPTIMIZATION - start divide now for main slope
    __MCD_FLOAT_BEGIN_DIVIDE(__MCDONE, fv3y, &frecip_main);

    // integer operations "free" since within fdiv latency
    ppdev = pRc->ppdev;
    pdwNext = ppdev->LL_State.pDL->pdwNext;
    pdwOrig = pdwNext;          

    int_cwiny = FTOL(cwiny);   
    int_bwiny = FTOL(bwiny);   
    int_awiny = FTOL(awiny);
    count1 = int_bwiny - int_awiny;
    count2 = int_cwiny - int_bwiny;

    __MCD_FLOAT_SIMPLE_END_DIVIDE(frecip_main);

    if ((awiny - int_awiny) == FLT_TYPE 0.0)
    {
        // start is on whole y - so bump count to include that scanline
        //  unless identical to b's y
        if (bwiny != awiny) count1++;
    }

    // check for case of adjusted A and real B being on same scan line (flat top)
    // even though count not 0
    // ex. a.y = 79.60, b.y = 80.00 -> a will be rounded to 80.0, so really
    // this is a flat top triangle.  In such case, set count1 = 0.
    // b will be counted below.  Failure to do this results in scanline that
    // has B being part of top and bottom, so width delta's applied when
    // hardware steps make for some interesting artifacts (see p. 205 of MCD notes)
    if (count1 == 1)
    {
        if ((bwiny - int_bwiny) == FLT_TYPE 0.0)
        {
            // convert to flat top
            count1 = 0;
        }
    }

    // similarly for almost flat bottom triangles...
    // If b.y=124.90 and c.y=125.000, we don't want to draw the scan line at
    // y=125 since any pixels drawn will be outside the triangle,
    // so if c on exact y and count2=1, set count2=0
    if (count2 == 1)
    {
        if ((cwiny - int_cwiny) == FLT_TYPE 0.0)
        {
            // convert to flat bottom
            count2 = 0;
        }
    }

    // main slope - based on precise vertices
 //USING MACROS TO OVERLAP DIVIDE WITH INTEGER OPERATIONS
 // frecip_main = FLT_TYPE 1.0/fv3y;

    fdx_main = fv3x * frecip_main;
    PREC_1616(fdx_main,fdx_main);

    // width at vtx b - based on precise vertices
    fwidth = fv2x - (fdx_main * fv2y);

    // make width positive, and set direction flag
    if (fwidth<0) 
    {
        fwidth = -fwidth;
        xflags = RIGHT_TO_LEFT_DIR | EDGE_DISABLE_X;
    }
    else
    {
        xflags = LEFT_TO_RIGHT_DIR | EDGE_DISABLE_X;
    }

    // if triangle has a top section (i.e. not flat top)....                
    if (count1)
    {
        fdwidth1 = fwidth / fv2y;

        PREC_1616(fdwidth1,fdwidth1);
                      
        if (aroundy < awiny)
        {
            // rounding produced y less than original, so step to next scan line
            // since init width would be negative
            aroundy += FLT_TYPE 1.0;
        }

        // determine distance between actual a and scanline we'll start on            
        fmain_adj = aroundy - awiny;

        // step width1 and x to scan line where we'll start
        finitwidth1 = fmain_adj * fdwidth1;
        fxincrement = fmain_adj * fdx_main;

    }
#ifdef QUAKEEDGE_FIX
    else
    {
        // flat top...
        if ((bwiny - int_bwiny) == FLT_TYPE 0.0)
        {
            // if b on exact scanline, it's part of top, and is counted in count1 above,
            // unless this is flat top triangle - in that case, bump count2
            // also, if identical to C's y, then flat bottom, so count2 should remain 0
            if (cwiny != bwiny) count2++;
        }
    }
#endif // QUAKEEDGE_FIX

    // if triangle has a bottom section (i.e. not flat bottom)....                
    if (count2)
    {
        float mid_adjust;

        fdwidth2 = fwidth / fv32y;
        NEG_PREC_1616(fdwidth2,fdwidth2);
        
    #ifdef QUAKEEDGE_FIX // badedge.sav fix
        if ((broundy < bwiny) || ((broundy==bwiny) && count1))  // step to next if b.y on exact scanline, unless flat top triangle
    #else
        if (broundy < bwiny)
    #endif
        {
            // rounding produced y less than original, so step to next scan line
            mid_adjust = (broundy + (float)1.0) - bwiny;
        }
        else
        {
            // rounding produced y greater than original (i.e on scan below actual start vertex)
            mid_adjust = broundy - bwiny;
        }

        finitwidth2 = fwidth - (fdwidth2 * mid_adjust);

        // if flat top, start x/y adjustments weren't made above
        if (!count1)
        {
            
            if (aroundy < awiny)
            {
                // rounding produced y less than original, so step to next scan line
                aroundy += FLT_TYPE 1.0;
            }

            // determine distance between actual a and scanline we'll start on            
            fmain_adj = aroundy - awiny;

            // step x to scan line where we'll start
            fxincrement = fmain_adj * fdx_main;
        }
    }
#ifdef QUAKEEDGE_FIX // badedge2.sav fix
    else
    {
        // flat bottom - if bottom is on exact scanline, don't draw that last scanline
        //   this will enforce GL restriction that bottom scanlines not drawn for polys
        //   (special case for this setup code for case of bottom of poly being on exact y value)
        if ((bwiny - int_bwiny) == FLT_TYPE 0.0)
        {
            if ((cwiny == bwiny) && count1) count1--;
        }
    }    
#endif // badedge2.sav fix

    // if triangle not a horizontal line (i.e. it traverses at least 1 scan line)....
    if (count1 || count2)
    {
        *(pdwNext+1) = (FTOL((awinx + fxincrement)*FLOAT_TO_1616) + FIXED_X_ROUND_FACTOR) | xflags;
        // subtracting special offset added to y to make visual match MSFT software
        *(pdwNext+2) = (DWORD)( (FTOL(aroundy)-MCD_CONFORM_ADJUST) << 16 ) | EDGE_DISABLE_Y;

        MCDTRI_PRINT(" x, y output = %x %x, yoffset=%x",*(pdwNext+1),*(pdwNext+2),pRc->yOffset);

        *(pdwNext+6) = FTOL(fdx_main*FLOAT_TO_1616);

        // if triangle has a bottom section, decrement number of scans in top so middle
        // scanline is first scanline of bottom section, and has length = finitwidth2

        if (!count2)
        {
            MCDTRI_PRINT(" FLATBOTTOM");
            *(pdwNext+8) = ONE + FTOL(finitwidth1*FLOAT_TO_1616);
            *(pdwNext+10)= FTOL(fdwidth1*FLOAT_TO_1616);
        #ifdef FASTER_RECIP_ORTHO
            __MCD_FLOAT_BEGIN_DIVIDE(__MCDONE, fwidth, &frecip_ortho);
        #endif
            *(pdwNext+7) = count1-1;
            *(pdwNext+9) = 0;
            *(pdwNext+11)= 0;
        }
        else if (!count1)
        {
            MCDTRI_PRINT(" FLATTOP");
            *(pdwNext+8) = ONE + FTOL(finitwidth2*FLOAT_TO_1616);
            *(pdwNext+10) = FTOL(FLT_TYPE -1.0*fdwidth2*FLOAT_TO_1616);
        #ifdef FASTER_RECIP_ORTHO
            __MCD_FLOAT_BEGIN_DIVIDE(__MCDONE, fwidth, &frecip_ortho);
        #endif
            *(pdwNext+7) = count2-1;
            *(pdwNext+9) = 0;
            *(pdwNext+11)= 0;                                                                     
        }
        else
        {
            MCDTRI_PRINT(" GENERAL");
            // sub 1 from count1, since hw adds 1 to account for first scan line
            *(pdwNext+8) = ONE + FTOL(finitwidth1*FLOAT_TO_1616);
            *(pdwNext+9) = ONE + FTOL(finitwidth2*FLOAT_TO_1616);
            *(pdwNext+10)= FTOL(fdwidth1*FLOAT_TO_1616);
            *(pdwNext+11)= FTOL(FLT_TYPE -1.0*fdwidth2*FLOAT_TO_1616);
        #ifdef FASTER_RECIP_ORTHO
            __MCD_FLOAT_BEGIN_DIVIDE(__MCDONE, fwidth, &frecip_ortho);
        #endif
            *(pdwNext+7) = (count1-1) + (count2 << 16);
        }

        MCDTRI_PRINT("dxm =%d w1=%d w2=%d dw1=%d dw2=%d",
            INTPR(fdx_main),INTPR(finitwidth1),INTPR(finitwidth2),INTPR(fdwidth1),INTPR(fdwidth2));
        MCDTRI_PRINT("  %x %x %x %x %x %x",*(pdwNext+6),*(pdwNext+7),*(pdwNext+8),*(pdwNext+9),*(pdwNext+10),*(pdwNext+11));

        pdwColor = pdwNext+3;
        pdwNext += 12;

    }
    else
    {
        // nothing to draw, triangle doesn't traverse any scan lines
        MCDTRI_PRINT(" Early return - flat top and bottom");
        return;                                            
    }

    // various integer ops to overlap with fdiv
    dwOpcode = pRc->dwPolyOpcode;
    pDest = ppdev->LL_State.pRegs + HOST_3D_DATA_PORT;
    pdwStart = ppdev->LL_State.pDL->pdwStartOutPtr;

    // do inside divide - won't slow us down unless 3D engine indeed not idle
    USB_TIMEOUT_FIX(ppdev)

    // compute 1/width, used in rgbzuv computations that follow
#ifdef FASTER_RECIP_ORTHO
    __MCD_FLOAT_SIMPLE_END_DIVIDE(frecip_ortho);
#else
    frecip_ortho = FLT_TYPE 1.0/fwidth;
#endif

    PREC_1616(frecip_ortho,frecip_ortho);


    if (pRc->privateEnables & __MCDENABLE_SMOOTH) 
    {
        // Calculate and set the color gradients, using gradients to adjust start color
        v1red = a->colors[0].r * pRc->rScale;
        v1grn = a->colors[0].g * pRc->gScale;
        v1blu = a->colors[0].b * pRc->bScale;

        ftemp = ((c->colors[0].r * pRc->rScale) - v1red) * frecip_main;

        *(pdwNext+0) = FTOL(ftemp);
        *(pdwNext+3) = FTOL(((b->colors[0].r * pRc->rScale) - (v1red + (ftemp * fv2y)) ) * frecip_ortho);
        
        // adjust v1red for start vertex's variance from vertex a
        *(pdwColor)   = FTOL(v1red + (ftemp * fmain_adj));

        ftemp = ((c->colors[0].g * pRc->gScale) - v1grn) * frecip_main;
        *(pdwNext+1) = FTOL(ftemp);
        *(pdwNext+4) = FTOL(((b->colors[0].g * pRc->gScale) - (v1grn + (ftemp * fv2y)) ) * frecip_ortho);

        // adjust v1grn for start vertex's variance from vertex a
        *(pdwColor+1) = FTOL(v1grn + (ftemp * fmain_adj));

        ftemp = ((c->colors[0].b * pRc->bScale) - v1blu) * frecip_main;
        *(pdwNext+2) = FTOL(ftemp);
        *(pdwNext+5) = FTOL(((b->colors[0].b * pRc->bScale) - (v1blu + (ftemp * fv2y)) ) * frecip_ortho);

        // adjust v1blu for start vertex's variance from vertex a
        *(pdwColor+2) = FTOL(v1blu + (ftemp * fmain_adj));

        MCDTRI_PRINT(" SHADE rgbout = %x %x %x",*(pdwColor),*(pdwColor+1),*(pdwColor+2));
        MCDTRI_PRINT("   CSLOPES: %x %x %x %x %x %x",*pdwNext,*(pdwNext+1),*(pdwNext+2),*(pdwNext+3),*(pdwNext+4),*(pdwNext+5));

        pdwNext += 6;
    }
    else
    {
        MCDCOLOR *pColor = &pRc->pvProvoking->colors[0];

        // flat shaded - no adjustment of original colors needed
    
        *(pdwColor)   = FTOL(pColor->r * pRc->rScale);
        *(pdwColor+1) = FTOL(pColor->g * pRc->gScale);
        *(pdwColor+2) = FTOL(pColor->b * pRc->bScale);

        MCDTRI_PRINT("  FLAT rgbout = %x %x %x",*(pdwColor),*(pdwColor+1),*(pdwColor+2));
    }



    if( pRc->privateEnables & __MCDENABLE_Z)
    {
        // "NICE" Polys for Alpha blended case - see comments above in
        //    geometry slopes calculations

        // Calculate and set the Z value base and gradient using floats
        float fdz_main = (c->windowCoord.z - a->windowCoord.z) * frecip_main;

        // compute adjustment - if negative z would result, set adjust so final = 0
        fadjust = fdz_main * fmain_adj;
        if ((a->windowCoord.z + fadjust) < (float)0.0) fadjust = - a->windowCoord.z;

        if (pRc->MCDState.enables & MCD_POLYGON_OFFSET_FILL_ENABLE) 
        {
            // APPLY Z OFFSET, and adjust for moved start vertex
            MCDFLOAT zOffset;
            if (fdz_main > 0)
            {
                zOffset = (fdz_main * pRc->MCDState.zOffsetFactor) + pRc->MCDState.zOffsetUnits;
            }
            else
            {
                zOffset = ((float)-1.0 * fdz_main * pRc->MCDState.zOffsetFactor) + pRc->MCDState.zOffsetUnits;
            }
                            
            *(pdwNext+0) = FTOL((a->windowCoord.z + fadjust + zOffset) * FLT_TYPE 65536.0);
        } 
        else
        {
            // NO Z OFFSET - just adjust for moved start vertex
            *(pdwNext+0) = FTOL((a->windowCoord.z + fadjust) * FLT_TYPE 65536.0);
        }

        *(pdwNext+1) = FTOL(fdz_main * FLT_TYPE 65536.0);
        *(pdwNext+2) = FTOL((b->windowCoord.z - a->windowCoord.z - (fdz_main * fv2y)) * FLT_TYPE 65536.0 * frecip_ortho);

        MCDTRI_PRINT("    Z: %x %x %x",*pdwNext,*(pdwNext+1),*(pdwNext+2));

        pdwNext += 3;

    }

    if (pRc->privateEnables & __MCDENABLE_TEXTURE) 
    {
        if ( (pRc->privateEnables & __MCDENABLE_PERSPECTIVE) && !linear_ok )
        {
            TEXTURE_VERTEX vmin, vmid, vmax;
            QUADRATIC main, mid;
            TEXTURE_VERTEX  i,imain,midmain,j,jmain;
            float   del_u_i, del_v_i;
            float   um,vm;      
            float   a1, a2, du_ortho_add;
            float   b1, b2, dv_ortho_add;
            float   sq, recip;
            float   delta_sq, inv_sumw;
            float   u1, v1;
            float   frecip_del_x_mid = frecip_ortho;
            int tempi;

            vmin.u = a->texCoord.x * pRc->texture_width;
            vmin.v = a->texCoord.y * pRc->texture_height;
            vmin.w = a->windowCoord.w;

            vmid.x = fv2x;
            vmid.y = fv2y;
            vmid.u = b->texCoord.x * pRc->texture_width;
            vmid.v = b->texCoord.y * pRc->texture_height;
            vmid.w = b->windowCoord.w;

            vmax.x = fv3x;
            vmax.y = fv3y;
            vmax.u = c->texCoord.x * pRc->texture_width;
            vmax.v = c->texCoord.y * pRc->texture_height;
            vmax.w = c->windowCoord.w;

            // solve quadratic equation for main slope - we'll need exact u values
            // along main, and the a1/b1, a2/b2 terms computed are used to compute
            // du/v_main, d2u/v_main
            delta_sq = frecip_main * frecip_main;

            inv_sumw = (float)1.0/(vmin.w + vmax.w);
            u1 = (vmin.u*vmin.w + vmax.u*vmax.w) * inv_sumw;
            v1 = (vmin.v*vmin.w + vmax.v*vmax.w) * inv_sumw;

            main.a1 = (-3*vmin.u + 4*u1 - vmax.u) * frecip_main;
            main.a2 = 2*(vmin.u - 2*u1 + vmax.u) * delta_sq;

            main.b1 = (-3*vmin.v + 4*v1 - vmax.v) * frecip_main;
            main.b2 = 2*(vmin.v - 2*v1 + vmax.v) * delta_sq;

            i.y = (float)0.5 * vmid.y;
            recip = (float)1.0 / (vmin.w + vmid.w);
            i.u = ((vmin.u * vmin.w) + (vmid.u * vmid.w)) * recip;
            i.v = ((vmin.v * vmin.w) + (vmid.v * vmid.w)) * recip;

            sq = i.y * i.y;
            imain.u = main.a2*sq + main.a1*i.y + vmin.u;
            imain.v = main.b2*sq + main.b1*i.y + vmin.v;

            // vmid coordinates given, just need midmain
            sq = vmid.y * vmid.y;
            midmain.u = main.a2*sq + main.a1*vmid.y + vmin.u;
            midmain.v = main.b2*sq + main.b1*vmid.y + vmin.v;

            // j and jmain
            j.y = (float)0.5 * (vmax.y + vmid.y);
            recip = (float)1.0 / (vmid.w + vmax.w);
            j.u = ((vmid.u * vmid.w) + (vmax.u * vmax.w)) * recip;
            j.v = ((vmid.v * vmid.w) + (vmax.v * vmax.w)) * recip;

            sq = j.y * j.y;
            jmain.u = main.a2*sq + main.a1*j.y + vmin.u;
            jmain.v = main.b2*sq + main.b1*j.y + vmin.v;

            // compute intermediate parameters needed to calculate a1
            del_u_i = i.u - imain.u;
            del_v_i = i.v - imain.v;
            um = j.u - jmain.u - del_u_i;
            vm = j.v - jmain.v - del_v_i;

            frecip_del_x_mid *= (float)2.0;

            a1 = 2*del_u_i - (float)0.5*(vmid.u - midmain.u);
            a1 += (vmid.y*frecip_main)*um;
            a1 *= frecip_del_x_mid;
            a2 = frecip_del_x_mid*(del_u_i*frecip_del_x_mid - a1);
            du_ortho_add = 2*um*frecip_del_x_mid*frecip_main;

            b1 = 2*del_v_i - (float)0.5*(vmid.v - midmain.v);
            b1 += (vmid.y*frecip_main)*vm;
            b1 *= frecip_del_x_mid;
            b2 = frecip_del_x_mid*(del_v_i*frecip_del_x_mid - b1);
            dv_ortho_add = 2*vm*frecip_del_x_mid*frecip_main;

            // rewind a1 from i scanline to top of triangle
            a1 -= (i.y) * du_ortho_add; 
            b1 -= (i.y) * dv_ortho_add; 

            // convert to forward difference terms
            a1 += a2;
            b1 += b2;
            a2 = 2 * a2;
            b2 = 2 * b2;

            // compute adjustment for v start - if negative would result -> no problem
            fadjust = ((main.b1 + main.b2) * fmain_adj) + pRc->texture_bias;
            *(pdwNext+0) = fix_ieee(vmin.v + fadjust) & 0x1ffffff;    // v

            // likewise for u
            fadjust = ((main.a1 + main.a2) * fmain_adj) + pRc->texture_bias;
            *(pdwNext+1) = fix_ieee(vmin.u + fadjust) & 0x1ffffff;    // u

            *(pdwNext+2) = fix_ieee(main.b1 + main.b2);     // dv_main
            *(pdwNext+3) = fix_ieee(main.a1 + main.a2);     // du_main
            *(pdwNext+4) = fix_ieee(b1);                    // dv_ortho
            *(pdwNext+5) = fix_ieee(a1);                    // du_ortho
        #if DRIVER_5465
            *(pdwNext+6) = fix824_ieee(2 * main.b2);        // d2v_main
            *(pdwNext+7) = fix824_ieee(2 * main.a2);        // d2u_main
            *(pdwNext+8) = fix824_ieee(b2);                 // d2v_ortho
            *(pdwNext+9) = fix824_ieee(a2);                 // d2u_ortho
            *(pdwNext+10)= fix824_ieee(dv_ortho_add);       // dv_ortho_add
            *(pdwNext+11)= fix824_ieee(du_ortho_add);       // du_ortho_add
        #else // DRIVER_5465
            // before 5465, only 16 bit fraction in second order terms
            *(pdwNext+6) = fix_ieee(2 * main.b2);           // d2v_main
            *(pdwNext+7) = fix_ieee(2 * main.a2);           // d2u_main
            *(pdwNext+8) = fix_ieee(b2);                    // d2v_ortho
            *(pdwNext+9) = fix_ieee(a2);                    // d2u_ortho
            *(pdwNext+10)= fix_ieee(dv_ortho_add);          // dv_ortho_add
            *(pdwNext+11)= fix_ieee(du_ortho_add);          // du_ortho_add
        #endif // DRIVER_5465

            dwOpcode += 6; // 6 parms assumed (linear), add 6 since 12 total
            pdwNext += 12;

        }
        else
        // Linear texture mapping parametarization
        //
        {
            float v1_u, v1_v;
            float du_main, dv_main;

            dwOpcode &= ~LL_PERSPECTIVE; // turn persp bit off

            v1_v = a->texCoord.y * pRc->texture_height;
            v1_u = a->texCoord.x * pRc->texture_width;

            dv_main = ((c->texCoord.y * pRc->texture_height)- v1_v) * frecip_main;
            du_main = ((c->texCoord.x * pRc->texture_width) - v1_u) * frecip_main;

            // compute adjustment for v start - if negative would result -> no problem
            fadjust = (dv_main * fmain_adj) + pRc->texture_bias;
            *(pdwNext+0) = fix_ieee(v1_v + fadjust) & 0x1ffffff;    // v

            // likewise for u...
            fadjust = (du_main * fmain_adj) + pRc->texture_bias;
            *(pdwNext+1) = fix_ieee(v1_u + fadjust) & 0x1ffffff;    // u

            *(pdwNext+2) = fix_ieee(dv_main);
            *(pdwNext+3) = fix_ieee(du_main);

            // dv_ortho, du_ortho
            *(pdwNext+4) = fix_ieee(((b->texCoord.y * pRc->texture_height) - (v1_v + (dv_main * count1))) * frecip_ortho);
            *(pdwNext+5) = fix_ieee(((b->texCoord.x * pRc->texture_width)  - (v1_u + (du_main * count1))) * frecip_ortho);

            MCDTRI_PRINT(" LINTEXT: %x %x %x %x %x %x",*pdwNext,*(pdwNext+1),*(pdwNext+2),*(pdwNext+3),*(pdwNext+4),*(pdwNext+5));

            pdwNext += 6;
        }

	}

    if (pRc->privateEnables & (__MCDENABLE_BLEND|__MCDENABLE_FOG)) 
    {
        float v1alp;

        // if CONST alpha blend, don't change alpha regs
        if (dwOpcode & ALPHA)
        {
            if (pRc->privateEnables & __MCDENABLE_BLEND) 
            {
                if (pRc->privateEnables & __MCDENABLE_SMOOTH) 
                {
                    // recall that if both blending and fog active, all prims punted back to software
                    v1alp = a->colors[0].a * pRc->aScale;

                    ftemp = ((c->colors[0].a * pRc->aScale) - v1alp) * frecip_main;

                    // load start alpha - adjusting for movement of start vertex from original
                    *pdwNext = FTOL(v1alp + (ftemp * fmain_adj));
                    // adjustment could result in negative alpha - set to 0 if so
                    if (*pdwNext & 0x80000000) *pdwNext = 0;  

                    *(pdwNext+1) = FTOL(ftemp);
                    *(pdwNext+2) = FTOL(((b->colors[0].a * pRc->aScale) - (v1alp + (ftemp * count1)) ) * frecip_ortho);
                }
                else                            
                {
                    v1alp = pRc->pvProvoking->colors[0].a * pRc->aScale;
                    // alpha constant across triangle, so no adjustment to start    
                    *(pdwNext+0) = FTOL(v1alp) & 0x00ffff00;// bits 31->24 and 7->0 reserved
                    *(pdwNext+1) = 0;
                    *(pdwNext+2) = 0;
                }
            }
            else
            {
                // FOG...
                v1alp = a->fog * FLT_TYPE 16777215.0; // convert from 0->1.0 val to 0->ff.ffff val
                ftemp = ((c->fog * FLT_TYPE 16777215.0) - v1alp) * frecip_main;

                // load start alpha - adjusting for movement of start vertex from original
                *pdwNext = FTOL(v1alp + (ftemp * fmain_adj));
                // adjustment could result in negative alpha - set to 0 if so
                if (*pdwNext & 0x80000000) *pdwNext = 0;  
                *(pdwNext+1) = FTOL(ftemp);
                *(pdwNext+2) = FTOL(((b->fog * FLT_TYPE 16777215.0) - (v1alp + (ftemp * count1)) ) * frecip_ortho);
            }

            *(pdwNext+0) &= 0x00ffff00;// bits 31->24 and 7->0 reserved
            *(pdwNext+1) &= 0xffffff00;// bits 7->0 reserved
            *(pdwNext+2) &= 0xffffff00;// bits 7->0 reserved

            pdwNext += 3; 
        }
    
	}

    *pdwOrig = dwOpcode;

	// output queued data here....
    pSrc  = pdwStart;                                                             
    while (pSrc != pdwNext)                                                   
    {                                                                         
        int len = (*pSrc & 0x3F) + 1;                                             
        while( len-- ) *pDest = *pSrc++;                                      
    } 
                          
    ppdev->LL_State.pDL->pdwNext = ppdev->LL_State.pDL->pdwStartOutPtr = pdwStart;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\mcdutil.h ===
/******************************Module*Header*******************************\
* Module Name: mcdutil.h
*
* Include file which indirects all of the hardware-dependent functionality
* in the MCD driver code.
*
* Copyright (c) 1996 Microsoft Corporation
* Copyright (c) 1997 Cirrus Logic, Inc.
\**************************************************************************/

#ifndef _MCDUTIL_H
#define _MCDUTIL_H

#include <gl\gl.h>

VOID MCDrvDebugPrint(char *, ...);

#if DBG // this is defined in \ddk\inc\makefile.def                     
UCHAR *MCDDbgAlloc(UINT);
VOID MCDDbgFree(UCHAR *);

#define MCDAlloc   MCDDbgAlloc
#define MCDFree    MCDDbgFree

#define MCDBG_PRINT             MCDrvDebugPrint
//#define MCDBG_PRINT

#define MCDFREE_PRINT           MCDrvDebugPrint
//#define MCDFREE_PRINT
                                                
#else

UCHAR *MCDAlloc(UINT);
VOID MCDFree(UCHAR *);
#define MCDBG_PRINT

//#define MCDFREE_PRINT           MCDrvDebugPrint
#define MCDFREE_PRINT

#endif

//#define MCDFORCE_PRINT           MCDrvDebugPrint
#define MCDFORCE_PRINT
                               
#define MCD_CHECK_RC(pRc)\
    if (pRc == NULL) {\
        MCDBG_PRINT("NULL device RC");\
        return FALSE;\
    }


#define MCD_CHECK_BUFFERS_VALID(pMCDSurface, pRc, resChangedRet)\
{\
    DEVWND *pDevWnd = (DEVWND *)pMCDSurface->pWnd->pvUser;\
\
    if (!pDevWnd) {\
        MCDBG_PRINT("HW_CHECK_BUFFERS_VALID: NULL buffers");\
        return FALSE;\
    }\
\
    if ((pRc->backBufEnabled) &&\
        (!pDevWnd->bValidBackBuffer)) {\
        MCDBG_PRINT("HW_CHECK_BUFFERS_VALID: back buffer invalid");\
        return FALSE;\
    }\
\
    if ((pRc->zBufEnabled) &&\
        (!pDevWnd->bValidZBuffer)) {\
        MCDBG_PRINT("HW_CHECK_BUFFERS_VALID: z buffer invalid");\
        return FALSE;\
    }\
\
    if (pDevWnd->dispUnique != GetDisplayUniqueness((PDEV *)pMCDSurface->pso->dhpdev)) {\
        MCDBG_PRINT("HW_CHECK_BUFFERS_VALID: resolution changed but not updated");\
        return resChangedRet;\
    }\
}

#define CHK_TEX_KEY(pTex);                                                    \
        if(pTex == NULL) {                                                    \
                MCDBG_PRINT("CHK_TEX_KEY:Attempted to update a null texture");    \
                return FALSE;                                                 \
        }                                                                     \
                                                                              \
        if(pTex->textureKey == 0) {                                           \
             MCDBG_PRINT("CHK_TEX_KEY:Attempted to update a null device texture");\
             return FALSE;                                                    \
        }                                                               

BOOL HWAllocResources(MCDWINDOW *pMCDWnd, SURFOBJ *pso, BOOL zEnabled,
                      BOOL backBufferEnabled);
VOID HWFreeResources(MCDWINDOW *pMCDWnd, SURFOBJ *pso);
VOID HWUpdateBufferPos(MCDWINDOW *pMCDWnd, SURFOBJ *pso, BOOL bForce);

ULONG __MCDLoadTexture(PDEV *ppdev, DEVRC *pRc);
POFMHDL __MCDForceTexture (PDEV *ppdev, SIZEL *mapsize, int alignflag, float priority);

VOID ContextSwitch(DEVRC *pRc);

// simple wait added for 546x
__inline void WAIT_HW_IDLE(PDEV *ppdev)
{

    int status;        
    volatile int wait_count=0;

    do
    {
        status = (*((volatile *)((DWORD *)(ppdev->pLgREGS) + PF_STATUS_3D)) & 0x3FF) ^ 0x3E0;

        // do something to give bus a breather
        wait_count++;

    } while((status & 0x3e0) != 0x3e0);
}

// From Tim McDonald concerning bits in status register, and checking that 2D is idle
//      execution engine - 3d only, says poly is being assembled
//      cmd fifo         - could have 2d command about to be sent to 2d engine, so must be empty
//      2d engine        - must be idle
// see include\laguna.h for MACRO display driver uses to make sure 3D idle before starting 2D

//#define WAIT_2D_STATUS_MASK 0x3e0 // wait for everything to stop
#define WAIT_2D_STATUS_MASK 0x300   // wait for 2D(BLT) engine to idle and CMD fifo to drain

// wait for 2D operations to end
__inline void WAIT_2D_IDLE(PDEV *ppdev)
{

    int status;        
    volatile int wait_count=0;

    do
    {
        status = (*((volatile *)((DWORD *)(ppdev->pLgREGS) + PF_STATUS_3D)) & 0x3FF) ^ WAIT_2D_STATUS_MASK;

        // do something to give bus a breather
        wait_count++;

    } while((status & WAIT_2D_STATUS_MASK) != WAIT_2D_STATUS_MASK);
}



__inline void HW_WAIT_DRAWING_DONE(DEVRC *pRc)
{
    // MCD_NOTE just waits for all engines to stop...need to change for displists
    WAIT_HW_IDLE (pRc->ppdev);

}


__inline void HW_INIT_DRAWING_STATE(MCDSURFACE *pMCDSurface, MCDWINDOW *pMCDWnd,
                                    DEVRC *pRc)
{
    DEVWND *pDevWnd = (DEVWND *)pMCDWnd->pvUser;
    PDEV    *ppdev  = (PDEV *)pMCDSurface->pso->dhpdev;
    DWORD   *pdwNext= ppdev->LL_State.pDL->pdwNext;

    union {
        TBase0Reg Base0;
        DWORD dwBase0;
    }b0;

    union {
        TBase1Reg Base1;
        DWORD dwBase1;
    }b1;

    b0.dwBase0 = pDevWnd->dwBase0;
    b1.dwBase1 = pDevWnd->dwBase1;

    // if window changed, or if double buffered, but drawing to front,
    //   set base addresses for current window

    /* since can have case of GL_FRONT, followed by GL_BACK, may need to reset for either case
     * instead of testing, just set regs since tests as expensive as blind set (?) */

    /*
    if (pRc->pLastDevWnd != pDevWnd || 
      ((pRc->MCDState.drawBuffer == GL_FRONT) && pDevWnd->pohBackBuffer)   )
    */
    {
        if ((pRc->MCDState.drawBuffer == GL_FRONT) && pDevWnd->pohBackBuffer)
        {
            // if double buffered window, pDevWnd->base0 and base1 always set for
            //  draw to back - override that here
            b1.Base1.Color_Buffer_Y_Offset = 0;
            b0.Base0.Color_Buffer_X_Offset = 0;
        }

        *pdwNext++ = write_register( BASE0_ADDR_3D, 2 );
        *pdwNext++ = b0.dwBase0;
        *pdwNext++ = b1.dwBase1;

        ppdev->LL_State.pDL->pdwNext = pdwNext;

        pRc->pLastDevWnd = pDevWnd;
    }
    // adjust pattern offset if stipple active and window has moved 
    if (pRc->privateEnables & __MCDENABLE_PG_STIPPLE)
    {
        if ((b0.Base0.Pattern_Y_Offset != (DWORD)(16-(pMCDSurface->pWnd->clientRect.top & 0xf) & 0xf)) ||
            (b0.Base0.Pattern_X_Offset != (DWORD)(16-(pMCDSurface->pWnd->clientRect.left & 0xf) & 0xf)) )
        {
            b0.Base0.Pattern_Y_Offset = 16-(pMCDSurface->pWnd->clientRect.top & 0xf) & 0xf;
            b0.Base0.Pattern_X_Offset = 16-(pMCDSurface->pWnd->clientRect.left & 0xf) & 0xf;

            *pdwNext++ = write_register( BASE0_ADDR_3D, 1 );
            *pdwNext++ = b0.dwBase0;

            ppdev->LL_State.pDL->pdwNext = pdwNext;
        }
                              
    }

    if (!(pRc->privateEnables & (__MCDENABLE_PG_STIPPLE|__MCDENABLE_LINE_STIPPLE)) &&
         (pRc->privateEnables & __MCDENABLE_DITHER))  
    {
        // dither active - check if dither pattern needs to be adjusted
        // Must keep pattern relative to x mod 4 = 0, y mod 4 = 0 for consistency    
        // Windowed draw buffers start at x=y=0. FullScreen buffers start at arbitrary
        // window offset - so must adjust dither pattern for these cases
        // (which means we may need to "un-adjust" for windowed buffer)
        int windowed_buffer = 
            ((pRc->MCDState.drawBuffer==GL_BACK) && (ppdev->pohBackBuffer!=pDevWnd->pohBackBuffer)) ? TRUE : FALSE;
    
        if ( (!windowed_buffer &&   // need to adjust???
             ((pMCDSurface->pWnd->clientRect.left & 0x3) != ppdev->LL_State.dither_x_offset) ||
             ((pMCDSurface->pWnd->clientRect.top  & 0x3) != ppdev->LL_State.dither_y_offset) )
             ||
             (windowed_buffer &&    // need to un-adjust???
               (ppdev->LL_State.dither_x_offset || ppdev->LL_State.dither_y_offset))
             )
        {
            if (windowed_buffer)
            {
                // load default dither pattern
                ppdev->LL_State.dither_array.pat[0] = ppdev->LL_State.dither_array.pat[4] = 0x04150415;
                ppdev->LL_State.dither_array.pat[1] = ppdev->LL_State.dither_array.pat[5] = 0x62736273;
                ppdev->LL_State.dither_array.pat[2] = ppdev->LL_State.dither_array.pat[6] = 0x15041504;
                ppdev->LL_State.dither_array.pat[3] = ppdev->LL_State.dither_array.pat[7] = 0x73627362;
                ppdev->LL_State.dither_x_offset = ppdev->LL_State.dither_y_offset = 0;
            }
            else
            {

                // adjustment required
                int offset;

                // adjust columns for X first...
                offset = pMCDSurface->pWnd->clientRect.left & 0x3;  // number of x positions
                offset *= 4;    // 4 bits per x position

                ppdev->LL_State.dither_array.pat[0]  = (0x04150415)>>offset;
                ppdev->LL_State.dither_array.pat[0] |= ((0x0415) & (0xFFFF>>(16-offset))) << (32 - offset);

                ppdev->LL_State.dither_array.pat[1]  = (0x62736273)>>offset;
                ppdev->LL_State.dither_array.pat[1] |= ((0x6273) & (0xFFFF>>(16-offset))) << (32 - offset);

                ppdev->LL_State.dither_array.pat[2]  = (0x15041504)>>offset;
                ppdev->LL_State.dither_array.pat[2] |= ((0x1504) & (0xFFFF>>(16-offset))) << (32 - offset);

                ppdev->LL_State.dither_array.pat[3]  = (0x73627362)>>offset;
                ppdev->LL_State.dither_array.pat[3] |= ((0x7362) & (0xFFFF>>(16-offset))) << (32 - offset);

                // now adjust rows for y
                
                // copy adjusted row to second half of pattern (which HW sees as repeat of first half)
                switch (pMCDSurface->pWnd->clientRect.top & 0x3)
                {
                    case 0:
                        ppdev->LL_State.dither_array.pat[4] = ppdev->LL_State.dither_array.pat[0];
                        ppdev->LL_State.dither_array.pat[5] = ppdev->LL_State.dither_array.pat[1];
                        ppdev->LL_State.dither_array.pat[6] = ppdev->LL_State.dither_array.pat[2];
                        ppdev->LL_State.dither_array.pat[7] = ppdev->LL_State.dither_array.pat[3];
                    break;
                    case 1:
                        ppdev->LL_State.dither_array.pat[4] = ppdev->LL_State.dither_array.pat[3];
                        ppdev->LL_State.dither_array.pat[5] = ppdev->LL_State.dither_array.pat[0];
                        ppdev->LL_State.dither_array.pat[6] = ppdev->LL_State.dither_array.pat[1];
                        ppdev->LL_State.dither_array.pat[7] = ppdev->LL_State.dither_array.pat[2];
                    break;
                    case 2:
                        ppdev->LL_State.dither_array.pat[4] = ppdev->LL_State.dither_array.pat[2];
                        ppdev->LL_State.dither_array.pat[5] = ppdev->LL_State.dither_array.pat[3];
                        ppdev->LL_State.dither_array.pat[6] = ppdev->LL_State.dither_array.pat[0];
                        ppdev->LL_State.dither_array.pat[7] = ppdev->LL_State.dither_array.pat[1];
                    break;
                    case 3:
                        ppdev->LL_State.dither_array.pat[4] = ppdev->LL_State.dither_array.pat[1];
                        ppdev->LL_State.dither_array.pat[5] = ppdev->LL_State.dither_array.pat[2];
                        ppdev->LL_State.dither_array.pat[6] = ppdev->LL_State.dither_array.pat[3];
                        ppdev->LL_State.dither_array.pat[7] = ppdev->LL_State.dither_array.pat[0];
                    break;
                }

                // copied adjusted pattern back to first 4 row

                ppdev->LL_State.dither_array.pat[0] = ppdev->LL_State.dither_array.pat[4];
                ppdev->LL_State.dither_array.pat[1] = ppdev->LL_State.dither_array.pat[5];
                ppdev->LL_State.dither_array.pat[2] = ppdev->LL_State.dither_array.pat[6];
                ppdev->LL_State.dither_array.pat[3] = ppdev->LL_State.dither_array.pat[7];

                ppdev->LL_State.dither_x_offset = pMCDSurface->pWnd->clientRect.left & 0x3;
                ppdev->LL_State.dither_y_offset = pMCDSurface->pWnd->clientRect.top  & 0x3;
            }

            // force adjusted pattern to be loaded before use
    	    ppdev->LL_State.pattern_ram_state   = PATTERN_RAM_INVALID;
        }
    }

    // Make sure 2D engine idle before continuing w/ 3D operations
    WAIT_2D_IDLE(ppdev);

}

__inline void HW_FILL_RECT(MCDSURFACE *pMCDSurface, DEVRC *pRc, RECTL *pRecl, ULONG buffers)

{
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;
    WORD FillValue;
    DEVWND *pDevWnd = (DEVWND *)(pMCDSurface->pWnd->pvUser);
    DWORD       *pdwNext = ppdev->LL_State.pDL->pdwNext;
    DWORD       bltdef  = 0x1070;
    DWORD       drawdef = 0x00cc;
    DWORD       blt_x;
    DWORD       blt_y;
    DWORD       ext_x;
    DWORD       ext_y;
    WORD        color_l;
    WORD        color_h;

    MCDBG_PRINT("fill rect = %d, %d, %d, %d", pRecl->left,
                                              pRecl->top,
                                              pRecl->right,
                                              pRecl->bottom);

    // Since not much setup per blit, all work done here, rather than some in HW_START_FILL_RECT

    if ((buffers & GL_DEPTH_BUFFER_BIT) && pRc->MCDState.depthWritemask)
    {
        MCDBG_PRINT("Z fill rect");

        // calculate blt info in the y-dimension, which is constant regardless of pixel-depth

        // see mcd.c near line 525 for more hints on z buffer location
        blt_y = pRecl->top + pDevWnd->pohZBuffer->aligned_y; 
        ext_y = pRecl->bottom - pRecl->top + 1;

        // QST: always 16bits (2 bytes) per pixel for z?? - z fill macro assumes so
        // Z buffer always starts at 0 x offset
        blt_x = pRecl->left * 2;                     
        ext_x = (pRecl->right - pRecl->left + 1) * 2;   

        if (ppdev->pohZBuffer != pDevWnd->pohZBuffer) 
        {
            // Z buffer is window size only, so remove client rectangle origin
            blt_y -= pMCDSurface->pWnd->clientRect.top;
            blt_x -= pMCDSurface->pWnd->clientRect.left*2;
        }

        FillValue = (WORD)(pRc->MCDState.depthClearValue);

        *pdwNext++ = 0x720003e0; // wait_3d(0x3e0, 0);
        *pdwNext++ = 0x720003e0; // wait_3d(0x3e0, 0);

        // check for blackness fill: don't need to set bg color
        if (FillValue == 0) 
        {
            bltdef  = 0x1101;
            drawdef = 0x0000;

            *pdwNext++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 4, 0);
        }
        else 
        {
            // break bg color into low and high for stuffing command register
            color_h = FillValue;
            color_l = FillValue;

            // set up to write the 2d command register
            *pdwNext++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 6, 0);
            *pdwNext++ = C_BG_L << 16 | color_l;        // bgcolor l
            *pdwNext++ = C_BG_H << 16 | color_h;        // bgcolor h
			ppdev->shadowBGCOLOR = 0xDEADBEEF;
        }                                                             

        // burst the blt data to the 2d command register
        *pdwNext++ = C_BLTDEF << 16 | bltdef;           // set bltdef register
        *pdwNext++ = C_DRWDEF << 16 | drawdef;          // set drawdef register
		ppdev->shadowDRAWBLTDEF = 0xDEADBEEF;
        *pdwNext++ = C_MRX_0  << 16 | blt_x;            // x location: use byte pointer
        *pdwNext++ = C_MRY_0  << 16 | blt_y;            // y location: use byte pointer

        // launch the blt by writing the extents
        *pdwNext++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXT_EX, 1, 0); // note pixel ptr
        *pdwNext++ = ext_y << 16 | ext_x;

        *pdwNext++ = 0x720003e0; // wait_3d(0x3e0, 0);

    } // end Z clear 

    if (buffers & GL_COLOR_BUFFER_BIT)
    {
        RGBACOLOR scaledcolor;
        DWORD color;

        MCDBG_PRINT("colorbuf fill rect");

        // calculate blt info in the y-dimension, which is constant regardless of pixel-depth

        blt_y = pRecl->top; 
        if ((pRc->MCDState.drawBuffer != GL_FRONT) && pRc->backBufEnabled)
            blt_y += pDevWnd->pohBackBuffer->aligned_y; 

        ext_y = pRecl->bottom - pRecl->top + 1;

        // these are x y coordinates - hw converts to proper byte-equivalent locations
        blt_x = pRecl->left;                     
        ext_x = (pRecl->right - pRecl->left + 1);

        if ((pRc->MCDState.drawBuffer != GL_FRONT) && pRc->backBufEnabled)
        {
            // back buffer not necessarily at 0 x offset
            blt_x += pDevWnd->pohBackBuffer->aligned_x / ppdev->iBytesPerPixel; 

            if (ppdev->pohBackBuffer != pDevWnd->pohBackBuffer) 
            {
                // Back buffer is window size only, so remove client rectangle origin
                blt_y -= pMCDSurface->pWnd->clientRect.top;
                blt_x -= pMCDSurface->pWnd->clientRect.left;
            }

        }

        *pdwNext++ = 0x720003e0; // wait_3d(0x3e0, 0);
        *pdwNext++ = 0x720003e0; // wait_3d(0x3e0, 0);

        // macro converts components to 8.16 format
        MCDFIXEDRGB(scaledcolor, pRc->MCDState.colorClearValue);

        switch( ppdev->iBitmapFormat )
        {
            case BMF_8BPP:
                color =((scaledcolor.r & 0xe00000) >> 16)     |   // 3 significant bits, shifted to bits 7 6 5
                       ((scaledcolor.g & 0xe00000) >> 16+3)   |   // 3 significant bits, shifted to bits 4 3 2
                       ((scaledcolor.b & 0xc00000) >> 16+3+3);    // 2 significant bits, shifted to bits 1 0

                // duplicate the 8-bit color value as a full 32-bit dword
                color = color | (color << 8) | (color << 16) | (color << 24);
                break;
            case BMF_16BPP:
                color =((scaledcolor.r & 0xf80000) >> 8)     |   // 5 significant bits, shifted to bits 15 - 11
                       ((scaledcolor.g & 0xfc0000) >> 8+5)   |   // 6 significant bits, shifted to bits 10 -  5
                       ((scaledcolor.b & 0xf80000) >> 8+5+6);    // 5 significant bits, shifted to bits  4 -  0

                // duplicate the 16-bit color value as a full 32-bit dword
                color = color | (color << 16);
                break;
            case BMF_24BPP:
            case BMF_32BPP:
                color = (scaledcolor.r & 0xff0000)          |   // 8 significant bits
                       ((scaledcolor.g & 0xff0000) >> 8)    |   // 8 significant bits, shifted to bits 15 -  8
                       ((scaledcolor.b & 0xff0000) >> 16);      // 8 significant bits, shifted to bits  7 -  0
                break;
        }

        // break bg color into low and high for stuffing command register
        color_h  = (0xffff0000 & color) >> 16;
        color_l  = (WORD)(0x0000ffff & color);

        *pdwNext++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 2, 0);
        *pdwNext++ = C_BG_L << 16 | color_l;        // bgcolor l
        *pdwNext++ = C_BG_H << 16 | color_h;        // bgcolor h
		ppdev->shadowBGCOLOR = 0xDEADBEEF;

        // burst blt data to 2d command register
        *pdwNext++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 4, 0);
        *pdwNext++ = C_BLTDEF << 16 | bltdef;
        *pdwNext++ = C_DRWDEF << 16 | drawdef;
		ppdev->shadowDRAWBLTDEF = 0xDEADBEEF;
        *pdwNext++ = C_RX_0   << 16 | blt_x;            // x location
        *pdwNext++ = C_RY_0   << 16 | blt_y;            // y location

        // launch the blt by writing the extents
        *pdwNext++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXT_EX, 1, 0);
        *pdwNext++ = ext_y << 16 | ext_x;

        // wait for everything to quit
        *pdwNext++ = 0x720003e0; // wait_3d(0x3e0, 0);

    }

    // send data to hardware
    if (pdwNext != ppdev->LL_State.pDL->pdwNext)  _RunLaguna(ppdev,pdwNext);

}

__inline void HW_COPY_RECT(MCDSURFACE *pMCDSurface, RECTL *pRecl)
{
    PDEV *ppdev = (PDEV *)pMCDSurface->pso->dhpdev;
    ULONG FillValue;
    DEVWND *pDevWnd = (DEVWND *)(pMCDSurface->pWnd->pvUser);

    DWORD       *pdwNext = ppdev->LL_State.pDL->pdwNext;
    DWORD       src_x=0, src_y=0;
    DWORD       dst_x=0, dst_y=0;
    DWORD       ext_x=0, ext_y=0;
    DWORD       bltdef=0;

    MCDBG_PRINT("copy rect = %d, %d, %d, %d", pRecl->left,
                                              pRecl->top,
                                              pRecl->right,
                                              pRecl->bottom);

    {
        RGBACOLOR scaledcolor;
        DWORD color;

        // calculate blt info in the y-dimension, which is constant regardless of pixel-depth

        dst_y = pRecl->top;
        src_y = dst_y + pDevWnd->pohBackBuffer->aligned_y; 
        ext_y = pRecl->bottom - pRecl->top;

        // these are x y coordinates - hw converts to proper byte-equivalent locations
        dst_x = pRecl->left;                     
        // back buffer may be at same y loc's as front, but offset to right
        src_x = dst_x + (pDevWnd->pohBackBuffer->aligned_x / ppdev->iBytesPerPixel); 

        ext_x = pRecl->right - pRecl->left;

        if (ppdev->pohBackBuffer != pDevWnd->pohBackBuffer) 
        {
            // back buffer is window size only, so remove client rectangle origin
            // front buffer is always relative to screen origin, so leave dest alone
            src_y -= pMCDSurface->pWnd->clientRect.top;
            src_x -= pMCDSurface->pWnd->clientRect.left;
        }

        *pdwNext++ = 0x720003e0; // wait_3d(0x3e0, 0);
        *pdwNext++ = 0x720003e0; // wait_3d(0x3e0, 0);

        // program frame->frame blt
        bltdef |= 0x1010;

        // set up blitter: check for display list
#if DRIVER_5465 // C_BLTX moved between 64 and 65, so converted to write extents more like fill proc
                //      leaving old code for 5464 - even though never enable on real product                                  
        *pdwNext++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 6, 0);

        *pdwNext++ = C_BLTDEF << 16 | bltdef;           // set bltdef register
        *pdwNext++ = C_DRWDEF << 16 | 0x00cc;           // set drawdef register
		ppdev->shadowDRAWBLTDEF = 0xDEADBEEF;
        *pdwNext++ = C_RX_1   << 16 | src_x;            // use PIXEL pointer for source x
        *pdwNext++ = C_RY_1   << 16 | src_y;            // use PIXEL pointer for source y
        *pdwNext++ = C_RX_0   << 16 | dst_x;            // set dest x always as pixel ptr
        *pdwNext++ = C_RY_0   << 16 | dst_y;            // set dest y always as pixel ptr
        // launch the blt by writing the extents
        *pdwNext++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXT_EX, 1, 0);
        *pdwNext++ = ext_y << 16 | ext_x;
#else
        *pdwNext++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 9, 0);
        *pdwNext++ = C_BLTDEF << 16 | bltdef;           // set bltdef register
        *pdwNext++ = C_DRWDEF << 16 | 0x00cc;           // set drawdef register
		ppdev->shadowDRAWBLTDEF = 0xDEADBEEF;
        *pdwNext++ = C_RX_1   << 16 | src_x;            // use PIXEL pointer for source x
        *pdwNext++ = C_RY_1   << 16 | src_y;            // use PIXEL pointer for source y
        *pdwNext++ = C_RX_0   << 16 | dst_x;            // set dest x always as pixel ptr
        *pdwNext++ = C_RY_0   << 16 | dst_y;            // set dest y always as pixel ptr
        *pdwNext++ = C_BLTX   << 16 | ext_x;            // set x extent
        *pdwNext++ = C_BLTY   << 16 | ext_y;            // set y extent
        *pdwNext++ = C_EX_BLT << 16 | 0;                // execute the blt
#endif
        // wait for everything to quit
        *pdwNext++ = 0x720003e0; // wait_3d(0x3e0, 0);

    }

    // send data to hardware
    _RunLaguna(ppdev,pdwNext);

}


__inline int __MCDSetTextureRegisters(DEVRC *pRc)
{
    PDEV *ppdev = pRc->ppdev;
    unsigned int *pdwNext = ppdev->LL_State.pDL->pdwNext;
    LL_Texture  *pTex;
    int         control0_set=FALSE;
    union {
        TTxCtl0Reg TxControl0;      // Tx_Ctl0_3D temp register
        DWORD dwTxControl0;
    } Tx;

    // Set the texture control register with the texture information - start
    // with the cleared register and build up info as needed
    //
    Tx.dwTxControl0 = pRc->dwTxControl0 & ~0x00640FFF;

    pTex = pRc->pLastTexture;


    // punt if clamp and linear filtering - in this case, BorderColor should be
    // used for blend with portion where clamp is in effect, but 5465/5466/5468 has no
    // support for border colors
    if ( ((pTex->dwTxCtlBits & (CLMCD_TEX_U_SATURATE|CLMCD_TEX_FILTER)) == (CLMCD_TEX_U_SATURATE|CLMCD_TEX_FILTER)) ||
         ((pTex->dwTxCtlBits & (CLMCD_TEX_V_SATURATE|CLMCD_TEX_FILTER)) == (CLMCD_TEX_V_SATURATE|CLMCD_TEX_FILTER)) )
    {
        return (FALSE);
    }

//MCD_NOTE2: for true Compliance, don't define TREAT_DECAL_LIKE_REPLACE and DONT_PUNT_MODULATE_W_BLEND
//MCD_NOTE2:    below.  However, without DONT_PUNT_MODULATE_W_BLEND defined, GLQuake
//MCD_NOTE2:        punts the "sparkly chaff" textures.


//  When DECAL with RGBA texture and BLEND active, theoretically, we should punt,
//    but recall Microsoft's behavior on tlogo:
//     - it looked like they treat DECAL like REPLACE in case of RGBA textures,
//        so let's do same
//#define TREAT_DECAL_LIKE_REPLACE

// GLQuake using GL_MODULATE, with RGBA textures, with lots of blending
#define DONT_PUNT_MODULATE_W_BLEND

    // determine if texture format requires blend capability hw doesn't have
    if ( (pRc->privateEnables & (__MCDENABLE_BLEND|__MCDENABLE_FOG)) && 
          pTex->bAlphaInTexture &&
    #ifndef TREAT_DECAL_LIKE_REPLACE 
        #ifndef DONT_PUNT_MODULATE_W_BLEND
         (pRc->MCDTexEnvState.texEnvMode != GL_REPLACE) )
        #else // ndef DONT_PUNT_MODULATE_W_BLEND
         (pRc->MCDTexEnvState.texEnvMode != GL_REPLACE) &&
         (pRc->MCDTexEnvState.texEnvMode != GL_MODULATE) )
        #endif // DONT_PUNT_MODULATE_W_BLEND
    #else
         (pRc->MCDTexEnvState.texEnvMode != GL_REPLACE) &&
        #ifdef DONT_PUNT_MODULATE_W_BLEND
         (pRc->MCDTexEnvState.texEnvMode != GL_MODULATE) &&
        #endif // ndef DONT_PUNT_MODULATE_W_BLEND
         (pRc->MCDTexEnvState.texEnvMode != GL_DECAL) )
    #endif
    {
        return (FALSE);
    }

#ifndef TREAT_DECAL_LIKE_REPLACE 
    if ((pRc->MCDTexEnvState.texEnvMode == GL_DECAL) && pTex->bAlphaInTexture )
    {
            // decal mode and texture has RGBA or BGRA
            // will use alpha circuit for blending texel with polyeng, using alpha in texture

            if( pRc->Control0.Alpha_Mode != LL_ALPHA_TEXTURE )
            {
                pRc->Control0.Alpha_Mode = LL_ALPHA_TEXTURE;
                control0_set=TRUE;
            }                            

            if( pRc->Control0.Alpha_Dest_Color_Sel != LL_ALPHA_DEST_INTERP )
            {
                pRc->Control0.Alpha_Dest_Color_Sel = LL_ALPHA_DEST_INTERP;
                control0_set=TRUE;
            }                            

            if (!pRc->Control0.Alpha_Blending_Enable)
            {
                pRc->Control0.Alpha_Blending_Enable = TRUE;
                control0_set=TRUE;
            }
    }
#endif

    // decal mode without alpha in texture, or replace mode - set alpha regs back for "normal" use
    //  (previous primitive may have used alpha regs for decal w/ alpha)
#ifndef TREAT_DECAL_LIKE_REPLACE 
    if ( ((pRc->MCDTexEnvState.texEnvMode == GL_DECAL) && !pTex->bAlphaInTexture) ||
#else
    if ( ((pRc->MCDTexEnvState.texEnvMode == GL_DECAL)) ||
#endif

#ifdef DONT_PUNT_MODULATE_W_BLEND
          (pRc->MCDTexEnvState.texEnvMode == GL_MODULATE) ||
#endif // DONT_PUNT_MODULATE_W_BLEND

          (pRc->MCDTexEnvState.texEnvMode == GL_REPLACE))
    {
        // alpha circuit will be set as required for normal (blend|fog)
        // note that __MCDPickRenderingFuncs will have set up for punt if current
        //  blend/fog mode not supported in hw

        if (pRc->privateEnables & (__MCDENABLE_BLEND|__MCDENABLE_FOG)) 
        {

            if ((pRc->privateEnables & __MCDENABLE_BLEND) &&
                 pTex->bAlphaInTexture) 
            {
                // case of GL_REPLACE and texture has alpha - use texture's alpha
                if( pRc->Control0.Alpha_Mode != LL_ALPHA_TEXTURE )
                {
                    pRc->Control0.Alpha_Mode = LL_ALPHA_TEXTURE;
                    control0_set=TRUE;
                }                            
            }
            else
            {
                if( pRc->Control0.Alpha_Mode != LL_ALPHA_INTERP )
                {
                    pRc->Control0.Alpha_Mode = LL_ALPHA_INTERP;
                    control0_set=TRUE;
                }                            
            }

            if (pRc->privateEnables & __MCDENABLE_BLEND)
            {
                if( pRc->Control0.Alpha_Dest_Color_Sel != LL_ALPHA_DEST_FRAME )
                {
                    pRc->Control0.Alpha_Dest_Color_Sel = LL_ALPHA_DEST_FRAME;
                    control0_set=TRUE;
                }                            
            }
            else
            {
                // for fog dest_color is const and alpha values are coord's "fog" value
                if( pRc->Control0.Alpha_Dest_Color_Sel != LL_ALPHA_DEST_CONST )
                {
                    pRc->Control0.Alpha_Dest_Color_Sel = LL_ALPHA_DEST_CONST;
                    control0_set=TRUE;
                }                            

                // fog color already loaded into color0 register by __MCDPickRenderingFuncs
            }


            if (!pRc->Control0.Alpha_Blending_Enable)
            {
                pRc->Control0.Alpha_Blending_Enable = TRUE;
                control0_set=TRUE;
            }
        }
        else
        {
            // alpha blend not used, so turn off if currently on
            if (pRc->Control0.Alpha_Blending_Enable)
            {
                pRc->Control0.Alpha_Blending_Enable = FALSE;
                control0_set=TRUE;
            }
        }
    }

    pRc->texture_width = pTex->fWidth;

    if (pRc->privateEnables & __MCDENABLE_1D_TEXTURE)
    {
        // set factors to make v always 0 in parameterization code
        pRc->texture_height = (float)0.0;     
    }
    else
    {
        pRc->texture_height = pTex->fHeight;
    }

    if (pTex->dwTxCtlBits & CLMCD_TEX_FILTER)
    {
        pRc->texture_bias = (float)-0.5;
    }
    else
    {
        pRc->texture_bias = (float)0.0;
    }

    // MCD_NOTE: allowing filtering with Decal - broke on 5464, fixed on 5465(?)
    Tx.dwTxControl0 |= pTex->dwTxCtlBits & 
           ( CLMCD_TEX_FILTER
           | CLMCD_TEX_U_SATURATE|CLMCD_TEX_V_SATURATE
           | CLMCD_TEX_DECAL|CLMCD_TEX_DECAL_POL
        //QST: MCD doesn't use CLMCD_TEX_DECAL_INTERP? (currently disabled)
         /*| CLMCD_TEX_DECAL_INTERP*/ );
    Tx.TxControl0.Texel_Mode = pTex->bType;
    Tx.TxControl0.Tex_U_Address_Mask = pTex->bSizeMask & 0xF;
    Tx.TxControl0.Tex_V_Address_Mask = pTex->bSizeMask >> 4;
    #if 0   // QST: support texture palette???
    Tx.TxControl0.Texel_Lookup_En = pTex->fIndexed;
    Tx.TxControl0.CLUT_Offset = pTex->bLookupOffset;
    #endif // 

    // masking only meaningful if texture has alpha    
    if ((pRc->privateEnables & __MCDENABLE_TEXTUREMASKING) && pTex->bAlphaInTexture)
    {
        Tx.TxControl0.Tex_Mask_Enable=1;
        // polarity set to 1 in MCDrvCreateContext and stays that way
    }

    // Two kinds of textures: those residing in the video memory and 
    // those rendered from the system memory.  They need different setup.
    //
#ifdef MCD_SUPPORTS_HOST_TEXTURES
    if( pTex->dwFlags & TEX_IN_SYSTEM )
    { 
        DWORD dwOffset;

        printf(" Polys.c - tex in system id=%d\n",pBatch->wBuf);
        
        // Texture is in the system memory, so set the location
        //
        if( LL_State.Base0.Texture_Location != 1 )
        {
            LL_State.Base0.Texture_Location = 1;
            *pdwNext++ = write_register( BASE0_ADDR_3D, 1 );
            *pdwNext++ = LL_State.dwBase0;
        }

        // Set the host access base address and texture map offset
        //
        dwOffset = (DWORD)pTex->dwAddress - (DWORD)LL_State.Tex.Mem[pTex->bMem].dwAddress;
        
        if( LL_State.dwHXY_Base1_Address_Ptr != LL_State.Tex.Mem[pTex->bMem].dwPhyPtr ||
            LL_State.dwHXY_Base1_Offset0 != dwOffset )
        {
            // Check if only the offset must be reloaded (this is most likely)
            //
            if( LL_State.dwHXY_Base1_Address_Ptr == LL_State.Tex.Mem[pTex->bMem].dwPhyPtr )
            {
                *pdwNext++ = write_dev_register( HOST_XY, HXY_BASE1_OFFSET0_3D, 1 );
                *pdwNext++ = LL_State.dwHXY_Base1_Offset0 = dwOffset;
            }
            else
            {
                *pdwNext++ = write_dev_register( HOST_XY, HXY_BASE1_ADDRESS_PTR_3D, 2 );
                *pdwNext++ = LL_State.dwHXY_Base1_Address_Ptr = LL_State.Tex.Mem[pTex->bMem].dwPhyPtr;
                *pdwNext++ = LL_State.dwHXY_Base1_Offset0 = dwOffset;
            }
        }
        

        // Set host control enable bit if necessary
        //
        if( LL_State.HXYHostControl.HostXYEnable != 1 )
        {
            LL_State.HXYHostControl.HostXYEnable = 1;

            *pdwNext++ = write_dev_register( HOST_XY, HXY_HOST_CTRL_3D, 1 );
            *pdwNext++ = LL_State.dwHXYHostControl;
        }

        *pdwNext++ = write_register( TX_CTL0_3D, 1 );
        *pdwNext++ = LL_State.dwTxControl0 = Tx.dwTxControl0 & TX_CTL0_MASK;
    }
    else
#endif // def MCD_SUPPORTS_HOST_TEXTURES
    {
        // Texture is in the video memory, so set the location
        //
    // texture base init'd to RDRAM in LL_InitLib
    #ifdef MCD_SUPPORTS_HOST_TEXTURES
        if( ppdev->LL_State.Base0.Texture_Location != 0 )
        {
            ppdev->LL_State.Base0.Texture_Location = 0;
            *pdwNext++ = write_register( BASE0_ADDR_3D, 1 );
            *pdwNext++ = ppdev->LL_State.dwBase0;
        }
    #endif

        // Set the coordinates of the texture
        if( pRc->TxXYBase.Tex_Y_Base_Addr != pTex->wYloc ||
            pRc->TxXYBase.Tex_X_Base_Addr != pTex->wXloc )
        {
            // New location, need to reload tx_xybase_3d register and perhaps control register
            //
            *pdwNext++ = write_register( TX_CTL0_3D, 2 );
            *pdwNext++ = pRc->dwTxControl0 = Tx.dwTxControl0 & TX_CTL0_MASK;
            *pdwNext++ = (pTex->wYloc << 16) | pTex->wXloc;

            pRc->TxXYBase.Tex_Y_Base_Addr = pTex->wYloc;
            pRc->TxXYBase.Tex_X_Base_Addr = pTex->wXloc;

        }
        else
        {
            *pdwNext++ = write_register( TX_CTL0_3D, 1 );
            *pdwNext++ = pRc->dwTxControl0 = Tx.dwTxControl0 & TX_CTL0_MASK;
        }

    }

    if (control0_set)
    {
        *pdwNext++ = write_register( CONTROL0_3D, 1 );
        *pdwNext++ = pRc->dwControl0;
    }

    ppdev->LL_State.pDL->pdwNext = pdwNext;

    return(TRUE);                

}

__inline ULONG GetDisplayUniqueness(PDEV *ppdev)
{
    return (ppdev->iUniqueness);
}


#define SET_HW_CLIP_REGS(pRc,pdwNext) {                                                                         \
        *pdwNext++ = write_register( X_CLIP_3D, 2 );                                                            \
        *pdwNext++ = ((pClip->right +pRc->AdjClip.right) <<16) | (pClip->left+pRc->AdjClip.left)| 0x80008000;   \
        *pdwNext++ = ((pClip->bottom+pRc->AdjClip.bottom)<<16) | (pClip->top +pRc->AdjClip.top) | 0x80008000;   \
}


// verify MCDTextureData in client space is accessible
#define VERIFY_TEXTUREDATA_ACCESSIBLE(pTex){                                                                    \
    try {                                                                                                       \
        EngProbeForRead(pTex->pMCDTextureData, sizeof(MCDTEXTUREDATA), 4);                                      \
    } except (EXCEPTION_EXECUTE_HANDLER) {                                                                      \
        MCDBG_PRINT("!!Exception accessing MCDTextureData in client address space!!");                          \
        return FALSE;                                                                                           \
    }                                                                                                           \
}

// verify struct addressed by MCDTextureData->level in client space is accessible
#define VERIFY_TEXTURELEVEL_ACCESSIBLE(pTex){                                                                   \
    try {                                                                                                       \
        EngProbeForRead(pTex->pMCDTextureData->level, sizeof(MCDMIPMAPLEVEL), 4);                               \
    } except (EXCEPTION_EXECUTE_HANDLER) {                                                                      \
        MCDBG_PRINT("!!Exception accessing MCDTextureData->level in client address space!!");                   \
        return FALSE;                                                                                           \
    }                                                                                                           \
}

// verify struct addressed by MCDTextureData->paletteData in client space is accessible
#define VERIFY_TEXTUREPALETTE8_ACCESSIBLE(pTex){                                                                \
    try {                                                                                                       \
        EngProbeForRead(pTex->pMCDTextureData->paletteData, 256*4, 4);/* 256 bytes for 8 bit indices */         \
    } except (EXCEPTION_EXECUTE_HANDLER) {                                                                      \
        MCDBG_PRINT("!!Exception accessing MCDTextureData->paletteData in client address space!!");             \
        return FALSE;                                                                                           \
    }                                                                                                           \
}

// verify struct addressed by MCDTextureData->paletteData in client space is accessible
#define VERIFY_TEXTUREPALETTE16_ACCESSIBLE(pTex){                                                               \
    try {                                                                                                       \
        EngProbeForRead(pTex->pMCDTextureData->paletteData, 65536*4, 4);/* 16K bytes for 16 bit indices */      \
    } except (EXCEPTION_EXECUTE_HANDLER) {                                                                      \
        MCDBG_PRINT("!!Exception accessing MCDTextureData->paletteData in client address space!!");             \
        return FALSE;                                                                                           \
    }                                                                                                           \
}

#define ENGPROBE_ALIGN_BYTE     1
#define ENGPROBE_ALIGN_WORD     2
#define ENGPROBE_ALIGN_DWORD    4

// verify struct addressed by MCDTextureData->paletteData in client space is accessible
#define VERIFY_TEXELS_ACCESSIBLE(pTexels,nBytes,Align){                                                         \
    try {                                                                                                       \
        EngProbeForRead(pTexels, nBytes, Align);                                                                \
    } except (EXCEPTION_EXECUTE_HANDLER) {                                                                      \
        MCDBG_PRINT("!!Exception accessing MCDTextureData->level->pTexels in client address space!!");          \
        return FALSE;                                                                                           \
    }                                                                                                           \
}


#define _3D_ENGINE_NOT_READY_FOR_MORE 0x040   // wait for execution engine idle

#define USB_TIMEOUT_FIX(ppdev)                                                  \
{                                                                               \
  if (ppdev->dwDataStreaming)                                                    \
  {                                                                             \
    int   status;                                                               \
    volatile int wait_count=0;                                                  \
    do                                                                          \
    {                                                                           \
        status = *((volatile *)((DWORD *)(ppdev->pLgREGS) + PF_STATUS_3D));     \
        wait_count++;   /* do something to give bus a breather */               \
        wait_count++;   /* do something to give bus a breather */               \
        wait_count++;   /* do something to give bus a breather */               \
    } while(status & _3D_ENGINE_NOT_READY_FOR_MORE);                            \
  }                                                                             \
}

#endif /* _MCDUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\overlay.c ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1997, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         overlay.c
*
* DESCRIPTION:
*
* REVISION HISTORY:
*
* $Log:   //uinac/log/log/laguna/ddraw/src/overlay.c  $
* 
*    Rev 1.20   Apr 07 1998 10:48:04   frido
* PDR#11299. We should always handle the DDOVER_HIDE flag in
* UpdateSurface32, even when the device is in background mode.
* Otherwise we might end up having the overlay disabled when it is no
* longer updated.
* 
*    Rev 1.19   06 Jan 1998 14:58:22   xcong
* Passs lpDDHALData into SyncWithQueusManager().
* 
*    Rev 1.18   06 Jan 1998 11:53:16   xcong
* Change pDriverData into local lpDDHALData for multi-monitor support.
*
*    Rev 1.17   08 Dec 1997 14:43:40   BERSABE
* used in fw162b12, fixed PDR# 10991. OverFly disappeared after switch back and
* and forth to DOS full several times
* 
*    Rev 1.16.1.2   Dec 06 1997 14:45:48   bersabe
* * Fixed PDR# 10991. OverFly disappered after switch back and forth to DOS ful
* * several times. 
* 
*    Rev 1.16.1.2   06 Dec 1997 14:35:00   chaoyi #cyl1
* 
* Fixed PDR# 10991. OverFly disappered after switch back and forth to DOS full screen
* several times. 
* 
*    Rev 1.16.1.1   25 Nov 1997 16:39:32   randys
* 
* Updated VDD API values to maintain backward compatibility
* 
*    Rev 1.16.1.0   10 Nov 1997 13:44:24   randys
* 
* Updated hard coded Win32 overlay API function number 12 ----> 13
* 
*    Rev 1.16   23 Oct 1997 11:17:30   frido
* Merged file with 161 tree.
* 
*    Rev 1.11.1.0   21 Oct 1997 17:49:10   frido
* HP#75. Added call to VXD whenever we get a request to update the position
* of an overlay so the VXD knows it has been updated.
* 
*    Rev 1.15   17 Oct 1997 11:31:32   bennyn
* 
* For NT, in UpdateOverlay32 & SetOverlayPosition32, return if dwReser0
* 
*    Rev 1.14   09 Oct 1997 15:16:18   bennyn
* Removed Noel's hack in QueryOverlaySupport.
* 
*    Rev 1.13   08 Oct 1997 11:15:44   RUSSL
* Fix for NT40 build without overlay support
*
*    Rev 1.12   08 Oct 1997 10:34:28   noelv
* HAcked QueryOverlaySupport to always return FALSE for NT.
*
*    Rev 1.11   19 Sep 1997 14:33:42   bennyn
* Fixed the NT4.0 5462/64 build problem
*
*    Rev 1.10   16 Sep 1997 15:10:26   bennyn
* Modified for NT DD overlay
*
*    Rev 1.9   29 Aug 1997 16:25:28   RUSSL
* Added support for NT
*
*    Rev 1.8   09 Jul 1997 14:47:58   RUSSL
* For forward compatibility, assume future chips support overlay
*
*    Rev 1.7   27 Apr 1997 22:10:38   cjl
* Added DX5-related test code.
* Added code, wrapped by "#ifdef TEST_DX5_AGP_HBT," that forces
* overlay support off.
*
*    Rev 1.6   01 Apr 1997 09:14:36   RUSSL
* Added calls to SyncWithQueueManager in UpdateOverlay32, SetOverlayPosition32
*   & SetColorKey32
*
*    Rev 1.5   12 Mar 1997 15:18:16   RUSSL
* replaced a block of includes with include of precomp.h for
*   precompiled headers
* Added check of pDriverData->bInBackground flag in UpdateOverlay32 and
*   SetOverlayPosition32.  If this flag is set then we want to fail the
*   call because we are in fullscreen DOS.
*
*    Rev 1.4   07 Mar 1997 12:57:44   RUSSL
* Modified DDRAW_COMPAT usage
*
*    Rev 1.3   31 Jan 1997 08:51:48   RUSSL
* Added better chip checking to QueryOverlaySupport
*
*    Rev 1.2   27 Jan 1997 18:36:02   RUSSL
* Moved GetFormatInfo to surface.c
*
*    Rev 1.1   21 Jan 1997 14:37:12   RUSSL
* Added OverlayReInit and GetFormatInfo functions
*
*    Rev 1.0   15 Jan 1997 10:33:36   RUSSL
* Initial revision.
*
***************************************************************************
***************************************************************************/

/***************************************************************************
* I N C L U D E S
****************************************************************************/

#include "precomp.h"

#if defined WINNT_VER35      // WINNT_VER35
// If WinNT 3.5 skip all the source code
#elif defined (NTDRIVER_546x)
// If WinNT 4.0 and 5462/64 build skip all the source code
#elif defined(WINNT_VER40) && !defined(OVERLAY)
// if nt40 without overlay, skip all the source code
#else

#ifndef WINNT_VER40
#include "flip.h"
#include "surface.h"
#include "blt.h"
#include "overlay.h"
#endif

/***************************************************************************
* D E F I N E S
****************************************************************************/

// VW_CAP0 bits
#define VWCAP_VW_PRESENT      0x00000001

#ifdef WINNT_VER40
#define lpDDHALData     ((DRIVERDATA *)(&(ppdev->DriverData)))
#endif

/***************************************************************************
* G L O B A L   V A R I A B L E S
****************************************************************************/

#ifndef WINNT_VER40
OVERLAYTABLE  OverlayTable;
#endif

/***************************************************************************
* S T A T I C   V A R I A B L E S
****************************************************************************/

#ifndef WINNT_VER40
ASSERTFILE("overlay.c");
#endif

/***************************************************************************
*
* FUNCTION:    QueryOverlaySupport()
*
* DESCRIPTION:
*
****************************************************************************/

BOOL QueryOverlaySupport
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#else
   LPGLOBALDATA lpDDHALData, 
#endif
  DWORD dwChipType
)
{
#ifdef TEST_DX5_AGP_HBT
  lpDDHALData->fOverlaySupport = FALSE;
  return lpDDHALData->fOverlaySupport;
#endif // TEST_DX5_AGP_HBT

  // We should check the capabilities register on the chip
  // but it's busted

#ifdef WINNT_VER40
  if (CL_GD5465 > dwChipType)
    lpDDHALData->fOverlaySupport = FALSE;
  else if (CL_GD5465 == dwChipType)
    lpDDHALData->fOverlaySupport = TRUE;

#else
  if (REVID_PRE65 & lpDDHALData->bRevInfoBits)
    lpDDHALData->fOverlaySupport = FALSE;
  else if (GD5465_PCI_DEVICE_ID == dwChipType)
    lpDDHALData->fOverlaySupport = TRUE;
#endif

  else
  {
#if 1
    // assume overlay hw exists
    lpDDHALData->fOverlaySupport = TRUE;
#else
    int     i;
    PVGAR   pREG = (PVGAR)lpDDHALData->RegsAddress;

    // assume no overlay hw
    lpDDHALData->fOverlaySupport = FALSE;

    // now check caps to see if any overlay hw present
    for (i = 0; i < MAX_VIDEO_WINDOWS; i++)
    {
      if (VWCAP_VW_PRESENT & pREG->VideoWindow[i].grVW_CAP0)
        lpDDHALData->fOverlaySupport = TRUE;
    }
#endif
  }

  return lpDDHALData->fOverlaySupport;
}

/***************************************************************************
*
* FUNCTION:    OverlayInit()
*
* DESCRIPTION:
*
****************************************************************************/

VOID OverlayInit
(
#ifdef WINNT_VER40
  PDEV                  *ppdev,
  DWORD                 dwChipType,
  PDD_SURFACECALLBACKS  pSurfaceCallbacks,
  PDD_HALINFO           pDDHalInfo
#else
  DWORD                       dwChipType,
  LPDDHAL_DDSURFACECALLBACKS  pSurfaceCallbacks,
  LPDDHALINFO                 pDDHalInfo,
  LPGLOBALDATA                lpDDHALData
#endif
)
{
#ifdef WINNT_VER40
#else
  memset(&OverlayTable,0, sizeof(OVERLAYTABLE));
#endif

#ifdef WINNT_VER40
  if (! QueryOverlaySupport(ppdev,dwChipType))
#else
    if (! QueryOverlaySupport(lpDDHALData,dwChipType))
#endif
    return;

#ifdef WINNT_VER40
  // NT passes pSurfaceCallbacks as NULL from DrvGetDirectDrawInfo
  if (NULL != pSurfaceCallbacks)
#endif
  {
    // fill in overlay callbacks
    pSurfaceCallbacks->UpdateOverlay = UpdateOverlay32;
    pSurfaceCallbacks->dwFlags |= DDHAL_SURFCB32_UPDATEOVERLAY;

    pSurfaceCallbacks->SetOverlayPosition = SetOverlayPosition32;
    pSurfaceCallbacks->dwFlags |= DDHAL_SURFCB32_SETOVERLAYPOSITION;

    pSurfaceCallbacks->SetColorKey = SetColorKey32;
    pSurfaceCallbacks->dwFlags |= DDHAL_SURFCB32_SETCOLORKEY;
  }

#ifdef WINNT_VER40
  // NT passes pDDHalInfo as NULL from DrvEnableDirectDraw
  if ((NULL != pDDHalInfo) && (CL_GD5465 == dwChipType))
    Init5465Overlay(ppdev, dwChipType, pDDHalInfo, &ppdev->DriverData.OverlayTable);
#else
  if (GD5465_PCI_DEVICE_ID == dwChipType)
    Init5465Overlay(dwChipType, pDDHalInfo, &OverlayTable, lpDDHALData);
#endif
}

#ifndef WINNT_VER40
/***************************************************************************
*
* FUNCTION:    OverlayReInit()
*
* DESCRIPTION:
*
****************************************************************************/

VOID OverlayReInit
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DWORD       dwChipType,
  PDD_HALINFO pDDHalInfo
#else
  DWORD       dwChipType,
  LPDDHALINFO pDDHalInfo,
  LPGLOBALDATA lpDDHALData
#endif
)
{
#ifdef WINNT_VER40
  if (! QueryOverlaySupport(ppdev,dwChipType))
#else
    if (! QueryOverlaySupport(lpDDHALData, dwChipType))
#endif
    return;

#ifdef WINNT_VER40
#pragma message("OverlayReInit: Is this function even needed for NT?")
  if (CL_GD5465 == dwChipType)
    Init5465Info(ppdev, pDDHalInfo);
#else
  if (GD5465_PCI_DEVICE_ID == dwChipType)
    Init5465Info(pDDHalInfo, lpDDHALData);
#endif
}
#endif  // ifndef WINNT_VER40

/***************************************************************************
*
* FUNCTION:     UpdateOverlay32
*
* DESCRIPTION:
*
****************************************************************************/

DWORD __stdcall UpdateOverlay32
(
#ifdef WINNT_VER40
  PDD_UPDATEOVERLAYDATA     pInput
#else
  LPDDHAL_UPDATEOVERLAYDATA pInput
#endif
)
{
#ifdef WINNT_VER40
  PDEV*   ppdev = (PDEV *)pInput->lpDD->dhpdev;
#else
	DWORD	cbBytesReturned;
	HANDLE	vxd;
    LPGLOBALDATA lpDDHALData = GetDDHALContext(pInput->lpDD);
#endif

  DD_LOG(("UpdateOverlay32 Entry\r\n"));

#ifndef WINNT_VER40
  DBG_MESSAGE(("UpdateOverlay32 (lpInput = 0x%08lX)", pInput));

	vxd = CreateFile("\\\\.\\546X.VXD", 0, 0, 0, CREATE_NEW,
			FILE_FLAG_DELETE_ON_CLOSE, 0);
	if (vxd != INVALID_HANDLE_VALUE)
	{
                DeviceIoControl(vxd, 12, NULL, 0, NULL, 0, &cbBytesReturned, NULL);
		CloseHandle(vxd);
	}
#endif

#ifdef WINNT_VER40
//#pragma message("UpdateOverlay32: Does NT ddraw call this function while in fullscreen DOS?")
  if (pInput->lpDDSrcSurface->dwReserved1 == 0)
  {
    pInput->ddRVal = DDERR_SURFACEBUSY;
    return DDHAL_DRIVER_HANDLED;
  }
#else
  if (lpDDHALData->bInBackground
#if 1 // PDR#11299. Always handle an overlaydisable call.
  && !(pInput->dwFlags & DDOVER_HIDE)
#endif
  )
  {
//#cyl1    pInput->ddRVal = DDERR_SURFACEBUSY;
    pInput->ddRVal = DD_OK; //#cyl1	 
    return DDHAL_DRIVER_HANDLED;
  }
#endif

#ifdef WINNT_VER40
  SYNC_W_3D(ppdev);
  return ppdev->DriverData.OverlayTable.pfnUpdateOverlay(ppdev,pInput);
#else
  SyncWithQueueManager(lpDDHALData);
  return OverlayTable.pfnUpdateOverlay(pInput);
#endif
} /* UpdateOverlay32 */

/***************************************************************************
*
* FUNCTION:     SetOverlayPosition32
*
* DESCRIPTION:
*
****************************************************************************/

DWORD __stdcall SetOverlayPosition32
(
#ifdef WINNT_VER40
  PDD_SETOVERLAYPOSITIONDATA      pInput
#else
  LPDDHAL_SETOVERLAYPOSITIONDATA  pInput
#endif
)
{
#ifdef WINNT_VER40
  PDEV*   ppdev = (PDEV *)pInput->lpDD->dhpdev;
#else
    LPGLOBALDATA lpDDHALData = GetDDHALContext(pInput->lpDD);
#endif

  DD_LOG(("SetOverlayPosition32 Entry\r\n"));

#ifndef WINNT_VER40
  DBG_MESSAGE(("SetOverlayPosition32 (lpInput = 0x%08lX)", pInput));
#endif

#ifdef WINNT_VER40
//#pragma message("SetOverlayPosition32: Does NT ddraw call this function while in fullscreen DOS?")
  if (pInput->lpDDSrcSurface->dwReserved1 == 0)
  {
    pInput->ddRVal = DDERR_SURFACEBUSY;
    return DDHAL_DRIVER_HANDLED;
  }
#else
  if (lpDDHALData->bInBackground)
  {
    pInput->ddRVal = DDERR_SURFACEBUSY;
    return DDHAL_DRIVER_HANDLED;
  }
#endif

#ifdef WINNT_VER40
  SYNC_W_3D(ppdev);
  return ppdev->DriverData.OverlayTable.pfnSetOverlayPos(ppdev,pInput);
#else
  SyncWithQueueManager(lpDDHALData);
  return OverlayTable.pfnSetOverlayPos(pInput);
#endif
} /* SetOverlayPosition32 */

/***************************************************************************
*
* FUNCTION:     SetColorKey32
*
* DESCRIPTION:
*
****************************************************************************/

DWORD __stdcall SetColorKey32
(
#ifdef WINNT_VER40
  PDD_SETCOLORKEYDATA     pInput
#else
  LPDDHAL_SETCOLORKEYDATA pInput
#endif
)
{
#ifdef WINNT_VER40
  PDEV*   ppdev = (PDEV *)pInput->lpDD->dhpdev;
#else
  LPGLOBALDATA lpDDHALData = GetDDHALContext( pInput->lpDD);
#endif

  DD_LOG(("SetColorKey32 Entry\r\n"));

#ifndef WINNT_VER40
  DBG_MESSAGE(("SetColorKey32 (lpInput = 0x%08lX)", pInput));
#endif

  // make sure it's a colorkey for an overlay surface
  if ((DDCKEY_DESTOVERLAY | DDCKEY_SRCOVERLAY) & pInput->dwFlags)
  {
#ifdef WINNT_VER40
    SYNC_W_3D(ppdev);
    ppdev->DriverData.OverlayTable.pfnSetColorKey(ppdev,pInput);
#else
    SyncWithQueueManager(lpDDHALData);
    OverlayTable.pfnSetColorKey(pInput);
#endif
  }

  return DDHAL_DRIVER_NOTHANDLED;
} /* SetColorKey32 */

#endif // WINNT_VER35


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\mmcore.c ===
/******************************************************************************\
*
* $Workfile:   mmCore.c  $
*
* This file holds the new memory manager core.
*
* Copyright (c) 1997, Cirrus Logic, Inc.
* All Rights Reserved.
*
* $Log:   X:/log/laguna/powermgr/inc/MMCORE.C  $
* 
*    Rev 1.5   Dec 10 1997 13:32:18   frido
* Merged from 1.62 branch.
* 
*    Rev 1.4.1.0   Nov 07 1997 15:04:10   frido
* PDR#10912. Fixed several problems in the mmMove routine that would cause
* lock ups inside WB98.
* 
*    Rev 1.4   Oct 24 1997 10:48:28   frido
* Copied from Windows 95.
* Removed #define MEMMGR SWAT5 line (I need to update this in 95 as well).
* 
*    Rev 1.5   23 Oct 1997 09:23:42   frido
* Removed fixes from RandyS.
* Merged fixed memory manager from 161 tree.
* 
*    Rev 1.3.1.0   15 Oct 1997 12:39:32   frido
* Added roll back functions for when we run out of handles.
* Added support for these roll back functions in mmAddRectToList.
* Changed the mmRemoveRectFromList algorithm.
* Added checks for the Windows 95 core to return NULL in allocations when
* there are no more handles.
* 
*    Rev 1.3   26 Sep 1997 16:18:00   FRIDO
* PDR #10617.  During mmFree the node should be marked NODE_FREE and during
* the first loop of mmAlloc the node status should be turned back to NOD_USED
* 
*    Rev 1.2   14 Aug 1997 16:54:16   FRIDO
* The last changes dropped the score a little, walking through the list
* of used nodes was taken too much time.  So now I have added a new field
* in the DEVMEM structure which holds the current state of the node.
* 
*    Rev 1.1   14 Aug 1997 14:12:12   FRIDO
* Added an extra check inside mmFree to see if the node to be freed indeed
* lives in the used list.
* 
*    Rev 1.0   07 Aug 1997 17:38:04   FRIDO
* Initial revision.
* SWAT: 
* SWAT:    Rev 1.10   06 Aug 1997 21:30:46   frido
* SWAT: Changed mmAllocGrid a little again, it will optimize allocation a bit.
* SWAT: 
* SWAT:    Rev 1.9   05 Aug 1997 23:07:50   frido
* SWAT: Changed grid allocation scheme a little to gain more memory.
* SWAT: 
* SWAT:    Rev 1.8   30 Jul 1997 17:38:00   frido
* SWAT: Added initialization of first rectangle in mmGetLargest.
* SWAT: 
* SWAT:    Rev 1.7   30 Jul 1997 14:26:08   frido
* SWAT: Fixed a counting problem in mmAllocGrid.
* SWAT: 
* SWAT:    Rev 1.6   17 Jun 1997 17:12:32   frido
* SWAT: Combined Windows 95 and NT versions together.
* SWAT: 
* SWAT:    Rev 1.5   16 Jun 1997 23:20:58   frido
* SWAT: Removed byte to pixel conversion.
* SWAT: More Windows 95 / NT combined code.
* SWAT: 
* SWAT:    Rev 1.4   27 May 1997 16:32:12   frido
* SWAT: Changed debug code.
* SWAT: Fixed a bug in non-tile-optimized move code.
* SWAT: 
* SWAT:    Rev 1.3   16 May 1997 23:06:56   frido
* SWAT: Renamed TILE_ALIGNMENT into MEMMGR_TILES.
* SWAT: 
* SWAT:    Rev 1.2   07 May 1997 15:38:10   frido
* SWAT: Fixed alignment code in 24-bpp.
* SWAT: 
* SWAT:    Rev 1.1   06 May 1997 17:57:28   frido
* SWAT: Added tile alignment.
* SWAT: 
* SWAT:    Rev 1.0   03 May 1997 14:34:08   frido
* SWAT: New memory manager core.
*
\******************************************************************************/
#include "PreComp.h"

#ifdef WIN95 /* Windows 95 */
	#pragma warning(disable : 4001 4209 4201)
	#include "SWAT.inc"
	#include "DDMini.h"
	#include "DMM.h"
	#include "mmCore.h"
	#include <string.h>

#else /* Windows NT */
	#include "SWAT.h"
#endif

#if MEMMGR

/******************************************************************************\
* BOOL FAR mmInit(PIIMEMMGR pmm)
*
* PURPOSE:	Initialize the MEMMGR structure.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*
* RETURNS:	TRUE if the initialization was successful, FALSE if there was an
*			error.
\******************************************************************************/
BOOL FAR mmInit(PIIMEMMGR pmm)
{
	// Initialize the list of available nodes.
	pmm->phArray = NULL;
	pmm->pdmHandles = NULL;
	if (!mmAllocArray(pmm))
	{
		return FALSE;
	}

	// Zero the heaps.
	pmm->pdmUsed = NULL;
	pmm->pdmFree = NULL;
	pmm->pdmHeap = NULL;

	return TRUE;
}

/******************************************************************************\
* BOOL mmAllocArray(PIIMEMMGR pmm)
*
* PURPOSE:	Allocdate an array of nodes and initialize the array.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*
* RETURNS:	TRUE if successful, FALSE if there is an error.
\******************************************************************************/
BOOL mmAllocArray(PIIMEMMGR pmm)
{
	PHANDLES	phArray;
	UINT		i;

	#ifdef WIN95 /* Windows 95 */
	{
		static HANDLES mmHandleArray;

		// We only support one static array under Windows 95.
		if (pmm->phArray != NULL)
		{
			return FALSE;
		}

		// Zero the entire array.
		memset(&mmHandleArray, 0, sizeof(mmHandleArray));

		// Store the pointer to the array.
		pmm->phArray = phArray = &mmHandleArray;
	}
	#else /* Windows NT */
	{
		// Allocate a new array.
		#ifdef WINNT_VER40
		{
			phArray = (PHANDLES) MEM_ALLOC(FL_ZERO_MEMORY, sizeof(HANDLES),
					ALLOC_TAG);
		}
		#else
		{
			phArray = (PHANDLES) MEM_ALLOC(LPTR, sizeof(HANDLES));
		}
		#endif

        if (phArray==NULL)  // v-normmi: need check for alloc failure
        {
            return FALSE;
        }

		// Link the allocated array into the list of arrays.
		phArray->pNext = pmm->phArray;
		pmm->phArray = phArray;
	}
	#endif

	// Copy all nodes into the list of free handles.
	for (i = 0; i < MM_NUM_HANDLES; i++)
	{
		mmFreeNode(pmm, &phArray->dmArray[i]);
	}

	// Return success.
	return TRUE;
}

/******************************************************************************\
* PDEVMEM mmAllocNode(PIIMEMMGR pmm)
*
* PURPOSE:	Allocate a node from the list of available nodes.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*
* RETURNS:	A pointer to the node or NULL is there are no more nodes available.
\******************************************************************************/
PDEVMEM mmAllocNode(PIIMEMMGR pmm)
{
	PDEVMEM	pdm;

	// Are we out of handles?
	if (pmm->pdmHandles == NULL)
	{
		// Yep, allocate a new array of handles.
		if (!mmAllocArray(pmm))
		{
			return NULL;
		}
	}

	// Remove one handle fromn the list of handles.
	pdm = pmm->pdmHandles;
	pmm->pdmHandles = pdm->next;
	pdm->mmFlags = NODE_FREE;
	return pdm;
}

/******************************************************************************\
* void mmFreeNode(PIIMEMMGR pmm, PDEVMEM pdm)
*
* PURPOSE:	Insert a node back into the list of available nodes.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			pdm		Pointer to node.
*
* RETURNS:	Nothing.
\******************************************************************************/
void mmFreeNode(PIIMEMMGR pmm, PDEVMEM pdm)
{
	pdm->next = pmm->pdmHandles;
	pmm->pdmHandles = pdm;
	pdm->mmFlags = NODE_AVAILABLE;
}

/******************************************************************************\
* PDEVMEM mmAlloc(PIIMEMMGR pmm, GXPOINT size, GXPOINT align)
*
* PURPOSE:	Allocate a node in off-screen memory which fits the requsted size
*			and alignment.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			size	Requested size.
*			align	Requested alignment.
*
* RETURNS:	A pointer to a memory node which fits the requested size and
*			alignment or NULL is there is not enough memory.
\******************************************************************************/
PDEVMEM mmAlloc(PIIMEMMGR pmm, GXPOINT size, GXPOINT align)
{
	PDEVMEM pdm;
	GXRECT	rect;

	// Walk through all nodes in the free list for an exact match.
	for (pdm = pmm->pdmFree; pdm != NULL; pdm = pdm->next)
	{
		if (   (pdm->cbSize.pt.x == size.pt.x)
			&& (pdm->cbSize.pt.y == size.pt.y)
			&& (pdm->cbAlign.pt.x == align.pt.x)
			&& (pdm->cbAlign.pt.y == align.pt.y)
		)
		{
			mmTRACE(("mmAlloc: %08X pos=%u,%u size=%u,%u align=%u,%u\r\n", pdm,
					pdm->cbAddr.pt.x, pdm->cbAddr.pt.y, size.pt.x, size.pt.y,
					align.pt.x, align.pt.y));

			// We have a match, move the node to the used list.
			mmRemoveFromList(&pmm->pdmFree, pdm);
			mmInsertInList(&pmm->pdmUsed, pdm);
			pdm->mmFlags = NODE_USED;
			return pdm;
		}
	}

	// Pack the list of free nodes.
	mmPack(pmm);

	#ifdef WIN95
	{
		// We need a free handle for Windows 95.
		if (pmm->pdmHandles == NULL)
		{
			return(NULL);
		}
	}
	#endif

	// Find a rectangle in the heap.
	if (!mmFindRect(pmm, &rect, size, align))
	{
		return NULL;
	}

	// Remove the rectangle from the heap.
	pdm = mmRemoveRectFromList(pmm, &pmm->pdmHeap, &rect, SINGLE_NODE);
	if (pdm != NULL)
	{
		mmTRACE(("mmAlloc: %08X pos=%u,%u size=%u,%u align=%u,%u\r\n", pdm,
				pdm->cbAddr.pt.x, pdm->cbAddr.pt.y, size.pt.x, size.pt.y,
				align.pt.x, align.pt.y));

		// Insert the node into the used list.
		mmInsertInList(&pmm->pdmUsed, pdm);
		mmDebugList(pmm->pdmUsed, FALSE);

		// Store alignment.
		pdm->cbAlign = align;
		pdm->mmFlags = NODE_USED;
	}

	// Return the node.
	return pdm;
}

/******************************************************************************\
* PDEVMEM mmAllocGrid(PIIMEMMGR pmm, GXPOINT size, GXPOINT align, UINT count)
*
* PURPOSE:	Allocate a node which holds a specific number of cells.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			size	The size of a single cell.
*			align	Requested alignment.
*			count	The number of cells.
*
* RETURNS:	A pointer to a memory node which fits the requested size and
*			alignment or NULL is there is not enough memory.
\******************************************************************************/
PDEVMEM mmAllocGrid(PIIMEMMGR pmm, GXPOINT size, GXPOINT align, UINT count)
{
	PDEVMEM	pdm;
	ULONG	scrap, scrapBest, area;
	GXRECT	rect, rectBest;
	UINT	countX, countY;

	// Pack the list of free nodes.
	mmPack(pmm);

	#ifdef WIN95
	{
		// We need a free handle for Windows 95.
		if (pmm->pdmHandles == NULL)
		{
			return(NULL);
		}
	}
	#endif

	// Calculate the requested area.
	area = MUL(size.pt.x * size.pt.y, count);
	scrapBest = (ULONG) -1;

	for (pdm = pmm->pdmHeap; pdm != NULL; pdm = pdm->next)
	{
		if (pdm->cbSize.pt.x >= size.pt.x)
		{
			// Get the largest rectangle for this node.
			rect.left = pdm->cbAddr.pt.x;
			rect.top = pdm->cbAddr.pt.y;
			rect.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
			rect.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
			if (mmGetLargest(pdm, &rect, align) >= area)
			{
				// Calculate the dimension of the grid.
				countX = min((rect.right - rect.left) / size.pt.x, count);
				if (countX == 0)
				{
					continue;
				}
				countY = (count + countX - 1) / countX;
				if (   (countY == 0)
					|| (rect.top + countY * size.pt.y > rect.bottom)
					)
				{
					continue;
				}

				// Calculate the amount of scrap.
				scrap = MUL(countX * countY - count, size.pt.x * size.pt.y)
													// remaining cells
					  + MUL(pdm->cbSize.pt.x - countX * size.pt.x,
					  		countY * size.pt.y)		// space at right
					  + MUL(rect.top - pdm->cbAddr.pt.y, pdm->cbSize.pt.x);
					  								// space at top

				if (   (scrap < scrapBest)
					|| (scrap == scrapBest && rect.area < rectBest.area)
				)
				{
					// Use this rectangle.
					scrapBest = scrap;
					rectBest.left = rect.left;
					rectBest.top = rect.top;
					rectBest.right = rect.left + countX * size.pt.x;
					rectBest.bottom = rect.top + countY * size.pt.y;
					rectBest.area = rect.area;

					if (   (pdm->next == NULL)
						&& (rectBest.right - rectBest.left == pmm->mmHeapWidth)
					)
					{
						rectBest.top = rect.bottom - countY * size.pt.y;
						rectBest.top -= rectBest.top % align.pt.y;
						rectBest.bottom = rectBest.top + countY * size.pt.y;
					}
				}
			}
		}
	}

	if (scrapBest == (ULONG) -1)
	{
		// We don't have any rectangle that fits.
		return NULL;
	}

	// Remove the rectangle from the heap.
	pdm = mmRemoveRectFromList(pmm, &pmm->pdmHeap, &rectBest, SINGLE_NODE);
	if (pdm != NULL)
	{
		mmTRACE(("mmAllocGrid: %08X pos=%u,%u size=%u,%u align=%u,%u "
				"count=%u\r\n", pdm, pdm->cbAddr.pt.x, pdm->cbAddr.pt.y,
				size.pt.x, size.pt.y, align.pt.x, align.pt.y, count));

		// Insert the node into the used list.
		mmInsertInList(&pmm->pdmUsed, pdm);

		// Store alignment.
		pdm->cbAlign = align;
		pdm->mmFlags = NODE_USED;
	}

	// Return the node.
	return pdm;
}

/******************************************************************************\
* PDEVMEM mmAllocLargest(PIIMEMMGR pmm, GXPOINT align)
*
* PURPOSE:	Allocate the largest node in off-screen memory which fits the
*			requsted alignment.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			align	Requested alignment.
*
* RETURNS:	A pointer to a memory node which fits the requested alignment or
*			NULL is there is not enough memory.
\******************************************************************************/
PDEVMEM mmAllocLargest(PIIMEMMGR pmm, GXPOINT align)
{
	PDEVMEM pdm;
	GXRECT	rect, rectFind;

	// Pack the list of free nodes.
	mmPack(pmm);

	#ifdef WIN95
	{
		// We need a free handle for Windows 95.
		if (pmm->pdmHandles == NULL)
		{
			return(NULL);
		}
	}
	#endif

	// Zero the largest area.
	rect.area = 0;

	// Walk through all nodes in the heap.
	for (pdm = pmm->pdmHeap; pdm != NULL; pdm = pdm->next)
	{
		rectFind.left = pdm->cbAddr.pt.x;
		rectFind.top = pdm->cbAddr.pt.y;
		rectFind.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
		rectFind.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
		if (mmGetLargest(pdm, &rectFind, align) > rect.area)
		{
			// Use the larger rectangle.
			rect = rectFind;
		}
	}

	// Test if we have a valid rectangle.
	if (rect.area == 0)
	{
		return NULL;
	}

	// Remove the rectangle from the heap.
	pdm = mmRemoveRectFromList(pmm, &pmm->pdmHeap, &rect, SINGLE_NODE);
	if (pdm != NULL)
	{
		mmTRACE(("mmAllocLargest: %08X pos=%u,%u size=%u,%u align=%u,%u\r\n",
				pdm, pdm->cbAddr.pt.x, pdm->cbAddr.pt.y, pdm->cbSize.pt.x,
				pdm->cbSize.pt.y, align.pt.x, align.pt.y));

		// Insert the node into the used list.
		mmInsertInList(&pmm->pdmUsed, pdm);

		// Store alignment.
		pdm->cbAlign = align;
		pdm->mmFlags = NODE_USED;
	}

	// Return the node.
	return pdm;
}

/******************************************************************************\
* void mmFree(PIIMEMMGR pmm, PDEVMEM pdm)
*
* PURPOSE:	Free an offscreen memory node.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			pdm		Pointer to the node.
*
* RETURNS:	Nothing.
\******************************************************************************/
void mmFree(PIIMEMMGR pmm, PDEVMEM pdm)
{
	// The node must not be NULL and must be in use.
	if (pdm == NULL || pdm->mmFlags != NODE_USED)
	{
		return;
	}

	mmTRACE(("mmFree: %08X\r\n", pdm));

	// Remove the node from the used list.
	mmRemoveFromList(&pmm->pdmUsed, pdm);

	// Insert the node into the free list.
	mmInsertInList(&pmm->pdmFree, pdm);
	pdm->mmFlags = NODE_FREE;
}

/******************************************************************************\
* void mmPack(PIIMEMMGR pmm)
*
* PURPOSE:	Insert all free nodes into am off-screen memory heap.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*
* RETURNS:	Nothing.
\******************************************************************************/
void mmPack(PIIMEMMGR pmm)
{
	PDEVMEM pdm, pdmNext;
	GXRECT	rect;

	if (pmm->pdmFree == NULL)
	{
		// The free list is empty.
		return;
	}

	#if DEBUG_HEAP
	{
		if (pmm->mmDebugHeaps)
		{
			mmDebug("\nmmPack:\r\n");
			mmDumpList(pmm->pdmFree, "Free:\r\n");
			mmDumpList(pmm->pdmHeap, "Before:\r\n");
		}
	}
	#endif

	// Walk through all nodes in the free list.
	for (pdm = pmm->pdmFree; pdm != NULL; pdm = pdmNext)
	{
		// Store pointer to next node.
		pdmNext = pdm->next;

		// Add the node to the heap.
		rect.left = pdm->cbAddr.pt.x;
		rect.top = pdm->cbAddr.pt.y;
		rect.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
		rect.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
		if (mmAddRectToList(pmm, &pmm->pdmHeap, &rect, FALSE))
		{
			// Remove the node from the free list.
			mmRemoveFromList(&pmm->pdmFree, pdm);
			mmFreeNode(pmm, pdm);
		}
		mmDebugList(pmm->pdmHeap, TRUE);
	}

	// Combine all nodes equal in size.
	mmCombine(pmm, pmm->pdmHeap);

	#if DEBUG_HEAP
	{
		if (!mmDebugList(pmm->pdmHeap, TRUE) && pmm->mmDebugHeaps)
		{
			mmDumpList(pmm->pdmHeap, "Free:\r\n");
			mmDumpList(pmm->pdmHeap, "After:\r\n");
		}
	}
	#endif
}

/******************************************************************************\
* PDEVMEM mmMove(PIIMEMMGR pmm, GXPOINT size, GXPOINT align, FNMMCOPY fnCopy)
*
* PURPOSE:	Move other nodes out of the way to make room for the requested node.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			size	Requested size.
*			align	Requested alignment.
*			fcCopy	Pointer to callback function to move a node.
*
* RETURNS:	A pointer to a memory node which fits the requested size and
*			alignment or NULL is there is not enough memory.
\******************************************************************************/
PDEVMEM mmMove(PIIMEMMGR pmm, GXPOINT size, GXPOINT align, FNMMCOPY fnCopy)
{
	PDEVMEM	pdm, pdmList, pdmNext, pdmNew;
	GXRECT	rect, rectFind;
	BOOL	fHostified = FALSE;

	// If we don't have a copy routine, return NULL.
	if (fnCopy == NULL)
	{
		return NULL;
	}

	// Pack all free nodes.
	mmPack(pmm);

	#ifdef WIN95
	{
		// We need a free handle for Windows 95.
		if (pmm->pdmHandles == NULL)
		{
			return(NULL);
		}
	}
	#endif

	// Zero the largest area.
	rect.area = 0;

	// Walk through all nodes in the heap.
	for (pdm = pmm->pdmHeap; pdm != NULL; pdm = pdm->next)
	{
		rectFind.left = pdm->cbAddr.pt.x;
		rectFind.top = pdm->cbAddr.pt.y;
		rectFind.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
		rectFind.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
		if (mmGetLargest(pdm, &rectFind, align) > rect.area)
		{
			// Use the larger rectangle.
			rect = rectFind;
		}
	}

	// If rectangle is too small on all sides, reject the move.
	if (   (rect.right - rect.left < size.pt.x)
		&& (rect.bottom - rect.top < size.pt.y)
	)
	{
		return NULL;
	}

	// Extent the largest rectangle to accomodate the requested size.
	if (rect.right - rect.left >= size.pt.x)
	{
		#if TILE_ALIGNMENT
		{
			rect.left = mmAlignX(pmm, rect.right - size.pt.x, size.pt.x,
					align.pt.x, TRUE);
		}
		#else
		{
			rect.left = rect.right - size.pt.x;
			rect.left -= rect.left % align.pt.x;
		}
		#endif
		rect.right = rect.left + size.pt.x;
	}
	else
	{
		rect.right = rect.left + size.pt.x;
		if (rect.right > pmm->mmHeapWidth)
		{
			#if TILE_ALIGNMENT
			{
				rect.left = mmAlignX(pmm, pmm->mmHeapWidth - size.pt.x,
						size.pt.x, align.pt.x, TRUE);
			}
			#else
			{
				rect.left = pmm->mmHeapWidth - size.pt.x;
				rect.left -= rect.left % align.pt.x;
			}
			#endif
			rect.right = rect.left + size.pt.x;
		}
	}

	if (rect.bottom - rect.top >= size.pt.y)
	{
		rect.top = rect.bottom - size.pt.y;
		rect.top -= rect.top % align.pt.y;
		rect.bottom = rect.top + size.pt.y;
	}
	else
	{
		if (rect.top < size.pt.y - (rect.bottom - rect.top))
		{
			// Not enough room on top to extent.
			return NULL;
		}
		rect.top = rect.bottom - size.pt.y;
		rect.top -= rect.top % align.pt.y;
		rect.bottom = rect.top + size.pt.y;
	}

	// First allocate as much free space as possible.
	pdmList = mmRemoveRectFromList(pmm, &pmm->pdmHeap, &rect, MULTIPLE_NODES);
	if (pdmList == NULL)
	{
		return(NULL);
	}

	// Walk the list of used nodes to find overlapping nodes.
	for (pdm = pmm->pdmUsed; pdm != NULL; pdm = pdmNext)
	{
		pdmNext = pdm->next;

		// Does the node overlap?
		if (   (pdm->cbAddr.pt.x < rect.right)
			&& (pdm->cbAddr.pt.y < rect.bottom)
			&& (pdm->cbAddr.pt.x + pdm->cbSize.pt.x > rect.left)
			&& (pdm->cbAddr.pt.y + pdm->cbSize.pt.y > rect.top)
		)
		{
			// Can this node be moved?
			if (!MM_MOVEABLE(pdm))
			{
				break;
			}

			// Allocate a new position for this node.
			pdmNew = mmAlloc(pmm, pdm->cbSize, pdm->cbAlign);
			if (pdmNew == NULL)
			{
				if (   !MM_HOSTIFYABLE(pdm)
					|| (MUL(pdm->cbSize.pt.x, pdm->cbSize.pt.y) > rect.area)
				)
				{
					break;
				}

				mmTRACE(("mmHostified: %08X\r\n", pdm));

				// Hostify the node.
				MM_HOSTIFY(pdm);
				fHostified = TRUE;
			}
			else
			{
				mmTRACE(("mmCopied: %08X to %08X pos=%u,%u\r\n", pdm, pdmNew,
						pdmNew->cbAddr.pt.x, pdmNew->cbAddr.pt.y));

				// Move the node.
				fnCopy(pdmNew, pdm);
			}

			// Free the old node.
			mmFree(pmm, pdm);

			// Add the rectangle to the list of allocated nodes.
			pdmNew = mmRemoveRectFromList(pmm, &pmm->pdmHeap, &rect,
					MULTIPLE_NODES);
			for (pdm = pdmNew; pdm != NULL; pdm = pdmNew)
			{
				pdmNew = pdm->next;
				rectFind.left = pdm->cbAddr.pt.x;
				rectFind.top = pdm->cbAddr.pt.y;
				rectFind.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
				rectFind.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
				if (mmAddRectToList(pmm, &pdmList, &rectFind, FALSE))
				{
					// Added, free the node.
					mmFreeNode(pmm, pdm);
				}
				else
				{
					// Not added, add to free list.
					mmInsertInList(&pmm->pdmFree, pdm);
				}
			}
		}
	}
	if (pdmList == NULL)
	{
		return(NULL);
	}

	// Combine all equal sized nodes together.
	mmCombine(pmm, pdmList);
	
	#if DEBUG_HEAP
	{
		if (pmm->mmDebugHeaps)
		{
			mmDumpList(pdmList, "\nmmMove:\r\n");
		}
	}
	#endif

	// If we still have a list of nodes, there must be not enough room.
	if (   (pdmList->next != NULL)
		|| (pdmList->cbSize.pt.x < size.pt.x)
		|| (pdmList->cbSize.pt.y < size.pt.y)
		|| (fHostified)
	)
	{
		// Move all allocated nodes to the free list.
		for (pdm = pdmList; pdm != NULL; pdm = pdmNext)
		{
			pdmNext = pdm->next;
			mmRemoveFromList(&pdmList, pdm);
			mmInsertInList(&pmm->pdmFree, pdm);
		}
	}
	else
	{
		mmTRACE(("mmMove: %08X pos=%u,%u size=%u,%u align=%u,%u\r\n", pdm,
				pdm->cbAddr.pt.x, pdm->cbAddr.pt.y, size.pt.x, size.pt.y,
				align.pt.x, align.pt.y));

		// Insert the node into the used list.
		mmInsertInList(&pmm->pdmUsed, pdmList);

		// Store alignment.
		pdmList->cbAlign = align;
		pdmList->mmFlags = NODE_USED;
	}

	return pdmList;
}

/******************************************************************************\
* void mmInsertInList(PDEVMEM FAR* pdmRoot, PDEVMEM pdm)
*
* PURPOSE:	Insert a node into a list.
*
* ON ENTRY:	pdmRoot	Address of the pointer to the root of the list.
*			pdm		Pointer to the node.
*
* RETURNS:	Nothing.
\******************************************************************************/
void mmInsertInList(PDEVMEM FAR* pdmRoot, PDEVMEM pdm)
{
	pdm->next = *pdmRoot;
	*pdmRoot = pdm;

	pdm->prev = NULL;
	if (pdm->next != NULL)
	{
		pdm->next->prev = pdm;
	}
}

/******************************************************************************\
* void mmRemoveFromList(PDEVMEM FAR* pdmRoot, PDEVMEM pdm)
*
* PURPOSE:	Remove a node from a list.
*
* ON ENTRY:	pdmRoot	Address of the pointer to the root of the list.
*			pdm		Pointer to the node.
*
* RETURNS:	Nothing.
\******************************************************************************/
void mmRemoveFromList(PDEVMEM FAR* pdmRoot, PDEVMEM pdm)
{
	if (pdm->prev == NULL)
	{
		*pdmRoot = pdm->next;
	}
	else
	{
		pdm->prev->next = pdm->next;
	}

	if (pdm->next != NULL)
	{
		pdm->next->prev = pdm->prev;
	}
}

/******************************************************************************\
* BOOL FAR far_mmAddRectToList(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot,
*							   LPGXRECT lpRect)
*
* PURPOSE:	Add a rectangle to an off-screen memory list.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			pdmRoot	Address of the pointer to the root of the list.
*			lpRect	Pointer to rectangle to add to te list.
*
* RETURNS:	TRUE if the rectangle has been completely added to the list or FALSE
*			if lpRect holds the coordinates of the rectangle which could not be
*			added to the list.
\******************************************************************************/
BOOL FAR far_mmAddRectToList(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot,
							 LPGXRECT lpRect)
{
	return mmAddRectToList(pmm, pdmRoot, lpRect, FALSE);
}

/******************************************************************************\
* void mmRollBackAdd(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot, LPGXRECT lpRect,
*					 LPGXRECT rectList, UINT nCount)
*
* PURPOSE:	Roll back the added rectangles.
*
* ON ENTRY:	pmm			Pointer to MEMMGR structure.
*			pdmRoot		Address of the pointer to the root of the list.
*			lpRect		Pointer to original rectangle to add to the list.
*			rectList	List of rectangles to roll back.
*			nCount		Number of rectangles in the list to roll back.
*
* RETURNS:	Nothing.
\******************************************************************************/
void mmRollBackAdd(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot, LPGXRECT lpRect,
				   LPGXRECT rectList, UINT nCount)
{
	GXRECT rect;
	
	while (nCount-- > 0)
	{
		if (   rectList[nCount].left >= rectList[nCount].right
			|| rectList[nCount].top >= rectList[nCount].bottom )
		{
			continue;
		}
		
		if (rectList[nCount].top < lpRect->top)
		{
			rect.left = rectList[nCount].left;
			rect.top = rectList[nCount].top;
			rect.right =  rectList[nCount].right;
			rect.bottom = lpRect->top;
			rectList[nCount].top = lpRect->top;
			if (!mmAddRectToList(pmm, pdmRoot, &rect, TRUE))
			{
				mmRollBackAdd(pmm, pdmRoot, lpRect, rectList, ++nCount);
				if (!mmAddRectToList(pmm, pdmRoot, &rect, TRUE))
				{
					mmASSERT(1, ("mmRollBackAdd failed\r\n"));
				}
				continue;
			}
			
			if (rectList[nCount].top >= rectList[nCount].bottom)
			{
				continue;
			}
		}
		
		if (rectList[nCount].bottom > lpRect->bottom)
		{
			rect.left = rectList[nCount].left;
			rect.top = lpRect->bottom;
			rect.right =  rectList[nCount].right;
			rect.bottom = rectList[nCount].bottom;
			rectList[nCount].bottom = lpRect->bottom;
			if (!mmAddRectToList(pmm, pdmRoot, &rect, TRUE))
			{
				mmRollBackAdd(pmm, pdmRoot, lpRect, rectList, ++nCount);
				if (!mmAddRectToList(pmm, pdmRoot, &rect, TRUE))
				{
					mmASSERT(1, ("mmRollBackAdd failed\r\n"));
				}
				continue;
			}
			
			if (rectList[nCount].top >= rectList[nCount].bottom)
			{
				continue;
			}
		}
		
		if (rectList[nCount].left < lpRect->left)
		{
			rect.left = rectList[nCount].left;
			rect.top = rectList[nCount].top;
			rect.right = lpRect->left;
			rect.bottom = rectList[nCount].bottom;
			rectList[nCount].left = lpRect->left;
			if (!mmAddRectToList(pmm, pdmRoot, &rect, TRUE))
			{
				mmRollBackAdd(pmm, pdmRoot, lpRect, rectList, ++nCount);
				if (!mmAddRectToList(pmm, pdmRoot, &rect, TRUE))
				{
					mmASSERT(1, ("mmRollBackAdd failed\r\n"));
				}
				continue;
			}
			
			if (rectList[nCount].left >= rectList[nCount].right)
			{
				continue;
			}
		}
		
		if (rectList[nCount].right > lpRect->right)
		{
			rect.left = lpRect->right;
			rect.top = rectList[nCount].top;
			rect.right = rectList[nCount].right;
			rect.bottom = rectList[nCount].bottom;
			rectList[nCount].right = lpRect->right;
			if (!mmAddRectToList(pmm, pdmRoot, &rect, TRUE))
			{
				mmRollBackAdd(pmm, pdmRoot, lpRect, rectList, ++nCount);
				if (!mmAddRectToList(pmm, pdmRoot, &rect, TRUE))
				{
					mmASSERT(1, ("mmRollBackAdd failed\r\n"));
				}
				continue;
			}
			
			if (rectList[nCount].left >= rectList[nCount].right)
			{
				continue;
			}
		}
	}
}

/******************************************************************************\
* BOOL mmAddRectToList(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot, LPGXRECT lpRect,
*					   BOOL fRollBack)
*
* PURPOSE:	Add a rectangle to an off-screen memory list.
*
* ON ENTRY:	pmm			Pointer to MEMMGR structure.
*			pdmRoot		Address of the pointer to the root of the list.
*			lpRect		Pointer to rectangle to add to te list.
*			fRollBack	True if this called from a roll back routine.
*
* RETURNS:	TRUE if the rectangle has been completely added to the list or FALSE
*			if lpRect holds the coordinates of the rectangle which could not be
*			added to the list.
\******************************************************************************/
BOOL mmAddRectToList(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot, LPGXRECT lpRect,
					 BOOL fRollBack)
{
	PDEVMEM	pdm, pdmNext, pdmNew;
	int		n = 0;
	GXRECT	rectList[10];
	UINT	left, top, right, bottom;
	UINT	pdmLeft, pdmTop, pdmRight, pdmBottom;
	UINT	nextLeft = 0, nextTop = 0, nextRight = 0, nextBottom = 0;

	#define ADDRECT(l, t, r, b)		\
	{								\
		rectList[n].left = l;		\
		rectList[n].top = t;		\
		rectList[n].right = r;		\
		rectList[n].bottom = b;		\
		n++;						\
	}

	// Test if there is no list yet.
	if (*pdmRoot == NULL)
	{
		// Allocate a new node.
		pdm = mmAllocNode(pmm);
		if (pdm == NULL)
		{
			return FALSE;
		}

		// Insert the node into the list.
		mmInsertInList(pdmRoot, pdm);

		// Set the node coordinates.
		pdm->cbAddr.pt.x = lpRect->left;
		pdm->cbAddr.pt.y = lpRect->top;
		pdm->cbSize.pt.x = lpRect->right - lpRect->left;
		pdm->cbSize.pt.y = lpRect->bottom - lpRect->top;
		return TRUE;
	}

	// Copy the rectangle coordinates.
	rectList[n++] = *lpRect;

	// Loop until all rectangles done.
	while (n-- > 0)
	{
		// Get coordinates of rectangle.
		left = rectList[n].left;
		top = rectList[n].top;
		right = rectList[n].right;
		bottom = rectList[n].bottom;

		// Walk the heap.
		for (pdm = *pdmRoot; pdm != NULL; pdm = pdm->next)
		{
			// Get coordinates of current node.
			pdmLeft = pdm->cbAddr.pt.x;
			pdmTop = pdm->cbAddr.pt.y;
			pdmRight = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
			pdmBottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;

			if (pdmTop < top && pdmBottom > top && pdmRight == left)
			{
				if (pdmBottom < bottom)
				{
					//             
					//                   pdm 
					//  pdm       
					//            >     rct    
					//  rct       
					//                         add 
					//                   
					mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
					ADDRECT(left, pdmBottom, right, bottom);
					pdm->cbSize.pt.y = top - pdmTop;
					left = pdmLeft;
					bottom = pdmBottom;
				}
				else if (pdmBottom > bottom)
				{
					//             
					//                   pdm 
					//            
					//  pdm  rct  >     rct    
					//            
					//                   add 
					//             
					mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
					ADDRECT(pdmLeft, bottom, pdmRight, pdmBottom);
					pdm->cbSize.pt.y = top - pdmTop;
					left = pdmLeft;
				}
				else // if (pdmBottom == bottom)
				{
					//             
					//                   pdm 
					//  pdm  > 
					//       rct           rct    
					//       
					pdm->cbSize.pt.y = top - pdmTop;
					left = pdmLeft;
				}
			}

			else if (pdmTop < top && pdmBottom > top && pdmLeft == right)
			{
				if (pdmBottom < bottom)
				{
					//                   
					//                         pdm 
					//  pdm       
					//            >     rct    
					//  rct       
					//                   add 
					//             
					mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
					ADDRECT(left, pdmBottom, right, bottom);
					pdm->cbSize.pt.y = top - pdmTop;
					right = pdmRight;
					bottom = pdmBottom;
				}
				else if (pdmBottom > bottom)
				{
					//                   
					//                         pdm 
					//            
					//  rct  pdm  >     rct    
					//            
					//                         add 
					//                   
					mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
					ADDRECT(pdmLeft, bottom, pdmRight, pdmBottom);
					pdm->cbSize.pt.y = top - pdmTop;
					right = pdmRight;
				}
				else // if (pdmBottom == bottom)
				{
					//                   
					//                         pdm 
					//  pdm  > 
					//  rct                rct    
					//       
					pdm->cbSize.pt.y = top - pdmTop;
					right = pdmRight;
				}
			}

			else if (pdmTop == top && pdmRight == left)
			{
				// Find the next rectangle at the right side.
				for (pdmNext = pdm->next; pdmNext != NULL;
					 pdmNext = pdmNext->next
				)
				{
					nextLeft = pdmNext->cbAddr.pt.x;
					nextTop = pdmNext->cbAddr.pt.y;
					nextRight = pdmNext->cbAddr.pt.x + pdmNext->cbSize.pt.x;
					nextBottom = pdmNext->cbAddr.pt.y + pdmNext->cbSize.pt.y;

					if (nextLeft == right && nextTop < bottom)
					{
						break;
					}
					if (nextTop >= bottom)
					{
						pdmNext = NULL;
						break;
					}
				}

				if (pdmNext == NULL || nextTop >= pdmBottom)
				{
					if (pdmBottom < bottom)
					{
						//       
						//  pdm                pdm    
						//  rct  > 
						//                         rct 
						//                   
						pdm->cbSize.pt.x = right - pdmLeft;
						top = pdmBottom;
					}
					else if (pdmBottom > bottom)
					{
						//       
						//       rct           pdm    
						//  pdm  > 
						//                   rct 
						//             
						pdm->cbSize.pt.x = right - pdmLeft;
						pdm->cbSize.pt.y = bottom - top;
						left = pdmLeft;
						top = bottom;
						right = pdmRight;
						bottom = pdmBottom;
					}
					else // if (pdmBottom == bottom)
					{
						// 	  
						//  pdm  rct  >     pdm    
						//       
						pdm->cbSize.pt.x = right - pdmLeft;
						break;
					}
				}

				else if (nextTop == top)
				{
					if (pdmBottom < bottom)
					{
						if (nextBottom < pdmBottom)
						{
							//       
							//            nxt              pdm       
							//  pdm            
							//       rct        >     rct    
							//                  
							//                               add 
							//                         
							mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
							ADDRECT(left, pdmBottom, right, bottom);
							pdm->cbSize.pt.x = nextRight - pdmLeft;
							pdm->cbSize.pt.y = pdmNext->cbSize.pt.y;
							left = pdmLeft;
							top = nextBottom;
							bottom = pdmBottom;
						}
						else if (nextBottom > pdmBottom)
						{
							if (nextBottom < bottom)
							{
								//       
								//  pdm                        pdm       
								//       nxt       
								//        rct       >           rct    
								//                        
								//                               add 
								//                         
								mmASSERT(n == 10,
										("Out of rectangle heap!\r\n"));
								ADDRECT(left, nextBottom, right, bottom);
								pdm->cbSize.pt.x = nextRight - pdmLeft;
								top = pdmBottom;
								right = nextRight;
								bottom = nextBottom;
							}
							else if (nextBottom > bottom)
							{
								//       
								//  pdm                        pdm       
								//  rct            
								//             nxt  >           rct    
								//                        
								//                                     add 
								//                               
								mmASSERT(n == 10,
										("Out of rectangle heap!\r\n"));
								ADDRECT(right, bottom, nextRight, nextBottom);
								pdm->cbSize.pt.x = nextRight - pdmLeft;
								top = pdmBottom;
								right = nextRight;
							}
							else // if (nextBottom == bottom)
							{
								//       
								//  pdm                        pdm       
								//  rct  nxt  > 
								//                                 rct    
								//                   
								pdm->cbSize.pt.x = nextRight - pdmLeft;
								top = pdmBottom;
								right = nextRight;
							}
						}
						else // if (nextBottom == pdmBottom)
						{
							//       
							//  pdm       nxt              pdm       
							//  rct  > 
							//                               rct 
							//                         
							pdm->cbSize.pt.x = nextRight - pdmLeft;
							top = pdmBottom;
						}
					}
					else if (pdmBottom > bottom)
					{
						if (nextBottom < bottom)
						{
							//       
							//            nxt              pdm       
							//       rct       
							//  pdm             >     rct    
							//                  
							//                         add 
							//                   
							mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
							ADDRECT(pdmLeft, bottom, pdmRight, pdmBottom);
							pdm->cbSize.pt.x = nextRight - pdmLeft;
							pdm->cbSize.pt.y = pdmNext->cbSize.pt.y;
							left = pdmLeft;
							top = nextBottom;
						}
						else if (nextBottom > bottom)
						{
							//       
							//       rct                   pdm       
							//  pdm  nxt  > 
							//                       rct       add 
							//                 
							mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
							ADDRECT(right, bottom, nextRight, nextBottom);
							pdm->cbSize.pt.x = nextRight - pdmLeft;
							pdm->cbSize.pt.y = bottom - top;
							left = pdmLeft;
							top = bottom;
							right = pdmRight;
							bottom = pdmBottom;
						}
						else // if (nextBottom == bottom)
						{
							//       
							//       rct  nxt              pdm       
							//  pdm  > 
							//                         rct 
							//                   
							pdm->cbSize.pt.x = nextRight - pdmLeft;
							pdm->cbSize.pt.y = pdmNext->cbSize.pt.y;
							left = pdmLeft;
							top = bottom;
							right = pdmRight;
							bottom = pdmBottom;
						}
					}
					else // if (pdmBottom == bottom)
					{
						if (nextBottom < pdmBottom)
						{
							//       
							//            nxt              pdm       
							//  pdm  rct  > 
							//                           rct    
							//             
							pdm->cbSize.pt.x = nextRight - pdmLeft;
							pdm->cbSize.pt.y = pdmNext->cbSize.pt.y;
							left = pdmLeft;
							top = nextBottom;
						}
						else if (nextBottom > pdmBottom)
						{
							//       
							//  pdm  rct                   pdm       
							//  nxt  > 
							//                                     rct 
							//                               
							pdm->cbSize.pt.x = nextRight - pdmLeft;
							left = right;
							top = bottom;
							right = nextRight;
							bottom = nextBottom;
						}
						else // if (nextBottom == pdmBottom)
						{
							//       
							//  pdm  rct  nxt  >        pdm       
							//       
							pdm->cbSize.pt.x = nextRight - pdmLeft;
							mmRemoveFromList(pdmRoot, pdmNext);
							mmFreeNode(pmm, pdmNext);
							break;
						}
					}

					// Free the <next> rectangle.
					mmRemoveFromList(pdmRoot, pdmNext);
					mmFreeNode(pmm, pdmNext);
				}

				else // if (nextTop > top)
				{
					if (pdmBottom < bottom)
					{
						//             
						//                           pdm    
						//  pdm            
						//       rct       >     rct         
						//       nxt        nxt 
						//                              add      
						//                             
						mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
						ADDRECT(left, pdmBottom, right, bottom);
						pdm->cbSize.pt.x = right - pdmLeft;
						pdm->cbSize.pt.y = nextTop - top;
						left = pdmLeft;
						top = nextTop;
						bottom = pdmBottom;
					}
					else if (pdmBottom > bottom)
					{
						//             
						//                           pdm    
						//       rct       
						//  pdm       nxt  >     rct     nxt 
						//                      
						//                         add 
						//                   
						mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
						ADDRECT(pdmLeft, bottom, pdmRight, pdmBottom);
						pdm->cbSize.pt.x = right - pdmLeft;
						pdm->cbSize.pt.y = nextTop - top;
						left = pdmLeft;
						top = nextTop;
					}
					else // if (pdmBottom == bottom)
					{
						//             
						//                           pdm    
						//  pdm  rct  > 
						//            nxt           rct     nxt 
						//                 
						pdm->cbSize.pt.x = right - pdmLeft;
						pdm->cbSize.pt.y = nextTop - top;
						left = pdmLeft;
						top = nextTop;
					}
				}
			}

			else if (pdmTop == top && pdmLeft == right)
			{
				// Find the next rectangle at the left side.
				for (pdmNext = pdm->next; pdmNext != NULL;
					 pdmNext = pdmNext->next
				)
				{
					nextLeft = pdmNext->cbAddr.pt.x;
					nextTop = pdmNext->cbAddr.pt.y;
					nextRight = pdmNext->cbAddr.pt.x + pdmNext->cbSize.pt.x;
					nextBottom = pdmNext->cbAddr.pt.y + pdmNext->cbSize.pt.y;

					if (nextRight == left && nextTop < bottom)
					{
						break;
					}
					if (nextTop >= bottom)
					{
						pdmNext = NULL;
						break;
					}
				}

				if (pdmNext == NULL || nextTop >= pdmBottom)
				{
					if (pdmBottom < bottom)
					{
						//       
						//       pdm           pdm    
						//  rct  > 
						//                   rct 
						//             
						pdm->cbAddr.pt.x = left;
						pdm->cbSize.pt.x = pdmRight - left;
						top = pdmBottom;
					}
					else if	(pdmBottom > bottom)
					{
						//       
						//  rct                pdm    
						//  pdm  > 
						//                         rct 
						//                   
						pdm->cbAddr.pt.x = left;
						pdm->cbSize.pt.x = pdmRight - left;
						pdm->cbSize.pt.y = bottom - top;
						left = pdmLeft;
						top = bottom;
						right = pdmRight;
						bottom = pdmBottom;
					}
					else // if (pdmBottom == bottom)
					{
						//       
						//  rct  pdm  >     pdm    
						//       
						pdm->cbAddr.pt.x = left;
						pdm->cbSize.pt.x = pdmRight - left;
						break;
					}
				}

				else if (pdmBottom < bottom)
				{
					//                   
					//                                 pdm    
					//       pdm       
					//  nxt  rct       >  nxt     rct    
					//                      
					//                               add 
					//                         
					mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
					ADDRECT(left, pdmBottom, right, bottom);
					pdm->cbAddr.pt.x = left;
					pdm->cbSize.pt.x = pdmRight - left;
					pdm->cbSize.pt.y = nextTop - top;
					top = nextTop;
					right = pdmRight;
					bottom = pdmBottom;
				}
				else if (pdmBottom > bottom)
				{
					//                   
					//                                 pdm    
					//  rct            
					//  nxt       pdm  >  nxt     rct    
					//                      
					//                                     add 
					//                               
					mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
					ADDRECT(pdmLeft, bottom, pdmRight, pdmBottom);
					pdm->cbAddr.pt.x = left;
					pdm->cbSize.pt.x = pdmRight - left;
					pdm->cbSize.pt.y = nextTop - top;
					top = pdmNext->cbAddr.pt.y;
					right = pdmRight;
				}
				else // if (pdmBottom == bottom)
				{
					//                   
					//                                 pdm    
					//  rct  pdm  > 
					//  nxt                  nxt     rct    
					//                 
					pdm->cbAddr.pt.x = left;
					pdm->cbSize.pt.x = pdmRight - left;
					pdm->cbSize.pt.y = nextTop - top;
					top = nextTop;
					right = pdmRight;
				}
			}
			
			else
			{
				if (pdmBottom == top && pdmLeft == left && pdmRight == right)
				{
					// Find the next rectangle at the left or right side.
					for (pdmNext = pdm->next; pdmNext != NULL; pdmNext =
							pdmNext->next)
					{
						nextLeft = pdmNext->cbAddr.pt.x;
						nextTop = pdmNext->cbAddr.pt.y;
						nextRight = pdmNext->cbAddr.pt.x + pdmNext->cbSize.pt.x;
						nextBottom = pdmNext->cbAddr.pt.y +
								pdmNext->cbSize.pt.y;

						if (   (nextLeft == right || nextRight == left)
							&& (nextTop < bottom) )
						{
							break;
						}
						if (nextTop >= bottom)
						{
							pdmNext = NULL;
							break;
						}
					}
					
					if (pdmNext == NULL)
					{
						//       
						//  pdm            
						//  >  pdm 
						//  rct            
						//       
						pdm->cbSize.pt.y += bottom - top;
						break;
					}
				}

				// Are we at the location where we should insert a new
				// rectangle?
				if ((pdmTop == top && pdmLeft > right) || pdmTop > top)
				{
					// Find the next rectangle at the left or right side.
					for (pdmNext = pdm; pdmNext != NULL; pdmNext =
							pdmNext->next)
					{
						nextLeft = pdmNext->cbAddr.pt.x;
						nextTop = pdmNext->cbAddr.pt.y;
						nextRight = pdmNext->cbAddr.pt.x + pdmNext->cbSize.pt.x;
						nextBottom = pdmNext->cbAddr.pt.y +
								pdmNext->cbSize.pt.y;

						if (   (nextTop < bottom)
							&& (nextRight == left || nextLeft == right)
						)
						{
							break;
						}
						else if (  nextTop == bottom
								&& nextLeft == left && nextRight == right )
						{
							break;
						}
						if (pdmNext->cbAddr.pt.y > bottom)
						{
							pdmNext = NULL;
							break;
						}
					}
					
					if (pdmNext != NULL && nextTop == bottom)
					{
						//       
						//  new            
						//  >  add 
						//  nxt            
						//       
						mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
						ADDRECT(left, top, right, nextBottom);
						mmRemoveFromList(pdmRoot, pdmNext);
						mmFreeNode(pmm, pdmNext);
						break;
					}

					// Allocate a new node.
					pdmNew = mmAllocNode(pmm);
					if (pdmNew == NULL)
					{
						// We are out of nodes!
						if (!fRollBack)
						{                                     
							mmRemoveRectFromList(pmm, pdmRoot, lpRect,
									NO_NODES);
							mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
							ADDRECT(left, top, right, bottom);
							mmRollBackAdd(pmm, pdmRoot, lpRect, rectList, n);
						}
						return FALSE;
					}

					// Insert node into the list.
					pdmNew->prev = pdm->prev;
					pdmNew->next = pdm;
					pdm->prev = pdmNew;
					if (pdmNew->prev == NULL)
					{
						*pdmRoot = pdmNew;
					}
					else
					{
						pdmNew->prev->next = pdmNew;
					}

					if (pdmNext == NULL)
					{
						// No neighbors at all.
						pdmNew->cbAddr.pt.x = left;
						pdmNew->cbAddr.pt.y = top;
						pdmNew->cbSize.pt.x = right - left;
						pdmNew->cbSize.pt.y = bottom - top;
						break;
					}
					else
					{
						//                         
						//                               new 
						//  rct  > 
						//  nxt       nxt        nxt  rct  nxt 
						//                           
						pdmNew->cbAddr.pt.x = left;
						pdmNew->cbAddr.pt.y = top;
						pdmNew->cbSize.pt.x = right - left;
						pdmNew->cbSize.pt.y = nextTop - top;
						if (pdm->prev == NULL)
						{
							mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
							ADDRECT(left, nextTop, right, bottom);
							break;
						}
						else
						{
							top = nextTop;
							pdm = pdm->prev;
						}
					}
				}
			}
			
			// Are we at the end of the packed queue?
			if (pdm->next == NULL)
			{
				// Allocate a new node.
				pdmNew = mmAllocNode(pmm);
				if (pdmNew == NULL)
				{
					// We are out of nodes!
					if (!fRollBack)
					{
						mmRemoveRectFromList(pmm, pdmRoot, lpRect, NO_NODES);
						mmASSERT(n == 10, ("Out of rectangle heap!\r\n"));
						ADDRECT(left, top, right, bottom);
						mmRollBackAdd(pmm, pdmRoot, lpRect, rectList, n);					
					}
					return FALSE;
				}

				// Append node after current node.
				pdmNew->next = NULL;

				pdmNew->prev = pdm;
				pdm->next = pdmNew;

				// No neighbors.
				pdmNew->cbAddr.pt.x = left;
				pdmNew->cbAddr.pt.y = top;
				pdmNew->cbSize.pt.x = right - left;
				pdmNew->cbSize.pt.y = bottom - top;
				break;
			}
		}
	}

	return TRUE;
}

/******************************************************************************\
* void mmRollBackRemove(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot,
*						PDEVMEM FAR* pdmList)
*
* PURPOSE:	Roll back a list of removed rectangles to a heap.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			pdmRoot	Address of the pointer to the root of the heap.
*			pdmList	Address of the pointer to the root of the list of removed
*					rectangles.
*
* RETURNS:	Nothing.
\******************************************************************************/
void mmRollBackRemove(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot, PDEVMEM FAR* pdmList)
{
	PDEVMEM	pdm, pdmNext;
	GXRECT	rect;

	for (pdm = *pdmList; pdm != NULL; pdm = pdmNext)
	{
		pdmNext = pdm->next;
		
		// Get the node coordinates.
		rect.left = pdm->cbAddr.pt.x;
		rect.top = pdm->cbAddr.pt.y;
		rect.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
		rect.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
		
		// Free the node.
		mmRemoveFromList(pdmList, pdm);
		mmFreeNode(pmm, pdm);
		
		// Add the freed node to the list.
		if (!mmAddRectToList(pmm, pdmRoot, &rect, TRUE))
		{
			mmASSERT(1, ("mmRollBackRemove failed\r\n"));
		}
	}
}

/******************************************************************************\
* PDEVMEM mmRemoveRectFromList(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot,
*							   LPGXRECT lpRect, REMOVE_METHOD fMethod)
*
* PURPOSE:	Remove a rectangle from a list.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			pdmRoot	Address of the pointer to the root of the list.
*			lpRect	Pointer to rectangle which holds the rectangle coordinates.
*			fMethod	Method of removing rectangles.
*
* RETURNS:	A pointer to the node which holds the removed rectangle or NULL if
*			there is an error.
\******************************************************************************/
PDEVMEM mmRemoveRectFromList(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot,
							 LPGXRECT lpRect, REMOVE_METHOD fMethod)
{
	PDEVMEM	pdm, pdmNext, pdmList = NULL;
	UINT	left, top, right, bottom;
	GXRECT	rect, newRect;
	BOOL	fRollBack = (fMethod == NO_NODES);

	left = lpRect->left;
	top = lpRect->top;
	right = lpRect->right;
	bottom = lpRect->bottom;

	#if DEBUG_HEAP
	{
		if (pmm->mmDebugHeaps)
		{
			mmDebug("\nmmRemoveRectFromList: %d,%d - %d,%d\r\n", left, top,
					right, bottom);
			mmDumpList(*pdmRoot, "before:\r\n");
		}
	}
	#endif

	for (pdm = *pdmRoot; pdm != NULL; pdm = pdmNext)
	{
		if (pdm->cbAddr.pt.y >= bottom)
		{
			// We have completely removed the specified rectangle.
			break;
		}

		pdmNext = pdm->next;

		// Does this node crosses the rectangle?
		if (   (pdm->cbAddr.pt.y + pdm->cbSize.pt.y > top)
			&& (pdm->cbAddr.pt.x + pdm->cbSize.pt.x > left)
			&& (pdm->cbAddr.pt.x < right)
		)                                                         
		{
			// Yes, get the node coordinates.
			rect.left = pdm->cbAddr.pt.x;
			rect.top = pdm->cbAddr.pt.y;
			rect.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
			rect.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;

			// Free the node.
			mmRemoveFromList(pdmRoot, pdm);
			mmFreeNode(pmm, pdm);
			
			if (rect.top < top)
			{
				// Split the node at the top.
				newRect.left = rect.left;
				newRect.top = rect.top;
				newRect.right = rect.right;
				newRect.bottom = top;

				// Insert the split rectangle into the list.
				if (!mmAddRectToList(pmm, pdmRoot, &newRect, fRollBack))
				{
					if (fMethod == NO_NODES)
					{
						// We are in a roll back, do other nodes first.
						mmRemoveRectFromList(pmm, pdmRoot, lpRect, NO_NODES);
						if (!mmAddRectToList(pmm, pdmRoot, &newRect, fRollBack))
						{
							mmASSERT(1, ("mmRemoveRectFromList - PANIC!\r\n"));
						}
						pdmNext = *pdmRoot;
					}
					else
					{
						// Roll back and exit.
						if (mmAddRectToList(pmm, pdmRoot, &rect, fRollBack))
						{
							mmRollBackRemove(pmm, pdmRoot, &pdmList);
						}
						else
						{
							mmRollBackRemove(pmm, pdmRoot, &pdmList);
							if (!mmAddRectToList(pmm, pdmRoot, &rect,
									fRollBack))
							{
								mmASSERT(1, ("mmRemoveRectFromList - rollback "
										"failed\r\n"));
							}
						}
						return(NULL);
					}
				}
				
				// Update the rectangle coordinates.
				rect.top = top;
			}

			if (rect.bottom > bottom)
			{
				// Split the node at the bottom.
				newRect.left = rect.left;
				newRect.top = bottom;
				newRect.right = rect.right;
				newRect.bottom = rect.bottom;

				// Insert the split rectangle into the list.
				if (!mmAddRectToList(pmm, pdmRoot, &newRect, fRollBack))
				{
					if (fMethod == NO_NODES)
					{
						// We are in a roll back, do other nodes first.
						mmRemoveRectFromList(pmm, pdmRoot, lpRect, NO_NODES);
						if (!mmAddRectToList(pmm, pdmRoot, &newRect, fRollBack))
						{
							mmASSERT(1, ("mmRemoveRectFromList - PANIC!\r\n"));
						}
						pdmNext = *pdmRoot;
					}
					else
					{
						// Roll back and exit.
						if (mmAddRectToList(pmm, pdmRoot, &rect, fRollBack))
						{
							mmRollBackRemove(pmm, pdmRoot, &pdmList);
						}
						else
						{
							mmRollBackRemove(pmm, pdmRoot, &pdmList);
							if (!mmAddRectToList(pmm, pdmRoot, &rect,
									fRollBack))
							{
								mmASSERT(1, ("mmRemoveRectFromList - rollback "
										"failed\r\n"));
							}
						}
						return(NULL);
					}
				}
				
				// Update the rectangle coordinates.
				rect.bottom = bottom;
			}

			if (rect.left < left)
			{
				// Split the node at the left.
				newRect.left = rect.left;
				newRect.top = rect.top;
				newRect.right = left;
				newRect.bottom = rect.bottom;
				
				// Insert the split rectangle into the list.
				if (!mmAddRectToList(pmm, pdmRoot, &newRect, fRollBack))
				{
					if (fMethod == NO_NODES)
					{
						// We are in a roll back, do other nodes first.
						mmRemoveRectFromList(pmm, pdmRoot, lpRect, NO_NODES);
						if (!mmAddRectToList(pmm, pdmRoot, &newRect, fRollBack))
						{
							mmASSERT(1, ("mmRemoveRectFromList - PANIC!\r\n"));
						}
						pdmNext = *pdmRoot;
					}
					else
					{
						// Roll back and exit.
						if (mmAddRectToList(pmm, pdmRoot, &rect, fRollBack))
						{
							mmRollBackRemove(pmm, pdmRoot, &pdmList);
						}
						else
						{
							mmRollBackRemove(pmm, pdmRoot, &pdmList);
							if (!mmAddRectToList(pmm, pdmRoot, &rect,
									fRollBack))
							{
								mmASSERT(1, ("mmRemoveRectFromList - rollback "
										"failed\r\n"));
							}
						}
						return(NULL);
					}
				}

				// Update the rectangle coordinates.
				rect.left = left;
			}

			if (rect.right > right)
			{
				// Split the node at the right.
				newRect.left = right;
				newRect.top = rect.top;
				newRect.right = rect.right;
				newRect.bottom = rect.bottom;
				
				// Insert the split rectangle into the list.
				if (!mmAddRectToList(pmm, pdmRoot, &newRect, fRollBack))
				{
					if (fMethod == NO_NODES)
					{
						// We are in a roll back, do other nodes first.
						mmRemoveRectFromList(pmm, pdmRoot, lpRect, NO_NODES);
						if (!mmAddRectToList(pmm, pdmRoot, &newRect, fRollBack))
						{
							mmASSERT(1, ("mmRemoveRectFromList - PANIC!\r\n"));
						}
						pdmNext = *pdmRoot;
					}
					else
					{
						// Roll back and exit.
						if (mmAddRectToList(pmm, pdmRoot, &rect, fRollBack))
						{
							mmRollBackRemove(pmm, pdmRoot, &pdmList);
						}
						else
						{
							mmRollBackRemove(pmm, pdmRoot, &pdmList);
							if (!mmAddRectToList(pmm, pdmRoot, &rect,
									fRollBack))
							{
								mmASSERT(1, ("mmRemoveRectFromList - rollback "
										"failed\r\n"));
							}
						}
						return(NULL);
					}
				}
				
				// Update the rectangle coordinates.
				rect.right = right;
			}

			if (fMethod != NO_NODES)
			{
				// Add the freed rectangle to the list.
				if (!mmAddRectToList(pmm, &pdmList, &rect, fRollBack))
				{
						// Roll back and exit.
						if (mmAddRectToList(pmm, pdmRoot, &rect, fRollBack))
						{
							mmRollBackRemove(pmm, pdmRoot, &pdmList);
						}
						else
						{
							mmRollBackRemove(pmm, pdmRoot, &pdmList);
							if (!mmAddRectToList(pmm, pdmRoot, &rect, fRollBack))
							{
								mmASSERT(1, ("mmRemoveRectFromList - rollback "
										"failed\r\n"));
							}
						}
						return(NULL);
				}
			}
		}
	}

	if (pdmList == NULL)
	{
		// No nodes found.
		return(NULL);
	}
	mmDebugList(pdmList, TRUE);

	// Combine all nodes equal in size.
	mmCombine(pmm, pdmList);

	#if DEBUG_HEAP
	{
		if (!mmDebugList(*pdmRoot, TRUE) && pmm->mmDebugHeaps)
		{
			mmDumpList(*pdmRoot, "After:\r\n");
			mmDumpList(pdmList, "Result:\r\n");
		}
	}
	#endif

	// In case we have a list and the method is not MULTIPLE_NODES, roll back.
	if ((fMethod != MULTIPLE_NODES) && (pdmList->next != NULL))
	{
		// Roll back and exit.
		mmRollBackRemove(pmm, pdmRoot, &pdmList);
		return(NULL);
	}

	return(pdmList);
}

/******************************************************************************\
* void mmCombine(PIIMEMMGR pmm, PDEVMEM pdmRoot)
*
* PURPOSE:	Combine all vertical nodes equal in width together in a list.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			pdmRoot	Pointer to root of list.
*
* RETURNS:	Nothing.
\******************************************************************************/
void mmCombine(PIIMEMMGR pmm, PDEVMEM pdmRoot)
{
	PDEVMEM	pdm, pdmNext;

	for (pdm = pdmRoot; pdm != NULL; pdm = pdm->next)
	{
		for (pdmNext = pdm->next; pdmNext != NULL; pdmNext = pdmNext->next)
		{
			// Are we too far under the current node?
			if (pdmNext->cbAddr.pt.y > pdm->cbAddr.pt.y + pdm->cbSize.pt.y)
			{
				break;
			}

			// Do we have a node under the current node of equal width?
			if (   (pdm->cbAddr.pt.x == pdmNext->cbAddr.pt.x)
				&& (pdm->cbSize.pt.x == pdmNext->cbSize.pt.x)
				&& (pdm->cbAddr.pt.y + pdm->cbSize.pt.y == pdmNext->cbAddr.pt.y)
			)
			{
				mmTRACE(("mmCombine: combined nodes %08X and %08X\r\n", pdm,
						pdmNext));
				
				// Merge the nodes together.
				pdm->cbSize.pt.y += pdmNext->cbSize.pt.y;
				mmRemoveFromList(&pdmRoot, pdmNext);
				mmFreeNode(pmm, pdmNext);

				// Rescan for more nodes.
				pdmNext = pdm;
			}
		}
	}
}

/******************************************************************************\
* BOOL mmFindRect(PIIMEMMGR pmm, LPGXRECT lpRect, GXPOINT size, GXPOINT align)
*
* PURPOSE:	Find a rectangle in the off-screen memory heap that fits the
*			requested size.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			lpRect	Pointer to rectangle which holds the return rectangle.
*			size	Size of requested rectangle.
*			align	Alignment of requested rectangle.
*
* RETURNS:	TRUE if lpRect holds a valid rectangle which is large enough to fit
*			the requested size or FALSE if there is not enough free memory in
*			the heap.
\******************************************************************************/
BOOL mmFindRect(PIIMEMMGR pmm, LPGXRECT lpRect, GXPOINT size, GXPOINT align)
{
	GXRECT	rect;
	PDEVMEM	pdm;
	UINT	bestDistance;

	// Initialize the area.
	lpRect->area = (ULONG) -1;

	// Case 1: we have a narrow and tall device bitmap.  We need to allocate it
	// at either the left side or the right side of the heap to leave room in
	// the middle for other device bitmaps.
	if (size.pt.x < size.pt.y)
	{
		// Initialize best distance.
		bestDistance = (UINT) -1;

		// Walk through all nodes.
		for (pdm = pmm->pdmHeap; pdm != NULL; pdm = pdm->next)
		{
			// Try allocating it at the left side of this node.
			rect.left = pdm->cbAddr.pt.x;
			rect.top = pdm->cbAddr.pt.y;
			rect.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
			rect.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
			if (   (pdm->cbAddr.pt.x < bestDistance)
				&& (mmGetLeft(pmm, pdm, &rect, size, align) < bestDistance)
			)
			{
				*lpRect = rect;

				bestDistance = rect.left;
				if (bestDistance == 0)
				{
					break;
				}
			}

			// Try allocating it at the right side of this node.
			rect.left = pdm->cbAddr.pt.x;
			rect.top = pdm->cbAddr.pt.y;
			rect.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
			rect.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
			if (   (pdm->cbAddr.pt.x + pdm->cbSize.pt.x > pmm->mmHeapWidth -
						bestDistance)
				&& (mmGetRight(pmm, pdm, &rect, size, align) > pmm->mmHeapWidth
						- bestDistance)
			)
			{
				*lpRect = rect;

				bestDistance = pmm->mmHeapWidth - rect.right;
				if (bestDistance == 0)
				{
					break;
				}
			}
		}
	}

	// Cae 2: we have a device bitmap which width equals the heap width.  We
	// will allocate this at the bottom of the heap.
	else if (size.pt.x == pmm->mmHeapWidth)
	{
		// Zero vertical coordinates.
		lpRect->top = 0;
		lpRect->bottom = 0;

		// Walk through all nodes.
		for (pdm = pmm->pdmHeap; pdm != NULL; pdm = pdm->next)
		{
			// Find the bottom coordinate of this node.
			rect.left = pdm->cbAddr.pt.x;
			rect.top = pdm->cbAddr.pt.y;
			rect.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
			rect.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
			if (   (pdm->cbSize.pt.x >= size.pt.x)
				&& (pdm->cbAddr.pt.y >= lpRect->top)
				&& (mmGetBottom(pmm, pdm, &rect, size, align) > lpRect->bottom)
			)
			{
				*lpRect = rect;
			}
		}
	}

	// All other cases.  Find the best possible match by finding the smallest
	// area which will fit the device bitmap.
	else
	{
		// Walk though all nodes.
		for (pdm = pmm->pdmHeap; pdm != NULL; pdm = pdm->next)
		{
			// Find the area for this node.
			rect.left = pdm->cbAddr.pt.x;
			rect.top = pdm->cbAddr.pt.y;
			rect.right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
			rect.bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
			if (   (pdm->cbSize.pt.x >= size.pt.x)
				&& (mmGetBest(pmm, pdm, &rect, size, align) < lpRect->area)
			)
			{
				*lpRect = rect;
			}
		}
	}

	if (lpRect->area == (ULONG) -1)
	{
		// No node was found, return an error.
		return FALSE;
	}

	// Reduce the size of the node to fit the requested size.
	if (lpRect->right - lpRect->left > size.pt.x)
	{
		lpRect->right = lpRect->left + size.pt.x;
	}
	if (lpRect->bottom - lpRect->top > size.pt.y)
	{
		lpRect->bottom = lpRect->top + size.pt.y;
	}
	return TRUE;
}

/******************************************************************************\
* UINT mmGetLeft(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
*				 GXPOINT align)
*
* PURPOSE:	Find the first rectangle that fits the requested size and alignment.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			pdmNode	Pointer to a node from which to start the search.
*			lpRect	Pointer to rectangle which holds the rectangle coordinates.
*			size	Size of requested rectangle.
*			align	Alignment of requested rectangle.
*
* RETURNS:	The left coordinate of the rectangle if it fits the requested size
*			or -1 if there is no such rectangle.
\******************************************************************************/
UINT mmGetLeft(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
			   GXPOINT align)
{
	GXRECT	rect, rectPath;
	PDEVMEM	pdm;
	UINT	pdmRight, left;

	// Copy rectangle coordinates.
	rect = *lpRect;

	// Align rectangle.
	#if TILE_ALIGNMENT
	{
		rect.left = mmAlignX(pmm, rect.left, size.pt.x, align.pt.x, FALSE);
	}
	#else
	{
		rect.left += align.pt.x - 1;
		rect.left -= rect.left % align.pt.x;
	}
	#endif
	rect.top += align.pt.y - 1;
	rect.top -= rect.top % align.pt.y;
	if (rect.left + size.pt.x > rect.right)
	{
		// Rectangle is too narrow for size or alignment.
		return (UINT) -1;
	}

	// Loop through all following nodes.
	for (pdm = pdmNode->next; pdm != NULL; pdm = pdm->next)
	{
		// Test if rectangle fits.
		if (rect.top + size.pt.y < rect.bottom)
		{
			break;
		}

		// Test if node is below rectangle.
		if (pdm->cbAddr.pt.y > rect.bottom)
		{
			break;
		}

		// Calculate right coordinate of node.
		pdmRight = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;

		// Test if node borders the rectangle at the bottom.
		if (   (pdm->cbAddr.pt.y == rect.bottom)
			&& (pdm->cbAddr.pt.x < rect.right)
			&& (pdmRight > rect.left)
		)
		{
			if (pdmRight < rect.right)
			{
				if (pdm->cbAddr.pt.x > rect.left)
				{
					// 
					//   rect  
					// 
					//   node 
					//  
					// Align the node horizontally.
					#if TILE_ALIGNMENT
					{
						left = mmAlignX(pmm, pdm->cbAddr.pt.x, size.pt.x,
								align.pt.x, FALSE);
					}
					#else
					{
						left = pdm->cbAddr.pt.x + align.pt.x - 1;
						left -= left % align.pt.x;
					}
					#endif
					if (left + size.pt.x < pdmRight)
					{
						// Follow the path of this node.
						rectPath.left = left;
						rectPath.top = rect.top;
						rectPath.right = pdmRight;
						rectPath.bottom = rect.bottom + pdm->cbSize.pt.y;
						if (mmGetLeft(pmm, pdm, &rectPath, size, align) !=
								(UINT) -1)
						{
							*lpRect = rectPath;
							return rectPath.left;
						}
					}
				}
				else
				{
					//  
					//   rect 
					// 
					//  node 
					// 
					if (rect.left + size.pt.x < pdmRight)
					{
						// Follow the path of this node.
						rectPath.left = rect.left;
						rectPath.top = rect.top;
						rectPath.right = pdmRight;
						rectPath.bottom = rect.bottom + pdm->cbSize.pt.y;
						if (mmGetLeft(pmm, pdm, &rectPath, size, align) !=
								(UINT) -1)
						{
							*lpRect = rectPath;
							return rectPath.left;
						}
					}
				}
			}
			else
			{
				if (pdm->cbAddr.pt.x > rect.left)
				{
					// 
					//  rect 
					// 
					//   node 
					//  
					// Align the node horizontally.
					#if TILE_ALIGNMENT
					{
						left = mmAlignX(pmm, pdm->cbAddr.pt.x, size.pt.x,
								align.pt.x, FALSE);
					}
					#else
					{
						left = pdm->cbAddr.pt.x + align.pt.x - 1;
						left -= left % align.pt.x;
					}
					#endif
					if (left + size.pt.x > rect.right)
					{
						// Node is too narrow for size or alignment.
						break;
					}
					rect.left = left;
					rect.bottom += pdm->cbSize.pt.y;
				}
				else
				{
					//  
					//   rect 
					// 
					//   node  
					// 
					rect.bottom += pdm->cbSize.pt.y;
				}
			}
		}
	}

	if (rect.top + size.pt.y > rect.bottom)
	{
		// Node is too low for size or alignment.
		return (UINT) -1;
	}

	// The rectangle fits.
	rect.area = MUL(rect.right - rect.left, rect.bottom - rect.top);
	*lpRect = rect;
	return rect.left;
}

/******************************************************************************\
* UINT mmGetRight(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
*				  GXPOINT align)
*
* PURPOSE:	Find the right most rectangle that fits the requested size and
*			alignment.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			pdmNode	Pointer to a node from which to start the search.
*			lpRect	Pointer to rectangle which holds the rectangle coordinates.
*			size	Size of requested rectangle.
*			align	Alignment of requested rectangle.
*
* RETURNS:	The right coordinate of the rectangle if it fits the requested size
*			or 0 if there is no such rectangle.
\******************************************************************************/
UINT mmGetRight(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
				GXPOINT align)
{
	GXRECT	rect, rectPath;
	PDEVMEM	pdm;
	UINT	pdmRight, left;

	// Copy rectangle coordinates.
	rect = *lpRect;

	// Align rectangle.
	#if TILE_ALIGNMENT
	{
		rect.left = mmAlignX(pmm, rect.left, size.pt.x, align.pt.x, FALSE);
	}
	#else
	{
		rect.left += align.pt.x - 1;
		rect.left -= rect.left % align.pt.x;
	}
	#endif
	rect.top += align.pt.y - 1;
	rect.top -= rect.top % align.pt.y;
	if (rect.left + size.pt.x > rect.right)
	{
		// Rectangle is too narrow for size or alignment.
		return 0;
	}

	// Zero the right most coordinate.
	lpRect->right = 0;

	// Loop through all following nodes.
	for (pdm = pdmNode->next; pdm != NULL; pdm = pdm->next)
	{
		// Test if node is below rectangle.
		if (pdm->cbAddr.pt.y > rect.bottom)
		{
			break;
		}

		// Calculate right coordinate of node.
		pdmRight = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;

		// Test if node borders the rectangle at the bottom.
		if (   (pdm->cbAddr.pt.y == rect.bottom)
			&& (pdm->cbAddr.pt.x < rect.right)
			&& (pdmRight > rect.left)
		)
		{
			if (pdmRight < rect.right)
			{
				if (pdm->cbAddr.pt.x > rect.left)
				{
					// 
					//   rect  
					// 
					//   node 
					//  
					// Align the node horizontally.
					#if TILE_ALIGNMENT
					{
						left = mmAlignX(pmm, pdm->cbAddr.pt.x, size.pt.x,
								align.pt.x, FALSE);
					}
					#else
					{
						left = pdm->cbAddr.pt.x + align.pt.x - 1;
						left -= left % align.pt.x;
					}
					#endif
					if (left + size.pt.x < pdmRight)
					{
						// Follow the path of this node.
						rectPath.left = left;
						rectPath.top = rect.top;
						rectPath.right = pdmRight;
						rectPath.bottom = rect.bottom + pdm->cbSize.pt.y;
						rectPath.area = 0;
						if (mmGetRight(pmm, pdm, &rectPath, size, align) >
								lpRect->right)
						{
							*lpRect = rectPath;
						}
					}
				}
				else
				{
					//  
					//   rect 
					// 
					//  node 
					// 
					if (rect.left + size.pt.x < pdmRight)
					{
						// Follow the path of this node.
						rectPath.left = rect.left;
						rectPath.top = rect.top;
						rectPath.right = pdmRight;
						rectPath.bottom = rect.bottom + pdm->cbSize.pt.y;
						rectPath.area = 0;
						if (mmGetRight(pmm, pdm, &rectPath, size, align) >
								lpRect->right)
						{
							*lpRect = rectPath;
						}
					}
				}
			}
			else
			{
				if (pdm->cbAddr.pt.x > rect.left)
				{
					// 
					//  rect 
					// 
					//   node 
					//  
					// Align the node horizontally.
					#if TILE_ALIGNMENT
					{
						left = mmAlignX(pmm, pdm->cbAddr.pt.x, size.pt.x,
								align.pt.x, FALSE);
					}
					#else
					{
						left = pdm->cbAddr.pt.x + align.pt.x - 1;
						left -= left % align.pt.x;
					}
					#endif
					if (left + size.pt.x > rect.right)
					{
						// Node is too narrow for size or alignment.
						break;
					}
					rect.left = left;
					rect.bottom += pdm->cbSize.pt.y;
				}
				else
				{
					//  
					//   rect 
					// 
					//   node  
					// 
					rect.bottom += pdm->cbSize.pt.y;
				}
			}
		}
	}

	if (rect.top + size.pt.y > rect.bottom)
	{
		// Node is too low for size or alignment.
		return 0;
	}

	// Align the rectangle to the right most coordinate.
	#if TILE_ALIGNMENT
	{
		rect.left = mmAlignX(pmm, rect.right - size.pt.x, size.pt.x, align.pt.x,
				TRUE);
	}
	#else
	{
		rect.left = rect.right - size.pt.x;
		rect.left -= rect.left % align.pt.x;
	}
	#endif
	rect.right = rect.left + size.pt.x;

	// Use the right most rectangle.
	if (rect.right > lpRect->right)
	{
		rect.area = MUL(rect.right - rect.left, rect.bottom - rect.top);
		*lpRect = rect;
	}
	return lpRect->right;
}

/******************************************************************************\
* UINT mmGetBottom(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect,
*				   GXPOINT size, GXPOINT align)
*
* PURPOSE:	Find the bottom most rectangle that fits the requested size and
*			alignment.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			pdmNode	Pointer to a node from which to start the search.
*			lpRect	Pointer to rectangle which holds the rectangle coordinates.
*			size	Size of requested rectangle.
*			align	Alignment of requested rectangle.
*
* RETURNS:	The bottom coordinate of the rectangle if it fits the requested size
*			or 0 if there is no such rectangle.
\******************************************************************************/
UINT mmGetBottom(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
				 GXPOINT align)
{
	GXRECT	rect, rectPath;
	PDEVMEM	pdm;
	UINT	pdmRight, left;

	// Copy rectangle coordinates.
	rect = *lpRect;

	// Align rectangle.
	#if TILE_ALIGNMENT
	{
		rect.left = mmAlignX(pmm, rect.left, size.pt.x, align.pt.x, FALSE);
	}
	#else
	{
		rect.left += align.pt.x - 1;
		rect.left -= rect.left % align.pt.x;
	}
	#endif
	rect.top += align.pt.y - 1;
	rect.top -= rect.top % align.pt.y;
	if (rect.left + size.pt.x > rect.right)
	{
		// Rectangle is too narrow for size or alignment.
		return 0;
	}

	// Zero the bottom most coordinate.
	lpRect->bottom = 0;

	// Loop through all following nodes.
	for (pdm = pdmNode->next; pdm != NULL; pdm = pdm->next)
	{
		// Test if node is below rectangle.
		if (pdm->cbAddr.pt.y > rect.bottom)
		{
			break;
		}

		// Calculate right coordinate of node.
		pdmRight = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;

		// Test if node borders the rectangle at the bottom.
		if (   (pdm->cbAddr.pt.y == rect.bottom)
			&& (pdm->cbAddr.pt.x < rect.right)
			&& (pdmRight > rect.left)
		)
		{
			if (pdmRight < rect.right)
			{
				if (pdm->cbAddr.pt.x > rect.left)
				{
					// 
					//   rect  
					// 
					//   node 
					//  
					// Align the node horizontally.
					#if TILE_ALIGNMENT
					{
						left = mmAlignX(pmm, pdm->cbAddr.pt.x, size.pt.x,
								align.pt.x, FALSE);
					}
					#else
					{
						left = pdm->cbAddr.pt.x + align.pt.x - 1;
						left -= left % align.pt.x;
					}
					#endif
					if (left + size.pt.x < pdmRight)
					{
						// Follow the path of this node.
						rectPath.left = left;
						rectPath.top = rect.top;
						rectPath.right = pdmRight;
						rectPath.bottom = rect.bottom + pdm->cbSize.pt.y;
						rectPath.area = 0;
						if (mmGetBottom(pmm, pdm, &rectPath, size, align) >
								lpRect->bottom)
						{
							*lpRect = rectPath;
						}
					}
				}
				else
				{
					//  
					//   rect 
					// 
					//  node 
					// 
					if (rect.left + size.pt.x < pdmRight)
					{
						// Follow the path of this node.
						rectPath.left = rect.left;
						rectPath.top = rect.top;
						rectPath.right = pdmRight;
						rectPath.bottom = rect.bottom + pdm->cbSize.pt.y;
						rectPath.area = 0;
						if (mmGetBottom(pmm, pdm, &rectPath, size, align) >
								lpRect->bottom)
						{
							*lpRect = rectPath;
						}
					}
				}
			}
			else
			{
				if (pdm->cbAddr.pt.x > rect.left)
				{
					// 
					//  rect 
					// 
					//   node 
					//  
					// Align the node horizontally.
					#if TILE_ALIGNMENT
					{
						left = mmAlignX(pmm, pdm->cbAddr.pt.x, size.pt.x,
								align.pt.x, FALSE);
					}
					#else
					{
						left = pdm->cbAddr.pt.x + align.pt.x - 1;
						left -= left % align.pt.x;
					}
					#endif
					if (left + size.pt.x > rect.right)
					{
						// Node is too narrow for size or alignment.
						break;
					}
					rect.left = left;
					rect.bottom += pdm->cbSize.pt.y;
				}
				else
				{
					//  
					//   rect 
					// 
					//   node  
					// 
					rect.bottom += pdm->cbSize.pt.y;
				}
			}
		}
	}

	if (rect.top + size.pt.y > rect.bottom)
	{
		// Node is too low for size or alignment.
		return 0;
	}

	// Align the rectangle to the bottom most coordinate.
	rect.top = rect.bottom - size.pt.y;
	rect.top -= rect.top % align.pt.y;
	rect.bottom = rect.top + size.pt.y;

	// Use the bottom most rectangle.
	if (rect.bottom > lpRect->bottom)
	{
		rect.area = MUL(rect.right - rect.left, rect.bottom - rect.top);
		*lpRect = rect;
	}
	return lpRect->bottom;
}

/******************************************************************************\
* UINT mmGetBest(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
*				 GXPOINT align)
*
* PURPOSE:	Find the best rectangle that fits the requested size and alignment.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			pdmNode	Pointer to a node from which to start the search.
*			lpRect	Pointer to rectangle which holds the rectangle coordinates.
*			size	Size of requested rectangle.
*			align	Alignment of requested rectangle.
*
* RETURNS:	The area of the rectangle if it fits the requested size or -1 if
*			there is no such rectangle.
\******************************************************************************/
ULONG mmGetBest(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
				GXPOINT align)
{
	GXRECT	rect, rectPath;
	PDEVMEM	pdm;
	UINT	pdmRight, left;

	// Copy rectangle coordinates.
	rect = *lpRect;

	// Align rectangle.
	#if TILE_ALIGNMENT
	{
		rect.left = mmAlignX(pmm, rect.left, size.pt.x, align.pt.x, FALSE);
	}
	#else
	{
		rect.left += align.pt.x - 1;
		rect.left -= rect.left % align.pt.x;
	}
	#endif
	rect.top += align.pt.y - 1;
	rect.top -= rect.top % align.pt.y;
	if (rect.left + size.pt.x > rect.right)
	{
		// Rectangle is too narrow for size or alignment.
		return (ULONG) -1;
	}

	// Initialize the area.
	lpRect->area = (ULONG) -1;

	// Loop through all following nodes.
	for (pdm = pdmNode->next; pdm != NULL; pdm = pdm->next)
	{
		// Test if node is below rectangle.
		if (pdm->cbAddr.pt.y > rect.bottom)
		{
			break;
		}

		// Calculate right coordinate of node.
		pdmRight = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;

		// Test if node borders the rectangle at the bottom.
		if (   (pdm->cbAddr.pt.y == rect.bottom)
			&& (pdm->cbAddr.pt.x < rect.right)
			&& (pdmRight > rect.left)
		)
		{
			if (pdmRight < rect.right)
			{
				if (pdm->cbAddr.pt.x > rect.left)
				{
					// 
					//   rect  
					// 
					//   node 
					//  
					// Align the node horizontally.
					#if TILE_ALIGNMENT
					{
						left = mmAlignX(pmm, pdm->cbAddr.pt.x, size.pt.x,
								align.pt.x, FALSE);
					}
					#else
					{
						left = pdm->cbAddr.pt.x + align.pt.x - 1;
						left -= left % align.pt.x;
					}
					#endif
					if (left + size.pt.x < pdmRight)
					{
						// Follow the path of this node.
						rectPath.left = left;
						rectPath.top = rect.top;
						rectPath.right = pdmRight;
						rectPath.bottom = rect.bottom + pdm->cbSize.pt.y;
						rectPath.area = 0;
						if (mmGetBest(pmm, pdm, &rectPath, size, align) <
								lpRect->area)
						{
							*lpRect = rectPath;
						}
					}
				}
				else
				{
					//  
					//   rect 
					// 
					//  node 
					// 
					if (rect.left + size.pt.x < pdmRight)
					{
						// Follow the path of this node.
						rectPath.left = rect.left;
						rectPath.top = rect.top;
						rectPath.right = pdmRight;
						rectPath.bottom = rect.bottom + pdm->cbSize.pt.y;
						rectPath.area = 0;
						if (mmGetBest(pmm, pdm, &rectPath, size, align) <
								lpRect->area)
						{
							*lpRect = rectPath;
						}
					}
				}
			}
			else
			{
				if (pdm->cbAddr.pt.x > rect.left)
				{
					// 
					//  rect 
					// 
					//   node 
					//  
					// Align the node horizontally.
					#if TILE_ALIGNMENT
					{
						left = mmAlignX(pmm, pdm->cbAddr.pt.x, size.pt.x,
								align.pt.x, FALSE);
					}
					#else
					{
						left = pdm->cbAddr.pt.x + align.pt.x - 1;
						left -= left % align.pt.x;
					}
					#endif
					if (left + size.pt.x > rect.right)
					{
						// Node is too narrow for size or alignment.
						break;
					}
					rect.left = left;
					rect.bottom += pdm->cbSize.pt.y;
				}
				else
				{
					//  
					//   rect 
					// 
					//   node  
					// 
					rect.bottom += pdm->cbSize.pt.y;
				}
			}
		}
	}

	if (rect.top + size.pt.y > rect.bottom)
	{
		// Node is too low for size or alignment.
		return (ULONG) -1;
	}

	// Use the smallest rectangle.
	rect.area = MUL(rect.right - rect.left, rect.bottom - rect.top);
	if (rect.area < lpRect->area)
	{
		*lpRect = rect;
	}

	// Return area of smallest rectangle that fits.
	return lpRect->area;
}

/******************************************************************************\
* UINT mmGetLargest(PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT align)
*
* PURPOSE:	Find the largest rectangle that fits the requested alignment.
*
* ON ENTRY:	pdmNode	Pointer to a node from which to start the search.
*			lpRect	Pointer to rectangle which holds the rectangle coordinates.
*			align	Alignment of requested rectangle.
*
* RETURNS:	The area of the rectangle if it fits the requested alignment or 0
*			if there is no such rectangle.
\******************************************************************************/
ULONG mmGetLargest(PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT align)
{
	GXRECT	rect, rectPath;
	PDEVMEM	pdm;
	UINT	pdmRight, left;

	// Copy rectangle coordinates.
	rect = *lpRect;

	// Align rectangle.
	rect.left += align.pt.x - 1;
	rect.left -= rect.left % align.pt.x;
	rect.top += align.pt.y - 1;
	rect.top -= rect.top % align.pt.y;
	if (rect.left >= rect.right)
	{
		// Rectangle is too narrow for alignment.
		return 0;
	}

	// Set the largest area to the aligned block size.
	rect.area = MUL(rect.right - rect.left, rect.bottom - rect.top);
	*lpRect = rect;

	// Loop through all following nodes.
	for (pdm = pdmNode->next; pdm != NULL; pdm = pdm->next)
	{
		// Test if node is below rectangle.
		if (pdm->cbAddr.pt.y > rect.bottom)
		{
			break;
		}

		// Calculate right coordinate of node.
		pdmRight = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;

		// Test if node borders the rectangle at the bottom.
		if (   (pdm->cbAddr.pt.y == rect.bottom)
			&& (pdm->cbAddr.pt.x < rect.right)
			&& (pdmRight > rect.left)
		)
		{
			if (pdmRight < rect.right)
			{
				if (pdm->cbAddr.pt.x > rect.left)
				{
					// 
					//   rect  
					// 
					//   node 
					//  
					// Align the node horizontally.
					left = pdm->cbAddr.pt.x + align.pt.x - 1;
					left -= left % align.pt.x;
					if (left < pdmRight)
					{
						// Follow the path of this node.
						rectPath.left = left;
						rectPath.top = rect.top;
						rectPath.right = pdmRight;
						rectPath.bottom = rect.bottom + pdm->cbSize.pt.y;
						rectPath.area = 0;
						if (mmGetLargest(pdm, &rectPath, align) > lpRect->area)
						{
							*lpRect = rectPath;
						}
					}
				}
				else
				{
					//  
					//   rect 
					// 
					//  node 
					// 
					// Follow the path of this node.
					rectPath.left = rect.left;
					rectPath.top = rect.top;
					rectPath.right = pdmRight;
					rectPath.bottom = rect.bottom + pdm->cbSize.pt.y;
					rectPath.area = 0;
					if (mmGetLargest(pdm, &rectPath, align) > lpRect->area)
					{
						*lpRect = rectPath;
					}
				}
			}
			else
			{
				if (pdm->cbAddr.pt.x > rect.left)
				{
					// 
					//  rect 
					// 
					//   node 
					//  
					// Align the node horizontally.
					left = pdm->cbAddr.pt.x + align.pt.x - 1;
					left -= left % align.pt.x;
					if (left > rect.right)
					{
						// Node is too narrow for alignment.
						break;
					}
					rect.left = left;
					rect.bottom += pdm->cbSize.pt.y;
				}
				else
				{
					//  
					//   rect 
					// 
					//   node  
					// 
					rect.bottom += pdm->cbSize.pt.y;
				}
			}
		}
	}

	if (rect.top >= rect.bottom)
	{
		// Node is too low for alignment.
		return 0;
	}

	// Use the largest rectangle.
	rect.area = MUL(rect.right - rect.left, rect.bottom - rect.top);
	if (rect.area > lpRect->area)
	{
		*lpRect = rect;
	}

	// Return area of largest rectangle.
	return lpRect->area;
}

#if TILE_ALIGNMENT
/******************************************************************************\
* UINT mmAlignX(PIIMEMMGR pmm, UINT x, UINT size, UINT align, BOOL fLeft)
*
* PURPOSE:	Align an x coordinate with the requested alignment factor.  Check
*			the alignment for too many tile boundary crossings.
*
* ON ENTRY:	pmm		Pointer to MEMMGR structure.
*			x		Unaligned x coordinate.
*			size	Requested width.
*			align	Requested alignment.
*			fLeft	TRUE if alignment should move to left, FALSE if alignment
*					should move to right.
*
* RETURNS:	The aligned x coordinate.
\******************************************************************************/
UINT mmAlignX(PIIMEMMGR pmm, UINT x, UINT size, UINT align, BOOL fLeft)
{
	BOOL	fFlag;

	// Remove tile-alignment flag from requested alignment.
	fFlag = align & 0x8000;
	align &= ~0x8000;

	// Loop forever.
	for (;;)
	{
		if (x % align)
		{
			// Align with the requested alignment.
			if (fLeft)
			{
				x -= x % align;
			}
			else
			{
				x += align - (x % align);
			}
		}

		// Do we cross too many tile boundaries?
		else if (fFlag && (x ^ (size - 1) ^ (x + size - 1)) & pmm->mmTileWidth)
		{
			// Align with tile boundary.
			if (fLeft)
			{
				x -= (x + size) & (pmm->mmTileWidth - 1);
			}
			else
			{
				x += pmm->mmTileWidth - (x & (pmm->mmTileWidth - 1));
			}
		}

		else
		{
			// We are done!
			break;
		}
	}

	// Return aligned x coordinate.
	return x;
}
#endif /* TILE_ALIGNMENT */

/******************************************************************************\
*																			   *
*					  1 6 - B I T   S U P P O R T   C O D E					   *
*																			   *
\******************************************************************************/
#ifdef WIN95
/******************************************************************************\
* UINT mmFindClient(PIIMEMMGR pmm, PCLIENT pClient, FNMMCALLBACK fnCallback)
*
* PURPOSE:	Call the given callback function for each node in the used list
*			which belongs to the specified client.
*
* ON ENTRY:	pmm			Pointer to MEMMGR structure.
*			pClient		Pointer to the client to look for.
*			fcCallback	Pointer to a callback function.
*
* RETURNS:	The return value of the callback function.
\******************************************************************************/
UINT mmFindClient(PIIMEMMGR pmm, PCLIENT pClient, FNMMCALLBACK fnCallback)
{
	PDEVMEM	pdm, pdmNext;
	UINT	status;

	// If we don't have a callback function just return 0.
	if (fnCallback == NULL)
	{
		return 0;
	}

	// Walk through all nodes.
	for (pdm = pmm->pdmUsed; pdm != NULL; pdm = pdmNext)
	{
		// Store pointer to next node.
		pdmNext = pdm->next;

		// Test if the client matches.
		if (pdm->client == pClient)
		{
			// If the callback function returns an error, return right away.
			status = fnCallback(pdm);
			if (status != 0)
			{
				return status;
			}
		}
	}

	return 0;
}

/******************************************************************************\
* ULONG mmMultiply(UINT n1, UINT n2)
*
* PURPOSE:	Multiply two unsigned values.
*
* ON ENTRY:	n1		First value to multiply.
*			n2		Second value to multiply.
*
* RETURNS:	The result of the multiplication.
\******************************************************************************/
#pragma optimize("", off)	// Oh boy, Microsoft does not understand assembly.
#pragma warning(disable : 4035)	// Yes, we do have a return value.
ULONG mmMultiply(UINT n1, UINT n2)
{
	_asm
	{
		mov ax, [n1]
		mul [n2]
	}
}
#pragma optimize("", on)
#pragma warning(default : 4035)
#endif /* WIN95 */

/******************************************************************************\
*																			   *
*						   D E B U G G I N G   C O D E						   *
*																			   *
\******************************************************************************/
#if DEBUG_HEAP
#pragma optimize("", off)	// Oh boy, Microsoft does not understand assembly.
void mmBreak()
{
	_asm int 3;         
}
#pragma optimize("", on)

void mmDumpList(PDEVMEM pdmRoot, LPCSTR lpszMessage)
{
	PDEVMEM	pdm;

	mmDebug(lpszMessage);
	for (pdm = pdmRoot; pdm != NULL; pdm = pdm->next)
	{
		mmDebug("%d,%d - %d,%d (%dx%d)\r\n", pdm->cbAddr.pt.x, pdm->cbAddr.pt.y,
				pdm->cbAddr.pt.x + pdm->cbSize.pt.x, pdm->cbAddr.pt.y +
				pdm->cbSize.pt.y, pdm->cbSize.pt.x, pdm->cbSize.pt.y);
	}
}

ULONG mmDebugList(PDEVMEM pdmRoot, BOOL fCheckSort)
{
	PDEVMEM pdm, pdmNext;
	UINT left, top, right, bottom;
	UINT nextLeft, nextTop, nextRight, nextBottom;
	ULONG error = 0;

	for (pdm = pdmRoot; pdm != NULL; pdm = pdm->next)
	{
		left = pdm->cbAddr.pt.x;
		top = pdm->cbAddr.pt.y;
		right = pdm->cbAddr.pt.x + pdm->cbSize.pt.x;
		bottom = pdm->cbAddr.pt.y + pdm->cbSize.pt.y;
		if (left >= right || top >= bottom)
		{
			mmDebug("ERROR: Invalid size: %08X(%u,%u - %u,%u)\r\n", pdm, left,
					top, right, bottom);
			mmBreak();
			error++;
		}
		for (pdmNext = pdm->next; pdmNext != NULL; pdmNext = pdmNext->next)
		{
			if (pdm == pdmNext)
			{
				mmDebug("ERROR: Cyclic list: %08X\r\n", pdm);
				mmBreak();
				error++;
				break;
			}

			nextLeft = pdmNext->cbAddr.pt.x;
			nextTop = pdmNext->cbAddr.pt.y;
			nextRight = pdmNext->cbAddr.pt.x + pdmNext->cbSize.pt.x;
			nextBottom = pdmNext->cbAddr.pt.y + pdmNext->cbSize.pt.y;
			if (   (nextLeft < right && nextTop < bottom)
				&& (nextRight > left && nextBottom > top)
			)
			{
				mmDebug("ERROR: Overlap: %08X(%u,%u - %u,%u) & "
						"%08X(%u,%u - %u,%u)\r\n", pdm, left, top, right,
						bottom, pdmNext, nextLeft, nextTop, nextRight,
						nextBottom);
				mmBreak();
				error++;
			}

			if (   (fCheckSort)
				&& (nextTop < top || (nextTop == top && nextLeft <= left))
			)
			{
				mmDebug("ERROR: Not sorted: %08X(%u,%u - %u,%u) & "
						"%08X(%u,%u - %u,%u)\r\n", pdm, left, top, right,
						bottom, pdmNext, nextLeft, nextTop, nextRight,
						nextBottom);
				mmBreak();
				error++;
			}

			if (   (fCheckSort)
				&& (left == nextRight || right == nextLeft)
				&& (top < nextBottom && bottom > nextTop)
			)
			{
				mmDebug("ERROR: Not packed: %08X(%u,%u - %u,%u) & "
						"%08X(%u,%u - %u,%u)\r\n", pdm, left, top, right,
						bottom, pdmNext, nextLeft, nextTop, nextRight,
						nextBottom);
				mmBreak();
				error++;
			}
		}
	}

	if (error > 0)
	{
		mmDumpList(pdmRoot, "Offending heap:\r\n");
	}

	return error;
}

void mmDebug(LPCSTR lpszFormat, ...)
{
	#ifdef WIN95 /* Windows 95 */
	{
		typedef int (PASCAL FAR* LPWVSPRINTF)(LPSTR lpszOutput,
				LPCSTR lpszFormat, const void FAR* lpvArgList);
		static LPWVSPRINTF lpwvsprintf;
		char szBuffer[128];

		if (lpwvsprintf == NULL)
		{
			lpwvsprintf = (LPWVSPRINTF) GetProcAddress(GetModuleHandle("USER"),
					"WVSPRINTF");
		}

		lpwvsprintf(szBuffer, lpszFormat, (LPVOID) (&lpszFormat + 1));
		OutputDebugString(szBuffer);
	}
	#else /* Windows NT */
	{
		va_list arglist;
		va_start(arglist, lpszFormat);

		#ifdef WINNT_VER40
		{
			EngDebugPrint("MemMgr: ", (PCHAR) lpszFormat, arglist);
		}
		#else
		{
			char buffer[128];

			vsprintf(szBuffer, lpszFormat, arglist);
			OutputDebugString(szBuffer);
		}
		#endif
	}
	#endif
}
#endif /* DEBUG_HEAP */
#endif /* MEMMGR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\palette.c ===
/******************************Module*Header*******************************\
* Module Name: palette.c
*
* Palette support.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// Global Table defining the 20 Window Default Colors.        For 256 color
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

const PALETTEENTRY BASEPALETTE[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

BOOL bInitDefaultPalette(PPDEV ppdev, DEVINFO *pDevInfo);

/******************************Public*Routine******************************\
* bInitPaletteInfo
*
* Initializes the palette information for this PDEV.
*
* Called by DrvEnablePDEV.
*
\**************************************************************************/

BOOL bInitPaletteInfo(PPDEV ppdev, DEVINFO *pDevInfo)
{
    if (!bInitDefaultPalette(ppdev, pDevInfo))
        return(FALSE);

    return(TRUE);
}

/******************************Public*Routine******************************\
* vDisablePalette
*
* Frees resources allocated by bInitPaletteInfo.
*
\**************************************************************************/

VOID vDisablePalette(PPDEV ppdev)
{
// Delete the default palette if we created one.

    if (ppdev->hpalDefault)
    {
        EngDeletePalette(ppdev->hpalDefault);
        ppdev->hpalDefault = (HPALETTE) 0;
    }

    if (ppdev->pPal != (PPALETTEENTRY)NULL)
        MEMORY_FREE((PVOID)ppdev->pPal);
}

/******************************Public*Routine******************************\
* bInitDefaultPalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitDefaultPalette(PPDEV ppdev, DEVINFO *pDevInfo)
{
    if (ppdev->ulBitCount == 8)
    {
        ULONG ulLoop;
        BYTE jRed,jGre,jBlu;

        // Allocate our palette

#ifdef WINNT_VER40
        ppdev->pPal = (PPALETTEENTRY)MEM_ALLOC(FL_ZERO_MEMORY,
                (sizeof(PALETTEENTRY) * 256), ALLOC_TAG);
#else
        ppdev->pPal = (PPALETTEENTRY)MEM_ALLOC(LMEM_FIXED | LMEM_ZEROINIT,
                (sizeof(PALETTEENTRY) * 256));
#endif

        if ((ppdev->pPal) == NULL) {
            RIP("DISP bInitDefaultPalette() failed MEM_ALLOC\n");
            return(FALSE);
        }


        // Generate 256 (8*4*4) RGB combinations to fill the palette

        jRed = jGre = jBlu = 0;

        for (ulLoop = 0; ulLoop < 256; ulLoop++)
        {
            ppdev->pPal[ulLoop].peRed   = jRed;
            ppdev->pPal[ulLoop].peGreen = jGre;
            ppdev->pPal[ulLoop].peBlue  = jBlu;
            ppdev->pPal[ulLoop].peFlags = (BYTE)0;

            if (!(jRed += 32))
            if (!(jGre += 32))
            jBlu += 64;
        }

    // Fill in Windows Reserved Colors from the WIN 3.0 DDK
    // The Window Manager reserved the first and last 10 colors for
    // painting windows borders and for non-palette managed applications.

        for (ulLoop = 0; ulLoop < 10; ulLoop++)
        {
        // First 10

            ppdev->pPal[ulLoop] = BASEPALETTE[ulLoop];

        // Last 10

            ppdev->pPal[246 + ulLoop] = BASEPALETTE[ulLoop+10];
        }

    // Create handle for palette.

        ppdev->hpalDefault =
        pDevInfo->hpalDefault = EngCreatePalette(PAL_INDEXED,
                                                   256,
                                                   (PULONG) ppdev->pPal,
                                                   0,0,0);

        if (ppdev->hpalDefault == (HPALETTE) 0)
        {
            RIP("DISP bInitDefaultPalette failed EngCreatePalette\n");
            MEMORY_FREE(ppdev->pPal);
            return(FALSE);
        }

    // Initialize the hardware with the initial palette.

        return(TRUE);
    } else {

        ppdev->hpalDefault =
        pDevInfo->hpalDefault = EngCreatePalette(PAL_BITFIELDS,
                                                   0,(PULONG) NULL,
                                                   ppdev->flRed,
                                                   ppdev->flGreen,
                                                   ppdev->flBlue);

        if (ppdev->hpalDefault == (HPALETTE) 0)
        {
            RIP("DISP bInitDefaultPalette failed EngCreatePalette\n");
            return(FALSE);
        }
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bInit256ColorPalette
*
* Initialize the hardware's palette registers.
*
\**************************************************************************/

BOOL bInit256ColorPalette(PPDEV ppdev)
{
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    ULONG       cColors;
    PVIDEO_CLUTDATA pScreenClutData;

    if (ppdev->ulBitCount == 8)
    {
        // Fill in pScreenClut header info:

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        // Copy colours in:

        cColors = 256;
        pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

        while(cColors--)
        {
            pScreenClutData[cColors].Red =    ppdev->pPal[cColors].peRed >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Green =  ppdev->pPal[cColors].peGreen >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue =   ppdev->pPal[cColors].peBlue >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }

        // Set palette registers:

        if (!DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_VIDEO_SET_COLOR_REGISTERS,
                             pScreenClut,
                             MAX_CLUT_SIZE,
                             NULL,
                             0,
                             &ulReturnedDataLength,
                             NULL))
        {
            DISPDBG((1, "Failed bEnablePalette"));
            return(FALSE);
        }
    }

    DISPDBG((5, "Passed bEnablePalette"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PVIDEO_CLUTDATA pScreenClutData;
    PDEV*           ppdev;

    UNREFERENCED_PARAMETER(fl);

    DISPDBG((1, "DISP DrvSetPalette: Entry.\n"));

    ppdev = (PDEV*) dhpdev;

    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                     (ULONG*) pScreenClutData))
    {
        DISPDBG((1, "DrvSetPalette failed PALOBJ_cGetColors\n"));
        return (FALSE);
    }

    // Set the high reserved byte in each palette entry to 0.
    // Do the appropriate palette shifting to fit in the DAC.

    if (ppdev->cPaletteShift)
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Red >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Green >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }
    }
    else
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Unused = 0;
        }
    }

    // Set palette registers

    if (!DEVICE_IO_CTRL(ppdev->hDriver,
                         IOCTL_VIDEO_SET_COLOR_REGISTERS,
                         pScreenClut,
                         MAX_CLUT_SIZE,
                         NULL,
                         0,
                         &cColors,
                         NULL))
    {
        DISPDBG((1, "DrvSetPalette failed DEVICE_IO_CTRL\n"));
        return (FALSE);
    }

    DISPDBG((1, "DISP DrvSetPalette: Exit.\n"));
    return(TRUE);

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\memmgr.c ===
/****************************************************************************
*****************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:      Laguna I (CL-GD5462) - 
*
* FILE:         memmgr.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*                This program provides the off screen memory management
*           using (X,Y) coordinate as memory reference instead of
*           linear memory.
*
* MODULES:
*           SaveOffscnToHost()
*           RestoreHostToOffscn()
*           DDOffScnMemAlloc()
*           DDOffScnMemRestore()
*           InitOffScnMem()
*           AllocOffScnMem()
*           FreeOffScnMem()
*           CloseOffScnMem()
*           ConvertToVideoBufferAddr()
*           OFS_AllocHdl()
*           OFS_InitMem()
*           OFS_PackMem()
*           OFS_InsertInFreeQ()
*           OFS_RemoveFrmFreeQ()
*           OFS_InsertInUsedQ()
*           OFS_RemoveFrmUsedQ()
*
* REVISION HISTORY:
*   6/12/95     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/MEMMGR.C  $
* 
*    Rev 1.48   Mar 04 1998 15:28:50   frido
* Added new shadow macros.
* 
*    Rev 1.47   Jan 22 1998 16:21:16   frido
* PDR#11132. The CopyBitmaps function is using byte aligned striping
* but was using the normal BLTEXT register instead of MBLTEXT.
* 
*    Rev 1.46   Dec 10 1997 13:32:16   frido
* Merged from 1.62 branch.
* 
*    Rev 1.45.1.2   Dec 04 1997 13:40:22   frido
* PDR#11039: Removed memory mover in 24-bpp as well.
* 
*    Rev 1.45.1.1   Dec 03 1997 18:11:10   frido
* PDR#11039. Disabled the memory mover in 32-bpp. It seems to cause
* corruption. This needs to be investigated after WHQL!
* 
*    Rev 1.45.1.0   Nov 13 1997 16:40:52   frido
* Added striping code inside the CopyBitmap routine which is used by the
* memory manager mmMove routine. This fixes the drop in speed in the
* High-End Graphics.
* 
*    Rev 1.45   Nov 03 1997 15:48:10   frido
* Added REQUIRE macros.
* 
*    Rev 1.44   Oct 28 1997 09:44:00   frido
* Fixed a compile problem with the updated mmCore.c
* 
*    Rev 1.43   02 Oct 1997 17:13:36   frido
* I have removed the extra rectangle in 1280x1024x8.
* 
*    Rev 1.42   24 Sep 1997 13:46:14   frido
* PDR#10526: Immortal Klowns needs its surfaces to be DWORD aligned in size.
* 
*    Rev 1.41   16 Sep 1997 15:07:28   bennyn
* 
* Added eight bytes alignment option
* 
*    Rev 1.40   29 Aug 1997 14:05:12   noelv
* Added MINSZY define.
* 
*    Rev 1.39   29 Aug 1997 08:54:58   FRIDO
* The old AllocOffScnMem routine had various bugs in there causing
* overlapping rectangles. The entire algoritm has been changed.
* 
*    Rev 1.38   25 Aug 1997 16:05:46   FRIDO
* 
* Added invalidation of brush cache in DDOffScnMemRestore.
* 
*    Rev 1.37   18 Aug 1997 09:21:22   FRIDO
* 
* Added initialization of bitmap filter.
* 
*    Rev 1.36   13 Aug 1997 12:16:24   bennyn
* Changed the PREALLOC_Y to 17 & Fixed the free rectange initialization bug
* 
*    Rev 1.35   08 Aug 1997 17:24:16   FRIDO
* Added support for new memory manager.
* 
*    Rev 1.34   07 Aug 1997 12:31:30   bennyn
* Undo Shuhua's fix and eliminated the extra rectangle for 1600x1200x16 and x
* 
*    Rev 1.33   06 Aug 1997 12:47:52   noelv
* Shuhua's fix for DXView no-memory bug. # 10227
* 
*    Rev 1.32   01 Jul 1997 09:53:30   einkauf
* init pdsurf to NULL in OFS_InsertInFreeQ (fix PDR 9385)
* change x tile size to 64 instead of 32 for 3D draw buffers
* 
*    Rev 1.31   29 Apr 1997 16:28:46   noelv
* 
* Merged in new SWAT code.
* SWAT: 
* SWAT:    Rev 1.6   24 Apr 1997 11:56:40   frido
* SWAT: NT140b09 merge.
* SWAT: 
* SWAT:    Rev 1.5   24 Apr 1997 11:49:56   frido
* SWAT: Removed all memory manager changes.
* SWAT: 
* SWAT:    Rev 1.4   19 Apr 1997 16:41:56   frido
* SWAT: Fixed minor bugs.
* SWAT: Added SWAT.h include file.
* SWAT: 
* SWAT:    Rev 1.3   15 Apr 1997 19:12:56   frido
* SWAT: Added more SWAT5 code (still disabled).
* SWAT: 
* SWAT:    Rev 1.2   10 Apr 1997 17:36:56   frido
* SWAT: Started work on SWAT5 optmizations.
* SWAT: 
* SWAT:    Rev 1.1   09 Apr 1997 17:33:16   frido
* SWAT: Called vAssertModeText to enable/disable font cache for DirectDraw.
* 
*    Rev 1.30   17 Apr 1997 15:31:28   noelv
* Dont' use the extra rectangle on an 8 meg board.
* 
*    Rev 1.29   17 Apr 1997 12:03:44   bennyn
* Fixed init offscn mem allocation problem for 1280x1024x24.
* 
*    Rev 1.28   26 Feb 1997 09:23:40   noelv
* 
* Added MCD support from ADC
* 
*    Rev 1.27   23 Jan 1997 10:57:32   noelv
* Added debugging option to erase memory blocks when freed.
* 
*    Rev 1.26   27 Nov 1996 11:32:42   noelv
* Disabled Magic Bitmap.  Yeah!!!
* 
*    Rev 1.25   26 Nov 1996 09:58:52   noelv
* 
* Added DBG prints.
* 
*    Rev 1.24   12 Nov 1996 15:21:58   bennyn
* 
* Fixed ALT-ENTER problem with DD appl
* 
*    Rev 1.23   07 Nov 1996 16:01:38   bennyn
* Alloc offscn mem in DD createsurface
* 
*    Rev 1.22   23 Oct 1996 14:42:42   BENNYN
* 
* CLeanup not use code for DirectDraw cursor
* 
*    Rev 1.21   18 Sep 1996 13:58:48   bennyn
* 
* Put the cursor mask and brush cache at the bottom of offscn mem
* 
*    Rev 1.20   27 Aug 1996 09:41:48   bennyn
* Restore the changes from the missing version
* 
*    Rev 1.19   26 Aug 1996 17:33:40   bennyn
* Restore the changes for the losed version
* 
*    Rev 1.18   23 Aug 1996 09:10:28   noelv
* Save unders are now discardable.
* 
*    Rev 1.7   22 Aug 1996 18:09:30   frido
* #ss -Added removing of DrvSaveScreenBits areas when DirectDraw gets
* initialized.
* 
*    Rev 1.6   20 Aug 1996 11:07:56   frido
* #ddl - Fixed DirectDraw lockup problem (compiler optimization bug).
* 
*    Rev 1.5   17 Aug 1996 19:39:16   frido
* Fixed DirectDraw cursor problem.
* 
*    Rev 1.4   17 Aug 1996 14:03:42   frido
* Added pre-compiled header.
* 
*    Rev 1.3   17 Aug 1996 13:25:28   frido
* New release from Bellevue.
* 
*    Rev 1.14   16 Aug 1996 09:04:22   bennyn
* 
* Modified to fix DirectDraw cursor problem
* 
*    Rev 1.13   07 Aug 1996 13:52:32   noelv
* 
* Cleaned up my hack job init code.
* 
*    Rev 1.12   25 Jul 1996 15:59:14   bennyn
* 
* Free more offscreen mem for DirectDraw
* 
*    Rev 1.11   11 Jul 1996 15:54:18   bennyn
* 
* Added DirectDraw support
* 
*    Rev 1.10   05 Jun 1996 09:03:10   noelv
* 
* Added the "extra rectangle".
* 
*    Rev 1.9   27 May 1996 14:53:12   BENNYN
* Use 2 free queues search instead of one
* 
*    Rev 1.8   21 May 1996 14:43:24   BENNYN
* Cleanup and code optimize.
* 
*    Rev 1.7   01 May 1996 11:00:06   bennyn
* 
* Modified for NT4.0
* 
*    Rev 1.6   25 Apr 1996 22:40:34   noelv
* Cleaned up frame buffer initialization some.  All of main rectangle is mana
* 
*    Rev 1.5   10 Apr 1996 14:14:34   NOELV
* 
* Hacked to ignore the 'extra' rectangle.
* 
*    Rev 1.4   04 Apr 1996 13:20:18   noelv
* Frido release 26
* 
*    Rev 1.2   28 Mar 1996 20:03:16   frido
* Added comments around changes.
* 
*    Rev 1.1   25 Mar 1996 11:56:26   frido
* Removed warning message.
* 
*    Rev 1.0   17 Jan 1996 12:53:26   frido
* Checked in from initial workfile by PVCS Version Manager Project Assistant.
* 
*    Rev 1.0   25 Jul 1995 11:23:18   NOELV
* Initial revision.
* 
*    Rev 1.4   20 Jun 1995 16:09:46   BENNYN
* 
* 
*    Rev 1.3   09 Jun 1995 16:03:38   BENNYN
* 
*    Rev 1.2   09 Jun 1995 09:48:54   BENNYN
* Modified the linear address offset calculation
* 
*    Rev 1.1   08 Jun 1995 15:20:08   BENNYN
* 
*    Rev 1.0   08 Jun 1995 14:54:16   BENNYN
* Initial revision.
*
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"
#include "SWAT.h"               // SWAT optimizations.

#define DISPLVL         1 

#if !MEMMGR
/******************************************************************************\
*																			   *
*					   O L D   M E M O R Y   M A N A G E R					   *
*																			   *
\******************************************************************************/

/*----------------------------- DEFINES -----------------------------------*/
// Definition of FLAG in OFMHDL structure
#define  IN_USE         1
#define  FREE           2
#define  UNKNOWN        3

#define  MEMSZY         64

#define  MINSZX         16
#define  MINSZY         1

//#define DBGBRK

#define  PREALLOC_Y     17

//
// This is a debugging option.
// We will erase (paint white) offscreen memory when it is freed.
//
#define CLEAR_WHEN_FREE 0

/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/
typedef union _HOST_DATA {
    BYTE    bData[8];
    DWORD   dwData[2];
} HOST_DATA;


/*-------------------------- STATIC VARIABLES -----------------------------*/

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/

// Function prototypes
POFMHDL OFS_AllocHdl();
BOOL OFS_InitMem (PPDEV ppdev, PRECTL surf);
POFMHDL OFS_FindBestFitFreeBlock(PPDEV ppdev, OFMHDL *pFreeQ, 
                                 PLONG reqszx, PLONG reqszy,
                                 ULONG alignflag);
void OFS_PackMem (PPDEV ppdev, OFMHDL *hdl);
void OFS_InsertInFreeQ  (PPDEV ppdev, OFMHDL *hdl);
void OFS_RemoveFrmFreeQ (PPDEV ppdev, OFMHDL *hdl);
void OFS_InsertInUsedQ  (PPDEV ppdev, OFMHDL *hdl);
void OFS_RemoveFrmUsedQ (PPDEV ppdev, OFMHDL *hdl);
BOOL OFS_DiscardMem(PPDEV ppdev, LONG reqszx, LONG reqszy);



#ifndef WINNT_VER35
#if 0  // Save the code as sample screen to host and host to screen BLT
// ppdev->pPtrMaskHost = SaveOffscnToHost(ppdev, ppdev->PtrMaskHandle);
// RestoreHostToOffscn(ppdev, ppdev->PtrMaskHandle, ppdev->pPtrMaskHost);
/****************************************************************************
* FUNCTION NAME: SaveOffscnToHost
*
* DESCRIPTION:   Save the off-screen memory to host.
*
* Output:        Pointer to host address
*                NULL = failed.
****************************************************************************/
PBYTE SaveOffscnToHost(PPDEV ppdev, POFMHDL pdh)
{
  BYTE       *pvHost = NULL;
  BYTE       *pvHostScan0;
  HOST_DATA  rddata;
  ULONG      ultmp;
  LONG       i, j, k;
  LONG       xsize, ysize, tsize;

  if (pdh == NULL)
     return NULL;

  // Calculate the host size
  tsize = pdh->sizex * pdh->sizey;
  pvHostScan0 = (BYTE *) MEM_ALLOC (FL_ZERO_MEMORY, tsize, ALLOC_TAG);
  if (pvHostScan0  == NULL)
     return NULL;

  DISPDBG((DISPLVL, "SaveOffscnToHost\n"));

  // Do a Screen to Host BLT
  // Wait for BLT engine not busy    
  while (((ultmp = LLDR_SZ (grSTATUS)) & 0x7) != 0)
    ;

  // Save the host address in PDEV
  pvHost = pvHostScan0;

  // Setup the laguna registers for byte to byte BLT extents
  REQUIRE(9);
  LL_DRAWBLTDEF(0x201000CC, 0);

  // LL16 (grOP1_opRDRAM.pt.X, 0);
  LL_OP1_MONO (pdh->x, pdh->y);
  LL32 (grOP0_opMRDRAM.dw, 0);

  // LL16 (grMBLTEXT_EX.pt.X, (WORD)lSrcDelta);
  // LL16 (grMBLTEXT_EX.pt.Y, cy);
  xsize = pdh->sizex;
  ysize = pdh->sizey;
  LL_MBLTEXT (xsize, ysize);

  // Copy the offscreen memory data to host space
  for (i=0; i < ysize; i++)
  {
    // Copy one screen line data from source to destination
    k = 8;
    for (j=0; j < xsize; j++)
    {
      if (k > 7)
      {
         k = 0;

         // Read the offscreen data
         rddata.dwData[0] = LLDR_SZ(grHOSTDATA[0]);
         rddata.dwData[1] = LLDR_SZ(grHOSTDATA[1]);
      };
      
      *pvHostScan0 = rddata.bData[k++];
      pvHostScan0++;
    }; // end for j
  }; // end for i

  return (pvHost);
}


/****************************************************************************
* FUNCTION NAME: RestoreHostToOffscn
*
* DESCRIPTION:   Restore host data to the off-screen memory.
*
* Output:        TRUE  = success,
*                FALSE = failed.
****************************************************************************/
BOOL RestoreHostToOffscn(PPDEV ppdev, POFMHDL pdh, PBYTE pHostAddr)
{
  BYTE       *pvScan0;
  ULONG      ultmp;
  LONG       cx, cy;
  LONG       i, j, k;
  ULONG      XYcord;
  PDWORD     pPattern;
  HOST_DATA  datapattern;
  LONG       xsize, ysize;


  if ((pdh == NULL) || (pHostAddr == NULL))
     return FALSE;

  DISPDBG((DISPLVL, "RestoreHostToOffscn\n"));

  // Do the host to screen blt
  // Wait for BLT engine not busy    
  while (((ultmp = LLDR_SZ (grSTATUS)) & 0x7) != 0)
    ;

  pPattern = &datapattern.dwData[0];

  pvScan0 = pHostAddr;

  // Get dimensions of the bitmap
  cx = pdh->sizex;
  cy = pdh->sizey;

  // Setup the laguna registers for byte to byte BLT extents
  REQUIRE(9);
  LL_DRAWBLTDEF(0x102000CC, 0);

  // LL16 (grOP1_opRDRAM.pt.X, 0);
  LL_OP1 (0,0);
  XYcord = (pdh->y << 16) | (pdh->x);
  LL32 (grOP0_opMRDRAM.dw, XYcord);

  // LL16 (grMBLTEXT_EX.pt.X, (WORD)lSrcDelta);
  // LL16 (grMBLTEXT_EX.pt.Y, cy);
  LL_MBLTEXT (cx, cy);

  // Copy the host bitmap data into the space in offscreen memory
  k = 0;
  for (i=0; i < cy; i++)
  {
    datapattern.dwData[0] = 0;

    // Copy one screen line data from source to destination
    for (j=0; j < cx; j++)
    {
      datapattern.bData[k++] = *pvScan0;
      pvScan0++;
  
      if (k > 3)
      {
		 REQUIRE(1);
         LL32 (grHOSTDATA[0], *pPattern);

         k = 0;
      };  // endif (k > 3)
    }; // endfor j
  }; // end for i

  return TRUE;
}
#endif

#if 0 // SWAT3 - the "inifinite" loop has gone
#if 1 //#ddl
  #pragma optimize("", off)
#endif
#endif
/****************************************************************************
* FUNCTION NAME: DDOffScnMemAlloc()
*
* DESCRIPTION:   Free up as much off-screen memory as possible, and
*                reserve the biggest chunk for use by DirectDraw.
*
* Output:        Pointer to the OFMHDL structure or.
*                NULL means not enough memory for allocation.
****************************************************************************/
POFMHDL DDOffScnMemAlloc(PPDEV ppdev)
{
  LONG    lg_szx, lg_szy;
  OFMHDL  *pds, *pallochdl;
  POFMHDL pofm, pofmNext;
  ULONG   ultmp;

  DISPDBG((DISPLVL, "DDOffScnMemAlloc\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  #if WINBENCH96
      // Free the pre-allocate magic block
      if (ppdev->pofmMagic != NULL)
      {
          FreeOffScnMem(ppdev, ppdev->pofmMagic);
          ppdev->pofmMagic = NULL;
          ppdev->bMagicUsed = 0;
      };
  #endif

#if 0   // Not free the brush cache
  // Free the brush cache
  if (ppdev->Bcache != NULL)
  {
     FreeOffScnMem(ppdev, ppdev->Bcache);
     ppdev->Bcache = NULL;
  };
#endif  // Not free the brush cache

        // We have to move all off-screen device bitmaps to memory.
        for (pofm = ppdev->OFM_UsedQ; pofm; pofm = pofmNext)
        {
                pofmNext = pofm->nexthdl;

                if ( (pofm->pdsurf) && (pofm->pdsurf->pofm) )
                {
                        if (!bCreateDibFromScreen(ppdev, pofm->pdsurf))
                        {
                                DISPDBG((DISPLVL, "DD: Error moving off-screen bitmap to DIB"));
                                break;
                        }
                }
#if 1 //#ss
                else if (pofm->alignflag & SAVESCREEN_FLAG)
                {
                        // Free the DrvSaveScreenBits rectangle.
                        FreeOffScnMem(ppdev, pofm);
                }
#endif
        }

  // Free the Font cache.
#if 1 // SWAT3 - Font cache release has moved to vAssertModeText.
  vAssertModeText(ppdev, FALSE);
#else
  while (ppdev->pfcChain != NULL)
  {
    DrvDestroyFont(ppdev->pfcChain->pfo);
  }
#endif

  // Find the biggest chunk of free memory for use by DirectDraw.
#ifndef ALLOC_IN_CREATESURFACE
  if ((pds = ppdev->OFM_SubFreeQ2) == NULL)
     pds = ppdev->OFM_SubFreeQ1;
#endif

  pallochdl = NULL;

#ifndef ALLOC_IN_CREATESURFACE
  lg_szx = 0;
  lg_szy = 0;
  while (pds != NULL)
  {
    if (pds->flag == FREE)
    {
       if ((pds->sizex > lg_szx) || (pds->sizey > lg_szy))
       {
          lg_szx = pds->sizex;
          lg_szy = pds->sizey;
          pallochdl = pds;
       }; // if ((pds->sizex > lg_szx) || (pds->sizex > lg_szy))
    }; // if (pds->flag == FREE)

    // Next free block
    pds = pds->subnxthdl;
  } /* end while */

  // Remove the free block from Free Queue and insert into the Used Queue
  if (pallochdl != NULL)
  {
     OFS_RemoveFrmFreeQ(ppdev, pallochdl);
     OFS_InsertInUsedQ(ppdev, pallochdl);
  };
#endif

  return(pallochdl);

} // DDOffScnMemAlloc()


#if 0 // SWAT3
#if 1 //#ddl
  #pragma optimize("", on)
#endif
#endif
/****************************************************************************
* FUNCTION NAME: DDOffScnMemRestore()
*
* DESCRIPTION:   Restore the offscreen memory allocation after DirectDraw
*                use.
****************************************************************************/
void DDOffScnMemRestore(PPDEV ppdev)
{
  SIZEL   sizl;
  int     i;
  ULONG   curloc;
  ULONG   ultmp;
  DDOFM   *pds;
  DDOFM   *nxtpds;

  DISPDBG((DISPLVL, "DDOffScnMemRestore\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  // Free all the DD allocate offsreen memory
  pds = ppdev->DDOffScnMemQ;
  while (pds != NULL)
  {
    nxtpds = pds->nexthdl;
    FreeOffScnMem(ppdev, pds->phdl);
    MEMORY_FREE(pds);
    pds = nxtpds;
  };
  ppdev->DDOffScnMemQ = NULL;

  // Free the allocated DirectDraw off-screen memory
  if (ppdev->DirectDrawHandle != NULL)
  {
     FreeOffScnMem(ppdev, ppdev->DirectDrawHandle);
     ppdev->DirectDrawHandle = NULL;
  };

#if 0   // Not free the brush cache
  // Allocate brush cache
  vInvalidateBrushCache(ppdev);

  // Invalidate the entire monochrome brush cache.
  for (i = 0; i < NUM_MONO_BRUSHES; i++)
  {
    ppdev->Mtable[i].iUniq = 0;
    memset(ppdev->Mtable[i].ajPattern, 0, sizeof(ppdev->Mtable[i].ajPattern));
  }
  ppdev->MNext = 0;

  // Invalidate the entire 4-bpp brush cache.
  for (i = 0; i < NUM_4BPP_BRUSHES; i++)
  {
    ppdev->Xtable[i].iUniq = 0;
    memset(ppdev->Xtable[i].ajPattern, 0, sizeof(ppdev->Xtable[i].ajPattern));
  }
  ppdev->XNext = 0;

  // Invalidate the entire dither brush cache.
  for (i = 0; i < NUM_DITHER_BRUSHES; i++)
  {
    ppdev->Dtable[i].ulColor = (ULONG) -1;
  }
  ppdev->DNext = 0;

  // Invalidate the entire color brush cache.
  for (i = 0; i < (int) ppdev->CLast; i++)
  {
    ppdev->Ctable[i].brushID = 0;
  }
  ppdev->CNext = 0;
#else
  // Invalidate the entire brush cache now.
  vInvalidateBrushCache(ppdev);
#endif  // Not free the brush cache

  #if WINBENCH96
  // Allocate the magic block
  sizl.cx = MAGIC_SIZEX;
  sizl.cy = MAGIC_SIZEY;
  ppdev->pofmMagic =  AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
  ppdev->bMagicUsed = 0;
  #endif

  // Invalidate all cached fonts.
  #if SWAT3
  vAssertModeText(ppdev, TRUE);
  #endif
  ppdev->ulFontCount++;

} // DDOffScnMemRestore()
#endif // ! ver3.51



/****************************************************************************
* FUNCTION NAME: InitOffScnMem()
*
* DESCRIPTION:   Initialize the offscreen memory. This module uses
*                the screen size, screen pitch and bits per pixel to
*                calculate the amount of off screen available and performs
*                the off screen memory management initialization.
*
*                When this routine is called, the following member in
*                the PDEV structure is assumed being setup for the current
*                mode.
*                    lOffset_2D,
*                    lTotalMem,
*                    lTileSize,
*                    lDeltaScreen,
*                    ulBitCount
*                    cxScreen,
*                    cyScreen.
*
*                This routine needs to be called whenever there is a
*                mode change.
*
* Output:        TRUE  = Ok,
*                FALSE = failed.
****************************************************************************/
BOOL InitOffScnMem(PPDEV ppdev)
{
    BOOL  bAllocCursorMaskBuf;
    RECTL surf;
    SIZEL rctsize;
    ULONG AvailMem;
    ULONG ulTemp;
    ULONG alignflag;
    LONG  ScnPitch;
    ULONG BytesInExtraRect, BytesInMainRect, Interleave, WidthInTiles,
    TileHeight, ExtraHeight, ExtraWidth, NumScanLines;
    ULONG ulLastLinearScan = ppdev->lTotalMem / ppdev->lDeltaScreen;
    BYTE TileCntl;

    DISPDBG((DISPLVL, "InitOffScnMem\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

    // If invalid argument or offscreen manager already initialized,
    // return FALSE
    if ((ppdev == NULL) || (ppdev->OFM_init == TRUE))
       return (FALSE);

    // Create Mutex
#ifdef WINNT_VER40
    if ((ppdev->MMhsem = EngCreateSemaphore()) == NULL)
#else
    if ((ppdev->MutexHdl = CreateMutex(NULL, FALSE, NULL)) == NULL)
#endif
       return (FALSE);

  // Wait for Mutex is released
#ifdef WINNT_VER40
  EngAcquireSemaphore(ppdev->MMhsem);
#else
  WaitForSingleObject(ppdev->MutexHdl, INFINITE);
#endif

    ppdev->bDirectDrawInUse = FALSE;
    ppdev->OFM_init = TRUE;
    ppdev->OFM_SubFreeQ1 = NULL;
    ppdev->OFM_SubFreeQ2 = NULL;
    ppdev->OFM_UsedQ = NULL;
    ppdev->OFM_FreeQ = NULL;
    ppdev->DDOffScnMemQ = NULL;

#ifdef WINNT_VER40
    ppdev->DirectDrawHandle = NULL;
#endif
  
  // Release the Mutex
#ifdef WINNT_VER40
  EngReleaseSemaphore(ppdev->MMhsem);
#else
  ReleaseMutex(ppdev->MutexHdl);
#endif

    //
    // Get the whole frame buffer as off screen memory.
    // The frame buffer is composed of 2 rectangles.  A main rectangle
    // whose width is the same as the memory pitch, and an "extra" rectangle
    // which is narrower and hangs off the lower left corner of the main 
    // rectangle.  
    //

    // The tiling interleave factor.
    TileCntl = LLDR_SZ(grTILE_CTRL);
    DISPDBG((DISPLVL, "InitOffScnMem - TileCntl = %d\n", TileCntl));
    TileCntl = (TileCntl >> 6) & 0x3;
    Interleave = 1 << TileCntl;
    
    DISPDBG((DISPLVL, "InitOffScnMem - Interleave = %d\n", Interleave));

    // Width of the frame buffer in tiles.  Each tile may be 128x16 bytes
    // or 256x8 bytes.
    WidthInTiles = ppdev->lDeltaScreen / ppdev->lTileSize;
    DISPDBG((DISPLVL, "InitOffScnMem - WidthInTiles = %d\n", WidthInTiles));

    // Get the size in bytes of the Extra rectangle.
    BytesInExtraRect = ppdev->lTotalMem % (WidthInTiles * 2048 * Interleave);
    DISPDBG((DISPLVL, "InitOffScnMem - BytesInExtraRect = %d\n", 
               BytesInExtraRect));

    // Get the size in bytes of the Main rectangle
    BytesInMainRect = ppdev->lTotalMem - BytesInExtraRect;
    DISPDBG((DISPLVL, "InitOffScnMem - BytesInMain = %d\n", BytesInMainRect));

    // Get the number of scan lines in the main rectangle.
    NumScanLines = BytesInMainRect / ppdev->lDeltaScreen;
    DISPDBG((DISPLVL, "InitOffScnMem - NumScanLines = %d\n", NumScanLines));

    // v-normmi
    ppdev->cyMemoryReal = NumScanLines; // without extra rectangle which will be
                                        // added below

    // Manage main rectangle
    if (NumScanLines > (ppdev->cyScreen + PREALLOC_Y))
    {
       surf.left = 0;
       surf.top  = 0;
       surf.right = ppdev->lDeltaScreen;
       surf.bottom = NumScanLines - PREALLOC_Y;
    }
    else if (NumScanLines > ppdev->cyScreen)
    {
       surf.left = 0;
       surf.top  = 0;
       surf.right = ppdev->lDeltaScreen;
       surf.bottom = ppdev->cyScreen;
    }

// v-normmi
//  else if ((ULONG) ppdev->lDeltaScreen != ppdev->cxScreen)
    else if ((ULONG) ppdev->lDeltaScreen != (ppdev->cxScreen * ppdev->iBytesPerPixel))
    {
       surf.left = ppdev->cxScreen * ppdev->iBytesPerPixel;
       surf.top  = 0;
       surf.right = ppdev->lDeltaScreen;
       surf.bottom = NumScanLines - PREALLOC_Y;

       if (!OFS_InitMem(ppdev, &surf))
       {
          DISPDBG((DISPLVL, "InitOffScnMem - InitMem1-1 failed\n"));
          return(FALSE);
       }

       surf.left = 0;
       surf.top  = 0;
       surf.right = ppdev->cxScreen * ppdev->iBytesPerPixel;
       surf.bottom = NumScanLines;
    }
    else
    {
       surf.left = 0;
       surf.top  = 0;
       surf.right = ppdev->lDeltaScreen;
       surf.bottom = NumScanLines;
    };

    DISPDBG((DISPLVL, "Initializing surface (x=%d,y=%d) to (x=%d,y=%d)....\n",
            surf.left, surf.top, surf.right, surf.bottom));

    if (!OFS_InitMem(ppdev, &surf))
    {
        DISPDBG((DISPLVL, "InitOffScnMem - InitMem1 failed\n"));
        return(FALSE);
    }

    // Mark a (PREALLOC_Y x Screen pitch) free block at the buttom
    // of the offscreen memory.
    // The purpose for that is to force the cursor mask and brush cache
    // to be allocated at that area.

    bAllocCursorMaskBuf = FALSE;

    if (NumScanLines > (ppdev->cyScreen + PREALLOC_Y))
    {
       bAllocCursorMaskBuf = TRUE;

       surf.left = 0;
       surf.top  = NumScanLines - PREALLOC_Y;
       surf.right = ppdev->lDeltaScreen;
       surf.bottom = NumScanLines;
    }
    else if (NumScanLines > ppdev->cyScreen)
    {
       bAllocCursorMaskBuf = TRUE;

       surf.left = 0;
       surf.top  = ppdev->cyScreen;
       surf.right = ppdev->lDeltaScreen;
       surf.bottom = NumScanLines;
    }
// v-normmi
//  else if ((ULONG) ppdev->lDeltaScreen != ppdev->cxScreen)
    else if ((ULONG) ppdev->lDeltaScreen != (ppdev->cxScreen * ppdev->iBytesPerPixel))
    {
       bAllocCursorMaskBuf = TRUE;

       surf.left = ppdev->cxScreen * ppdev->iBytesPerPixel;
       surf.top  = NumScanLines - PREALLOC_Y;
       surf.right = ppdev->lDeltaScreen;
       surf.bottom = NumScanLines;
    };

    if (bAllocCursorMaskBuf)
    {
       if (!OFS_InitMem(ppdev, &surf))
       {
          DISPDBG((DISPLVL, "InitOffScnMem - InitMem2 failed\n"));
          return(FALSE);
       }
    };

    //
    // BTN - For some reason, this extra rectange cause the WHQL PC97
    // Rand Create/Release 100x test fails on 1600x1200x16 and 1600x1200x8
    //
    if ((ppdev->cxScreen == 1600) &&
        (ppdev->cyScreen == 1200) &&
        ((ppdev->iBytesPerPixel == 2) || (ppdev->iBytesPerPixel == 1)))
        BytesInExtraRect = 0;

    //
    // Manage the extra rectangle.
    // NVH - Skip for 8 meg boards.
    //
    if (ppdev->lTotalMem < 8*1024*1024) 
    if (BytesInExtraRect)
    {
                // get Tile Height
                TileHeight = 2048 / ppdev->lTileSize;
                DISPDBG((DISPLVL, "InitOffScnMem - TileHeight = %d\n", TileHeight));

                // Get height of extra rectangle
                ExtraHeight = Interleave * TileHeight;
                DISPDBG((DISPLVL, "InitOffScnMem - ExtraHeight = %d\n", ExtraHeight));

    // v-normmi
    ppdev->cyMemoryReal += ExtraHeight; // account for extra rectangle

                // Get the width of the extra rectangle
                ExtraWidth = BytesInExtraRect / ExtraHeight;
                DISPDBG((DISPLVL, "InitOffScnMem - ExtraWidth = %d\n", ExtraWidth));

                ulLastLinearScan = (ExtraHeight + NumScanLines);  
                surf.left = 0;
                surf.top  = NumScanLines;
                surf.right = ExtraWidth;
                surf.bottom = MIN ((LONG) ulLastLinearScan,
                                (LONG) (ExtraHeight+NumScanLines));

                DISPDBG((DISPLVL, "Initializing surface (x=%d,y=%d) to (x=%d,y=%d).\n",
                                surf.left, surf.top, surf.right, surf.bottom));

        if (!OFS_InitMem(ppdev, &surf))
        {
             DISPDBG((DISPLVL, "InitOffScnMem - InitMem1 failed\n"));
             return(FALSE);
        }
    }
    else
    {
                DISPDBG((DISPLVL, " **** No extra rectangle.\n"));
    }




    #ifdef DBGBRK
        DBGBREAKPOINT();
    #endif

  // Allocate the active video buffer space from the off screen memory
  rctsize.cx = ppdev->cxScreen;
  rctsize.cy = ppdev->cyScreen;
 
  if ((ppdev->lTileSize == (LONG) 128) || (ppdev->lTileSize == (LONG) 256))
     alignflag = 0;
  else
     alignflag = NO_X_TILE_AlIGN | NO_Y_TILE_AlIGN;

  if ((ppdev->ScrnHandle = AllocOffScnMem(ppdev, &rctsize, alignflag, NULL)) == NULL)
  {
     DISPDBG((DISPLVL, "InitOffScnMem - AllocOffScnMem failed\n"));

     return(FALSE);
  };

  DISPDBG((DISPLVL, "InitOffScnMem Completed\n"));

#ifdef DBGBRK
    DBGBREAKPOINT();
#endif

  return (TRUE);

} // InitOffScnMem()



/****************************************************************************
* FUNCTION NAME: AllocOffScnMem()
*
* DESCRIPTION:   Allocate a rectange space from the offscreen memory.
*                This routine do a search of the Free Queue to find a
*                best fit free memory block. It the free block is bigger
*                than the request size, it will split the unused memory
*                into smaller rectange blocks and insert them back to
*                the Free Queue for future use. It will also do a tile
*                or pixel alignment if requested.
*      
*                If no more enough free memory for the current request,
*                This routine will search Used Queue for any discardable
*                allocated block. Releases those blocks to satisfy
*                the current request.
*
*                An user-supplied callback function will be call before
*                the discardable block is released.
*
* Input:         surf: Request of the offscreen memory size (in Pixel).
*
*                alignflag: Alignment flag.
*
*                pcallback: Callback function pointer.
*                (Only apply if the flag is set to DISCARDABLE_FLAG).
*
* Output:        Pointer to the OFMHDL structure or.
*                NULL means not enough memory for allocation.
****************************************************************************/
POFMHDL AllocOffScnMem(PPDEV  ppdev,
                       PSIZEL surf,
                       ULONG  alignflag,
                       POFM_CALLBACK  pcallback)
{
  // Convert the pixel into bytes requirement
  LONG    bpp;
  LONG    reqszx;
  LONG    reqszy;
  LONG    orgreqszx;

  OFMHDL  *pds, *pallochdl;
  BOOL    findflg, alignblkflg;
  LONG    szx, szy;
  LONG    tmpx, tmpy;

  DISPDBG((DISPLVL, "AllocOffScnMem\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  if (alignflag & MCD_Z_BUFFER_ALLOCATE)
  {
     // special memory region -> z buffer: always 16bit/pix
     bpp = 2;
  }  
  else if (alignflag & MCD_TEXTURE_ALLOCATE)
  {
     // special memory region -> texture map: depth varies and is coded in alignflag
     bpp = (alignflag & MCD_TEXTURE_ALLOCATE) >> MCD_TEXTURE_ALLOC_SHIFT;
  }  
  else  
  {
     // normal memory region -> allocate at depth of frame buffer
     bpp = ppdev->ulBitCount/8; 
  }  

  reqszx = surf->cx * bpp;
  reqszy = surf->cy;
  orgreqszx = reqszx;

  // If no more free memory or invalid arguments, return NULL
  //  if ((ppdev == NULL) || (surf == NULL) || (ppdev->OFM_FreeQ == NULL) || (!ppdev->OFM_init))
  if (ppdev->OFM_FreeQ == NULL)
     return (NULL);

#ifndef ALLOC_IN_CREATESURFACE
  if (ppdev->bDirectDrawInUse)
     return (NULL);
#endif

  // Wait for Mutex is released
#ifdef WINNT_VER40
  EngAcquireSemaphore(ppdev->MMhsem);
#else
  WaitForSingleObject(ppdev->MutexHdl, INFINITE);
#endif

  // Search for the free memory block
  findflg = FALSE;
  pallochdl = NULL;
  while (!findflg)
  {
    // Search for the best fit block for the request and
    // Check whether any free block satisfy the requirement
    if (reqszy < MEMSZY)
    {
       pallochdl = OFS_FindBestFitFreeBlock(ppdev,
                                            ppdev->OFM_SubFreeQ1,
                                            &reqszx, &reqszy,
                                            alignflag);
    };

    if (pallochdl == NULL)
    {
       pallochdl = OFS_FindBestFitFreeBlock(ppdev,
                                            ppdev->OFM_SubFreeQ2,
                                            &reqszx, &reqszy,
                                            alignflag);
    };


    if (pallochdl != NULL)
    {
       // Remove the free block from Free Queue
       OFS_RemoveFrmFreeQ(ppdev, pallochdl);

       alignblkflg = FALSE;

#if 0 // Frido 08/29/97: a new algorithm is in place now, see below. 
       // If tilt aligned, create the free block for the align adjusted
       // memory
       if (!(alignflag & PIXEL_AlIGN))
       {
          if ((tmpx = pallochdl->aligned_x - pallochdl->x) > MINSZX)
          {
             if ((pds = OFS_AllocHdl()) != NULL)
             {
                pds->x = pallochdl->x;
                pds->y = pallochdl->y;
                pds->sizex = tmpx;
                pds->sizey = reqszy;
                OFS_InsertInFreeQ(ppdev, pds);

                alignblkflg = TRUE;
             };
          };
       };

       szx = pallochdl->sizex;
       szy = pallochdl->sizey;

       // If the block is larger than the request size, create the
       // free blocks for excess size
       if ((szx > reqszx) && (szy > reqszy))
       {
          if ((szx - reqszx) > (szy - reqszy))
          {
             tmpx = reqszx;
             tmpy = szy;
          }
          else
          {
             tmpx = szx;
             tmpy = reqszy;
          };
       }
       else
       {
          tmpx = reqszx;
          tmpy = reqszy;
       };  // endif ((szx > reqszx) && (szy > reqszy))
     
       if (szx > reqszx)
       {
          if ((pds = OFS_AllocHdl()) != NULL)
          {
            pds->x = pallochdl->x + reqszx;
            pds->y = pallochdl->y;
            pds->sizex = szx - reqszx;
            pds->sizey = tmpy;
            OFS_InsertInFreeQ(ppdev, pds);
          };
       }
       else
       {
         reqszx = szx;
       };
     
       if (szy > reqszy)
       {
          if ((pds = OFS_AllocHdl()) != NULL)
          {
            pds->x = pallochdl->x;
            pds->y = pallochdl->y + reqszy;
            pds->sizex = tmpx;
            pds->sizey = szy - reqszy;
            OFS_InsertInFreeQ(ppdev, pds);
          };
       }
       else
       {
         reqszy = szy;
       };

       // If this is discardable block, save the callback function pointer     
       if ((alignflag & DISCARDABLE_FLAG) != 0)
          pallochdl->pcallback = pcallback;
       else
          pallochdl->pcallback = NULL;

       // Insert allocate block into the Used Queue
       if (alignblkflg)
       {
          pallochdl->x = pallochdl->aligned_x;
          pallochdl->y = pallochdl->aligned_y;

          pallochdl->sizex = orgreqszx;
       }
       else
       {
          pallochdl->sizex = reqszx;
       };

       pallochdl->sizey = reqszy;
#else
		tmpx = pallochdl->aligned_x + reqszx;
		tmpy = pallochdl->aligned_y + reqszy;

		// Do we have extra space at the top?
		szy = pallochdl->aligned_y - pallochdl->y;
		if (szy >= MINSZY)
		{
			pds = OFS_AllocHdl();
			if (pds != NULL)
			{
				pds->x = pallochdl->x;
				pds->y = pallochdl->y;
				pds->sizex = pallochdl->sizex;
				pds->sizey = szy;
				OFS_InsertInFreeQ(ppdev, pds);
				pallochdl->y += szy;
				pallochdl->sizey -= szy;
			}
		}

		// Do we have extra space at the bottom?
		szy = pallochdl->y + pallochdl->sizey - tmpy;
		if (szy >= MINSZY)
		{
			pds = OFS_AllocHdl();
			if (pds != NULL)
			{
				pds->x = pallochdl->x;
				pds->y = tmpy;
				pds->sizex = pallochdl->sizex;
				pds->sizey = szy;
				OFS_InsertInFreeQ(ppdev, pds);
				pallochdl->sizey -= szy;
			}
		}

		// Do we have extra space at the top?
		szx = pallochdl->aligned_x - pallochdl->x;
		if (szx >= MINSZX)
		{
			pds = OFS_AllocHdl();
			if (pds != NULL)
			{
				pds->x = pallochdl->x;
				pds->y = pallochdl->y;
				pds->sizex = szx;
				pds->sizey = pallochdl->sizey;
				OFS_InsertInFreeQ(ppdev, pds);
				pallochdl->x += szx;
				pallochdl->sizex -= szx;
			}
		}

		// Do we have extra space at the right?
		szx = pallochdl->x + pallochdl->sizex - tmpx;
		if (szx >= MINSZX)
		{
			pds = OFS_AllocHdl();
			if (pds != NULL)
			{
				pds->x = tmpx;
				pds->y = pallochdl->y;
				pds->sizex = szx;
				pds->sizey = pallochdl->sizey;
				OFS_InsertInFreeQ(ppdev, pds);
				pallochdl->sizex -= szx;
			}
		}
#endif
       pallochdl->alignflag = alignflag;
       OFS_InsertInUsedQ(ppdev, pallochdl);
   
       // Set Find flag to indicate a free block is found
       findflg = TRUE;
    }
    else
    {
      // Free block not found, try to discard any discardable memory
      // to satisfy the request
      if (!OFS_DiscardMem(ppdev, reqszx, reqszy))
      {
         DISPDBG((DISPLVL, "AllocOffScnMem failed\n"));

         // Allocation fail not enough memory
         break;
      };

    }; // endif pallochdl != NULL
  };  // endwhile

  // Release the Mutex
#ifdef WINNT_VER40
  EngReleaseSemaphore(ppdev->MMhsem);
#else
  ReleaseMutex(ppdev->MutexHdl);
#endif

  DISPDBG((DISPLVL, "AllocOffScnMem Completed\n"));

#ifdef DBGBRK
    DBGBREAKPOINT();
#endif

  if (pallochdl)
  {
    DISPDBG((DISPLVL, 
    "AllocOffScnMem: from (x=%d,y=%d) to (x=%d,y=%d).\n",
        pallochdl->x,  
        pallochdl->y, 
        (pallochdl->x + pallochdl->sizex),  
        (pallochdl->y + pallochdl->sizey)   ));
  }


  return(pallochdl);

} // AllocOffScnMem()



/****************************************************************************
* FUNCTION NAME: FreeOffScnMem()
*
* DESCRIPTION:   Free the allocated offscreen memory.
*
* Input:         Pointer to the OFMHDL structure.
* 
* Output:        TRUE  = Ok,
*                FALSE = failed.
****************************************************************************/
BOOL FreeOffScnMem(PPDEV ppdev,
                   OFMHDL *hdl)
{
  OFMHDL *pds;
  BOOL   fndflg;

  DISPDBG((DISPLVL, "FreeOffScnMem\n"));

#ifdef DBGBRK
    DBGBREAKPOINT();
#endif

//  if ((!ppdev->OFM_init) || (ppdev == NULL) || (hdl == NULL))
  if (ppdev == NULL)
     return (FALSE);

    #if CLEAR_WHEN_FREE
	REQUIRE(7);
        LL16(grBLTDEF, 0x1101);  // solid color fill
        LL16(grDRAWDEF, 0x00FF); // whiteness
        LL_OP0(hdl->x, hdl->y);
        LL_BLTEXT( (hdl->sizex/ppdev->iBytesPerPixel), hdl->sizey );
    #endif

  // Wait for Mutex is released
#ifdef WINNT_VER40
  EngAcquireSemaphore(ppdev->MMhsem);
#else
  WaitForSingleObject(ppdev->MutexHdl, INFINITE);
#endif

  // Validate the release block
  fndflg = FALSE;
  pds = ppdev->OFM_UsedQ;
  while (pds != 0)
  {
    if ((hdl == pds) && (pds->flag == IN_USE))
    {
       fndflg = TRUE;
       break;
    };

    // Next free block
    pds = pds->nexthdl;
  }; // end while

  // Return if it is an invalid handle
  if (!fndflg)  
     return (FALSE);

  DISPDBG((DISPLVL, 
  "FreeOffScnMem: from (x=%d,y=%d) to (x=%d,y=%d).\n",
      hdl->x,  
      hdl->y, 
      (hdl->x + hdl->sizex),  
      (hdl->y + hdl->sizey)   ));

  // Remove the block from the Used queue
  OFS_RemoveFrmUsedQ(ppdev, hdl);

  // Unfragment the memory
  OFS_PackMem(ppdev, hdl);

  // Insert the block into the Free queue
  OFS_InsertInFreeQ(ppdev, hdl);

  // Release the Mutex
#ifdef WINNT_VER40
  EngReleaseSemaphore(ppdev->MMhsem);
#else
  ReleaseMutex(ppdev->MutexHdl);
#endif

  DISPDBG((DISPLVL, "FreeOffScnMem Completed\n"));

#ifdef DBGBRK
    DBGBREAKPOINT();
#endif

  return (TRUE);

} // FreeOffScnMem()



/****************************************************************************
* FUNCTION NAME: CloseOffScnMem()
*
* DESCRIPTION:   Close the offscreen memory manager. This function
*                will release all allocated offscreen memories and the
*                memories used by the Offscreen manager back to Windows.
****************************************************************************/
void CloseOffScnMem(PPDEV ppdev)
{
  OFMHDL *pds;
  OFMHDL *nxtpds;

  DISPDBG((DISPLVL, "CloseOffScnMem\n"));

#ifdef DBGBRK
    DBGBREAKPOINT();
#endif

  // If invalid arguments, return NULL
  if ((!ppdev->OFM_init) || (ppdev == NULL))
     return;

  // Wait for Mutex is released
#ifdef WINNT_VER40
  EngAcquireSemaphore(ppdev->MMhsem);
#else
  WaitForSingleObject(ppdev->MutexHdl, INFINITE);
#endif

  pds = ppdev->OFM_UsedQ;
  while (pds != NULL)
  {
    nxtpds = pds->nexthdl;
    MEMORY_FREE(pds);
    pds = nxtpds;
  };

  pds = ppdev->OFM_FreeQ;
  while (pds != NULL)
  {
    nxtpds = pds->nexthdl;
    MEMORY_FREE(pds);
    pds = nxtpds;
  };

  ppdev->OFM_UsedQ = NULL;
  ppdev->OFM_FreeQ = NULL;
  ppdev->OFM_SubFreeQ1 = NULL;
  ppdev->OFM_SubFreeQ2 = NULL;
  ppdev->DDOffScnMemQ = NULL;

  ppdev->OFM_init = FALSE;

  // Release the Mutex
#ifdef WINNT_VER40
  EngReleaseSemaphore(ppdev->MMhsem);
#else
  ReleaseMutex(ppdev->MutexHdl);
#endif

  // Close the Mutex
#ifdef WINNT_VER40
  EngDeleteSemaphore(ppdev->MMhsem);
#else
  CloseHandle(ppdev->MutexHdl);
#endif

  DISPDBG((DISPLVL, "CloseOffScnMem Completed\n"));

#ifdef DBGBRK
    DBGBREAKPOINT();
#endif

} // CloseOffScnMem()



/****************************************************************************
* FUNCTION NAME: ConvertToVideoBufferAddr()
*
* DESCRIPTION:   Convert the X, Y rectange cordinate into Linear address
*                in video buffer.
*
* Input:         Pointer to the OFMHDL structure.
*
* Output:        32-bits Linear address pointer.
****************************************************************************/
PVOID ConvertToVideoBufferAddr(PPDEV ppdev, POFMHDL psurf)
{
  ULONG retaddr;

  DISPDBG((DISPLVL, "ConvertToVideoBufferAddr\n"));

  // If invalid arguments, return NULL

//v-normmi
//if ((!ppdev->OFM_init) || (ppdev == NULL) || (psurf == NULL))
  if (( ppdev == NULL) || (!ppdev->OFM_init) || (psurf == NULL))

     return (NULL);

  // Wait for Mutex is released
#ifdef WINNT_VER40
  EngAcquireSemaphore(ppdev->MMhsem);
#else
  WaitForSingleObject(ppdev->MutexHdl, INFINITE);
#endif

  // Calculate the linear address from the X & Y coordinate
  retaddr = ((ULONG) (psurf->x + (ppdev->lDeltaScreen * psurf->y))) +
            ((ULONG) ppdev->pjScreen);

  DISPDBG((DISPLVL, "ConvertToVideoBufferAddr Completed\n"));

#ifdef DBGBRK
    DBGBREAKPOINT();
#endif

  // Release the Mutex
#ifdef WINNT_VER40
  EngReleaseSemaphore(ppdev->MMhsem);
#else
  ReleaseMutex(ppdev->MutexHdl);
#endif

  return ((PVOID)retaddr);

} // ConvertToVideoBufAddr()


/****************************************************************************
* FUNCTION NAME: OFS_AllocHdl()
*
* DESCRIPTION:   Alocate offscreen memoru handler from the windows heap.
*
* Input:         None
*
* Output:        Pointer to OFMHDL structre
****************************************************************************/
POFMHDL OFS_AllocHdl()
{
  OFMHDL *pds;

#ifdef WINNT_VER40
  if ((pds = (POFMHDL) MEM_ALLOC (FL_ZERO_MEMORY, sizeof(OFMHDL), ALLOC_TAG)) != NULL)
#else
  if ((pds = (POFMHDL) MEM_ALLOC (LPTR, sizeof(OFMHDL))) != NULL)
#endif
  {
     pds->x = 0;
     pds->y = 0;
     pds->aligned_x = 0;
     pds->aligned_y = 0;
     pds->sizex = 0;
     pds->sizey = 0;
     pds->alignflag = 0;
     pds->flag = 0;
     pds->pcallback = 0;
     pds->prevhdl = 0;
     pds->nexthdl = 0;
     pds->subprvhdl = 0;
     pds->subnxthdl = 0;
     pds->prvFonthdl = 0;
     pds->nxtFonthdl = 0;
     pds->pdsurf = 0;
  };

  return (pds);

} // OFS_AllocHdl()


/****************************************************************************
* FUNCTION NAME: OFS_InitMem()
*
* DESCRIPTION:   Initialize the offscreen memory.
*
* Input:         Coordinate and size of the offscreen memory.
*
* Output:        TRUE  = Ok,
*                FALSE = failed.
****************************************************************************/
BOOL OFS_InitMem(PPDEV ppdev,
                 PRECTL surf)
{
  OFMHDL *pds;

  // Allocate the control block handle from local windows memory pool
#ifdef WINNT_VER40
  if ((pds = (POFMHDL) MEM_ALLOC(FL_ZERO_MEMORY, sizeof(OFMHDL), ALLOC_TAG)) == NULL)
#else
  if ((pds = (POFMHDL) MEM_ALLOC(LPTR, sizeof(OFMHDL))) == NULL)
#endif
     return (FALSE);

  // Wait for Mutex is released
#ifdef WINNT_VER40
  EngAcquireSemaphore(ppdev->MMhsem);
#else
  WaitForSingleObject(ppdev->MutexHdl, INFINITE);
#endif

  // Insert the free memory block into the queue
  pds->x = surf->left;
  pds->y = surf->top;
  pds->sizex = surf->right - surf->left;
  pds->sizey = surf->bottom - surf->top;
  OFS_InsertInFreeQ(ppdev, pds);

  // Release the Mutex
#ifdef WINNT_VER40
  EngReleaseSemaphore(ppdev->MMhsem);
#else
  ReleaseMutex(ppdev->MutexHdl);
#endif

  return (TRUE);

} // OFS_InitMem()



/****************************************************************************
* FUNCTION NAME: OFS_FindBestFitFreeBlock()
*
* DESCRIPTION:   Find the best fit free block.
*
* Input:         Request offscreen memory size (in bytes).
*
* Output:        Pointer to the OFMHDL structure or.
*                NULL means not enough memory for allocation.
****************************************************************************/
POFMHDL OFS_FindBestFitFreeBlock(PPDEV  ppdev,
                                 OFMHDL *pFreeQ,
                                 PLONG  preqszx,
                                 PLONG  preqszy,
                                 ULONG  alignflag)
{
  OFMHDL *pds = pFreeQ;
  LONG    reqszx = *preqszx;
  LONG    reqszy = *preqszy;
  OFMHDL  *pbestfit_hdl = NULL;
  LONG    bestfitx = 0x7FFFFFF;
  LONG    bestfity = 0x7FFFFFF;
  LONG    bpp;
  LONG    tileszx = 0;
  LONG    tileszy = 0;
  LONG    maskx = 0;
  LONG    masky = 0;
  BOOL    Findit = FALSE;

  ULONG   bestfit_aligned_x, bestfit_aligned_y;
  LONG    bestfit_Reqszx, bestfit_Reqszy;
  ULONG   aligned_x, aligned_y;
  LONG    szx, szy;
  LONG    NewReqszx, NewReqszy;
  BOOL    adjxflg, adjyflg;

  if (alignflag & MCD_Z_BUFFER_ALLOCATE)
  {
     // special memory region -> z buffer: always 16bit/pix
     bpp = 2;
  }  
  else if (alignflag & MCD_TEXTURE_ALLOCATE)
  {
     // special memory region -> texture map: depth varies and is coded in alignflag
     bpp = (alignflag & MCD_TEXTURE_ALLOCATE) >> MCD_TEXTURE_ALLOC_SHIFT;
  }  
  else  
  {
     // normal memory region -> allocate at depth of frame buffer
     bpp = ppdev->ulBitCount/8; 
  }  

  // Check the alignment flag and adjust the request size accordingly.
  if (alignflag & EIGHT_BYTES_ALIGN)
	{  // 8 bytes alignment.
     tileszx = 8;
     tileszy = 1;
     maskx = tileszx - 0x1;
     masky = 0;
	}
  else if (alignflag & PIXEL_AlIGN)
  {
     tileszx = bpp;
     tileszy = 1;
     maskx = tileszx - 0x1;
     masky = 0;

     if (bpp == 3)
     {
        maskx += 1;
        masky += 1;
     };
  }
  else if (alignflag & (MCD_DRAW_BUFFER_ALLOCATE|MCD_Z_BUFFER_ALLOCATE|MCD_TEXTURE_ALLOCATE))
  {
     // Determine tile size
     if (alignflag & MCD_DRAW_BUFFER_ALLOCATE)
         tileszx = 64;  // rgb buffer on 64 byte boundary (z always at x=0, so tile doesn't matter)
     else
         tileszx = 32;  // texture on 32 byte boundary

     if (alignflag & MCD_TEXTURE_ALLOCATE)
         tileszy = 16;  // textures must be on 16 scanline boundary
     else
         tileszy = 32;  // z,backbuf must be on 32 scanline boundary

     maskx = tileszx - 1;
     masky = tileszy - 1;
  }
  else
  {
     // Determine tile size
     tileszx = ppdev->lTileSize;
     tileszy = (LONG) 2048/ppdev->lTileSize;
     maskx = tileszx - 1;
     masky = tileszy - 1;
  };

  // Search for the best fit block for the request
  while (pds != NULL)
  {
    if (pds->flag == FREE)
    {
       szx = pds->sizex;
       szy = pds->sizey;
       // MCD z buffer, and possibly color buffer need to start at x=0 
       if ((szx >= reqszx) && (szy >= reqszy) && (!(alignflag & MCD_NO_X_OFFSET) || (pds->x==0)))
       {
          // If yes, calculate the aligned rectange starting positions
          aligned_x = pds->x;
          aligned_y = pds->y;

          adjxflg = FALSE;
          adjyflg = FALSE;
          if (alignflag & PIXEL_AlIGN)
          {
             if ((pds->x % bpp) != 0)
                adjxflg = TRUE;
      
             if ((pds->y % bpp) != 0)
                adjyflg = TRUE;
          }
          else
          {

             if ((!(alignflag & NO_X_TILE_AlIGN)) && ((pds->x % tileszx) != 0))
                adjxflg = TRUE;

             if ((!(alignflag & NO_Y_TILE_AlIGN)) && ((pds->y % tileszy) != 0))
                adjyflg = TRUE;
          };

          if (adjxflg)
             aligned_x = (pds->x & (~maskx)) + tileszx;

          if (adjyflg)
             aligned_y = (pds->y & (~masky)) + tileszy;

          // Adjust the request size again to fit the required alignment
          NewReqszx = reqszx + (aligned_x - pds->x);
          NewReqszy = reqszy + (aligned_y - pds->y);

          // Check the allocate block is large enough to hold the adjusted
          // request size
          if ((szx >= NewReqszx) && (szy >= NewReqszy))
          {
             if ((szx == NewReqszx) && (szy == NewReqszy))
             {
                Findit = TRUE;
                bestfit_Reqszx = NewReqszx;
                bestfit_Reqszy = NewReqszy;
                bestfit_aligned_x = aligned_x;
                bestfit_aligned_y = aligned_y;
                pbestfit_hdl = pds;
             }
             else if ((bestfitx > szx) || (bestfity > szy))
             {
                bestfit_Reqszx = NewReqszx;
                bestfit_Reqszy = NewReqszy;
                bestfit_aligned_x = aligned_x;
                bestfit_aligned_y = aligned_y;
                bestfitx = szx; 
                bestfity = szy;
                pbestfit_hdl = pds;
             }; // if ((bestfitx > szx) || (bestfity > szy))
          }; // if ((szx >= NewReqszx) && (szy >= NewReqszy))

       }; // if ((szx >= reqszx) && (szy >= reqszy))
    }; // if (pds->flag == FREE)

    // Next free block
    if (Findit)
       pds = NULL;
    else
       pds = pds->subnxthdl;
  } /* end while */

  if (pbestfit_hdl != NULL)
  {
     *preqszx = bestfit_Reqszx;
     *preqszy = bestfit_Reqszy;

     pbestfit_hdl->aligned_x = bestfit_aligned_x;
     pbestfit_hdl->aligned_y = bestfit_aligned_y;
  };

  return(pbestfit_hdl);

} // OFS_FindBestFitFreeBlock()



/****************************************************************************
* FUNCTION NAME: OFS_PackMem()
*
* DESCRIPTION:   Unfragment the memory.
*                This routine combines current release memory block
*                with the adjacent free blocks of same X or Y dimension into 
*                one big free block.
****************************************************************************/
void OFS_PackMem(PPDEV ppdev,
                 OFMHDL *hdl)
{
  BOOL  cmbflg;
  OFMHDL *pds;
  ULONG pdsxdim, pdsydim;

  pds = ppdev->OFM_FreeQ;
  while (pds != NULL)
  {
    // Check for any free block (aliasing in either X or Y direction)
    // before or after the current release block.
    // If yes, combine the two into one big free block
    pdsxdim = pds->x + pds->sizex;
    pdsydim = pds->y + pds->sizey;

    cmbflg = FALSE;

    // Check for X-axis
    if ((hdl->x == pds->x) && ((hdl->x + hdl->sizex) == pdsxdim))
    {
       if ((hdl->y == pdsydim) || (hdl->y == (pds->y - hdl->sizey)))
       {
          cmbflg = TRUE;
          hdl->sizey += pds->sizey;
          if (hdl->y == pdsydim)
             hdl->y = pds->y;
       };
    };

    // Check for Y-axis
    if ((hdl->y == pds->y) && ((hdl->y + hdl->sizey) == pdsydim))
    {
       if ((hdl->x == pdsxdim) || (hdl->x == (pds->x - hdl->sizex)))
       {
          cmbflg = TRUE;
          hdl->sizex += pds->sizex;
          if (hdl->x == pdsxdim)
             hdl->x = pds->x;
       };
    };

    if (cmbflg)
    {
      OFS_RemoveFrmFreeQ(ppdev, pds);

      // Release control block to Windows
      MEMORY_FREE(pds);

      // Restart the unfragment memory processing
      pds = ppdev->OFM_FreeQ;
    }
    else
    {
      // Next free block
      pds = pds->nexthdl;
    };
  }; // end while

} // OFS_PackMem



/****************************************************************************
* FUNCTION NAME: OFS_InsertInFreeQ()
*
* DESCRIPTION:   Insert the handle into the Free queue.
*
* Input:         Pointer to the OFMHDL structure.
*
* Output:        None
****************************************************************************/
void OFS_InsertInFreeQ(PPDEV  ppdev,
                       OFMHDL *hdl)
{
  hdl->flag = FREE;
  hdl->prevhdl = NULL;
  hdl->subprvhdl = NULL;    
  hdl->aligned_x = 0;
  hdl->aligned_y = 0;
  hdl->alignflag = 0;
  hdl->pcallback = NULL;

  // Fix for PDR9385 - added by Mark Einkauf
  // if pdsurf non-zero, when this block reused later, various DIB functions can misbehave
  // Exact scenario in 9385 was...
  //   first app exit:
  //    DrvDisableDirectDraw freed all OFM blocks (leaving pdsurf field non-0 in some cases)
  //   next app startup:
  //    DrvGetDirectDrawInfo, calls...
  //        DDOffScnMemAlloc 
  //            - loops through all OFM_UsedQ blocks, searching for
  //              off screen bit maps it can convert to DIB (and then free the offscreen memory)
  //            - Finds UsedQ block with non-zero pdsurf, pointing to non-existent pdsurf, 
  //                which then had non-zero pofm field, causing it to appear as a valid
  //                off-screen bitmap    
  //            - does memcpy with garbage x,y,sizex,sizey, wreaking havoc on system memory
  //                in a random sort of way
  hdl->pdsurf = NULL;

  // Insert into the SubFreeQs
  if (hdl->sizey < MEMSZY)
  {
     if (ppdev->OFM_SubFreeQ1 == NULL)
     {
       hdl->subnxthdl = NULL;
       ppdev->OFM_SubFreeQ1 = hdl;
     }
     else
     {
       ppdev->OFM_SubFreeQ1->subprvhdl = hdl;
       hdl->subnxthdl = ppdev->OFM_SubFreeQ1;
       ppdev->OFM_SubFreeQ1 = hdl;
     };
  }
  else
  {
     if (ppdev->OFM_SubFreeQ2 == NULL)
     {
       hdl->subnxthdl = NULL;
       ppdev->OFM_SubFreeQ2 = hdl;
     }
     else
     {
       ppdev->OFM_SubFreeQ2->subprvhdl = hdl;
       hdl->subnxthdl = ppdev->OFM_SubFreeQ2;
       ppdev->OFM_SubFreeQ2 = hdl;
     };
  };

  // Insert into the Main FreeQ
  if (ppdev->OFM_FreeQ == NULL)
  {
     hdl->nexthdl = NULL;
     ppdev->OFM_FreeQ = hdl;
  }
  else
  {
     ppdev->OFM_FreeQ->prevhdl = hdl;
     hdl->nexthdl = ppdev->OFM_FreeQ;
     ppdev->OFM_FreeQ = hdl;
  };

} // OFS_InsertInFreeQ()



/****************************************************************************
* FUNCTION NAME: OFS_RemoveFrmFreeQ()
*
* DESCRIPTION:   Remove the handle from the Free queue.
****************************************************************************/
void OFS_RemoveFrmFreeQ(PPDEV  ppdev,
                        OFMHDL *hdl)
{
  OFMHDL *prvpds, *nxtpds;
  OFMHDL *subprvpds, *subnxtpds;

  hdl->flag = UNKNOWN;
  prvpds = hdl->prevhdl;
  nxtpds = hdl->nexthdl;
  subprvpds = hdl->subprvhdl;
  subnxtpds = hdl->subnxthdl;

  // Remove from the SubFreeQs
  if (hdl->sizey < MEMSZY)
  {
     if (hdl == ppdev->OFM_SubFreeQ1)
     {
       ppdev->OFM_SubFreeQ1 = subnxtpds;
   
       if (subnxtpds != 0)
          subnxtpds->subprvhdl = NULL;
     }
     else
     {
       if (subnxtpds != NULL)
          subnxtpds->subprvhdl = subprvpds;
   
       if (subprvpds != NULL)
          subprvpds->subnxthdl = subnxtpds;
     };
  }
  else
  {
     if (hdl == ppdev->OFM_SubFreeQ2)
     {
       ppdev->OFM_SubFreeQ2 = subnxtpds;
   
       if (subnxtpds != 0)
          subnxtpds->subprvhdl = NULL;
     }
     else
     {
       if (subnxtpds != NULL)
          subnxtpds->subprvhdl = subprvpds;
   
       if (subprvpds != NULL)
          subprvpds->subnxthdl = subnxtpds;
     };
  };

  // Remove from the Main FreeQ
  if (hdl == ppdev->OFM_FreeQ)
  {
    ppdev->OFM_FreeQ = nxtpds;

    if (nxtpds != 0)
       nxtpds->prevhdl = NULL;
  }
  else
  {
    if (nxtpds != NULL)
       nxtpds->prevhdl = prvpds;

    if (prvpds != NULL)
       prvpds->nexthdl = nxtpds;
  };
} // OFS_RemoveFrmFreeQ



/****************************************************************************
* FUNCTION NAME: OFS_InsertInUsedQ()
*
* DESCRIPTION:   Insert the handle into the Used queue.
****************************************************************************/
void OFS_InsertInUsedQ(PPDEV  ppdev,
                       OFMHDL *hdl)
{
  hdl->flag = IN_USE;
  hdl->prevhdl = NULL;

  if (ppdev->OFM_UsedQ == NULL)
  {
    hdl->nexthdl = NULL;
    ppdev->OFM_UsedQ = hdl;
  }
  else
  {
    ppdev->OFM_UsedQ->prevhdl = hdl;
    hdl->nexthdl = ppdev->OFM_UsedQ;
    ppdev->OFM_UsedQ = hdl;
  };

} // OFS_InsertInUsedQ()



/****************************************************************************
* FUNCTION NAME: OFS_RemoveFrmUsedQ()
*
* DESCRIPTION:   Remove the handle from the Used queue.
****************************************************************************/
void OFS_RemoveFrmUsedQ(PPDEV  ppdev,
                        OFMHDL *hdl)
{
  OFMHDL *prvpds, *nxtpds;

  hdl->flag = UNKNOWN;
  prvpds = hdl->prevhdl;
  nxtpds = hdl->nexthdl;

  if (hdl == ppdev->OFM_UsedQ)
  {
    ppdev->OFM_UsedQ = nxtpds;

    if (nxtpds != 0)
       nxtpds->prevhdl = NULL;
  }
  else
  {
    if (nxtpds != NULL)
       nxtpds->prevhdl = prvpds;

    if (prvpds != NULL)
       prvpds->nexthdl = nxtpds;
  };

} // OFS_RemoveFrmUsedQ()



/****************************************************************************
* FUNCTION NAME: OFS_DiscardMem()
*
* DESCRIPTION:   This routine search Used Queue to find any discardable
*                allocated block. Releases those blocks to satisfy
*                the current request.
*
* Input:         Request offscreen memory size (in bytes).
*
* Output:        TRUE:  Find a free block.
*                FALSE: No free block available.
****************************************************************************/
BOOL OFS_DiscardMem(PPDEV ppdev,
                    LONG  reqszx,
                    LONG  reqszy)
{
  OFMHDL *hdl, *pds;
  
  hdl = ppdev->OFM_UsedQ;
  while (hdl != NULL)
  {
    if ((hdl->alignflag & DISCARDABLE_FLAG) != 0)
    {
       // Save the handle
       pds = hdl;

       // Get next free block handle
       hdl = hdl->nexthdl;

       // Call the callback function
       if (pds->pcallback != NULL)
          pds->pcallback();

       // Remove this discardable block from the Used queue
       OFS_RemoveFrmUsedQ(ppdev, pds);

       // Unfragment the memory
       OFS_PackMem(ppdev, pds);

       // Insert the block into the Free queue
       OFS_InsertInFreeQ(ppdev, pds);

       // Return TRUE, if the combined block is satisfy the request.
       // Otherwise continues search for next discardable block.
       if ((pds->sizex >= reqszx) && (pds->sizey >= reqszy))
          return TRUE;
    }
    else
    {
       // Next free block
       hdl = hdl->nexthdl;
    }; // endif ((hdl->alignflag & DISCARDABLE_FLAG) != 0)

  };  // endwhile (hdl != NULL)

  // Return FALSE, no more discardable block to release and still
  // no free block large enough for the request.
  return FALSE;

} // OFS_DiscardMem
#else /* MEMMGR */

/******************************************************************************\
*																			   *
*					   N E W   M E M O R Y   M A N A G E R					   *
*																			   *
\******************************************************************************/

#ifdef WINNT_VER40
	#define CREATE_MUTEX(ppdev)	ppdev->MMhsem = EngCreateSemaphore()
	#define DELETE_MUTEX(ppdev)	EngDeleteSemaphore(ppdev->MMhsem)
	#define	BEGIN_MUTEX(ppdev)	EngAcquireSemaphore(ppdev->MMhsem);
	#define END_MUTEX(ppdev)	EngReleaseSemaphore(ppdev->MMhsem)
#else
	#define CREATE_MUTEX(ppdev)	ppdev->MutexHdl = CreateMutex(NULL, FALSE, NULL)
	#define DELETE_MUTEX(ppdev)	CloseHandle(ppdev->MutexHdl)
	#define	BEGIN_MUTEX(ppdev)	WaitForSingleObject(ppdev->MutexHdl, INFINITE);
	#define END_MUTEX(ppdev)	ReleaseMutex(ppdev->MutexHdl)
#endif

/******************************************************************************\
* Function:		HostifyBitmap
*
* Purpose:		Move a device bitmap from off-screen memory to host memory.
*
* On entry:		pdm			Pointer to node to hostify.
*
* Returns:		TRUE if successful, FALSE if there is an error.
\******************************************************************************/
BOOL HostifyBitmap(PDEVMEM pdm)
{
	if (pdm->ofm.pdsurf != NULL)
	{
		// Hostify the bitmap.
		if (!bCreateDibFromScreen(pdm->ofm.pdsurf->ppdev, pdm->ofm.pdsurf))
		{
			// There was an error.
			return FALSE;
		}
	}

	return TRUE;
}

/******************************************************************************\
* Function:		HostifyAllBitmaps
*
* Purpose:		Move all device bitmaps from off-screen memory to host memory.
*
* On entry:		ppdev		Pointer to physical device.
*
* Returns:		Nothing.
\******************************************************************************/
void HostifyAllBitmaps(PPDEV ppdev)
{
	PDEVMEM	pdm, pdmNext;

	// Walk through all used nodes.
	for (pdm = ppdev->mmMemMgr.pdmUsed; pdm != NULL; pdm = pdmNext)
	{
		// Save pointer to next node.
		pdmNext = pdm->next;

		// If this is a device bitmap, hostify it.
		if (pdm->ofm.pdsurf != NULL)
		{
			if (bCreateDibFromScreen(ppdev, pdm->ofm.pdsurf))
			{
				// After successful hostification, free the node.
				mmFree(&ppdev->mmMemMgr, pdm);
			}
		}

		// If this is a SaveScreen bitmap, just remove it.
		else if (pdm->ofm.alignflag & SAVESCREEN_FLAG)
		{
			mmFree(&ppdev->mmMemMgr, pdm);
		}
	}
}

/******************************************************************************\
* Function:		CopyBitmap
*
* Purpose:		Move a device bitmap in off-screen memory.
*
* On entry:		pdmNew		Pointer to new node for device bitmap.
*				pdmOld		Pointer to old node of device bitmap.
*
* Returns:		Nothing.
\******************************************************************************/
void CopyBitmap(PDEVMEM pdmNew, PDEVMEM pdmOld)
{
	PPDEV	ppdev;
	PDSURF	pdsurf;
	ULONG	xSrc, xDest, xExt, cx;
	BOOL	fFirst = TRUE;

	// Set the pointers to the device bitmap and physical device.
	pdsurf = pdmOld->ofm.pdsurf;
	ppdev = pdsurf->ppdev;

	// Setup the values in the old NT structure.
	pdmNew->ofm.x = pdmNew->ofm.aligned_x = pdmNew->cbAddr.pt.x;
	pdmNew->ofm.y = pdmNew->ofm.aligned_y = pdmNew->cbAddr.pt.y;
	pdmNew->ofm.sizex = pdmNew->cbSize.pt.x;
	pdmNew->ofm.sizey = pdmNew->cbSize.pt.y;

	// Copy the information from the old node.
	pdmNew->ofm.alignflag = pdmOld->ofm.alignflag;
	pdmNew->ofm.pcallback = pdmOld->ofm.pcallback;
	pdmNew->ofm.pdsurf = pdsurf;

	// Update the device bitmap structure.
	pdsurf->pofm = (POFMHDL) pdmNew;
	pdsurf->ptl.x = pdmNew->cbAddr.pt.x / ppdev->iBytesPerPixel;
	pdsurf->ptl.y = pdmNew->cbAddr.pt.y;
	pdsurf->packedXY = (pdsurf->ptl.y << 16) | pdsurf->ptl.x;

	// Copy the device bitmap to a new location.
	xSrc = pdmOld->cbAddr.pt.x;
	xDest = pdmNew->cbAddr.pt.x;
	xExt = pdmNew->cbSize.pt.x;

	// We do striping.
	while (xExt > 0)
	{
		cx = min( xExt, ppdev->lTileSize - (xSrc % ppdev->lTileSize) );
		cx = min( cx, ppdev->lTileSize - (xDest % ppdev->lTileSize) );
		if (fFirst)
		{
			fFirst = FALSE;
			REQUIRE(9);
			LL_DRAWBLTDEF(0x101000CC, 0);
			LL_OP1_MONO(xSrc, pdmOld->cbAddr.pt.y);
			LL_OP0_MONO(xDest, pdmNew->cbAddr.pt.y);
			LL_MBLTEXT(cx, pdmNew->cbSize.pt.y);
		}
		else
		{
			REQUIRE(4);
			LL16(grOP1_opMRDRAM.PT.X, xSrc);
			LL16(grOP0_opMRDRAM.PT.X, xDest);
			LL16(grMBLTEXT_XEX.PT.X, cx);
		}
		xSrc += cx;
		xDest += cx;
		xExt -= cx;
	}
}

/******************************************************************************\
* Function:		InitOffScnMem
*
* Purpose:		Initialize the off-screen memory manager.
*
* On entry:		ppdev		Pointer to physical device.
*
* Returns:		TRUE if successful, FALSE if there is an error.
\******************************************************************************/
BOOL InitOffScnMem(PPDEV ppdev)
{
	UINT	Interleave, WidthInTiles, ExtraWidth, ExtraHeight;
	ULONG	BytesInMainRect, BytesInExtraRect;
	GXRECT	rect;
	SIZEL	size;
	GXPOINT	align;
	PDEVMEM	pdm;

	DISPDBG((DISPLVL, "InitOffScnMem\n"));

	// Already initialized?
	if (ppdev == NULL || ppdev->OFM_init == TRUE)
	{
		DISPDBG((DISPLVL, "InitOffScnMem: already initialized\n"));
		return FALSE;
	}

	// Create the semaphore.
	if ((CREATE_MUTEX(ppdev)) == NULL)
	{
		DISPDBG((DISPLVL, "InitOffScnMem: CREATE_MUTEX failed\n"));
		return FALSE;
	}

	// Setup the maximum width for a device bitmap for which we will move and
	// hostify other devcie bitmaps.
	if ( (ppdev->iBytesPerPixel == 3) || (ppdev->iBytesPerPixel == 4) )
	{
		ppdev->must_have_width = 0;
	}
	else
	{
		ppdev->must_have_width = ppdev->cxScreen * 98 / 100;
	}

	// Calculate memory stuff.
	Interleave = 1 << ((LLDR_SZ(grTILE_CTRL) & 0xC0) >> 6);
	WidthInTiles = ppdev->lDeltaScreen / ppdev->lTileSize;
	BytesInExtraRect = ppdev->lTotalMem % (WidthInTiles * 2048 * Interleave);
	BytesInMainRect = ppdev->lTotalMem - BytesInExtraRect;

    //
    // BTN - For some reason, this extra rectange cause the WHQL PC97
    // Rand Create/Release 100x test fails on 1600x1200x16 and 1600x1200x8
    //
    if ((ppdev->cxScreen == 1600) &&
        (ppdev->cyScreen == 1200) &&
        ((ppdev->iBytesPerPixel == 2) || (ppdev->iBytesPerPixel == 1)))
        BytesInExtraRect = 0;
	//
	// I have removed the extra rectangle at 1280x1024x8.  Somehow it messes up
	// FoxBear.
	//
	if (   (ppdev->cxScreen == 1280)
		&& (ppdev->cyScreen == 1024)
		&& (ppdev->iBytesPerPixel == 1)
	)
	{
		BytesInExtraRect = 0;
	}

	// Setup the main rectangle.
	rect.left = 0;
	rect.top = 0;
	rect.right = ppdev->lDeltaScreen;
	rect.bottom = BytesInMainRect / ppdev->lDeltaScreen;

	// Setup the extra rectangle.
	if (BytesInExtraRect && ppdev->lTotalMem < 8 * 1024 * 1024)
	{
		ExtraHeight = Interleave * 2048 / ppdev->lTileSize;
		ExtraWidth = BytesInExtraRect / ExtraHeight;
	}
	else
	{
		ExtraWidth = ExtraHeight = 0;
	}

// v-normmi   effective height of direct frame buffer access region
//              not all of it is populated with memory
    ppdev->cyMemoryReal = rect.bottom + ExtraHeight;

	BEGIN_MUTEX(ppdev)
	{
		// Initialize the mmemory manager core.
		ppdev->mmMemMgr.mmTileWidth = ppdev->lTileSize;
		ppdev->mmMemMgr.mmHeapWidth = rect.right;
		ppdev->mmMemMgr.mmHeapHeight = rect.bottom + ExtraHeight;
		mmInit(&ppdev->mmMemMgr);

		// Initialize flags and queues.
		ppdev->OFM_init = TRUE;
		ppdev->bDirectDrawInUse = FALSE;
		ppdev->DDOffScnMemQ = FALSE;
		ppdev->DirectDrawHandle = NULL;
	}
	END_MUTEX(ppdev);

	// Add the main rectangle to the heap.
	if (!mmAddRectToList(&ppdev->mmMemMgr, &ppdev->mmMemMgr.pdmHeap, &rect,
			FALSE))
	{
		DISPDBG((DISPLVL, "InitOffScnMem: mmAddRectToList failed\n"));
		return FALSE;
	}
	DISPDBG((DISPLVL, "InitOffScnMem: main rectangle from (%d,%d) to (%d,%d)\n",
			rect.left, rect.top, rect.right, rect.bottom));

	// Add the extra rectangle to the heap.
	if (ExtraWidth > 0 && ExtraHeight > 0)
	{
		rect.left = 0;
		rect.top = rect.bottom;
		rect.right = ExtraWidth;
		rect.bottom += ExtraHeight;
		if (mmAddRectToList(&ppdev->mmMemMgr, &ppdev->mmMemMgr.pdmHeap, &rect,
				FALSE))
		{
			DISPDBG((DISPLVL, "InitOffScnMem: "
					"extra rectangle from (%d,%d) to (%d,%d)\n", rect.left,
					rect.top, rect.right, rect.bottom));
		}
	}

	// Allocate a node for the screen.
	size.cx = ppdev->cxScreen;
	size.cy = ppdev->cyScreen;
	ppdev->ScrnHandle = AllocOffScnMem(ppdev, &size, SCREEN_ALLOCATE, NULL);
	if (ppdev->ScrnHandle == NULL)
	{
		DISPDBG((DISPLVL, "InitOffScnMem: AllocOffScnMem failed\n"));
		return FALSE;
	}

	// Determine if bitmap filter should be turned on.
	align.pt.x = align.pt.y = 1;
	pdm = mmAllocLargest(&ppdev->mmMemMgr, align);
	if (pdm == NULL)
	{
		DISPDBG((DISPLVL, "InitOffScnMem: mmAllocLargest faled\n"));
		return FALSE;
	}
	size.cx = pdm->cbSize.pt.x / ppdev->iBytesPerPixel;
	size.cy = pdm->cbSize.pt.y;
	mmFree(&ppdev->mmMemMgr, pdm);

	if ((ULONG) size.cx < ppdev->cxScreen || (ULONG) size.cy < ppdev->cyScreen)
	{
		ppdev->fBitmapFilter = TRUE;
		ppdev->szlBitmapMin.cx = 64;
		ppdev->szlBitmapMin.cy = 64;
		ppdev->szlBitmapMax.cx = size.cx;
		ppdev->szlBitmapMax.cy = size.cy;
	}
	else
	{
		ppdev->fBitmapFilter = FALSE;
	}

	// Return success.
	DISPDBG((DISPLVL, "InitOffScnMem: completed\n"));
	return TRUE;
}

/******************************************************************************\
* Function:		CloseOffScnMem
*
* Purpose:		Free all memory allocated for the off-screen memory manager.
*
* On entry:		ppdev		Pointer to physical device.
*
* Returns:		Nothing.
\******************************************************************************/
void CloseOffScnMem(PPDEV ppdev)
{
	PHANDLES ph, phNext;

	DISPDBG((DISPLVL, "CloseOffScnMem\n"));

	// Already closed?
	if (ppdev == NULL || !ppdev->OFM_init)
	{
		DISPDBG((DISPLVL, "CloseOffScnMem: already closed\n"));
		return;
	}

	BEGIN_MUTEX(ppdev)
	{
		// Delete all allocated arrays.
		for (ph = ppdev->mmMemMgr.phArray; ph != NULL; ph = phNext)
		{
			phNext = ph->pNext;
			MEMORY_FREE(ph);
		}
		ppdev->mmMemMgr.phArray = NULL;

		ppdev->mmMemMgr.pdmUsed = NULL;
		ppdev->mmMemMgr.pdmFree = NULL;
		ppdev->mmMemMgr.pdmHeap = NULL;
		ppdev->mmMemMgr.pdmHandles = NULL;

		ppdev->OFM_init = FALSE;
	}
	END_MUTEX(ppdev);

	// Delete the semaphore.
	DELETE_MUTEX(ppdev);
	DISPDBG((DISPLVL, "CloseOffScnMem: completed\n"));
}

/******************************************************************************\
* Function:		AllocOffScnMem
*
* Purpose:		Allocate a node in off-screen memory.
*
* On entry:		ppdev		Pointer to physical device.
*				psize		Pointer to the size of the requested node.  The size
*							is specified in pixels or bytes, depending on the
*							alignment flags.
*				alignflag	Alignment flags.
*				pcallback	Pointer to callback routine if DISCARDABLE_FLAG is
*							set.
*
* Returns:		Pointer to the node if successful, or NULL if there is not
*				enough memory to allocate the node.
\******************************************************************************/
POFMHDL AllocOffScnMem(PPDEV ppdev, PSIZEL psize, ULONG alignflag,
					   POFM_CALLBACK pcallback)
{
	GXPOINT	size, align;
	UINT	bpp;
	PDEVMEM	pdm;

	DISPDBG((DISPLVL, "AllocOffScnMem\n"));

	// If the memory manager active?
	if (ppdev == NULL || !ppdev->OFM_init || psize == NULL)
	{
		DISPDBG((DISPLVL, "AllocOffScnMem: not initialized\n"));
		return NULL;
	}

	#ifndef ALLOC_IN_CREATESURFACE
	// Return in case DirectDraw is active.
	if (pdpev->bDirectDrawInUse)
	{
		DISPDBG((DISPLVL, "AllocOffScnMem: DirectDraw is active\n"));
		return NULL;
	}
	#endif

	// Z-buffer alignment.
	if (alignflag & MCD_Z_BUFFER_ALLOCATE)
	{
		bpp = 2;
		align.pt.x = 32;
		align.pt.y = 32;
	}

	// Texture alignment.
	else if (alignflag & MCD_TEXTURE_ALLOCATE)
	{
		bpp = (alignflag & MCD_TEXTURE_ALLOCATE) >> MCD_TEXTURE_ALLOC_SHIFT;
		align.pt.x = 32;
		align.pt.y = 16;
	}

	// DirectDraw buffer alignment.
	else if (alignflag & MCD_DRAW_BUFFER_ALLOCATE)
	{
		bpp = ppdev->iBytesPerPixel;
		align.pt.x = 64;
		align.pt.y = 32;
	}

	// 8 bytes alignment.
	else if (alignflag & EIGHT_BYTES_ALIGN)
	{
		bpp = ppdev->iBytesPerPixel;
		align.pt.x = 8;
		align.pt.y = 1;
	}

	// Pixel alignment.
	else if (alignflag & PIXEL_AlIGN)
	{
		bpp = ppdev->iBytesPerPixel;
		align.pt.x = ppdev->iBytesPerPixel;
		align.pt.y = 1;
	}

	// Screen alignment.
	else if (alignflag & SCREEN_ALLOCATE)
	{
		bpp = ppdev->iBytesPerPixel;
		align.pt.x = ppdev->lDeltaScreen;
		align.pt.y = ppdev->cyMemory;
	}

	// Tile alignment.
	else
	{
		bpp = 1;
		align.pt.x = ppdev->lTileSize;
		align.pt.y = 2048 / ppdev->lTileSize;

		if (alignflag & NO_X_TILE_AlIGN)
		{
			align.pt.x = 1;
		}
		if (alignflag & NO_Y_TILE_AlIGN)
		{
			align.pt.y = 1;
		}
	}

	// The Z-buffer needs to be allocated at x=0.
	if (alignflag & MCD_NO_X_OFFSET)
	{
		align.pt.x = ppdev->lDeltaScreen;
	}

	#if TILE_ALIGNMENT
	// If this is a call from DrvCreateDeviceBitmap, set tile alignment.
	if (alignflag & MUST_HAVE)
	{
		align.pt.x |= 0x8000;
	}
	#endif

	// Set the size of the node.
	size.pt.x = psize->cx * bpp;
	size.pt.y = psize->cy;

	#if 1 // PDR#10526
	// Immortal Klowns copies a few bytes too much to the screen if the size of
	// a DirectDraw surface is not DWORD aligned.  So for DirectDraw and pixel
	// aligned allocations we align the size to DWORDs.
	if (ppdev->bDirectDrawInUse && (alignflag & PIXEL_AlIGN))
	{
		size.pt.x = (size.pt.x + 3) & ~3;
	}
	#endif

	BEGIN_MUTEX(ppdev)
	{
		// 1st pass, allocate the node.
		pdm = mmAlloc(&ppdev->mmMemMgr, size, align);
		if (pdm == NULL && (alignflag & MUST_HAVE))
		{
			// 2nd pass, move stuff away and allocate the node.
			pdm = mmMove(&ppdev->mmMemMgr, size, align, CopyBitmap);
		}
	}
	END_MUTEX(ppdev);

	if (pdm == NULL)
	{
		// Oops, no room for the node.
		DISPDBG((DISPLVL, "AllocOffScnMem: failed for (%dx%d)\n", size.pt.x,
				size.pt.y));
		return NULL;
	}

	// Setup the values in the old NT structure.
	pdm->ofm.x = pdm->ofm.aligned_x = pdm->cbAddr.pt.x;
	pdm->ofm.y = pdm->ofm.aligned_y = pdm->cbAddr.pt.y;
	pdm->ofm.sizex = pdm->cbSize.pt.x;
	pdm->ofm.sizey = pdm->cbSize.pt.y;
	pdm->ofm.alignflag = alignflag;
	pdm->ofm.pdsurf = NULL;

	// Set the address of the callback function.
	if (alignflag & DISCARDABLE_FLAG)
	{
		pdm->ofm.pcallback = pcallback;
	}
	else if (alignflag & MUST_HAVE)
	{
		// This is a device bitmap.
		pdm->ofm.pcallback = (POFM_CALLBACK) HostifyBitmap;
	}
	else
	{
		// No callback function.
		pdm->ofm.pcallback = NULL;
	}

	// Return node.
	DISPDBG((DISPLVL, "AllocOffScnMem: completed from (%d,%d) to (%d,%d)\n",
			pdm->cbAddr.pt.x, pdm->cbAddr.pt.y, pdm->cbAddr.pt.x +
			pdm->cbSize.pt.x, pdm->cbAddr.pt.y + pdm->cbSize.pt.y));
	return (POFMHDL) pdm;
}

/******************************************************************************\
* Function:		FreeOffScnMem
*
* Purpose:		Free a node allocated from off-screen memory.
*
* On entry:		ppdev		Pointer to physical device.
*				hdl			Handle of node to free.
*
* Returns:		TRUE if successful, FALSE if there is an error.
\******************************************************************************/
BOOL FreeOffScnMem(PPDEV ppdev, POFMHDL hdl)
{
	DISPDBG((DISPLVL, "FreeOffScnMem\n"));

	// If the memory manager enabled?
	if (ppdev == NULL || !ppdev->OFM_init || hdl == NULL)
	{
		DISPDBG((DISPLVL, "FreeOffScnMem: not initialized\n"));
		return FALSE;
	}

	// Free the node.
	DISPDBG((DISPLVL, "FreeOffScnMem: from (%d,%d) to (%d,%d)\n", hdl->x,
			hdl->y, hdl->x + hdl->sizex, hdl->y + hdl->sizey));
	mmFree(&ppdev->mmMemMgr, (PDEVMEM) hdl);

	// Return success.
	DISPDBG((DISPLVL, "FreeOffScnMem: completed\n"));
	return TRUE;
}

/******************************************************************************\
* Function:		ConvertToVideoBufferAddr
*
* Purpose:		Convert the location of a node in off-screen memory to a linear
*				address.
*
* On entry:		ppdev		Pointer to physical device.
*				hdl			Handle of node.
*
* Returns:		Linear address of node.
\******************************************************************************/
PVOID ConvertToVideoBufferAddr(PPDEV ppdev, POFMHDL hdl)
{
	PBYTE	retaddr;

	BEGIN_MUTEX(ppdev)
	{
		// Calculate the address.
		retaddr = ppdev->pjScreen + hdl->x + hdl->y * ppdev->lDeltaScreen;
	}
	END_MUTEX(ppdev);

	return (PVOID) retaddr;
}

/******************************************************************************\
* Function:		DDOffScnMemAlloc
*
* Purpose:		Free all non-essential memory to make room for DirectDraw.
*
* On entry:		ppdev		Pointer to physical device.
*
* Returns:		Pointer to biggest node for DirectDraw or NULL if the memory
*				manager handles DirectDraw surfaces.
\******************************************************************************/
POFMHDL DDOffScnMemAlloc(PPDEV ppdev)
{
	PDEVMEM	pdm;
	GXPOINT	align;

	DISPDBG((DISPLVL, "DDOffScnMemAlloc\n"));

	// Hostify all device bitmaps.
	HostifyAllBitmaps(ppdev);

	// SWAT3: Font cache release has moved to vAssertModeText.
	vAssertModeText(ppdev, FALSE);

	#ifdef ALLOC_IN_CREATESURFACE
	// We handle DirectDraw surfaces ourselfs.
	pdm = NULL;
	#else
	// Allocate the biggest chunk of memory for DirectDraw.
	align.pt.x = align.pt.y = 1;
	pdm = mmAllocLargest(&ppdev->mmMemMgr, align);
	#endif

	DISPDBG((DISPLVL, "DDOffScnMemAlloc: completed\n"));
	return (POFMHDL) pdm;
}

/******************************************************************************\
* Function:		DDOffScnMemRestore
*
* Purpose:		Release the memory allocated by DirectDraw.
*
* On entry:		ppdev		Pointer to physical device.
*
* Returns:		Nothing.
\******************************************************************************/
void DDOffScnMemRestore(PPDEV ppdev)
{
	PDDOFM	pdd, pddNext;

	DISPDBG((DISPLVL, "DDOffScnMemRestore\n"));

	// Release all DirectDraw nodes.
	for (pdd = ppdev->DDOffScnMemQ; pdd != NULL; pdd = pddNext)
	{
		pddNext = pdd->nexthdl;
		mmFree(&ppdev->mmMemMgr, (PDEVMEM) pdd->phdl);
		MEMORY_FREE(pdd);
	}
	ppdev->DDOffScnMemQ = NULL;

	// Release DirectDraw memory.
	if (ppdev->DirectDrawHandle != NULL)
	{
		mmFree(&ppdev->mmMemMgr, (PDEVMEM) ppdev->DirectDrawHandle);
		ppdev->DirectDrawHandle = NULL;
	}

	// Invalidate the entire brush cache now.
	vInvalidateBrushCache(ppdev);

	// Invalidate all cached fonts.
	#if SWAT3
	vAssertModeText(ppdev, TRUE);
	#endif
	ppdev->ulFontCount++;

	DISPDBG((DISPLVL, "DDOffScnMemRestore: completed\n"));
}

/******************************************************************************\
* Function:		FindHandle
*
* Purpose:		Find a specific node int the used list.
*
* On entry:		ppdev		Pointer to physical device.
*				hdl			Handle of node to find.
*
* Returns:		A pointer to the specified handle if it is found in the used
*				list, otherwise NULL will be returned.
\******************************************************************************/
POFMHDL FindHandle(PPDEV ppdev, POFMHDL hdl)
{
	PDEVMEM	pdm;

	// Walk through the used list.
	for (pdm = ppdev->mmMemMgr.pdmUsed; pdm != NULL; pdm = pdm->next)
	{
		if ((POFMHDL) pdm == hdl)
		{
			// We have a match!
			return hdl;
		}
	}

	return NULL;
}
#endif /* MEMMGR */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\paint.c ===
/******************************Module*Header*******************************\
* Module Name: PAINT.c
* Author: Noel VanHook
* Date: Mar. 21, 1995
* Purpose: Handle calls to DrvPaint
*
* Copyright (c) 1995 Cirrus Logic, Inc.
*
\**************************************************************************/

/*

    This module handles calls to DrvPaint() by converting them into calls
    to DrvBitBlt().  The only conversion needed to to change the MIX into
    a ROP4.  

*/


#include "precomp.h"

#define PAINT_DBG_LEVEL 1

//==========================================================================
//
// In an attempt to trace the problems with the FIFO, we supply a few
// macros that will allow us to easily try different FIFO stratagies.
//

//
// This macro is executed at the start of every BLT, before any registers
// are written.
//
#define STARTBLT()      \
    do {                \
    }while (0)

//
// This macro is executed at the top of inner BLT loops. 
// If there were clipping, for example, STARTBLT() would be executed
// once at the start of the BLT, and STARTBLTLOOP() would be executed 
// before each rectangle in the clip list.
//
#define STARTBLTLOOP()  \
    do {                \
	REQUIRE(0);     \
    }while (0)
//==========================================================================


//
// Table to convert ROP2 codes to ROP3 codes.
//

BYTE Rop2ToRop3[]=
{
	0xFF, // R2_WHITE       /*  1       */ 
	0x00, // R2_BLACK       /*  0       */
	0x05, // R2_NOTMERGEPEN /* DPon     */
	0x0A, // R2_MASKNOTPEN  /* DPna     */
	0x0F, // R2_NOTCOPYPEN  /* PN       */
	0x50, // R2_MASKPENNOT  /* PDna     */
	0x55, // R2_NOT         /* Dn       */
	0x5A, // R2_XORPEN      /* DPx      */
	0x5F, // R2_NOTMASKPEN  /* DPan     */
	0xA0, // R2_MASKPEN     /* DPa      */
	0xA5, // R2_NOTXORPEN   /* DPxn     */
	0xAA, // R2_NOP         /* D        */
	0xAF, // R2_MERGENOTPEN /* DPno     */
	0xF0, // R2_COPYPEN     /* P        */
	0xF5, // R2_MERGEPENNOT /* PDno     */
	0xFA, // R2_MERGEPEN    /* DPo      */
	0xFF  // R2_WHITE       /*  1       */
};


//
// If data logging is enabled, Prototype the logging files.
//
#if LOG_CALLS
    void LogPaint(
	int 	  acc,
        SURFOBJ*  psoDest,
	MIX       mix,
        CLIPOBJ*  pco,
        BRUSHOBJ* pbo);

//
// If data logging is not enabled, compile out the calls.
//
#else
    #define LogPaint(acc, psoDest, mix, pco, pbo)
#endif





/**************************************************************************\
* DrvPaint                                                                 *
*                                                                          *
* Paint the clipping region with the specified brush                       *
* Accomplished by converting into a call to DrvBitBlt()                    *
*                                                                          *
\**************************************************************************/

BOOL DrvPaint
(
    SURFOBJ  *pso,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    MIX       mix
)
{
    ULONG fg_rop, bg_rop, rop4;
    DWORD  color;
    PPDEV ppdev;      

    #if NULL_PAINT
    {
	if (pointer_switch)	    return TRUE;
    }
    #endif

    ppdev = (PPDEV) pso->dhpdev;  
    ASSERTMSG (ppdev,"No PDEV in DrvPaint.");

    SYNC_W_3D(ppdev);

    //
    // The destination rectangle is defined by the clipping region, 
    // so we should never get a null clipping region.
    //
    ASSERTMSG (pco, "DrvPaint without a clip object!\n");

    DISPDBG((PAINT_DBG_LEVEL,"Drvpaint: Entry.\n"));


    // Are we painting to a device bitmap?
    if (pso->iType == STYPE_DEVBITMAP)
    {
        // Yes. 
	PDSURF pdsurf = (PDSURF)pso->dhsurf;

	// Is the device bitmap currently in host memory?
	if ( pdsurf->pso )
	{
	    // Yes.  Move it into off screen memory.
	    if ( !bCreateScreenFromDib(ppdev, pdsurf) )
	    {
		// We couldn't move it to off-screen memory.
		LogPaint(1, pso, mix, pco, pbo);
	        return EngPaint(pdsurf->pso, pco, pbo, pptlBrush, mix);
	    }
	}

	// The device bitmap now resides in off-screen memory.
	// This is the offset to it.
	ppdev->ptlOffset.x = pdsurf->ptl.x;
	ppdev->ptlOffset.y = pdsurf->ptl.y;
    }
    else
    {
	// No, we are not painting to a device bitmap.
	ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;
    }
    
    //
    // DrvPaint is most often called with 
    // mix 0D (PAT COPY) and mix 06 (DEST INVERT).
    // It behooves us, therefore, to handle these as
    // special cases... provided they aren't clipped.
    //
    if ((pco->iDComplexity != DC_COMPLEX))
    {
	// =================== PATCOPY ==================================
        if (mix == 0x0D0D) 
        {
    	    ASSERTMSG(pbo, "DrvPaint PATCOPY without a brush.\n");
    	    if (pbo->iSolidColor != 0xFFFFFFFF) // Solid color
	    {
	        color = pbo->iSolidColor;
	        switch (ppdev->ulBitCount)
	        {
		    case 8: // For 8 bpp duplicate byte 0 into byte 1. 
	    		color |=  (color << 8);
	
		    case 16: // For 8,16 bpp, duplicate the low word into the high word.
		    	color |=  (color << 16);
	    	    break;
        	}
	
			REQUIRE(9);
       	    LL_BGCOLOR(color, 0);
	        LL_DRAWBLTDEF(0x100700F0, 0);
	        LL_OP0(pco->rclBounds.left + ppdev->ptlOffset.x,
        	       pco->rclBounds.top + ppdev->ptlOffset.y);
	        LL_BLTEXT ((pco->rclBounds.right - pco->rclBounds.left),
    				   (pco->rclBounds.bottom - pco->rclBounds.top));
          
		LogPaint(0, pso, mix, pco, pbo);
	        return TRUE;
	    } // End PATCOPY with solid color.  

	    else // PATCOPY with a brush.
            {
	        DWORD bltdef = 0x1000;
	        if (SetBrush(ppdev, &bltdef, pbo, pptlBrush))
	        {
				REQUIRE(7);
	    	    LL_DRAWBLTDEF((bltdef << 16) | 0x00F0, 0);
	    	    LL_OP0 (pco->rclBounds.left + ppdev->ptlOffset.x,
    	                pco->rclBounds.top + ppdev->ptlOffset.y);
	    	    LL_BLTEXT ((pco->rclBounds.right -  pco->rclBounds.left) ,
    		               (pco->rclBounds.bottom - pco->rclBounds.top) );
    
		    LogPaint(0, pso, mix, pco, pbo);
	    	    return TRUE;
	        }
	    } // End PATCOPY with a brush
	
       } // End PATCOPY

       // ======================= DEST INVERT ============================
       else if (mix == 0x0606)
       {
		REQUIRE(7);
	    LL_DRAWBLTDEF(0x11000055, 0);
	    LL_OP0(pco->rclBounds.left + ppdev->ptlOffset.x,
        	   pco->rclBounds.top + ppdev->ptlOffset.y);
	    LL_BLTEXT ((pco->rclBounds.right -  pco->rclBounds.left),
    		       (pco->rclBounds.bottom - pco->rclBounds.top) );
	
	    LogPaint(0, pso, mix, pco, pbo);
            return TRUE;
	
       } // End DEST INVERT

    } // End special cases


    // First, convert the fg and bg mix into a fg and bg rop
    fg_rop = Rop2ToRop3[ (mix & 0x0F) ];      // convert fg mix to fg rop.
    bg_rop = Rop2ToRop3[ ((mix>>8) & 0x0F) ]; // convert bg mix to bg rop
    rop4 = (bg_rop<<8) | fg_rop;              // build rop4.

    //
    // Now convert Paint to BitBLT
    //
    LogPaint(2, pso, mix, pco, pbo);

    DISPDBG((PAINT_DBG_LEVEL,"Drvpaint: Convert to DrvBitBlt().\n"));
    return DrvBitBlt(pso,	            // Target
    		     (SURFOBJ *) NULL,      // Source
	    	     (SURFOBJ *) NULL,      // Mask
	    	     pco,                   // Clip object
		     (XLATEOBJ *) NULL,     // Xlate object
	    	     &(pco->rclBounds),     // Dest rectangle.
	    	     (PPOINTL) NULL,        // Src point.
	    	     (PPOINTL) NULL,        // Mask point.
	    	     pbo,                   // Brush
	    	     pptlBrush,             // Brush alignment
	    	     rop4);                 // ROP4
}



#if LOG_CALLS
// ============================================================================
//
//    Everything from here down is for data logging and is not used in the 
//    production driver.
//
// ============================================================================


// ****************************************************************************
//
// LogPaint()
// This routine is called only from DrvPaint()
// Dump information to a file about what is going on in DrvPaint land.
//
// ****************************************************************************
void LogPaint(
	int 	  acc,
        SURFOBJ*  psoDest,
	MIX 	  mix,
        CLIPOBJ*  pco,
        BRUSHOBJ* pbo)
{
    PPDEV dppdev,sppdev,ppdev;
    char buf[256];
    int i;
    BYTE fg_rop, bg_rop;
    ULONG iDComplexity;

    ppdev = (PPDEV) (psoDest ? psoDest->dhpdev : 0);
     
    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    i = sprintf(buf,"DrvPaint: ");
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    switch(acc)
    {
	case 0: // Accelerated
	    i = sprintf(buf, "ACCL ");
	    break;

	case 1: // Punted
	    i = sprintf(buf,"PUNT host ");
	    break;

	case 2: // Punted
	    i = sprintf(buf, "PUNT BitBlt ");
	    break;

	default:
 	    i = sprintf(buf, "PUNT unknown ");
	    break;

    }
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    //
    // Check the DEST
    //
    if (psoDest)
    {
        if (psoDest->iType == STYPE_DEVBITMAP)
        {
            i = sprintf(buf, "Id=%p ", psoDest->dhsurf);
            WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
            if (  ((PDSURF)psoDest->dhsurf)->pso   )
                i = sprintf(buf,"DST=DH ");
            else
                i = sprintf(buf,"DST=DF ");
        }
        else if (psoDest->hsurf == ppdev->hsurfEng)
            i = sprintf(buf,"DST=S  ");
        else
            i = sprintf(buf,"DST=H  ");
    }
    else
        i = sprintf(buf,"DST=N  ");
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);



    //
    // Check the MIX
    //
    i = sprintf(buf,"MIX = 0x%04X   ", mix);
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    //
    // Check the type of clipping.
    //
    iDComplexity = (pco ? pco->iDComplexity : DC_TRIVIAL);
    i = sprintf(buf,"CLIP=%s ",
                (iDComplexity==DC_TRIVIAL ? "T": 
                (iDComplexity == DC_RECT ? "R" : "C" )));
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    //
    // Type of pattern.
    //
    if (pbo == NULL)
    {
        i = sprintf(buf,"BRUSH=N          ");
        WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else if (pbo->iSolidColor == 0xFFFFFFFF )
    {
        i = sprintf(buf,"BRUSH=P          ");
        WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else
    {
        i = sprintf(buf,"BRUSH=0x%08X ",(pbo->iSolidColor));
        WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }


    i = sprintf(buf,"\r\n");
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\pointer.c ===
/***************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:	Laguna I (CL-GD5462) - 
*
* FILE:		pointer.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module contains the SW & HW curosr support for the
*           Laguna NT driver.
*
* MODULES:
*           DrvMovePointer()
*           DrvSetPointerShape()
*
* REVISION HISTORY:
*   6/20/95     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/POINTER.C  $
* 
*    Rev 1.39   Mar 04 1998 15:30:24   frido
* Added new shadow macros.
* 
*    Rev 1.38   Jan 19 1998 10:26:26   frido
* HP#86 (no PDR yet). Removed hardware cursor for 1600x1200 >=65Hz.
* 
*    Rev 1.37   Nov 03 1997 11:30:16   frido
* Added REQUIRE macros.
* 
*    Rev 1.36   23 Sep 1997 10:48:22   bennyn
* Not use HW cursor if the resolution is below 640x480
* 
*    Rev 1.35   11 Jun 1997 15:13:14   bennyn
* Fixed PDR 9747 Punt to SW cursor in 1600x1200x8 & x16 at 65,70,75 Hz
* 
*    Rev 1.34   11 Jun 1997 14:02:30   bennyn
* Fixed PDR 9741 (animated cursor turns back)
* 
*    Rev 1.33   28 May 1997 14:17:58   bennyn
* Fixed PDR 9741 and eliminated dead code
* 
*    Rev 1.32   01 May 1997 15:02:12   bennyn
* Punt the cursor if it is in interlace modes
* 
*    Rev 1.31   09 Apr 1997 10:53:36   SueS
* Changed type of pointer_switch to eliminate compiler warning.
* 
*    Rev 1.30   08 Apr 1997 15:22:50   SueS
* Don't use color for monochrome animated cursors - otherwise we'll 
* reference a NULL pointer.
* 
*    Rev 1.29   07 Apr 1997 12:44:50   BENNYN
* Added the checking ptrmaskhandle equal to NULL
* 
*    Rev 1.28   02 Apr 1997 14:24:14   noelv
* NT 35.1 wass accessing a NULL pointer in DrvMovePointer
* Removed SW cursor and chainblt cursor code 
* 
*    Rev 1.27   21 Mar 1997 13:37:44   noelv
* 
* Combined do_flag and sw_test_flag into pointer_switch
* 
*    Rev 1.26   03 Feb 1997 13:35:22   bennyn
* Modified the 5465 cursor algorithm
* 
*    Rev 1.25   30 Jan 1997 17:15:02   bennyn
* Added cursor algorithm for 5465
* 
*    Rev 1.24   17 Dec 1996 17:01:10   SueS
* Added test for writing to log file based on cursor at (0,0).
* 
*    Rev 1.23   10 Dec 1996 14:32:46   bennyn
* 
* Fixed cursor mask from device bitmap problem
* 
*    Rev 1.22   26 Nov 1996 10:43:04   SueS
* Changed WriteLogFile parameters for buffering.
* 
*    Rev 1.21   13 Nov 1996 17:00:52   SueS
* Changed WriteFile calls to WriteLogFile.
* 
*    Rev 1.20   01 Nov 1996 09:26:46   BENNYN
* 
* Cleanup unused code
* 
*    Rev 1.19   23 Oct 1996 14:44:44   BENNYN
* 
* Fixed the YUV cursor problems
* 
*    Rev 1.18   06 Sep 1996 09:07:02   noelv
* 
* Cleaned up NULL driver code.
* 
*    Rev 1.17   26 Aug 1996 17:35:08   bennyn
* 
* Restore the changes for the losed version
* 
*    Rev 1.16   20 Aug 1996 11:04:20   noelv
* Bugfix release from Frido 8-19-96
* 
*    Rev 1.3   17 Aug 1996 19:39:20   frido
* Fixed DirectDraw cursor problem.
* 
*    Rev 1.2   17 Aug 1996 13:34:56   frido
* New release from Bellevue.
* 
*    Rev 1.1   15 Aug 1996 11:40:18   frido
* Added precompiled header.
* 
*    Rev 1.0   14 Aug 1996 17:16:30   frido
* Initial revision.
* 
*    Rev 1.13   25 Jul 1996 15:56:00   bennyn
* 
* Modified to support DirectDraw
* 
*    Rev 1.12   18 Jun 1996 12:44:18   noelv
* Fixed the way interleave is calculated.
* 
*    Rev 1.11   28 May 1996 15:11:28   noelv
* Updated data logging.
* 
*    Rev 1.10   01 May 1996 12:23:30   bennyn
* 
*    Rev 1.9   01 May 1996 12:05:36   bennyn
* Fixed resolution change bug for NT4.0
* 
*    Rev 1.8   01 May 1996 11:00:48   bennyn
* 
* Modified for NT4.0
* 
*    Rev 1.7   04 Apr 1996 13:20:24   noelv
* Frido release 26
 * 
 *    Rev 1.4   28 Mar 1996 20:22:28   frido
 * Removed warning messages from new Bellevue release.
* 
*    Rev 1.6   25 Mar 1996 18:55:30   noelv
* Fixed bouncing screeen when cursor is disabled.
* 
*    Rev 1.5   08 Mar 1996 17:27:38   noelv
* 
* Added NULL_POINTER flag
* 
*    Rev 1.4   07 Mar 1996 18:22:46   bennyn
* 
* Removed read/modify/write on CONTROL reg
* 
*    Rev 1.3   05 Mar 1996 11:58:26   noelv
* Frido version 19
 * 
 *    Rev 1.1   20 Jan 1996 01:22:00   frido
 *  
* 
*    Rev 1.10   15 Jan 1996 16:59:58   NOELV
* AB workaround reductions
* 
*    Rev 1.9   11 Jan 1996 09:22:04   NOELV
* Removed al 16 bit writes to X,Y,and BLTEXT registers.
* 
*    Rev 1.8   10 Jan 1996 16:20:56   NOELV
* Added increased logging capabilities.
* Added null driver capabilities.
* 
*    Rev 1.7   29 Nov 1995 12:11:42   noelv
* 
* Coded a workaround for HW bug.  The screen corrupts sometimes when the curs
* I changed the code to turn the cursor off as little as possible.
* 
*    Rev 1.6   29 Sep 1995 10:26:20   bennyn
* 
* Punt the cursor to GDI for 1600x1200 modes
* 
*    Rev 1.5   29 Sep 1995 09:54:58   bennyn
* 
*    Rev 1.4   27 Sep 1995 16:45:40   bennyn
* Fixed the HW cursor AND mask
* 
*    Rev 1.3   26 Sep 1995 16:27:50   bennyn
* 
*    Rev 1.2   26 Sep 1995 09:35:16   bennyn
* Enable HW cursor
* 
*    Rev 1.1   21 Aug 1995 13:52:16   NOELV
* Initial port to real hardware.
* Converted all 32 bit register writes to 2 16 bit regiser writes.
* 
*    Rev 1.0   25 Jul 1995 11:19:28   NOELV
* Initial revision.
* 
*    Rev 1.6   06 Jul 1995 09:57:10   BENNYN
* 
* Fixed the problem switching between full-screen & Windowed DOS box
* 
*    Rev 1.5   29 Jun 1995 09:50:54   BENNYN
* Fixed the unsupport cursor request problem
* 
*    Rev 1.4   29 Jun 1995 09:01:30   BENNYN
* 
*    Rev 1.3   28 Jun 1995 11:13:32   BENNYN
* Fixed 16-bit/pixel problem
* 
*    Rev 1.2   22 Jun 1995 13:33:32   BENNYN
* 
* Added SW cursor auto BLT
* 
*    Rev 1.1   20 Jun 1995 16:09:30   BENNYN
* 
*
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"

/*----------------------------- DEFINES -----------------------------------*/
//#define DBGBRK
//#define DBGDISP
#define CURSOR_DBG_LEVEL 1

#define  MAX_CNT           0x7FFF
#define  BLT_FLAG_BIT      0x2L
#define  BYTES_PER_TILE    0x800  // 2048


/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/
typedef union _HOST_DATA {
    BYTE    bData[4];
    DWORD   dwData;
} HOST_DATA;


/*-------------------------- STATIC VARIABLES -----------------------------*/

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/
VOID CopyLgHWPtrMaskData(PPDEV ppdev,
                         LONG  Ycord,
                         LONG  lSrcDelta,
                         LONG  cy,
                         ULONG tileszx,
                         BYTE  *pANDSrcScan,
                         BYTE  *pXORSrcScan);

ULONG ConvertMaskBufToLinearAddr(PPDEV ppdev);

VOID RestoreSaveShowCursor(PPDEV ppdev,
                           LONG  x,
                           LONG  y);

#if POINTER_SWITCH_ENABLED
    int pointer_switch=0;
#endif

#if LOG_QFREE
    unsigned long QfreeData[32];
#endif



/****************************************************************************
* FUNCTION NAME: InitPointerHW()
*
* DESCRIPTION:   Initialization the cursor palette colors.
*
****************************************************************************/
VOID InitPointerHW (PPDEV ppdev)
{
  ULONG   ultmp;

  // Enable HW cursor color access
  ultmp = LLDR_SZ (grPalette_State);
  ultmp |= 0x8;
  LL8 (grPalette_State, ultmp);

  // Write HW cursor BK & FG color
  ultmp = 0;
  LL8 (grPalette_Write_Address, ultmp);
  LL8 (grPalette_Data, ultmp);
  LL8 (grPalette_Data, ultmp);
  LL8 (grPalette_Data, ultmp);
  
  ultmp = 0xF;
  LL8 (grPalette_Write_Address, ultmp);

  ultmp = 0xFF;
  LL8 (grPalette_Data, ultmp);
  LL8 (grPalette_Data, ultmp);
  LL8 (grPalette_Data, ultmp);

  // Disable HW cursor color access
  ultmp = LLDR_SZ (grPalette_State);
  ultmp &= 0xFFF7;
  LL8 (grPalette_State, ultmp);
}



/****************************************************************************
* FUNCTION NAME: InitPointer()
*
* DESCRIPTION:   Initialization the variables used by the pointer.
*
* REVISION HISTORY:
*   6/20/95     Benny Ng      Initial version
****************************************************************************/
VOID InitPointer(PPDEV ppdev)
{
  ULONG   ultmp;
  SIZEL   reqsz;

  ppdev->PointerUsage = HW_CURSOR;
  DISPDBG((CURSOR_DBG_LEVEL, "HW cursor\n"));

  ppdev->bYUVuseSWPtr = FALSE;
  ppdev->PtrImageHandle = NULL;
  ppdev->PtrABltHandle = NULL;

  // Get the current tile size
  if (ppdev->lTileSize == (LONG) 128)
  {
     reqsz.cx = 128;  
     reqsz.cy = 8;
  }
  else if (ppdev->lTileSize == (LONG) 256)
  {
     reqsz.cx = 256;
     reqsz.cy = 4;
  }
  else
  {
     reqsz.cx = 1024;
     reqsz.cy = 1;
  };

  InitPointerHW (ppdev);

  // Allocate the mask buffer from offscreen memory
  DISPDBG((CURSOR_DBG_LEVEL, "Allocating Pointer Mask\n"));
  ppdev->PtrMaskHandle = AllocOffScnMem(ppdev, &reqsz, 0, NULL);

#ifdef WINNT_VER40
  ppdev->CShsem = NULL;
#endif
}



/****************************************************************************
* FUNCTION NAME: DrvMovePointer()
*
* DESCRIPTION:   This function Moves the hardware pointer to a new position.
*
* REVISION HISTORY:
*   6/20/95     Benny Ng      Initial version
****************************************************************************/
VOID DrvMovePointer(SURFOBJ *pso,
                    LONG     x,
                    LONG     y,
                    RECTL   *prcl)
{
    LONG  adjx, adjy;
    LONG  delaycnt = 0;

    PPDEV ppdev = (PPDEV) pso->dhpdev;

    if (x==0 && y==0)
    {
        // 
        // This isn't used in the released code.  This is test code for setting
        // the sw_test_flag to different values by pointing the cursor to 
        // 'special' places.  Used to turn different test features on and off.
        //
        #if (POINTER_SWITCH_ENABLED)
       	    if (pointer_switch)
                pointer_switch = 0;
            else
                pointer_switch = 1;
        #endif

   	    #if ENABLE_LOG_SWITCH && POINTER_SWITCH_ENABLED
       	    if (pointer_switch)
            {
                CreateLogFile(ppdev->hDriver, &ppdev->TxtBuffIndex);
                ppdev->pmfile = ppdev->hDriver;   // handle to the miniport
                lg_i = sprintf(lg_buf, "Log file opened\r\n");
                WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

            }
            else
   	           CloseLogFile(ppdev->pmfile, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
   	    #endif

        #if NULL_HW
            //
            // Enables and disables the "infinitly fast hardware" feature.
            // then "on" all register writes go to a chunk of blank memory 
            // on the host.  Register reads proceed normally.
            //
    	    if (ppdev->pLgREGS == ppdev->pLgREGS_real)
	        	ppdev->pLgREGS = (GAR *)ppdev->buffer;
	        else
    	    	ppdev->pLgREGS = ppdev->pLgREGS_real;
        #endif

        #if LOG_QFREE
        {
            int i;
            
            DISPDBG((CURSOR_DBG_LEVEL,"Dumping QFREE log.\n"));
            lg_i = sprintf(lg_buf,"\r\n\r\n");
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

            for (i=0; i<32; ++i)
            {
                lg_i = sprintf(lg_buf,"QFREE %d: %d times.\r\n", i, QfreeData[i]);
                WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
                QfreeData[i] = 0;
            }
        }
        #endif    
   	} // End if x==0 and y==0


    #if LOG_CALLS
        #if ENABLE_LOG_SWITCH
        if (pointer_switch)
        #endif
        {
            lg_i = sprintf(lg_buf,"DrvMovePointer: x=%d, y=%d \r\n", x, y);
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
        }
    #endif


    #if NULL_POINTER
        if (pointer_switch)	return;
    #endif

    if ((ppdev->PointerUsage == DEF_CURSOR) ||
        (ppdev->PtrMaskHandle == NULL))
		return;

    adjx = x;
    adjy = y;

    // Check whether want to hide the pointer.
    if (x == -1)
    {
	    #if HW_PRESET_BUG
            LL16 (grCursor_X, (WORD)0xFFFF);
            LL16 (grCursor_Y, (WORD)0xFFFF);
 	    #else
        	// Disable the Hw cursor by clearing the hw cursor enable
            // bit in CURSOR_CONTROL reg
            ultmp = LLDR_SZ (grCursor_Control);
            if (ultmp & 1)
            {
                ultmp &= 0xFFFE;
                LL16 (grCursor_Control, ultmp);
            }
	    #endif
    }

    else if ((adjx >= 0) && (adjy >= 0))
    {
	    // Restore the current pointer area screen image from offscreen memory.
     	// Save the new pointer area screen image to offscreen memory.
     	// Show the curosr using both AND and XOR masks
     	RestoreSaveShowCursor(ppdev, adjx, adjy);

     	ppdev->PtrX = adjx;
     	ppdev->PtrY = adjy;

        if (prcl != NULL)
        {
           	prcl->left = ppdev->PtrX;
          	prcl->top  = ppdev->PtrY;
          	prcl->right  = prcl->left + ppdev->PtrSzX;
          	prcl->bottom = prcl->top  + ppdev->PtrSzY;

 	        ppdev->prcl.left = prcl->left;
    	    ppdev->prcl.top  = prcl->top;
    	    ppdev->prcl.right = prcl->right;
    	    ppdev->prcl.bottom = prcl->bottom;
        }
    }
    return;
}



/****************************************************************************
* FUNCTION NAME: DrvSetPointerShape()
*
* DESCRIPTION:   This function sets the new pointer shape.
*
* REVISION HISTORY:
*   6/20/95     Benny Ng      Initial version
****************************************************************************/
ULONG DrvSetPointerShape(SURFOBJ  *pso,
                         SURFOBJ  *psoMask,
                         SURFOBJ  *psoColor,
                         XLATEOBJ *pxlo,
                         LONG      xHot,
                         LONG      yHot,
                         LONG      x,
                         LONG      y,
                         RECTL    *prcl,
                         FLONG     fl)
{

  BOOL    bAnimatedCursor = FALSE;
  LONG    lSrcDelta;
  ULONG   retul;
  ULONG   cx, cy;
  LONG    bpp;
  SIZEL   tilesz;
  SIZEL   reqsz;
  BYTE    *pANDSrcScan;
  BYTE    *pXORSrcScan;
  LONG    Ycord;
  ULONG   curloc;
  ULONG   ultmp;
  PPDEV   ppdev = (PPDEV) pso->dhpdev;

    #if NULL_POINTER
        if (pointer_switch)
		return SPS_ACCEPT_NOEXCLUDE;
    #endif
   
    DISPDBG((CURSOR_DBG_LEVEL, "DrvSetPointerShape %d, x=%d, y=%d, xHot=%d, yHot=%d\n",
           ppdev->PointerUsage, x, y, xHot, yHot));

    // If no HW cursor mask buffer allocated from offscreen memory,
    // or If in intrelace mode, Use SW cursor
    // Use SW cursor
    if ((ppdev->PtrMaskHandle == NULL) || (ppdev->ulFreq < 50))
       return (SPS_DECLINE);

    // HW cursor bug in 1600x1200-8bpp & 16bpp with refresh rate 65,
    // 70 or 75Hz. Use SW cursor
    if ((ppdev->cxScreen == 1600) && (ppdev->cyScreen == 1200) &&
        ((ppdev->ulBitCount == 8) || (ppdev->ulBitCount == 16)))
    {
       if (ppdev->ulFreq >= 65)
          return (SPS_DECLINE);
    };

    // Don't use HW cursor if resolution below 640x480
    if ((ppdev->cxScreen < 640) || (ppdev->cyScreen < 480))
       return (SPS_DECLINE);

    // Get dimensions of the pointer
    cx = psoMask->sizlBitmap.cx ;
    cy = psoMask->sizlBitmap.cy >> 1;

    // Calculate bytes per pixel
    bpp = ppdev->iBytesPerPixel;

    // Get the current tile size
    if (ppdev->lTileSize == (LONG) 128)
    {
        tilesz.cx = 128;	
	    tilesz.cy = 16;
    }
    else if (ppdev->lTileSize == (LONG) 256)
    {
        tilesz.cx = 256;
	    tilesz.cy = 8;
    }
    else
    {
        tilesz.cx = 2048;
	    tilesz.cy = 1;
    };

    lSrcDelta = psoMask->lDelta;
    retul = SPS_ACCEPT_NOEXCLUDE; // We can still draw while HW cursor is on the screen.

    // Check whether we should let the GDI handle the pointer
    if ((ppdev->PointerUsage == DEF_CURSOR) ||
        (psoMask == (SURFOBJ *) NULL)       ||
        (cx > HW_POINTER_DIMENSION)         ||
        (cy > (HW_POINTER_DIMENSION - 1))   ||
        (psoColor != NULL)       ||
        (fl & SPS_ASYNCCHANGE)	|| // We can't change the cursor shape while drawing.
        (fl & SPS_ANIMATESTART)	|| // We don't do animated cursors
        (fl & SPS_ANIMATEUPDATE) || // We don't do animated cursors
        !(fl & SPS_CHANGE))
    {
        bAnimatedCursor = TRUE;

	    #if HW_PRESET_BUG
            LL16 (grCursor_X, (WORD)0xFFFF);
            LL16 (grCursor_Y, (WORD)0xFFFF);
	    #else
            // Disable the Hw cursor by clearing the hw cursor enable
            // bit in CURSOR_CONTROL reg
            ultmp = LLDR_SZ (grCursor_Control);
            if (ultmp & 1)
            {
                ultmp &= 0xFFFE;
                LL16 (grCursor_Control, ultmp);
            }
	    #endif
    };

    // Save the position informations
    //
    ppdev->PtrXHotSpot = xHot;
    ppdev->PtrYHotSpot = yHot;
    ppdev->PtrSzX = cx;
    ppdev->PtrSzY = cy;

    // Setup the AND and XOR mask data pointer
    pANDSrcScan = psoMask->pvScan0;
    pXORSrcScan = psoMask->pvScan0;
    pXORSrcScan += (cy * lSrcDelta);

    // If animated cursor generate the XOR mask from psoColor->pvScan0
    // data
    if ((bAnimatedCursor) && (psoColor != NULL))
    {
       PDSURF  pDSURF;
       POFMHDL pOFMHDL;
       SURFOBJ*  pDsurfSo;
       BYTE  XorMaskBuf[130];
       BYTE  *pColorSrcScan;
       BYTE  maskval;
       LONG  ii, jj, kk, mm;
       BOOL  bCalc;

       bCalc = FALSE;
       pColorSrcScan = NULL;
       if (psoColor->pvScan0 != NULL)
       {
          // From host memory
          pColorSrcScan = psoColor->pvScan0;
       }
       else
       {
          // From device bitmap
          pDSURF  = (DSURF *) psoColor->dhsurf;
          pDsurfSo = (SURFOBJ*) pDSURF->pso;

          if (pDsurfSo != NULL)
          {
             pColorSrcScan = pDsurfSo->pvScan0;
          }
          else
          {
             pOFMHDL = (OFMHDL *) pDSURF->pofm;
             if (pOFMHDL != NULL)
             {
                bCalc = TRUE;
                pColorSrcScan = (BYTE *)((pOFMHDL->aligned_y * ppdev->lDeltaScreen) +
                                          pOFMHDL->aligned_x + (ULONG) ppdev->pjScreen);
             };  // endif (pOFMHDL != NULL)
          };  // endif (pDsurfSo != NULL)
       };  // endif (psoColor->pvScan0 != NULL)

       if (pColorSrcScan != NULL)
       {
          mm = 0;
          for (ii=0; ii < 0x20; ii++)
          {
            for (jj=0; jj < 0x4; jj++)
            {
              maskval = 0;
              for (kk=0; kk < 0x8; kk++)
              {
                maskval = maskval << 1;
   
                if ((*pColorSrcScan & 1) != 0)
                   maskval |= 0x1;
   
                pColorSrcScan += ppdev->iBytesPerPixel;
   
              };  // endfor kk
   
              XorMaskBuf[mm++] = maskval;
   
            };  // endfor jj

            if (bCalc)
            {
               pColorSrcScan = (BYTE *)(((pOFMHDL->aligned_y+ii) * ppdev->lDeltaScreen) +
                                          pOFMHDL->aligned_x + (ULONG) ppdev->pjScreen);
            };

          };  // endfor ii

          pXORSrcScan = &XorMaskBuf[0];

       };  // endif (pColorSrcScan != NULL)
    };  // endif (bAnimatedCursor)

    // Set Laguna Command Control Register SWIZ_CNTL bit
    ppdev->grCONTROL |= SWIZ_CNTL;
    LL16(grCONTROL, ppdev->grCONTROL);

    // Setup the laguna registers for byte to byte BLT extents
	REQUIRE(6);
    LL_DRAWBLTDEF(0x102000CC, 0);
    LL_OP1 (0,0);
    Ycord = ppdev->PtrMaskHandle->aligned_y;
    LL_OP0_MONO (ppdev->PtrMaskHandle->aligned_x, Ycord);

    // Use the AND and XOR mask to create the mask buffer for Laguna HW.
    CopyLgHWPtrMaskData(ppdev, Ycord, lSrcDelta, cy, tilesz.cx, pANDSrcScan, pXORSrcScan);

    // Set the HW cursor mask location register
    curloc = ConvertMaskBufToLinearAddr(ppdev);
    curloc = (curloc >> 8) & 0xFFFC;
    LL16 (grCursor_Location, curloc);

    // Clear Laguna Command Control Register SWIZ_CNTL bit
    ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
    LL16(grCONTROL, ppdev->grCONTROL);

    // Specific the exclude rectange
    if (prcl != NULL)
    {
       prcl->left = x - xHot;
       prcl->top  = y - yHot;
       prcl->right  = prcl->left + cx;
       prcl->bottom = prcl->top  + cy;

       ppdev->prcl.left = prcl->left;
       ppdev->prcl.top  = prcl->top;
       ppdev->prcl.right = prcl->right;
       ppdev->prcl.bottom = prcl->bottom;
    };

    if (bAnimatedCursor)
    {
        DISPDBG((CURSOR_DBG_LEVEL, "DrvSetPointerShape - SPS_DECLINE\n"));

        // Indicate use animiated cursor
        ppdev->bYUVuseSWPtr = TRUE;

        if (!ppdev->bYUVSurfaceOn)
            return (SPS_DECLINE);
    };

    if ((ppdev->bYUVuseSWPtr) && (x == -1) && (y == -1))
    {
	    #if HW_PRESET_BUG
            LL16 (grCursor_X, (WORD)0xFFFF);
            LL16 (grCursor_Y, (WORD)0xFFFF);
	    #else
            // Disable the Hw cursor by clearing the hw cursor enable
            // bit in CURSOR_CONTROL reg
            ultmp = LLDR_SZ (grCursor_Control);
            if (ultmp & 1)
            {
                ultmp &= 0xFFFE;
                LL16 (grCursor_Control, ultmp);
            }
	    #endif

       ppdev->bYUVuseSWPtr = FALSE;

       return (SPS_DECLINE);
    };

    // Enable the Hw cursor by setting the hw cursor enable
    // bit in CURSOR_CONTROL reg
    ultmp = LLDR_SZ (grCursor_Control);
    if ((ultmp & 1) == 0)
    {
       ultmp |= 0x0001;
       LL16 (grCursor_Control, ultmp);
    };

    // Indicate use HW cursor
    ppdev->bYUVuseSWPtr = FALSE;

    // Show the pointer by using the mask buffer
    DrvMovePointer(pso, x, y, prcl);

    return (retul);
}



/****************************************************************************
* FUNCTION NAME: CopyLgHWPtrMaskData()
*
* DESCRIPTION:   Using the AND & XOR source mask data to generate
*                a 64x64 bits pointer size mask buffer in the offscreen
*                memory for Laguna HW.
*
* REVISION HISTORY:
*   6/20/95     Benny Ng      Initial version
****************************************************************************/
VOID CopyLgHWPtrMaskData(PPDEV ppdev,
                         LONG  Ycord,
                         LONG  lSrcDelta,
                         LONG  cy,
                         ULONG tileszx,
                         BYTE  *pANDSrcScan,
                         BYTE  *pXORSrcScan)
{
  LONG       i, j, k;
  LONG       cnt;
  LONG       DWcnt;
  PDWORD     pPattern;
  LONG       TileSize;
  HOST_DATA  MaskPattern;

  pPattern = &MaskPattern.dwData;

  TileSize = ppdev->lTileSize;
  REQUIRE(3);
  LL_MBLTEXT (TileSize, (1024/TileSize));

  DWcnt = tileszx / sizeof(DWORD);

  // Copy the mask data into the 64x64 space with unused portion
  // fill with AND or XOR default mask value.
  cnt = DWcnt;
  k = 0;
  for (i=0; i < 64; i++)
  {
    // Copy XOR mask
    for (j=0; j < 8; j++)
    {
      // Copy one screen line mask data from source to destination
      if ((j < lSrcDelta) && (i < cy))
      {
         MaskPattern.bData[k++] = *pXORSrcScan;
         pXORSrcScan++;
      }
      else
      {
         MaskPattern.bData[k++] = 0x0;
      };
  
      if (k > 3)
      {
		 REQUIRE(1);
         LL32 (grHOSTDATA[0], *pPattern);

         k = 0;
         cnt--;
      };  // endif (k > 3)
    }; // endfor j

    // Copy AND mask
    for (j=0; j < 8; j++)
    {
      // Copy one screen line mask data from source to destination
      if ((j < lSrcDelta) && (i < cy))
      {
         MaskPattern.bData[k++] = *pANDSrcScan;
         pANDSrcScan++;
      }
      else
      {
         MaskPattern.bData[k++] = 0xFF;
      };
  
      if (k > 3)
      {
         *pPattern = ~ *pPattern;
		 REQUIRE(1);
         LL32 (grHOSTDATA[0], *pPattern);

         k = 0;
         cnt--;
      };  // endif (k > 3)
    }; // endfor j

    // Check whether one tile row size of host data is written to the
    // HOSTDATA register. 
    if (cnt == 0)
    {
       // Reset the row data count
       cnt = DWcnt;
    };  // endif (cnt == 0)
  }; // end for i
};
 


/****************************************************************************
* FUNCTION NAME: RestoreSaveShowCursor()
*
* DESCRIPTION:   Restore the screen image (if needed), save the new
*                cursor location the image to offscreen memory and
*                show the cursor in the new location
*
* REVISION HISTORY:
*   6/20/95     Benny Ng      Initial version
****************************************************************************/
VOID RestoreSaveShowCursor(PPDEV ppdev,
                           LONG  x,
                           LONG  y)
{
  ULONG  curloc;
  LONG   ltmpX, ltmpY;

  DISPDBG((CURSOR_DBG_LEVEL, "DrvMovePointer - RestoreSaveShowCursor\n"));

    ltmpX = x;
    ltmpY = y;

    // Set Hw cursor preset register
    curloc = 0;

    if ((ltmpY = (y - ppdev->PtrYHotSpot)) < 0)
    {
       curloc = (-ltmpY) & 0x7F;
       ltmpY = 0;
    }

    if ((ltmpX = (x - ppdev->PtrXHotSpot)) < 0)
    {
       curloc = curloc | (((-ltmpX) << 8) & 0x7F00);
       ltmpX = 0;
    }

    LL16 (grCursor_Preset, curloc);

    // Set Hw cursor X & Y registers
    LL16 (grCursor_X, (WORD)ltmpX);
    LL16 (grCursor_Y, (WORD)ltmpY);

    return;
}; 



/****************************************************************************
* FUNCTION NAME: ConvertMaskBufToLinearAddr()
*
* DESCRIPTION:   Convert the HW cursor mask buffer address to linear offset
*                address.
*
* Input:         Pointer to the OFMHDL structure.
*
* Output:        32-bits Linear address pointer.
*
* REVISION HISTORY:
*   6/12/95     Benny Ng      Initial version
****************************************************************************/
ULONG ConvertMaskBufToLinearAddr(PPDEV ppdev)
{
#if DRIVER_5465
  ULONG  Page;
  ULONG  Bank;
  ULONG  CurLoc;
  ULONG  DP;
#endif  // DRIVER_5465

  ULONG  retaddr;
  ULONG  xtile, ytile;
  ULONG  tileszx, tileszy;
  ULONG  tileno;
  ULONG  xByteOffset, yByteOffset;
  ULONG  bpp;
  ULONG  TilesPerLine, Interleave;

#ifdef DBGDISP
  DISPDBG((CURSOR_DBG_LEVEL, "ConvertMaskBufToLinearAddr\n"));
#endif

  // Calculate the linear address from the X & Y coordinate
  if ((ppdev->lTileSize == (LONG) 128) || (ppdev->lTileSize == (LONG) 256))
  {
    if (ppdev->lTileSize == (LONG) 128)
    {
        tileszx = 128;
        tileszy = 16;
    }
    else if (ppdev->lTileSize == (LONG) 256)
    {
        tileszx = 256;
        tileszy = 8;
    };

    Interleave = LLDR_SZ(grTILE_CTRL);
    TilesPerLine = Interleave & 0x3F;
    Interleave = ((Interleave >> 6) & 0x3);
    Interleave = 1 << Interleave;
     
    bpp = ppdev->ulBitCount/8;

    #if DRIVER_5465
         DP = TilesPerLine * tileszx;
         Page = (ppdev->PtrMaskHandle->aligned_y) /
                (tileszy * Interleave) * TilesPerLine +
                (ppdev->PtrMaskHandle->aligned_x/tileszx);

         Bank = (((ppdev->PtrMaskHandle->aligned_x / tileszx) +
                  (ppdev->PtrMaskHandle->aligned_y / tileszy)) % Interleave) +
                 ((Page/512) << (Interleave >> 1));

         Page = Page & 0x1FF;
       
         CurLoc = (Bank<<20) + (Page<<11) +
                  (ppdev->PtrMaskHandle->aligned_y % tileszy) * tileszx;
       
         retaddr = CurLoc;
    #else
         // calculate x tile coordinate and byte offset into tile due to x
         // xTileCoord  = x / TileWidth
         // xByteOffset = x % TileWidth

         xtile = ppdev->PtrMaskHandle->aligned_x / tileszx;
         xByteOffset = ppdev->PtrMaskHandle->aligned_x % tileszx;

         // calculate y tile coordinate and byte offset into tile due to y
         // yTileCoord  =  y / TileHeight
         // yByteOffset = (y % TileHeight) * TileWidth
         // byteOffset  = yByteOffset + xByteOffset

         ytile = ppdev->PtrMaskHandle->aligned_y / tileszy;
         yByteOffset = (ppdev->PtrMaskHandle->aligned_y % tileszy) * tileszx;

         // calculate tile number from start of RDRAM
         // (the LS 0,1,or 2 bits of this will become the bank selects based
         //	on interleave of 1,2,or 4)
         //
         //  tileNo = ((yTile / Interleave) * TilesPerLine) * Interleave
         //           + xTile * Interleave
         //	         + (yTile + xTile) % Interleave
         // (the "+xTile" takes care of interleave rotation)

         tileno = (((ytile / Interleave) * TilesPerLine) * Interleave)
                  + (xtile * Interleave)
                  + ((ytile + xtile) % Interleave);

         // calculate linear offset
         //   LinOffset = tileNo * BYTES_PER_TILE + xByteOffset + yByteOffset
         retaddr = (tileno * BYTES_PER_TILE) + xByteOffset + yByteOffset;
    #endif  // DRIVER_5465
  }
  else 
  {
     // Calculate the linear address from the X & Y coordinate
     retaddr = (ULONG) ppdev->PtrMaskHandle->aligned_x +
               (ULONG) ppdev->lDeltaScreen * ppdev->PtrMaskHandle->aligned_y;
  };

  return (retaddr);
};


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\path.c ===
/******************************Module*Header*******************************\
*
* $Workfile:   PATH.C  $
*
* Author: Noel VanHook
* Date: Jan 10, 1996
*
* Purpose: Handle calls to DrvStokeAndFillPath.
*
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/path.c  $
* 
*    Rev 1.7   21 Mar 1997 12:21:42   noelv
* Combined "do_flag" and "sw_test_flag" together into "pointer_switch"
* 
*    Rev 1.6   26 Nov 1996 09:57:52   noelv
* Added DBG prints.
* 
*    Rev 1.5   06 Sep 1996 15:16:36   noelv
* Updated NULL driver for 4.0
* 
*    Rev 1.4   20 Aug 1996 11:04:08   noelv
* Bugfix release from Frido 8-19-96
* 
*    Rev 1.3   17 Aug 1996 14:03:28   frido
* Added PVCS header.
*
\**************************************************************************/

#include "precomp.h"

#define PATH_DBG_LEVEL 1

//
// Since we don't accelerate these, we only hook them for analysys purposes.
// Otherwise, skip the entire file.
//
#if NULL_STROKEFILL || PROFILE_DRIVER

//
// Table to convert ROP2 codes to ROP3 codes.
//

extern BYTE Rop2ToRop3[]; // See paint.c


//
// Driver profiling stuff.
// Gets compiled out in a free bulid.
//
#if PROFILE_DRIVER
    void DumpStrokeAndFillInfo(INT acc, SURFOBJ* pso, MIX mix, BRUSHOBJ* pbo);
#else
    #define DumpStrokeAndFillInfo(acc, pso, mix, pbo)
#endif

/**************************************************************************\
* DrvStrokeAndFillPath								                       *
*									                                       *
* We don't currently accelerate this, but we hook it for analysis.         *
*									                                       *
\**************************************************************************/

BOOL DrvStrokeAndFillPath
(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pboStroke,
    LINEATTRS *plineattrs,
    BRUSHOBJ  *pboFill,
    POINTL    *pptlBrushOrg,
    MIX        mix,
    FLONG      flOptions
)
{
    #if NULL_STROKEFILL
    {
    	if (pointer_switch)	return TRUE;
    }
    #endif

    DISPDBG((PATH_DBG_LEVEL, "DrvStrokeAndFillPath.\n"));

    //
    // Dump info on what is being punted to a file.
    //
    DumpStrokeAndFillInfo(0, pso, mix, pboStroke);
    
    //
    // Punt it back to GDI.
    //
    return FALSE;
}






// ==================================================================

#if PROFILE_DRIVER
void DumpStrokeAndFillInfo(
	INT	  acc,
	SURFOBJ*  pso,
	MIX 	  mix,
	BRUSHOBJ* pbo)
{

    PPDEV ppdev;

    ppdev = (PPDEV) (pso ? pso->dhpdev : 0); 	    


    //////////////////////////////////////////////////////////////
    // Profiling info to keep track of what GDI is asking us to do.
    //
    if (!ppdev)
    {
	    RIP(("DrvStrokeAndFillPath() with no clipOBJ and no PDEV!\n"));
    }
    else
    {

    	fprintf(ppdev->pfile,"DrvStrokeAndFillPath: ");
	
        fprintf(ppdev->pfile,"(PUNT) ");

	//
	// Check the DEST
	//
	fprintf(ppdev->pfile,"DEST=%s ", (ppdev ? "FB" : "HOST?") );

	//
	// Check the MIX
	//
    	fprintf(ppdev->pfile,"Mix=0x%08X ", mix);

	//
	// Type of pattern.
        //
	if (pbo == NULL)
            fprintf(ppdev->pfile,"BRUSH=NONE ");

	else if (pbo->iSolidColor == 0xFFFFFFFF )
 	{
            fprintf(ppdev->pfile,"BRUSH=PATTERN ");
	}
	else
	{
            fprintf(ppdev->pfile,"BRUSH=SOLID ");
	    fprintf(ppdev->pfile,"COLOR = 0x%08X ",(pbo->iSolidColor));
	}

        fprintf(ppdev->pfile,"\n");
        fflush(ppdev->pfile);
    }
}
#endif // PROFILE_DRIVER

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\pattern.c ===
/******************************Module*Header*******************************\
* Module Name: pattern.c
*
* Used for creating and destroying the default patterns to be used on this
* device.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Data*Struct*************************\
* gaajPat
*
* These are the standard patterns defined Windows, they are used to produce
* hatch brushes, grey brushes etc.
*
\**************************************************************************/

const BYTE gaajPat[HS_DDI_MAX][32] = {

    { 0x00,0x00,0x00,0x00,                 // ........     HS_HORIZONTAL 0
      0x00,0x00,0x00,0x00,                 // ........
      0x00,0x00,0x00,0x00,                 // ........
      0xff,0x00,0x00,0x00,                 // ********
      0x00,0x00,0x00,0x00,                 // ........
      0x00,0x00,0x00,0x00,                 // ........
      0x00,0x00,0x00,0x00,                 // ........
      0x00,0x00,0x00,0x00 },               // ........

    { 0x08,0x00,0x00,0x00,                 // ....*...     HS_VERTICAL 1
      0x08,0x00,0x00,0x00,                 // ....*...
      0x08,0x00,0x00,0x00,                 // ....*...
      0x08,0x00,0x00,0x00,                 // ....*...
      0x08,0x00,0x00,0x00,                 // ....*...
      0x08,0x00,0x00,0x00,                 // ....*...
      0x08,0x00,0x00,0x00,                 // ....*...
      0x08,0x00,0x00,0x00 },               // ....*...

    { 0x80,0x00,0x00,0x00,                 // *.......     HS_FDIAGONAL 2
      0x40,0x00,0x00,0x00,                 // .*......
      0x20,0x00,0x00,0x00,                 // ..*.....
      0x10,0x00,0x00,0x00,                 // ...*....
      0x08,0x00,0x00,0x00,                 // ....*...
      0x04,0x00,0x00,0x00,                 // .....*..
      0x02,0x00,0x00,0x00,                 // ......*.
      0x01,0x00,0x00,0x00 },               // .......*

    { 0x01,0x00,0x00,0x00,                 // .......*     HS_BDIAGONAL 3
      0x02,0x00,0x00,0x00,                 // ......*.
      0x04,0x00,0x00,0x00,                 // .....*..
      0x08,0x00,0x00,0x00,                 // ....*...
      0x10,0x00,0x00,0x00,                 // ...*....
      0x20,0x00,0x00,0x00,                 // ..*.....
      0x40,0x00,0x00,0x00,                 // .*......
      0x80,0x00,0x00,0x00 },               // *.......

    { 0x08,0x00,0x00,0x00,                 // ....*...     HS_CROSS 4
      0x08,0x00,0x00,0x00,                 // ....*...
      0x08,0x00,0x00,0x00,                 // ....*...
      0xff,0x00,0x00,0x00,                 // ********
      0x08,0x00,0x00,0x00,                 // ....*...
      0x08,0x00,0x00,0x00,                 // ....*...
      0x08,0x00,0x00,0x00,                 // ....*...
      0x08,0x00,0x00,0x00 },               // ....*...

    { 0x81,0x00,0x00,0x00,                 // *......*     HS_DIAGCROSS 5
      0x42,0x00,0x00,0x00,                 // .*....*.
      0x24,0x00,0x00,0x00,                 // ..*..*..
      0x18,0x00,0x00,0x00,                 // ...**...
      0x18,0x00,0x00,0x00,                 // ...**...
      0x24,0x00,0x00,0x00,                 // ..*..*..
      0x42,0x00,0x00,0x00,                 // .*....*.
      0x81,0x00,0x00,0x00 }                // *......*
};

/******************************Public*Routine******************************\
* bInitPatterns
*
* This routine initializes the default patterns.
*
\**************************************************************************/

BOOL bInitPatterns(IN PPDEV ppdev, ULONG cPatterns)
{
    SIZEL           sizl;
    ULONG           ulLoop;

    sizl.cx = 8;
    sizl.cy = 8;

    for (ulLoop = 0; ulLoop < cPatterns; ulLoop++)
    {
        ppdev->ahbmPat[ulLoop] = EngCreateBitmap(sizl, 4, BMF_1BPP,
        BMF_TOPDOWN, (PULONG) (&gaajPat[ulLoop][0]));

        if (ppdev->ahbmPat[ulLoop] == (HBITMAP) 0)
        {
        // Set the count created so vDisablePatterns will clean up.

            ppdev->cPatterns = ulLoop;
            return(FALSE);
        }
    }

    ppdev->cPatterns = cPatterns;
    return(TRUE);
}

/******************************Public*Routine******************************\
* vDisablePatterns
*
* Delete the standard patterns allocated.
*
\**************************************************************************/

VOID vDisablePatterns(IN PPDEV ppdev)
{
    ULONG ulIndex;

// Erase all patterns.

    for (ulIndex = 0; ulIndex < ppdev->cPatterns; ulIndex++)
    {
        EngDeleteSurface((HSURF) ppdev->ahbmPat[ulIndex]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\precomp.h ===
/******************************************************************************\
*
* $Workfile:   PRECOMP.H  $
*
* Contents:
* Common headers used throughout the display driver. This entire include file
* will typically be pre-compiled.
*
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/PRECOMP.H  $
* 
*    Rev 1.10   Feb 16 1998 15:54:18   frido
* Removed rx.h from NT 5.0 headers.
* 
*    Rev 1.9   29 Aug 1997 17:14:46   RUSSL
* Added overlay support
*
*    Rev 1.8   08 Aug 1997 16:05:10   FRIDO
*
* Added mMCore.h file.
*
*    Rev 1.7   26 Feb 1997 13:20:20   noelv
*
* disable MCD code for NT 3.5x
*
*    Rev 1.6   26 Feb 1997 09:24:14   noelv
*
* Added MCD include files.
*
*    Rev 1.5   20 Jan 1997 14:48:32   bennyn
*
* Added ddinline.h
*
*    Rev 1.4   16 Jan 1997 11:41:22   bennyn
*
* Added pwrmgr.h & lgddmsg.h
*
*    Rev 1.3   01 Nov 1996 09:24:12   BENNYN
*
* Added shareable DD blt include files
*
*    Rev 1.2   20 Aug 1996 11:05:22   noelv
* Bugfix release from Frido 8-19-96
*
*    Rev 1.1   15 Aug 1996 11:38:56   frido
* First revision.
*
\******************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>

#ifdef WINNT_VER40
	#include <windef.h>
	#include <wingdi.h>
	#include <winerror.h>
#else
	#include <windows.h>
#endif

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <winddi.h>
#include <devioctl.h>
#include <ntddvdeo.h>
#include <ioaccess.h>
#if _WIN32_WINNT < 0x0500
	#include <rx.h>
#endif
#include <ntsdexts.h>
#include <dciddi.h>

#ifndef WINNT_VER35
    #include <mcdrv.h>              // OpenGL MCD ddk supplied header
#endif

#include "bltp.h"
#include "l2d.h"
#include "l3system.h"

#if DRIVER_5465 && defined(OVERLAY)
#include "overlay.h"
#include "5465bw.h"
#endif

#include "driver.h"
#include "HDtable.h"
#include "lines.h"
#include "Optimize.h"

#include "ddinline.h"
#include "lgddmsg.h"
#include "pwrmgr.h"
#include "mmCore.h"

/// Define the A vector polynomial bits
//
// Each bit corresponds to one of the terms in the polynomial
//
// Rop(D,S,P) = a + a D + a S + a P + a  DS + a  DP + a  SP + a   DSP
//               0   d     s     p     ds      dp      sp      dsp

#define AVEC_NOT    0x01
#define AVEC_D      0x02
#define AVEC_S      0x04
#define AVEC_P      0x08
#define AVEC_DS     0x10
#define AVEC_DP     0x20
#define AVEC_SP     0x40
#define AVEC_DSP    0x80

#define AVEC_NEED_SOURCE  (AVEC_S | AVEC_DS | AVEC_SP | AVEC_DSP)
#define AVEC_NEED_PATTERN (AVEC_P | AVEC_DP | AVEC_SP | AVEC_DSP)
#define AVEC_NEED_DEST    (AVEC_D | AVEC_DP | AVEC_DS | AVEC_DSP)

// This is Laguna specific or 3 OP ROP specific

#define ROP3MIX(fg, bg)	((fg & 0xCC) | (bg & 0x33))

// SWAP - Swaps the value of two variables, using a temporary variable

#define SWAP(a, b, tmp) { (tmp) = (a); (a) = (b); (b) = (tmp); }

#if defined(i386)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}
#endif

#define BD_OP1_IS_SRAM_MONO (BD_OP1 * IS_SRAM_MONO)

#ifdef DEBUG

#define ASSERTDD(x, y) if (!(x)) RIP (y)

#else

#define ASSERTDD(x, y)

#endif

typedef VOID (FNFILL)(PDEV*, LONG, RECTL*, ULONG, ULONG, BRUSHOBJ*, POINTL*);

//
// File Prototypes
BOOL bIntersect(RECTL*  prcl1, RECTL*  prcl2, RECTL*  prclResult);
BOOL bSetMask(PPDEV	ppdev, BRUSHOBJ *pbo, POINTL   *pptlBrush, ULONG  *bltdef);
BOOL bMmFastFill(
PDEV*       ppdev,
LONG        cEdges,         // Includes close figure edge
POINTFIX*   pptfxFirst,
ULONG       ulHwForeMix,
ULONG       ulHwBackMix,
ULONG       iSolidColor,
BRUSHOBJ*  pbo);

VOID vMmFillSolid(              // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           ulHwForeMix,    // Hardware mix mode
ULONG           ulHwBackMix,    // Not used
BRUSHOBJ*    	 pbo,            // Drawing colour is pbo->iSolidColor
POINTL*         pptlBrush);      // Not used

VOID vMmFillPatFast(            // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           ulHwForeMix,    // Hardware mix mode (foreground mix mode if
                                //   the brush has a mask)
ULONG           ulHwBackMix,    // Not used (unless the brush has a mask, in
                                //   which case it's the background mix mode)
BRUSHOBJ*		 pbo,            // pbo
POINTL*         pptlBrush);      // Pattern alignment

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\stretch.c ===
/****************************************************************************
*****************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna I (CL-GD5462) - 
*
* FILE:     stretch.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module implements the DrvStretchBlt() function for the
*           Laguna NT driver.
*
* MODULES:
*           AdjustSrcSize()
*           bRectIntersect()
*           cRectIntersect()
*           Shrink()
*           Stretch()
*           CopySrcToOffMem()
*           bStretchDIB()
*           HandleCase_1()
*           DrvStretchBlt()
*
* REVISION HISTORY:
*   7/11/95     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/STRETCH.C  $
* 
*    Rev 1.14   Nov 03 1997 11:10:48   frido
* Added REQUIRE and WRITE_STRING macros.
* 
*    Rev 1.13   08 Apr 1997 12:29:06   einkauf
* 
* add SYNC_W_3D to coordinate MCD/2D access
* 
*    Rev 1.12   21 Mar 1997 12:22:16   noelv
* Combined "do_flag" and "sw_test_flag" together into "pointer_switch"
* 
*    Rev 1.11   07 Mar 1997 10:15:58   SueS
* Handle NULL pointer in DrvStretchBlt.
* 
*    Rev 1.10   06 Sep 1996 15:16:40   noelv
* Updated NULL driver for 4.0
* 
*    Rev 1.9   20 Aug 1996 11:04:26   noelv
* Bugfix release from Frido 8-19-96
* 
*    Rev 1.1   15 Aug 1996 11:39:42   frido
* Added precompiled header.
* 
*    Rev 1.0   14 Aug 1996 17:16:30   frido
* Initial revision.
* 
*    Rev 1.8   16 May 1996 15:01:40   bennyn
* 
* Add PIXEL_ALIGN to allocoffscnmem()
* 
*    Rev 1.7   04 Apr 1996 13:20:28   noelv
* No change.
* 
*    Rev 1.6   15 Mar 1996 09:40:00   andys
* 
* Removed BITMASK setting from code
* 
*    Rev 1.5   13 Mar 1996 11:11:20   bennyn
* Added device bitmap support
* 
*    Rev 1.4   07 Mar 1996 18:23:50   bennyn
* 
* Removed read/modify/write on CONTROL reg
* 
*    Rev 1.3   05 Mar 1996 11:59:10   noelv
* Frido version 19
 * 
 *    Rev 1.1   20 Jan 1996 01:16:50   frido
 *  
* 
*    Rev 1.5   10 Jan 1996 16:11:12   NOELV
* Added NULL driver ability.
* 
*    Rev 1.4   18 Oct 1995 14:09:06   NOELV
* 
* Fixed the mess I made of STRETCH.C  I was writing to the BLT extents instea
* 
*    Rev 1.3   18 Oct 1995 12:10:26   NOELV
* 
* Reworked register writes.
* punted 16,24, and 32 bpp
* 
*    Rev 1.2   06 Oct 1995 13:50:26   bennyn
* 
*    Rev 1.1   22 Aug 1995 16:40:38   bennyn
* 
*    Rev 1.3   15 Aug 1995 11:27:28   bennyn
* 
*    Rev 1.2   07 Aug 1995 08:02:34   bennyn
* 
*    Rev 1.1   02 Aug 1995 12:13:04   bennyn
* 
*    Rev 1.0   11 Jul 1995 15:14:16   BENNYN
* Initial revision.
* 
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"

/*----------------------------- DEFINES -----------------------------------*/
//#define PUNTBRK
//#define DBGBRK
#define DBGDISP
#define OPTION_1
//#define OPTION_2
//#define OPTION_3

#define X_INTERP_ENABLE        0x1
#define Y_INTERP_ENABLE        0x2
#define X_SHRINK_ENABLE        0x4
#define Y_SHRINK_ENABLE        0x8

#define _32K                   32768
#define SF                     0x10000L


/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/
typedef union _HOST_DATA {
    BYTE    bData[4];
    DWORD   dwData;
} HOST_DATA;


/*-------------------------- STATIC VARIABLES -----------------------------*/

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/



/****************************************************************************
* FUNCTION NAME: AdjustSrcSize()
*
* DESCRIPTION:   If the destination rectange is changed due to the clipping,
*                the source rectange size need to proportional change.
*                This routine handles the source size change calcualtion.
*
* RETURN:        TRUE: Punt it.
*
* REVISION HISTORY:
*   7/27/95     Benny Ng      Initial version
****************************************************************************/
BOOL AdjustSrcSize(LONG dx,
                   LONG dy,
                   LONG origdx,
                   LONG origdy,
                   LONG dszX,
                   LONG dszY,
                   LONG origdszX,
                   LONG origdszY,
                   LONG *sszX,
                   LONG *sszY,
                   LONG *XsrcOff,
                   LONG *YsrcOff)
{
  LONG ratioX, ratioY;
  LONG ltemp;
  UINT orig_sszX, orig_sszY;

  BOOL bpuntit = FALSE;

  BOOL bStretchX = FALSE;
  BOOL bStretchY = FALSE;

  orig_sszX = *sszX;
  orig_sszY = *sszY;

  // -------------------------------------------------------
  // Calculate the source to destination size ratio
  if (*sszX < origdszX)
  {
     ratioX = (origdszX * SF) / *sszX;
     bStretchX = TRUE;
  }
  else
  {
     ratioX = (*sszX * SF) / origdszX;
  };

  if (*sszY < origdszY)
  {
     ratioY = (origdszY * SF) / *sszY;
     bStretchY = TRUE;
  }
  else
  {
     ratioY = (*sszY * SF) / origdszY;
  };

  // -------------------------------------------------------
  // Calculate the source X offset
  if (origdx != dx)
  {
     if (bStretchX)
        ltemp = ((dx - origdx) * SF) / ratioX;
     else
        ltemp = ((dx - origdx) * ratioX) / SF;

     *XsrcOff = ltemp;
  };

  // Calculate the source X size change
  if (origdszX != dszX)
  {
     if (bStretchX)
        ltemp = ((origdszX - dszX) * SF) / ratioX;
     else
        ltemp = ((origdszX - dszX) * ratioX) / SF;

     *sszX = *sszX - ltemp;
  };

  // -------------------------------------------------------
  // Calculate the source Y offset
  if (origdy != dy)
  {
     if (bStretchY)
        ltemp = ((dy - origdy) * SF) / ratioY;
     else
        ltemp = ((dy - origdy) * ratioY) / SF;

     *YsrcOff = ltemp;
  };

  // Calculate the source Y size change
  if (origdszY != dszY)
  {
     if (bStretchY)
        ltemp = ((origdszY - dszY) * SF) / ratioY;
     else
        ltemp = ((origdszY - dszY) * ratioY) / SF;

     *sszY = *sszY - ltemp;
  };

  #ifdef DBGDISP
    DISPDBG((1, "AdjustSrcSize - bpuntit= %x, ratioX=%d, ratioY=%d\n",
           bpuntit, ratioX, ratioY));
    DISPDBG((1, "dx=%d, dy=%d, origdx=%d, origdy=%d,\n",
               dx, dy, origdx, origdy));
    DISPDBG((1, "dszX=%d, dszY=%d, origdszX=%d, origdszY=%d,\n",
               dszX, dszY, origdszX, origdszY));
    DISPDBG((1, "*sszX=%d, *sszY=%d, orig_sszX=%d, orig_sszY=%d,\n",
               *sszX, *sszY, orig_sszX, orig_sszY));
    DISPDBG((1, "*XsrcOff=%d, *YsrcOff=%d\n", *XsrcOff, *YsrcOff));
  #endif

  #ifdef DBGBRK
    DbgBreakPoint();
  #endif

  return(bpuntit);
}



/****************************************************************************
* FUNCTION NAME: bRectIntersect()
*
* DESCRIPTION:   If 'prcl1' and 'prcl2' intersect, has a return value of
*                TRUE and returns the intersection in 'prclResult'.
*                If they don't intersect, has a return value of FALSE,
*                and 'prclResult' is undefined.
*
* RETURN:        TRUE: Rectange intersect.
*
* REVISION HISTORY:
*   8/01/95     Benny Ng      Initial version
\**************************************************************************/
BOOL bRectIntersect(RECTL*  prcl1,
                    RECTL*  prcl2,
                    RECTL*  prclResult)
{
  prclResult->left  = max(prcl1->left,  prcl2->left);
  prclResult->right = min(prcl1->right, prcl2->right);

  if (prclResult->left < prclResult->right)
  {
     prclResult->top    = max(prcl1->top,    prcl2->top);
     prclResult->bottom = min(prcl1->bottom, prcl2->bottom);

     if (prclResult->top < prclResult->bottom)
        return(TRUE);
  };

  return(FALSE);
}


/****************************************************************************
* FUNCTION NAME: cRectIntersect()
*
* DESCRIPTION:   This routine takes a list of rectangles from 'prclIn'
*                and clips them in-place to the rectangle 'prclClip'.
*                The input rectangles don't have to intersect 'prclClip';
*                the return value will reflect the number of input rectangles
*                that did intersect, and the intersecting rectangles will
*                be densely packed.
*
* RETURN:        TRUE: Rectange intersect.
*
* REVISION HISTORY:
*   8/01/95     Benny Ng      Initial version
\**************************************************************************/
LONG cRectIntersect(RECTL*  prclClip,
                    RECTL*  prclIn,      // List of rectangles
                    LONG    c)           // Can be zero
{
  LONG    cIntersections;
  RECTL*  prclOut;

  cIntersections = 0;
  prclOut = prclIn;

  for (; c != 0; prclIn++, c--)
  {
    prclOut->left  = max(prclIn->left,  prclClip->left);
    prclOut->right = min(prclIn->right, prclClip->right);

    if (prclOut->left < prclOut->right)
    {
       prclOut->top    = max(prclIn->top,    prclClip->top);
       prclOut->bottom = min(prclIn->bottom, prclClip->bottom);

       if (prclOut->top < prclOut->bottom)
       {
          prclOut++;
          cIntersections++;
       };
    };
  }

  return(cIntersections);
}



/****************************************************************************
* FUNCTION NAME: Shrink()
*
* DESCRIPTION:   This function calculates the parameters for shrink BLT
*                operation.
*
* REVISION HISTORY:
*   7/18/95     Benny Ng      Initial version
****************************************************************************/
VOID Shrink(PPDEV ppdev,
            LONG  lSrc,
            LONG  lDst,
            char  chCoord,
            ULONG LnCntl,
            LONG *sShrinkInc)
{
  LONG  maj = 0;
  LONG  min = 0;
  LONG  accum = 0;
    
  // Set SHRINKINC value,
  //   for y, SHRINKINC = ratio of src/dst
  //   for x, SHRINKINC = ratio of src/dst if not interpolating
  //          SHRINKINC = (ratio of src/dst minus one) if interpolating
  // low byte for x coordinate
  // high byte for y coordinate
  if (chCoord == 'X')
  {
     *sShrinkInc |= (lSrc / lDst);
     if (LnCntl & X_INTERP_ENABLE)
        sShrinkInc--;
  }
  else
  {
     *sShrinkInc |= ((lSrc / lDst) << 8);
  };

  // Compute ACCUM_?, MAJ_? and MIN_? values
  // MAJ_? = width (for x) or height (for y) of destination
  // MIN_? = negative of the remainder of src/dst
  // ACCUM_? = MAJ_? - 1 - ( Src%Dst / (shrink factor + 1))
  maj = lDst;
  min = -(lSrc % lDst);
  accum = maj - 1 - ((lSrc % lDst) / ((lSrc / lDst) + 1)) ;

  if (chCoord == 'X')
  {
	 REQUIRE(3);
     LL16 (grMAJ_X, maj);
     LL16 (grMIN_X, min);
     LL16 (grACCUM_X, accum);
  }
  else
  {
	 REQUIRE(3);
     LL16 (grMAJ_Y, maj);
     LL16 (grMIN_Y, min);
     LL16 (grACCUM_Y, accum);
  };

  #ifdef DBGBRK
    DISPDBG((1, "DrvStretchBlt - shrink\n"));
    DbgBreakPoint();
  #endif
}
    

/****************************************************************************
* FUNCTION NAME: Stretch()
*
* DESCRIPTION:   This function calculates the parameters for stretch BLT
*                operation.
*
* REVISION HISTORY:
*   7/18/95     Benny Ng      Initial version
****************************************************************************/
VOID Stretch(PPDEV ppdev,
             LONG lSrc,
             LONG lDst,
             char chCoord,
             ULONG LnCntl)
{ 
  LONG  min = 0;
  LONG  maj = 0;
  LONG  accum = 0;
    
  // For interpolated stretches registers values differ from values for
  // replicated stretches
  if (((chCoord == 'X') && ((LnCntl & X_INTERP_ENABLE) == 0)) ||
      ((chCoord == 'Y') && ((LnCntl & Y_INTERP_ENABLE) == 0)))
  {
     // Compute ACCUM_?, MAJ_? and MIN_? for replicated stretch
     //   MAJ_? = width (for x) or height (for y) of destination
     //   MIN_? = negative of width (for x) or height (for y) of source
     //   ACCUM_? = MAJ_? - 1 - ( Dst%Src / (stretch factor    + 1))
     maj = lDst;
     min = -lSrc;
     accum = maj - 1 - ((lDst % lSrc) / ((lDst / lSrc) + 1));
  }
  else
  {
     // Compute ACCUM_?, MAJ_? and MIN_? for interpolated stretch
     // Interpolated strecthes use bits 13 & 14 of ACCUM_? to determine
     // whether to use pixel A, 3/4 A + 1/4 B, 1/2 A + 1/2 B or
     // 1/4 A + 3/4 B.
     // To set DDA values appropriately there are three choices.
     // 1) Set MAJ_? to 32k and scale MIN_? to keep ratio approximately
     //    correct
     //      MAJ_? = 32k
     //      MIN_? = (negative of ratio of src/dst) scaled up to 32k
     //      ACCUM_? = MAJ_? - 1 - (1/2 * Absolute difference of MAJ and MIN)
     //
     // 2) Scale both src and dst appropriately such that the ratio of
     //    src/dst is preserved exactly.
     //    Note: In the following, the division is performed first thus
     //          there is a possiblity of a rounding error which shows the
     //          difference between options 1 & 2.
     //      MAJ_? = (32k / dst) * dst
     //      MIN_? = (32k / dst) * src
     //      ACCUM_? = MAJ_? - 1 - (1/2 * Absolute difference of MAJ and MIN)
     //
     // 3) Scale both SRC and Dest in such a manner as to force the last
     //    pixels output on a line to match the last source pixels rather
     //    than the last source interpolated with the pixel past the end
     //    of the line. Option 3 is used here.
     //    NOTE: Options 1 and both oversample Src data and so will replicate
     //          last pixel in X and interpolate past end of data in Y
     
#ifdef OPTION_1  // Option 1
      maj = _32K;
      min = -((_32K * lSrc) / lDst);
#endif

#ifdef OPTION_2  // Option 2
      maj =  ((_32K / lDst) * lDst);
      min = -((_32K / lDst) * lSrc);
#else         // Option 3
      lDst *= 4;
      lSrc = lSrc * 4 - 3; 
      maj =  ((_32K / lDst) * lDst);
      min = -((_32K / lDst) * lSrc);
#endif

      accum = maj - 1 - ((maj % -min) / (lDst/lSrc + 1));
    };

  if (chCoord == 'X')
  {
	 REQUIRE(3);
     LL16 (grMAJ_X, maj);
     LL16 (grMIN_X, min);
     LL16 (grACCUM_X, accum);
  }
  else
  {
	 REQUIRE(3);
     LL16 (grMAJ_Y, maj);
     LL16 (grMIN_Y, min);
     LL16 (grACCUM_Y, accum);
  };

  #ifdef DBGBRK
    DISPDBG((1, "DrvStretchBlt - stretch\n"));
    DbgBreakPoint();
  #endif
}


/****************************************************************************
* FUNCTION NAME: CopySrcToOffMem()
*
* DESCRIPTION:   This function copies source data from host memory to
*                offscreen memory
*
* REVISION HISTORY:
*   7/18/95     Benny Ng      Initial version
****************************************************************************/
VOID CopySrcToOffMem(PPDEV ppdev,
                     BYTE  *pSrcScan0,
                     LONG  sDelta,
                     LONG  sszY,
                     POFMHDL SrcHandle)
{
  LONG    DWcnt;
  LONG    i, j, k;
  LONG    cnt;
  BYTE    *pSrcScan;
  PDWORD  pSrcData;
  ULONG   ultmp;
  LONG    Ycord;
  HOST_DATA  SrcData;

  pSrcScan = pSrcScan0;
  Ycord = SrcHandle->aligned_y;

  // Clear Laguna Command Control Register SWIZ_CNTL bit
  ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
  LL16(grCONTROL, ppdev->grCONTROL);

  pSrcData = &SrcData.dwData;
  DWcnt = sDelta / sizeof(DWORD);

  // Setup the laguna registers for byte to byte BLT extents
  REQUIRE(8);
  LL16 (grBLTDEF,  0x1020);
  LL16 (grDRAWDEF, 0x00CC);

  LL16 (grOP1_opRDRAM.pt.X, 0);

  // LL (grOP0_opMRDRAM.pt.X, SrcHandle->aligned_x);
  // LL (grOP0_opMRDRAM.pt.Y, Ycord);
  LL_OP0_MONO (SrcHandle->aligned_x + ppdev->ptlOffset.x, Ycord + ppdev->ptlOffset.y);

  // LL (grMBLTEXT_EX.pt.X, sDelta);
  // LL (grMBLTEXT_EX.pt.Y, sszY);
  LL_MBLTEXT (sDelta, sszY);

  cnt = DWcnt;
  k = 0;
  for (i=0; i < sszY; i++)
  {
    // Pre-fill the 32-bits pattern with default values
    for (j=0; j < 4; j++)
      SrcData.bData[j] = 0;

    // Copy one screen line mask data from source to destination
    for (j=0; j < sDelta; j++)
    {
      SrcData.bData[k++] = *pSrcScan;
      pSrcScan++;
  
      if (k > 3)
      {
		 REQUIRE(1);
         LL32 (grHOSTDATA[0], *pSrcData);
         k = 0;
         cnt--;
      };  // endif (k > 3)
    }; // endfor j

    // Check whether one screen line of data are written to the
    // HOSTDATA register. 
    if (cnt == 0)
    {
       // Reset the row data count
       cnt = DWcnt;
    };  // endif (cnt == 0)
  }; // end for i

  #ifdef DBGBRK
    DISPDBG((0, "DrvStretchBlt-CopySrcToOffMem\n"));
    DbgBreakPoint();
  #endif
}



/****************************************************************************
* FUNCTION NAME: bStretchDIB()
*
* DESCRIPTION:   StretchBlt using integer math. Must be from one surface
*                to another surface of the same format.
*
* RETURN:        TRUE: Punt it.
*
* REVISION HISTORY:
*   7/27/95     Benny Ng      Initial version
****************************************************************************/
BOOL bStretchDIB(SURFOBJ* psoSrc,
                 SURFOBJ* psoMsk,
                 PDEV*    ppdev,
                 VOID*    pvDst,
                 LONG     lDeltaDst,
                 RECTL*   prclDst,
                 VOID*    pvSrc,
                 LONG     lDeltaSrc,
                 RECTL*   prclSrc,
                 RECTL*   prclClip)
{
  LONG    ltmp;
  ULONG   ultmp;
  SIZEL   reqsz;
  LONG    bpp;
  BYTE    *pSrcScan;
  RECTL   rclRes;

  BOOL    bNoBlt = FALSE;
  BOOL    bpuntit = TRUE;
  POFMHDL SrcHandle = NULL;

  long    drawdef = 0;
  long    srcx = 0;
  ULONG   LnCntl = 0;
  LONG    sShrinkInc = 0;
  LONG    XsrcOff = 0;
  LONG    YsrcOff = 0;

  // Calculate the rectange start points and sizes:
  //
  LONG  WidthDst  = prclDst->right  - prclDst->left;
  LONG  HeightDst = prclDst->bottom - prclDst->top;

  LONG  WidthSrc  = prclSrc->right  - prclSrc->left;
  LONG  HeightSrc = prclSrc->bottom - prclSrc->top;

  LONG  XDstStart = prclDst->left;
  LONG  YDstStart = prclDst->top;

  LONG  XSrcStart = prclSrc->left;
  LONG  YSrcStart = prclSrc->top;


  // -------------------------------------------------------
  // Calculate bytes per pixel
  bpp = ppdev->ulBitCount/8;

  // Get the informations from source and destination surface
  pSrcScan = pvSrc;

  if (psoMsk != NULL)
  {
     #ifdef DBGDISP
        DISPDBG((1, "DrvStretchBlt - HandleCase_1 mask pointer != NULL (punt it)\n"));
     #endif

     goto Punt_It;
  };

  // -------------------------------------------------------
  // Check whether source is from host or video memory
  if ((pSrcScan <  ppdev->pjScreen) ||
      (pSrcScan > (ppdev->pjScreen + ppdev->lTotalMem)))
  {    
     #ifdef DBGDISP
       DISPDBG((1, "DrvStretchBlt - HandleCase_1 - src host\n"));
     #endif

     // Allocate the offscreen memory for the source if not enough offscreen
     // memory available punt it.
     reqsz.cx = psoSrc->sizlBitmap.cx;
     reqsz.cy = psoSrc->sizlBitmap.cy;

     if ((SrcHandle = AllocOffScnMem(ppdev, &reqsz, PIXEL_AlIGN, NULL)) == NULL)
     {   goto Punt_It;     };

//?? bbbbbbbbbb
// Note: The following lines of code takes care the host data HW problem,
//       it punt back to GDI when host data size is 29 to 30 to DWORD.
//
     if ((lDeltaSrc >= 116) && (lDeltaSrc <= 120))
     {
        DISPDBG((1, "DrvStretchBlt - src host (punt it)\n"));
        goto Punt_It;
     };
//?? eeeeeeeeee

     // Copy the source data into allocated offscreen memory
     CopySrcToOffMem(ppdev,
                     pSrcScan,
                     lDeltaSrc,
                     HeightSrc,
                     SrcHandle);

     XSrcStart = SrcHandle->aligned_x / bpp;
     YSrcStart = SrcHandle->aligned_y;
  }
  else
  {    
     #ifdef DBGDISP
        DISPDBG((1, "DrvStretchBlt - HandleCase_1 - src videow\n"));
     #endif
     if ((WidthSrc * bpp) > ppdev->lDeltaScreen)
        WidthSrc = ppdev->lDeltaScreen / bpp;

     ltmp = ppdev->lTotalMem / ppdev->lDeltaScreen;

     if (HeightSrc > ltmp)
        HeightSrc = ltmp;
  };

  // -------------------------------------------------------
  if (prclClip != NULL)
  {
     // Test for intersection of clipping rectangle and destination
     // rectangle. If they don't intersect, go on for stretch BLT.
     // For DC_RECT clipping we have a single clipping rectangle.
     // We create a new destination rectangle which is the intersection 
     // between the old destination rectangle and the clipping rectangle.
     // Then we adjust our source rectangle accordingly.
     //
     if (!bRectIntersect(prclDst, prclClip, &rclRes))
     {
        #ifdef DBGDISP
          DISPDBG((1, "DrvStretchBlt - HandleCase_1 - DC_RECT no intersect\n"));
        #endif
        goto Punt_It;
     };

     // Adjust the source size
     bNoBlt = AdjustSrcSize(rclRes.left, rclRes.top,
                            XDstStart,   YDstStart, 
                            (rclRes.right - rclRes.left),
                            (rclRes.bottom - rclRes.top),
                            WidthDst,    HeightDst,
                            &WidthSrc,   &HeightSrc,
                            &XsrcOff,    &YsrcOff);
         
     // Adjust the destination rectange size
     XDstStart = rclRes.left;
     YDstStart = rclRes.top;
     WidthDst  = rclRes.right  - rclRes.left; 
     HeightDst = rclRes.bottom - rclRes.top;
  }; // endif (prclClip != NULL)

  if (!bNoBlt)
  {
     // -------------------------------------------------------
     // Perform the shrink or stretch operation

     // Set the shrink or interpolate bit in LNCNTL
     if (WidthSrc >= WidthDst)
     {
        LnCntl |= X_SHRINK_ENABLE;
        Shrink(ppdev, WidthSrc, WidthDst, 'X', LnCntl, &sShrinkInc);
     }
     else
     {
        Stretch(ppdev, WidthSrc, WidthDst, 'X', LnCntl);
     };

     if (HeightSrc >= HeightDst)
     {
        LnCntl |= Y_SHRINK_ENABLE;
        Shrink(ppdev, HeightSrc, HeightDst, 'Y', LnCntl, &sShrinkInc);
     }
     else
     {
        Stretch(ppdev, HeightSrc, HeightDst, 'Y', LnCntl);
     };

     #ifdef DBGBRK
       DISPDBG((1, "DrvStretchBlt - bStretchDIB - before exec\n"));
       DbgBreakPoint();
     #endif

     // -------------------------------------------------------
     XSrcStart += XsrcOff;
     YSrcStart += YsrcOff;

     // LL (grOP1_opRDRAM.pt.X, XSrcStart);
     // LL (grOP1_opRDRAM.pt.Y, YSrcStart);
	 REQUIRE(12);
     LL_OP1 (XSrcStart, YSrcStart);

     LL16 (grSHRINKINC, sShrinkInc);

     LL16 (grBLTDEF,  0x1010);
     LL16 (grDRAWDEF, 0x00CC);
   
     // Setup the shrink and interpolate bits in LNCNTL
     ultmp = LLDR_SZ (grLNCNTL.w);
     ultmp |= LnCntl;
     LL16 (grLNCNTL, ultmp);

     srcx = WidthSrc * bpp;
     LL16 (grSRCX, srcx);

     // LL (grOP0_opRDRAM.pt.X, XDstStart);
     // LL (grOP0_opRDRAM.pt.Y, YDstStart);
     LL_OP0 (XDstStart + ppdev->ptlOffset.x, YDstStart + ppdev->ptlOffset.y);
   
     // LL (grBLTEXTR_EX.pt.X, WidthDst);
     // LL (grBLTEXTR_EX.pt.Y, HeightDst);
     LL_BLTEXTR (WidthDst, HeightDst);

     #ifdef DBGBRK
       DISPDBG((1, "DrvStretchBlt - bStretchDIB - after exec\n"));
       DbgBreakPoint();
     #endif

     bpuntit = FALSE;
  }; //endif (!bNoBlt)

Punt_It:
  // -------------------------------------------------------
  // Release the offscreen buffer if allocated
  if (SrcHandle != NULL)
     FreeOffScnMem(ppdev, SrcHandle);

  return(bpuntit);
}



/****************************************************************************
* FUNCTION NAME: HandleCase_1()
*
* DESCRIPTION:   This function handle the case when
*                Both src and dst surface types are equal to STYPE_BITMAP,
*                both src and dst surface have same iBitmapFormat,
*                no color translation.
*
* RETURN:        TRUE: Punt it.
*
* REVISION HISTORY:
*   7/18/95     Benny Ng      Initial version
****************************************************************************/
BOOL HandleCase_1(SURFOBJ*  psoDst,
                  SURFOBJ*  psoSrc,
                  SURFOBJ*  psoMsk,
                  CLIPOBJ*  pco,
                  RECTL*    prclDst,
                  RECTL*    prclSrc,
                  POINTL*   pptlMsk,
                  BOOL*     bRet)
{
  BOOL  bpuntit = TRUE;
  PDEV* ppdev = (PDEV*) psoDst->dhpdev;

  BYTE    iDComplexity;
  PRECTL  prclClip;

  ENUMRECTS  ce;
  BOOL    bMore;
  LONG    c;
  LONG    i;

  *bRet = FALSE;

  // -------------------------------------------------------
  // CHeck what kind of clipping is it?
  iDComplexity = (pco ? pco->iDComplexity : DC_TRIVIAL);

  switch (iDComplexity)
  {
    case  DC_TRIVIAL:
      #ifdef DBGDISP
        DISPDBG((1, "DrvStretchBlt - HandleCase_1 - DC_TRIVIAL\n"));
      #endif

      bpuntit = bStretchDIB(psoSrc,
                            psoMsk,
                            ppdev,
                            NULL,
                            psoDst->lDelta,
                            prclDst,
                            psoSrc->pvScan0,
                            psoSrc->lDelta,
                            prclSrc,
                            NULL);
      break;
  
    case DC_RECT:
      #ifdef DBGDISP
        DISPDBG((1, "DrvStretchBlt - HandleCase_1 - DC_RECT\n"));
      #endif

      // Get the clipping rectangle.
      prclClip = &pco->rclBounds;

      bpuntit = bStretchDIB(psoSrc,
                            psoMsk,
                            ppdev,
                            NULL,
                            psoDst->lDelta,
                            prclDst,
                            psoSrc->pvScan0,
                            psoSrc->lDelta,
                            prclSrc,
                            prclClip);
      break;

    case DC_COMPLEX:
      #ifdef DBGDISP
        DISPDBG((1, "DrvStretchBlt - HandleCase_1 - DC_COMPLEX\n"));
      #endif

      bpuntit = FALSE;
      CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

      do
      {
         bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

         c = cRectIntersect(prclDst, ce.arcl, ce.c);

         if (c != 0)
         {
            for (i = 0; i < c; i++)
            {
              bpuntit = bStretchDIB(psoSrc,
                                    psoMsk,
                                    ppdev,
                                    NULL,
                                    psoDst->lDelta,
                                    prclDst,
                                    psoSrc->pvScan0,
                                    psoSrc->lDelta,
                                    prclSrc,
                                    &ce.arcl[i]);

              if (bpuntit)
                 break;

            }; // enddo
         }; // endif

      } while ((bMore) && (!bpuntit));

      break;

    default:
      break;
  };  // end switch (iDComplexity)

  // -------------------------------------------------------
  // Check whether the operation was handled successfully
  if (!bpuntit)
     *bRet = TRUE;

  return (bpuntit);
}


/****************************************************************************
* FUNCTION NAME: DrvStretchBlt()
*
* DESCRIPTION:   This function provides stretching bit-block transfer
*                capabilities for Laguna NT
*
* REVISION HISTORY:
*   7/11/95     Benny Ng      Initial version
****************************************************************************/
#define  TSTFRIDO     1

BOOL DrvStretchBlt(SURFOBJ*   psoDst,
                   SURFOBJ*   psoSrc,
                   SURFOBJ*   psoMsk,
                   CLIPOBJ*   pco,
                   XLATEOBJ*  pxlo,
                   COLORADJUSTMENT*  pca,
                   POINTL*    pptlHTOrg,
                   RECTL*     prclDst,
                   RECTL*     prclSrc,
                   POINTL*    pptlMsk,
                   ULONG      iMode)
{
  BOOL    bRet = TRUE;
  BOOL    bPuntIt = TRUE;
  LONG    HandleIt = 0;

  #if NULL_STRETCH
  {
      if (pointer_switch)    	    return TRUE;
  }
  #endif


#ifdef TSTFRIDO
{
  PPDEV  ppdev = (PPDEV) psoDst->dhpdev;      
  SYNC_W_3D(ppdev);
  if (psoDst->iType == STYPE_DEVBITMAP)
  {
	  PDSURF pdsurf = (PDSURF)psoDst->dhsurf;

	  if ( pdsurf->pso )
	  {
	  	  if ( !bCreateScreenFromDib(ppdev, pdsurf) )
  	  	  {
           return EngStretchBlt(psoDst, psoSrc, psoMsk, pco,
                                pxlo, pca, pptlHTOrg,
                                prclDst, prclSrc, pptlMsk, iMode);
  	  	  };
	  };
	  ppdev->ptlOffset.x = pdsurf->ptl.x;
	  ppdev->ptlOffset.y = pdsurf->ptl.y;
  }
  else
  {
     if (ppdev != NULL)
        ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;
     else
        return(EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                             prclDst, prclSrc, pptlMsk, iMode));
  };

  ppdev = (PPDEV) psoSrc->dhpdev;      
  if (psoSrc->iType == STYPE_DEVBITMAP)
  {
	  PDSURF pdsurf = (PDSURF)psoSrc->dhsurf;

	  if ( pdsurf->pso )
	  {
	  	  if ( !bCreateScreenFromDib(ppdev, pdsurf) )
	  	  {
           return EngStretchBlt(psoDst, psoSrc, psoMsk, pco,
                                pxlo, pca, pptlHTOrg,
                                prclDst, prclSrc, pptlMsk, iMode);
	  	  };
	  };
	  ppdev->ptlOffset.x = pdsurf->ptl.x;
	  ppdev->ptlOffset.y = pdsurf->ptl.y;
  }
  else
  {
     if (ppdev != NULL)
        ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;
     else
        return(EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                             prclDst, prclSrc, pptlMsk, iMode));
  };
}
#else
  {  
  PPDEV  ppdev = (PPDEV) psoDst->dhpdev;      
  SYNC_W_3D(ppdev);
  }
  bRet = EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                          prclDst, prclSrc, pptlMsk, iMode);
  return(bRet);
#endif


  #ifdef DBGDISP
    DISPDBG((1, "DrvStretchBlt - %d\n", iMode));
  #endif

  if ((psoDst->iType == psoSrc->iType) &&
      (psoDst->fjBitmap == psoSrc->fjBitmap) &&
      (psoDst->fjBitmap == BMF_TOPDOWN))
  {
    // If src and dst surface have same iBitmapFormat
    if (psoDst->iBitmapFormat == psoSrc->iBitmapFormat)
    {
       // Check for color translation
       if (pxlo == NULL)
       {
          HandleIt = 1;
       }
       else if ((pxlo != NULL) && (pxlo->iSrcType == pxlo->iDstType))
       {
          switch (pxlo->flXlate)
          {
            case XO_TRIVIAL:
            case 0:
              HandleIt = 1;
              break;

            default:
	      #ifdef DBGDISP
                DISPDBG((1, "DrvStretchBlt - pxlo->flXlate (punt it)\n"));
	      #endif
              break;
          };
       }; // endif (pxlo == NULL)
    }; // endif (src and dst surface have same iBitmapFormat)
  }; // endif (Both src and dst surface types are equal to STYPE_BITMAP)

  // Check whether we can handle this case, if yes call the case
  // handle routine to try to handle it. Otherwise punt it back to GDI
  if (HandleIt != 0)
  {
     if (HandleIt == 1)
     {
        bPuntIt = HandleCase_1(psoDst,
                               psoSrc,
                               psoMsk,
                               pco,
                               prclDst,
                               prclSrc,
                               pptlMsk,
                               &bRet);
     }
     else if (HandleIt == 2)
     {
     };
  };  // endif (HandleIt)

  // -------------------------------------------------------
  // Punt It back to GDI to handle it
  if (bPuntIt)
  {
     DISPDBG((1, "DrvStretchBlt - punt it\n"));

     #ifdef PUNTBRK
         DbgBreakPoint();  
     #endif

     bRet = EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                          prclDst, prclSrc, pptlMsk, iMode);
  };

  return(bRet);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\screen.c ===
/******************************Module*Header*******************************\
 *
 * Module Name: screen.c
 *
 * Initializes the GDIINFO and DEVINFO structures for DrvEnablePDEV.
 *
 * Copyright (c) 1992 Microsoft Corporation
 * Copyright (c) 1995 Cirrus Logic, Inc.
 *
 * $Log:   X:/log/laguna/nt35/displays/cl546x/SCREEN.C  $
* 
*    Rev 1.68   Mar 04 1998 15:33:44   frido
* Added new shadow macros.
* 
*    Rev 1.67   Mar 04 1998 14:45:02   frido
* Added initialization of shadowFGCOLOR register.
* 
*    Rev 1.66   Feb 27 1998 17:00:46   frido
* Added zeroing of shadowQFREE register.
* 
*    Rev 1.65   Feb 03 1998 10:43:32   frido
* There was a (not yet reported) bug in the shadow registers. When the
* mode was reset after a DOS box the shadow registers need to be initialized.
* 
*    Rev 1.64   Dec 10 1997 13:32:20   frido
* Merged from 1.62 branch.
* 
*    Rev 1.63.1.0   Nov 14 1997 13:48:02   frido
* PDR#10750: Moved the allocation of the font cache down. It caused
* fragmentation of the off-screen memory heap in certain modes.
* 
*    Rev 1.63   Nov 04 1997 09:50:02   frido
* Added COLOR_TRANSLATE switches around hardware color translation code.
* 
*    Rev 1.62   Nov 03 1997 11:20:40   frido
* Added REQUIRE macros.
* 
*    Rev 1.61   12 Sep 1997 12:00:28   bennyn
* 
* Added PDEV and DRIVERDATA structure signature initialization.
* 
*    Rev 1.60   12 Aug 1997 16:55:46   bennyn
* Added DD scratch buffer allocation
* 
*    Rev 1.59   22 Jul 1997 12:32:52   bennyn
* 
* Added dwLgVenID to PDEV
* 
*    Rev 1.58   02 Jul 1997 15:57:12   noelv
* Added LgMatchDriverToChip() function.  Moved driver/chip match from bin
* from binitSurface to DrvEnablePdev()
* 
*    Rev 1.57   20 Jun 1997 13:38:16   bennyn
* 
* Eliminated power manager initialization
* 
*    Rev 1.56   16 Jun 1997 16:17:58   noelv
* Fixed conversion warning line 539
* 
*    Rev 1.55   23 May 1997 15:41:00   noelv
* 
* Added chip revision id to pdev
* 
*    Rev 1.54   15 May 1997 15:57:54   noelv
* 
* moved swat4 stuff to miniport
* 
*    Rev 1.53   29 Apr 1997 16:28:48   noelv
* 
* Merged in new SWAT code.
* SWAT: 
* SWAT:    Rev 1.5   24 Apr 1997 11:28:00   frido
* SWAT: NT140b09 merge.
* SWAT: 
* SWAT:    Rev 1.4   19 Apr 1997 16:40:26   frido
* SWAT: Added 4-way interleave.
* SWAT: Added Frame Buffer Bursting.
* SWAT: Added SWAT.h include file.
* SWAT: 
* SWAT:    Rev 1.3   18 Apr 1997 00:15:26   frido
* SWAT: NT140b07 merge.
* SWAT: 
* SWAT:    Rev 1.2   10 Apr 1997 14:09:00   frido
* SWAT: Added hardware optimizations SWAT4.
* SWAT: 
* SWAT:    Rev 1.1   09 Apr 1997 17:32:02   frido
* SWAT: Called vAssertModeText during first time initialization.
* 
*    Rev 1.52   23 Apr 1997 07:40:20   SueS
* Moved VS_CONTROL_HACK to laguna.h.  Send message to miniport to
* enable MMIO access to PCI registers before use.
* 
*    Rev 1.51   22 Apr 1997 11:03:54   noelv
* Changed chip detect to allow 5465 driver to load on 5465 and later chips.
* 
*    Rev 1.50   17 Apr 1997 14:40:24   noelv
* 
* Added hack for VS_CONTROL reg.
* 
*    Rev 1.49   07 Apr 1997 10:25:10   SueS
* Removed sw_test_flag and unreferenced #if USE_FLAG.
* 
*    Rev 1.48   19 Feb 1997 13:11:02   noelv
* 
* Moved brush cache invalidation to it's own function
* 
*    Rev 1.47   28 Jan 1997 11:14:16   noelv
* 
* Removed extra dword requirements from 5465 driver.
* 
*    Rev 1.46   28 Jan 1997 10:52:00   noelv
* 
* Match driver type to chip type.
* 
*    Rev 1.45   23 Jan 1997 17:22:28   bennyn
* 
* Added #ifdef DRIVER_5465
* 
*    Rev 1.44   16 Jan 1997 11:43:00   bennyn
* 
* Added power manager init call
* 
*    Rev 1.43   10 Dec 1996 13:30:10   bennyn
* 
* Added update the ulFreq in PDEV
* 
*    Rev 1.42   27 Nov 1996 11:32:40   noelv
* Disabled Magic Bitmap.  Yeah!!!
* 
*    Rev 1.41   18 Nov 1996 10:15:50   bennyn
* 
* Added grFormat to PDEV
* 
*    Rev 1.40   13 Nov 1996 16:59:38   SueS
* Changed WriteFile calls to WriteLogFile.
* 
*    Rev 1.39   13 Nov 1996 08:16:52   noelv
* 
* Added hooks for bus mastered host to screen.
* 
*    Rev 1.38   31 Oct 1996 11:15:16   noelv
* 
* Split common buffer into two buffers.
* 
*    Rev 1.37   24 Oct 1996 14:40:04   noelv
* 
* Get the loations of the bus master common buffer from the miniport.
* 
*    Rev 1.36   04 Oct 1996 16:53:24   bennyn
* Added DirectDraw YUV support
* 
*    Rev 1.35   18 Sep 1996 13:58:16   bennyn
* 
* Save the DeviceID into PDEV
* 
*    Rev 1.34   21 Aug 1996 16:43:38   noelv
* 
* Turned on the GoFast bit.
* 
*    Rev 1.33   20 Aug 1996 11:04:22   noelv
* Bugfix release from Frido 8-19-96
* 
*    Rev 1.2   17 Aug 1996 13:54:18   frido
* New release from Bellevue.
* 
*    Rev 1.1   15 Aug 1996 11:36:08   frido
* Added precompiled header.
* 
*    Rev 1.0   14 Aug 1996 17:16:30   frido
* Initial revision.
* 
*    Rev 1.31   25 Jul 1996 15:57:14   bennyn
* 
* Modified for DirectDraw
* 
*    Rev 1.30   11 Jul 1996 15:54:42   bennyn
* 
* Added DirectDraw support
* 
*    Rev 1.29   04 Jun 1996 16:00:00   noelv
* Added debug information.
* 
*    Rev 1.28   17 May 1996 12:56:08   bennyn
* 
* Fixed the problem NT40 allocate 400x90 twice
* 
*    Rev 1.27   16 May 1996 15:00:22   bennyn
* Add PIXEL_ALIGN to allocoffscnmem()
* 
*    Rev 1.26   13 May 1996 16:01:26   bennyn
* Fill ExtraDwordTable with 0 if 5464 is detected
* 
*    Rev 1.25   08 May 1996 17:02:58   noelv
* 
* Preallocate device bitmap
* 
*    Rev 1.24   08 May 1996 10:31:08   BENNYN
* 
* Added version display for NT4.0
* 
*    Rev 1.23   03 May 1996 15:18:58   noelv
* 
* Added switch to turn font caching off in low memory situations.
* Moved driver version to a header file.
* 
*    Rev 1.22   01 May 1996 11:01:28   bennyn
* 
* Modified for NT4.0
* 
*    Rev 1.21   25 Apr 1996 22:41:58   noelv
* clean-up
* 
*    Rev 1.20   16 Apr 1996 22:48:26   noelv
* label 3.5.17
* 
*    Rev 1.19   14 Apr 1996 11:49:06   noelv
* Optimized device to device xlate some.
* 
*    Rev 1.18   13 Apr 1996 17:57:52   noelv
* 
* 
*    Rev 1.17   12 Apr 1996 17:24:00   noelv
* I *knew* I should have skipped rev 13...
* 
*    Rev 1.16   12 Apr 1996 10:08:54   noelv
* 
* 
*    Rev 1.15   10 Apr 1996 14:15:04   NOELV
* 
* Made version 3.5.12
 * 
 *    Rev 1.17   08 Apr 1996 16:41:14   frido
 * Cleared brush cache on mode re-init.
 * 
 *    Rev 1.16   02 Apr 1996 09:12:02   frido
 * Bellevue lg102b04 release.
 * 
 *    Rev 1.15   28 Mar 1996 20:26:00   frido
 * New bellevue release.
 * 
 *    Rev 1.14   27 Mar 1996 13:12:32   frido
 * Added FILL support for all color resolutions.
 * 
 *    Rev 1.13   25 Mar 1996 12:07:44   frido
 * Removed warning message.
 * 
 *    Rev 1.12   25 Mar 1996 11:50:34   frido
 * Bellevue 102B03.
* 
*    Rev 1.9   20 Mar 1996 16:12:00   noelv
* Bumped rev
* 
*    Rev 1.8   15 Mar 1996 09:39:04   andys
* Bracketed BITMASK setting with set/clear of enable bit in DRAWDEF
* .
* 
*    Rev 1.7   14 Mar 1996 09:37:02   andys
* 
* Added code to calculate Tile Width in Pixels and SRAM Width in Pixels at 
* switch instead of each pass
* 
*    Rev 1.6   12 Mar 1996 15:46:14   noelv
* Added support file Stroke and Fill
* 
*    Rev 1.5   07 Mar 1996 18:23:14   bennyn
* 
* Removed read/modify/write on CONTROL reg
* 
*    Rev 1.4   06 Mar 1996 12:56:42   noelv
* 
* Set version number to 3.5.0
* 
*    Rev 1.3   05 Mar 1996 12:01:34   noelv
* Frido version 19
 * 
 *    Rev 1.10   26 Feb 1996 23:38:46   frido
 * Added initialization of new function pointers.
 * 
 *    Rev 1.9   17 Feb 1996 21:45:38   frido
 *  
 * 
 *    Rev 1.8   13 Feb 1996 16:50:24   frido
 * Changed the layout of the PDEV structure.
 * 
 *    Rev 1.7   10 Feb 1996 21:43:22   frido
 * Split monochrome and colored translation tables.
 * 
 *    Rev 1.6   08 Feb 1996 00:18:04   frido
 * Changed reinitialization of XLATE cache.
 * 
 *    Rev 1.5   05 Feb 1996 17:35:44   frido
 * Added translation cache.
 * 
 *    Rev 1.4   03 Feb 1996 13:43:18   frido
 * Use the compile switch "-Dfrido=0" to disable my extensions.
 * 
 *    Rev 1.3   25 Jan 1996 12:46:30   frido
 * Added initialization of dither cache and font counter ID after mode switch.
 * 
 *    Rev 1.2   20 Jan 1996 22:14:10   frido
 * Added GCAPS_DITHERONREALIZE.
 *
\**************************************************************************/

#include "precomp.h"
#include "version.h"
#include "clioctl.h"
#include "SWAT.h"		// SWAT optimizations.

VOID InitPointerHW (PPDEV ppdev);


#if !DRIVER_5465
    extern unsigned char ExtraDwordTable[1]; 
#endif

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_STROKE_PRECIS,PROOF_QUALITY,VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_STROKE_PRECIS,PROOF_QUALITY,FIXED_PITCH | FF_DONTCARE, L"Courier"}

// This is the basic devinfo for a default driver.  This is used as a base and customized based
// on information passed back from the miniport driver.

const DEVINFO gDevInfoFrameBuffer =
{
	GCAPS_OPAQUERECT                // flGraphicsCaps
#ifdef WINNT_VER40
   | GCAPS_DIRECTDRAW
#endif
	| GCAPS_DITHERONREALIZE
	| GCAPS_ALTERNATEFILL
	| GCAPS_WINDINGFILL
	| GCAPS_MONO_DITHER,
	SYSTM_LOGFONT,                  // lfDefaultFont
	HELVE_LOGFONT,                  // lfAnsiVarFont
	COURI_LOGFONT,                  // lfAnsiFixFont
	0,                                              // cFonts
	0,                                              // iDitherFotmat
	8,                                              // cxDither
	8,                                              // cyDither
	0                                               // hpalDefault
};

COPYFN DoHost8ToDevice;
COPYFN DoDeviceToHost8;
COPYFN DoHost16ToDevice;
COPYFN DoDeviceToHost16;
COPYFN DoHost24ToDevice;
COPYFN DoDeviceToHost24;
COPYFN DoHost32ToDevice;
COPYFN DoDeviceToHost32;

//
// Array of HostToScreen routines for each resolution.
// These host to screen functions use the HOSTDATA port.
//
COPYFN *afnHostToScreen[4] =
{
	DoHost8ToDevice,
	DoHost16ToDevice,
	DoHost24ToDevice,
	DoHost32ToDevice
};

//
// Array of ScreenToHost routines for eache resolution.
// These host to screen functions use the HOSTDATA port.
//
COPYFN *afnScreenToHost[4] =
{
	DoDeviceToHost8,
	DoDeviceToHost16,
	DoDeviceToHost24,
	DoDeviceToHost32
};


#if BUS_MASTER
    COPYFN BusMasterBufferedHost8ToDevice;

    //
    // Array of HostToScreen routines for each resolution.
    // These host to screen functions use bus mastering through a buffer.
    //
    COPYFN *afnBusMasterBufferedHostToScreen[4] =
    {
        BusMasterBufferedHost8ToDevice,
	    DoHost16ToDevice,
	    DoHost24ToDevice,
	    DoHost32ToDevice
    };
#endif


#define LG_SRAM_SIZE 120


/******************************Public*Routine******************************\
* bInitSURF
*
* Enables the surface.        Maps the frame buffer into memory.
*
\**************************************************************************/

BOOL bInitSURF(PPDEV ppdev, BOOL bFirst)
{
	WORD	DeviceID;

	DWORD returnedDataLength;
	VIDEO_MEMORY videoMemory;
	VIDEO_MEMORY_INFORMATION videoMemoryInformation;
	VIDEO_PUBLIC_ACCESS_RANGES   VideoAccessRanges[2];

        DISPDBG((1,"bInitSurf: Entry.\n"));

	if (!DEVICE_IO_CTRL(ppdev->hDriver,
			IOCTL_VIDEO_SET_CURRENT_MODE,
			&(ppdev->ulMode),
			sizeof(ULONG),
			NULL,
			0,
			&returnedDataLength,
			NULL))
	{
		RIP("DISP bInitSURF failed IOCTL_SET_MODE\n");
		return(FALSE);
	}

	// Initialize the shadow registers.
	ppdev->shadowFGCOLOR = 0xDEADBEEF;
	ppdev->shadowBGCOLOR = 0xDEADBEEF;
	ppdev->shadowDRAWBLTDEF = 0xDEADBEEF;
	ppdev->shadowQFREE = 0;

	//
	// If this is the first time we enable the surface we need to map in the
	// memory also.
	//
	if (bFirst)
	{

		videoMemory.RequestedVirtualAddress = NULL;

		if (!DEVICE_IO_CTRL(ppdev->hDriver,
							IOCTL_VIDEO_MAP_VIDEO_MEMORY,
							&videoMemory,
							sizeof(VIDEO_MEMORY),
							&videoMemoryInformation,
							sizeof(VIDEO_MEMORY_INFORMATION),
							&returnedDataLength,
							NULL))
		{
			RIP("DISP bInitSURF failed IOCTL_VIDEO_MAP_VIDEO_MEMORY.\n");
			return(FALSE);
		}

		ppdev->pjScreen = (PBYTE)(videoMemoryInformation.FrameBufferBase);
		ppdev->lTotalMem = videoMemoryInformation.FrameBufferLength;

                DISPDBG((1,"FrameBufferSize: %d.\n", ppdev->lTotalMem));


		//
		// Calculate start of off screen memory.
		//
		ppdev->pjOffScreen = ppdev->pjScreen +
				(ppdev->cxScreen * ppdev->cyScreen * (ppdev->iBytesPerPixel));


		//
		// Map graphics registers into memory.
		//

                DISPDBG((1,"bInitSurf:  Getting pointer to LgREGS from miniport.\n"));

		if (!DEVICE_IO_CTRL(ppdev->hDriver,
						 IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
						 NULL,                      // input buffer
						 0,
						 (PVOID) VideoAccessRanges, // output buffer
						 sizeof (VideoAccessRanges),
						 &returnedDataLength,
						 NULL))
		{
			RIP("bInitSURF - QUERY_PUBLIC_ACCESS_RANGES ioctl failed!\n");
			return (FALSE);
		}

		ppdev->pLgREGS = (GAR*) VideoAccessRanges[0].VirtualAddress;
		ppdev->pLgREGS_real = (GAR*) VideoAccessRanges[0].VirtualAddress;

                DISPDBG((1,"bInitSurf:  Got pointer to registers.\n"));

        //
        // Map common bus master data buffer.
        // If the chip can't do bus mastering, then the size of
        // the data buffer will be 0.
        //
        #if BUS_MASTER
        {
            // Must match structure in Miniport:CIRRUS.H
            struct {
                PVOID PhysAddress;
                PVOID VirtAddress;
                ULONG  Length;
            } CommonBufferInfo;

            DISPDBG((1,"bInitSurf:  Getting the common buffer.\n"));
            if (!DEVICE_IO_CTRL(ppdev->hDriver,
                IOCTL_CL_GET_COMMON_BUFFER,
                NULL,                        // Input buffer.
                0,
                &CommonBufferInfo,           // Output buffer.
                sizeof(CommonBufferInfo),
                &returnedDataLength,
                NULL))
            {
                RIP("bInitSURF - GET_COMMON_BUFFER ioctl failed!\n");
                return (FALSE);
            }

            //
            // Split the buffer in half and store it in the PDEV
            //
            ppdev->Buf1VirtAddr = CommonBufferInfo.VirtAddress;
            ppdev->Buf1PhysAddr = CommonBufferInfo.PhysAddress;
            ppdev->BufLength =    CommonBufferInfo.Length/2;

            ppdev->Buf2VirtAddr = ppdev->Buf1VirtAddr + ppdev->BufLength;
            ppdev->Buf2PhysAddr = ppdev->Buf1PhysAddr + ppdev->BufLength;


            DISPDBG((1,"bInitSurf:  Got the common buffer.\n"
                       "            Virtual:  0x%08X\n"
                       "            Physical: 0x%08X\n"
                       "            Length:   %d\n",
                     CommonBufferInfo.VirtAddress,
                     CommonBufferInfo.PhysAddress,
                     CommonBufferInfo.Length
            ));

           // ppdev->BufLength = 0;
        }
        #endif



        // DirectDraw initalization
        ppdev->DriverData.DrvSemaphore = 0;
        ppdev->DriverData.VideoSemaphore = 0;
        ppdev->DriverData.YUVTop  = 0;
        ppdev->DriverData.YUVLeft = 0;
        ppdev->DriverData.YUVXExt = 0;
        ppdev->DriverData.YUVYExt = 0;


		//
		// The following is "good practice" for GRX setup.
		//
                DISPDBG((1,"bInitSurf:  Beginning register init.\n"));
		REQUIRE(13);
		LL16(grOP0_opRDRAM.pt.X, 0);	//# Set host phase 0
		LL16(grOP1_opRDRAM.pt.X, 0);	//# Set host phase 0
		LL16(grOP2_opRDRAM.pt.X, 0);	//# Set host phase 0
		LL16(grOP0_opSRAM, 0);			//# Point to start of SRAM0
		LL16(grOP1_opSRAM, 0);			//# Point to start of SRAM1
		LL16(grOP2_opSRAM, 0);			//# Point to start of SRAM2
		LL16(grOP1_opMSRAM, 0);			//# Point to start of mono SRAM1
		LL16(grOP2_opMSRAM, 0);			//# Point to start of mono SRAM2
		LL16(grPATOFF.w, 0);			//# All patterns aligned to 0,0
		LL_BGCOLOR(0xFFFFFFFF, 0);		//# Background color is White
		LL_FGCOLOR(0x00000000, 0);		//# Foreground color is Black

        #if (VS_CONTROL_HACK && DRIVER_5465)
        {
           DWORD ReturnedDataLength;

           DISPDBG((1,"bInitSurf: Enable MMIO for PCI config regs.\n"));
           // Send message to miniport to enable MMIO access of PCI registers 
           if (!DEVICE_IO_CTRL(ppdev->hDriver,
                              IOCTL_VIDEO_ENABLE_PCI_MMIO,
                              NULL,
                              0,
                              NULL,
                              0,
                              &ReturnedDataLength,
                              NULL))
           {
             RIP("bInitSurf failed IOCTL_VIDEO_ENABLE_PCI_MMIO");
           }
        }
        #endif

        //
        // Get the chip ID.
        //
        ppdev->dwLgVenID = (DWORD) LLDR_SZ (grVendor_ID);
        DeviceID = (WORD) LLDR_SZ (grDevice_ID);
        ppdev->dwLgDevID = DeviceID;
        ppdev->dwLgDevRev = (DWORD) LLDR_SZ (grRevision_ID);

        #if !(DRIVER_5465)
            //
            // If it is not a 5462 chip, fill ExtraDwordTable with zero
            //
            if (ppdev->dwLgDevID != CL_GD5462)
            {
                memset(&ExtraDwordTable[0],      0, 0x8000);
                memset(&ExtraDwordTable[0x8000], 0, 0x8000);

                //
                // Turn on the GoFast(tm) bit (bit 7 of OP0_opSRAM).
                //
				REQUIRE(1);
                LL16(grOP0_opSRAM, 0x0080);
            }
        #endif

		// Bit 13 must be on for BITMASK to happen
		REQUIRE(4);
		LL16 (grDRAWDEF, LLDR_SZ(grDRAWDEF) | 0x2000);
		LL32 (grBITMASK.dw,0xFFFFFFFF);      //# Turn on all bits
		LL16 (grDRAWDEF, LLDR_SZ(grDRAWDEF) & ~0x2000);
                DISPDBG((1,"bInitSurf:  Register init complete.\n"));

		//
		// Get the tile size and offset_2D informations
		// *** Note: ***
		//    Temporary set, should read from Laguna OFFSET_2D register
		ppdev->lOffset_2D = 0;        
		ppdev->grFORMAT = (DWORD) LLDR_SZ (grFormat);
		ppdev->grCONTROL = (DWORD) LLDR_SZ (grCONTROL);
		ppdev->grVS_CONTROL = (DWORD) LLDR_SZ (grVS_Control);
		if (ppdev->grCONTROL & 0x1000)
		{
                        DISPDBG((1,"Tiling not enabled!\n"));
			return(FALSE);
		}
		ppdev->lTileSize = (ppdev->grCONTROL & 0x0800) ? 256 : 128;

		// Initialize Some variable for stroke and fill
		if (ppdev->iBytesPerPixel == 3)
		{
			ppdev->dcTileWidth = (USHORT) (ppdev->lTileSize / (ppdev->iBytesPerPixel + 1));
			ppdev->dcSRAMWidth = (USHORT) (LG_SRAM_SIZE / (ppdev->iBytesPerPixel + 1));
		}       
		else
		{
			ppdev->dcTileWidth = (USHORT) (ppdev->lTileSize / ppdev->iBytesPerPixel);
			ppdev->dcSRAMWidth = (USHORT) (LG_SRAM_SIZE / ppdev->iBytesPerPixel);
		}       


        //
        // HACK!!! for VS_CONTROL bit 0
        //
        #if (VS_CONTROL_HACK && DRIVER_5465)
        {
            DISPDBG((1,"bInitSurf: Disable MMIO for PCI config regs.\n"));
            ppdev->grVS_CONTROL &= 0xFFFFFFFE; // Clear bit 0
            LL32 (grVS_Control, ppdev->grVS_CONTROL);
        }
        #endif

		// Initialize the offscreen manager
		if (!InitOffScnMem(ppdev))
		{
                        DISPDBG((1,"bInitSurf: Fail off screen memory init. Exit.\n"));
			return(FALSE);
		}

      // Allocate a 1x(lDeltaScreen/bpp) block offscreen mem as
      // DD scratch buffer
      {
        DRIVERDATA* pDriverData = (DRIVERDATA*) &ppdev->DriverData;
        SIZEL  sizl;

        if (pDriverData->ScratchBufferOrg == 0)
        {
           sizl.cx = ppdev->lDeltaScreen/BYTESPERPIXEL;
           sizl.cy = 1;
           ppdev->DDScratchBufHandle = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);

           if (ppdev->DDScratchBufHandle != NULL)
           {
              pDriverData->ScratchBufferOrg = (DWORD) ((ppdev->DDScratchBufHandle->aligned_y << 16) |
                                                        ppdev->DDScratchBufHandle->aligned_x);
           };
        };
      }

		// Initialize the cursor information.
		InitPointer(ppdev);

		//
		// Initialize the brush cache.
		//
		vInitBrushCache(ppdev);

		#if COLOR_TRANSLATE
		//
		// Initialize the color translation cache.
		//
		vInitHwXlate(ppdev);
		#endif
		
		#if SWAT3
		// Enable font cache.
		vAssertModeText(ppdev, TRUE);
		#endif

        #if BUS_MASTER
        if (ppdev->BufLength != 0)
        {
		    ppdev->pfnHostToScreen =
			    afnBusMasterBufferedHostToScreen[ppdev->iBytesPerPixel - 1];
		    ppdev->pfnScreenToHost =
			    afnScreenToHost[ppdev->iBytesPerPixel - 1];
        }
        else
        #endif
        {
		    ppdev->pfnHostToScreen =
			    afnHostToScreen[ppdev->iBytesPerPixel - 1];
		    ppdev->pfnScreenToHost =
			    afnScreenToHost[ppdev->iBytesPerPixel - 1];
        }


	} // END bFirst

	else // The surface is being re-initialized for some reason.
	{    // Usually this means the user is switching back from a 
		 // full-screen DOS box back to Windows.
		
		int i;

        // get cursor HW going again
        InitPointerHW (ppdev);

		//
		// The following is "good practice" for GRX setup.
		//
		REQUIRE(13);
		LL16(grOP0_opRDRAM.pt.X, 0);	//# Set host phase 0
		LL16(grOP1_opRDRAM.pt.X, 0);	//# Set host phase 0
		LL16(grOP2_opRDRAM.pt.X, 0);	//# Set host phase 0
		LL16(grOP0_opSRAM, 0);			//# Point to start of SRAM0
		LL16(grOP1_opSRAM, 0);			//# Point to start of SRAM1
		LL16(grOP2_opSRAM, 0);			//# Point to start of SRAM2
		LL16(grOP1_opMSRAM, 0);			//# Point to start of mono SRAM1
		LL16(grOP2_opMSRAM, 0);			//# Point to start of mono SRAM2
		LL16(grPATOFF.w, 0);			//# All patterns aligned to 0,0
		LL_BGCOLOR(0xFFFFFFFF, 0);		//# Background color is White
		LL_FGCOLOR(0x00000000, 0);		//# Foreground color is Black (~FGC)

		// Bit 13 must be on for BITMASK to happen
		REQUIRE(4);
		LL16 (grDRAWDEF, LLDR_SZ(grDRAWDEF) | 0x2000);
		LL32 (grBITMASK.dw,0xFFFFFFFF);      //# Turn on all bits
		LL16 (grDRAWDEF, LLDR_SZ(grDRAWDEF) & ~0x2000);


		#if COLOR_TRANSLATE
        // Invalidate the color translation cache
        vInvalidateXlateCache(ppdev);
		#endif

		// Invalidate the brush cache.
        vInvalidateBrushCache(ppdev);

		// Invalidate all cached fonts.
		ppdev->ulFontCount++;

		// Release the pointer buffers
		if (ppdev->PtrImageHandle != NULL)
		{
		   FreeOffScnMem(ppdev, ppdev->PtrImageHandle);
		   ppdev->PtrImageHandle = NULL;
		};

		if (ppdev->PtrABltHandle != NULL)
		{
		   FreeOffScnMem(ppdev, ppdev->PtrABltHandle);
		   ppdev->PtrABltHandle = NULL;
		};

		ppdev->CursorHidden = TRUE;

	}

	#if HW_PRESET_BUG
	{
		ULONG ultmp;

		//
		// Enable the HW cursor once, then leave it on.
		// Turn it "off" by moving it off the screen.
		//
		LL16 (grCursor_X, (WORD)0xFFFF);
		LL16 (grCursor_Y, (WORD)0xFFFF);

		ultmp = LLDR_SZ (grCursor_Control);
		if ((ultmp & 1) == 0)
		{
			ultmp |= 0x0001;
			LL16 (grCursor_Control, ultmp);
		}
	}
	#endif
	
	//
	// Decide whether to use the font cache or not.
	// In low offscreen memory situations, we want to ensure we 
	// have enough off screen memory for device bitmaps.
	//
	ppdev->UseFontCache = 1; // Enable it.

	#if 0
	// Now disable it if we don't have much memory.
	if (ppdev->lTotalMem == 4*1024*1024) // 4 meg board.
	{
	    ; // Leave it enabled.
	}
	else if (ppdev->lTotalMem == 2*1024*1024) // 2 meg board.
	{
	    switch (ppdev->iBytesPerPixel)
	    {
		case 1: // 8 bpp, Lots of memory, leave it on.
		    break;         

		case 2: // 16 bpp.  
		    if (ppdev->cxScreen >= 1024)
			ppdev->UseFontCache = 1;
		    break;

		case 3: // 24 bpp
		    if (ppdev->cxScreen == 800)
			ppdev->UseFontCache = 0;
		    break;

		case 4: // 32 bpp. 
		    if (ppdev->cxScreen == 640)
			ppdev->UseFontCache = 0;
		    break; 
	    }
	}
	else if (ppdev->lTotalMem == 1*1024*1024) // 1 meg board.
	{
	    ; // leave it on.
	}
	else
	{
	    RIP("Error determining memory on board.\n");
	}
	#endif 


    #if WINBENCH96
	{
        //
	    // Pre allocate a small chunk of off screen memory for device bitmaps.
  	    // Otherwise the font cache quickly consumes all offscreen memory on
	    // 1 and 2 meg boards.
	    //
	    SIZEL  sizl;

		sizl.cx = MAGIC_SIZEX;
		sizl.cy = MAGIC_SIZEY;

		if (!ppdev->pofmMagic)
		{
                        DISPDBG((1,"Allocating magic bitmap.\n"));
			ppdev->pofmMagic =  AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
			ppdev->bMagicUsed = 0;  // We've allocated it, but we haven't used it.
		};
	}
    #endif
	
        DISPDBG((1,"bInitSurf: Exit.\n"));
	return TRUE;
}

/******************************Public*Routine******************************\
* vDisableSURF
*
* Disable the surface. Un-Maps the frame in memory.
*
\**************************************************************************/

VOID vDisableSURF(PPDEV ppdev)
{
	DWORD returnedDataLength;
	VIDEO_MEMORY videoMemory;

        DISPDBG((1,"vDisableSURF:  Entry.\n"));

	videoMemory.RequestedVirtualAddress = (PVOID) ppdev->pjScreen;

	if (!DEVICE_IO_CTRL(ppdev->hDriver,
						IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
						&videoMemory,
						sizeof(VIDEO_MEMORY),
						NULL,
						0,
						&returnedDataLength,
						NULL))
	{
		RIP("DISP vDisableSURF failed IOCTL_VIDEO_UNMAP\n");
	}

        DISPDBG((1,"vDisableSurface:  Exit.\n"));

}


/******************************Public*Routine******************************\
* bInitPDEV
*
* Determine the mode we should be in based on the DEVMODE passed in.
* Query mini-port to get information needed to fill in the DevInfo and the
* GdiInfo .
*
\**************************************************************************/

BOOL bInitPDEV(
PPDEV ppdev,
DEVMODEW *pDevMode,
GDIINFO *pGdiInfo,
DEVINFO *pDevInfo)
{
	ULONG cModes;
	PVIDEO_MODE_INFORMATION pVideoBuffer, pVideoModeSelected, pVideoTemp;
	VIDEO_COLOR_CAPABILITIES colorCapabilities;
	ULONG ulTemp;
	BOOL bSelectDefault;
	ULONG cbModeSize;

	//
	// calls the miniport to get mode information.
	//

        DISPDBG((1,"bInitPDEV:  Entry.\n"));

	cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);

	if (cModes == 0)
	{
                DISPDBG((1,"bInitPDEV:  Exit. cModes==0.\n"));
		return(FALSE);
	}

	//
	// Determine if we are looking for a default mode.
	//

	if ( ((pDevMode->dmPelsWidth) ||
		  (pDevMode->dmPelsHeight) ||
		  (pDevMode->dmBitsPerPel) ||
		  (pDevMode->dmDisplayFlags) ||
		  (pDevMode->dmDisplayFrequency)) == 0)
	{
		bSelectDefault = TRUE;
	}
	else
	{
		bSelectDefault = FALSE;
	}

	//
	// Now see if the requested mode has a match in that table.
	//

	pVideoModeSelected = NULL;
	pVideoTemp = pVideoBuffer;

	while (cModes--)
	{
		if (pVideoTemp->Length != 0)
		{
			if (bSelectDefault ||
				((pVideoTemp->VisScreenWidth  == pDevMode->dmPelsWidth) &&
				 (pVideoTemp->VisScreenHeight == pDevMode->dmPelsHeight) &&
				 (pVideoTemp->BitsPerPlane *
				  pVideoTemp->NumberOfPlanes  == pDevMode->dmBitsPerPel) &&
				 ((pVideoTemp->Frequency  == pDevMode->dmDisplayFrequency) ||
					(pDevMode->dmDisplayFrequency == 0)) ) )
			{
				pVideoModeSelected = pVideoTemp;
				break;
			}
		}

		pVideoTemp = (PVIDEO_MODE_INFORMATION)
			(((PUCHAR)pVideoTemp) + cbModeSize);
	}

	//
	// If no mode has been found, return an error
	//

	if (pVideoModeSelected == NULL)
	{
		MEMORY_FREE(pVideoBuffer);
                DISPDBG((1,"DISP bInitPDEV failed - no valid modes\n"));
		return(FALSE);
	}

   // Fill in signature for PDEV and DriverData structures
   {
      DRIVERDATA* pDriverData = (DRIVERDATA*) &ppdev->DriverData;

      ppdev->signature = 0x12345678;
      pDriverData->signature = 0x9abcdef0;
   }

	//
	// Fill in the GDIINFO data structure with the information returned from
	// the kernel driver.
	//

	ppdev->ulFreq = pVideoModeSelected->Frequency;
	ppdev->ulMode = pVideoModeSelected->ModeIndex;
	ppdev->cxScreen = pVideoModeSelected->VisScreenWidth-OFFSCREEN_COLS;
	ppdev->cyScreen = pVideoModeSelected->VisScreenHeight-OFFSCREEN_LINES;
	ppdev->cxMemory = pVideoModeSelected->VideoMemoryBitmapWidth;
	ppdev->cyMemory = pVideoModeSelected->VideoMemoryBitmapHeight;
	ppdev->ulBitCount = pVideoModeSelected->BitsPerPlane *
						pVideoModeSelected->NumberOfPlanes;
	ppdev->lDeltaScreen = pVideoModeSelected->ScreenStride;
	ppdev->iBytesPerPixel = ppdev->ulBitCount/8;


        DISPDBG((1, "DISP bInitPDEV: Screen size = %d x %d.\n",ppdev->cxScreen,ppdev->cyScreen));
        DISPDBG((1, "DISP bInitPDEV: Color depth = %d bpp.\n",ppdev->ulBitCount));
        DISPDBG((1, "DISP bInitPDEV: Screen Delta = %d bpp.\n",ppdev->lDeltaScreen));

	ppdev->flRed = pVideoModeSelected->RedMask;
	ppdev->flGreen = pVideoModeSelected->GreenMask;
	ppdev->flBlue = pVideoModeSelected->BlueMask;

	// pGdiInfo->ulVersion    = 0x1019;    // Our driver is verion 3.5.00

#ifdef WINNT_VER40
	pGdiInfo->ulVersion    = GDI_DRIVER_VERSION | (VER_REV & 0xFF);
#else
	pGdiInfo->ulVersion    = (((VER_MAJ) & 0xF) << 12) |
				 (((VER_MIN) & 0xF) << 8 ) | 
				 (((VER_REV) & 0xFFFF)   ) ;
#endif

	pGdiInfo->ulTechnology = DT_RASDISPLAY;
	pGdiInfo->ulHorzSize   = pVideoModeSelected->XMillimeter;
	pGdiInfo->ulVertSize   = pVideoModeSelected->YMillimeter;

	pGdiInfo->ulHorzRes        = ppdev->cxScreen;
	pGdiInfo->ulVertRes        = ppdev->cyScreen;

#ifdef WINNT_VER40
	pGdiInfo->ulPanningHorzRes = ppdev->cxScreen;
	pGdiInfo->ulPanningVertRes = ppdev->cyScreen;
#else
	pGdiInfo->ulDesktopHorzRes = ppdev->cxScreen;
	pGdiInfo->ulDesktopVertRes = ppdev->cyScreen;
#endif

	pGdiInfo->cBitsPixel       = pVideoModeSelected->BitsPerPlane;
	pGdiInfo->cPlanes          = pVideoModeSelected->NumberOfPlanes;
	pGdiInfo->ulVRefresh       = pVideoModeSelected->Frequency;
	pGdiInfo->ulBltAlignment   = 0; // We have accelerated screen-to-screen.

	pGdiInfo->ulLogPixelsX = pDevMode->dmLogPixels;
	pGdiInfo->ulLogPixelsY = pDevMode->dmLogPixels;

	pGdiInfo->flTextCaps = TC_RA_ABLE;

	pGdiInfo->flRaster = 0;           // flRaster is reserved by DDI

	pGdiInfo->ulDACRed   = pVideoModeSelected->NumberRedBits;
	pGdiInfo->ulDACGreen = pVideoModeSelected->NumberGreenBits;
	pGdiInfo->ulDACBlue  = pVideoModeSelected->NumberBlueBits;

	pGdiInfo->ulAspectX    = 0x24;    // One-to-one aspect ratio
	pGdiInfo->ulAspectY    = 0x24;
	pGdiInfo->ulAspectXY   = 0x33;

	pGdiInfo->xStyleStep   = 1;       // A style unit is 3 pels
	pGdiInfo->yStyleStep   = 1;
	pGdiInfo->denStyleStep = 3;

	pGdiInfo->ptlPhysOffset.x = 0;
	pGdiInfo->ptlPhysOffset.y = 0;
	pGdiInfo->szlPhysSize.cx  = 0;
	pGdiInfo->szlPhysSize.cy  = 0;

	// RGB and CMY color info.

	// try to get it from the miniport.
	// if the miniport doesn ot support this feature, use defaults.

	if (!DEVICE_IO_CTRL(ppdev->hDriver,
						 IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES,
						 NULL,
						 0,
						 &colorCapabilities,
						 sizeof(VIDEO_COLOR_CAPABILITIES),
						 &ulTemp,
						 NULL))
	{

                DISPDBG((1, "DISP getcolorCapabilities failed \n"));

		pGdiInfo->ciDevice.Red.x = 6700;
		pGdiInfo->ciDevice.Red.y = 3300;
		pGdiInfo->ciDevice.Red.Y = 0;
		pGdiInfo->ciDevice.Green.x = 2100;
		pGdiInfo->ciDevice.Green.y = 7100;
		pGdiInfo->ciDevice.Green.Y = 0;
		pGdiInfo->ciDevice.Blue.x = 1400;
		pGdiInfo->ciDevice.Blue.y = 800;
		pGdiInfo->ciDevice.Blue.Y = 0;
		pGdiInfo->ciDevice.AlignmentWhite.x = 3127;
		pGdiInfo->ciDevice.AlignmentWhite.y = 3290;
		pGdiInfo->ciDevice.AlignmentWhite.Y = 0;

		pGdiInfo->ciDevice.RedGamma = 20000;
		pGdiInfo->ciDevice.GreenGamma = 20000;
		pGdiInfo->ciDevice.BlueGamma = 20000;

	}
	else
	{
		pGdiInfo->ciDevice.Red.x = colorCapabilities.RedChromaticity_x;
		pGdiInfo->ciDevice.Red.y = colorCapabilities.RedChromaticity_y;
		pGdiInfo->ciDevice.Red.Y = 0;
		pGdiInfo->ciDevice.Green.x = colorCapabilities.GreenChromaticity_x;
		pGdiInfo->ciDevice.Green.y = colorCapabilities.GreenChromaticity_y;
		pGdiInfo->ciDevice.Green.Y = 0;
		pGdiInfo->ciDevice.Blue.x = colorCapabilities.BlueChromaticity_x;
		pGdiInfo->ciDevice.Blue.y = colorCapabilities.BlueChromaticity_y;
		pGdiInfo->ciDevice.Blue.Y = 0;
		pGdiInfo->ciDevice.AlignmentWhite.x = colorCapabilities.WhiteChromaticity_x;
		pGdiInfo->ciDevice.AlignmentWhite.y = colorCapabilities.WhiteChromaticity_y;
		pGdiInfo->ciDevice.AlignmentWhite.Y = colorCapabilities.WhiteChromaticity_Y;

		// if we have a color device store the three color gamma values,
		// otherwise store the unique gamma value in all three.

		if (colorCapabilities.AttributeFlags & VIDEO_DEVICE_COLOR)
		{
			pGdiInfo->ciDevice.RedGamma = colorCapabilities.RedGamma;
			pGdiInfo->ciDevice.GreenGamma = colorCapabilities.GreenGamma;
			pGdiInfo->ciDevice.BlueGamma = colorCapabilities.BlueGamma;
		}
		else
		{
			pGdiInfo->ciDevice.RedGamma = colorCapabilities.WhiteGamma;
			pGdiInfo->ciDevice.GreenGamma = colorCapabilities.WhiteGamma;
			pGdiInfo->ciDevice.BlueGamma = colorCapabilities.WhiteGamma;
		}

	};

	pGdiInfo->ciDevice.Cyan.x = 0;
	pGdiInfo->ciDevice.Cyan.y = 0;
	pGdiInfo->ciDevice.Cyan.Y = 0;
	pGdiInfo->ciDevice.Magenta.x = 0;
	pGdiInfo->ciDevice.Magenta.y = 0;
	pGdiInfo->ciDevice.Magenta.Y = 0;
	pGdiInfo->ciDevice.Yellow.x = 0;
	pGdiInfo->ciDevice.Yellow.y = 0;
	pGdiInfo->ciDevice.Yellow.Y = 0;

	// No dye correction for raster displays.

	pGdiInfo->ciDevice.MagentaInCyanDye = 0;
	pGdiInfo->ciDevice.YellowInCyanDye = 0;
	pGdiInfo->ciDevice.CyanInMagentaDye = 0;
	pGdiInfo->ciDevice.YellowInMagentaDye = 0;
	pGdiInfo->ciDevice.CyanInYellowDye = 0;
	pGdiInfo->ciDevice.MagentaInYellowDye = 0;

	pGdiInfo->ulDevicePelsDPI = 0;   // For printers only
	pGdiInfo->ulPrimaryOrder = PRIMARY_ORDER_CBA;

        // This should be modified to take into account the size
	// of the display and the resolution.

	pGdiInfo->ulHTPatternSize = HT_PATSIZE_4x4_M;

	pGdiInfo->flHTFlags = HT_FLAG_ADDITIVE_PRIMS;

	// Fill in the basic devinfo structure

	*pDevInfo = gDevInfoFrameBuffer;

	// Fill in the rest of the devinfo and GdiInfo structures.

	if (ppdev->ulBitCount == 8)
	{
		// It is Palette Managed.

		pGdiInfo->ulNumColors = 20;
		pGdiInfo->ulNumPalReg = 1 << ppdev->ulBitCount;

		pDevInfo->flGraphicsCaps |= GCAPS_PALMANAGED | GCAPS_COLOR_DITHER;

		pGdiInfo->ulHTOutputFormat = HT_FORMAT_8BPP;
		pDevInfo->iDitherFormat = BMF_8BPP;

		// Assuming palette is orthogonal - all colors are same size.

		ppdev->cPaletteShift   = 8 - pGdiInfo->ulDACRed;
	}
	else
	{
		pGdiInfo->ulNumColors = (ULONG) (-1);
		pGdiInfo->ulNumPalReg = 0;

		if (ppdev->ulBitCount == 16)
		{
			pGdiInfo->ulHTOutputFormat = HT_FORMAT_16BPP;
			pDevInfo->iDitherFormat = BMF_16BPP;
		}
		else if (ppdev->ulBitCount == 24)
		{
			pGdiInfo->ulHTOutputFormat = HT_FORMAT_24BPP;
			pDevInfo->iDitherFormat = BMF_24BPP;
		}
		else
		{
			pGdiInfo->ulHTOutputFormat = HT_FORMAT_32BPP;
			pDevInfo->iDitherFormat = BMF_32BPP;
		}
	}

	MEMORY_FREE(pVideoBuffer);
        DISPDBG((1,"bInitPDEV:  Exit.\n"));
	return(TRUE);
}


/******************************Public*Routine******************************\
* getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE hDriver,
PVIDEO_MODE_INFORMATION *modeInformation,
DWORD *cbModeSize)
{
	ULONG ulTemp;
	VIDEO_NUM_MODES modes;
	PVIDEO_MODE_INFORMATION pVideoTemp;

	//
	// Get the number of modes supported by the mini-port
	//

        DISPDBG((1,"getAvailableModes:  Entry.\n"));

	if (!DEVICE_IO_CTRL(hDriver,
			IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
			NULL,
			0,
			&modes,
			sizeof(VIDEO_NUM_MODES),
			&ulTemp,
			NULL))
	{
                DISPDBG((1, "framebuf.dll getAvailableModes failed VIDEO_QUERY_NUM_AVAIL_MODES\n"));
		return(0);
	}

	*cbModeSize = modes.ModeInformationLength;

	//
	// Allocate the buffer for the mini-port to write the modes in.
	//

	*modeInformation = (PVIDEO_MODE_INFORMATION)
#ifdef WINNT_VER40
						MEM_ALLOC(FL_ZERO_MEMORY,
								   modes.NumModes *
								   modes.ModeInformationLength, ALLOC_TAG);
#else
						MEM_ALLOC(LMEM_FIXED | LMEM_ZEROINIT,
								   modes.NumModes *
								   modes.ModeInformationLength);
#endif

	if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
	{
                DISPDBG((1, "framebuf.dll getAvailableModes failed LocalAlloc\n"));

		return 0;
	}

	//
	// Ask the mini-port to fill in the available modes.
	//

	if (!DEVICE_IO_CTRL(hDriver,
			IOCTL_VIDEO_QUERY_AVAIL_MODES,
			NULL,
			0,
			*modeInformation,
			modes.NumModes * modes.ModeInformationLength,
			&ulTemp,
			NULL))
	{

                DISPDBG((1, "framebuf.dll getAvailableModes failed VIDEO_QUERY_AVAIL_MODES\n"));

		MEMORY_FREE(*modeInformation);
		*modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

		return(0);
	}

	//
	// Now see which of these modes are supported by the display driver.
	// As an internal mechanism, set the length to 0 for the modes we
	// DO NOT support.
	//

	ulTemp = modes.NumModes;
	pVideoTemp = *modeInformation;

	//
	// Mode is rejected if it is not one plane, or not graphics, or is not
	// one of 8, 16 or 32 bits per pel.
	//

	while (ulTemp--)
	{
		if ((pVideoTemp->NumberOfPlanes != 1 ) ||
			!(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
			((pVideoTemp->BitsPerPlane != 8) &&
			 (pVideoTemp->BitsPerPlane != 16) &&
			 (pVideoTemp->BitsPerPlane != 24) &&
			 (pVideoTemp->BitsPerPlane != 32)))
		{
			pVideoTemp->Length = 0;
		}

		pVideoTemp = (PVIDEO_MODE_INFORMATION)
			(((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
	}

        DISPDBG((1,"getAvailableModes:  Exit.\n"));

	return modes.NumModes;

}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\pwrmgr.c ===
/***************************************************************************
*
*                ******************************************
*                * Copyright (c) 1997, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna (CL-GD546X) - 
*
* FILE:     pwrmgr.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module contains Power manager code for both
*           Laguna Win95 and NT drivers.
*
* MODULES:
*           LgPM_SetHwModuleState()
*           LgPM_GetHwModuleState()
*
* REVISION HISTORY:
* $Log:   X:/log/laguna/powermgr/src/pwrmgr.c  $
* 
*    Rev 1.3   20 Jun 1997 13:37:16   bennyn
* 
* Moved power manager functions to Miniport
* 
*    Rev 1.2   23 Apr 1997 08:01:42   SueS
* Enable MMIO access to PCI configuration registers before VS_Clk_Control
* and VS_Control are referenced.  Disable MMIO access after they're
* referenced.
* 
*    Rev 1.1   23 Jan 1997 16:29:28   bennyn
* Use bit-11 instead of bit-15 to enable VS_CLK_CNTL
* 
*    Rev 1.0   16 Jan 1997 11:48:20   bennyn
* Initial revision.
* 
*
****************************************************************************
****************************************************************************/


#include "precomp.h"
#include "clioctl.h"

#if defined WINNT_VER35      // WINNT_VER35
  // If WinNT 3.5 skip all the source code
#else

/*----------------------------- INCLUDES ----------------------------------*/
#ifndef WINNT_VER40
#include <pwrmgr.h>
#endif

/*----------------------------- DEFINES -----------------------------------*/

/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/

/*-------------------------- STATIC VARIABLES -----------------------------*/
            
            
/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/
            
/****************************************************************************
* FUNCTION NAME: LgPM_SetHwModuleState()
*
* DESCRIPTION:   This routine validates the request for any conflict between
*                the request and the current chip operation. If it is valid,
*                it will enable or disable the specified HW module by turning
*                on or off appropriate HW clocks and returns TRUE. If it is 
*                invalid or there is a conflict to the current chip operation,
*                it ignores the request and return FAIL.
*
* Input:
*   hwmod - can be one of the following HW modules
*             MOD_2D
*             MOD_3D
*             MOD_TVOUT
*             MOD_VPORT
*             MOD_VGA
*             MOD_EXTMODE
*             MOD_STRETCH
*
*   state - Ether ENABLE or DISABLE.
*
* Return: TRUE - succeed, FALSE - failed.     
*
*****************************************************************************/
BOOL LgPM_SetHwModuleState (PPDEV ppdev, ULONG hwmod, ULONG state)
{
  LGPM_IN_STRUCT    InBuf;
  LGPM_OUT_STRUCT   OutBuf;
  DWORD  cbBytesReturned;

  InBuf.arg1 = hwmod;
  InBuf.arg2 = state;
  OutBuf.status = FALSE;
  OutBuf.retval = 0;

  if (DEVICE_IO_CTRL(ppdev->hDriver,
                     IOCTL_SET_HW_MODULE_POWER_STATE,
                     (LPVOID)&InBuf,  sizeof(InBuf),
                     (LPVOID)&OutBuf, sizeof(OutBuf),
                     &cbBytesReturned, NULL))
     return TRUE;
  else
     return FALSE;

};  // LgPM_SetHwModuleState



/****************************************************************************
* FUNCTION NAME: LgPM_GetHwModuleState()
*
* DESCRIPTION:   This routine returns the current state of a particular
*                hardware module.
* 
* Input:
*   hwmod - can be one of the following HW modules
*             MOD_2D
*             MOD_3D
*             MOD_TVOUT
*             MOD_VPORT
*             MOD_VGA
*             MOD_EXTMODE
*             MOD_STRETCH
*
*   state - Pointer to ULONG variable for returning the HW module state
*           (ENABLE or DISABLE).
*
* Return: TRUE - succeed, FALSE - failed.     
*                
****************************************************************************/
BOOL LgPM_GetHwModuleState (PPDEV ppdev, ULONG hwmod, ULONG* state)
{
  LGPM_IN_STRUCT    InBuf;
  LGPM_OUT_STRUCT   OutBuf;
  DWORD  cbBytesReturned;

  InBuf.arg1 = hwmod;
  InBuf.arg2 = (ULONG) state;
  OutBuf.status = FALSE;
  OutBuf.retval = 0;

  if (DEVICE_IO_CTRL(ppdev->hDriver,
                     IOCTL_GET_HW_MODULE_POWER_STATE,
                     (LPVOID)&InBuf,  sizeof(InBuf),
                     (LPVOID)&OutBuf, sizeof(OutBuf),
                     &cbBytesReturned, NULL))
     return TRUE;
  else
     return FALSE;

};  // LgPM_GetHwModuleState


#endif // WINNT_VER35


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\ssbits.c ===
/****************************************************************************
*****************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:	Laguna I (CL-GD5462) - 
*
* FILE:		ssbits.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module implements the DrvSaveScreenBits() for
*           Laguna NT driver.
*
* MODULES:
*           DrvSaveScreenBits()
*
* REVISION HISTORY:
*   6/20/95     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/SSBITS.C  $
* 
*    Rev 1.18   Apr 28 1998 12:51:44   frido
* PDR#11389. I have disabled DrvSaveScreenBits on 2MB boards. We
* seem to run out of memory and the memory manager moves the blocks
* to a different place causing corruption.
* 
*    Rev 1.17   Mar 04 1998 15:34:18   frido
* Added new shadow macros.
* 
*    Rev 1.16   Nov 03 1997 11:18:10   frido
* Added REQUIRE macros.
* 
*    Rev 1.15   08 Aug 1997 17:24:22   FRIDO
* Added support for new memory manager.
* 
*    Rev 1.14   09 Apr 1997 10:49:28   SueS
* Changed sw_test_flag to pointer_switch.
* 
*    Rev 1.13   08 Apr 1997 12:27:40   einkauf
* 
* add SYNC_W_3D to coordinate MCD/2D hw access
* 
*    Rev 1.12   26 Nov 1996 10:44:02   SueS
* Changed WriteLogFile parameters for buffering.
* 
*    Rev 1.11   13 Nov 1996 17:08:46   SueS
* Changed WriteFile calls to WriteLogFile.
* 
*    Rev 1.10   07 Nov 1996 16:09:08   bennyn
* 
* Added no offscn allocation if DD enabled
* 
*    Rev 1.9   23 Aug 1996 09:10:38   noelv
* Save unders are now discardable.
* 
*    Rev 1.2   22 Aug 1996 17:07:14   frido
* #ss - Added validation of saved area before restoring or freeing it.
* 
*    Rev 1.1   15 Aug 1996 11:39:54   frido
* Added precompiled header.
* 
*    Rev 1.0   14 Aug 1996 17:16:30   frido
* Initial revision.
* 
*    Rev 1.7   18 Jun 1996 12:39:34   noelv
* added debug information.
* 
*    Rev 1.6   28 May 1996 15:11:30   noelv
* Updated data logging.
* 
*    Rev 1.5   16 May 1996 15:01:02   bennyn
* 
* Add PIXEL_ALIGN to allocoffscnmen()
* 
*    Rev 1.4   20 Mar 1996 16:09:42   noelv
* 
* Updated data logging
* 
*    Rev 1.3   05 Mar 1996 12:01:46   noelv
* Frido version 19
 * 
 *    Rev 1.1   20 Jan 1996 01:16:48   frido
 *  
* 
*    Rev 1.4   15 Jan 1996 17:00:08   NOELV
* AB workaround reductions
* 
*    Rev 1.3   20 Oct 1995 11:21:50   NOELV
* 
* Was leaking offscreen memory.  Now it releases its memory after resoring.
* 
*    Rev 1.2   04 Oct 1995 10:17:36   NOELV
* 
* Used updated write macros.
* 
*    Rev 1.1   21 Aug 1995 13:52:44   NOELV
* Initial port to real hardware.
* Converted all 32 bit register writes to 2 16 bit regiser writes.
* 
*    Rev 1.0   25 Jul 1995 11:23:20   NOELV
* Initial revision.
* 
*    Rev 1.2   06 Jul 1995 09:59:10   BENNYN
* 
* 
*    Rev 1.1   05 Jul 1995 08:39:44   BENNYN
* Initial version
* 
*    Rev 1.0   29 Jun 1995 14:20:44   BENNYN
* Initial revision.
* 
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"
#include "SWAT.h"

#if MEMMGR
POFMHDL FindHandle(PPDEV ppdev, POFMHDL hdl);
#endif

/*----------------------------- DEFINES -----------------------------------*/
#define SSB_DBG_LEVEL 1

/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/

/*-------------------------- STATIC VARIABLES -----------------------------*/

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/

//
// If data logging is enabled, Prototype the logging files.
//
#if LOG_CALLS
    void LogSaveScreenBits(
	int 	  acc,
        PPDEV ppdev);

//
// If data logging is not enabled, compile out the calls.
//
#else
    #define LogSaveScreenBits(acc, ppdev)
#endif


/****************************************************************************
* FUNCTION NAME: DrvSaveScreenBits()
*
* DESCRIPTION:   Do the save and restore of a given rectange of the
*                displayed image
*
* REVISION HISTORY:
*   7/05/95     Benny Ng      Initial version
****************************************************************************/
ULONG DrvSaveScreenBits(
SURFOBJ* pso,
ULONG    iMode,
ULONG    ident,
RECTL*   prcl)
{
	POFMHDL Handle;
	SIZEL   reqsz;
	LONG    szx, szy;
	PPDEV   ppdev = (PPDEV) pso->dhpdev;
#if 1 //#ss
	POFMHDL pofm;
#endif

    SYNC_W_3D(ppdev);

	DISPDBG((SSB_DBG_LEVEL, "DrvSaveScreenBits - (%d)\n", iMode));

	switch (iMode)
	{
	case SS_SAVE: // -----------------------------------------------------------

#ifdef ALLOC_IN_CREATESURFACE
      if (ppdev->bDirectDrawInUse)
         return (0);
#ifdef WINNT_VER40      // WINNT_VER40
      // MCD should be active only when DDraw is active, but after mode change, 
      // it seems that DDraw is disabled and not re-enabled.  Since MCD uses
      // off screen memory like DDraw, we should punt SS_SAVE as if DDraw was alive
      if (ppdev->NumMCDContexts > 0)                                                                          \
         return (0);
#endif
#endif

#if 1 // PDR#11389
		if (ppdev->lTotalMem < 4096 * 1024)
		{
			DISPDBG((SSB_DBG_LEVEL, "DrvSaveScreenBits - Not enough memory\n"));
			return (ULONG)NULL;
		}
#endif

		ASSERTMSG((prcl != NULL),
				  "NULL rectangle in SaveScreenBits. Mode=SS_SAVE.\n");

		szx = prcl->right  - prcl->left;
		szy = prcl->bottom - prcl->top;
		reqsz.cx = szx;
		reqsz.cy = szy;
      
		Handle = AllocOffScnMem(ppdev, &reqsz, PIXEL_AlIGN, NULL);
		if (Handle != NULL)
		{
			// Save the image to offscreen memory
			REQUIRE(9);
			LL_DRAWBLTDEF(0x101000CC, 0);
			LL_OP1(prcl->left, prcl->top);
			LL_OP0(Handle->aligned_x / ppdev->iBytesPerPixel,
				   Handle->aligned_y);
			LL_BLTEXT(szx, szy);
			LogSaveScreenBits(0, ppdev);
#if 1 //#ss
			Handle->alignflag |= SAVESCREEN_FLAG;
#endif
		}
		else
		{
			LogSaveScreenBits(9, ppdev);
		}

		DISPDBG((SSB_DBG_LEVEL, "DrvSaveScreenBits - Exit\n", iMode));
		return((ULONG) Handle);

	case SS_RESTORE: // --------------------------------------------------------
		ASSERTMSG((prcl != NULL),
				  "NULL rectangle in SaveScreenBits. Mode=SS_RESTORE.\n");

		Handle = (POFMHDL) ident;

#if 1 //#ss
	#if MEMMGR
		pofm = FindHandle(ppdev, Handle);
	#else
		for (pofm = ppdev->OFM_UsedQ; pofm; pofm = pofm->nexthdl)
		{
			if (Handle == pofm)
			{
				break;
			}
		}
	#endif
		if (pofm == NULL)
		{
			DISPDBG((SSB_DBG_LEVEL,
					 "DrvSaveScreenBits - Unable to restore.\n"));
			return(FALSE);
		}
#endif
      
		// Restore the image using the BLT operation
		REQUIRE(9);
		LL_DRAWBLTDEF(0x101000CC, 0);
		LL_OP1(Handle->aligned_x / ppdev->iBytesPerPixel, Handle->aligned_y);
		LL_OP0(prcl->left, prcl->top);
		LL_BLTEXT(prcl->right - prcl->left, prcl->bottom - prcl->top);

		//
		// After doing a restore we automatically do a free, So fall through to
		// SS_FREE.
		//
		LogSaveScreenBits(1, ppdev);

	case SS_FREE: // -----------------------------------------------------------
		Handle = (POFMHDL) ident;
		#if MEMMGR
		pofm = FindHandle(ppdev, Handle);
		#else
		for (pofm = ppdev->OFM_UsedQ; pofm; pofm = pofm->nexthdl)
		{
			if (Handle == pofm)
			{
				break;
			}
		}
		#endif
		if (pofm != NULL)
		{
			FreeOffScnMem(ppdev, Handle);
			LogSaveScreenBits(2, ppdev);
		}
		DISPDBG((SSB_DBG_LEVEL, "DrvSaveScreenBits - Exit\n", iMode));
        return(TRUE);

	} // end switch

	//
	// We shouldn't ever get here.
	//

	DISPDBG((SSB_DBG_LEVEL, "DrvSaveScreenBits - PANIC\n", iMode));
	RIP(("Panic! SaveScreenBits got an invalid command.\n"));
	LogSaveScreenBits(2, ppdev);
	return(FALSE);
}

#if LOG_CALLS
void LogSaveScreenBits(
	int 	  acc,
        PPDEV ppdev)
{
    char buf[256];
    int i;

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    i = sprintf(buf,"DrvSaveScreenBits: ");
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    switch(acc)
    {
	case 0: 
	    i = sprintf(buf, "SAVE (success)");
	    break;

	case 1: 
	    i = sprintf(buf,"RESTORE ");
	    break;

	case 2: 
	    i = sprintf(buf, "DELETE ");
	    break;

	case 3: 
	    i = sprintf(buf, "INVALID ");
	    break;

	case 9: 
	    i = sprintf(buf, "SAVE (fail) ");
	    break;

	default:
 	    i = sprintf(buf, "PUNT unknown ");
	    break;

    }
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);




    i = sprintf(buf,"\r\n");
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}


#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\stroke.c ===
/******************************Module*Header*******************************\
*
* $Workfile:   STROKE.C  $
*
* Handle DrvStrokePath routine.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1997 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/STROKE.C  $
*
*    Rev 1.17   Mar 04 1998 15:35:34   frido
* Added new shadow macros.
*
*    Rev 1.16   Nov 03 1997 10:20:44   frido
* Added REQUIRE macros.
*
\**************************************************************************/


#include "precomp.h"
#define STROKE_DBG_LEVEL 1

#if LOG_CALLS
    void LogStrokePath(
        ULONG     acc,
        PPDEV     ppdev,
        CLIPOBJ*   pco,
        BRUSHOBJ*  pbo,
        MIX        mix,
        LINEATTRS* pla,
        PATHOBJ*   ppo
        );
#else
    #define LogStrokePath(acc, ppdev, pco, pbo, mix, pla, ppo)
#endif

VOID (*gapfnStrip[])(PDEV*, STRIP*, LINESTATE*) = {
    vrlSolidHorizontal,
    vrlSolidVertical,
    NULL,
    NULL,

// Should be NUM_STRIP_DRAW_DIRECTIONS = 4 strip drawers in every group

    vrlSolidHorizontal,
    vrlSolidVertical,
    NULL,
    NULL,

// Should be NUM_STRIP_DRAW_STYLES = 8 strip drawers in total for doing
// solid lines, and the same number for non-solid lines:

    vStripStyledHorizontal,
    vStripStyledVertical,
    NULL,       // Diagonal goes here
    NULL,       // Diagonal goes here

    vStripStyledHorizontal,
    vStripStyledVertical,
    NULL,       // Diagonal goes here
    NULL,       // Diagonal goes here
};

// Style array for alternate style (alternates one pixel on, one pixel off):

STYLEPOS gaspAlternateStyle[] = { 1 };

extern BYTE Rop2ToRop3[];

USHORT mixToBLTDEF[] =
{
        0x1000,         //0  R2_WHITE 1
        0x1000,         //1  R2_BLACK 0
        0x1107,         //2  DPon
        0x1107,         //3  DPna
        0x1007,         //4  PN
        0x1107,         //5  PDna
        0x1100,         //6  Dn
        0x1107,         //7  DPx
        0x1107,         //8  DPan
        0x1107,         //9  DPa
        0x1107,         //A  DPxn
        0x1100,         //B  D
        0x1107,         //C  DPno
        0x1007,         //D  P
        0x1107,         //E  PDno
        0x1107,         //F  DPo
};


/******************************Public*Routine******************************\
* BOOL DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix)
*
* Strokes the path.
*
\**************************************************************************/
BOOL DrvStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    STYLEPOS  aspLtoR[STYLE_MAX_COUNT];
    STYLEPOS  aspRtoL[STYLE_MAX_COUNT];
    LINESTATE ls;
    PFNSTRIP* apfn;
    FLONG     fl;
    PDEV*     ppdev;
    RECTL     arclClip[4];                  // For rectangular clipping
    DWORD     color;

    #if NULL_STROKE
    {
        if (pointer_switch)     return(TRUE);
    }
    #endif

    DISPDBG((STROKE_DBG_LEVEL,"DrvStrokePath: Entry %x.\n", mix));
    ppdev = (PDEV*) pso->dhpdev;

    SYNC_W_3D(ppdev);

    if (pso->iType == STYPE_DEVBITMAP)
    {
        PDSURF pdsurf = (PDSURF) pso->dhsurf;
        if ( pdsurf->pso && !bCreateScreenFromDib(ppdev, pdsurf) )
        {
            LogStrokePath(4,ppdev, pco, pbo, mix, pla, ppo);
            return(EngStrokePath(pdsurf->pso, ppo, pco, pxo, pbo,
                                                 pptlBrush, pla, mix));
        }
        ppdev->ptlOffset = pdsurf->ptl;
    }
    else
    {
        ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;
    }
    // Convert to 3 OP ROP
    ppdev->uRop = Rop2ToRop3[mix & 0xF];
    ppdev->uBLTDEF = mixToBLTDEF[mix & 0x0F];

    //
    // Get the device ready:
    //
    ASSERTMSG(pbo,"Null brush in SrvStrokePath!\n");
    color = pbo->iSolidColor; // & 0x00000000FF; // Clear upper 24 bits.
    ASSERTMSG((color !=0xFFFFFFFF),"DrvStrokePath got a Pattern!\n");

    switch (ppdev->ulBitCount)
    {
        case 8: // For 8 bpp duplicate byte 0 into bytes 1,2,3.
            color =  (color << 8)  | (color & 0xFF);

        case 16: // For 16 bpp, duplicate the low word into the high word.
            color =  ((color << 16) | (color & 0xFFFF));

        default:
            break;
    }


    DISPDBG((STROKE_DBG_LEVEL,"DrvStrokePath: Set Color %x.\n", color));
    REQUIRE(2);
    LL_BGCOLOR(color, 2);

    fl = 0;

    // Check line style.
    if (pla->fl & LA_ALTERNATE)
    {
        ls.cStyle      = 1;
        ls.spTotal     = 1;
        ls.spTotal2    = 2;
        ls.spRemaining = 1;
        ls.aspRtoL     = &gaspAlternateStyle[0];
        ls.aspLtoR     = &gaspAlternateStyle[0];
        ls.spNext      = HIWORD(pla->elStyleState.l);
        ls.xyDensity   = 1;
        fl            |= FL_STYLED;
        ls.ulStartMask = 0L;
    }

    // Is it styled or solid?
    else if (pla->pstyle != (FLOAT_LONG*) NULL)
    {
        // Styled.

        PFLOAT_LONG pstyle;
        STYLEPOS*   pspDown;
        STYLEPOS*   pspUp;

        pstyle = &pla->pstyle[pla->cstyle];

        ls.xyDensity = STYLE_DENSITY;
        ls.spTotal   = 0;
        while (pstyle-- > pla->pstyle)
        {
            ls.spTotal += pstyle->l;
        }
        ls.spTotal *= STYLE_DENSITY;
        ls.spTotal2 = 2 * ls.spTotal;

        // Compute starting style position
        // (this is guaranteed not to overflow):

        ls.spNext = HIWORD(pla->elStyleState.l) * STYLE_DENSITY +
                    LOWORD(pla->elStyleState.l);

        fl        |= FL_STYLED;
        ls.cStyle  = pla->cstyle;
        ls.aspRtoL = aspRtoL;
        ls.aspLtoR = aspLtoR;

        if (pla->fl & LA_STARTGAP)
            ls.ulStartMask = 0xffffffffL;
        else
            ls.ulStartMask = 0L;

        pstyle  = pla->pstyle;
        pspDown = &ls.aspRtoL[ls.cStyle - 1];
        pspUp   = &ls.aspLtoR[0];

        while (pspDown >= &ls.aspRtoL[0])
        {
            *pspDown = pstyle->l * STYLE_DENSITY;
            *pspUp   = *pspDown;

            pspUp++;
            pspDown--;
            pstyle++;
        }
    }

    apfn = &gapfnStrip[NUM_STRIP_DRAW_STYLES *
                            ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];

    // Set up to enumerate the path:

    if (pco->iDComplexity != DC_COMPLEX)
    {
        PATHDATA  pd;
        RECTL*    prclClip = (RECTL*) NULL;
        BOOL      bMore;
        ULONG     cptfx;
        POINTFIX  ptfxStartFigure;
        POINTFIX  ptfxLast;
        POINTFIX* pptfxFirst;
        POINTFIX* pptfxBuf;

        if (pco->iDComplexity == DC_RECT)
        {
            fl |= FL_SIMPLE_CLIP;

            arclClip[0]        =  pco->rclBounds;

            // FL_FLIP_D:

            arclClip[1].top    =  pco->rclBounds.left;
            arclClip[1].left   =  pco->rclBounds.top;
            arclClip[1].bottom =  pco->rclBounds.right;
            arclClip[1].right  =  pco->rclBounds.bottom;

            // FL_FLIP_V:

            arclClip[2].top    = -pco->rclBounds.bottom + 1;
            arclClip[2].left   =  pco->rclBounds.left;
            arclClip[2].bottom = -pco->rclBounds.top + 1;
            arclClip[2].right  =  pco->rclBounds.right;

            // FL_FLIP_V | FL_FLIP_D:

            arclClip[3].top    =  pco->rclBounds.left;
            arclClip[3].left   = -pco->rclBounds.bottom + 1;
            arclClip[3].bottom =  pco->rclBounds.right;
            arclClip[3].right  = -pco->rclBounds.top + 1;

            prclClip = arclClip;
        } // End DC_RECT

        pd.flags = 0;

        do {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            cptfx = pd.count;
            if (cptfx == 0)
            {
                break;
            }

            if (pd.flags & PD_BEGINSUBPATH)
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                cptfx--;
            }
            else
            {
                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;
            }

            if (pd.flags & PD_RESETSTYLE)
                ls.spNext = 0;

            if (cptfx > 0)
            {
                if (!bLines(ppdev,
                            pptfxFirst,
                            pptfxBuf,
                            (RUN*) NULL,
                            cptfx,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                {
                    LogStrokePath(2, ppdev, pco, pbo, mix, pla, ppo);
                    return(FALSE);
                }
            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if (pd.flags & PD_CLOSEFIGURE)
            {
                if (!bLines(ppdev,
                            &ptfxLast,
                            &ptfxStartFigure,
                            (RUN*) NULL,
                            1,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                {
                    LogStrokePath(2, ppdev, pco, pbo, mix, pla, ppo);
                    return(FALSE);
                }
            }
        } while (bMore);

        if (fl & FL_STYLED)
        {
            // Save the style state:

            ULONG ulHigh;
            ULONG ulLow;

            // Masked styles don't normalize the style state.  It's a good
            // thing to do, so let's do it now:

            if ((ULONG) ls.spNext >= (ULONG) ls.spTotal2)
                ls.spNext = (ULONG) ls.spNext % (ULONG) ls.spTotal2;

            ulHigh = ls.spNext / ls.xyDensity;
            ulLow  = ls.spNext % ls.xyDensity;

            pla->elStyleState.l = MAKELONG(ulLow, ulHigh);
        }
    } // End non complex clipping.

    else // clipping is DC_COMPLEX
    {
        // Local state for path enumeration:

        BOOL bMore;
        union {
            BYTE     aj[offsetof(CLIPLINE, arun) + RUN_MAX * sizeof(RUN)];
            CLIPLINE cl;
        } cl;

        fl |= FL_COMPLEX_CLIP;

        // We use the clip object when non-simple clipping is involved:

        PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pla);

        do {
            bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(cl), &cl.cl);
            if (cl.cl.c != 0)
            {
                if (fl & FL_STYLED)
                {
                    ls.spComplex = HIWORD(cl.cl.lStyleState) * ls.xyDensity
                                 + LOWORD(cl.cl.lStyleState);
                }
                if (!bLines(ppdev,
                            &cl.cl.ptfxA,
                            &cl.cl.ptfxB,
                            &cl.cl.arun[0],
                            cl.cl.c,
                            &ls,
                            (RECTL*) NULL,
                            apfn,
                            fl))
                {
                    LogStrokePath(2, ppdev, pco, pbo, mix, pla, ppo);
                    return(FALSE);
                }
            }
        } while (bMore);
    }

    DISPDBG((STROKE_DBG_LEVEL,"DrvStrokePath: Exit.\n"));

    LogStrokePath(0, ppdev, pco, pbo, mix, pla, ppo);
    return(TRUE);
}


#if LOG_CALLS

extern long lg_i;
extern char lg_buf[256];

void LogStrokePath(
ULONG     acc,
PPDEV     ppdev,
CLIPOBJ*   pco,
BRUSHOBJ*  pbo,
MIX        mix,
LINEATTRS* pla,
PATHOBJ*   ppo
)
{
    BYTE iDComplexity;

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    lg_i = sprintf(lg_buf,"DSP: ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    // Did we realize it?  If not, why?
    switch (acc)
    {
        case  0: lg_i = sprintf(lg_buf,"(ACCL) ");                  break;
        case  2: lg_i = sprintf(lg_buf,"(Punt - bLines failed) ");  break;
        case  3: lg_i = sprintf(lg_buf,"(Punt - S3) ");             break;
        case  4: lg_i = sprintf(lg_buf,"(Punt - DevBmp on host) "); break;
        default: lg_i = sprintf(lg_buf,"(STATUS UNKNOWN) ");        break;
    }
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    //
    // Check the type of clipping.
    //
    iDComplexity = (pco ? pco->iDComplexity : DC_TRIVIAL);
    lg_i = sprintf(lg_buf,"C=%s ",
                (iDComplexity==DC_TRIVIAL ? "T":
                (iDComplexity == DC_RECT ? "R" : "C" )));
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    //
    // Check the brush
    //
    if (pbo)
      if (pbo->iSolidColor == 0xFFFFFFFF )
        lg_i = sprintf(lg_buf,"BR=P ");
      else
        lg_i = sprintf(lg_buf,"BR=0x%X ",(pbo->iSolidColor));
    else
        lg_i = sprintf(lg_buf,"BR=N ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    //
    // Check the MIX
    //
    lg_i = sprintf(lg_buf,"MIX = 0x%04X   ", mix);
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    //
    // Check the Line Attrs
    //
    if      (pla->fl & LA_GEOMETRIC)    lg_i = sprintf(lg_buf,"LA=G ");
    else if (pla->fl & LA_ALTERNATE)    lg_i = sprintf(lg_buf,"LA=A ");
    else if (pla->fl & LA_STARTGAP)     lg_i = sprintf(lg_buf,"LA=S ");
    else                                lg_i = sprintf(lg_buf,"LA=U ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    if      (pla->iJoin == JOIN_ROUND)  lg_i = sprintf(lg_buf,"J=R ");
    else if (pla->iJoin == JOIN_BEVEL)  lg_i = sprintf(lg_buf,"J=B ");
    else if (pla->iJoin == JOIN_MITER)  lg_i = sprintf(lg_buf,"J=M ");
    else                                lg_i = sprintf(lg_buf,"J=U ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    if      (pla->iEndCap == ENDCAP_ROUND)  lg_i = sprintf(lg_buf,"E=R ");
    else if (pla->iEndCap == ENDCAP_SQUARE) lg_i = sprintf(lg_buf,"E=S ");
    else if (pla->iEndCap == ENDCAP_BUTT)   lg_i = sprintf(lg_buf,"E=B ");
    else                                    lg_i = sprintf(lg_buf,"E=U ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    if (pla->pstyle == NULL)  lg_i = sprintf(lg_buf,"SOLID ");
    else                      lg_i = sprintf(lg_buf,"STYLED ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    lg_i = sprintf(lg_buf,"\r\n");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\sync.c ===
/****************************************************************************
*****************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:	Laguna I (CL-GD5462) - 
*
* FILE:		sync.c
*
* Initial AUTHOR:   Benny Ng
* Major re-write:   Noel VanHook
*
* DESCRIPTION:
*           This module contains the implementation of DrvSynchronize()
*           routine.
*
* MODULES:
*           DrvSynchronize()
*
* REVISION HISTORY:
*   7/06/95     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/sync.c  $
* 
*    Rev 1.13   22 Apr 1997 11:06:36   noelv
* Removed frame buffer cache invalidate since FB cache is disabled.
* 
*    Rev 1.12   09 Apr 1997 10:50:06   SueS
* Changed sw_test_flag to pointer_switch.
* 
*    Rev 1.11   08 Apr 1997 12:32:00   einkauf
* 
* add SYNC_W_3D to coordinate MCD/2D hw access
* 
*    Rev 1.10   04 Feb 1997 13:52:36   noelv
* Fixed typo.
* 
*    Rev 1.9   04 Feb 1997 10:50:56   noelv
* Added workaround for 5465 direct frame buffer readback bug.
* 
*    Rev 1.8   26 Nov 1996 10:45:48   SueS
* Changed WriteLogFile parameters for buffering.
* 
*    Rev 1.7   13 Nov 1996 17:05:34   SueS
* Changed WriteFile calls to WriteLogFile.
* 
*    Rev 1.6   20 Aug 1996 11:04:32   noelv
* Bugfix release from Frido 8-19-96
* 
*    Rev 1.1   15 Aug 1996 11:39:20   frido
* Added precompiled header.
* 
*    Rev 1.0   14 Aug 1996 17:16:32   frido
* Initial revision.
* 
*    Rev 1.5   07 Aug 1996 08:30:56   noelv
* added comments
* 
*    Rev 1.4   20 Mar 1996 16:09:44   noelv
* 
* Updated data logging
* 
*    Rev 1.3   05 Mar 1996 11:59:18   noelv
* Frido version 19
 * 
 *    Rev 1.1   20 Jan 1996 01:11:38   frido
* 
*    Rev 1.6   15 Jan 1996 17:01:34   NOELV
* 
*    Rev 1.5   12 Jan 1996 10:54:30   NOELV
* Totally re-written.
* 
*    Rev 1.4   22 Sep 1995 10:24:58   NOELV
* Re-aranged the order of the tests.
* 
*    Rev 1.1   19 Sep 1995 16:31:02   NOELV
* Ported to rev AB.
* 
*    Rev 1.0   25 Jul 1995 11:23:22   NOELV
* Initial revision.
* 
*    Rev 1.1   07 Jul 1995 10:37:22   BENNYN
* Initial version
* 
*    Rev 1.0   06 Jul 1995 14:55:48   BENNYN
* Initial revision.
*
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"

/*----------------------------- DEFINES -----------------------------------*/
#define DBGDISP

#define  MAX_CNT           0x7FFFFF

#define  BLT_RDY_BIT       0x1L
#define  BLT_FLAG_BIT      0x2L
#define  WF_EMPTY_BIT      0x4L

#define  BITS_CHK          (BLT_RDY_BIT | BLT_FLAG_BIT | WF_EMPTY_BIT)
#define  ENGINE_IDLE        0

#define  SYNC_DBG_LEVEL     0

//
// If data logging is enabled, Prototype the logging files.
//
#if LOG_CALLS
    void LogSync(
        int     acc,
        PPDEV   ppdev,
        int     count);

//
// If data logging is not enabled, compile out the calls.
//
#else
    #define LogSync(acc, ppdev, count)
#endif



/****************************************************************************
* FUNCTION NAME: DrvSynchronize()
*
* REVISION HISTORY:
*   7/06/95     Benny Ng      Initial version
****************************************************************************/
VOID DrvSynchronize(DHPDEV dhpdev,
                    RECTL  *prcl)
{

    PPDEV ppdev = (PPDEV) dhpdev;

    SYNC_W_3D(ppdev);

    //
    // NOTE:  We also call this function from within the driver.
    // When we do, we don't bother to set prcl.  If you need to use
    // prcl here, you need to find where we call DrvSynchronize, and
    // set prcl to a real value.
    //


    //
    // Make the first chip test as fast as possible.  If the chip
    // is already idle, we want to return to NT as fast as possible.
    //
    if ( LLDR_SZ (grSTATUS) == ENGINE_IDLE)
    {
        LogSync(0, ppdev, 0);
    }

    //
    // Alright, the chip isn't idle yet.  
    // Go into a wait loop.
    //
    else
    {
        ULONG ultmp;
        LONG delaycnt = 1;

        while (1)
        {
            ultmp = LLDR_SZ (grSTATUS);
     
            if ((ultmp & BITS_CHK) == ENGINE_IDLE)
            {
                LogSync(0, ppdev, delaycnt);
                break;
            }

            if (delaycnt++ >= MAX_CNT)
            {
                //
                // The chip never went idle.  This most likely means the chip
                // is totally dead.  In a checked build we will halt with a
                // debug message.
                // In a free build we will return to NT and hope for the best.
                //

                LogSync(1, ppdev, 0);
                RIP("Chip failed to go idle in DrvSynchronize!\n");
                break;
            }
        }
    }

    //
    // We can skp this 'cause frame buffer caching is broken.
    //
    #if 0 
    #if DRIVER_5465
    {
        //
        // The 5465 Rev AA and Rev AB have a bug.
        // We must invalidate the frame buffer cache before direct 
        // frame buffer accesses will work correctly.
        // We do this with two DWORD reads of the frame buffer, 
        // 8 QWORDS apart.
        //
   
        DWORD temp;

        temp = * ((volatile DWORD *) (ppdev->pjScreen));
        temp = * ((volatile DWORD *) (ppdev->pjScreen+64));
        
    }
    #endif
    #endif

    return;
}

// meant to be called only from .asm routines - .c routines use SYNC_W_3D macro
VOID Sync_w_3d_proc(PPDEV ppdev)
{
    SYNC_W_3D(ppdev);
}


#if LOG_CALLS
// ============================================================================
//
//    Everything from here down is for data logging and is not used in the 
//    production driver.
//
// ============================================================================


// ****************************************************************************
//
// LogPaint()
// This routine is called only from DrvPaint()
// Dump information to a file about what is going on in DrvPaint land.
//
// ****************************************************************************
void LogSync(
	int   acc,
        PPDEV ppdev,
        int   count)
{
    char buf[256];
    int i;

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    i = sprintf(buf,"DrvSync: ");
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    switch(acc)
    {
	case 0: // Accelerated
	    i = sprintf(buf,"Wait %d Idle ",count);
	    break;

	case 1: // Punted
	    i = sprintf(buf, "Never idle ");
	    break;

	default:
 	    i = sprintf(buf, "PUNT unknown ");
	    break;

    }
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    i = sprintf(buf,"\r\n");
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\strips.c ===
/******************************Module*Header*******************************\
* Module Name: Strips.c
*
* All the line code in this driver amounts to a big bag of dirt.  Someday,
* I'm going to rewrite it all.  Not today, though (sigh)...
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
* $Workfile:   STRIPS.C  $
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/STRIPS.C  $
*
*    Rev 1.4   Mar 04 1998 15:35:14   frido
* Added new shadow macros.
*
*    Rev 1.3   Nov 03 1997 10:50:06   frido
* Added REQUIRE macros.
*
*    Rev 1.2   20 Aug 1996 11:04:28   noelv
* Bugfix release from Frido 8-19-96
*
*    Rev 1.0   14 Aug 1996 17:16:32   frido
* Initial revision.
*
*    Rev 1.1   28 Mar 1996 08:58:40   noelv
* Frido bug fix release 22
 *
 *    Rev 1.1   27 Mar 1996 13:57:28   frido
 * Fixed line drawing.
*
\**************************************************************************/

#include "precomp.h"

#define STARTBLT()

/******************************Public*Routine******************************\
* VOID vrlSolidHorizontal
*
* Draws left-to-right x-major near-horizontal lines using radial lines.
*
\**************************************************************************/

VOID vrlSolidHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    LONG  cStrips;
    LONG  i, yDir, x, y;
    PLONG pStrips;
        LONG  xPels;

    cStrips = pStrip->cStrips;
        pStrips = pStrip->alStrips;

        // Get the starting coordinates and adjust for device bitmaps.
    x = pStrip->ptlStart.x + ppdev->ptlOffset.x;
    y = pStrip->ptlStart.y + ppdev->ptlOffset.y;

        // Determine y-direction.
    if (pStrip->flFlips & FL_FLIP_V)
        {
                yDir = -1;
                ppdev->uBLTDEF |= BD_YDIR;
        }
        else
        {
                yDir = 1;
                ppdev->uBLTDEF &= ~BD_YDIR;
        }

        // Start the BitBlt.
    STARTBLT();

    // Here is where we will setup DrawDef and BlitDef
        REQUIRE(2);
        LL_DRAWBLTDEF((ppdev->uBLTDEF << 16) | ppdev->uRop, 2);

        // Loop through all the strips.
    for (i = 0; i < cStrips; i++)
    {
                // Get the width of this stripe.
                xPels = *pStrips++;

                // Draw it.
                REQUIRE(5);
                LL_OP0(x, y);
                LL_BLTEXT(xPels, 1);

                // Advance to next strip.
                x += xPels;
        y += yDir;
    }

        // Store the current coordinates back.
    pStrip->ptlStart.x = x - ppdev->ptlOffset.x;
    pStrip->ptlStart.y = y - ppdev->ptlOffset.y;
}

/******************************Public*Routine******************************\
* VOID vrlSolidVertical
*
* Draws left-to-right y-major near-vertical lines using radial lines.
*
\**************************************************************************/

VOID vrlSolidVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    LONG  cStrips;
    LONG  i, x, y, yDir;
    PLONG pStrips;
        LONG  yPels;

    cStrips = pStrip->cStrips;
    pStrips = pStrip->alStrips;

        // Get the starting coordinates and adjust for device bitmaps.
    x = pStrip->ptlStart.x + ppdev->ptlOffset.x;
    y = pStrip->ptlStart.y + ppdev->ptlOffset.y;

        // Determine y-direction.
        if (pStrip->flFlips & FL_FLIP_V)
        {
                ppdev->uBLTDEF |= BD_YDIR;
                yDir = -1;
        }
        else
        {
                yDir = 1;
                ppdev->uBLTDEF &= ~BD_YDIR;
        }

        // Start the BitBlt.
    STARTBLT();

    // Here is where we will setup DrawDef and BlitDef
        REQUIRE(2);
        LL_DRAWBLTDEF((ppdev->uBLTDEF << 16) | ppdev->uRop, 2);

        // Loop through all the strips.
    for (i = 0; i < cStrips; i++)
        {
                // Get the height of this stripe.
                yPels = *pStrips++;

                // Draw it.
                REQUIRE(5);
                LL_OP0(x, y);
                LL_BLTEXT(1, yPels);

                // Advance to next strip.
                x++;
                y += yDir * yPels;
        }

        // Store the current coordinates back.
    pStrip->ptlStart.x = x - ppdev->ptlOffset.x;
    pStrip->ptlStart.y = y - ppdev->ptlOffset.y;
}


/******************************Public*Routine******************************\
* VOID vStripStyledHorizontal
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles x-major lines that run left-to-right,
* and are comprised of horizontal strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vStripStyledHorizontal(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    LONG  x, y, dy;
    PLONG plStrip;
    LONG  cStrips;
    LONG  cStyle;
    LONG  cStrip;
    LONG  cThis;
    ULONG bIsGap;

        // Determine y-direction.
        if (pstrip->flFlips & FL_FLIP_V)
        {
                dy = -1;
                ppdev->uBLTDEF |= BD_YDIR;
        }
        else
        {
                ppdev->uBLTDEF &= ~BD_YDIR;
                dy = 1;
        }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip

        // Get the starting coordinates and adjust for device bitmaps.
    x = pstrip->ptlStart.x + ppdev->ptlOffset.x;
    y = pstrip->ptlStart.y + ppdev->ptlOffset.y;

        // Start the BitBlt.
    STARTBLT();

    // Here is where we will setup DrawDef and BlitDef.
    REQUIRE(2);
    LL_DRAWBLTDEF((ppdev->uBLTDEF << 16) | ppdev->uRop, 2);

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
                goto OutputADash;
    }

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

                // Draw the stripe.
                REQUIRE(5);
                LL_OP0(x, y);
                LL_BLTEXT(cThis, 1);

                x += cThis;

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x - ppdev->ptlOffset.x;
    pstrip->ptlStart.y = y - ppdev->ptlOffset.y;
}

/******************************Public*Routine******************************\
* VOID vStripStyledVertical
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles y-major lines that run left-to-right,
* and are comprised of vertical strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vStripStyledVertical(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    LONG  x, y, dy;
    PLONG plStrip;
    LONG  cStrips;
    LONG  cStyle;
    LONG  cStrip;
    LONG  cThis;
    ULONG bIsGap;

        // Determine the y-direction.
    if (pstrip->flFlips & FL_FLIP_V)
        {
                dy = -1;
                ppdev->uBLTDEF |= BD_YDIR;
        }
        else
        {
                dy = 1;
                ppdev->uBLTDEF &= ~BD_YDIR;
        }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip

        // Get the starting coordinates and adjust for device bitmaps.
    x = pstrip->ptlStart.x + ppdev->ptlOffset.x;
    y = pstrip->ptlStart.y + ppdev->ptlOffset.y;

        // Start the BitBlt.
    STARTBLT();

    // Here is where we will setup DrawDef and BlitDef.
    REQUIRE(2);
    LL_DRAWBLTDEF((ppdev->uBLTDEF << 16) | ppdev->uRop, 2);

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        y += (dy > 0) ? cThis : -cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        goto OutputADash;
    }

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

                // Draw the stripe.
                REQUIRE(5);
                LL_OP0(x, y);
                LL_BLTEXT(1, cThis);

                y += dy * cThis;

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x - ppdev->ptlOffset.x;
    pstrip->ptlStart.y = y - ppdev->ptlOffset.y;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\texparm.c ===
/******************************Module*Header*******************************\
*
* Module Name: texparm.c
* Author: Goran Devic, Mark Einkauf
* Purpose: Texture memory management and parameterization for perspective textures
*                                                                       
* Copyright (c) 1997 Cirrus Logic, Inc.
*
\**************************************************************************/

/******************************************************************************
*   Include Files
******************************************************************************/

#include "precomp.h"

#include <excpt.h>
#include <stdlib.h>                 /* Include standard library              */
#include <stdio.h>                  /* Include standard input/output         */
#include <math.h>                   /* Include math module                   */

#include "mcdhw.h"
#include "mcdutil.h"
#include "mcdmath.h"

#if 1   // 1 here to avoid tons of prints for each texture load
#define MCDBG_PRINT_TEX
#else
#define MCDBG_PRINT_TEX MCDBG_PRINT
#endif

#define DEBUG_CONDITION  DEBUG_TEX
#include "debug.h"                  /* Include debug support         */

/******************************************************************************
*   Local Variables and Defines
******************************************************************************/

#define F_NEG(var)   (*(unsigned *)&var ^= 0x80000000)


// convert from float to 16.16 long
#define fix_ieee( val )     FTOL((val) * (float)65536.0)

// convert from float to 8.24 long
#define fix824_ieee( val )  FTOL((val) * (float)16777216.0)

typedef struct {
    float   a1, a2;
    float   b1, b2;
} QUADRATIC;



typedef float * (WINAPI *CONVERT_TEXEL_FUNC)();

__inline float *luminance_texel(float *pSrc, MCDMIPMAPLEVEL *level, RGBQUAD *texel_rgba )
{
    // Single float used as R,G,B
    texel_rgba->rgbRed  = 
    texel_rgba->rgbGreen= 
//  texel_rgba->rgbBlue = (UCHAR)(*pSrc++ * ((1<<level->luminanceSize)  - 1));
    texel_rgba->rgbBlue = (UCHAR)(*pSrc++ * (float)255.0);

    return(pSrc);
}

// same as above, except texel = 1-color instead of color
__inline float *n_luminance_texel(float *pSrc, MCDMIPMAPLEVEL *level, RGBQUAD *texel_rgba )
{
    // Single float used as R,G,B
    texel_rgba->rgbRed  = 
    texel_rgba->rgbGreen= 
//  texel_rgba->rgbBlue = (UCHAR)(((float)1.0 - *pSrc++) * ((1<<level->luminanceSize)  - 1));
    texel_rgba->rgbBlue = (UCHAR)(((float)1.0 - *pSrc++) * (float)255.0);

    return(pSrc);
}


__inline float *luminance_alpha_texel(float *pSrc, MCDMIPMAPLEVEL *level, RGBQUAD *texel_rgba )
{
    // MCD_NOTE: For case of LUMINANCE_ALPHA, final alpha supposed to be Atexture*Afragment - 5465
    // MCD_NOTE:    can't do this, so we'll punt if blend on and LUMINANCE_ALPHA texture
    // MCD_NOTE:    This code left for completeness in case hardware support added

    // 1st float used as R,G,B
    texel_rgba->rgbRed  = 
    texel_rgba->rgbGreen= 
//  texel_rgba->rgbBlue = (UCHAR)(*pSrc++ * ((1<<level->luminanceSize)  - 1));
    texel_rgba->rgbBlue = (UCHAR)(*pSrc++ * (float)255.0);

    // 2nd float is alpha
//  texel_rgba->rgbReserved  = (UCHAR)(*pSrc++ * ((1<<level->alphaSize)  - 1));
    texel_rgba->rgbReserved  = (UCHAR)(*pSrc++ * (float)255.0);

    return(pSrc);
}

// same as above, except texel = 1-color instead of color
__inline float *n_luminance_alpha_texel(float *pSrc, MCDMIPMAPLEVEL *level, RGBQUAD *texel_rgba )
{
    // MCD_NOTE: For case of LUMINANCE_ALPHA, final alpha supposed to be Atexture*Afragment - 5465
    // MCD_NOTE:    can't do this, so we'll punt if blend on and LUMINANCE_ALPHA texture
    // MCD_NOTE:    This code left for completeness in case hardware support added

    // 1st float used as R,G,B
    texel_rgba->rgbRed  = 
    texel_rgba->rgbGreen= 
//  texel_rgba->rgbBlue = (UCHAR)(((float)1.0 - *pSrc++) * ((1<<level->luminanceSize)  - 1));
    texel_rgba->rgbBlue = (UCHAR)(((float)1.0 - *pSrc++) * (float)255.0);

    // 2nd float is alpha
//  texel_rgba->rgbReserved  = (UCHAR)(((float)1.0 - *pSrc++) * ((1<<level->alphaSize)  - 1));
    texel_rgba->rgbReserved  = (UCHAR)(((float)1.0 - *pSrc++) * (float)255.0);

    return(pSrc);
}



__inline float *luminance_blend_texel(float *pSrc, MCDMIPMAPLEVEL *level, RGBQUAD *texel_rgba )
{
    // RGB is from Texture Environment and is set by caller - 
    // A is Luminance value in texture
    texel_rgba->rgbReserved  = (UCHAR)(*pSrc++ * ((1<<level->luminanceSize)  - 1));

    return(pSrc);
}

__inline float *luminance_alpha_blend_texel(float *pSrc, MCDMIPMAPLEVEL *level, RGBQUAD *texel_rgba )
{
    // RGB is from Texture Environment and is set by caller - so ignore texel value
    pSrc++;
    // A is Luminance value in texture
    texel_rgba->rgbReserved  = (UCHAR)(*pSrc++ * ((1<<level->luminanceSize)  - 1));

    return(pSrc);
}



__inline float *alpha_texel(float *pSrc, MCDMIPMAPLEVEL *level, RGBQUAD *texel_rgba )
{
    // RGB set by caller
    // Single float used as Alpha
    texel_rgba->rgbReserved  = (UCHAR)(*pSrc++ * ((1<<level->alphaSize)  - 1));

    return(pSrc);
}

__inline float *rgb_texel(float *pSrc, MCDMIPMAPLEVEL *level, RGBQUAD *texel_rgba )
{
    // 1st float used is R
    texel_rgba->rgbRed  = (UCHAR)(*pSrc++ * ((1<<level->redSize)  - 1));
    // 2nd float used is G
    texel_rgba->rgbGreen= (UCHAR)(*pSrc++ * ((1<<level->greenSize)- 1));
    // 3rd float used is B
    texel_rgba->rgbBlue = (UCHAR)(*pSrc++ * ((1<<level->blueSize) - 1));

    return(pSrc);
}

__inline float *rgba_texel(float *pSrc, MCDMIPMAPLEVEL *level, RGBQUAD *texel_rgba )
{
    // 1st float used is R
    texel_rgba->rgbRed  = (UCHAR)(*pSrc++ * ((1<<level->redSize)  - 1));
    // 2nd float used is G
    texel_rgba->rgbGreen= (UCHAR)(*pSrc++ * ((1<<level->greenSize)- 1));
    // 3rd float used is B
    texel_rgba->rgbBlue = (UCHAR)(*pSrc++ * ((1<<level->blueSize) - 1));
    // 4th float is alpha
    texel_rgba->rgbReserved  = (UCHAR)(*pSrc++ * ((1<<level->alphaSize)  - 1));

    return(pSrc);
}

__inline float *intensity_texel(float *pSrc, MCDMIPMAPLEVEL *level, RGBQUAD *texel_rgba )
{
    // Single float used as R,G,B,A
    texel_rgba->rgbReserved = 
    texel_rgba->rgbRed      = 
    texel_rgba->rgbGreen    = 
    texel_rgba->rgbBlue     = (UCHAR)(*pSrc++ * ((1<<level->intensitySize)  - 1));

    return(pSrc);
}

ULONG __MCDLoadTexture(PDEV *ppdev, DEVRC *pRc)

{
    LL_Texture     *pTexCtlBlk = pRc->pLastTexture;
    POFMHDL         pohTextureMap = NULL;
    MCDTEXTURE     *pTex = pTexCtlBlk->pTex;
    MCDMIPMAPLEVEL *level;
    SIZEL           mapsize;
    UCHAR          *pDest;
    int             rowlength,row,col;
    ULONG           alignflag;
    int             rshift, gshift, bshift, ashift, rpos, gpos, bpos, apos;


    VERIFY_TEXTUREDATA_ACCESSIBLE(pTex);
    VERIFY_TEXTURELEVEL_ACCESSIBLE(pTex);
    level = pTex->pMCDTextureData->level;

    mapsize.cx = (int)pTexCtlBlk->fWidth;
    mapsize.cy = (int)pTexCtlBlk->fHeight;

    // FUTURE: MUST ADD EngProbeForRead, EngSecureMem/EngUnsecureMem for MIPMAPLEVEL access            
    MCDFREE_PRINT("  __MCDLoadTexture, size = %x by %x, mask=%x, neg=%x", 
        mapsize.cx, mapsize.cy, pTexCtlBlk->bMasking, pTexCtlBlk->bNegativeMap);

    if ((level[0].internalFormat == GL_BGR_EXT) ||
        (level[0].internalFormat == GL_BGRA_EXT))
    {

        if (pRc->MCDTexEnvState.texEnvMode==GL_BLEND)
        {
            MCDBG_PRINT_TEX("  TexEnvMode=GL_BLEND, w/ RGB/RGBA texture - load fails");
            return FALSE;
        }   

    // FUTURE: large 32 bit textures have trouble fitting in 4M board since 512 X 32bitpp
    // FUTURE: requires pitch of 2048.  2048 pitch only happens at hi-res, such as
    // FUTURE: 1024x786 at 16bpp.  However, catch-22, since at hi-res, no room for 
    // FUTURE: backbuf+zbuf+large texture (may work on 8Meg board???)
    // FUTURE: THEREFORE, will reformat 32bit texture to match screen format

//#define SUPPORT_32BIT_TEXTURES_ASIS --WARNING-> this path doesn't work for alphatest(mask) - 
                                                //should add if() to uses "non-ASIS" path if masking

#ifdef SUPPORT_32BIT_TEXTURES_ASIS
        // if GL_BGR_EXT or GL_BGRA_EXT internalFormat, use 8888 texel mode and copy as is in
        //    32bit quantities (x86 byte reversal converts BGRA to ARGB, which is what L3d needs)
        UCHAR *pSrc;

    #if DRIVER_5465
        pTexCtlBlk->bType = LL_TEX_8888;
    #else            
        pTexCtlBlk->bType = LL_TEX_1888;
    #endif

        alignflag = MCD_TEXTURE32_ALLOCATE;

        pohTextureMap = ppdev->pAllocOffScnMem(ppdev, &mapsize, alignflag, NULL);

        // if alloc failed - try to recover
        if (!pohTextureMap)
        {
            pohTextureMap = __MCDForceTexture(ppdev, &mapsize, alignflag, pTexCtlBlk->fLastDrvDraw);
        }

        pTexCtlBlk->pohTextureMap = pohTextureMap;
                                    
        if (!pohTextureMap)
        {
            MCDBG_PRINT_TEX("  Load texture failed ");
            pTexCtlBlk->wXloc = 0;  // set to 0 - have seen keys from deleted textures used in error
            pTexCtlBlk->wYloc = 0;  //      - have sent question about this to Microsoft (3/29/97)
            return FALSE;
        }
        else
        {
            // alloc of off screen memory worked - key is ptr to control block
            pTexCtlBlk->wXloc = (WORD)pohTextureMap->aligned_x;
            pTexCtlBlk->wYloc = (WORD)pohTextureMap->aligned_y;
        }

        // if we make it this far, texture allocation was successful,
        // copy texture to video memory
        
        pDest  = ppdev->pjScreen + 
                 (pohTextureMap->aligned_y * ppdev->lDeltaScreen) + 
                 pohTextureMap->aligned_x;

        pSrc   = level[0].pTexels;

        rowlength = level[0].widthImage << 2;   // num bytes per row of map

        // texture is 4 bytes per texel
        VERIFY_TEXELS_ACCESSIBLE(pSrc,level[0].heightImage*rowlength,ENGPROBE_ALIGN_DWORD);

        // MCD_PERF - CONVERT memcpy of texture TO A BLIT
        for (row=0; row<level[0].heightImage; row++) 
        {  
            memcpy (pDest,pSrc,rowlength); 
        
            pDest += ppdev->lDeltaScreen;
            pSrc += rowlength;
        }

#else // ifdef SUPPORT_32BIT_TEXTURES_ASIS

        // alloc block with same color format as screen
        switch (ppdev->iBitmapFormat) 
        {
            case BMF_8BPP:
                if ( pTexCtlBlk->bAlphaInTexture )
                    // need alpha in texture                    
                    alignflag = MCD_TEXTURE16_ALLOCATE;
                else
                    alignflag = MCD_TEXTURE8_ALLOCATE;
                break;
            case BMF_16BPP:
                alignflag = MCD_TEXTURE16_ALLOCATE;
                break;
            case BMF_24BPP:     
            case BMF_32BPP:
                alignflag = MCD_TEXTURE32_ALLOCATE;
                break;
        }

        pohTextureMap = ppdev->pAllocOffScnMem(ppdev, &mapsize, alignflag, NULL);

        // if alloc failed - try to recover
        if (!pohTextureMap)
        {
            pohTextureMap = __MCDForceTexture(ppdev, &mapsize, alignflag, pTexCtlBlk->fLastDrvDraw);
        }
                           
        pTexCtlBlk->pohTextureMap = pohTextureMap;
                                    
        if (!pohTextureMap)
        {
            MCDBG_PRINT_TEX("  Load texture failed ");
            pTexCtlBlk->wXloc = 0;  // set to 0 - have seen keys from deleted textures used in error
            pTexCtlBlk->wYloc = 0;  //      - have sent question about this to Microsoft
            return FALSE;
        }
        else
        {
            // alloc of off screen memory worked
            pTexCtlBlk->wXloc = (WORD)pohTextureMap->aligned_x;
            pTexCtlBlk->wYloc = (WORD)pohTextureMap->aligned_y;
        }

        // if we make it this far, texture allocation was successful,
        // copy texture to video memory
        pDest  = ppdev->pjScreen + 
                 (pohTextureMap->aligned_y * ppdev->lDeltaScreen) +
                 pohTextureMap->aligned_x;
                
        {
        RGBQUAD *pSrc = (RGBQUAD *)level[0].pTexels;

        // texture is 4 bytes per texel
        VERIFY_TEXELS_ACCESSIBLE(pSrc,level[0].heightImage*level[0].widthImage*4,ENGPROBE_ALIGN_DWORD);

        switch (alignflag) 
            {
            case MCD_TEXTURE8_ALLOCATE:
                pTexCtlBlk->bType = LL_TEX_332;
                for (row=0; row<level[0].heightImage; row++) 
                {  
                    for (col=0; col<level[0].widthImage; col++)
                    {
                        // convert from 888 to 332
                        *(pDest + col) = 
                            ((pSrc->rgbRed   >> 5) << 5) |
                            ((pSrc->rgbGreen >> 5) << 2) |
                             (pSrc->rgbBlue  >> 6);
                        pSrc++;
                    }
                
                    pDest += ppdev->lDeltaScreen;
                }
                break;
            case MCD_TEXTURE16_ALLOCATE:

                if ( pTexCtlBlk->bAlphaInTexture )
                {
                    if (pTexCtlBlk->bMasking)
                    {
                        pTexCtlBlk->bType = LL_TEX_1555;
                        ashift = 7; apos = 15;  // 1 bits alp, at bits 15->12
                        rshift = 3; rpos = 10;  // 5 bits red, at bits 11->8
                        gshift = 3; gpos =  5;  // 5 bits grn, at bits  7->4
                        bshift = 3;             // 5 bits blu, at bits  3->0
                    }
                    else
                    {
                    #if DRIVER_5465                 
                        pTexCtlBlk->bType = LL_TEX_4444;
                        ashift = 4; apos = 12;  // 4 bits alp, at bits 15->12
                        rshift = 4; rpos =  8;  // 4 bits red, at bits 11->8
                        gshift = 4; gpos =  4;  // 4 bits grn, at bits  7->4
                        bshift = 4;             // 4 bits blu, at bits  3->0
                    #else // DRIVER_5465
                        // 5464 has no 4444 support
                        pTexCtlBlk->bType = LL_TEX_1555;
                        ashift = 7; apos = 15;  // 1 bits alp, at bits 15->12
                        rshift = 3; rpos = 10;  // 5 bits red, at bits 11->8
                        gshift = 3; gpos =  5;  // 5 bits grn, at bits  7->4
                        bshift = 3;             // 5 bits blu, at bits  3->0
                    #endif // DRIVER_5465
                    }
                }                              
                else                        
                {
                    pTexCtlBlk->bType = LL_TEX_565;
                    ashift = 8; apos = 16;  // removes alpha altogether
                    rshift = 3; rpos = 11;  // 5 bits red, at bits 15->11
                    gshift = 2; gpos = 5;   // 6 bits grn, at bits 10->5
                    bshift = 3;             // 5 bits blu, at bits  4->0
                }

                for (row=0; row<level[0].heightImage; row++) 
                {  
                    if (!pTexCtlBlk->bMasking)
                    {
                        for (col=0; col<level[0].widthImage; col++)
                        {
                            // convert from 8888 to 4444 or 565
                            *(USHORT *)(pDest + (col*2)) = 
                                ((pSrc->rgbReserved >> ashift) << apos) |
                                ((pSrc->rgbRed      >> rshift) << rpos) |
                                ((pSrc->rgbGreen    >> gshift) << gpos)  |
                                 (pSrc->rgbBlue     >> bshift);

                            pSrc++;

                        }
                   }
                   else
                   {
                        for (col=0; col<level[0].widthImage; col++)
                        {
                            // convert from 8888 to 1555
                            
                            *(USHORT *)(pDest + (col*2)) = 
                                ((pSrc->rgbRed      >> rshift) << rpos) |
                                ((pSrc->rgbGreen    >> gshift) << gpos)  |
                                 (pSrc->rgbBlue     >> bshift);

                            // turn on mask bit (bit 15) if alpha > ref
                            if (pSrc->rgbReserved > pRc->bAlphaTestRef)
                                *(USHORT *)(pDest + (col*2)) |= 0x8000;

                            pSrc++;

                        }
                    }
                
                    pDest += ppdev->lDeltaScreen;
                }
                break;
            case MCD_TEXTURE32_ALLOCATE:
    #if DRIVER_5465
                if (!pTexCtlBlk->bMasking)
                    pTexCtlBlk->bType = LL_TEX_8888;
                else
                    pTexCtlBlk->bType = LL_TEX_1888;
    #else  // DRIVER_5465
                pTexCtlBlk->bType = LL_TEX_1888;
    #endif // DRIVER_5465

                rowlength = level[0].widthImage << 2;   // num bytes per row of map
                if (!pTexCtlBlk->bMasking)
                {
                    for (row=0; row<level[0].heightImage; row++) 
                    {  
                        // copy the RGBQUAD as is, a whole row at a time
                        memcpy (pDest,pSrc,rowlength); 
                    
                        pDest += ppdev->lDeltaScreen;
                        pSrc += level[0].widthImage;    // remember pSrc is RGBQUAD*, not UCHAR*
                    }
                }
                else
                {
                    // masking on - set bit31 of texel according to alpha test
                    for (row=0; row<level[0].heightImage; row++) 
                    {  
                        // copy the RGBQUAD as is, a whole row at a time
                        memcpy (pDest,pSrc,rowlength); 
                            
                        for (col=0; col<level[0].widthImage; col++)
                        {
                            // revisit the row, turning on mask bit (bit 31) if alpha > ref
                            if ((pSrc+col)->rgbReserved > pRc->bAlphaTestRef)
                                *(ULONG *)(pDest + (col*4)) |= 0x80000000;
                        }

                        pDest += ppdev->lDeltaScreen;
                        pSrc += level[0].widthImage;    // remember pSrc is RGBQUAD*, not UCHAR*
                    }
                }

                break;
            } // endswitch
        } // endblock

#endif // ifdef SUPPORT_32BIT_TEXTURES_ASIS

    }
    else 
    {
        // if internalFormat not GL_BGR_EXT or GL_BGRA_EXT , we'll convert to screen's format
        // (see note below on FUTURE plans to use indexed textures without conversion)


        if ( (pRc->MCDTexEnvState.texEnvMode==GL_BLEND) &&
                (level[0].internalFormat != GL_LUMINANCE) &&
                (level[0].internalFormat != GL_LUMINANCE_ALPHA) &&
                (level[0].internalFormat != GL_INTENSITY) )

        {
            MCDBG_PRINT_TEX("  TexEnvMode=GL_BLEND, w/ non LUM or INTENSITY texture - load fails");
            return FALSE;
        }   

        if (pRc->MCDTexEnvState.texEnvMode==GL_BLEND)
        {
            // alpha only in texture - recall we've punted if not luminance or intensity
            alignflag = MCD_TEXTURE8_ALLOCATE;
        }
        else
        {
            // alloc block with same color format as screen
            switch (ppdev->iBitmapFormat) 
            {
                case BMF_8BPP:
                    if ( pTexCtlBlk->bAlphaInTexture )
                        // need alpha in texture                    
                        alignflag = MCD_TEXTURE16_ALLOCATE;
                    else
                        alignflag = MCD_TEXTURE8_ALLOCATE;
                    break;
                case BMF_16BPP:
                    alignflag = MCD_TEXTURE16_ALLOCATE;
                    break;
                case BMF_24BPP:     
                case BMF_32BPP:
                    alignflag = MCD_TEXTURE32_ALLOCATE;
                    break;
                
            }
          }  

        pohTextureMap = ppdev->pAllocOffScnMem(ppdev, &mapsize, alignflag, NULL);
        
        // if alloc failed - try to recover
        if (!pohTextureMap)
        {
            pohTextureMap = __MCDForceTexture(ppdev, &mapsize, alignflag, pTexCtlBlk->fLastDrvDraw);
        }

        pTexCtlBlk->pohTextureMap = pohTextureMap;
                                    
        if (!pohTextureMap)
        {
            MCDBG_PRINT_TEX("  Load texture failed ");
            // alloc of off screen memory failed
            pTexCtlBlk->wXloc = 0;  // set to 0 - have seen keys from deleted textures uses in error
            pTexCtlBlk->wYloc = 0;  //      - have sent question about this to Microsoft
            return FALSE;
        }
        else
        {
            // alloc of off screen memory worked - key is ptr to control block
            pTexCtlBlk->wXloc = (WORD)pohTextureMap->aligned_x;
            pTexCtlBlk->wYloc = (WORD)pohTextureMap->aligned_y;
        }

        // if we make it this far, texture allocation was successful,
        // copy texture to video memory
        
        pDest  = ppdev->pjScreen + 
                 (pohTextureMap->aligned_y * ppdev->lDeltaScreen) +
                 pohTextureMap->aligned_x;

        // MCD_NOTE concerning indexed textures...
        // MCD_NOTE - will convert indexed textures to same format as screen and
        // MCD_NOTE - store as RGB texture, until hw palette use coded and debugged. 
        // FUTURE: use texture palettes in HW - possible complications are: 
        // FUTURE:  -palette size not fixed - data format can be 16 bit index
        // FUTURE:  -palette can only be used when screen not in 8 bit mode
        // FUTURE:  -5465 bug where cursor interaction can corrupt palette
        // FUTURE:  -MISC_TEST bit set needed for some reason (see CGL code/ask Dan)
        
        switch (level[0].internalFormat)
        {
        case GL_COLOR_INDEX8_EXT:
            {
            // indices are 8 bit
            UCHAR *pSrc = level[0].pTexels;
            RGBQUAD *pPaletteData;

            VERIFY_TEXTUREPALETTE8_ACCESSIBLE(pTex);

            pPaletteData = pTex->pMCDTextureData->paletteData;

            // texture is 1 BYTE per texel
            VERIFY_TEXELS_ACCESSIBLE(pSrc,level[0].heightImage*level[0].widthImage,ENGPROBE_ALIGN_BYTE);

            switch (alignflag) 
                {
                case MCD_TEXTURE8_ALLOCATE:
                    pTexCtlBlk->bType = LL_TEX_332;
                    for (row=0; row<level[0].heightImage; row++) 
                    {  
                        for (col=0; col<level[0].widthImage; col++)
                        {

                            // convert from 888 to 332
                            *(pDest + col) = 
                                ((pPaletteData[*pSrc].rgbRed   >> 5) << 5) |
                                ((pPaletteData[*pSrc].rgbGreen >> 5) << 2) |
                                 (pPaletteData[*pSrc].rgbBlue  >> 6);

                            pSrc++; // increment by 1 byte
                        }
                    
                        pDest += ppdev->lDeltaScreen;
                    }
                    break;
                case MCD_TEXTURE16_ALLOCATE:

            #if DRIVER_5465
                    pTexCtlBlk->bType = LL_TEX_4444;
                    ashift = 4; apos = 12;  // 4 bits alp, at bits 15->12
                    rshift = 4; rpos =  8;  // 4 bits red, at bits 11->8
                    gshift = 4; gpos =  4;  // 4 bits grn, at bits  7->4
                    bshift = 4;             // 4 bits blu, at bits  3->0
            #else // DRIVER_5465
                    pTexCtlBlk->bType = LL_TEX_565;
                    ashift = 8; apos = 16;  // removes alpha altogether
                    rshift = 3; rpos = 11;  // 5 bits red, at bits 15->11
                    gshift = 2; gpos = 5;   // 6 bits grn, at bits 10->5
                    bshift = 3;             // 5 bits blu, at bits  4->0
            #endif // DRIVER_5465

                    for (row=0; row<level[0].heightImage; row++) 
                    {  
                        for (col=0; col<level[0].widthImage; col++)
                        {
                            // convert from 8888 to 565
                            *(USHORT *)(pDest + (col*2)) = 
                                ((pPaletteData[*pSrc].rgbReserved    >> ashift) << apos) |
                                ((pPaletteData[*pSrc].rgbRed         >> rshift) << rpos) |
                                ((pPaletteData[*pSrc].rgbGreen       >> gshift) << gpos) |
                                 (pPaletteData[*pSrc].rgbBlue        >> bshift);

                            pSrc++; // increment by 1 byte
                        }
                    
                        pDest += ppdev->lDeltaScreen;
                    }

                    break;
                case MCD_TEXTURE32_ALLOCATE:
    #if DRIVER_5465
                    pTexCtlBlk->bType = LL_TEX_8888;
    #else            
                    pTexCtlBlk->bType = LL_TEX_1888;
    #endif
                    for (row=0; row<level[0].heightImage; row++) 
                    {  
                        for (col=0; col<level[0].widthImage; col++)
                        {

                            // copy the RGBQUAD as is
                            *(DWORD *)(pDest + (col*4)) = *(DWORD *)(&pPaletteData[*pSrc]);

                            pSrc++; // increment by 1 byte
                        }
                    
                        pDest += ppdev->lDeltaScreen;
                    }
                    break;
                }
            }
            break;
        case GL_COLOR_INDEX16_EXT:
            // indices are 16 bit
            {
            USHORT *pSrc = (USHORT *)level[0].pTexels;
            RGBQUAD *pPaletteData;

            VERIFY_TEXTUREPALETTE16_ACCESSIBLE(pTex);

            pPaletteData = pTex->pMCDTextureData->paletteData;

            // texture is 2 bytes per texel
            VERIFY_TEXELS_ACCESSIBLE(pSrc,level[0].heightImage*level[0].widthImage*2,ENGPROBE_ALIGN_WORD);

            switch (alignflag) 
                {
                case MCD_TEXTURE8_ALLOCATE:
                    pTexCtlBlk->bType = LL_TEX_332;
                    for (row=0; row<level[0].heightImage; row++) 
                    {  
                        for (col=0; col<level[0].widthImage; col++)
                        {
                            // convert from 888 to 332
                            *(pDest + col) = 
                                ((pPaletteData[*pSrc].rgbRed   >> 5) << 5) |
                                ((pPaletteData[*pSrc].rgbGreen >> 5) << 2) |
                                 (pPaletteData[*pSrc].rgbBlue  >> 6);

                            pSrc++; // increment by 1 16bit word
                        }
                    
                        pDest += ppdev->lDeltaScreen;
                    }
                    break;
                case MCD_TEXTURE16_ALLOCATE:
            #if DRIVER_5465
                    pTexCtlBlk->bType = LL_TEX_4444;
                    ashift = 4; apos = 12;  // 4 bits alp, at bits 15->12
                    rshift = 4; rpos =  8;  // 4 bits red, at bits 11->8
                    gshift = 4; gpos =  4;  // 4 bits grn, at bits  7->4
                    bshift = 4;             // 4 bits blu, at bits  3->0
            #else // DRIVER_5465
                    pTexCtlBlk->bType = LL_TEX_565;
                    ashift = 8; apos = 16;  // removes alpha altogether
                    rshift = 3; rpos = 11;  // 5 bits red, at bits 15->11
                    gshift = 2; gpos = 5;   // 6 bits grn, at bits 10->5
                    bshift = 3;             // 5 bits blu, at bits  4->0
            #endif // DRIVER_5465

                    for (row=0; row<level[0].heightImage; row++) 
                    {  
                        for (col=0; col<level[0].widthImage; col++)
                        {
                            // convert from 8888 to 565
                            *(USHORT *)(pDest + (col*2)) = 
                                ((pPaletteData[*pSrc].rgbReserved    >> ashift) << apos) |
                                ((pPaletteData[*pSrc].rgbRed         >> rshift) << rpos) |
                                ((pPaletteData[*pSrc].rgbGreen       >> gshift) << gpos) |
                                 (pPaletteData[*pSrc].rgbBlue        >> bshift);

                            pSrc++; // increment by 1 16bit word
                        }
                    
                        pDest += ppdev->lDeltaScreen;
                    }



                    break;
                case MCD_TEXTURE32_ALLOCATE:
    #if DRIVER_5465
                    pTexCtlBlk->bType = LL_TEX_8888;
    #else            
                    pTexCtlBlk->bType = LL_TEX_1888;
    #endif
                    for (row=0; row<level[0].heightImage; row++) 
                    {  
                        for (col=0; col<level[0].widthImage; col++)
                        {

                            // copy the RGBQUAD as is
                            *(DWORD *)(pDest + (col*4)) = *(DWORD *)(&pPaletteData[*pSrc]);

                            pSrc++; // increment by 1 16bit word
                        }
                    
                        pDest += ppdev->lDeltaScreen;
                    }
                    break;
                }
            }
            break;
        case GL_LUMINANCE:
        case GL_LUMINANCE_ALPHA:
        case GL_ALPHA:
        case GL_RGB:
        case GL_RGBA:
        case GL_INTENSITY:
            // pTexels is pointer to sequence of floats
            // read pTexel value, convert to RGBA using redSize, greenSize, etc.,
            //  and store in current screen format.
            {
            float *pSrc;
            RGBQUAD texel_rgba;
            CONVERT_TEXEL_FUNC pTexelFunc;
            int     sweetspot=0;

            // texture is 1, 2, 3, or 4 floats per texel, each float is 4 bytes
            pSrc = (float *)level[0].pTexels;

            texel_rgba.rgbReserved = 0xff;  // initialize for cases of constant Alpha

            // FUTURE: We currently punt correctly if global blend enabled with texture alpha since
            // FUTURE:    can't do blend two levels of blend - However, 5465 doesn't modulate alpha
            // FUTURE:    of texture with alpha of fragment as req'd by GL_LUMINANCE_ALPHA
            // FUTURE:    with Modulate or Blend, and RGBA with Modulate - therefore alpha stored
            // FUTURE:    for these 3 cases is wrong - and if blend turned on later, results wrong
            switch (level[0].internalFormat)
            {
                case GL_LUMINANCE:          

                    // texture is 1 float(4 bytes) per texel
                    VERIFY_TEXELS_ACCESSIBLE(pSrc,level[0].heightImage*level[0].widthImage*4,ENGPROBE_ALIGN_DWORD);

                    if ( pRc->MCDTexEnvState.texEnvMode==GL_BLEND )
                    {
                        pTexelFunc = luminance_blend_texel;       
                    //  texel_rgba.rgbRed  = (int)(pRc->MCDTexEnvState.texEnvColor.r * pRc->rScale) >> 16;
                    //  texel_rgba.rgbGreen= (int)(pRc->MCDTexEnvState.texEnvColor.g * pRc->gScale) >> 16;
                    //  texel_rgba.rgbBlue = (int)(pRc->MCDTexEnvState.texEnvColor.b * pRc->bScale) >> 16;
                    }
                    else
                        if (pTexCtlBlk->bNegativeMap)
                        {
                            pTexelFunc = n_luminance_texel;       
                            sweetspot++;
                        }
                        else
                        {
                            pTexelFunc = luminance_texel;       
                        }
                    break;
                case GL_LUMINANCE_ALPHA:    

                    // texture is 2 floats(8 bytes) per texel
                    VERIFY_TEXELS_ACCESSIBLE(pSrc,level[0].heightImage*level[0].widthImage*8,ENGPROBE_ALIGN_DWORD);

                    if ( pRc->MCDTexEnvState.texEnvMode==GL_BLEND )
                    {
                        pTexelFunc = luminance_alpha_blend_texel;       
                    //  texel_rgba.rgbRed  = (int)(pRc->MCDTexEnvState.texEnvColor.r * pRc->rScale) >> 16;
                    //  texel_rgba.rgbGreen= (int)(pRc->MCDTexEnvState.texEnvColor.g * pRc->gScale) >> 16;
                    //  texel_rgba.rgbBlue = (int)(pRc->MCDTexEnvState.texEnvColor.b * pRc->bScale) >> 16;
                    }
                    else
                        if (pTexCtlBlk->bNegativeMap)
                            pTexelFunc = n_luminance_alpha_texel; 
                        else
                            pTexelFunc = luminance_alpha_texel; 
                    break;
                case GL_ALPHA:              
                    // FUTURE: GL_BLEND texture env defined in GL1.1 for GL_ALPHA,GL_RGB,GL_RGBA
                    // R, G, B assumed 0

                    // texture is 1 float(4 bytes) per texel
                    VERIFY_TEXELS_ACCESSIBLE(pSrc,level[0].heightImage*level[0].widthImage*4,ENGPROBE_ALIGN_DWORD);

                    texel_rgba.rgbRed = texel_rgba.rgbGreen = texel_rgba.rgbBlue = 0;
                    pTexelFunc = alpha_texel;           
                    break;
                case GL_RGB:                
                    // texture is 3 float(12 bytes) per texel
                    VERIFY_TEXELS_ACCESSIBLE(pSrc,level[0].heightImage*level[0].widthImage*12,ENGPROBE_ALIGN_DWORD);
                    pTexelFunc = rgb_texel;             
                    break;
                case GL_RGBA:               
                    // texture is 4 float(16 bytes) per texel
                    VERIFY_TEXELS_ACCESSIBLE(pSrc,level[0].heightImage*level[0].widthImage*16,ENGPROBE_ALIGN_DWORD);
                    pTexelFunc = rgba_texel;            
                    break;
                case GL_INTENSITY:          
                    // texture is 1 float(4 bytes) per texel
                    VERIFY_TEXELS_ACCESSIBLE(pSrc,level[0].heightImage*level[0].widthImage*4,ENGPROBE_ALIGN_DWORD);
                    pTexelFunc = intensity_texel;
                    break;
            }


            switch (alignflag) 
                {
                case MCD_TEXTURE8_ALLOCATE:                    
                    if (pRc->MCDTexEnvState.texEnvMode==GL_BLEND)
                    {
                        // this works for GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_INTENSITY only
                        pTexCtlBlk->bType = LL_TEX_8_ALPHA;

                        for (row=0; row<level[0].heightImage; row++) 
                        {  
                            for (col=0; col<level[0].widthImage; col++)
                            {
                                pSrc = pTexelFunc(pSrc,&level[0],&texel_rgba);
                                *(pDest + col) = texel_rgba.rgbReserved;
                            }
                        
                            pDest += ppdev->lDeltaScreen;
                        }

                    }
                    else
                    {
                        pTexCtlBlk->bType = LL_TEX_332;

                        for (row=0; row<level[0].heightImage; row++) 
                        {  
                            for (col=0; col<level[0].widthImage; col++)
                            {
                                pSrc = pTexelFunc(pSrc,&level[0],&texel_rgba);

                                // convert from 888 to 332
                                *(pDest + col) = 
                                    ((texel_rgba.rgbRed   >> 5) << 5) |
                                    ((texel_rgba.rgbGreen >> 5) << 2) |
                                     (texel_rgba.rgbBlue  >> 6);
                            }
                        
                            pDest += ppdev->lDeltaScreen;
                        }
                    }

                    break;
                case MCD_TEXTURE16_ALLOCATE:
                    if ( pTexCtlBlk->bAlphaInTexture )
                    {
                        if (pTexCtlBlk->bMasking)
                        {
                            pTexCtlBlk->bType = LL_TEX_1555;
                            ashift = 7; apos = 15;  // 1 bits alp, at bits 15->12
                            rshift = 3; rpos = 10;  // 5 bits red, at bits 11->8
                            gshift = 3; gpos =  5;  // 5 bits grn, at bits  7->4
                            bshift = 3;             // 5 bits blu, at bits  3->0
                        }
                        else
                        {
                        #if DRIVER_5465                 
                            pTexCtlBlk->bType = LL_TEX_4444;
                            ashift = 4; apos = 12;  // 4 bits alp, at bits 15->12
                            rshift = 4; rpos =  8;  // 4 bits red, at bits 11->8
                            gshift = 4; gpos =  4;  // 4 bits grn, at bits  7->4
                            bshift = 4;             // 4 bits blu, at bits  3->0
                        #else // DRIVER_5465
                            // 5464 has no 4444 support
                            pTexCtlBlk->bType = LL_TEX_1555;
                            ashift = 7; apos = 15;  // 1 bits alp, at bits 15->12
                            rshift = 3; rpos = 10;  // 5 bits red, at bits 11->8
                            gshift = 3; gpos =  5;  // 5 bits grn, at bits  7->4
                            bshift = 3;             // 5 bits blu, at bits  3->0
                        #endif // DRIVER_5465
                        }
                    }                              
                    else                        
                    {
                        pTexCtlBlk->bType = LL_TEX_565;
                        ashift = 8; apos = 16;  // removes alpha altogether
                        rshift = 3; rpos = 11;  // 5 bits red, at bits 15->11
                        gshift = 2; gpos = 5;   // 6 bits grn, at bits 10->5
                        bshift = 3;             // 5 bits blu, at bits  4->0
                        sweetspot++;
                    }

                    for (row=0; row<level[0].heightImage; row++) 
                    {  
                        if (!pTexCtlBlk->bMasking)
                        {
                            if (sweetspot<2)
                            {
                                for (col=0; col<level[0].widthImage; col++)
                                {
                                    pSrc = pTexelFunc(pSrc,&level[0],&texel_rgba);

                                    // convert from 8888 to 4444 or 565
                                    *(USHORT *)(pDest + (col*2)) = 
                                        ((texel_rgba.rgbReserved    >> ashift) << apos) |
                                        ((texel_rgba.rgbRed         >> rshift) << rpos) |
                                        ((texel_rgba.rgbGreen       >> gshift) << gpos) |
                                         (texel_rgba.rgbBlue        >> bshift);
                                }
                            }
                            else
                            {
                                // n_luminance_texel -> 565
                                for (col=0; col<level[0].widthImage; col++)
                                {
                                    ULONG   _8bitequiv;
                                    ULONG   redblue;
                                    ULONG   green;
                                    _8bitequiv = FTOL(((float)1.0 - *pSrc++) * (float)255.0);

                                    redblue = _8bitequiv >> 3;  // 5 bits for r,b
                                    green = (_8bitequiv << 3) & 0x07e0; // 6 bits for g, shift to middle
                                    // convert to 565
                                    *(USHORT *)(pDest + (col*2)) = (USHORT)
                                        ((redblue<<11) | green | redblue);
                                    
                                }                                                      
                            }
                        }
                        else
                        {
                            for (col=0; col<level[0].widthImage; col++)
                            {
                                pSrc = pTexelFunc(pSrc,&level[0],&texel_rgba);

                                // convert from 8888 to 4444 or 565
                                *(USHORT *)(pDest + (col*2)) = 
                                    ((texel_rgba.rgbReserved    >> ashift) << apos) |
                                    ((texel_rgba.rgbRed         >> rshift) << rpos) |
                                    ((texel_rgba.rgbGreen       >> gshift) << gpos) |
                                     (texel_rgba.rgbBlue        >> bshift);

                                // turn on mask bit (bit 15) if alpha > ref
                                if (texel_rgba.rgbReserved > pRc->bAlphaTestRef)
                                    *(USHORT *)(pDest + (col*2)) |= 0x8000;

                            }
                        }
                        pDest += ppdev->lDeltaScreen;
                    }
                    break;
                case MCD_TEXTURE32_ALLOCATE:
    #if DRIVER_5465
                    if (!pTexCtlBlk->bMasking)
                        pTexCtlBlk->bType = LL_TEX_8888;
                    else
                        pTexCtlBlk->bType = LL_TEX_1888;
    #else  // DRIVER_5465
                    pTexCtlBlk->bType = LL_TEX_1888;
    #endif // DRIVER_5465
                    for (row=0; row<level[0].heightImage; row++) 
                    {  
                        if (!pTexCtlBlk->bMasking)
                        {
                            for (col=0; col<level[0].widthImage; col++)
                            {
                                pSrc = pTexelFunc(pSrc,&level[0],&texel_rgba);

                                // copy the RGBQUAD as is
                                *(RGBQUAD *)(pDest + (col*4)) = texel_rgba;
                            }
                        }
                        else
                        {
                            // masking on - set bit31 of texel according to alpha test

                            for (col=0; col<level[0].widthImage; col++)
                            {
                                pSrc = pTexelFunc(pSrc,&level[0],&texel_rgba);

                                // turn on mask bit (bit 8) of alpha component, if alpha > ref
                                if (texel_rgba.rgbReserved > pRc->bAlphaTestRef)
                                    texel_rgba.rgbReserved|=0x80;

                                // copy the RGBQUAD as is
                                *(RGBQUAD *)(pDest + (col*4)) = texel_rgba;
                            }
                        }                                
                    
                        pDest += ppdev->lDeltaScreen;
                    }
                    break;
                }
            }
            break;
        } // endswitch
    }

    // if texture width or height less than 16, stretch it to 16x16
    if ((level[0].widthImage < 16) || (level[0].heightImage < 16))
    {

        int col_copies, row_copies, h, w;
        UCHAR *colsrc, *coldest, *rowdest; 
        int bpt;

        // bytes per texel
        switch (alignflag)
        {
            case MCD_TEXTURE8_ALLOCATE:     bpt = 1;    break;
            case MCD_TEXTURE16_ALLOCATE:    bpt = 2;    break;
            case MCD_TEXTURE32_ALLOCATE:    bpt = 4;    break;
        }

        // for width stretch - 8 requires 2 copies, 4 requires 4, 2 requires 8, 1 requires 16
        col_copies = (16 / level[0].widthImage);

        // for height stretch - 8 requires 2 copies, 4 requires 4, 2 requires 8, 1 requires 16
        // if already at least 16 high, then width stretch all that's needed, so prevent row copy
        row_copies = (level[0].heightImage < 16) ? (16/level[0].heightImage) : 0;

        // start with last row

        h = level[0].heightImage - 1;

        while (h >= 0)
        {
            int rc;   // row copy counter

            colsrc = coldest = 
                      ppdev->pjScreen + ((pohTextureMap->aligned_y + h) * ppdev->lDeltaScreen) +
                      pohTextureMap->aligned_x;

            w = level[0].widthImage;

            // start at last texel of current row
            // will copy last texel col_copies times to 15th, 14th, etc. texel(s)

            colsrc  += ( w - 1) * bpt;
            coldest += (16 - 1) * bpt;
            
            
            while (w--)
            {
                int cc=0;
                // copy original texel col_copies times
                while (cc<col_copies)
                {
                    // copy texel of bpt size        
                    memcpy (coldest,colsrc,bpt);

                    // src remains the same, dest is decremented 
                    coldest-=bpt;        
                    cc++;
                }

                colsrc-=bpt;
            }
            
            // now row is at least 16 texels 
            //      NOTE: may have been > 16 originally -
            //      If >= 16 originally, the "cc<col_copies" loop above
            //      would never have executed, and the "w--" loop would get
            //      colsrc back to start of row - inefficient but typically
            //      width=height so case of width>=16 rare

            // colsrc points to start of row 
            colsrc =  ppdev->pjScreen + 
                      ((pohTextureMap->aligned_y + h) * ppdev->lDeltaScreen) +
                        pohTextureMap->aligned_x;

            // compute where row should be copied to for expansion heightwise
            rowdest = ppdev->pjScreen + 
                      ((pohTextureMap->aligned_y+(h * row_copies)) * ppdev->lDeltaScreen) +
                        pohTextureMap->aligned_x;

            rc=0;  
            // width of row is now 16, if original less than 16                
            w = (level[0].widthImage < 16) ? 16 : level[0].widthImage;

            while (rc<row_copies)
            {
                // copy row
                memcpy (rowdest,colsrc,w*bpt);

                // src remains the same, dest is incremented 
                rowdest += ppdev->lDeltaScreen;        
                rc++;
            }

            h--;

        } // endwhile

    }

    return TRUE;

}

#if 1 // 0 here for simplest form of force
POFMHDL __MCDForceTexture (PDEV *ppdev, SIZEL *mapsize, int alignflag, float time_stamp)
{
    int         attempt=4;
    LL_Texture *pTexCtlBlk, *pTexCandidate;
    POFMHDL     pohTextureMap=NULL;
    float       cand_time_stamp;

    MCDFORCE_PRINT("    __MCDForceTexture, pri=%d",(int)time_stamp);

    // wait until pending drawing completes, since offscreen memory may be moved by this routine
    WAIT_HW_IDLE(ppdev);

    while (!pohTextureMap && attempt)
    {
        switch(attempt)
        {
            case 4:
            // 1st try:look for texture of same (or bigger) size of current, but with lower time_stamp
            // MCD_NOTE2: texture cache manager assumes alignflag same for all textures
            // MCD_NOTE2:   this may not be true if 32bpp textures ever supported as is
                pTexCtlBlk = ppdev->pFirstTexture->next;
                pTexCandidate = NULL;
                cand_time_stamp = time_stamp;

                MCDFORCE_PRINT("     Force, case 4");

                while (pTexCtlBlk)
                {

                    MCDFORCE_PRINT("         loop:  h=%x w=%x, pri=%d",
                       (LONG)pTexCtlBlk->fHeight,(LONG)pTexCtlBlk->fWidth,(int)pTexCtlBlk->fLastDrvDraw);
                
                    if ( pTexCtlBlk->pohTextureMap &&
                        (mapsize->cy <= (LONG)pTexCtlBlk->fHeight) &&
                        (mapsize->cx <= (LONG)pTexCtlBlk->fWidth) &&
                        (pTexCtlBlk->fLastDrvDraw < cand_time_stamp) )
                    {                                
                        cand_time_stamp = pTexCtlBlk->fLastDrvDraw;    
                        pTexCandidate = pTexCtlBlk;
                    }

                    pTexCtlBlk = pTexCtlBlk->next;

                }                
                              
                // if we found a candidate, free it
                if (pTexCandidate) 
                {
                    MCDFORCE_PRINT("          freeing cand:  h=%x w=%x, pri=%d",
                        (LONG)pTexCandidate->fHeight,(LONG)pTexCandidate->fWidth,(int)pTexCandidate->fLastDrvDraw);

                    ppdev->pFreeOffScnMem(ppdev, pTexCandidate->pohTextureMap);
                    pTexCandidate->pohTextureMap = NULL;
                }

            break;

            case 3:
            // 2nd try:look for texture of same or bigger size of current, with any time_stamp

                pTexCtlBlk = ppdev->pFirstTexture->next;
                pTexCandidate = NULL;

                MCDFORCE_PRINT("     Force, case 3");

                while (pTexCtlBlk)
                {
                    MCDFORCE_PRINT("         loop:  h=%x w=%x",(LONG)pTexCtlBlk->fHeight,(LONG)pTexCtlBlk->fWidth);
                    if ( pTexCtlBlk->pohTextureMap &&
                        (mapsize->cy <= (LONG)pTexCtlBlk->fHeight) &&
                        (mapsize->cx <= (LONG)pTexCtlBlk->fWidth) )
                    {
                        // if already found a candidate, check if new find smaller
                        // if so it's new candidate, since we want to free smallest region
                        if (pTexCandidate)
                        {
                            if ((pTexCtlBlk->fHeight < pTexCandidate->fHeight) ||
                                (pTexCtlBlk->fWidth  < pTexCandidate->fWidth))
                            {
                                // new find is better choice
                                pTexCandidate = pTexCtlBlk;
                            }
                        }
                        else
                        {
                            // first find - default candidate                                    
                            pTexCandidate = pTexCtlBlk;
                        }                                        
                    }

                    pTexCtlBlk = pTexCtlBlk->next;

                }                
                              
                // if we found a candidate, free it
                if (pTexCandidate)
                {
                    MCDFORCE_PRINT("          freeing cand:  h=%x w=%x, pri=%d",
                        (LONG)pTexCandidate->fHeight,(LONG)pTexCandidate->fWidth,(int)pTexCandidate->fLastDrvDraw);
                    ppdev->pFreeOffScnMem(ppdev, pTexCandidate->pohTextureMap);
                    pTexCandidate->pohTextureMap = NULL;
                }

            break;

            case 2:
            // 3rd try:free all textures with time_stamp less than current
                pTexCtlBlk = ppdev->pFirstTexture->next;

                MCDFORCE_PRINT("     Force, case 2");

                while (pTexCtlBlk)
                {
                    if ( pTexCtlBlk->pohTextureMap &&
                        (pTexCtlBlk->fLastDrvDraw < time_stamp) )
                    {                                
                        ppdev->pFreeOffScnMem(ppdev, pTexCtlBlk->pohTextureMap);
                        pTexCtlBlk->pohTextureMap = NULL;
                    }

                    pTexCtlBlk = pTexCtlBlk->next;

                }                
                              
            break;

            case 1:
            // Last try:free all textures
                pTexCtlBlk = ppdev->pFirstTexture->next;
                MCDFORCE_PRINT("     Force, case 1");
                while (pTexCtlBlk)
                {
                    if (pTexCtlBlk->pohTextureMap)
                    {
                        ppdev->pFreeOffScnMem(ppdev, pTexCtlBlk->pohTextureMap);
                        pTexCtlBlk->pohTextureMap = NULL;
                    }

                    pTexCtlBlk = pTexCtlBlk->next;

                }                
            break;
        } // endswitch

        // try it now...
        pohTextureMap = ppdev->pAllocOffScnMem(ppdev, mapsize, alignflag, NULL);

        attempt--;

    }
           
    MCDFORCE_PRINT("     Force RESULT= %x",pohTextureMap);

    return (pohTextureMap);
}

#else // simple force

// simplest force algorithm
POFMHDL __MCDForceTexture (PDEV *ppdev, SIZEL *mapsize, int alignflag, float time_stamp)
{
    int         attempts;
    LL_Texture *pTexCtlBlk;
    POFMHDL     pohTextureMap;
    WAIT_HW_IDLE(ppdev); // wait until pending drawing completes, since offscreen memory may be moved by this routine
    pTexCtlBlk = ppdev->pFirstTexture->next;
    while (pTexCtlBlk)
    {
        if (pTexCtlBlk->pohTextureMap)
        {
            ppdev->pFreeOffScnMem(ppdev, pTexCtlBlk->pohTextureMap);
            pTexCtlBlk->pohTextureMap = NULL;
        }
        pTexCtlBlk = pTexCtlBlk->next;
    }
    // try it now..       
    pohTextureMap = ppdev->pAllocOffScnMem(ppdev, mapsize, alignflag, NULL);
    return (pohTextureMap);
}

#endif //simple force
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\i386\font.inc ===
;===============================================================================
;
;	$Workfile:   FONT.INC  $
;
;	Contents:
;	Include file for the font cache.
;
;	Copyright (c) 1996, Cirrus Logic, Inc.
;
;	$Log:   X:/log/laguna/nt35/displays/cl546x/i386/FONT.INC  $
; 
;    Rev 1.6   20 Aug 1996 11:28:58   noelv
; Bugfix release from Frido 8-19-96
; 
;    Rev 1.0   14 Aug 1996 17:14:34   frido
; Initial revision.
; 
;    Rev 1.5   25 Jul 1996 15:50:12   bennyn
; 
; Modified to support DirectDraw
; 
;    Rev 1.4   04 Apr 1996 13:22:20   noelv
; Frido version 26
;	
;	   Rev 1.1   25 Jan 1996 12:44:16   frido
;	Added ID counter in FONTCACHE structure.
;	
;	   Rev 1.0   24 Jan 1996 23:13:38   frido
;	 Initial release.
;
;===============================================================================

BYTES_PER_TILE		=		128
LINES_PER_TILE		=		16

CACHE_EXPAND_XPAR	=		105501F0h


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\i386\i386brus.asm ===
;===============================================================================
;
;	$Workfile:   I386BRUS.ASM  $
;
;	Contents:
;	This file contains the assembly code for some of the brush realization.
;
;	Copyright (c) 1996, Cirrus Logic, Inc.
;
;	$Log:   X:/log/laguna/nt35/displays/cl546x/i386/I386BRUS.ASM  $
; 
;    Rev 1.11   29 Apr 1997 16:29:24   noelv
; Merged in new SWAT code.
; SWAT: 
; SWAT:    Rev 1.3   24 Apr 1997 10:46:06   frido
; SWAT: NT140b09 merge.
; SWAT: 
; SWAT:    Rev 1.2   19 Apr 1997 16:31:40   frido
; SWAT: Added automatic include file dependencies for BUILD.EXE.
; 
;    Rev 1.10   08 Apr 1997 11:45:06   einkauf
; 
; add call to SYNC_W_3D for MCD coordination
; 
;    Rev 1.9   22 Aug 1996 18:15:10   noelv
; Frido bug fix release 8-22.
; 
;    Rev 1.2   22 Aug 1996 19:11:14   frido
; #1308 - Added extra checks for empty cache slots.
; 
;    Rev 1.1   18 Aug 1996 15:19:52   frido
; #nbr - Added brush translation.
; 
;    Rev 1.0   14 Aug 1996 17:14:34   frido
; Initial revision.
; 
;    Rev 1.7   10 Apr 1996 13:39:20   NOELV
; Frido release 27
;       
;          Rev 1.11   08 Apr 1996 16:48:00   frido
;       Added new check for 32-bpp brushes.
;       
;          Rev 1.10   01 Apr 1996 13:57:44   frido
;       Added check for valid brush cache.
;       
;          Rev 1.9   30 Mar 1996 22:01:22   frido
;       Refined check for invalid translation flags.
;       
;          Rev 1.8   27 Mar 1996 13:04:58   frido
;       Removed 32-bpp colored brushes.
;       Added check for undocumented translation flags.
;       Masked 16-bit colors.
;       
;          Rev 1.7   04 Mar 1996 23:47:54   frido
;       Removed bug in realization of dithered brush.
;       
;          Rev 1.6   29 Feb 1996 20:20:38   frido
;       Fixed bug in 16-bpp brush realization.
;       
;          Rev 1.5   28 Feb 1996 22:40:08   frido
;       Added Optimize.h.
;       
;          Rev 1.4   19 Feb 1996 07:23:02   frido
;       Added comments.
;       Added assembly version of CacheMono and CacheDither.
;       
;          Rev 1.3   17 Feb 1996 21:46:16   frido
;       Revamped brushing algorithmn.
;       
;          Rev 1.2   13 Feb 1996 16:51:52   frido
;       Changed the layout of the PDEV structure.
;       Changed the layout of all brush caches.
;       Changed the number of brush caches.
;       
;          Rev 1.1   10 Feb 1996 21:51:12   frido
;       Split monochrome and colored translation cache.
;       Added debugging macro.
;       Fixed a bug that caused dithered brush never to be cached.
;       
;          Rev 1.0   08 Feb 1996 00:14:40   frido
;       First release.
;  
;===============================================================================

.386
.MODEL FLAT, STDCALL

OPTION	PROLOGUE:None
OPTION	EPILOGUE:None

.NOLIST
INCLUDE i386\Macros.inc
INCLUDE i386\WinNT.inc
INCLUDE i386\Laguna.inc
INCLUDE Optimize.h
COMMENT !		;automatic include file dependencies for BUILD.EXE
#include "i386\Macros.inc"
#include "i386\WinNT.inc"
#include "i386\Laguna.inc"
#include "Optimize.h"
!
.LIST

IF USE_ASM

.DATA

EXTERN		Swiz		:BYTE

.CODE
;
; Function prototypes.
;
vDitherColor	PROTO		PROC,
		rgb		:ULONG,
		pul		:PTR ULONG
CacheBrush	PROTO		PROC,
		ppdev		:PTR PDEV,
		pRbrush		:PTR RBRUSH
Cache4BPP	PROTO		PROC,
		ppdev		:PTR PDEV,
		pRbrush		:PTR RBRUSH
IF 1 ;#nbr
i386RealizeBrush PROTO		PROC,
		pbo		:PTR BRUSHOBJ,
		psoTarget	:PTR SURFOBJ,
		psoPattern	:PTR SURFOBJ,
		psoMask		:PTR SURFOBJ,
		pxlo		:PTR XLATEOBJ,
		iHatch		:ULONG
ENDIF

ifdef WINNT_VER40
Sync_w_3d_proc  	PROTO		PROC,
		ppdev		:PTR PDEV
endif

;
; Stack frame for DrvRealizeBrush.
;
espPTR		=	0
frmPTR		=	0
pbo_		TEXTEQU	<DWORD PTR [esp + 4 + espPTR]>
psoTarget_	TEXTEQU <DWORD PTR [esp + 8 + espPTR]>
psoPattern_	TEXTEQU <DWORD PTR [esp + 12 + espPTR]>
psoMask_	TEXTEQU	<DWORD PTR [esp + 16 + espPTR]>
pxlo_		TEXTEQU	<DWORD PTR [esp + 20 + espPTR]>
iHatch_		TEXTEQU <DWORD PTR [esp + 24 + espPTR]>

DrvRealizeBrush PROC PUBLIC,
	pbo		:PTR BRUSHOBJ,
	psoTarget	:PTR SURFOBJ,
	psoPattern	:PTR SURFOBJ,
	psoMask		:PTR SURFOBJ,
	pxlo		:PTR XLATEOBJ,
	iHatch		:ULONG

	mov	eax, [psoTarget_]	;EAX holds pointer to destination
	ASSUME	eax:PTR SURFOBJ
	push_	esi
	push_	edi
	or	eax, eax		;any destination?
	push_	ebx
	push_	ebp
	mov	esi, [psoPattern_]	;ESI holds pointer to psoPattern
	ASSUME	esi:PTR SURFOBJ
	jz	Error			;error: we don't have a target
	mov	ebx, [eax].dhpdev	;get handle to PDEV
	ASSUME	ebx:PTR PDEV
	mov	ebp, [iHatch_]		;get iHatch value
	test	ebx, ebx
	jz	Error			;error: we don't have a valid handle
	cmp	[ebx].Bcache, 0		;do we have a valid brush cache?
	je	Error			;nope

ifdef WINNT_VER40
;SYNC_W_3D macro equivalent
    cmp [ebx].NumMCDContexts, 0 ; is MCD alive?
	jle	Sync_end    			; no
    push    eax                 ; save
    push    ebx                 ; save
    push    ebx                 ; input to Sync_w_3d_proc
    call Sync_w_3d_proc         
    pop     ebx                 ; restore
    pop     eax                 ; restore
Sync_end:
endif

IF RB_DITHERCOLOR EQ 80000000h
	or	ebp, ebp		;must we realize a dither?
	js	RealizeDither		;yes, go do it now
ELSE
	test	ebp, RB_DITHERCOLOR	;must we realize a dither?
	jnz	RealizeDither		;yes, go do it now
ENDIF
	mov	ecx, [psoMask_]
	mov	eax, [pxlo_]
	ASSUME	eax:PTR XLATEOBJ
	cmp	[esi].sizlBitmap._cx, 8	;we only handle 8x8 patterns
	jne	Error
	cmp	[esi].sizlBitmap._cy, 8
	jne	Error
	or	ecx, ecx		;psoMask equals NULL?
	jnz	Error			;no, we don't support masks
	cmp	[esi].iType, STYPE_BITMAP
	jne	Error			;we only handle normal bitmaps

	mov	ecx, [esi].iBitmapFormat
	xor	ebp, ebp		;zero pointer to translation table
;//frido BEGIN 07-Apr-96
	cmp	ecx, BMF_1BPP		;monochrome pattern?
	je	@F			;yes, supported
	cmp	[ebx].iBitmapFormat, BMF_32BPP
					;32-bpp mode?
	je	Error			;yes, brushes are broken in chip

@@:	test	eax, eax
	jz	@F
;//frido END 07-Apr-96
	test	[eax].flXlate, XO_TRIVIAL
	jnz	@F
	mov	ebp, [eax].pulXlate	;get pointer from XLATEOBJ
	test	[eax].flXlate, XO_TABLE
	jnz	@F			;we have a translation table
	INVOKE	XLATEOBJ_piVector,	;get a pointer to the translation table
			eax
	mov	ecx, [esi].iBitmapFormat
	mov	ebp, eax
;//frido BEGIN 30-Mar-96
@@:	mov	eax, [pxlo_]
	cmp	ecx, BMF_4BPP		;test for 1- or 4-bpp pattern
	jb	RealizeMono		;realize monochrome pattern
	je	Realize4bpp		;realize 4-bpp pattern
	test	eax, eax		;XLATEOBJ specified?
	jz	@F			;no
IF 1 ;#nbr
	test	[eax].flXlate, XO_TRIVIAL
					;trivial translation?
	jz	ChainC			;no, chain to "C" code
ELSE
	test	[eax].flXlate, 10h	;invalid translation flags?
	jnz	Error			;yes
ENDIF

@@:	cmp	ecx, BMF_24BPP		;get number of bytes in pattern
;//frido END 30-Mar-96
	mov	edi, [esi].cjBits
	jne	@F
	add	edi, 64
@@:	cmp	ecx, [ebx].iBitmapFormat;must be same as device format
	jne	Error
	or	ebp, ebp		;we don't support translation
	jnz	Error
	lea	eax, [SIZEOF(RBRUSH) + edi]
	mov	edx, [pbo_]		;allocate the brush
	INVOKE	BRUSHOBJ_pvAllocRbrush,
			edx,
			eax
	ASSUME	eax:PTR RBRUSH
	test	eax, eax
	jz	Error			;error allocating the brush
	mov	ecx, [esi].iBitmapFormat
	mov	[eax].nPatSize, edi	;initialize the brush structure
	mov	[eax].iBitmapFormat, ecx
	mov	[eax].cjMask, 0
	mov	[eax].iType, BRUSH_COLOR

	mov	edx, [esi].lDelta	;get lDelta from pattern
	mov	esi, [esi].pvScan0	;get pointer to first scan line
	ASSUME	esi:NOTHING
	lea	edi, [eax].ajPattern	;get pointer to Rbrush->ajPattern
	mov	ebp, 8			;8 lines
	cmp	ecx, BMF_16BPP		;dispatch brush realization
	jb	Realize8bpp
	je	Realize16bpp
	cmp	ecx, BMF_24BPP
	je	Realize24bpp

;-------------------------------------------------------------------------------
; Realize32bpp - Realize a 32-bpp brush.
;
; On entry:	EDX	lDelta.
;		ESI	Pointer to source pattern.
;		EDI	Pointer to destination brush.
;		EBP	Number of lines to copy.
;-------------------------------------------------------------------------------
Realize32bpp:
	push	eax			;store arguments for CacheBrush
	push	ebx
@@:	mov	eax, [esi + 0]		;copy line
	mov	ebx, [esi + 4]
	mov	[edi + 0], eax
	mov	[edi + 4], ebx
	mov	eax, [esi + 8]
	mov	ebx, [esi + 12]
	mov	[edi + 8], eax
	mov	[edi + 12], ebx
	mov	eax, [esi + 16]
	mov	ebx, [esi + 20]
	mov	[edi + 16], eax
	mov	[edi + 20], ebx
	mov	eax, [esi + 24]
	mov	ebx, [esi + 28]
	mov	[edi + 24], eax
	mov	[edi + 28], ebx
	add	esi, edx		;next line
	add	edi, 32
	dec	ebp
	jnz	@B
	call	CacheBrush		;cache the brush
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	ret	24

;-------------------------------------------------------------------------------
; Realize24bpp - Realize a 24-bpp brush.
;
; On entry:	EDX	lDelta.
;		ESI	Pointer to source pattern.
;		EDI	Pointer to destination brush.
;		EBP	Number of lines to copy.
;-------------------------------------------------------------------------------
Realize24bpp:
	push	eax			;store arguments for CacheBrush
	push	ebx
@@:	mov	eax, [esi + 0]		;copy line
	mov	ebx, [esi + 4]
	mov	[edi + 0], eax
	mov	[edi + 4], ebx
	mov	eax, [esi + 8]
	mov	ebx, [esi + 12]
	mov	[edi + 8], eax
	mov	[edi + 12], ebx
	mov	eax, [esi + 16]
	mov	ebx, [esi + 20]
	mov	[edi + 16], eax
	mov	[edi + 20], ebx
	mov	eax, [esi + 0]
	mov	ebx, [esi + 4]
	mov	[edi + 24], eax
	mov	[edi + 28], ebx
	add	esi, edx		;next line
	add	edi, 32
	dec	ebp
	jnz	@B
	call	CacheBrush		;cache the brush
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	ret	24

;-------------------------------------------------------------------------------
; Realize16bpp - Realize a 16-bpp brush.
;
; On entry:	EDX	lDelta.
;		ESI	Pointer to source pattern.
;		EDI	Pointer to destination brush.
;		EBP	Number of lines to copy.
;-------------------------------------------------------------------------------
Realize16bpp:
	push	eax			;store arguments for CacheBrush
	push	ebx
@@:	mov	eax, [esi + 0]		;copy line
	mov	ebx, [esi + 4]
	mov	[edi + 0], eax
	mov	[edi + 4], ebx
	mov	eax, [esi + 8]
	mov	ebx, [esi + 12]
	mov	[edi + 8], eax
	mov	[edi + 12], ebx
	add	esi, edx		;next line
	add	edi, 16
	dec	ebp
	jnz	@B
	call	CacheBrush		;cache the brush
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	ret	24

;-------------------------------------------------------------------------------
; Realize8bpp - Realize an 8-bpp brush.
;
; On entry:	EDX	lDelta.
;		ESI	Pointer to source pattern.
;		EDI	Pointer to destination brush.
;		EBP	Number of lines to copy.
;-------------------------------------------------------------------------------
Realize8bpp:
	push	eax			;store arguments for CacheBrush
	push	ebx
@@:	mov	eax, [esi + 0]		;copy line
	mov	ebx, [esi + 4]
	mov	[edi + 0], eax
	mov	[edi + 4], ebx
	add	esi, edx		;next line
	add	edi, 8
	dec	ebp
	jnz	@B
	call	CacheBrush		;cache the brush
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	ret	24

;-------------------------------------------------------------------------------
; RealizeDither - Realize a dithered brush.
;
; Dithered brushes are only used in 8-bpp modes and are cached off-screen. The
; dither cache consists of a small table containing the off-screen location for
; each cache slot entry and a color value that is cached in that entry. When-
; ever we have to realize a dither, we first lookup the color in the cache
; table. If the color is found, we just load the brush with the cache parameters
; and return TRUE. Otherwise, we allocate a new cache slot and call the
; dithering routine which will create the dither directly in off-screen memory.
;
; On entry:	EBX	Pointer to PDEV.
;		EBP	Logical RGB color in lower three bytes.
;-------------------------------------------------------------------------------
RealizeDither:
	mov	eax, [pbo_]		;allocate the brush
	ASSUME	ebx:PTR PDEV
	INVOKE	BRUSHOBJ_pvAllocRbrush,
			eax,
			SIZEOF(RBRUSH)
	ASSUME	eax:PTR RBRUSH
	or	eax, eax
	jz	Error			;error
	and	ebp, 00FFFFFFh		;mask RGB color
	mov	edx, -SIZEOF(PDEV).Dtable
	mov	[eax].nPatSize, 0	;initialize brush structure
	mov	[eax].iBitmapFormat, BMF_8BPP
	mov	[eax].cjMask, 0
	mov	[eax].iType, BRUSH_DITHER
	mov	[eax].iUniq, ebp
@@:	cmp	[ebx].Dtable[edx + SIZEOF(PDEV).Dtable].ulColor, ebp
					;lookup color in Dtable
	jne	NextDither		;we still don't have a match
	lea	ebp, [edx + SIZEOF(PDEV).Dtable]
					;get index into cache table
	mov	esi, [ebx].Dtable[edx + SIZEOF(PDEV).Dtable].xy
	mov	[eax].cache_slot, ebp	;brush is cached
	mov	[eax].cache_xy, esi
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	mov	eax, 1			;return TRUE
	ret	24

NextDither:
	add	edx, SIZEOF(DC_ENTRY)	;next cache slot
	jnz	@B
;
; Cache the new dither.
;
	mov	edx, [ebx].DNext	;get the index of the next cache slot
	mov	ecx, edx
	and	edx, NUM_DITHER_BRUSHES - 1
	inc	ecx			;increment cache slot
	imul	edx, SIZEOF(DC_ENTRY)	;build cache table index
	mov	[ebx].DNext, ecx
	mov	[eax].cache_slot, edx	;store cache slot index
	mov	[ebx].Dtable[edx].ulColor, ebp
					;store logical color in cache table
	mov	esi, [ebx].Dtable[edx].xy
					;copy the x/y location of brush
	mov	edi, [ebx].Dtable[edx].pjLinear
					;get linear address
	mov	[eax].cache_xy, esi
	INVOKE	vDitherColor,		;dither the color
			ebp,
			edi
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	mov	eax, 1			;return TRUE
	ret	24

;-------------------------------------------------------------------------------
; Realize4bpp - Realize a 4-bpp brush.
;
; The 4-bpp cache consists of a small table containing the off-screen
; location for each cache slot entry, an 32-byte pattern, and a 16-color palette
; that is cached in that entry. Whenever we have to realize a 4-bpp brush, we
; first lookup the pattern and color palette in the cache table. If the pattern
; is found, we just load the brush with the cache parameters and return TRUE.
; Otherwise, we allocate a new cache slot and store the pattern and palette in
; the cache slot and translate the 4-bpp pattern in off-screen memory.
;
; On entry:	EAX	Pointer to XLATEOBJ.
;		EBX	Pointer to PDEV.
;		ESI	Pointer to psoPattern.
;		EBP	Pointer to translation table.
;-------------------------------------------------------------------------------
Realize4bpp:
	ASSUME	eax:PTR XLATEOBJ
	ASSUME	ebx:PTR PDEV
	ASSUME	esi:PTR SURFOBJ
	or	ebp, ebp		;we must have a valid translation table
	jz	Error
	cmp	[eax].cEntries, 16	;we only support 16 entries in the
	jne	Error			;  palette
	cmp	[esi].cjBits, 32	;we only support 32 bytes in the pattern
	jne	Error

	mov	edx, [pbo_]		;allocate the brush
	INVOKE	BRUSHOBJ_pvAllocRbrush,
			edx,
			SIZEOF(RBRUSH) + 32 + 64
	ASSUME	eax:PTR RBRUSH
	test	eax, eax
	jz	Error			;error allocating brush

	mov	[eax].nPatSize, 32 + 64	;initialize brush structure
	mov	[eax].iBitmapFormat, BMF_4BPP
	lea	edi, [eax].ajPattern
	mov	[eax].cjMask, 0
	mov	[eax].iType, BRUSH_4BPP

	cmp	[esi].lDelta, -4	;test for negative increment
	mov	esi, [esi].pvScan0	;get pointer to first scan line
	ASSUME	esi:NOTHING
	jne	Forward			;we have forward increment

	mov	ecx, [esi - 0]		;copy the pattern from top to bottom
	mov	edx, [esi - 4]
	mov	[edi + 0], ecx
	mov	[edi + 4], edx
	mov	ecx, [esi - 8]
	mov	edx, [esi - 12]
	mov	[edi + 8], ecx
	mov	[edi + 12], edx
	mov	ecx, [esi - 16]
	mov	edx, [esi - 20]
	mov	[edi + 16], ecx
	mov	[edi + 20], edx
	mov	ecx, [esi - 24]
	mov	edx, [esi - 28]
	mov	[edi + 24], ecx
	mov	[edi + 28], edx
	jmp	CopyPalette

Forward:
	mov	ecx, [esi + 0]		;copy the pattern from top to bottom
	mov	edx, [esi + 4]
	mov	[edi + 0], ecx
	mov	[edi + 4], edx
	mov	ecx, [esi + 8]
	mov	edx, [esi + 12]
	mov	[edi + 8], ecx
	mov	[edi + 12], edx
	mov	ecx, [esi + 16]
	mov	edx, [esi + 20]
	mov	[edi + 16], ecx
	mov	[edi + 20], edx
	mov	ecx, [esi + 24]
	mov	edx, [esi + 28]
	mov	[edi + 24], ecx
	mov	[edi + 28], edx

CopyPalette:
	mov	esi, ebp		;copy the palette into the brush
	add	edi, 32
	mov	ecx, 16
	mov	ebp, -SIZEOF(PDEV).Xtable
	cld
	rep	movsd

@@:	lea	esi, [ebx].Xtable[ebp + SIZEOF(PDEV).Xtable].ajPattern
	lea	edi, [eax].ajPattern	;check if the pattern and palette match
	mov	ecx, 8 + 16
	repe	cmpsd
	jne	NextXlate		;we still don't have a match
IF 1 ;#1308
	cmp	[ebx].Xtable[ebp + SIZEOF(PDEV).Xtable].iUniq, 0
	je	NextXlate
ENDIF
	mov	ecx, [ebx].Xtable[ebp + SIZEOF(PDEV).Xtable].xy
					;copy the cached parameters
	mov	ebx, [ebx].Xtable[ebp + SIZEOF(PDEV).Xtable].iUniq
	add	ebp, SIZEOF(PDEV).Xtable
	mov	[eax].iUniq, ebx
	mov	[eax].cache_slot, ebp
	mov	[eax].cache_xy, ecx
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	mov	eax, 1			;return TRUE
	ret	24

NextXlate:
	add	ebp, SIZEOF(XC_ENTRY)
	jnz	@B
	INVOKE	Cache4BPP,
			ebx,
			eax
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	ret	24

Error:
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	xor	eax, eax		;return FALSE
	ret	24

IF 1 ;#nbr
ChainC:
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	jmp	i386RealizeBrush
ENDIF

;-------------------------------------------------------------------------------
; RealizeMono - Realize a monochrome brush.
;
; The monochrome cache consists of a small table containing the off-screen
; location for each cache slot entry and an 8-byte pattern that is cached in
; that entry. Whenever we have to realize a monochrome brush, we first lookup
; the pattern in the cache table. If the pattern is found, we just load the
; brush with the cache parameters and return TRUE. Otherwise, we allocate a new
; cache slot and store the monochrome pattern in the cache slot and into off-
; screen memory.
;
; On entry:	EBX	Pointer to PDEV.
;		ESI	Pointer to psoPattern.
;		EBP	Pointer to translation table.
;-------------------------------------------------------------------------------
RealizeMono:
	ASSUME	ebx:PTR PDEV
	ASSUME	esi:PTR SURFOBJ
	or	ebp, ebp		;we must have a translation table
	jz	Error
	mov	edx, [pbo_]		;allocate the brush
	INVOKE	BRUSHOBJ_pvAllocRbrush,
			edx,
			SIZEOF(RBRUSH) + 8
	ASSUME	eax:PTR RBRUSH
	or	eax, eax
	jz	Error			;error

	mov	[eax].nPatSize, 8	;initialize the brush structure
	mov	[eax].iBitmapFormat, BMF_1BPP
	mov	[eax].cjMask, 0
	mov	[eax].iType, BRUSH_MONO

	mov	ecx, [ebp + 0]		;get the background color
	mov	edx, [ebp + 4]		;get the foreground color
	cmp	[ebx].iBytesPerPixel, 2	;expand the colors
	ja	XlateNone
	je	@F
	mov	ch, cl			;expand 8-bpp into 16-bit
	mov	dh, dl
@@:	mov	ebp, ecx		;expand 16-bpp into 32-bit
	mov	edi, edx
;//frido BEGIN 27-Mar-96
	and	ebp, 0000FFFFh		;mask 16-bits
	and	edi, 0000FFFFh
;//frido END 27-Mar-96
	shl	ecx, 16
	shl	edx, 16
	or	ecx, ebp
	or	edx, edi
XlateNone:
	mov	[eax].ulBackColor, ecx	;store the background color
	mov	[eax].ulForeColor, edx	;store the foreground color

	cmp	[esi].lDelta, 4		;test lDelta
	mov	esi, [esi].pvScan0	;get pointer to first scan line
	je	mForward

	mov	cl, [esi - 8]		;copy pattern into ECX/EDX bottom up
	mov	ch, [esi - 12]
	mov	dl, [esi - 24]
	mov	dh, [esi - 28]
	shl	ecx, 16
	mov	ebp, -SIZEOF(PDEV).Mtable
	shl	edx, 16
	mov	cl, [esi - 0]
	mov	ch, [esi - 4]
	mov	dl, [esi - 16]
	mov	dh, [esi - 20]
	jmp	@F

mForward:
	mov	cl, [esi + 8]		;copy pattern into ECX/EDX bottom down
	mov	ch, [esi + 12]
	mov	dl, [esi + 24]
	mov	dh, [esi + 28]
	shl	ecx, 16
	mov	ebp, -SIZEOF(PDEV).Mtable
	shl	edx, 16
	mov	cl, [esi + 0]
	mov	ch, [esi + 4]
	mov	dl, [esi + 16]
	mov	dh, [esi + 20]

@@:	mov	DWORD PTR [eax].ajPattern[0], ecx
					;store pattern in brush
	mov	DWORD PTR [eax].ajPattern[4], edx
mPTR	TEXTEQU	<ebp + SIZEOF(PDEV).Mtable>

@@:	cmp	DWORD PTR [ebx].Mtable[mPTR].ajPattern[0], ecx
					;lookup pattern in cache table
	jne	NextMono
	cmp	DWORD PTR [ebx].Mtable[mPTR].ajPattern[4], edx
	jne	NextMono
IF 1 ;#1308
	cmp	[ebx].Mtable[mPTR].iUniq, 0
	je	NextMono
ENDIF

	mov	ecx, [ebx].Mtable[mPTR].xy
					;copy the cached parameters
	mov	ebx, [ebx].Mtable[mPTR].iUniq
	add	ebp, SIZEOF(PDEV).Mtable
	mov	[eax].iUniq, ebx
	mov	[eax].cache_slot, ebp
	mov	[eax].cache_xy, ecx
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	mov	eax, 1			;return TRUE
	ret	24

NextMono:
	add	ebp, SIZEOF(MC_ENTRY)	;next table entry
	jnz	@B
;
; Cache the new brush.
;
	mov	edi, [ebx].MNext	;get the next monochrome cache slot
	mov	esi, edi
	and	edi, NUM_MONO_BRUSHES - 1
	inc	esi			;increment slot number
	imul	edi, SIZEOF(MC_ENTRY)	;build index into cache table
	mov	[ebx].MNext, esi	;stor new slot number

	mov	[eax].iUniq, esi	;store unique value
	mov	[eax].cache_slot, edi	;store index into cache table
	mov	[ebx].Mtable[edi].iUniq, esi
					;store unique value in cache table
	mov	DWORD PTR [ebx].Mtable[edi].ajPattern[0], ecx
					;store pattern in cache table
	mov	DWORD PTR [ebx].Mtable[edi].ajPattern[4], edx
	mov	esi, [ebx].Mtable[edi].xy
					;copy x/y location of brush
	mov	edi, [ebx].Mtable[edi].pjLinear
	mov	[eax].cache_xy, esi

	xor	eax, eax		;copy the swizzled bits to off-screen
	xor	ebx, ebx
	mov	al, cl
	mov	bl, ch
	shr	ecx, 16
	mov	al, [Swiz + eax]
	mov	bl, [Swiz + ebx]
	mov	[edi + 0], al
	mov	[edi + 1], bl
	mov	al, cl
	mov	bl, ch
	mov	al, [Swiz + eax]
	mov	bl, [Swiz + ebx]
	mov	[edi + 2], al
	mov	[edi + 3], bl
	mov	al, dl
	mov	bl, dh
	shr	edx, 16
	mov	al, [Swiz + eax]
	mov	bl, [Swiz + ebx]
	mov	[edi + 4], al
	mov	[edi + 5], bl
	mov	al, dl
	mov	bl, dh
	mov	al, [Swiz + eax]
	mov	bl, [Swiz + ebx]
	mov	[edi + 6], al
	mov	[edi + 7], bl

	pop	ebp
	pop	ebx
	pop	edi
	pop	esi
	mov	eax, 1			;return TRUE
	ret	24

DrvRealizeBrush ENDP

ENDIF ; USE_ASM

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\xlate.c ===
/******************************Module*Header***********************************\
*
* Module Name: Xlate.c
* Author: Noel VanHook
* Purpose: Handles hardware color translation.
*
* Copyright (c) 1997 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/xlate.c  $
*
*    Rev 1.9   Mar 04 1998 15:51:04   frido
* Added new shadow macros.
*
*    Rev 1.8   Nov 04 1997 09:50:38   frido
* Only include the code if COLOR_TRANSLATE switch is enabled.
*
*    Rev 1.7   Nov 03 1997 09:34:22   frido
* Added REQUIRE and WRITE_STRING macros.
*
*    Rev 1.6   15 Oct 1997 14:40:40   noelv
* Moved ODD[] from xlate.h to xlate.c
*
*    Rev 1.5   15 Oct 1997 12:04:52   noelv
*
* Test ROP code (only SRCCPY is supported)
* Add switch to disable frame buffer caching.
*
*    Rev 1.4   02 Oct 1997 09:42:22   noelv
* re-enabled color translation.
*
*    Rev 1.3   23 Sep 1997 17:35:14   FRIDO
*
* I have disabled color translation for now until we know what is the real
* cause.
*
*    Rev 1.2   17 Apr 1997 14:38:14   noelv
* Changed 16 bit writes to 32 bit writes in BLTDRAWDEF
*
*    Rev 1.1   19 Feb 1997 13:07:18   noelv
* Added translation table cache
*
*    Rev 1.0   06 Feb 1997 10:35:48   noelv
* Initial revision.
*/

/*
   Color translation occures under two conditions:
   1) The source bitmap has a different color depth than the destination.
   2) The source bitmap had a different palette than the destination.

   Color translation is done with a translation table.  A translation table
   is simply an array of DWORDS.  Source "pixels" are used as indices into
   the translation table.  Translation table entries are used as destination
   pixels.

   An example will clarify.  Suppose we are doing a host to screen source
   copy operation.  The host bitmap is a 4bpp bitmap.  The current screen
   mode is 8 bpp.  This operation will require color translation, so NT will
   supply a translation table.  Since a 4bpp bitmap can have 16 different
   colors, the translation table will have 16 entries.  Since the destination
   is an 8bpp bitmap, each entry will be an 8 bit color (1 byte).  Since
   translation tables are always arrays of DWORDs, the 1 byte color will be
   followed by 3 bytes of padding.

*/

#include "PreComp.h"

#define XLATE_DBG_LEVEL 1
#define CACHE_XLATE_TABLE 0

//
// Default 4-bpp translation table.
//
ULONG ulXlate[16] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
};

#if COLOR_TRANSLATE // Only include the next code if color translation is on.

//
// Table for determining bad BLTs.  See XLATE.H
//
char ODD[] = {0,1,1,1, 1,0,0,0, 0,1,1,1, 1,0,0,0};


//
// Chip bug in 5465-AA and AB
// Bring the chip to a known state before blitting to SRAM2
//
#define SRAM2_5465_WORKAROUND()                                                \
{                                                                              \
    WORD temp;                                                                 \
    while(LLDR_SZ (grSTATUS));          /* Wait for idle. */                   \
    temp = LLDR_SZ (grPERFORMANCE);     /* get the performance register. */    \
    LL16(grPERFORMANCE, (temp|0x8000)); /* toggle RES_FIFO_FLUSH */            \
    LL16(grPERFORMANCE, temp );         /* restore the performance register. */\
}





// ============================================================================
//
// vInvalidateXlateCache(PPDEV)
//
// Invalidates color translation cache
//
// ============================================================================
void vInvalidateXlateCache(PPDEV ppdev)
{

    DISPDBG((XLATE_DBG_LEVEL, "vInvalidateXlateCache: Entry.\n"));

    //
    // Whatever translation table that may have been stored in the cache has
    // been lost.  Mark the cache as empty.
    //
    ppdev->XlateCacheId = 0;

    DISPDBG((XLATE_DBG_LEVEL, "vInvalidateXlateCache: Exit.\n"));
}





// ============================================================================
//
// vInitHwXlate(PPDEV)
//
// Allocate and init scan line cache and xlate table cache.
//
// ============================================================================
void vInitHwXlate(PPDEV ppdev)
{

    DISPDBG((XLATE_DBG_LEVEL, "vInitHwXlate: Entry.\n"));

    //
    // Mark the cache as empty.
    //
    ppdev->XlateCacheId = 0;


    #if DRIVER_5465 // The 62 and 64 don't do HW xlate.
        #if CACHE_XLATE_TABLE

            //
            // Allocate a cache for color translation tables.
            //
            if (ppdev->XlateCache == NULL)
            {
                SIZEL  sizl;

                        sizl.cy = 1;
                        sizl.cx = 1024/ppdev->iBytesPerPixel;
                if (ppdev->iBytesPerPixel == 3) ++sizl.cx;

                        ppdev->XlateCache =  AllocOffScnMem(ppdev,
                                                            &sizl,
                                                            PIXEL_AlIGN,
                                                            NULL);
            }
        #endif
    #endif

    DISPDBG((XLATE_DBG_LEVEL, "vInitHwXlate: Exit.\n"));
}





// ============================================================================
//
// bCacheXlateTable()
//
// Caches a color translation table in SRAM.
// If the table is sucessfully cached, the chip is set up for hardware xlate.
//
// Returns TRUE if:
//        +  There is no color translation required,
//        +  or the color translation can be handled by hardware.
//
// Returns FALSE if:
//        + Color translation is required,
//        + and the color translation must be done in software.
//
// If a color translation table exists, *ppulXlate will be set to point to it.
// This is how we pass the translation table back to the caller.
//
// ============================================================================
BOOLEAN bCacheXlateTable(struct _PDEV *ppdev,
                        unsigned long **ppulXlate,
                        SURFOBJ  *psoTrg,
                        SURFOBJ  *psoSrc,
                        XLATEOBJ *pxlo,
                        BYTE      rop)
{
    unsigned long i, src_fmt, dst_fmt, stretch_ctrl;
    unsigned long *pulXlate;


    DISPDBG((XLATE_DBG_LEVEL, "bCacheXlateTable: Entry.\n"));


    //
    // Get the translation vector.
    //
    if ( (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) )
        pulXlate = NULL;

    else if (pxlo->flXlate & XO_TABLE)
        pulXlate = pxlo->pulXlate;
    else if (pxlo->iSrcType == PAL_INDEXED)
        pulXlate = XLATEOBJ_piVector(pxlo);
    else
    {
        // Some kind of translation we don't handle
        return FALSE;
    }


    //
    // Pass the translation table back to the caller.
    //
    *ppulXlate = pulXlate;

    //
    // If there is no color translation necessary, then we're done.
    //
    if (pulXlate == NULL)
    {
        DISPDBG((XLATE_DBG_LEVEL, "bCacheXlateTable: No color translation necessary.\n"));
        return TRUE;
    }

    //
    // The 5462 and 5464 don't do hardware color translation.
    //
    #if ! DRIVER_5465
        DISPDBG((XLATE_DBG_LEVEL,
            "bCacheXlateTable: Chip doesn't support hardware translation.\n"));
        return FALSE;
    #endif


    //
    // The 5465 only does hardware translation for rop code CC.
    //
    if (rop != 0xCC)
    {
        DISPDBG((XLATE_DBG_LEVEL,
            "bCacheXlateTable: Can't color translate ROP 0x%X.\n",
            rop));
        return FALSE;
    }


    //
    // Make sure we have an INDEXED palette
    //
    if (pxlo->iSrcType == PAL_BITFIELDS)
    {
        // I don't think we should get any of these.
        RIP("Panic!: bCacheXlateTable has PAL_BITFIELDS iSrcType.\n");
        return FALSE;
    }

    if  (pxlo->iDstType == PAL_BITFIELDS)
    {
        // I don't think we should get any of these.
        RIP ("Panic!: bCacheXlateTable has PAL_BITFIELDS iDstType.\n");
        return FALSE;
    }


    //
    // What is the source format?
    //
    ASSERTMSG(psoSrc,"bCacheXlateTable has no source object.\n");
    switch (psoSrc->iBitmapFormat)
    {
        case BMF_4BPP:  src_fmt = 5;    break;
        case BMF_8BPP:  src_fmt = 6;    break;
        default:
            // I don't think we should get any of these.
            RIP("Panic! bCacheXlateTable: Bad source format.\n");
            return FALSE;
    }


    //
    // What is the destination format?
    //
    ASSERTMSG(psoTrg,"bCacheXlateTable has no destination object.\n");
    switch (psoTrg->iBitmapFormat)
    {
        case BMF_8BPP:  dst_fmt = 0;    break;
        case BMF_16BPP: dst_fmt = 2;    break;
        case BMF_24BPP: dst_fmt = 3;    break;
        case BMF_32BPP: dst_fmt = 4;    break;
        default:
            // I don't think we should get any of these.
            RIP("Panic! bCacheXlateTable: Bad destination  format.\n");
            return FALSE;
    }

#if CACHE_XLATE_TABLE
    //
    // Have we cached this table already?
    //
    if (ppdev->XlateCacheId == pxlo->iUniq)
    {
        ULONG num_dwords = ( (pxlo->cEntries == 16) ? 64 : 256);

        DISPDBG((XLATE_DBG_LEVEL,
            "bCacheXlateTable: Table is already cached. ID=%d.\n", pxlo->iUniq));

        // Yep.  Refresh SRAM2 in case it was destroyed.
        // Blt from frame buffer cache into SRAM2
        ASSERTMSG( (ppdev->XlateCache != NULL),
            "bCacheXlateTable: Xlate cache pointer is NULL.\n");

        // Blt the table from the frame buffer cache to SRAM2
        SRAM2_5465_WORKAROUND();
        REQUIRE(9);
        LL_DRAWBLTDEF(0x601000CC, 2);  // SRC COPY
        LL_OP0(0,0);              // Dest location
        LL_OP1(ppdev->XlateCache->x,ppdev->XlateCache->y); // Src location
        LL_MBLTEXT( num_dwords, 1);

    }

    //
    // If not, can we cache it?
    //
    else if (ppdev->XlateCache != NULL)
    {
        DISPDBG((XLATE_DBG_LEVEL,
            "bCacheXlateTable: Caching table.  ID = %d.\n", pxlo->iUniq));

        // Store the translation table in the offscreen cache,
        REQUIRE(9);
        LL_DRAWBLTDEF(0x102000CC, 2);  // SRC COPY
        LL_OP0(ppdev->XlateCache->x,ppdev->XlateCache->y); // Dest
        LL_OP1(0,0);              // Source Phase.
        LL_MBLTEXT( (pxlo->cEntries*4), 1); // 4 bytes per table entry
                WRITE_STRING(pulXlate, pxlo->cEntries);

        // Make sure the table is the expected size.
        if ((pxlo->cEntries != 16) && (pxlo->cEntries != 256))
        {
            // Since we only do 4 and 8 bpp source, this shouldn't happen.
            RIP("Panic! bCacheXlateTable: Wrong number of entries in the table.\n");
            return FALSE;
        }

        // Blt the table from the frame buffer cache to SRAM2
        SRAM2_5465_WORKAROUND();
        REQUIRE(9);
        LL_DRAWBLTDEF(0x601000CC, 2);  // SRC COPY
        LL_OP0(0,0);              // Dest location
        LL_OP1(ppdev->XlateCache->x,ppdev->XlateCache->y); // Src location
        LL_MBLTEXT( (pxlo->cEntries*4), 1); // 4 bytes per table entry

        // Store the ID.
        ppdev->XlateCacheId = pxlo->iUniq;

    }


    //
    // Nope. Skip the frame buffer cache.
    //
    else
#endif
    {
        DISPDBG((XLATE_DBG_LEVEL, "bCacheXlateTable: Bypassing cache.\n"));

        //
        // There is no xlate table cache in the frame buffer.
        // Load the table directly from the host to the SRAM.
        //

        // Make sure the table is the expected size.
        ASSERTMSG( ((pxlo->cEntries==16) || (pxlo->cEntries == 256)),
                "XLATE.C: XLATE table has wrong number of entries.\n");
        //if ((pxlo->cEntries != 16) && (pxlo->cEntries != 256))
        //{
        //    // Since we only do 4 and 8 bpp source, this shouldn't happen.
        //    RIP("Panic! bCacheXlateTable: Wrong number of entries in the table.\n");
        //    return FALSE;
        //}


        // BLT the translation table into SRAM2 on the chip.
        SRAM2_5465_WORKAROUND();
        REQUIRE(9);
        LL32_DRAWBLTDEF(0x602000CC, 2);  // SRC COPY
        LL_OP0(0,0);              // SRAM location
        LL_OP1(0,0);              // Source Phase.
        LL_MBLTEXT( (pxlo->cEntries*4), 1); // 4 bytes per table entry

        // Now supply the table.
                WRITE_STRING(pulXlate, pxlo->cEntries);
    }



    //
    // Cache successful.
    // Set up the chip to use hardware xlate.
    //
    stretch_ctrl =  0                // Use NT style table.
                  | (src_fmt << 12)  // source pixel format
                  | (dst_fmt << 8);  // destination pixel format.
    REQUIRE(2);
    LL16(grSTRETCH_CNTL, stretch_ctrl);
    LL16(grCHROMA_CNTL, 0);  // disable chroma compare.


    DISPDBG((XLATE_DBG_LEVEL, "bCacheXlateTable: Exit - success.\n"));
    return TRUE;
}
#endif //!COLOR_TRANSLATE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\textout.c ===
/******************************Module*Header*******************************\
*
* Module Name: TEXTOUT.c
* Author: Martin Barber
* Date: Jun. 19, 1995
* Purpose: Handle calls to DrvTxtOut
*
* Copyright (c) 1995,1996 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/TEXTOUT.C  $
*
*    Rev 1.34   Mar 27 1998 14:47:14   frido
* PDR#11280. In the monospaced font loop there was a problem loading
* the pointer to the next glyph bits. It always got the pointer to the
* previous glyph.
*
*    Rev 1.33   Mar 04 1998 15:38:46   frido
* Added new shadow macros.
*
*    Rev 1.32   Dec 17 1997 16:42:14   frido
* PDR#10875: There was a GPF inside vMmClipGlyphExpansion and NT
* 3.51 does not handle this very well. It caused the hardware to wait for
* another DWORD which was never send.
*
*    Rev 1.31   Dec 10 1997 13:32:20   frido
* Merged from 1.62 branch.
*
*    Rev 1.30.1.1   Dec 03 1997 18:12:20   frido
* PDR#11039. Fixed allocation of font cache. In certain cases it would
* allocate too few cells and still use the unallocated cells causing
* corruption.
*
*    Rev 1.30.1.0   Nov 18 1997 15:40:16   frido
* Changed a spelling error: RWQUIRE into REQUIRE.
*
*    Rev 1.30   Nov 03 1997 10:17:36   frido
* Added REQUIRE and WRITE_STRING macros.
* Removed CHECK_QFREE macros.
*
*    Rev 1.29   25 Aug 1997 16:07:24   FRIDO
*
* Fixed lockup in 8-bpp vMmClipGlyphExpansion SWAT7 code.
*
*    Rev 1.28   08 Aug 1997 17:24:30   FRIDO
* Added support for new memory manager.
* Added SWAT7 switches for 8-bpp hardware bug.
*
*    Rev 1.27   29 Apr 1997 16:28:50   noelv
*
* Merged in new SWAT code.
* SWAT:
* SWAT:    Rev 1.7   24 Apr 1997 12:05:38   frido
* SWAT: Fixed a missing "}".
* SWAT:
* SWAT:    Rev 1.6   24 Apr 1997 11:22:18   frido
* SWAT: NT140b09 merge.
* SWAT: Changed pfm into pCell for SWAT3 changes.
* SWAT:
* SWAT:    Rev 1.5   19 Apr 1997 17:11:02   frido
* SWAT: Added SWAT.h include file.
* SWAT: Fixed a bug in DrvDestroyFont causing hangups in 2nd WB97 pass.
* SWAT:
* SWAT:    Rev 1.4   18 Apr 1997 00:34:28   frido
* SWAT: Fixed a merge bug.
* SWAT:
* SWAT:    Rev 1.3   18 Apr 1997 00:15:28   frido
* SWAT: NT140b07 merge.
* SWAT:
* SWAT:    Rev 1.2   10 Apr 1997 16:02:06   frido
* SWAT: Oops, I allocated the font cache in the wrong size.
* SWAT:
* SWAT:    Rev 1.1   09 Apr 1997 17:37:30   frido
* SWAT: New font cache allocation scheme.  Allocate from a 'pool' of cells
* SWAT: instead of putting the font cache all over the place.
*
*    Rev 1.26   08 Apr 1997 12:32:50   einkauf
*
* add SYNC_W_3D to coordinate MCD/2D hw access
*
*    Rev 1.25   21 Mar 1997 13:37:06   noelv
* Added checkes for QFREE.
*
*    Rev 1.24   06 Feb 1997 10:38:04   noelv
* Removed WAIT_FOR_IDLE
*
*    Rev 1.23   04 Feb 1997 11:11:00   SueS
* Added support for hardware clipping for the 5465.
*
*    Rev 1.22   17 Dec 1996 16:59:00   SueS
* Added test for writing to log file based on cursor at (0,0).
*
*    Rev 1.21   26 Nov 1996 10:46:36   SueS
* Changed WriteLogFile parameters for buffering.
*
*    Rev 1.20   13 Nov 1996 17:01:28   SueS
* Changed WriteFile calls to WriteLogFile.
*
*    Rev 1.19   07 Nov 1996 16:10:16   bennyn
*
* Added no offscn mem allocation if DD enabled
*
*    Rev 1.18   06 Sep 1996 15:16:44   noelv
* Updated NULL driver for 4.0
*
*    Rev 1.17   20 Aug 1996 11:04:36   noelv
* Bugfix release from Frido 8-19-96
*
*    Rev 1.3   16 Aug 1996 14:48:20   frido
* Fixed a small wanring error.
*
*    Rev 1.2   15 Aug 1996 11:54:32   frido
* Fixed precompiled headers.
*
*    Rev 1.1   15 Aug 1996 11:38:32   frido
* Added precompiled header.
*
*    Rev 1.0   14 Aug 1996 17:16:32   frido
* Initial revision.
*
*    Rev 1.16   25 Jul 1996 15:56:28   bennyn
*
* Modified to support DirectDraw
*
*    Rev 1.15   28 May 1996 15:11:36   noelv
* Updated data logging.
*
*    Rev 1.14   16 May 1996 15:06:18   bennyn
*
* Added PIXEL_ALIGN to allocoffscnmem()
*
*    Rev 1.13   16 May 1996 14:54:32   noelv
* Added logging code.
*
*    Rev 1.12   03 May 1996 15:09:42   noelv
*
* Added flag to turn caching on and off.
*
*    Rev 1.11   01 May 1996 11:01:48   bennyn
*
* Modified for NT4.0
*
*    Rev 1.10   12 Apr 1996 18:13:06   andys
* Fixed bug in combining 3 bytes into DWORD (<< | bug)
*
*    Rev 1.9   11 Apr 1996 18:00:56   andys
* Added Code to the > 16 PEL case to guard against walking off the end of a b
*
*    Rev 1.8   04 Apr 1996 13:20:32   noelv
* Frido release 26
 *
 *    Rev 1.16   01 Apr 1996 15:29:22   frido
 * Fixed bug in font cache when glyph cannot be cached.
 *
 *    Rev 1.15   28 Mar 1996 23:37:34   frido
 * Fixed drawing of partially left-clipped glyphs.
 *
 *    Rev 1.14   27 Mar 1996 14:12:18   frido
 * Commented changes.
 *
 *    Rev 1.13   25 Mar 1996 11:58:38   frido
 * Removed warning message.
 *
 *    Rev 1.12   25 Mar 1996 11:50:42   frido
 * Bellevue 102B03.
*
*    Rev 1.5   18 Mar 1996 12:34:10   noelv
*
* Added data logging stuff
*
*    Rev 1.4   07 Mar 1996 18:24:14   bennyn
*
* Removed read/modify/write on CONTROL reg
*
*    Rev 1.3   05 Mar 1996 11:59:20   noelv
* Frido version 19
*
*    Rev 1.11   04 Mar 1996 20:23:28   frido
* Cached grCONTROL register.
*
*    Rev 1.10   29 Feb 1996 20:23:08   frido
* Changed some comments.
*
*    Rev 1.9   28 Feb 1996 22:39:46   frido
* Added Optimize.h.
*
*    Rev 1.8   27 Feb 1996 16:38:12   frido
* Added device bitmap store/restore.
*
*    Rev 1.7   24 Feb 1996 01:23:16   frido
* Added device bitmaps.
*
*    Rev 1.6   03 Feb 1996 13:57:24   frido
* Use the compile switch "-Dfrido=0" to disable my extensions.
*
*    Rev 1.5   03 Feb 1996 12:17:58   frido
* Added text clipping.
*
*    Rev 1.4   25 Jan 1996 12:45:56   frido
* Added reinitialization of font cache after mode switch.
*
*    Rev 1.3   24 Jan 1996 23:10:16   frido
* Moved font cache and entry point to assembly for i386.
*
*    Rev 1.2   23 Jan 1996 15:37:20   frido
* Added font cache.
*
\**************************************************************************/

#include "precomp.h"
#include "font.h"
#include "SWAT.h"               // SWAT optimizations

#define TEXT_DBG_LEVEL  1
#define TEXT_DBG_LEVEL1 1
#define RECORD_ON               FALSE
#define BUFFER_EXPAND   FALSE


/*
-------------------------------------------------------------------------------
Module Entry Points:
--------------------
    DrvTextOut()

General Plan:
--------------------
*
* On every TextOut, GDI provides an array of 'GLYPHPOS' structures
* for every glyph to be drawn.  Each GLYPHPOS structure contains a
* the glyph.    (Note that unlike Windows 3.1, which provides a column-
* major glyph bitmap, Windows NT always provides a row-major glyph
* bitmap.)  As such, there are three basic methods for drawing text
* with hardware acceleration:
*
* 1) Glyph caching -- Glyph bitmaps are cached by the accelerator
*       (probably in off-screen memory), and text is drawn by
*       referring the hardware to the cached glyph locations.
*
* 2) Glyph expansion -- Each individual glyph is colour-expanded
*       directly to the screen from the monochrome glyph bitmap
*       supplied by GDI.
*
* 3) Buffer expansion -- The CPU is used to draw all the glyphs into
*       a 1bpp monochrome bitmap, and the hardware is then used
*       to colour-expand the result.
*
* The fastest method depends on a number of variables, such as the
* colour expansion speed, bus speed, CPU speed, average glyph size,
* and average string length.
*
* Copyright (c) 1992-1994 Microsoft Corporation
*
\**************************************************************************/

//
// Data logging stuff.
// Gets compiled out in a free bulid.
//
#if LOG_CALLS
    char BUF[256];

    #if ENABLE_LOG_SWITCH
    #define LogFile(x)                      \
    do {                            \
        if (pointer_switch == 1)                           \
        {                                                       \
    int i = sprintf x ;                     \
        WriteLogFile(ppdev->pmfile, BUF, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);  \
        }                                                       \
    } while(0);                         \

    #else
    #define LogFile(x)                      \
    do {                            \
    int i = sprintf x ;                     \
        WriteLogFile(ppdev->pmfile, BUF, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);  \
    } while(0);                         \

    #endif
#else
    #define BUF 0
    #define LogFile(x)
#endif



POINTL gptlZero = { 0, 0 }; // Specifies that the origin of the
                //  temporary buffer given to the 1bpp
                //  transfer routine for fasttext is
                //  at (0, 0)

/******************************Public*Routine******************************\
* void AddToFontCacheChain
*
* Add the FONTCACHE to the Font cache chain
*
\**************************************************************************/
void AddToFontCacheChain(PDEV*       ppdev,
                         FONTOBJ*    pfo,
                         PFONTCACHE  pfc)
{
        DISPDBG((TEXT_DBG_LEVEL1," AddToFontCacheChain.\n"));

        pfc->pfo = pfo;

#if !SWAT3 // We don't need this anymore.  The cell grid has all the pointers.
        // Hook the font cache into the chain.
        if (ppdev->pfcChain != NULL)
        {
                ppdev->pfcChain->pfcPrev = pfc;
        }

        pfc->pfcPrev = NULL;
        pfc->pfcNext = ppdev->pfcChain;
        ppdev->pfcChain = pfc;
#endif
}


/******************************Public*Routine******************************\
* BOOL bIntersect
*
* If 'prcl1' and 'prcl2' intersect, has a return value of TRUE and returns
* the intersection in 'prclResult'. If they don't intersect, has a return
* value of FALSE, and 'prclResult' is undefined.
*
\**************************************************************************/

BOOL bIntersect(
RECTL*  prcl1,
RECTL*  prcl2,
RECTL*  prclResult)
{
    DISPDBG((TEXT_DBG_LEVEL1," bIntersect.\n"));

    prclResult->left    = max(prcl1->left, prcl2->left);
    prclResult->right   = min(prcl1->right, prcl2->right);

    if (prclResult->left < prclResult->right)
    {
    prclResult->top = max(prcl1->top, prcl2->top);
    prclResult->bottom = min(prcl1->bottom, prcl2->bottom);

    if (prclResult->top < prclResult->bottom)
    {
        return(TRUE);
    }
    }

    return(FALSE);
}




/******************************Public*Routine******************************\
* LONG cIntersect
*
* This routine takes a list of rectangles from 'prclIn' and clips them
* in-place to the rectangle 'prclClip'. The input rectangles don't
* have to intersect 'prclClip'; the return value will reflect the
* number of input rectangles that did intersect, and the intersecting
* rectangles will be densely packed.
*
\**************************************************************************/

LONG cIntersect(
    RECTL*  prclClip,
    RECTL*  prclIn,     // List of rectangles
    LONG    c)          // Can be zero
{
    LONG    cIntersections;
    RECTL*  prclOut;

    DISPDBG((TEXT_DBG_LEVEL1," cIntersect.\n"));
    cIntersections = 0;
    prclOut = prclIn;

    for ( ; c != 0; prclIn++, c--)
    {
        prclOut->left  = max(prclIn->left,  prclClip->left);
        prclOut->right = min(prclIn->right, prclClip->right);

        if (prclOut->left < prclOut->right)
        {
            prclOut->top    = max(prclIn->top,    prclClip->top);
            prclOut->bottom = min(prclIn->bottom, prclClip->bottom);

            if (prclOut->top < prclOut->bottom)
            {
                prclOut++;
                cIntersections++;
            }
        }
    }

    return(cIntersections);
}




/******************************Public*Routine******************************\
* VOID vClipSolid
*
* Fills the specified rectangles with the specified colour, honouring
* the requested clipping.  No more than four rectangles should be passed in.
* Intended for drawing the areas of the opaquing rectangle that extend
* beyond the text box.  The rectangles must be in left to right, top to
* bottom order. Assumes there is at least one rectangle in the list.
*
\**************************************************************************/

VOID vClipSolid(
    PDEV*       ppdev,
    LONG        crcl,
    RECTL*      prcl,
    ULONG       iColor,
    CLIPOBJ*    pco)
{
    BOOL        bMore;  // Flag for clip enumeration
    ENUMRECTS8  ce;     // Clip enumeration object
    ULONG       i;
    ULONG       j;
    #if !(DRIVER_5465 && HW_CLIPPING)
        RECTL       arclTmp[4];
        ULONG       crclTmp;
        RECTL*      prclTmp;
        RECTL*      prclClipTmp;
        LONG        iLastBottom;
    #endif
    RECTL*      prclClip;

    DISPDBG((TEXT_DBG_LEVEL1,"vClipSolid: Entry.\n"));
    ASSERTMSG( (crcl > 0) && (crcl <= 4), "Expected 1 to 4 rectangles");
    ASSERTMSG( (pco != NULL) && (pco->iDComplexity != DC_TRIVIAL),
                "Expected a non-null clip object");

    // Do the loop invariant setup here
    REQUIRE(2);
    LL_DRAWBLTDEF(SOLID_COLOR_FILL, 2);

    if (pco->iDComplexity == DC_RECT)
    {
        crcl = cIntersect(&pco->rclBounds, prcl, crcl);
        while (crcl--)
        {
            REQUIRE(5);
            LL_OP0(prcl->left + ppdev->ptlOffset.x,
                prcl->top + ppdev->ptlOffset.y);
            LL_BLTEXT((prcl->right - prcl->left), (prcl->bottom - prcl->top));
            prcl++;
        }
    }

    else // iDComplexity == DC_COMPLEX
    {
        // Initialize the clip rectangle enumeration to right-down so we can
        // take advantage of the rectangle list being right-down:

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN, 0);

        #if DRIVER_5465 && HW_CLIPPING
            // Set up the hardware clipping
            REQUIRE(6);
            LL_DRAWBLTDEF(SOLID_COLOR_FILL | DD_CLIPEN, 0);
            i = max(0, prcl->left);
            j = max(0, prcl->top);
            LL_OP0(i + ppdev->ptlOffset.x, j + ppdev->ptlOffset.y);
            LL_BLTEXT_EXT(prcl->right - i, prcl->bottom - j);

            do
            {
               // Get a batch of region rectangles:
               bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*)&ce);

               // Clip the rect list to each region rect:
               for (j = ce.c, prclClip = ce.arcl; j-- > 0; prclClip++)
               {
                    // Draw the clipped rects
                    REQUIRE(5);
                    LL_CLIPULE(prclClip->left + ppdev->ptlOffset.x,
                    prclClip->top + ppdev->ptlOffset.y);
                    LL_CLIPLOR_EX(prclClip->right + ppdev->ptlOffset.x,
                    prclClip->bottom + ppdev->ptlOffset.y);

               } // End for each rectangle in the list.

            } while (bMore); // End loop for each batch
        #else

            // Bottom of last rectangle to fill
            iLastBottom = prcl[crcl - 1].bottom;

            // Scan through all the clip rectangles, looking for intersects
            // of fill areas with region rectangles:

            do
            {
                // Get a batch of region rectangles:
                bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*)&ce);

                // Clip the rect list to each region rect:
                for (j = ce.c, prclClip = ce.arcl; j-- > 0; prclClip++)
                {
                    // Since the rectangles and the region enumeration are both
                    // right-down, we can zip through the region until we reach
                    // the first fill rect, and are done when we've passed the
                    // last fill rect.

                    if (prclClip->top >= iLastBottom)
                    {
                        // Past last fill rectangle; nothing left to do:
                        return;
                    }

                    // Do intersection tests only if we've reached the top of
                    // the first rectangle to fill:

                    if (prclClip->bottom > prcl->top)
                    {
                        // We've reached the top Y scan of the first rect, so
                        // it's worth bothering checking for intersection.

                        // Generate a list of the rects clipped to this region
                        // rect:

                        prclTmp = prcl;
                        prclClipTmp = arclTmp;

                        for (i = crcl, crclTmp = 0; i-- != 0; prclTmp++)
                        {
                            // Intersect fill and clip rectangles

                            if (bIntersect(prclTmp, prclClip, prclClipTmp))
                            {
                                // Draw the clipped rects
                                REQUIRE(5);
                                LL_OP0(prclClipTmp->left + ppdev->ptlOffset.x,
                                    prclClipTmp->top + ppdev->ptlOffset.y);
                                LL_BLTEXT ( (prclClipTmp->right - prclClipTmp->left) ,
                                    (prclClipTmp->bottom - prclClipTmp->top) );
                             }

                        } // End for each rectangle in the batch.

                    } // End intersect test.

                } // End for each rectangle in the list.

            } while (bMore); // End loop for each batch
        #endif   // if !(DRIVER_5465 && HW_CLIPPING)

    } // End DC_COMPLEX

}

#if SWAT7
/******************************Public*Routine******************************\
* VOID Xfer64Pixels
*
* Copy 64 pixels of font data to the Laguna memory.
*
\**************************************************************************/

VOID Xfer64Pixels(
        PDEV*   ppdev,
        UINT    x,
        UINT    y,
        UINT    bitOffset,
        UINT    height,
        BYTE*   pjGlyph,
        UINT    delta
)
{
        delta = (delta + 7) >> 3;

        REQUIRE(5);
        LL_OP0(x + ppdev->ptlOffset.x, y + ppdev->ptlOffset.y);
        LL_BLTEXT(64, height);

        while (height--)
        {
                REQUIRE(3);
                LL32(grHOSTDATA[0], *(ULONG*) &pjGlyph[0]);
                LL32(grHOSTDATA[1], *(ULONG*) &pjGlyph[4]);
                if (bitOffset > 0)
                {
                        LL32(grHOSTDATA[2], pjGlyph[8]);
                }
                pjGlyph += delta;
        }
}
#endif

/******************************Public*Routine******************************\
* VOID vMmClipGlyphExpansion
*
* Handles any strings that need to be clipped, using the 'glyph
* expansion' method.
*
\**************************************************************************/

VOID vMmClipGlyphExpansion(
PDEV*    ppdev,
STROBJ* pstro,
CLIPOBJ*    pco)
{
    BOOL        bMoreGlyphs;
    ULONG       cGlyphOriginal;
    ULONG       cGlyph;
    GLYPHPOS*   pgpOriginal;
    GLYPHPOS*   pgp;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    ENUMRECTS8  ce;
    RECTL*      prclClip;
    ULONG       ulCharInc;
    LONG        cxGlyph;
    LONG        cyGlyph;
    BYTE*       pjGlyph;
    BYTE*       pTmp;
    LONG        cj;
    LONG        cw;
    LONG        xLeft;
    LONG        yTop;
    LONG        xRight;
    LONG        yBottom;
    LONG        xBias;
    LONG        lDelta;
    LONG        cx;
    LONG        cy;
#if SWAT7
        UINT            xOrigin;
#endif

    DISPDBG((TEXT_DBG_LEVEL1,"vMmClipGlyphExpansion: Entry.\n"));

    ASSERTMSG(pco != NULL, "Don't expect NULL clip objects here");

    do // Loop for each batch of glyphs to be done.
    {
        //
        // Get a batch of glyphs.
        //

        if (pstro->pgp != NULL)
        {
            // There's only the one batch of glyphs, so save ourselves
            // a call:

            pgpOriginal = pstro->pgp;
            cGlyphOriginal = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
        }

        //
        // cGlyphOrigional is the number of glyphs in the batch before they
        // are clipped.
        // bMoreGlyphs is TRUE if there are more batches to be done after
        // this one.
        //

        if (cGlyphOriginal > 0) // Were there any glyphs in the batch?
        {
            ulCharInc = pstro->ulCharInc;

            if (pco->iDComplexity == DC_RECT)
            {
                //
                // We could call 'cEnumStart' and 'bEnum' when the clipping is
                // DC_RECT, but the last time I checked, those two calls took
                // more than 150 instructions to go through GDI. Since
                // 'rclBounds' already contains the DC_RECT clip rectangle,
                // and since it's such a common case, we'll special case it:
                //

                bMore    = FALSE; // No more clip lists to do.
                prclClip = &pco->rclBounds;
                ce.c     = 1;     // Only one rectangle in this list.

                goto SingleRectangle;
            }

            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

            do // For each list of rectangles.
            {
                bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                // For each rectangle in the list.
                for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
                {
                    SingleRectangle:

                    pgp    = pgpOriginal;
                    cGlyph = cGlyphOriginal;
                    pgb    = pgp->pgdf->pgb;

                    ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
                    ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

                    // Loop through all the glyphs for this rectangle:
                    while (TRUE)
                    {
                        LogFile((BUF, "GC:M\r\n"));

                        cxGlyph = pgb->sizlBitmap.cx;
                        cyGlyph = pgb->sizlBitmap.cy;

                        pjGlyph = pgb->aj;
                                                #if SWAT7
                                                lDelta  = (cxGlyph + 7) >> 3;
                                                #endif

                        if ((prclClip->left <= ptlOrigin.x) &&
                            (prclClip->top  <= ptlOrigin.y) &&
                            (prclClip->right  >= ptlOrigin.x + cxGlyph) &&
                            (prclClip->bottom >= ptlOrigin.y + cyGlyph))
                        {
                            //-----------------------------------------------------
                            // Unclipped glyph

                                                        #if SWAT7
                                                        xOrigin = ptlOrigin.x;
                                                        #endif

                                                        #if SWAT7
                                                        //
                                                        // Test for 5465AD hardware bug in 8-bpp.
                                                        //
                                                        if (   (cxGlyph > 64) && (cxGlyph < 128)
                                                                && (ppdev->iBytesPerPixel == 1)
                                                        )
                                                        {
                                                                Xfer64Pixels(ppdev, xOrigin, ptlOrigin.y, 0,
                                                                                cyGlyph, pjGlyph, cxGlyph);
                                                                pjGlyph += 64 / 8;
                                                                xOrigin += 64;
                                                                cxGlyph -= 64;
                                                        }
                            REQUIRE(5);
                            LL_OP0(xOrigin + ppdev->ptlOffset.x,
                                                                   ptlOrigin.y + ppdev->ptlOffset.y);
                                                        #else
                            REQUIRE(5);
                            LL_OP0(ptlOrigin.x + ppdev->ptlOffset.x,
                                    ptlOrigin.y + ppdev->ptlOffset.y);
                                                        #endif
                            LL_BLTEXT(cxGlyph, cyGlyph);

                            if (cxGlyph <= 8)
                            {
                                //-----------------------------------------------------
                                // 1 to 8 pels in width

                                while ( cyGlyph-- )
                                {
                                    REQUIRE(1);
                                                                        #if SWAT7
                                    LL32 (grHOSTDATA[0], *pjGlyph);
                                                                        pjGlyph += lDelta;
                                                                        #else
                                    LL32 (grHOSTDATA[0], *pjGlyph++);
                                                                        #endif
                                                                }

                            }

                            else if (cxGlyph <= 16)
                            {
                                //-----------------------------------------------------
                                // 9 to 16 pels in width

                                while ( cyGlyph-- )
                                {
                                    REQUIRE(1);
                                                                        #if SWAT7
                                    LL32 (grHOSTDATA[0], *(USHORT*)pjGlyph);
                                                                        pjGlyph += lDelta;
                                                                        #else
                                    LL32 (grHOSTDATA[0], *((USHORT*)pjGlyph)++);
                                                                        #endif
                                                                }
                            }

                            else
                            {
                                //-----------------------------------------------------
                                // More than 16 pels in width

                                                                #if SWAT7
                                                                cw = (cxGlyph + 31) >> 5;
                                                                #else
                                lDelta = (pgb->sizlBitmap.cx + 7) >> 3;
                                cw   = (lDelta + 3) >> 2;
                                                                #endif
                                pTmp = pjGlyph + lDelta * pgb->sizlBitmap.cy;

                                for (;cyGlyph!=1; cyGlyph--)
                                {
                                                                        WRITE_STRING(pjGlyph, cw);
                                    pjGlyph += lDelta;
                                }

                                {
                                    ULONG *pSrc = (ULONG*) pjGlyph + cw - 1;
                                                                        WRITE_STRING(pjGlyph, cw - 1);

                                    if ((BYTE *)pSrc+4<=pTmp)
                                    {
                                        REQUIRE(1);
                                        LL32 (grHOSTDATA[0], *pSrc++ );
                                    }
                                    else
                                    {
                                        int Extra = (ULONG) pTmp - (ULONG) pSrc;
                                        BYTE * pByte = (BYTE *)pSrc;
                                        ULONG ulData;

                                        DISPDBG((TEXT_DBG_LEVEL1,
                                            "Caught it %s %d %d %x %x\n", __FILE__, __LINE__, Extra, pTmp, pSrc));

                                        if (Extra == 1)
                                            ulData = (ULONG)(*pByte);
                                        else if (Extra == 2)
                                            ulData = (ULONG)(*(USHORT*)pByte);
                                        else
                                            ulData = (((ULONG)*(pByte+2) << 8) | (ULONG)*(pByte+1)) << 8 | *pByte;

                                        REQUIRE(1);
                                        LL32 (grHOSTDATA[0], ulData );
                                    }
                                }
                            } // End 16 pels or wider.
                        } // End unclipped glyph.

                        else
                        {
                            //-----------------------------------------------------
                            // Clipped glyph

                            // Find the intersection of the glyph rectangle
                            // and the clip rectangle:

                            xLeft   = max(prclClip->left,   ptlOrigin.x);
                            yTop    = max(prclClip->top,    ptlOrigin.y);
                            xRight  = min(prclClip->right,  ptlOrigin.x + cxGlyph);
                            yBottom = min(prclClip->bottom, ptlOrigin.y + cyGlyph);

                            // Check for trivial rejection:
                            if (((cx = xRight - xLeft) > 0) &&
                                ((cy = yBottom - yTop) > 0))
                            {

                                xBias = (xLeft - ptlOrigin.x) & 7;

                                // 'xBias' is the bit position in the monochrome glyph
                                // bitmap of the first pixel to be lit, relative to
                                // the start of the byte.   That is, if 'xBias' is 2,
                                // then the first unclipped pixel is represented by bit
                                // 2 of the corresponding bitmap byte.
                                //
                                // Normally, the accelerator expects bit 0 to be the
                                // first lit byte.  We set the host phase to discard the
                                // first 'xBias' bits.
                                //

                                if ( xBias )
                                {
                                    REQUIRE(2);
                                    LL_OP2_MONO (xBias,0);
                                }

                                                                #if !SWAT7
                                REQUIRE(5);
                                LL_OP0(xLeft + ppdev->ptlOffset.x,
                                        yTop + ppdev->ptlOffset.y);
                                LL_BLTEXT (cx, cy);
                                                                #endif

                                lDelta   = (cxGlyph + 7) >> 3;

                                // compute the end-of-glyph marker before
                                // clipping the glyph.
                                pTmp = pjGlyph + lDelta * cy;

                                pjGlyph += (yTop - ptlOrigin.y) * lDelta
                                     + ((xLeft - ptlOrigin.x) >> 3);

                                                                #if SWAT7
                                                                //
                                                                // Test for 5465AD hardware bug in 8-bpp.
                                                                //
                                                                if (   (cx > 64) && (cx < 128)
                                                                        && (ppdev->iBytesPerPixel == 1)
                                                                )
                                                                {
                                                                        Xfer64Pixels(ppdev, xLeft, yTop, xBias, cy,
                                                                                        pjGlyph, cxGlyph);
                                                                        pjGlyph += 64 / 8;
                                                                        xLeft += 64;
                                                                        cx -= 64;
                                                                }

                                REQUIRE(5);
                                LL_OP0(xLeft + ppdev->ptlOffset.x,
                                                                           yTop + ppdev->ptlOffset.y);
                                LL_BLTEXT (cx, cy);
                                                                #endif

                                cj = (cx + xBias + 31) >> 5;

                                for (;cy!=1; cy--)
                                {
                                                                        WRITE_STRING(pjGlyph, cj);
                                    pjGlyph += lDelta;
                                }

                                {
                                    ULONG *pSrc = (ULONG*) pjGlyph + cj - 1;

                                    int Extra = (ULONG) pTmp - (ULONG) pSrc;
                                    BYTE * pByte = (BYTE *)pSrc;
                                    ULONG ulData;

                                                                        WRITE_STRING(pjGlyph, cj - 1);

                                    if (Extra == 1)
                                        ulData = (ULONG)(*pByte);
                                    else if (Extra == 2)
                                        ulData = (ULONG)(*(USHORT*)pByte);
                                    else if (Extra == 3)
                                        ulData = (((ULONG)*(pByte+2) << 8) | (ULONG)*(pByte+1)) << 8 | *pByte;
                                                                        else
                                                                                ulData = *pSrc;

                                    REQUIRE(1);
                                    LL32 (grHOSTDATA[0], ulData );
                                }

                                if (xBias != 0)
                                {
                                    REQUIRE(2);
                                    LL_OP2_MONO(0,0);
                                }

                            } // if not trivially rejected.

                        } // End clipped glyph.

                        //
                        // If we're out of glyphs the get next batch.
                        if (--cGlyph == 0)
                            break;

                        // Get ready for next glyph:
                        pgp++;
                        pgb = pgp->pgdf->pgb;

                        //
                        // Calculate where to place the next glyph.
                        // If this is mono spaced text, we may need to
                        // skip over some pixels to make our characters
                        // line up.
                        //
                        if (ulCharInc == 0)
                        {
                            ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
                            ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
                        }
                        else
                        {
                            ptlOrigin.x += ulCharInc;
                        }

                    } // End loop for each glyph in the batch.

                } // End for each rectangle in the list.

            } while (bMore); // Loop for each batch of clipping rectangles.

        } // If there were any glyphs in this batch.

    } while (bMoreGlyphs); // Loop for each batch of glyphs.

} // End clipped glyph expansion.




/******************************Public*Routine******************************\
* BOOL DrvTextOut
*
* If it's the fastest method, outputs text using the 'glyph expansion'
* method.   Each individual glyph is colour-expanded directly to the
* screen from the monochrome glyph bitmap supplied by GDI.
*
* If it's not the fastest method, calls the routine that implements the
* 'buffer expansion' method.
*
\**************************************************************************/

#if (USE_ASM && defined(i386))
BOOL i386DrvTextOut(
#else
BOOL APIENTRY DrvTextOut(
#endif
SURFOBJ*    pso,
STROBJ*     pstro,
FONTOBJ*    pfo,
CLIPOBJ*    pco,
RECTL*      prclExtra,  // If we had set GCAPS_HORIZSTRIKE, we would have
                // to fill these extra rectangles (it is used
                // largely for underlines). It's not a big
                // performance win (GDI will call our DrvBitBlt
                // to draw the extra rectangles).
RECTL*      prclOpaque,
BRUSHOBJ*   pboFore,
BRUSHOBJ*   pboOpaque,
POINTL*     pptlBrush,
MIX         mix)
{
    PDEV*           ppdev;
    BOOL            bTextPerfectFit;
    ULONG           cGlyph;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgp;
    GLYPHBITS*      pgb;
    BYTE*           pjGlyph;
    BYTE*           pTmp;
        #if SWAT7
        LONG                    cxGlyph;
        #endif
    LONG            cyGlyph;
    POINTL          ptlOrigin;
    LONG            ulCharInc;
    BYTE            iDComplexity;
    LONG            lDelta;
    LONG            cw;
    ULONG           iFGColor;
    ULONG           iBGColor;
    ULONG           bitCount;
        #if SWAT7
        UINT                    xOrigin;
        #endif

    #if NULL_TEXTOUT
    {
        if (pointer_switch)    return TRUE;
    }
    #endif

    DISPDBG((TEXT_DBG_LEVEL,"DrvTextOut: Entry.\n"));


    // The DDI spec says we'll only ever get foreground and background
    // mixes of R2_COPYPEN:

    ASSERTMSG(mix == 0x0d0d, "GDI should only give us a copy mix");

    ppdev = (PDEV*) pso->dhpdev;

    SYNC_W_3D(ppdev);   // if 3D context(s) active, make sure 3D engine idle before continuing...

    if (pso->iType == STYPE_DEVBITMAP)
    {
        PDSURF pdsurf = (PDSURF)pso->dhsurf;
        LogFile((BUF, "DTO Id=%p ", pdsurf));
        if (pdsurf->pso)
        {
            if ( !bCreateScreenFromDib(ppdev, pdsurf) )
            {
                LogFile((BUF, "DTO: D=DH (punted)\r\n"));
                return(EngTextOut(pdsurf->pso, pstro, pfo, pco, prclExtra,
                  prclOpaque, pboFore, pboOpaque, pptlBrush, mix));
        }
        else
        {
            LogFile((BUF, "DTO: D=DF "));
        }


        }
        else
        {
            LogFile((BUF, "DTO: D=D "));
        }
        ppdev->ptlOffset.x = pdsurf->ptl.x;
        ppdev->ptlOffset.y = pdsurf->ptl.y;
    }
    else
    {
        LogFile((BUF, "DTO: D=S "));
        ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;
    }

    //
    // Dump information about the call to the log file.
    //
    LogFile((BUF, "FG=%X BG=%X ",
                  pboFore->iSolidColor, pboOpaque->iSolidColor));
    LogFile((BUF, "C=%s ",
        (pco == NULL) ? "N " :
          ((pco->iDComplexity == DC_TRIVIAL) ? "T" :
             ((pco->iDComplexity == DC_RECT) ? "R" : "C" ))
    ));
    LogFile((BUF, "%s ", (prclOpaque != NULL) ? "O" : "T"));
    LogFile((BUF, "%s ", (pstro->ulCharInc == 0) ? "P" : "M"));


    #if !(USE_ASM && defined(i386))
    // If we have a font that is cached but the screen has been reinitialized,
    // we delete the font from memory and try again.

    if (ppdev->UseFontCache == 0)
        pfo->pvConsumer = (VOID*) -1;

    if (pfo->pvConsumer != NULL && pfo->pvConsumer != (PVOID) -1)
    {
        if (((PFONTCACHE) pfo->pvConsumer)->ulFontCount != ppdev->ulFontCount)
        {
            LogFile((BUF, "FCD "));
            DrvDestroyFont(pfo);
        }
        else
            LogFile((BUF, "GC=2 "));
    }

    if (pfo->pvConsumer == (PVOID) -1)
    {
        LogFile((BUF, "GC=3"));
    }


    // If we have a font that has not yet been cached, try caching it.
    if (pfo->pvConsumer == NULL)
    {
        // New font, check it out.
        int height = pstro->rclBkGround.bottom - pstro->rclBkGround.top;
        LogFile((BUF, "GC="));

#if SWAT3
            if (height > FONTCELL_Y * 3 / 2)
#else
        if (height > LINES_PER_TILE * 3 / 2)
#endif
            {
                // Font too big, mark is as uncacheable.
                LogFile((BUF, "0size "));
                pfo->pvConsumer = (PVOID) -1;
            }
            else
            {
                // Allocate memory for the font cache.
                #ifdef WINNT_VER40
                    pfo->pvConsumer = MEM_ALLOC(FL_ZERO_MEMORY, sizeof(FONTCACHE), ALLOC_TAG);
                #else
                    pfo->pvConsumer = MEM_ALLOC(LMEM_FIXED | LMEM_ZEROINIT, sizeof(FONTCACHE));
                #endif
                if (pfo->pvConsumer == NULL)
                {
                    // Not enough memory, mark it as uncacheable.
                    LogFile((BUF, "0mem "));
                    pfo->pvConsumer = (PVOID) -1;
                }
                else
                {
                    LogFile((BUF, "1 "));

                                AddToFontCacheChain(ppdev, pfo, pfo->pvConsumer);

                // Store device this font belongs to.
                ((PFONTCACHE) pfo->pvConsumer)->ppdev = ppdev;
            }
        }
    }

    #endif

    // Set FG / BG colors at this level

    iFGColor = pboFore->iSolidColor;
    iBGColor = pboOpaque->iSolidColor;

    switch (ppdev->iBitmapFormat)
    {
        case BMF_8BPP:
            iFGColor |= iFGColor << 8;
            iBGColor |= iBGColor << 8;

        case BMF_16BPP:
            iFGColor |= iFGColor << 16;
            iBGColor |= iBGColor << 16;
            break;
    }

    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    #if !(USE_ASM && defined(i386))
    // Can we use the font cache?
    if (  (pfo->pvConsumer != (PVOID) -1) && (iDComplexity != DC_COMPLEX)
       && (((PFONTCACHE) pfo->pvConsumer)->ppdev == ppdev))
    {
        // Set color registers.
        REQUIRE(4);
        LL_BGCOLOR(iBGColor, 2);
        LL_FGCOLOR(iFGColor, 2);

        if (prclOpaque != NULL)
        {
            #if LOG_CALLS
                #define FIT_FLAGS (SO_ZERO_BEARINGS      | \
                       SO_FLAG_DEFAULT_PLACEMENT | \
                       SO_MAXEXT_EQUAL_BM_SIDE   | \
                       SO_CHAR_INC_EQUAL_BM_BASE)

                    bTextPerfectFit =
                        (pstro->flAccel & FIT_FLAGS) == FIT_FLAGS;

                if (!(bTextPerfectFit)                              ||
                   (pstro->rclBkGround.top    > prclOpaque->top)    ||
                   (pstro->rclBkGround.left   > prclOpaque->left)   ||
                   (pstro->rclBkGround.right  < prclOpaque->right)  ||
                   (pstro->rclBkGround.bottom < prclOpaque->bottom))
                {
                    LogFile((BUF, "FIT=N "));
                }
                else
                {
                    LogFile((BUF, "FIT=Y "));
                }
            #endif


            // Draw opaqueing rectangle.
            if (iDComplexity == DC_TRIVIAL)
            {
                REQUIRE(7);
                LL_DRAWBLTDEF(SOLID_COLOR_FILL, 0);
                LL_OP0(prclOpaque->left + ppdev->ptlOffset.x,
                  prclOpaque->top + ppdev->ptlOffset.y);
                LL_BLTEXT(prclOpaque->right - prclOpaque->left,
                  prclOpaque->bottom - prclOpaque->top);
            }
            else
            {
                LONG x, y, cx, cy;
                x = max(prclOpaque->left, pco->rclBounds.left);
                y = max(prclOpaque->top, pco->rclBounds.top);
                cx = min(prclOpaque->right, pco->rclBounds.right) - x;
                cy = min(prclOpaque->bottom, pco->rclBounds.bottom) - y;
                if ( (cx > 0) && (cy > 0) )
                {
                    REQUIRE(7);
                        LL_DRAWBLTDEF(SOLID_COLOR_FILL, 0);
                    LL_OP0(x + ppdev->ptlOffset.x, y + ppdev->ptlOffset.y);
                    LL_BLTEXT(cx, cy);
                }
            }
        }

        // Enable bit swizzling and set DRAWBLTDEF.
        ppdev->grCONTROL |= SWIZ_CNTL;
        LL16(grCONTROL, ppdev->grCONTROL);
        REQUIRE(2);
        LL_DRAWBLTDEF(CACHE_EXPAND_XPAR, 2);
        LogFile((BUF, "UC"));
        LogFile((BUF, "\r\n"));

        // Call the font cache handler.
        if (iDComplexity == DC_TRIVIAL)
        {
               FontCache((PFONTCACHE) pfo->pvConsumer, pstro);
        }
        else
        {
               ClipCache((PFONTCACHE) pfo->pvConsumer, pstro, pco->rclBounds);
        }

        // Disable bit swizzling.
        ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
        LL16(grCONTROL, ppdev->grCONTROL);
        return(TRUE);
    }
    #endif

    DISPDBG((TEXT_DBG_LEVEL1,"DrvTextOut: Setting FG/BG Color.\n"));
    REQUIRE(4);
    LL_BGCOLOR(iBGColor, 2);
    LL_FGCOLOR(iFGColor, 2);

    ppdev->grCONTROL |= SWIZ_CNTL;
    LL16(grCONTROL, ppdev->grCONTROL);

    if (prclOpaque != NULL)
    {
        DISPDBG((TEXT_DBG_LEVEL1,"DrvTextOut: Setting Opaque.\n"));
        ////////////////////////////////////////////////////////////
        // Opaque Initialization
        ////////////////////////////////////////////////////////////
        //
        // If we paint the glyphs in 'opaque' mode, we may not actually
        // have to draw the opaquing rectangle up-front -- the process
        // of laying down all the glyphs will automatically cover all
        // of the pixels in the opaquing rectangle.
        //
        // The condition that must be satisfied is that the text must
        // fit 'perfectly' such that the entire background rectangle is
        // covered, and none of the glyphs overlap (if the glyphs
        // overlap, such as for italics, they have to be drawn in
        // transparent mode after the opaquing rectangle is cleared).
        //

        #define PERFECT_FIT_FLAGS (SO_ZERO_BEARINGS          | \
            SO_FLAG_DEFAULT_PLACEMENT | \
            SO_MAXEXT_EQUAL_BM_SIDE   | \
            SO_CHAR_INC_EQUAL_BM_BASE)

        bTextPerfectFit =
            (pstro->flAccel & PERFECT_FIT_FLAGS) == PERFECT_FIT_FLAGS;

        if (!(bTextPerfectFit)                              ||
             (pstro->rclBkGround.top    > prclOpaque->top)  ||
             (pstro->rclBkGround.left   > prclOpaque->left) ||
             (pstro->rclBkGround.right  < prclOpaque->right)||
             (pstro->rclBkGround.bottom < prclOpaque->bottom))
        {
            //
            // Draw opaquing rectangle.
            //

            if (iDComplexity == DC_TRIVIAL)
            {
                DISPDBG((TEXT_DBG_LEVEL1,"DrvTextOut: Opaque DC_TRIVIAL.\n"));
                REQUIRE(7);
                LL_DRAWBLTDEF(SOLID_COLOR_FILL, 0);
                LL_OP0(prclOpaque->left + ppdev->ptlOffset.x,
                        prclOpaque->top + ppdev->ptlOffset.y);
                LL_BLTEXT ((prclOpaque->right - prclOpaque->left) ,
                        (prclOpaque->bottom - prclOpaque->top) );
            }
            else
            {
                vClipSolid(ppdev, 1, prclOpaque, pboOpaque->iSolidColor, pco);
            }

            LogFile((BUF, "FIT=N "));
            // Opaquing rectangle has been drawn, now
            // we do transparent text.
        }
        else
        {
             LogFile((BUF, "FIT=Y "));
            // We don't have to draw the opaquing rectangle because
            // the text is an exact fit.
            goto TextInitOpaque;
        }

    } // End (prclOpaque != NULL)

    LogFile((BUF, "\r\n"));

    ////////////////////////////////////////////////////////////
    // Transparent Initialization
    ////////////////////////////////////////////////////////////


    // Initialize the hardware for transparent text:

    //
    // Set the chip up to do transparent text.
    //
    DISPDBG((TEXT_DBG_LEVEL1,"DrvTextOut: Setting XPAR Text.\n"));
    LL_DRAWBLTDEF(TEXT_EXPAND_XPAR, 2);

    goto TextInitDone;

TextInitOpaque:

    //
    // Set the chip up to do opaque text.
    // Any opaquing rectangle needed has been drawn by now.
    //
    DISPDBG((TEXT_DBG_LEVEL1,"DrvTextOut: Setting Opaque Text.\n"));
    LL_DRAWBLTDEF(TEXT_EXPAND_OPAQUE, 2);

TextInitDone:

    //
    // We're all set up to do either opaque or transparent text.
    // If necessary, any opaquing has been done by now.
    // So let's draw some glyphs on the screen.
    //

    REQUIRE(2);
    LL_OP2_MONO (0,0); // Set Zero phase for transfers
    if (iDComplexity == DC_TRIVIAL)
    {
        do // Loop while there are glyphs to draw.
        {
            //
            // Get a batch of glyphs to draw.
            //

            if (pstro->pgp != NULL)
            {
                DISPDBG((TEXT_DBG_LEVEL1,"DrvTextOut: One batch of Glyphs.\n"));
                // There's only the one batch of glyphs, so save ourselves
                // a call:

                pgp = pstro->pgp;
                cGlyph = pstro->cGlyphs;
                bMoreGlyphs = FALSE;
            }
            else
            {
                DISPDBG((TEXT_DBG_LEVEL1,
                    "DrvTextOut: Calling STROBJ_bEnum for Glyphs.\n"));
                bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
            }

            //
            // cGlyph is the count of glyphs in this batch.
            // bMorGlyphs is TRUE if there is another batch waiting for
            // us after this one.
            //

            if (cGlyph > 0)
            {
                //
                // Check the type of spacing.
                //

                if (pstro->ulCharInc == 0)
                {
                    ///////////////////////////////////////////////////////////
                    // Proportional Spacing

                    DISPDBG((TEXT_DBG_LEVEL1,
                        "DrvTextOut: Proportional Spacing.\n"));

                    while (TRUE) // Loop once for each Glyph.
                    {
                        pgb = pgp->pgdf->pgb;

                        LogFile((BUF, "GC:M\r\n"));

                                                #if !SWAT7
                        REQUIRE(5);
                        LL_OP0(pgp->ptl.x + pgb->ptlOrigin.x + ppdev->ptlOffset.x,
                                    pgp->ptl.y + pgb->ptlOrigin.y + ppdev->ptlOffset.y);
                        LL_BLTEXT (pgb->sizlBitmap.cx, pgb->sizlBitmap.cy);
                                                #endif

                                                #if SWAT7
                                                xOrigin = pgp->ptl.x + pgb->ptlOrigin.x;
                                                cxGlyph = pgb->sizlBitmap.cx;
                                                lDelta  = (cxGlyph + 7) >> 3;
                                                #endif
                        pjGlyph = pgb->aj;
                        cyGlyph = pgb->sizlBitmap.cy;

                                                #if SWAT7
                                                //
                                                // Test for 5465AD hardware bug in 8-bpp.
                                                //
                                                if (   (cxGlyph > 64) && (cxGlyph < 128)
                                                        && (ppdev->iBytesPerPixel == 1)
                                                )
                                                {
                                                        Xfer64Pixels(ppdev, xOrigin, pgp->ptl.y +
                                                                        pgb->ptlOrigin.y, 0, cyGlyph, pjGlyph,
                                                                        cxGlyph);
                                                        pjGlyph += 64 / 8;
                                                        xOrigin += 64;
                                                        cxGlyph -= 64;
                                                }

                        REQUIRE(5);
                        LL_OP0(xOrigin + ppdev->ptlOffset.x, pgp->ptl.y +
                                                                pgb->ptlOrigin.y + ppdev->ptlOffset.y);
                        LL_BLTEXT (cxGlyph, cyGlyph);
                                                #endif

                        // The monochrome bitmap describing the glyph is
                        // byte-aligned.  This means that if the glyph is
                        // 1 to 8 pels in width, each row of the glyph is
                        // defined in consecutive bytes; if the glyph is 9
                        // to 16 pels in width, each row of the glyph is
                        // defined in consecutive words, etc.
                        //

                                                #if SWAT7
                        if (cxGlyph <= 8)
                                                #else
                        if (pgb->sizlBitmap.cx <= 8)
                                                #endif
                        {
                            //--------------------------------------------------
                            // 1 to 8 pels in width
                            // 91% of all glyphs will go through this path.

                            while (cyGlyph--)
                                                        #if SWAT7
                            {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], *pjGlyph);
                                                                pjGlyph += lDelta;
                            }
                                                        #else
                            REQUIRE(1);
                                                                LL32 (grHOSTDATA[0], *pjGlyph++);

                            // We're a bit tricky here in order to avoid letting
                            // the compiler tail-merge this code (which would
                            // add an extra jump):

                            pgp++;
                            if (--cGlyph != 0)
                                continue; // Go do the next glyph.

                            break;  // Done with all glyphs in this batch.
                                    // breakout of Glyph Loop.
                                                        #endif
                        }

                                                #if SWAT7
                        else if (cxGlyph <= 16)
                                                #else
                        else if (pgb->sizlBitmap.cx <= 16)
                                                #endif
                        {
                            //--------------------------------------------------
                            // 9 to 16 pels in width
                            // 5% of all glyphs will go through this path.

                            while ( cyGlyph-- )
                                                        #if SWAT7
                            {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], *(USHORT*)pjGlyph);
                                                                pjGlyph += lDelta;
                                                        }
                                                        #else
                                REQUIRE(1);
                                LL32 (grHOSTDATA[0], *((USHORT*)pjGlyph)++);
                                                        #endif
                        }

                        else
                        {
                            //--------------------------------------------------
                            // More than 16 pels in width

                                                        #if SWAT7
                            cw = (cxGlyph + 31) >> 5;
                                                        #else
                            lDelta = (pgb->sizlBitmap.cx + 7) >> 3;
                            cw = (lDelta + 3) >> 2;
                                                        #endif

                            pTmp = pjGlyph + lDelta * pgb->sizlBitmap.cy;

                            for (;cyGlyph!=1; cyGlyph--)
                            {
                                                                WRITE_STRING(pjGlyph, cw);
                                pjGlyph += lDelta;
                            }

                            {
                                ULONG *pSrc = (ULONG*) pjGlyph + cw - 1;
                                                                WRITE_STRING(pjGlyph, cw - 1);

                                if ((BYTE *)pSrc+4<=pTmp)
                                {
                                    REQUIRE(1);
                                    LL32 (grHOSTDATA[0], *pSrc++ );
                                }
                                else
                                {
                                    int Extra = (ULONG) pTmp - (ULONG) pSrc;
                                    BYTE * pByte = (BYTE *)pSrc;
                                    ULONG ulData;

                                    DISPDBG((TEXT_DBG_LEVEL1,
                                        "Caught it %s %d %d %x %x\n", __FILE__, __LINE__, Extra, pTmp, pSrc));

                                    if (Extra == 1)
                                        ulData = (ULONG)(*pByte);
                                    else if (Extra == 2)
                                        ulData = (ULONG)(*(USHORT*)pByte);
                                    else
                                        ulData = (((ULONG)*(pByte+2) << 8) | (ULONG)*(pByte+1)) << 8 | *pByte;

                                    REQUIRE(1);
                                    LL32 (grHOSTDATA[0], ulData );
                                }
                            }

                        } // END pel width test.

                        pgp++;    // Next glyph
                        if (--cGlyph == 0)
                            break;  // Done with this batch.
                                    // Break out of the Glyph Loop.

                    } // End Glyph Loop.

                } // End porportional characters.

                else
                {
                    ////////////////////////////////////////////////////////////
                    // Mono Spacing

                    DISPDBG((TEXT_DBG_LEVEL1,"DrvTextOut: Mono Spacing.\n"));

                    ulCharInc = pstro->ulCharInc;
                    pgb = pgp->pgdf->pgb;

                    ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
                    ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

                    while (TRUE) // Loop once for each Glyph in the batch.
                    {
                        LogFile((BUF, "GC:M\r\n"));
                        pgb = pgp->pgdf->pgb;

                                                #if !SWAT7
                        REQUIRE(5);
                        LL_OP0(ptlOrigin.x + ppdev->ptlOffset.x,
                                ptlOrigin.y + ppdev->ptlOffset.y);

                        ptlOrigin.x += ulCharInc;

                        LL_BLTEXT (pgb->sizlBitmap.cx, pgb->sizlBitmap.cy);
                                                #endif

                        pjGlyph = pgb->aj;
                        cyGlyph = pgb->sizlBitmap.cy;
                                                #if SWAT7
                                                xOrigin = ptlOrigin.x;
                                                cxGlyph = pgb->sizlBitmap.cx;
                                                lDelta  = (cxGlyph + 7) >> 3;

                                                //
                                                // Test for 5465AD hardware bug in 8-bpp.
                                                //
                                                if (   (cxGlyph > 64) && (cxGlyph < 128)
                                                        && (ppdev->iBytesPerPixel == 1)
                                                )
                                                {
                                                        Xfer64Pixels(ppdev, xOrigin, ptlOrigin.y, 0,
                                                                        cyGlyph, pjGlyph, cxGlyph);
                                                        pjGlyph += 64 / 8;
                                                        xOrigin += 64;
                                                        cxGlyph -= 64;
                                                }

                                                REQUIRE(5);
                                                LL_OP0(xOrigin + ppdev->ptlOffset.x,
                                   ptlOrigin.y + ppdev->ptlOffset.y);

                        ptlOrigin.x += ulCharInc;

                        LL_BLTEXT (cxGlyph, cyGlyph);
                                                #endif

                        //
                        // Note: Mono spacing does not guarantee that all the
                        //  glyphs are the same size -- that is, we cannot
                        //  move the size check out of this inner loop,
                        //  unless we key off some more of the STROBJ
                        //  accelerator flags.
                        //  We are not guarenteed the Glyphs are the same size,
                        //  only that they are the same distance apart.
                        //

                                                #if SWAT7
                        if (cxGlyph <= 8)
                                                #else
                        if (pgb->sizlBitmap.cx <= 8)
                                                #endif
                        {
                            //-----------------------------------------------------
                            // 1 to 8 pels in width

                            while ( cyGlyph-- )
                                                        #if SWAT7
                                                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], *pjGlyph);
                                                                pjGlyph += lDelta;
                                                        }
                                                        #else
                                REQUIRE(1);
                                LL32 (grHOSTDATA[0], *pjGlyph++);
                                                        #endif

                        }
                                                #if SWAT7
                        else if (cxGlyph <= 16)
                                                #else
                        else if (pgb->sizlBitmap.cx <= 16)
                                                #endif
                        {
                            //-----------------------------------------------------
                            // 9 to 16 pels in width


                            while ( cyGlyph-- )
                                                        #if SWAT7
                                                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], *(USHORT*)pjGlyph);
                                                                pjGlyph += lDelta;
                                                        }
                                                        #else
                                REQUIRE(1);
                                LL32 (grHOSTDATA[0], *((USHORT*)pjGlyph)++);
                                                        #endif

                        }
                        else
                        {
                            //-----------------------------------------------------
                            // More than 16 pels in width


                                                        #if SWAT7
                            cw = (cxGlyph + 31) >> 5;
                                                        #else
                            lDelta = (pgb->sizlBitmap.cx + 7) >> 3;
                            cw = (lDelta + 3) >> 2;
                                                        #endif

                            pTmp = pjGlyph + lDelta * pgb->sizlBitmap.cy;

                            for (;cyGlyph!=1; cyGlyph--)
                            {
                                                                WRITE_STRING(pjGlyph, cw);
                                pjGlyph += lDelta;
                            }

                            {
                                ULONG *pSrc = (ULONG*) pjGlyph + cw - 1;
                                                                WRITE_STRING(pjGlyph, cw - 1);

                                if ((BYTE *)pSrc+4<=pTmp)
                                {
                                    REQUIRE(1);
                                    LL32 (grHOSTDATA[0], *pSrc++ );
                                }
                                else
                                {
                                    int Extra = (ULONG) pTmp - (ULONG) pSrc;
                                    BYTE * pByte = (BYTE *)pSrc;
                                    ULONG ulData;

                                    DISPDBG((TEXT_DBG_LEVEL1,
                                        "Caught it %s %d %d %x %x\n",
                                        __FILE__, __LINE__, Extra, pTmp, pSrc));

                                    if (Extra == 1)
                                        ulData = (ULONG)(*pByte);
                                    else if (Extra == 2)
                                        ulData = (ULONG)(*(USHORT*)pByte);
                                    else
                                        ulData = (((ULONG)*(pByte+2) << 8) | (ULONG)*(pByte+1)) << 8 | *pByte;

                                    REQUIRE(1);
                                    LL32 (grHOSTDATA[0], ulData );
                                }
                            }
                         } // End more than 16 pels wide.

                        pgp++;
                        if (--cGlyph == 0)  // We are done with this batch
                            break;  // of glyphs.  Break out of the glyph loop.

                    } // End Glyph Loop.

                } // End Mono Spacing.

            } // End  if (cGlyph > 0)

            //
            // Done with this batch of Glyphs.
            // Go get the next one.
            //

        } while (bMoreGlyphs);

    } // End DC_TRIVIAL
    else
    {
        // If there's clipping, call off to a function:
        vMmClipGlyphExpansion(ppdev, pstro, pco);
    }

    ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
    LL16(grCONTROL, ppdev->grCONTROL);

    return(TRUE);

} // End DrvTextOut.


/******************************Public*Routine******************************\
* BOOL bEnableText
*
* Performs the necessary setup for the text drawing subcomponent.
*
\**************************************************************************/

BOOL bEnableText(
PDEV*   ppdev)
{
    // Our text algorithms require no initialization.   If we were to
    // do glyph caching, we would probably want to allocate off-screen
    // memory and do a bunch of other stuff here.

    DISPDBG((TEXT_DBG_LEVEL,"bEnableText: Entry.\n"));
#if RECORD_ON
    LL( RECORD, 1);     // Switch on
    LL( RECORD, 2);     // Pause
    DISPDBG((TEXT_DBG_LEVEL1,"xbEnableText: Recording Paused.\n"));
#endif
    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableText
*
* Performs the necessary clean-up for the text drawing subcomponent.
*
\**************************************************************************/

VOID vDisableText(PDEV* ppdev)
{
    // Here we free any stuff allocated in 'bEnableText'.

    DISPDBG((TEXT_DBG_LEVEL,"vDisableText: Entry.\n"));
}

#if !SWAT3
#pragma optimize("", off) // Microsoft doesn't know how to do compile...
#endif
/******************************Public*Routine******************************\
* VOID vAssertModeText
*
* Disables or re-enables the text drawing subcomponent in preparation for
* full-screen entry/exit.
*
\**************************************************************************/

VOID vAssertModeText(
PDEV*   ppdev,
BOOL    bEnable)
{
#if SWAT3
        SIZEL sizl;
        POINTL pos;
        int i;

        if (bEnable)
        {
                // We are enabling the screen again, so allocate the font cache if it
                // is not yet allocated.
                if (ppdev->pofmFontCache == NULL)
                {
                        #if MEMMGR
                        sizl.cx = ppdev->lDeltaScreen / FONTCELL_X;
                        #else
                        //sizl.cx = ppdev->cxMemory;
                        sizl.cx = ppdev->lDeltaScreen / ppdev->iBytesPerPixel / FONTCELL_X;
                        #endif
                        sizl.cy = (FONTCELL_COUNT + sizl.cx - 1) / sizl.cx;
                        sizl.cx *= FONTCELL_X;
                        sizl.cy *= FONTCELL_Y;

                        ppdev->pofmFontCache = AllocOffScnMem(ppdev, &sizl, 0, NULL);
                        //ppdev->pofmFontCache = AllocOffScnMem(ppdev, &sizl,
                        //              PIXEL_AlIGN, NULL);
                }

                if (ppdev->pofmFontCache != NULL)
                {
                        // Clear the entire font cell array.
                        pos.x = pos.y = 0;
                        for (i = 0; i < FONTCELL_COUNT; i++)
                        {
                                if (pos.y >= sizl.cy)
                                {
                                        ppdev->fcGrid[i].x = 0;
                                        ppdev->fcGrid[i].y = 0;
                                        ppdev->fcGrid[i].pfc = (PFONTCACHE) -1;
                                }
                                else
                                {
                                        ppdev->fcGrid[i].x = ppdev->pofmFontCache->x + pos.x;
                                        ppdev->fcGrid[i].y = ppdev->pofmFontCache->y + pos.y;
                                        ppdev->fcGrid[i].pfc = NULL;
                                        ppdev->fcGrid[i].ulLastX = 0;
                                        ppdev->fcGrid[i].pNext = NULL;

                                        pos.x += FONTCELL_X;
                                        if (pos.x >= (LONG) ppdev->cxMemory)
                                        {
                                                pos.x = 0;
                                                pos.y += FONTCELL_Y;
                                        }
                                }
                        }
                }
        }
        else
        {
                // We are disabling the screen so destroy all cached fonts.
                if (ppdev->pofmFontCache != NULL)
                {
                        for (i = 0; i < FONTCELL_COUNT; i++)
                        {
                                if (   (ppdev->fcGrid[i].pfc != NULL)
                                        && (ppdev->fcGrid[i].pfc != (PFONTCACHE) -1)
                                )
                                {
                                        DrvDestroyFont(ppdev->fcGrid[i].pfc->pfo);
                                }
                        }

                        // Free the font cache cells.
                        FreeOffScnMem(ppdev, ppdev->pofmFontCache);
                        ppdev->pofmFontCache = NULL;
                }
        }
#elif !SWAT3
        if (!bEnable)
        {
                // Remove all chained fonts.
                PFONTCACHE p = ppdev->pfcChain;
                while (p != NULL)
                {
                        DrvDestroyFont(p->pfo);
                        p = ppdev->pfcChain;
                }
        }
#endif // SWAT3

}
#if !SWAT3
#pragma optimize("", on)
#endif

#if SWAT3
/******************************************************************************\
* PFONTCELL fcAllocCell(PFONTCACGE pfc)
*
* Allocate a font cell for the given font cache.  Returns NULL if there are no
* more empty font cells.
\******************************************************************************/
PFONTCELL fcAllocCell(PFONTCACHE pfc)
{
        int i;
        PPDEV ppdev = pfc->ppdev;
        PFONTCELL p = ppdev->fcGrid;

        if (ppdev->pofmFontCache == NULL)
        {
                // Font cache is disabled, return NULL.
                return NULL;
        }

        for (i = 0; i < FONTCELL_COUNT; i++, p++)
        {
                if (p->pfc == NULL)
                {
                        p->pfc = pfc;
                        return p;
                }
        }

        return NULL;
}

/******************************************************************************\
* void fcFreeCell(PFONTCELL pCell)
*
* Mark the given font cell as free.
\******************************************************************************/
void fcFreeCell(PFONTCELL pCell)
{
        pCell->pfc = NULL;
        pCell->ulLastX = 0;
        pCell->pNext = NULL;
}
#endif // SWAT3

/******************************Public*Routine******************************\
* VOID DrvDestroyFont
*
* We're being notified that the given font is being deallocated; clean up
* anything we've stashed in the 'pvConsumer' field of the 'pfo'.
*
\**************************************************************************/

VOID DrvDestroyFont(FONTOBJ *pfo)
{
        DISPDBG((TEXT_DBG_LEVEL, "DrvDestroyFont Entry\n"));

        if (pfo->pvConsumer != NULL && pfo->pvConsumer != (PVOID) -1)
        {
                PFONTCACHE pfc = (PFONTCACHE) pfo->pvConsumer;
#if SWAT3
                PFONTCELL pCell, pCellNext;
#else
                PFONTMEMORY     pfm, pfmNext;
#endif
                PPDEV ppdev;

                ppdev = pfc->ppdev;

                LogFile((BUF, "DrvDestroyFont: "));

#if SWAT3
                for (pCell = pfc->pFontCell; pCell != NULL; pCell = pCellNext)
                {
                        pCellNext = pCell->pNext;
                        fcFreeCell(pCell);
                }
                LogFile((BUF, "\r\n"));
#else
                for (pfm = pfc->pFontMemory; pfm != NULL; pfm = pfmNext)
                {
                        pfmNext = pfm->pNext;
                        if (pfm->pTile != NULL)
                        {
                                FreeOffScnMem(pfc->ppdev, pfm->pTile);
                        }
                        MEMORY_FREE(pfm);
                }

                // Unhook the font cache from the chain.
                if (pfc->pfcPrev != NULL)
                {
                        pfc->pfcPrev->pfcNext = pfc->pfcNext;
                }
                else
                {
                        ppdev->pfcChain = pfc->pfcNext;
                }

                if (pfc->pfcNext != NULL)
                {
                        pfc->pfcNext->pfcPrev = pfc->pfcPrev;
                }
#endif

                LogFile((BUF, "\r\n"));
                MEMORY_FREE(pfc);
        }

        pfo->pvConsumer = NULL;
        DISPDBG((TEXT_DBG_LEVEL, "DrvDestroyFont Exit\n"));
}

/*
 *  GetGlyphSize
 *
 *  Get the size (in pixels) of the requested glyph. Return the width of the
 *  glyph in bytes or 0 if the glyph is too big to cache.
 *
 */
long GetGlyphSize(
    GLYPHBITS*  pgb,        // Pointer to glyph.
    POINTL*     pptlOrigin, // Pointer to return origin in.
    DWORD*      pcSize      // Pointer to return size in.
)
{
    long  x, y, height = 0;
    BYTE* pByte = pgb->aj;
    int   i;

    x = (pgb->sizlBitmap.cx + 7) >> 3;  // get width in bytes
    if (x > 0)
    {
    // find first line in glyph that contains data
    for (y = 0; y < pgb->sizlBitmap.cy; y++, pByte += x)
    {
        // walk trough every byte on a line
        for (i = 0; i < x; i++)
        {
        if (pByte[i])   // we have data, so we are at the first line
        {
            // find the last line in te glyph that contains data
            height = pgb->sizlBitmap.cy - y;
            for (pByte += (height - 1) * x; height > 0; height--)
            {
            // walk trough every byte on a line
            for (i = 0; i < x; i++)
            {
                if (pByte[i])
                {
                    // test height of glyph
#if SWAT3
                    if (height > FONTCELL_Y)
#else
                    if (height > LINES_PER_TILE)
#endif
                    {
                        // glyph too big, mark it as uncacheable
                        *pcSize = (DWORD) -1;
                        return(0);
                    }
                    // fill return parameters
                    pptlOrigin->y = y;
                    *pcSize = PACK_XY(pgb->sizlBitmap.cx, height);
                    return(x);
                }
            }
            pByte -= x;
            }
        }
        }
    }
    }

    // glyph is empty
    *pcSize = 0;
    return(0);
}

/*
 *  AllocFontCache
 *
 *  Allocate the requsted memory in off-screen memory. Return TRUE and the x,y
 *  coordinates of the upper left corner of this region, or FALSE if there is
 *  not enough memory.
 *
 */
BOOL AllocFontCache(
  PFONTCACHE  pfc,       // Pointer to font cache.
  long        cWidth,    // Width (in bytes) to allocate.
  long        cHeight,   // Height to allocate.
  POINTL*     ppnt       // Point to return cooridinate in.
)
{
#if SWAT3
        PFONTCELL       pCell;
#else
        SIZEL           sizl;
        PFONTMEMORY     pfm;
#endif
        long            x;
        PPDEV           ppdev = pfc->ppdev;

#if !SWAT3
        if (ppdev->iBytesPerPixel == 3)
        {
                sizl.cx = (128 + 2) / 3;
        }
        else
        {
                sizl.cx = 128 / ppdev->iBytesPerPixel;
        }
        sizl.cy = 16;
#endif

#if SWAT3
        if (pfc->pFontCell == NULL)
        {
                pfc->pFontCell = fcAllocCell(pfc);
        }
#else
        if (pfc->pFontMemory == NULL)
        {
                pfc->pFontMemory = (PFONTMEMORY)
                #ifdef WINNT_VER40
                                MEM_ALLOC(FL_ZERO_MEMORY, sizeof(FONTMEMORY), ALLOC_TAG);
                #else
                                MEM_ALLOC(LMEM_FIXED | LMEM_ZEROINIT, sizeof(FONTMEMORY));
                #endif
        }
#endif

#if SWAT3
        for (pCell = pfc->pFontCell; pCell != NULL; pCell = pCell->pNext)
        {
                x = pCell->ulLastX;
                if (x + cWidth <= FONTCELL_X)
                {
                        pCell->ulLastX += cWidth;
                        ppnt->x = pCell->x + x;
                        ppnt->y = pCell->y;
                        return TRUE;
            }

                if (pCell->pNext == NULL)
                {
                        pCell->pNext = fcAllocCell(pfc);
                }
        }
#else
        for (pfm = pfc->pFontMemory; pfm; pfm = pfm->pNext)
        {
                if (pfm->pTile == NULL)
                {
                        #ifdef ALLOC_IN_CREATESURFACE
                        if (!ppdev->bDirectDrawInUse)
                        #endif
                        pfm->pTile  = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
                        if (pfm->pTile == NULL)
                        {
                                return FALSE;
                        }

                        ppnt->x = pfm->pTile->x;
                        ppnt->y = pfm->pTile->y;
                        pfm->ulLastX = cWidth;
                        return TRUE;
                }

                x = pfm->ulLastX;
                if (x + cWidth <= BYTES_PER_TILE)
                {
                        pfm->ulLastX += cWidth;
                        ppnt->x = pfm->pTile->x + x;
                        ppnt->y = pfm->pTile->y;
                        return TRUE;
            }

                if (pfm->pNext == NULL)
                {
                        pfm->pNext = (PFONTMEMORY)
                        #ifdef WINNT_VER40
                                        MEM_ALLOC(FL_ZERO_MEMORY, sizeof(FONTMEMORY), ALLOC_TAG);
                        #else
                                        MEM_ALLOC(LMEM_FIXED | LMEM_ZEROINIT, sizeof(FONTMEMORY));
                        #endif
                }
        }
#endif
        return FALSE;
}

/*
 *  AllocGlyph
 *
 *  Allocate memory for the requested glyph and copy the glyph into off-screen
 *  memory. If there is not enough off-screen memory left, or the glyph is too
 *  large to glyph, return FALSE, otherwise return TRUE.
 *
 */
VOID AllocGlyph(
    PFONTCACHE  pfc,        // pointer to font cache
    GLYPHBITS*  pgb,        // pointer to glyph to cache
    GLYPHCACHE* pgc     // pointer to glyph cache structure
)
{
    long   cBytes;
    BYTE   *pOffScreen, *pSrc;
    long   y;
    PDEV   *ppdev;
    POINTL pointl;

    ppdev = pfc->ppdev;
    cBytes = GetGlyphSize(pgb, &pgc->ptlOrigin, &pgc->cSize);
    if (cBytes == 0)
    {
        pgc->xyPos = (DWORD) -1;
        LogFile((BUF, "GC:F\r\n"));
        return;
    }

    if (AllocFontCache(pfc, cBytes, pgc->cSize >> 16, &pointl) == FALSE)
    {
        pgc->cSize = (DWORD) -1;
        LogFile((BUF, "GC:F\r\n"));
        return;
    }

    pOffScreen = ppdev->pjScreen + pointl.x + pointl.y * ppdev->lDeltaScreen;
    pSrc = &pgb->aj[pgc->ptlOrigin.y * cBytes];
    y = (long) (pgc->cSize >> 16);
    if (cBytes == sizeof(BYTE))
    {
        while (y-- > 0)
        {
            *pOffScreen = Swiz[*pSrc];
            pOffScreen += ppdev->lDeltaScreen;
            pSrc += sizeof(BYTE);
        }
    }
    else
    {
        while (y-- > 0)
        {
            long lDelta = ppdev->lDeltaScreen - cBytes;
            long i;

            for (i = cBytes; i > 0; i--)
            {
                *pOffScreen++ = Swiz[*pSrc++];
            }
            pOffScreen += lDelta;
        }
    }
    pgc->xyPos = PACK_XY(pointl.x * 8, pointl.y);
    pgc->ptlOrigin.x = pgb->ptlOrigin.x;
    pgc->ptlOrigin.y += pgb->ptlOrigin.y;
    LogFile((BUF, "GC:S\r\n"));
}


#if !(USE_ASM && defined(i386))

/*
 *  FontCache
 *
 *  Draw glyphs using the off-screen font cache.
 *
 */
VOID FontCache(
    PFONTCACHE  pfc,        // Pointer to font cache.
    STROBJ*     pstro       // Pointer to glyphs.
)
{
    PDEV*       ppdev;
    BOOL        bMoreGlyphs = TRUE;
    ULONG       cGlyph;
    GLYPHPOS*   pgp;
    POINTL      ptlOrigin;
    PGLYPHCACHE pgc;
    ULONG       ulCharInc;

    // set pointer to physical device
    ppdev = pfc->ppdev;

    // loop until there are no more glyphs to process
    while (bMoreGlyphs)
    {
        if (pstro->pgp != NULL)
        {
            // we have just one set of glyphs
            pgp = pstro->pgp;
            cGlyph = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            // enumerate a set of glyphs
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
        }

        if (pstro->ulCharInc)
        {
            // fixed fonts... get x and y coordinates of first glyph
            ptlOrigin.x = pgp->ptl.x;
            ptlOrigin.y = pgp->ptl.y;
            // get glyph increment
            ulCharInc = pstro->ulCharInc;

            // walk through all glyphs
            while (cGlyph-- > 0)
            {
                if (pgp->hg < MAX_GLYPHS)
                {
                    // this glyph index is cacheable
                    pgc = &pfc->aGlyphs[pgp->hg];
                    if (pgc->xyPos == 0)
                    {
                        // cache the glyph
                        AllocGlyph(pfc, pgp->pgdf->pgb, pgc);
                    }
                    if ((long) pgc->cSize > 0)
                    {
                        LogFile((BUF, "GC:H\r\n"));
                        // the glyph is cached, blit it on the screen
                        REQUIRE(7);
                        LL_OP0(ptlOrigin.x + pgc->ptlOrigin.x + ppdev->ptlOffset.x,
                               ptlOrigin.y + pgc->ptlOrigin.y + ppdev->ptlOffset.y);
                        LL32 (grOP2_opMRDRAM, pgc->xyPos);
                        LL32 (grBLTEXT_EX.dw, pgc->cSize);
                    }
                    else if ((long) pgc->cSize == -1)
                    {
                        // the glyph is uncacheable, draw it directly
                        DrawGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin);
                    }
                }
                else
                {
                    // the glyph index is out of range, draw it directly
                    DrawGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin);
                }
                // increment glyph x coordinate
                ptlOrigin.x += ulCharInc;
                // next glyph
                pgp++;
            }
        }
        else
        {
            // variable width fonts, walk trough all glyphs
            while (cGlyph-- > 0)
            {
                if (pgp->hg < MAX_GLYPHS)
                {
                    // this glyph index is cacheable
                    pgc = &pfc->aGlyphs[pgp->hg];
                    if (pgc->xyPos == 0)
                    {
                        // cache the glyph
                        AllocGlyph(pfc, pgp->pgdf->pgb, pgc);
                    }
                    if ((long) pgc->cSize > 0)
                    {
                        LogFile((BUF, "GC:H\r\n"));
                        // the glyph is cached, blit it on the screen
                        REQUIRE(7);
                        LL_OP0(pgp->ptl.x + pgc->ptlOrigin.x + ppdev->ptlOffset.x,
                               pgp->ptl.y + pgc->ptlOrigin.y + ppdev->ptlOffset.y);
                        LL32 (grOP2_opMRDRAM, pgc->xyPos);
                        LL32 (grBLTEXT_EX.dw, pgc->cSize);
                    }
                    else if ((long) pgc->cSize == -1)
                    {
                        // the glyph is uncacheable, draw it directly
                        DrawGlyph(ppdev, pgp->pgdf->pgb, pgp->ptl);
                    }
                }
                else
                {
                    // the glyph index is out of range, draw it directly
                    DrawGlyph(ppdev, pgp->pgdf->pgb, pgp->ptl);
                }
                // next glyph
                pgp++;
            }
        }
    }
}

/*
 * DrawGlyph
 *
 * Draw glyphs directly on the screen.
 *
 */
VOID DrawGlyph(
    PDEV*       ppdev,      // Pointer to physical device.
    GLYPHBITS*  pgb,        // Pointer to glyph to draw.
    POINTL      ptl         // Location of glyph.
)
{
    BYTE*   pjGlyph;
    ULONG   cyGlyph;
        #if SWAT7
    ULONG   cxGlyph;
        ULONG   xOrigin;
        LONG    lDelta;
        #endif

    LogFile((BUF, "GC:M\r\n"));

        #if SWAT7
        xOrigin = ptl.x + pgb->ptlOrigin.x;
    cxGlyph = pgb->sizlBitmap.cx;
    cyGlyph = pgb->sizlBitmap.cy;
    pjGlyph = pgb->aj;
        lDelta  = (cxGlyph + 7) >> 3;
        #endif

    // start the blit
    REQUIRE(4);
    LL_DRAWBLTDEF(TEXT_EXPAND_XPAR, 0);
    LL_OP2_MONO(0, 0);
        #if !SWAT7
    REQUIRE(5);
    LL_OP0(ptl.x + pgb->ptlOrigin.x + ppdev->ptlOffset.x,
           ptl.y + pgb->ptlOrigin.y + ppdev->ptlOffset.y);
        LL_BLTEXT(pgb->sizlBitmap.cx, pgb->sizlBitmap.cy);

    pjGlyph = pgb->aj;
    cyGlyph = pgb->sizlBitmap.cy;
        #endif

        #if SWAT7
        //
        // Test for 5465AD hardware bug in 8-bpp.
        //
        if (   (cxGlyph > 64) && (cxGlyph < 128)
                && (ppdev->iBytesPerPixel == 1)
        )
        {
                Xfer64Pixels(ppdev, xOrigin, ptl.y + pgb->ptlOrigin.y, 0, cyGlyph,
                                pjGlyph, cxGlyph);
                pjGlyph += 64 / 8;
                xOrigin += 64;
                cxGlyph -= 64;
        }

    REQUIRE(5);
    LL_OP0(xOrigin + ppdev->ptlOffset.x,
                   ptl.y + pgb->ptlOrigin.y + ppdev->ptlOffset.y);
        LL_BLTEXT(cxGlyph, cyGlyph);
        #endif

        #if SWAT7
        if (cxGlyph <= 8)
        #else
    if (pgb->sizlBitmap.cx <= 8)
        #endif
    {
        // just one byte per line
        while (cyGlyph--)
        {
            REQUIRE(1);
            LL32 (grHOSTDATA[0], *pjGlyph);
                        #if SWAT7
            pjGlyph += lDelta;
                        #else
            pjGlyph++;
                        #endif
        }
    }
        #if SWAT7
    else if (cxGlyph <= 16)
        #else
    else if (pgb->sizlBitmap.cx <= 16)
        #endif
    {
        // just two bytes per line
        while (cyGlyph--)
        {
            REQUIRE(1);
            LL32 (grHOSTDATA[0], *(WORD *) pjGlyph);
                        #if SWAT7
            pjGlyph += lDelta;
                        #else
            pjGlyph += 2;
                        #endif
        }
    }
        #if SWAT7
    else if (cxGlyph <= 24)
        #else
    else if (pgb->sizlBitmap.cx <= 24)
        #endif
    {
        // just three bytes per line
        while (cyGlyph--)
        {
            REQUIRE(1);
            LL32 (grHOSTDATA[0], *(DWORD *) pjGlyph);
                        #if SWAT7
            pjGlyph += lDelta;
                        #else
            pjGlyph += 3;
                        #endif
        }
    }
        #if SWAT7
    else if (cxGlyph <= 32)
        #else
    else if (pgb->sizlBitmap.cx <= 32)
        #endif
    {
        // just four bytes per line
        while (cyGlyph--)
        {
            REQUIRE(1);
            LL32 (grHOSTDATA[0], *(DWORD *) pjGlyph);
                        #if SWAT7
            pjGlyph += lDelta;
                        #else
            pjGlyph += 4;
                        #endif
        }
    }
    else
    {
        // any number of bytes per line
                #if SWAT7
        int cw = (cxGlyph + 31) >> 5;
                #else
        long lDelta = (pgb->sizlBitmap.cx + 7) >> 3;
        int cw = (lDelta + 3) >> 2;
                #endif

        BYTE * pTmp = pjGlyph + lDelta * pgb->sizlBitmap.cy;

        for (;cyGlyph!=1; cyGlyph--)
        {
                        WRITE_STRING(pjGlyph, cw);
            pjGlyph += lDelta;
        }

        {
            ULONG *pSrc = (ULONG*) pjGlyph + cw - 1;
                        WRITE_STRING(pjGlyph, cw - 1);

            if ((BYTE *)pSrc+4<=pTmp)
            {
                REQUIRE(1);
                LL32 (grHOSTDATA[0], *pSrc++ );
            }
            else
            {
                int Extra = (ULONG) pTmp - (ULONG) pSrc;
                BYTE * pByte = (BYTE *)pSrc;
                ULONG ulData;

                DISPDBG((TEXT_DBG_LEVEL1,
                    "Caught it %s %d %d %x %x\n",
                    __FILE__, __LINE__, Extra, pTmp, pSrc));

                if (Extra == 1)
                    ulData = (ULONG)(*pByte);
                else if (Extra == 2)
                    ulData = (ULONG)(*(USHORT*)pByte);
                else
                    ulData = (((ULONG)*(pByte+2) << 8) | (ULONG)*(pByte+1)) << 8 | *pByte;

                REQUIRE(1);
                LL32 (grHOSTDATA[0], ulData );
            }
        }
    }

    // reset to transparent cache expansion
    LL_DRAWBLTDEF(CACHE_EXPAND_XPAR, 2);
}




VOID ClipCache(
    PFONTCACHE  pfc,        // Pointer to font cache.
    STROBJ*     pstro,      // Pointer to glyphs.
    RECTL       rclBounds   // Clipping rectangle.
)
{
    PDEV*       ppdev;
    BOOL        bMoreGlyphs = TRUE;
    ULONG       cGlyph;
    GLYPHPOS*   pgp;
    POINTL      ptlOrigin;
    PGLYPHCACHE pgc;
    ULONG       ulCharInc;

    // set pointer to physical device
    ppdev = pfc->ppdev;

    // loop until there are no more glyphs to process
    while (bMoreGlyphs)
    {
        if (pstro->pgp != NULL)
        {
            // we have just one set of glyphs
            pgp  = pstro->pgp;
            cGlyph = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            // enumerate a set of glyphs
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
        }

        // get x and y coordinates of first glyph
        ptlOrigin.x = pgp->ptl.x;
        ptlOrigin.y = pgp->ptl.y;
        // get glyph increment
        ulCharInc = pstro->ulCharInc;

        // walk through all glyphs
        while (cGlyph-- > 0)
        {
            if (pgp->hg < MAX_GLYPHS)
            {
                // this glyph index is cacheable
                pgc = &pfc->aGlyphs[pgp->hg];
                if (pgc->xyPos == 0)
                {
                    // cache the glyph
                    AllocGlyph(pfc, pgp->pgdf->pgb, pgc);
                }
                if ((long) pgc->cSize > 0)
                {
                    RECTL rcl;
                    LONG i, cx, cy;
                    ULONG xyPos;


                    // the glyph is cached, ckeck clipping
                    rcl.left = ptlOrigin.x + pgc->ptlOrigin.x;
                    rcl.top = ptlOrigin.y + pgc->ptlOrigin.y;
                    rcl.right = rcl.left + (pgc->cSize & 0x0000FFFF);
                    rcl.bottom = rcl.top + (pgc->cSize >> 16);
                    xyPos = pgc->xyPos;

                    i = rclBounds.left - rcl.left;
                    if (i > 0)
                    {
                        // the glyph is partially clipped on the left, draw it
                        // directly
                        ClipGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin, rclBounds);
                    }
                    else
                    {
                        LogFile((BUF, "GC:H\r\n"));
                        cx = min(rcl.right, rclBounds.right) - rcl.left;
                        if (cx > 0)
                        {
                            i = rclBounds.top - rcl.top;
                            if (i > 0)
                            {
                                rcl.top += i;
                                xyPos += i << 16;
                            }
                            cy = min(rcl.bottom, rclBounds.bottom) - rcl.top;
                            if (cy > 0)
                            {
                                REQUIRE(7);
                                LL_OP0(rcl.left + ppdev->ptlOffset.x,
                                       rcl.top + ppdev->ptlOffset.y);
                                LL32(grOP2_opMRDRAM, xyPos);
                                LL_BLTEXT(cx, cy);
                            }
                        }
                    }
                }
                else if ((long) pgc->cSize == -1)
                {
                    // the glyph is uncacheable, draw it directly
                    ClipGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin, rclBounds);
                }
            }
            else
            {
                // the glyph index is out of range, draw it directly
                ClipGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin, rclBounds);
            }
            // next glyph
            pgp++;
            if (ulCharInc == 0)
            {
                ptlOrigin.x = pgp->ptl.x;
                ptlOrigin.y = pgp->ptl.y;
            }
            else
            {
                // increment glyph x coordinate
                ptlOrigin.x += ulCharInc;
            }
        }
    }
}

VOID ClipGlyph(
    PDEV*       ppdev,      // Pointer to physical device.
    GLYPHBITS*  pgb,        // Pointer to glyph to draw.
    POINTL      ptl,        // Location of glyph.
    RECTL       rclBounds   // Clipping rectangle.
)
{
    BYTE*   pjGlyph;
    LONG    cx, cy, lDelta, i;
    RECTL   rcl;
    ULONG   xBit;

    LogFile((BUF, "GC:M\r\n"));

    rcl.left = ptl.x + pgb->ptlOrigin.x;
    rcl.top = ptl.y + pgb->ptlOrigin.y;
    rcl.right = rcl.left + pgb->sizlBitmap.cx;
    rcl.bottom = rcl.top + pgb->sizlBitmap.cy;
    xBit = 0;
    pjGlyph = pgb->aj;
    lDelta = (pgb->sizlBitmap.cx + 7) >> 3;

    i = rclBounds.left - rcl.left;
    if (i > 0)
    {
        pjGlyph += i >> 3;
        xBit = i & 7;
        rcl.left += i;
    }
    cx = min(rcl.right, rclBounds.right) - rcl.left;
    if (cx > 0)
    {
        i = rclBounds.top - rcl.top;
        if (i > 0)
        {
            pjGlyph += i * lDelta;
            rcl.top += i;
        }
        cy = min(rcl.bottom, rclBounds.bottom) - rcl.top;
        if (cy > 0)
        {
            // start the blit
            REQUIRE(4);
            LL_DRAWBLTDEF(TEXT_EXPAND_XPAR, 0);
            LL_OP2(xBit, 0);

                        #if SWAT7
                        //
                        // Test for 5465AD hardware bug in 8-bpp.
                        //
                        if ((cx > 64) && (cx < 128) && (ppdev->iBytesPerPixel == 1))
                        {
                                Xfer64Pixels(ppdev, rcl.left, rcl.top, xBit, cy, pjGlyph,
                                                pgb->sizlBitmap.cx);
                                pjGlyph += 64 / 8;
                                rcl.left += 64;
                                cx -= 64;
                        }
                        #endif

            REQUIRE(5);
            LL_OP0(rcl.left + ppdev->ptlOffset.x,
                   rcl.top + ppdev->ptlOffset.y);
            LL_BLTEXT(cx, cy);

            cx = (xBit + cx + 7) >> 3;
            switch (cx)
            {
                case 1:
                    while (cy--)
                    {
                        REQUIRE(1);
                        LL32(grHOSTDATA[0], *(BYTE *) pjGlyph);
                        pjGlyph += lDelta;
                    }
                    break;

                case 2:
                    while (cy--)
                    {
                        REQUIRE(1);
                        LL32(grHOSTDATA[0], *(WORD *) pjGlyph);
                        pjGlyph += lDelta;
                    }
                    break;

                case 3:
                case 4:
                    while (cy--)
                    {
                        REQUIRE(1);
                        LL32(grHOSTDATA[0], *(DWORD *) pjGlyph);
                        pjGlyph += lDelta;
                    }
                    break;

                default:
                    while (cy--)
                    {
                                                WRITE_STRING(pjGlyph, (cx + 3) / 4);
                        pjGlyph += lDelta;
                    }
                    break;
            }

            // reset to transparent cache expansion
            REQUIRE(2);
            LL_DRAWBLTDEF(CACHE_EXPAND_XPAR, 2);
        }
    }
}

#endif  // !(USE_ASM && defined(i386))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\i386\laguna.inc ===
;===============================================================================
;
;	$Workfile:   LAGUNA.INC  $
;
;	Contents:
;	Laguna family structures and registers.
;
;	Copyright (c) 1996, Cirrus Logic, Inc.
;
;	$Log:   X:/log/laguna/nt35/displays/cl546x/i386/LAGUNA.INC  $
; 
;    Rev 1.59   Mar 25 1998 16:35:22   frido
; Added dwOverlayContr and dwCONTROL2Save variables.
; 
;    Rev 1.58   Mar 04 1998 14:43:10   frido
; Added shadowFGCOLOR.
; 
;    Rev 1.57   Feb 27 1998 17:03:34   frido
; Added shadowQFREE register and updated REQUIRE macro to use it.
; 
;    Rev 1.56   Jan 20 1998 11:45:54   frido
; Changed the REQUIRE macro for GBP on.
; Synchronized PDEV structure with C version.
; 
;    Rev 1.55   Jan 16 1998 14:06:26   frido
; Changed SOLID_COLOR_FILL so it uses the pattern.
; 
;    Rev 1.54   Nov 04 1997 09:25:22   frido
; Fixed a typo in DATASTREAMING switch.
; 
;    Rev 1.53   Nov 03 1997 16:26:04   frido
; Added fDataStreaming flag to PDEV structure.
; Changed REQUIRE macro.
; 
;    Rev 1.52   16 Oct 1997 09:50:34   bennyn
; 
; Added bPrevModeDDOutOfVideoMem to PDEV
; 
;    Rev 1.51   18 Sep 1997 16:02:18   bennyn
; Fixed compile/link problem of NT3.51
; 
;    Rev 1.50   16 Sep 1997 11:09:06   bennyn
; Fixed the DRIVERDATA mismatch in laguna.inc and driver.h
; 
;    Rev 1.49   12 Sep 1997 11:57:18   bennyn
; Fixed the PDEV misalignment and added overlay structures.
; 
;    Rev 1.48   18 Aug 1997 09:19:02   FRIDO
; 
; Added fields for bitmap filter.
; 
;    Rev 1.47   08 Aug 1997 17:19:18   FRIDO
; 
; Moved mmCore include file to after OFMHDL definition.
; 
;    Rev 1.46   08 Aug 1997 15:11:58   FRIDO
; Added automatic include file dependencies.
; 
;    Rev 1.45   08 Aug 1997 14:51:52   FRIDO
; Added support for new memory manager.
; 
;    Rev 1.44   01 Jul 1997 09:56:18   einkauf
; 
; 
; add dither x,y offsets to TMCDSYSTEM structs, to mirror PDEV changes
; 
;    Rev 1.43   23 May 1997 15:41:56   noelv
; 
; Added chip revision to pdev
; 
;    Rev 1.42   29 Apr 1997 16:29:42   noelv
; Merged in new SWAT code.
; SWAT: 
; SWAT:    Rev 1.4   24 Apr 1997 10:55:42   frido
; SWAT: NT140b09 merge.
; SWAT: Removed all memory manager changes for now.
; SWAT: 
; SWAT:    Rev 1.3   18 Apr 1997 00:26:10   frido
; SWAT: NT140b07 merge.
; SWAT: 
; SWAT:    Rev 1.2   11 Apr 1997 12:38:18   frido
; SWAT: Added OFM_HandleChain.
; SWAT: 
; SWAT:    Rev 1.1   09 Apr 1997 17:34:22   frido
; SWAT: Added fPreAllocate and nPages.
; SWAT: Added FONTCELL structure and variables.
; 
;    Rev 1.41   08 Apr 1997 11:49:34   einkauf
; 
; clean up TMCDSYSTEM struct, adds to PDEV to complete MCD
; 
;    Rev 1.40   04 Apr 1997 16:50:52   noelv
; Added pointer for new DDraw functions.
; 
;    Rev 1.39   27 Mar 1997 14:32:18   noelv
; Added new DDRAW function.
; 
;    Rev 1.38   21 Mar 1997 10:08:42   noelv
; Synced PDEV between C code and ASM code.
; Added macro to log QFREE data.
; Consolidated do_flag and sw_test_flag into a single pointer_switch flag.
; 
;    Rev 1.37   07 Mar 1997 09:35:48   SueS
; Define DO_FLAG based on NULL driver flags.
; 
;    Rev 1.36   26 Feb 1997 13:20:48   noelv
; 
; disable MCD code for NT 3.5x
; 
;    Rev 1.35   26 Feb 1997 09:24:50   noelv
; 
; Added support form OpenGL MCD driver
; 
;    Rev 1.33   28 Jan 1997 16:11:02   SueS
; Added clipping support for the 5465.
; 
;    Rev 1.32   23 Jan 1997 16:36:16   bennyn
; 
; Added 5465 DD support
; 
;    Rev 1.31   16 Jan 1997 11:32:38   bennyn
; Added power manager variables to PDEV
; 
;    Rev 1.30   10 Dec 1996 13:28:48   bennyn
; 
; Added ulFreq to PDEV
; 
;    Rev 1.29   27 Nov 1996 11:33:04   noelv
; Disabled Magic Bitmap
; 
;    Rev 1.28   18 Nov 1996 10:18:24   bennyn
; 
; Added grFormat to PDEV
; 
;    Rev 1.27   12 Nov 1996 15:17:16   bennyn
; 
; Added handle for DD blt scratch buffer
; 
;    Rev 1.26   07 Nov 1996 16:16:24   bennyn
; 
; Added support to alloc offscn mem in DD createsurface
; 
;    Rev 1.25   01 Nov 1996 09:21:12   BENNYN
; 
; Added support for DD blt code
; 
;    Rev 1.24   31 Oct 1996 11:13:44   noelv
; Split common buffer into two buffers.
; 
;    Rev 1.23   25 Oct 1996 11:53:06   noelv
; 
; added second common buffer
; 
;    Rev 1.22   23 Oct 1996 14:40:26   BENNYN
; 
; Added YUV cursor variables to PDEV
; 
;    Rev 1.21   04 Oct 1996 16:46:56   bennyn
; Added DirectDraw YUV support
; 
;    Rev 1.20   18 Sep 1996 13:56:08   bennyn
; Modified to support DD stretchBLT
; 
;    Rev 1.19   20 Aug 1996 11:29:00   noelv
; Bugfix release from Frido 8-19-96
; 
;    Rev 1.1   17 Aug 1996 12:32:50   frido
; New release from Bellevue.
; 
;    Rev 1.18   16 Aug 1996 08:59:02   bennyn
; 
; Moved bUseSWPtr outside of #ifdef WINNT_VER40
; 
;    Rev 1.17   16 Aug 1996 08:47:58   bennyn
; Modified to fix DirectDraw cursor problem
; 
;    Rev 1.16   25 Jul 1996 15:50:32   bennyn
; 
; Modified to support DirectDraw
; 
;    Rev 1.15   16 Jul 1996 14:26:44   BENNYN
; 
; 
;    Rev 1.14   11 Jul 1996 15:51:00   bennyn
; 
; Added DirectDraw support
; 
;    Rev 1.13   23 May 1996 16:23:06   BENNYN
; 
; Added SubFreeQ declarations
; 
;    Rev 1.12   08 May 1996 17:03:52   noelv
; preallocate device bitmap.
; 
;    Rev 1.11   03 May 1996 15:22:44   noelv
; added switch to turn font cache on and off
; 
;    Rev 1.10   01 May 1996 11:06:00   bennyn
; Modified for NT 4.0
; 
;    Rev 1.9   10 Apr 1996 13:40:02   NOELV
; Frido release 27
;	
;	   Rev 1.18   07 Apr 1996 17:12:30   frido
;	Added solid brush cache.
;	
;	   Rev 1.17   01 Apr 1996 13:58:40   frido
;	Changed layout of brush cache.
;	
;	   Rev 1.16   25 Mar 1996 11:42:18   frido
;	Bellevue 102B3.
; 
;    Rev 1.7   14 Mar 1996 09:40:08   andys
; 
; Added dcTileWidth and dsSRAMWidth
; 
;    Rev 1.6   12 Mar 1996 15:47:24   noelv
; Added support for stroke and fill path
; 
;    Rev 1.5   11 Mar 1996 11:53:40   noelv
; Added file pointer to PDEV
; 
;    Rev 1.4   08 Mar 1996 11:07:32   BENNYN
; 
;    Rev 1.3   05 Mar 1996 12:03:48   noelv
; Frido version 19
;	
;	   Rev 1.13   29 Feb 1996 19:57:10   frido
;	Added bEnable to PDEV structure.
;	
;	   Rev 1.12   27 Feb 1996 16:39:42   frido
;	Added device bitmap store/restore.
;	Changed DSURF structure.
;	
;	   Rev 1.11   26 Feb 1996 23:39:10   frido
;	Added function pointers for ScreenToHost and HostToScreen.
;	
;	   Rev 1.10   24 Feb 1996 01:22:40   frido
;	Added device bitmaps.
;	
;	   Rev 1.9   19 Feb 1996 05:10:50   frido
;	Changed broken_FIFO to 0.
;	
;	   Rev 1.8   17 Feb 1996 21:46:22   frido
;	Revamped brushing algorithmn.
;	
;	   Rev 1.7   13 Feb 1996 16:51:44   frido
;	Changed the layout of the PDEV structure.
;	Changed the layout of all brush caches.
;	Changed the number of brush caches.
;	
;	   Rev 1.6   10 Feb 1996 21:48:36   frido
;	Split monochrome and colored translation cache.
;	
;	   Rev 1.5   08 Feb 1996 00:03:06   frido
;	Added some extra definitions from Driver.h.
;	Changed number of XLATE caches to 8.
;	
;	   Rev 1.4   05 Feb 1996 17:35:10   frido
;	Added translation cache.
;	
;	   Rev 1.3   31 Jan 1996 13:48:32   frido
;	Added engine macros.
;	
;	   Rev 1.2   25 Jan 1996 22:03:10   frido
;	Added some more structures for the PatBLT.
;	
;	   Rev 1.1   25 Jan 1996 12:44:44   frido
;	Added font cache ID counter.
;	
;	   Rev 1.0   24 Jan 1996 23:13:40   frido
;	 Initial release.
;
;===============================================================================

.NOLIST
INCLUDE Optimize.h
INCLUDE SWAT.h
COMMENT ~		;automatic include file dependencies for BUILD.EXE
#include "Optimize.h"
#include "SWAT.h"
~
.LIST

; DirectDraw
; Be sure to synchronize these structures with those in driver.h!
ACCUM                 =     0
MAJ                   =     1
MIN                   =     2
MAX_REGS              =     3

MAX_FOURCCS           =     3
MAX_VIDEO_WINDOWS     =     8

; Bits defined in DrvSemaphore
; Be sure to synchronize these structures with those in driver.h!
DRVSEM_CURSOR_REMOVED_BIT    =     0
DRVSEM_HW_CURSOR_BIT         =     1
DRVSEM_IN_USE_BIT            =     2
DRVSEM_NEW_CURSOR_XY_BIT     =     3
DRVSEM_CHECK_CURSOR_BIT      =     4
DRVSEM_CURSOR_IN_USE_BIT     =     5
DRVSEM_CURSOR_CHANGED_BIT    =     6
DRVSEM_3D_BUSY_BIT           =     7
DRVSEM_MISSED_SET_BIT        =     8
DRVSEM_YUV_ON_BIT            =     9
DRVSEM_DISABLE_SETS_BIT      =     10
DRVSEM_YUV_RECT_VALID_BIT    =     11

; the corresponding mask values
; Be sure to synchronize these structures with those in driver.h!
DRVSEM_CURSOR_REMOVED        =     00000001h
DRVSEM_HW_CURSOR             =     00000002h
DRVSEM_IN_USE                =     00000004h
DRVSEM_NEW_CURSOR_XY         =     00000008h
DRVSEM_CHECK_CURSOR          =     00000010h
DRVSEM_CURSOR_IN_USE         =     00000020h
DRVSEM_CURSOR_CHANGED        =     00000040h
DRVSEM_3D_BUSY               =     00000080h
DRVSEM_MISSED_SET            =     00000100h
DRVSEM_YUV_ON                =     00000200h
DRVSEM_DISABLE_SETS          =     00000400h
DRVSEM_YUV_RECT_VALID        =     00000800h

broken_FIFO		=		0

autoblt_regs STRUCT
  LNCNTL		WORD		?
  SHRINKINC		WORD		?
  DRAWBLTDEF		DWORD		?
  FGCOLOR		DWORD		?
  BGCOLOR		DWORD		?
  OP0_opRDRAM		DWORD		?
  MAJ_Y			WORD		?
  MIN_Y			WORD		?
  OP1_opRDRAM		DWORD		?
  ACCUM_Y		WORD		?
  PATOFF		WORD		?
  OP2_opRDRAM		DWORD		?
  MAJ_X			WORD		?
  MIN_X			WORD		?
  BLTEXT		DWORD		?
  ACCUM_X		WORD		?
  OP0_opSRAM		WORD		?
  SRCX			WORD		?
  OP2_opSRAM		WORD		?
  BLTEXTR_EX            DWORD		?
  MBLTEXTR_EX           DWORD		?
  OP0_opMRDRAM          DWORD		?
  OP1_opMRDRAM          DWORD		?
  STRETCH_CNTL          WORD		?
  RESERVED              WORD		?
  CLIPULE               DWORD		?
  CLIPLOR               DWORD		?
  NEXT_HEAD		DWORD		?
autoblt_regs ENDS

NUM_MONO_BRUSHES	=		32
NUM_4BPP_BRUSHES	=		8
NUM_DITHER_BRUSHES	=		8
NUM_COLOR_BRUSHES	=		32
NUM_8BPP_BRUSHES	=		(NUM_COLOR_BRUSHES)
NUM_16BPP_BRUSHES	=		(NUM_COLOR_BRUSHES/2)
NUM_TC_BRUSHES		=		(NUM_COLOR_BRUSHES/4)
;//frido BEGIN 07-Apr-96
NUM_SOLID_BRUSHES	=		4
;//frido END 07-Apr-96

;//frido BEGIN 01-Apr-96
;FIRST_MONO_ROW		=		0
;NUM_MONO_ROWS		=		(NUM_MONO_BRUSHES/16)
;FIRST_4BPP_ROW		=		(FIRST_MONO_ROW + NUM_MONO_ROWS)
;NUM_4BPP_ROWS		=		(NUM_4BPP_BRUSHES*2)
;FIRST_DITHER_ROW	=		(FIRST_4BPP_ROW + NUM_4BPP_ROWS)
;NUM_DITHER_ROWS   	=		(NUM_DITHER_BRUSHES/2)
;FIRST_COLOR_ROW   	=		(FIRST_DITHER_ROW + NUM_DITHER_ROWS)
;NUM_COLOR_ROWS		=		(NUM_COLOR_BRUSHES/2)
;//frido END 01-Apr-96

RBRUSH STRUCT
  nPatSize		ULONG		?
  iBitmapFormat		ULONG		?
  ulForeColor		ULONG		?
  ulBackColor		ULONG		?
  iType			ULONG		?
    BRUSH_MONO		=		1
    BRUSH_4BPP		=		2
    BRUSH_DITHER	=		3
    BRUSH_COLOR		=		4
  iUniq			ULONG		?
  cache_slot		ULONG		?
  cache_xy		ULONG		?
  cjMask		ULONG		?
  ajPattern		BYTE		0 DUP(?)
RBRUSH ENDS

BC_ENTRY STRUCT
  xy			ULONG		?
  pjLinear		DWORD		?
  brushID		DWORD		?
BC_ENTRY ENDS

DC_ENTRY STRUCT
  xy			ULONG		?
  pjLinear		DWORD		?
  ulColor		ULONG		?
DC_ENTRY ENDS

MC_ENTRY STRUCT
  xy			ULONG		?
  pjLinear		DWORD		?
  iUniq			ULONG		?
  ajPattern		BYTE		8 DUP(?)
MC_ENTRY ENDS

XC_ENTRY STRUCT
  xy			ULONG		?
  pjLinear		DWORD		?
  iUniq			ULONG		?
  ajPattern		BYTE		8 * 4 DUP(?)
  ajPalette		ULONG		16 DUP(?)
XC_ENTRY ENDS

POFM_CALLBACK		TYPEDEF		PTR

OFMHDL STRUCT
  x			ULONG		?
  y			ULONG		?
  aligned_x		ULONG		?
  aligned_y		ULONG		?
  sizex			LONG		?
  sizey			LONG		?
  alignflag		ULONG		?
  flag			ULONG		?
  pcallback		POFM_CALLBACK	?
  prevhdl		DWORD		?
  nexthdl		DWORD		?
  subprvhdl		DWORD		?
  subnxthdl		DWORD		?
  prvFonthdl		DWORD		?
  nxtFonthdl		DWORD		?
  pdsurf		DWORD		?
OFMHDL ENDS
POFMHDL			TYPEDEF		PTR OFMHDL

IF MEMMGR
  INCLUDE mmCore.h
ENDIF
COMMENT ~
#include "mmCore.h" //automatic include file dependencies for BUILD.EXE
~

DDOFM STRUCT
  prevhdl      	DWORD        	?
  nexthdl	DWORD		?
  phdl		POFMHDL		?
DDOFM ENDS
PDDOFM			TYPEDEF		PTR DDOFM


MAX_GLYPHS		=		256
FONTMEMORY STRUCT
  pTile			DWORD		?
  ulLastX		DWORD		?
  pNext			DWORD		?
FONTMEMORY ENDS

GLYPHCACHE STRUCT
  xyPos			DWORD		?
  cSize			DWORD		?
  ptlOrigin		POINTL		{}
GLYPHCACHE ENDS

; New SWAT3 structure.
FONTCELL STRUCT
  x			DWORD		?
  y			DWORD		?
  pfc			DWORD		?
  ulLastX		DWORD		?
  pNext			DWORD		?
FONTCELL ENDS
PFONTCELL		TYPEDEF		PTR FONTCELL

FONTCACHE STRUCT
  ppdev			DWORD		?
  pFontMemory		DWORD		?
  pFontCell		PFONTCELL	?	;SWAT3
  ulFontCount		ULONG		?
  aGlyphs		GLYPHCACHE	MAX_GLYPHS DUP({})
  pfo                   DWORD		?
  pfcPrev               DWORD		?
  pfcNext               DWORD		?
FONTCACHE ENDS
PFONTCACHE      	TYPEDEF		PTR FONTCACHE

OFFSCR_YUV STRUCT
  SrcRect               RECTL		{}
  nInUse  		WORD		?
  ratio                 WORD		?
OFFSCR_YUV ENDS
POFFSCR_YUV  		TYPEDEF		PTR OFFSCR_YUV

if DRIVER_5465
ifdef OVERLAY

VIDCONFIG STRUCT
   sizXfer		SIZEL		{}
   sizCap		SIZEL		{}
   sizSrc		SIZEL		{}
   sizDisp		SIZEL		{}
   uXferDepth           DWORD           ?
   uCapDepth            DWORD           ?
   uSrcDepth            DWORD           ?
   uDispDepth           DWORD           ?
   uGfxDepth            DWORD           ?
   dwXferRate           DWORD           ?
   dwFlags              DWORD           ?
VIDCONFIG ENDS
LPVIDCONFIG  		TYPEDEF		PTR VIDCONFIG


PROGREGS STRUCT
   VW0_FIFO_THRSH          WORD            ?
   DispThrsTiming          WORD            ?
PROGREGS ENDS
LPPROGREGS  		TYPEDEF		PTR PROGREGS


OVERLAYFLIPRECORD STRUCT
   fpFlipFrom                 PBYTE        ?
   liFlipTime                 DWORD        ?
                              DWORD        ?
                              DWORD        ?
                              DWORD        ?
   dwFlipDuration             DWORD        ?
   dwFlipScanline             DWORD        ?
   bFlipFlag                  BOOL	   ?
   bHaveEverCrossedVBlank     BOOL	   ?
   bWasEverInDisplay          BOOL	   ?
OVERLAYFLIPRECORD ENDS


OVERLAYTABLE STRUCT
   pfnCanCreateSurface        DWORD        ?
   pfnCreateSurface           DWORD        ?
   pfnDestroySurface          DWORD        ?
   pfnLock                    DWORD        ?
   pfnUnlock                  DWORD        ?
   pfnSetColorKey             DWORD        ?
   pfnFlip                    DWORD        ?
   pfnUpdateOverlay           DWORD        ?
   pfnSetOverlayPos           DWORD        ?
   pfnGetFlipStatus           DWORD        ?
OVERLAYTABLE ENDS
LPOVERLAYTABLE  		TYPEDEF		PTR OVERLAYTABLE

endif ; OVERLAY
endif ; DRIVER_5465


DRIVERDATA STRUCT
   PTAGFooPixel         DWORD           ?
   fNineBitRDRAMS       WORD            ?
   fReset               BOOL		?
   ScreenAddress        PBYTE           ?
   VideoBase            PBYTE           ?
   RegsAddress          DWORD	        ?
   DrvSemaphore         WORD            ?
   EdgeTrim             WORD            ?
   YUVTop               WORD            ?
   YUVLeft              WORD            ?
   YUVXExt              WORD            ?
   YUVYExt              WORD            ?
   VideoSemaphore       WORD            ?
   CurrentVideoFormat   WORD            ?
   NumVideoSurfaces     WORD            ?
   ScratchBufferOrg     DWORD           ?

ifdef WINNT_VER40
if DRIVER_5465
ifdef OVERLAY
   fOverlaySupport      BOOL		?
   OverlayTable		OVERLAYTABLE	{}
   dwOverlayCount	DWORD		?
   dwCONTROL2Save	DWORD		?

   ; Win95 5465over.c static vars
   bUseBWEqn            BOOL		?
   bNoOverlayInThisMode BOOL		?

   lpHardwareOwner  	DWORD           MAX_VIDEO_WINDOWS DUP (?)
   lpColorSurfaceVW  	DWORD           MAX_VIDEO_WINDOWS DUP (?)
   lpSrcColorSurfaceVW  DWORD           MAX_VIDEO_WINDOWS DUP (?)

   grOverlaySrc		RECTL           MAX_VIDEO_WINDOWS DUP ({})
   grOverlayDest 	RECTL           MAX_VIDEO_WINDOWS DUP ({})
   gdwFourccVW 	        DWORD           MAX_VIDEO_WINDOWS DUP (?)
   bIsVWMirrored        BOOL	        MAX_VIDEO_WINDOWS DUP (?)

   gdwAvailVW           DWORD           ?
   gdwColorKey          DWORD           ?
   gdwSrcColorKeyLow    DWORD           ?
   gdwSrcColorKeyHigh   DWORD           ?
   gdwDestColorKeyOwnerVW DWORD         ?
   gdwSrcColorKeyOwnerVW  DWORD         ?

   giOvlyCnt 	        DWORD           MAX_VIDEO_WINDOWS DUP (?)
   giPlanarCnt          DWORD           ?
   bCLPLLobotomyMode    BOOL		?

   ; Win95 5465over.c global vars
   gsOverlayFlip 	OVERLAYFLIPRECORD	{}

   gsProgRegs           PROGREGS        {}

   gvidConfig           VIDCONFIG       {}

   gwNormalDTTR         WORD            ?
   dwNumVideoWindows    DWORD           ?

   bEnableCLPL          BOOL		?

   ; NT only data
   dwMaxOverlayStretch  DWORD           ?
   dwMinOverlayStretch  DWORD           ?

   dwFourCC 	        DWORD           MAX_FOURCCS DUP (?)
else
   dwFourCC             DWORD           ?
endif ; OVERLAY
else
   dwFourCC             DWORD           ?
endif ; DRIVER_5465
endif ; WINNT_VER40

   signature            DWORD           ?

DRIVERDATA ENDS
PDRIVERDATA  		TYPEDEF		PTR DRIVERDATA

FLIPRECORD STRUCT
ifdef WINNT_VER40
   fpFlipFrom              PBYTE        ?
endif
   liFlipTime              DWORD        ?
                           DWORD        ?
   liFlipDuration          DWORD        ?
                           DWORD        ?
   bFlipFlag               BOOL		?
   bHaveEverCrossedVBlank  BOOL		?
   bWasEverInDisplay       BOOL		?
   dwFlipScanLine          WORD         ?
FLIPRECORD ENDS
PFLIPRECORD  		TYPEDEF		PTR FLIPRECORD


LL_RECT STRUCT
    DWORD left                          ?
    DWORD top                           ?
    DWORD right                         ?
    DWORD bottom                        ?
LL_RECT ENDS

TDISPLAYLIST STRUCT
    pdwNext                 DWORD       ?
    hMem                    DWORD       ?
    pdwLinPtr               DWORD       ?
    pdwStartOutPtr          DWORD       ?
    dwPhyPtr                DWORD       ?
    dwLen                   DWORD       ?
    dwMargin                DWORD       ?
TDISPLAYLIST ENDS
PTRDL TYPEDEF		PTR TDISPLAYLIST

NUM_DL      =       2

LL_PATTERN STRUCT
    pat DWORD   8 DUP(?)
LL_PATTERN ENDS

TMCDSYSTEM STRUCT
    rColor_Min_Bounds       DWORD       ?
    rColor_Max_Bounds       DWORD       ?
    AlphaConstSource        DWORD       ?
    AlphaConstDest          DWORD       ?
    Displists  TDISPLAYLIST    NUM_DL  DUP({})
    pDL                     PTRDL       ?
    dwCdl                   DWORD       ?
    pRegs                   DWORD       ?
    pFrame                  PBYTE       ?
    pattern_ram_state       DWORD       ?
	dither_array            LL_PATTERN  {}	
    dither_x_offset         WORD        ?
    dither_y_offset         WORD        ?
TMCDSYSTEM  ENDS

;temporary mem for MCD display lists
SIZE_TEMP_DL    =     2048   
SIZE_FRECIP     =     2048+1

PDEV STRUCT
  hDriver		HANDLE		?
  hdevEng		HANDLE		?
  hsurfEng		HANDLE		?
  hPalDefault		HANDLE		?
  pjScreen		PBYTE		?
  cxScreen		ULONG		?
  cyScreen		ULONG		?
  cxMemory              ULONG           ?
  cyMemory              ULONG           ?
  cyMemoryReal          ULONG           ?
  ulMode		ULONG		?
  ulFreq		ULONG		?
  lDeltaScreen		LONG		?
  flRed			FLONG		?
  flGreen		FLONG		?
  flBlue		FLONG		?
  cPaletteShift		ULONG		?
  ptlHotSpot		POINTL		{}
  cPatterns		ULONG		?
  ahbmPat		HANDLE		HS_DDI_MAX DUP(?)
  pPal			DWORD		?
  pjOffScreen		PBYTE		?
  iBitmapFormat		ULONG		?
  ulBitCount		ULONG		?
  iBytesPerPixel	ULONG		?
  PtrABlt		autoblt_regs	3 DUP({})

ifdef WINNT_VER40
  CShsem		HANDLE		?
else
  PtrCritSec		CRITICAL_SECTION {}
endif

  prcl			RECTL		{}
  PtrBusy		BOOL		?
  fHwCursorActive	BOOL		?
  CursorHidden		BOOL		?
  PtrMaskHandle		POFMHDL		?
  PtrImageHandle	POFMHDL		?
  PtrABltHandle		POFMHDL		?
  PtrXHotSpot		ULONG		?
  PtrYHotSpot		ULONG		?
  PtrX			ULONG		?
  PtrY			ULONG		?
  PtrSzX		ULONG		?
  PtrSzY		ULONG		?
  PointerUsage		LONG		?
  grCONTROL             DWORD           ?
  grFORMAT              DWORD           ?
  grVSCONTROL           DWORD           ?
  lOffset_2D		LONG		?
  lTileSize		LONG		?
  lTotalMem		LONG		?
  OFM_init		BOOL		?

ifdef WINNT_VER40
  MMhsem		HANDLE		?
else
  MutexHdl		HANDLE		?
endif

  bDirectDrawInUse	BOOL		?
  ScrnHandle		POFMHDL		?
  OFM_UsedQ		POFMHDL		?
  OFM_FreeQ		POFMHDL		?
  OFM_SubFreeQ1		POFMHDL		?
  OFM_SubFreeQ2		POFMHDL		?
  pfcChain              PFONTCACHE      ?

  Bcache		POFMHDL		?

  Mtable		MC_ENTRY	NUM_MONO_BRUSHES DUP({})
  Xtable		XC_ENTRY	NUM_4BPP_BRUSHES DUP({})
  Dtable		DC_ENTRY	NUM_DITHER_BRUSHES DUP({})
  Ctable		BC_ENTRY	NUM_COLOR_BRUSHES DUP({})
;frido BEGIN 07-Apr-96
  Stable		DC_ENTRY	NUM_SOLID_BRUSHES DUP({})
  SNext			ULONG		?
;frido END 07-Apr-96
  CLast			ULONG		?
  MNext			ULONG		?
  XNext			ULONG		?
  DNext			ULONG		?
  CNext			ULONG		?

  ulFontCount		ULONG		?
  UseFontCache		ULONG		?

  ptlOffset		POINTL		{}
  bEnable		BOOL		?

  pfnHostToScreen	DWORD		?
  pfnScreenToHost	DWORD		?

  pLgREGS_real		DWORD		?
  pLgREGS		DWORD		?

  dcTileWidth		WORD		?
  dcSRAMWidth		WORD		?

  uBLTDEF		    ULONG		?
  uRop			    ULONG		?
  pvTmpBuffer		DWORD		?


  IF ENABLE_LOG_FILE 
    pmfile          DWORD           ? 
    TxtBuff         DWORD   1000h   DUP(?) 
    TxtBuffIndex    DWORD           ?
  ENDIF

  IF NULL_HW
    buffer          BYTE    1000h   DUP(?)
  ENDIF

  IF WINBENCH96
    pofmMagic           POFMHDL		?
    bMagicUsed          ULONG		?
  ENDIF

; SWAT1 changes.
  fPreAllocate		BOOL		?
  nPages		DWORD		?
; SWAT3 changes.
  FONTCELL_COUNT	=		64
  FONTCELL_X		=		128
  FONTCELL_y		=		16
  pofmFontCache		POFMHDL		?
  fcGrid		FONTCELL	FONTCELL_COUNT DUP({})
IF MEMMGR
; MEMMGR changes.
  mmMemMgr		IIMEMMGR	{}
  must_have_width	LONG		?
  bBitmapFilter		BOOL		?
  szlBitmapMin		SIZEL		{}
  szlBitmapMax		SIZEL		{}
ENDIF

  ; For DirectDraw      
  bPrevModeDDOutOfVideoMem  BOOL	?
  DirectDrawHandle      POFMHDL		?
  flipRecord            FLIPRECORD      {}
  DriverData            DRIVERDATA      {}
  offscr_YUV            OFFSCR_YUV      {}
  dwDDLinearCnt		DWORD		?
  pPtrMaskHost		PBYTE		?

  bYUVuseSWPtr     	BOOL		?
  dwLgDevID     	DWORD		?
  dwLgDevRev     	DWORD		?
  bYUVSurfaceOn         BOOL            ?
  InitBPP               WORD		?

  lRegVals              DWORD           2 * MAX_REGS DUP(?)
  sShrinkInc            DWORD		?
  usLnCntl              DWORD		?
  usStretchCtrl         DWORD		?

  pPMdatabuf            PBYTE		?

ifdef WINNT_VER40
  pfnDelay9BitBlt       DWORD		?
  pfnEdgeFillBlt        DWORD		?
  pfnMEdgeFillBlt       DWORD		?
  pfnDrvDstBlt          DWORD		?
  pfnDrvDstMBlt         DWORD		? 
  pfnDrvSrcBlt          DWORD		?
  pfnDrvSrcMBlt         DWORD		?
  pfnDrvStrBlt          DWORD		?
  pfnDrvStrMBlt         DWORD		?
  pfnDrvStrMBltY        DWORD		?
  pfnDrvStrMBltX        DWORD		?
  pfnDrvStrBltY         DWORD		?
  pfnDrvStrBltX         DWORD		?
endif

   DDScratchBufHandle   POFMHDL     ?
   DDOffScnMemQ         PDDOFM      ?

  IFDEF BUS_MASTER
    Buf1VirtAddr 	DWORD       ?
    Buf2VirtAddr 	DWORD       ?
    Buf1PhysAddr 	DWORD       ?
    Buf2PhysAddr 	DWORD       ?
    BufLength 		ULONG       ?
  ENDIF

  ;START OpenGL MCD additions
  IFNDEF WINNT_VER35
    hMCD                 HANDLE     ?
    pMCDFilterFunc       DWORD      ?
    cDoubleBufferRef     DWORD      ?
    cZBufferRef          DWORD      ?
    pohBackBuffer        POFMHDL	?
    pohZBuffer           POFMHDL	?

    temp_DL_chunk        DWORD		SIZE_TEMP_DL DUP(?)
    LL_State             TMCDSYSTEM {}

    pAllocOffScnMem      DWORD      ?
    pFreeOffScnMem       DWORD      ?
    pAssertModeMCD       DWORD      ?

    frecips              DWORD		SIZE_FRECIP DUP(?)

    pLastDevRC           DWORD      ?
    NumMCDContexts       DWORD      ?
    iUniqueness          DWORD      ?
    pFirstTexture        DWORD      ?
    pLastTexture         DWORD      ?
  ENDIF
  ;END OpenGL MCD additions

  XlateCache          POFMHDL ?
  XlateCacheId        ULONG   ?
  CachedChromaCtrl    WORD    ?
  CachedStretchCtrl   WORD    ?
                                      
  signature           DWORD   ?

if DATASTREAMING
   dwDataStreaming	DWORD		?
   shadowFGCOLOR	DWORD		?
   shadowBGCOLOR	DWORD		?
   shadowDRAWBLTDEF	DWORD		?
   shadowQFREE		BYTE		?
endif
PDEV ENDS

DSURF STRUCT
  ppdev			DWORD		?
  pofm			DWORD		?
  pso			DWORD		?
  ptl			POINTL		{}
  sizl			SIZEL		{}
  packedXY		DWORD		?
DSURF ENDS

TEXT_EXPAND_XPAR	=		106601F0h
TEXT_EXPAND_OPAQUE	=		100600F0h
SOLID_COLOR_FILL	=		100700F0h
CLIPEN			=		0800h

grSTATUS		=		400h
grCONTROL		=		402h
grQFREE			=		404h
grOFFSET_2D		=		405h
grTIMEOUT		=		406h
grTILE_CTRL		=		407h
grRESIZE_A_opRDRAM	=		408h
grRESIZE_B_opRDRAM	=		40Ch
grRESIZE_C_opRDRAM	=		410h
grCOMMAND		=		480h
grMIN_Y			=		500h
grMAJ_Y			=		502h
grACCUM_Y		=		504h
grMIN_X			=		508h
grMAJ_X			=		50Ah
grACCUM_X		=		50Ch
grLNCNTL		=		50Eh
grBLTEXT		=		518h
grMBLTEXT		=		51Ch
grOP0_opRDRAM		=		520h
grOP0_opMRDRAM		=		524h
grOP0_opSRAM		=		528h
grPATOFF		=		52Ah
grOP1_opRDRAM		=		540h
grOP1_opMRDRAM		=		544h
grOP1_opSRAM		=		548h
grOP1_opMSRAM		=		54Ah
grOP2_opRDRAM		=		560h
grOP2_opMRDRAM		=		564h
grOP2_opSRAM		=		568h
grOP2_opMSRAM		=		56Ah
grSRCX			=		580h
grSHRINKINC		=		582h
grDRAWBLTDEF		=		584h
grDRAWDEF		=		584h
grBLTDEF		=		586h
grMONOQW		=		588h
grCLIPULE		=		590h
grCLIPLOR		=		594h
grMCLIPULE		=		598h
grMCLIPLOR		=		59Ch
grOP_opFGCOLOR		=		5E0h
grOP_opBGCOLOR		=		5E4h
grBITMASK		=		5E8h
grPTAG			=		5ECh
grBOGUS			=		5FCh
grBLTEXT_XEX		=		600h
grBLTEXTFF_XEX		=		604h
grBLTEXTR_XEX		=		608h
grBLTEXT_LN_EX		=		60Ch
grMBLTEXT_XEX		=		620h
grMBLTEXTR_XEX		=		628h
grBLTEXT_EX		=		700h
grBLTEXTFF_EX		=		704h
grBLTEXTR_EX		=		708h
grMBLTEXT_EX		=		720h
grMBLTEXTR_EX		=		728h
grCLIPULE_EX		=		760h
grCLIPLOR_EX		=		770h
grMCLIPULE_EX		=		780h
grMCLIPLOR_EX		=		790h
grHOSTDATA		=		800h

SWIZ_CNTL		=		0400h

ENUMRECTS8 STRUCT
  _c			DWORD		?
  arcl			RECTL		8 DUP({})
ENUMRECTS8 ENDS

FUDGE			=		2	;fudge factor for QFREE register

REQUIRE MACRO n:REQ, ppdev:REQ, base:=<ebp>
  LOCAL WaitFIFO, SkipWait, WaitIdle, SkipWaitUpdate, WaitLoop
  IF DATASTREAMING
    TEMPREG8 TEXTEQU <>
    TEMPREG32 TEXTEQU <>
    IFDIFI <ppdev>, <eax>
      IFDIFI <base>, <eax>
        TEMPREG8 TEXTEQU <al>
        TEMPREG32 TEXTEQU <aex>
      ENDIF
    ENDIF
    IFDIFI <ppdev>, <ebx>
      IFDIFI <base>, <ebx>
        TEMPREG8 TEXTEQU <bl>
        TEMPREG32 TEXTEQU <ebx>
      ENDIF
    ENDIF
    IFDIFI <ppdev>, <ecx>
      IFDIFI <base>, <ecx>
        TEMPREG8 TEXTEQU <cl>
        TEMPREG32 TEXTEQU <ecx>
      ENDIF
    ENDIF
    IFDIFI <ppdev>, <edx>
      IFDIFI <base>, <edx>
        TEMPREG8 TEXTEQU <dl>
        TEMPREG32 TEXTEQU <edx>
      ENDIF
    ENDIF
	test	[ppdev].dwDataStreaming, -1
	js	WaitFIFO
	jz	SkipWait
	cmp	BYTE PTR [base + grQFREE], n + FUDGE
	jnb	SkipWait
WaitIdle:
	test	WORD PTR [base + grSTATUS], 8005h
	jnz	WaitIdle
	mov	byte ptr [ppdev].dwDataStreaming, 0
	jmp	SkipWait
WaitFIFO:
	push	TEMPREG32
	mov	TEMPREG8, [ppdev].shadowQFREE
WaitLoop:
	cmp	TEMPREG8, n + FUDGE
	jnb	SkipWaitUpdate
	mov	TEMPREG8, [base + grQFREE]
	jmp	WaitLoop
SkipWaitUpdate:
	sub	TEMPREG8, n
	mov	[ppdev].shadowQFREE, TEMPREG8
	pop	TEMPREG32
SkipWait:
  ENDIF
ENDM

IDLE MACRO base:=<ebp>
  LOCAL WaitFIFO
WaitFIFO:
	cmp	WORD PTR [base + grSTATUS], 0
	jne	WaitFIFO
ENDM

ENDREQUIRE MACRO ppdev:REQ
  IF DATASTREAMING
	or	[ppdev].dwDataStreaming, 1
  ENDIF
ENDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\i386\text.asm ===
;===============================================================================
;
;       $Workfile:   TEXT.ASM  $
;
;       Contents:
;       This file contains the assembly code for the text output routine.
;
;       Copyright (c) 1996, Cirrus Logic, Inc.
;
;       $Log:   //uinac/log/log/laguna/nt35/displays/cl546x/i386/TEXT.ASM  $
; 
;    Rev 1.23   Jun 22 1998 11:07:36   frido
; PDR#11546. Fixed save/restore in clipping BugLoop and also
; the register increments in DrawLoop.
; 
;    Rev 1.22   Mar 04 1998 15:47:14   frido
; Added more shadowing.
; 
;    Rev 1.21   Jan 21 1998 17:12:36   frido
; Added SWAT6 switches to stripe the opaque rectangles.
; 
;    Rev 1.20   Jan 20 1998 11:45:12   frido
; Added shadowing for DRAWBLTDEF and BGCOLOR registers.
; 
;    Rev 1.19   Dec 11 1997 16:02:46   frido
; Oops...
; 
;    Rev 1.18   Dec 11 1997 15:41:18   frido
; PDR#10875: There was a very weird instruction in the DrawGlyph
; routine with clipped non-cacheable glyphs.
; 
;    Rev 1.17   Nov 03 1997 17:41:58   frido
; Added REQUIRE macros.
; 
;    Rev 1.16   08 Aug 1997 17:22:32   FRIDO
; Added SWAT7 switches for 8-bpp hardware bug.
; 
;    Rev 1.15   29 Apr 1997 16:29:40   noelv
; Merged in new SWAT code.
; SWAT: 
; SWAT:    Rev 1.3   24 Apr 1997 10:45:54   frido
; SWAT: NT140b09 merge.
; SWAT: 
; SWAT:    Rev 1.2   19 Apr 1997 16:31:54   frido
; SWAT: Added automatic include file dependencies for BUILD.EXE.
; 
;    Rev 1.14   08 Apr 1997 11:48:24   einkauf
; 
; add call to SYNC_W_3D for MCD coordination
; 
;    Rev 1.13   21 Mar 1997 10:10:20   noelv
; Synced PDEV between C code and ASM code.
; Added macro to log QFREE data.
; Consolidated do_flag and sw_test_flag into a single pointer_switch flag.
; 
;    Rev 1.12   07 Mar 1997 09:41:02   SueS
; Added NULL_TEXTOUT flag to assembly code.  Changed order of include files.
; 
;    Rev 1.11   05 Mar 1997 10:37:32   noelv
; 
; Marked where to put tests for QFREE
; 
;    Rev 1.10   04 Feb 1997 12:19:28   SueS
; Added support for hardware clipping for the 5465.
; 
;    Rev 1.9   20 Aug 1996 11:28:52   noelv
; Bugfix release from Frido 8-19-96
; 
;    Rev 1.0   14 Aug 1996 17:14:38   frido
; Initial revision.
; 
;    Rev 1.8   25 Jul 1996 15:49:52   bennyn
; Modified to support DirectDraw
; 
;    Rev 1.7   03 May 1996 15:24:24   noelv
; 
; Added switch to turn font caching on and off.
; 
;    Rev 1.6   01 May 1996 11:06:46   bennyn
; 
; Modified for NT 4.0
; 
;    Rev 1.5   04 Apr 1996 13:22:18   noelv
; Frido version 26
;       
;          Rev 1.14   28 Mar 1996 23:38:52   frido
;       Fixed drawing of partially left-clipped glyphs.
;       
;          Rev 1.13   04 Mar 1996 20:23:50   frido
;       Cached grCONTROL register.
;       
;          Rev 1.12   29 Feb 1996 20:21:32   frido
;       Fixed some pointer updates.
;       
;          Rev 1.11   28 Feb 1996 22:40:22   frido
;       Added Optimize.h.
;       
;          Rev 1.10   27 Feb 1996 23:52:40   frido
;       Removed bug in DrawGlyph with non clipped characters.
;       
;          Rev 1.9   27 Feb 1996 16:39:54   frido
;       Added device bitmap store/restore.
;       
;          Rev 1.8   24 Feb 1996 01:22:58   frido
;       Added device bitmaps.
;       
;          Rev 1.7   19 Feb 1996 06:24:28   frido
;       Removed extraneous debugging code.
;       Added comments.
;       
;          Rev 1.6   17 Feb 1996 21:46:44   frido
;       Changed FIFO_CHECK into broken_FIFO.
;       
;          Rev 1.5   08 Feb 1996 00:03:54   frido
;       Added i386\ to include files.
;       
;          Rev 1.4   06 Feb 1996 16:13:16   frido
;       Added check for invalid rectangle during clippped opaquing.
;       
;          Rev 1.3   03 Feb 1996 12:17:28   frido
;       Added text clipping.
;       
;          Rev 1.2   25 Jan 1996 22:14:10   frido
;       Removed extraneous push/pop instructions.
;       
;          Rev 1.1   25 Jan 1996 12:42:38   frido
;       Added reinitialization of font cache after mode switch.
;       
;          Rev 1.0   24 Jan 1996 23:13:44   frido
;       Initial release.
;
;===============================================================================

.386
.MODEL FLAT, STDCALL

.NOLIST
INCLUDE i386\Macros.inc
INCLUDE i386\WinNT.inc
INCLUDE i386\Font.inc
INCLUDE Optimize.h
INCLUDE i386\Laguna.inc
INCLUDE Swat.h
COMMENT !		;automatic include file dependencies for BUILD.EXE
#include "i386\Macros.inc"
#include "i386\WinNT.inc"
#include "i386\Font.inc"
#include "Optimize.h"
#include "i386\Laguna.inc"
#include "SWAT.h"
!
.LIST

IF USE_ASM

.DATA

IF POINTER_SWITCH_ENABLED
EXTERN pointer_switch: DWORD 
ENDIF

IF LOG_QFREE
EXTERN QfreeData: DWORD 
ENDIF

 .CODE

;
; Function prototypes.
;
AddToFontCacheChain     PROTO           PROC,
                ppdev           :DWORD,
                pfo             :DWORD,
                pfc             :DWORD
AllocGlyph      PROTO           PROC,
                pfc             :DWORD,
                pgb             :DWORD,
                pgc             :DWORD
i386DrvTextOut  PROTO           PROC,
                pso             :DWORD,
                pstro           :DWORD,
                pfo             :DWORD,
                pco             :DWORD,
                prclExtra       :DWORD,
                prclOpaque      :DWORD,
                pboFore         :DWORD,
                pboOpaque       :DWORD,
                pptlBrush       :DWORD,
                mix             :DWORD
EngTextOut      PROTO           PROC,
                pso             :DWORD,
                pstro           :DWORD,
                pfo             :DWORD,
                pco             :DWORD,
                prclExtra       :DWORD,
                prclOpaque      :DWORD,
                pboFore         :DWORD,
                pboOpaque       :DWORD,
                pptlBrush       :DWORD,
                mix             :DWORD
DrvDestroyFont  PROTO           PROC,
                pfo             :DWORD
bCreateScreenFromDib PROTO      PROC,
                ppdev           :DWORD,
                pdsurf          :DWORD
StripePatBlt	PROTO		PROC,
		ppdev		:DWORD,
		x		:DWORD,
		y		:DWORD,
		nWidth		:DWORD,
		nHeight		:DWORD
ifdef WINNT_VER40
Sync_w_3d_proc  	PROTO		PROC,
		ppdev		:PTR PDEV
endif


;
; Stack frame for DrvTextOut.
;
espPTR          =       0
frmPTR          =       0
pso_            TEXTEQU <DWORD PTR [esp + 4 + espPTR]>
pstro_          TEXTEQU <DWORD PTR [esp + 8 + espPTR]>
pfo_            TEXTEQU <DWORD PTR [esp + 12 + espPTR]>
pco_            TEXTEQU <DWORD PTR [esp + 16 + espPTR]>
prclExtra_      TEXTEQU <DWORD PTR [esp + 20 + espPTR]>
prclOpaque_     TEXTEQU <DWORD PTR [esp + 24 + espPTR]>
pboFore_        TEXTEQU <DWORD PTR [esp + 28 + espPTR]>
pboOpaque_      TEXTEQU <DWORD PTR [esp + 32 + espPTR]>
pptlBrush_      TEXTEQU <DWORD PTR [esp + 36 + espPTR]>
mix_            TEXTEQU <DWORD PTR [esp + 40 + espPTR]>

OPTION  PROLOGUE:None
OPTION  EPILOGUE:None

DrvTextOut PROC PUBLIC,
        pso             :DWORD,
        pstro           :DWORD,
        pfo             :DWORD,
        pco             :DWORD,
        prclExtra       :DWORD,
        prclOpaque      :DWORD,
        pboFore         :DWORD,
        pboOpaque       :DWORD,
        pptlBrush       :DWORD,
        mix             :DWORD

IF NULL_TEXTOUT
	cmp	pointer_switch, 0		; Has the cursor been moved to (0,0)?
	je	NotNull			; No - continue on
	mov	eax, 1			; Make GDI think we succeeded
	ret	40			; Return and release stack frame
NotNull:
ENDIF

        push_   edi
        mov     edi, [pfo_]             ;EDI holds pointer to font
        ASSUME  edi:PTR FONTOBJ
        mov     ecx, [pso_]             ;ECX holds pointer to destination
        ASSUME  ecx:PTR SURFOBJ
        push_   esi
        push_   ebp
        push_   ebx
        save_   1                       ;save current stack state
        mov     edx, [pstro_]           ;EDX holds pointer to string
        ASSUME  edx:PTR STROBJ
        mov     ebx, [ecx].dhsurf       ;get the pointer to the device bitmap
        ASSUME  ebx:PTR DSURF
        mov     esi, [edi].pvConsumer   ;ESI holds pointer to font cache
        ASSUME  esi:PTR FONTCACHE
        cmp     [ecx].iType, STYPE_DEVBITMAP
                                        ;are we drawing in a device bitmap?
        mov     ebp, [ecx].dhpdev       ;EBP holds pointer to device
        ASSUME  ebp:PTR PDEV
        jne     @F                      ;no

ifdef WINNT_VER40
;SYNC_W_3D macro equivalent
    cmp [ebp].NumMCDContexts, 0 ; is MCD alive?
	jle	Sync_end    			; no
    push    ecx                 ; save
    push    edx                 ; save
    push    ebp                 ; input to Sync_w_3d_proc
    call Sync_w_3d_proc         
    pop     edx                 ; restore
    pop     ecx                 ; restore
Sync_end:
endif

        mov     ebx, [ebx].pso          ;get the handle to the DIB
        or      ebx, ebx                ;is the device bitmap a DIB?
        jz      @F                      ;no
        INVOKE  bCreateScreenFromDib,   ;copy the DIB to off-screen
                        ebp,
                        ebx
        or      eax, eax
        jz      Simulate                ;failure
@@:     cmp     [ebp].UseFontCache, 0   ;Is font caching enabled?
        je      FontNotCached           ;no, use C code.
        or      esi, esi                ;is font cache allocated?
        jz      NewFont                 ;no, new font
        cmp     esi, -1                 ;is font uncacheable?
        je      FontNotCached           ;yes
        cmp     [esi].ppdev, ebp        ;font cached in current device?
        mov     eax, [ebp].ulFontCount
        jne     FontNotCached           ;no
        cmp     [esi].ulFontCount, eax  ;device count still matches?
        jne     DestroyFont             ;no, recache font

;
; We have a font that is still cached.
;
FontCached:
        mov     ebx, [pco_]             ;EBX holds pointer to clip object
        ASSUME  ebx:PTR CLIPOBJ
        mov     eax, [pboFore_]         ;EAX has foreground brush
        ASSUME  eax:PTR BRUSHOBJ
        mov     edx, [pboOpaque_]       ;EDX has background brush
        ASSUME  edx:PTR BRUSHOBJ
        or      ebx, ebx                ;clip object present?
        jz      @F                      ;no
        cmp     [ebx].iDComplexity, DC_TRIVIAL
                                        ;trivial clipping?
        jne     CheckClipping           ;no, check for clipping
@@:     cmp     [ebp].iBytesPerPixel, 2
	mov	ebx, ebp		;store pointer to PDEV structure
        mov     ebp, [ebp].pLgREGS_real ;EBP holds pointer to Laguna registers
        ASSUME  ebp:NOTHING
        mov     eax, [eax].iSolidColor  ;get foreground color
        ASSUME  eax:NOTHING
        mov     edx, [edx].iSolidColor  ;get background color
        ASSUME  edx:NOTHING
        ja      @F                      ;no color translation needed
        je      Xlate16                 ;16-bpp
        mov     ah, al                  ;expand 8-bpp into 16-bit
        mov     dh, dl
Xlate16:
        mov     ecx, eax                ;expand 16-bpp into 32-bit
        shl     eax, 16
        mov     esi, edx
        shl     edx, 16
        or      eax, ecx
        or      edx, esi

@@:     ASSUME	ebx:PTR PDEV
	REQUIRE	4, ebx
	cmp	[ebx].shadowFGCOLOR, eax
	je	@F
	mov     [ebp + grOP_opFGCOLOR], eax
	mov	[ebx].shadowFGCOLOR, eax;store foreground color in Laguna
@@:	mov     eax, [pso_]             ;EAX holds pointer to destination
        ASSUME  eax:PTR SURFOBJ
	cmp	[ebx].shadowBGCOLOR, edx
	je	@F
        mov     [ebp + grOP_opBGCOLOR], edx
	mov	[ebx].shadowBGCOLOR, edx;store background color in Laguna
@@:	xor     edx, edx                ;zero x/y offset
        cmp     [eax].iType, STYPE_DEVBITMAP
        mov     eax, [eax].dhsurf       ;get pointer to device bitmap
        ASSUME  eax:PTR DSURF
        jne     @F                      ;target is not a device bitmap
        mov     edx, [eax].packedXY     ;get packed x/y offset of device bitmap
@@:     mov     eax, [prclOpaque_]      ;EAX holds opaquing rectangle
        ASSUME  eax:PTR RECTL
        mov     [mix_], edx             ;store x/y offset into mix variable
        test    eax, eax                ;opaquing rectangle present?
        jz      SkipOpaque              ;no
	ASSUME	ebx:PTR PDEV
        REQUIRE 7, ebx
	cmp	[ebx].shadowDRAWBLTDEF, SOLID_COLOR_FILL
	je	@F
        mov     DWORD PTR [ebp + grDRAWBLTDEF], SOLID_COLOR_FILL
	mov	[ebx].shadowDRAWBLTDEF, SOLID_COLOR_FILL
@@:					;use solid background fill
        mov     edi, [eax].left         ;get rectangle coordinates
        mov     ecx, [eax].top
        mov     edx, [eax].right
        mov     eax, [eax].bottom
        sub     edx, edi                ;convert to size
        sub     eax, ecx
IF SWAT6
	push_	ebx
	mov	ebx, [mix_]
	and	ebx, 0000FFFFh
	add	edi, ebx
	mov	ebx, [mix_]
	shr	ebx, 16
	add	ecx, ebx
	pop_	ebx
	INVOKE	StripePatBlt, ebx, edi, ecx, edx, eax
ELSE
        shl     ecx, 16                 ;pack x/y
        add     edi, [mix_]             ;add x/y offset to left
        shl     eax, 16
        add     ecx, edi
        or      eax, edx
        mov     [ebp + grOP0_opRDRAM], ecx
                                        ;draw rectangle
        mov     [ebp + grBLTEXT_EX], eax
ENDIF

SkipOpaque:
        mov     ax, [ebp + grCONTROL]
        mov     edi, [pfo_]             ;EDI holds pointer to font
        ASSUME  edi:PTR FONTOBJ
        or      eax, SWIZ_CNTL          ;enable bit mirroring
	cmp	[ebx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR
	je	@F
        mov     DWORD PTR [ebp + grDRAWBLTDEF], CACHE_EXPAND_XPAR
	mov	[ebx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR
@@:					;expand characters from cache
        mov     [ebp + grCONTROL], ax
	mov	edx, ebx		;store pointer to PDEV structure
        mov     ebx, [pstro_]           ;EBX holds pointer to string
        ASSUME  ebx:PTR STROBJ
        mov     edi, [edi].pvConsumer   ;EDI holds pointer to font cache
        ASSUME  edi:PTR FONTCACHE

;
; We are now ready to start the main font cache loop. We first determine if we
; need to enumerate the GLYPHPOS arrays or not. Then we start the main loop,
; which is a very short simple loop. For each glyph that falls in the caching
; range, we check if the glyph is cached. If so, we just copy the glyph from
; off-screen memory. If the glyph is not cached, we check if it is small enough
; to fit in a tile and if so, we cache it off-screen and than copy itto its
; destination. If the glyph is too large, we draw it directly on screen.
;
        enter_  16                      ;create stack frame
bMoreGlyphs_    TEXTEQU <DWORD PTR [esp + 0 + frmPTR]>
ulCharInc_      TEXTEQU <DWORD PTR [esp + 4 + frmPTR]>
dwControl_      TEXTEQU <DWORD PTR [esp + 8 + frmPTR]>
pdev_		TEXTEQU <DWORD PTR [esp + 12 + frmPTR]>
        save_   2                       ;store state of stack
	mov	[pdev_], edx

        mov     [dwControl_], eax
        mov     eax, [ebx].ulCharInc    ;copy ulCharInc from string object
        cmp     [ebx].pgp, 0
        mov     [ulCharInc_], eax
        je      Enumerate               ;there is more than one array
        mov     ecx, [ebx].cGlyphs      ;get number of glyphs to draw
        mov     ebx, [ebx].pgp          ;get pointer to glyph position array
        ASSUME  ebx:PTR GLYPHPOS
        mov     [bMoreGlyphs_], 0       ;no more glyphs to enumerate

MainLoop:
        or      ecx, ecx                ;any glyphs to draw?
        je      SkipLoop                ;no
        mov     eax, [ebx].ptl.x        ;get coordinates of first glyph
        mov     edx, [ebx].ptl.y
GlyphLoop:
        push_   ecx
        mov     ecx, [ebx].hg           ;get the glyph handle
        cmp     [ulCharInc_], 0         ;fixed font?
        jne     @F                      ;no
        mov     eax, [ebx].ptl.x        ;get coordinates for glyph
        mov     edx, [ebx].ptl.y
@@:     shl     ecx, 4                  ;build index into font cache array
        cmp     ecx, MAX_GLYPHS * 16    ;glyph out of range?
        jnl     DrawGlyph               ;yes, draw it directly
        save_   9
        mov     esi, [edi + ecx*1].aGlyphs.xyPos
                                        ;get off-screen location of glyph
        lea     ecx, [edi + ecx*1].aGlyphs
                                        ;load address of cache slot
        ASSUME  ecx:PTR GLYPHCACHE
        or      esi, esi                ;is the glyph already cached?
        jnz     @F                      ;yes
        mov     esi, [ebx].pgdf         ;cache the glyph
        ASSUME  esi:PTR GLYPHDEF
        push    eax
        push    edx
        push    ecx
        INVOKE  AllocGlyph,
                        edi,
                        [esi].pgb,
                        ecx
        pop     ecx
        pop     edx
        pop     eax
        mov     esi, [ecx].xyPos        ;get off-screen location of glyph
@@:     cmp     [ecx].cSize, 0          ;is this an empty glyph?
        jl      DrawGlyph               ;no, in fact it is non-cacheable
        jz      Increment               ;yes, skip it
        push_   edx
        push_   eax
        add     edx, [ecx].ptlOrigin.y  ;add origin of glyph to coordinates
        add     eax, [ecx].ptlOrigin.x
        shl     edx, 16                 ;pack coordinates
	or	edx, eax
	mov	eax, [pdev_]
	ASSUME	eax:PTR PDEV
        REQUIRE 7, eax
        mov     [ebp + grOP2_opMRDRAM], esi
                                        ;copy the glyph from off-screen memory
        mov     esi, [mix_]             ;get x/y offset
        mov     eax, [ecx].cSize
        add     edx, esi                ;add x/y offset
        mov     [ebp + grOP0_opRDRAM], edx
        mov     [ebp + grBLTEXT_EX], eax
        pop_    eax
        pop_    edx

Increment:
        add     eax, [ulCharInc_]       ;add the x-increment
        pop_    ecx
        add     ebx, SIZEOF GLYPHPOS    ;next glyph
        dec     ecx
        jnz     GlyphLoop
SkipLoop:
        cmp     [bMoreGlyphs_], 0       ;more arrays to draw?
        jne     Enumerate               ;yes
        mov     ecx, [dwControl_]
        leave_  16                      ;remove stack frame
        and     ecx, NOT SWIZ_CNTL      ;reset bit mirroring
        mov     eax, 1                  ;return TRUE
        mov     [ebp + grCONTROL], cx
        pop_    ebx
        pop_    ebp
        pop_    esi
        pop_    edi
        ret     40

;
; Draw the glyph directly to screen.
;
DrawGlyph:
        load_   9
        mov     esi, [ebx].pgdf         ;ESI holds pointer to GLYPHDEF
        ASSUME  esi:PTR GLYPHDEF
        push_   eax
        push_   edx
        mov     esi, [esi].pgb          ;ESI holds pointer to GLYPHBITS
        ASSUME  esi:PTR GLYPHBITS
        push_   edi
	push_	ebx
	mov	ebx, [pdev_]
	ASSUME	ebx:PTR PDEV

        mov     ecx, [esi].sizlBitmap._cy
                                        ;get height of glyph
        add     edx, [esi].ptlOrigin.y  ;add y-origin to coordinate
        shl     ecx, 16 
        jz      SkipDraw                ;if zero, skip
        shl     edx, 16
        add     eax, [esi].ptlOrigin.x  ;add x-origin to coordinate
        mov     edi, [esi].sizlBitmap._cx
                                        ;get width of glyph
        or      edx, eax
        or      ecx, edi
        add     edx, [mix_]             ;add x/y offset
        lea     esi, [esi].aj           ;ESI points to bits
        ASSUME  esi:NOTHING

IF SWAT7
	add	edi, 7			;convert width into byte delta
	REQUIRE 9, ebx
	cmp	[ebx].shadowDRAWBLTDEF, TEXT_EXPAND_XPAR
	je	@F
        mov     DWORD PTR [ebp + grDRAWBLTDEF], TEXT_EXPAND_XPAR
	mov	[ebx].shadowDRAWBLTDEF, TEXT_EXPAND_XPAR
@@:	shr	edi, 3
        mov     DWORD PTR [ebp + grOP2_opMRDRAM], 0
	cmp	cx, 64			;bug when doing 64 < width < 128
	jbe	SkipBug
	cmp	cx, 128
	jae	SkipBug
	push	ecx			;save registers
	push	edx
	push	esi
	mov	cx, 64			;1st passs, 64 pixels
	mov	[ebp + grOP0_opRDRAM], edx
	mov	[ebp + grBLTEXT_EX], ecx
	shr	ecx, 16			;get height into ECX
@@:	REQUIRE	2, ebx
	mov	eax, [esi][0]		;transfer 64 pixels
	mov	edx, [esi][4]
	mov	[ebp + grHOSTDATA][0], eax
	mov	[ebp + grHOSTDATA][4], edx
	add	esi, edi		;next glyph line
	dec	ecx
	jnz	@B
	pop	esi
	pop	edx
	add	esi, 64 / 8		;8 bytes already done
	pop	ecx
	add	edx, 64			;offset to next 64 pixels
	sub	ecx, 64
SkipBug:
	REQUIRE	5, ebx
        mov     [ebp + grOP0_opRDRAM], edx
	mov	edx, ecx		;get number of pixels into EDX
        mov     [ebp + grBLTEXT_EX], ecx
	and	edx, 0000FFFFh
        shr     ecx, 16                 ;get height back
	mov	ebx, [pdev_]
	ASSUME	ebx:PTR PDEV
        cmp     edx, 8                  ;test width
        jbe	Draw1Byte               ;glyph located in 1 byte
        cmp     edx, 16
        jbe	Draw2Bytes              ;glyph located in 2 bytes
        cmp     edx, 24
        jbe	Draw3Bytes              ;glyph located in 3 bytes
        cmp     edx, 32
        jbe	Draw4Bytes              ;glyph located in 4 bytes

DrawLoop:
	push	edx			;store pixel count
        push	esi			;store current byte offset
@@:     mov     eax, [esi]              ;get 4 bytes
        add     esi, 4
        REQUIRE	1, ebx
	mov     [ebp + grHOSTDATA], eax ;draw them
        sub     edx, 32			;32 pixels done
        jg      @B                      ;still more bytes to copy
	pop	esi			;restore byte offset
	pop	edx			;restore pixel count
	add	esi, edi		;next glyph row
        dec     ecx
        jnz     DrawLoop
        jmp     SkipDraw

Draw1Byte:
	mov     al, [esi]               ;get byte from glyph
        add	esi, edi
        REQUIRE	1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw it
        dec     ecx                     ;next glyph row
        jnz     Draw1Byte
        jmp     SkipDraw

Draw2Bytes:
	mov     ax, [esi]               ;get 2 bytes from glyph
        add	esi, edi
	REQUIRE	1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw them
        dec     ecx                     ;next glyph row
        jnz     Draw2Bytes
        jmp     SkipDraw

Draw4Bytes:
	mov     eax, [esi]              ;get 4 bytes from glyph
        add     esi, edi
	REQUIRE	1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw them
        dec     ecx                     ;next glyph row
        jnz     Draw4Bytes
        jmp     SkipDraw

Draw3Bytes:
	mov	al, [esi + 2]		;get 3 bytes from glyph
	shl	eax, 16
	mov	ax, [esi + 0]
        add     esi, edi
	REQUIRE	1, ebx
        mov     [ebp + grHOSTDATA], eax	;draw them
	dec	ecx			;next glyph row
        jnz     Draw3Bytes
ELSE
	REQUIRE	7, ebx
	cmp	[ebx].shadowDRAWBLTDEF, TEXT_EXPAND_XPAR
	je	@F
        mov     DWORD PTR [ebp + grDRAWBLTDEF], TEXT_EXPAND_XPAR
	mov	[ebx].shadowDRAWBLTDEF, TEXT_EXPAND_XPAR
@@:					;expand glyph on-screen
        mov     [ebp + grOP0_opRDRAM], edx
        mov     DWORD PTR [ebp + grOP2_opMRDRAM], 0
        mov     [ebp + grBLTEXT_EX], ecx
        shr     ecx, 16                 ;get height back
        cmp     edi, 8                  ;test width
        jbe     Draw1Byte               ;glyph located in 1 byte
        cmp     edi, 16
        jbe     Draw2Bytes              ;glyph located in 2 bytes
        cmp     edi, 24
        jbe     Draw3Bytes              ;glyph located in 3 bytes
        cmp     edi, 32
        jbe     Draw4Bytes              ;glyph located in 4 bytes

        add     edi, 7                  ;byte adjust glyph width
        shr     edi, 3
DrawLoop:
        mov     edx, edi                ;get width
@@:     mov     eax, [esi]              ;get 4 bytes
        add     esi, 4
	REQUIRE	1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw them
        sub     edx, 4                  ;4 bytes done
        jg      @B                      ;still more bytes to copy
        add     esi, edx                ;next glyph row
        dec     ecx
        jnz     DrawLoop
        jmp     SkipDraw

Draw1Byte:
@@:	mov     al, [esi]               ;get byte from glyph
        inc     esi
	REQUIRE 1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw it
        dec     ecx                     ;next glyph row
        jnz     @B
        jmp     SkipDraw

Draw2Bytes:
@@:	mov     ax, [esi]               ;get 2 bytes from glyph
        add     esi, 2
	REQUIRE 1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw them
        dec     ecx                     ;next glyph row
        jnz     @B
        jmp     SkipDraw

Draw4Bytes:
@@:	mov     eax, [esi]              ;get 4 bytes from glyph
        add     esi, 4
	REQUIRE	1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw them
        dec     ecx                     ;next glyph row
        jnz     @B
        jmp     SkipDraw

Draw3Bytes:
@@:	mov     eax, [esi]              ;eax = 3210
        add     esi, 4
	REQUIRE 4, ebx
        mov     [ebp + grHOSTDATA], eax ;store 210
        dec     ecx
        jz      SkipDraw
        mov     edx, [esi]              ;edx = 7654
        add     esi, 4
        shrd    eax, edx, 24            ;eax = 6543
        dec     ecx
        mov     [ebp + grHOSTDATA], eax ;store 543
        jz      SkipDraw
        mov     eax, [esi]              ;eax = ba98
        add     esi, 4
        shrd    edx, eax, 16            ;edx = 9876
        dec     ecx
        mov     [ebp + grHOSTDATA], edx ;store 876
        jz      SkipDraw
        shr     eax, 8                  ;eax = xba9
        dec     ecx
        mov     [ebp + grHOSTDATA], eax ;store ba9
        jnz     @B
ENDIF
SkipDraw:
	REQUIRE	2, ebx
	cmp	[ebx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR
	je	@F
        mov     DWORD PTR [ebp + grDRAWBLTDEF], CACHE_EXPAND_XPAR
	mov	[ebx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR
@@:					;enable off-screen expansion
        pop_    ebx
        pop_    edi
        pop_    edx
        pop_    eax
        jmp     Increment

;
; Enumerate an array of glyphs.
;
Enumerate:
        load_   2
        push_   eax                     ;create room on stack for return
        push_   eax                     ;  parameters
        mov     eax, [pstro_]           ;get pointer to STROBJ
        mov     ebx, esp                ;ebx points to pgp parameter
        lea     ecx, [esp + 4]          ;ecx points to c parameter
        INVOKE  STROBJ_bEnum,
                        eax,
                        ecx,
                        ebx
        pop_    ebx                     ;load pgp from stack
        pop_    ecx                     ;load c from stack
        mov     [bMoreGlyphs_], eax
        jmp     MainLoop

;
; Remove the current font from the cache. EDI holds the pointer to the font
; object.
;
DestroyFont:
        load_   1                       ;retrieve stack state on entry
        INVOKE  DrvDestroyFont,         ;destroy font
                        edi
        jmp     @F
;
; We have a new font. See if the font fits into an off-screen tile by comparing
; the bounding box to 150% of the tile size. We use 150% since we might still
; be able to cache the lowercase glyphs of larger fonts.
;
NewFont:
        ASSUME  edx:PTR STROBJ
        mov     ebx, [edx].rclBkGround.bottom
                                        ;get height of font
        sub     ebx, [edx].rclBkGround.top
        cmp     ebx, LINES_PER_TILE * 3 / 2
                                        ;test if small enough to fit in tile
        jg      AbortFont               ;too big

ifdef WINNT_VER40
@@:     INVOKE  EngAllocMem,            ;allocate memory for font cache
                        FL_ZERO_MEMORY,
                        SIZEOF FONTCACHE,
                        'XGLC'
else
@@:     INVOKE  LocalAlloc,             ;allocate memory for font cache
                        LMEM_FIXED OR LMEM_ZEROINIT,
                        SIZEOF FONTCACHE
endif

        ASSUME  eax:PTR FONTCACHE
        or      eax, eax
        jz      AbortFont               ;error, not enough memory
        ASSUME  edi:PTR FONTOBJ
        mov     [edi].pvConsumer, eax   ;store pointer to font cache in font
        ASSUME  ebp:PTR PDEV
        mov     ebx, [ebp].ulFontCount
        mov     [eax].ppdev, ebp        ;store pointer to device
        mov     [eax].ulFontCount, ebx  ;store current device count
        INVOKE  AddToFontCacheChain,
                        ebp,
                        edi,
                        eax
        jmp     FontCached

AbortFont:
        ASSUME  edi:PTR FONTOBJ
        mov     [edi].pvConsumer, -1    ;mark the font as uncacheable
FontNotCached:
        pop_    ebx                     ;pass through non-cache font handler
        pop_    ebp
        pop_    esi
        pop_    edi
        jmp     i386DrvTextOut

Simulate:
        load_   1
        mov     [pso_], ebx             ;save new surface object
        pop     ebx                     ;pass through engine
        pop     ebp
        pop     esi
        pop     edi
        jmp     EngTextOut
;
; We only support simple rectangle clipping in assembly.
;
CheckClipping:
        ASSUME  ebx:PTR CLIPOBJ
        cmp     [ebx].iDComplexity, DC_RECT
        jne     FontNotCached
DrvTextOut ENDP

;
; Right now, EAX holds the foreground brush, EBX points to the clipping object,
; EDX holds the background brush, and EBP points to the device.
;
ClipTextOut PROC
        ASSUME  eax:PTR BRUSHOBJ
	ASSUME	ebx:PTR CLIPOBJ
        ASSUME  edx:PTR BRUSHOBJ
        ASSUME  ebp:PTR PDEV

        load_   1
        cmp     [ebp].iBytesPerPixel, 2
	push_	ebp
        mov     ebp, [ebp].pLgREGS_real ;EBP points to Laguna registers
        ASSUME  ebp:NOTHING
        mov     eax, [eax].iSolidColor  ;get foreground color
        ASSUME  eax:NOTHING
        mov     edx, [edx].iSolidColor  ;get background color
        ASSUME  edx:NOTHING
        ja      @F
        je      Xlate16
        mov     ah, al                  ;expand 8-bpp into 16-bit
        mov     dh, dl
Xlate16:
        mov     ecx, eax                ;expand 16-bpp into 32-bit
        shl     eax, 16
        mov     esi, edx
        shl     edx, 16
        or      eax, ecx
        or      edx, esi
@@:     pop_	ecx
	ASSUME	ecx:PTR PDEV
	REQUIRE	4, ecx
	cmp	[ecx].shadowFGCOLOR, eax
	je	@F
        mov     [ebp + grOP_opFGCOLOR], eax
	mov	[ecx].shadowFGCOLOR, eax;store foreground color
@@:	mov     eax, [pso_]             ;get pointer to destination
        ASSUME  eax:PTR SURFOBJ
	cmp	[ecx].shadowBGCOLOR, edx
	je	@F
        mov     [ebp + grOP_opBGCOLOR], edx
	mov	[ecx].shadowBGCOLOR, edx
@@:					;store background color
        xor     edx, edx                ;zero x/y offset
        cmp     [eax].iType, STYPE_DEVBITMAP
        mov     eax, [eax].dhsurf       ;get pointer to device bitmap
        ASSUME  eax:PTR DSURF
        jne     @F                      ;destination is not a device bitmap
        mov     edx, [eax].packedXY     ;get x/y offset of device bitmap
@@:     mov     eax, [prclOpaque_]      ;get pointer to opaquing rectangle
        ASSUME  eax:PTR RECTL
        mov     [mix_], edx             ;store x/y offset into mix variable
	push_	ecx
        test    eax, eax                ;do we have an opaquing rectangle?
        jz      SkipOpaque              ;no
	cmp	[ecx].shadowDRAWBLTDEF, SOLID_COLOR_FILL
	je	@F
	REQUIRE	2, ecx
        mov     DWORD PTR [ebp + grDRAWBLTDEF], SOLID_COLOR_FILL
	mov	[ecx].shadowDRAWBLTDEF, SOLID_COLOR_FILL
@@:					;use a solid fill
        mov     esi, [mix_]             ;get x/y offset
        mov     edi, [eax].left         ;get the rectangle coordinates
        mov     ecx, [eax].top
        mov     edx, [eax].right
        mov     eax, [eax].bottom
        cmp     edi, [ebx].rclBounds.left
                                        ;clip with clipping rectangle
        jg      @F
        mov     edi, [ebx].rclBounds.left
@@:     cmp     ecx, [ebx].rclBounds.top
        jg      @F
        mov     ecx, [ebx].rclBounds.top
@@:     cmp     edx, [ebx].rclBounds.right
        jl      @F
        mov     edx, [ebx].rclBounds.right
@@:     cmp     eax, [ebx].rclBounds.bottom
        jl      @F
        mov     eax, [ebx].rclBounds.bottom
@@:     sub     edx, edi
        jle     SkipOpaque              ;invalid width
        sub     eax, ecx
        jle     SkipOpaque              ;invalid height
IF SWAT6
	push	esi
	and	esi, 0000FFFFh
	add	edi, esi
	pop	esi
	shr	esi, 16
	add	ecx, esi
	mov	esi, [esp]
	INVOKE	StripePatBlt, esi, edi, ecx, edx, eax
ELSE
        shl     ecx, 16                 ;pack x/y
        add     edi, esi                ;add x/y offset
        shl     eax, 16
        add     ecx, edi
        or      eax, edx
	mov	edx, [esp]
	ASSUME	edx:PTR PDEV
	REQUIRE	5, edx
        mov     [ebp + grOP0_opRDRAM], ecx
                                        ;draw rectangle
        mov     [ebp + grBLTEXT_EX], eax
ENDIF
SkipOpaque:
	pop_	ecx
	ASSUME	ecx:PTR PDEV

        enter_  40                      ;create stack frame
bMoreGlyphs_    TEXTEQU <DWORD PTR [esp + 0 + frmPTR]>
ulCharInc_      TEXTEQU <DWORD PTR [esp + 4 + frmPTR]>
xBit_           TEXTEQU <DWORD PTR [esp + 8 + frmPTR]>
lDelta_         TEXTEQU <DWORD PTR [esp + 12 + frmPTR]>
dwControl_      TEXTEQU <DWORD PTR [esp + 16 + frmPTR]>
pdev_		TEXTEQU <DWORD PTR [esp + 20 + frmPTR]>
rclBounds_      TEXTEQU <RECTL PTR [esp + 24 + frmPTR]>
        save_   2
	mov	[pdev_], ecx

        mov     ax, [ebp + grCONTROL]
if DRIVER_5465 AND HW_CLIPPING
	cmp	[ecx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR + CLIPEN
	je	@F
	REQUIRE	2, ecx
        mov     DWORD PTR [ebp + grDRAWBLTDEF], CACHE_EXPAND_XPAR + CLIPEN
	mov	[ecx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR + CLIPEN
else
	cmp	[ecx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR
	je	@F
	REQUIRE	2, ecx
        mov     DWORD PTR [ebp + grDRAWBLTDEF], CACHE_EXPAND_XPAR
	mov	[ecx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR
endif
@@:					;enable off-screen expansion
        mov     [dwControl_], eax
        or      eax, SWIZ_CNTL          ;enable bit mirroring
        mov     edi, [pfo_]             ;EDI points to font object
        ASSUME  edi:PTR FONTOBJ
        mov     [ebp + grCONTROL], ax

        mov     eax, [ebx].rclBounds.left
                                        ;get clipping coordinates
        mov     ecx, [ebx].rclBounds.top
        mov     edx, [ebx].rclBounds.right
        mov     esi, [ebx].rclBounds.bottom

        mov     ebx, [pstro_]           ;EBX points to string
        ASSUME  ebx:PTR STROBJ
        mov     edi, [edi].pvConsumer   ;EDI points to font cache
        ASSUME  edi:PTR FONTCACHE
        mov     [rclBounds_].left, eax  ;store clipping coordinates
        mov     [rclBounds_].top, ecx
        mov     [rclBounds_].right, edx
        mov     [rclBounds_].bottom, esi

if DRIVER_5465 AND HW_CLIPPING
        ;; Set up hardware clipping
        shl     ecx, 16                 ; Top of clipping rect. in high word
        add     eax, ecx                ; Packed upper left coordinate
        add     eax, [mix_]
	mov	ecx, [pdev_]
	ASSUME	ecx:PTR PDEV
	REQUIRE	4, ecx
        mov     [ebp + grCLIPULE], eax  ; Set upper left clipping coordinate
        shl     esi, 16                 ; Bottom of clipping rect. in high word
        add     edx, esi                ; Packed lower right coordinate
        add     edx, [mix_]
        mov     [ebp + grCLIPLOR], edx  ; Set lower right clipping coordinate
endif

        mov     eax, [ebx].ulCharInc    ;copy ulCharInc
        cmp     [ebx].pgp, 0
        mov     [ulCharInc_], eax
        je      Enumerate               ;there is more than one array
        mov     ecx, [ebx].cGlyphs      ;get the number of glyphs
        mov     ebx, [ebx].pgp          ;EBX points to GLYPHPOS
        ASSUME  ebx:PTR GLYPHPOS
        mov     [bMoreGlyphs_], 0       ;no more glyph arrays

MainLoop:
        or      ecx, ecx                ;any glyphs to draw?
        je      SkipLoop                ;no
        mov     eax, [ebx].ptl.x        ;get coordinates of first glyph
        mov     edx, [ebx].ptl.y
GlyphLoop:
        push_   ecx
        mov     ecx, [ebx].hg           ;get the glyph handle
        cmp     [ulCharInc_], 0         ;fixed font?
        jne     @F                      ;no
        mov     eax, [ebx].ptl.x        ;get coordinates for glyph
        mov     edx, [ebx].ptl.y
@@:     shl     ecx, 4                  ;build index into font cache array
        cmp     ecx, MAX_GLYPHS * 16    ;glyph out of range?
        jnl     DrawGlyph               ;yes, draw it directly
        save_   3
        mov     esi, [edi + ecx*1].aGlyphs.xyPos
                                        ;get off-screen location of glyph
        lea     ecx, [edi + ecx*1].aGlyphs
                                        ;load address of cache slot
        ASSUME  ecx:PTR GLYPHCACHE
        or      esi, esi                ;is the glyph already cached?
        jnz     @F                      ;yes
        mov     esi, [ebx].pgdf         ;cache the glyph
        ASSUME  esi:PTR GLYPHDEF
        push    eax
        push    edx
        push    ecx
        INVOKE  AllocGlyph,
                        edi,
                        [esi].pgb,
                        ecx
        pop     ecx
        pop     edx
        pop     eax
        mov     esi, [ecx].xyPos        ;get off-screen location of glyph
@@:     cmp     [ecx].cSize, 0          ;is this an empty glyph?
        jl      DrawGlyph               ;no, in fact it is non-cacheable
        jz      Increment               ;yes, skip it
        push_   edx
        push_   eax
        push_   edi
        push_   ebx
        add     edx, [ecx].ptlOrigin.y  ;EDX = top
        mov     edi, [ecx].cSize        ;get packed width/height
        add     eax, [ecx].ptlOrigin.x  ;EAX = left
        mov     ecx, edi
        ASSUME  ecx:NOTHING
        shr     edi, 16                 ;EDI holds height
        and     ecx, 0000FFFFh          ;ECX holds width
        add     edi, edx                ;EDI = bottom
        add     ecx, eax                ;ECX = right

        mov     ebx, [rclBounds_].left  ;clip coordinates

ife (DRIVER_5465 AND HW_CLIPPING)
        cmp     ecx, [rclBounds_].right ; is the right edge clipped?
        jng     @F                      ; 
        mov     ecx, [rclBounds_].right ; yes - set new right 
endif
@@:     sub     ebx, eax                ; is the left edge clipped?
        jg      SpecialDraw             ; yes

        sub     ecx, eax                ; get delta x
        jng     SkipGlyph               ; right > left? - don't draw it
        mov     ebx, [rclBounds_].top

ife (DRIVER_5465 AND HW_CLIPPING)
        cmp     edi, [rclBounds_].bottom; is the bottom clipped?
        jng     @F
        mov     edi, [rclBounds_].bottom; yes - set new bottom
endif

@@:     sub     ebx, edx                ; is the top clipped?
        jng     @F
        shl     ebx, 16                 ; top is clipped
        mov     edx, [rclBounds_].top   ; adjust top
        add     esi, ebx                ; adjust off-screen top
@@:     sub     edi, edx                ; bottom > top?
        jng     SkipGlyph               ; no - skip it
        shl     edi, 16                 ; pack x/y
        add     eax, [mix_]             ; add x/y offset
        shl     edx, 16                 ; top << 16
        or      edi, ecx
        add     edx, eax                ; packed top left corner
	mov	ecx, [pdev_]
	ASSUME	ecx:PTR PDEV
        REQUIRE 7, ecx
        mov     [ebp + grOP0_opRDRAM], edx
                                        ;expand glyph from off-screen
        mov     [ebp + grOP2_opMRDRAM], esi
        mov     [ebp + grBLTEXT_EX], edi
SkipGlyph:
        pop_    ebx
        pop_    edi
        pop_    eax
        pop_    edx

Increment:
        add     eax, [ulCharInc_]       ;add x-increment
        pop_    ecx
        add     ebx, SIZEOF GLYPHPOS    ;next glyph
        dec     ecx
        jnz     GlyphLoop
SkipLoop:
        cmp     [bMoreGlyphs_], 0       ;more arrays of glypos?
        jne     Enumerate               ;yes
        mov     ecx, [dwControl_]
        leave_  40			;kill stack frame
        and     ecx, NOT SWIZ_CNTL      ;disable bit mirroring
        mov     eax, 1                  ;return TRUE
        mov     [ebp + grCONTROL], cx
        pop_    ebx
        pop_    ebp
        pop_    esi
        pop_    edi
        ret     40

Enumerate:
        load_   2
        push_   eax                     ;create room on stack for return
        push_   eax                     ;  parameters
        mov     eax, [pstro_]           ;get pointer to STROBJ
        mov     ebx, esp                ;ebx points to pgp parameter
        lea     ecx, [esp + 4]          ;ecx points to c parameter
        INVOKE  STROBJ_bEnum,
                        eax,
                        ecx,
                        ebx
        pop_    ebx                     ;load pgp from stack
        pop_    ecx                     ;load c from stack
        mov     [bMoreGlyphs_], eax
        jmp     MainLoop

;//frido BEGIN 28-Mar-96
SpecialDraw:
        pop_    ebx
        pop_    edi
        pop_    eax
        pop_    edx
;//frido END 28-Mar-96

;
; Draw a clipped glyph directly to screen.
;
DrawGlyph:
        load_   3
        mov     esi, [ebx].pgdf         ;ESI holds pointer to GLYPHDEF
        ASSUME  esi:PTR GLYPHDEF
        push_   eax
        push_   edx
        mov     esi, [esi].pgb          ;ESI holds pointer to GLYPHBITS
        ASSUME  esi:PTR GLYPHBITS
        push_   edi
        push_   ebx

        mov     edi, [esi].sizlBitmap._cx
                                        ;EDI = right
        mov     ecx, [esi].sizlBitmap._cy
                                        ;ECX = bottom
        add     eax, [esi].ptlOrigin.x  ;EAX = left
        add     edx, [esi].ptlOrigin.y  ;EDX = top
        lea     ebx, [edi + 7]          ;EBX = byte increment to next line
        add     edi, eax
        shr     ebx, 3
        add     ecx, edx
        lea     esi, [esi].aj           ;ESI holds pointer to bits
        ASSUME  esi:NOTHING
        mov     [xBit_], 0              ;zero bit offset
        mov     [lDelta_], ebx

        mov     ebx, [rclBounds_].left
        cmp     edi, [rclBounds_].right ;clip right
        jl      @F
        mov     edi, [rclBounds_].right
@@:     sub     ebx, eax                ;clip left
        jng     @F
        mov     eax, ebx                ;store bit offset
        shr     ebx, 3
        and     eax, 7
        add     esi, ebx
        mov     [xBit_], eax
        mov     eax, [rclBounds_].left
@@:     sub     edi, eax                ;EDI = width
        jng     GoIncrement

        mov     ebx, [rclBounds_].top
        cmp     ecx, [rclBounds_].bottom;clip bottom
        jl      @F
        mov     ecx, [rclBounds_].bottom
@@:     sub     ebx, edx                ;clip top
        jng     @F
        add     edx, ebx                ;store line offset
        imul    ebx, [lDelta_]
        add     esi, ebx
@@:     sub     ecx, edx                ;ECX = height
        jng     GoIncrement

        shl     edx, 16                 ;pack x,y
        mov     ebx, [xBit_]
        shl     ecx, 16
        or      edx, eax
        or      ecx, edi
        add     edx, [mix_]             ;add x/y offset
        lea     edi, [edi + ebx + 7]    ;EDI = adjusted width
IF broken_FIFO
        IDLE
ENDIF
	mov	eax, [pdev_]
	ASSUME	eax:PTR PDEV
	REQUIRE	4, eax
if DRIVER_5465 AND HW_CLIPPING
	cmp	[eax].shadowDRAWBLTDEF, TEXT_EXPAND_XPAR + CLIPEN
	je	@F
        mov     DWORD PTR [ebp + grDRAWBLTDEF], TEXT_EXPAND_XPAR + CLIPEN
	mov	[eax].shadowDRAWBLTDEF, TEXT_EXPAND_XPAR + CLIPEN
@@:					;enable on-screen expansion & clipping
else
	cmp	[eax].shadowDRAWBLTDEF, TEXT_EXPAND_XPAR
	je	@F
        mov     DWORD PTR [ebp + grDRAWBLTDEF], TEXT_EXPAND_XPAR
	mov	[eax].shadowDRAWBLTDEF, TEXT_EXPAND_XPAR
@@:					;enable on-screen expansion
endif
IF SWAT7
        mov     [ebp + grOP2_opMRDRAM], ebx
	cmp	cx, 64			;bug when doing 64 < width < 128
	jbe	SkipBug
	cmp	cx, 128
	jae	SkipBug
	push_	ecx			;save registers
	push_	edx
	push_	esi
	push_	edi
	mov	cx, 64			;1st passs, 64 pixels
	REQUIRE	5, eax
	mov	[ebp + grOP0_opRDRAM], edx
	mov	[ebp + grBLTEXT_EX], ecx
	shr	ecx, 16			;get height into ECX
	mov	edi, [lDelta_]		;get delta
BugLoop:
	mov	eax, [pdev_]
	REQUIRE	2, eax
	mov	eax, [esi][0]		;transfer 64 pixels
	mov	edx, [esi][4]
	mov	[ebp + grHOSTDATA][0], eax
	mov	[ebp + grHOSTDATA][4], edx
	or	ebx, ebx
	jz	@F
	mov	edx, [pdev_]
	ASSUME	edx:PTR PDEV
	mov	eax, [esi][8]
	REQUIRE	1, edx
	mov	[ebp + grHOSTDATA][8], eax
@@:	add	esi, [lDelta_]		;next glyph line
	dec	ecx
	jnz	BugLoop
	pop_	edi			;restore registers
	pop_	esi
	sub	edi, 64			;64 pixels less to do
	pop_	edx
	add	esi, 64 / 8		;8 bytes already done
	pop_	ecx
	add	edx, 64			;offset to next 64 pixels
	sub	ecx, 64
SkipBug:
	mov	eax, [pdev_]
	ASSUME	eax:PTR PDEV
	shr	edi, 3
	REQUIRE	5, eax
        mov     [ebp + grOP0_opRDRAM], edx
ELSE
	mov	eax, [pdev_]
	ASSUME	eax:PTR PDEV
        mov     [ebp + grOP0_opRDRAM], edx
	REQUIRE	5, eax
        mov     [ebp + grOP2_opMRDRAM], ebx
        shr     edi, 3
ENDIF
        mov     [ebp + grBLTEXT_EX], ecx
        shr     ecx, 16
        mov     edx, [lDelta_]
        mov	ebx, [pdev_]
	ASSUME	ebx:PTR PDEV
        cmp     edi, 2
        jb      Draw1Byte
        je      Draw2Bytes
        cmp     edi, 4
        jbe     Draw4Bytes

DrawLoop:
	push_	edi
	push_	esi
@@:     mov     eax, [esi]              ;get 4 bytes from glyph
        add     esi, 4
	REQUIRE	1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw them
        sub     edi, 4                  ;4 bytes done
        jg      @B                      ;still more bytes to draw
	pop_	esi
	pop_	edi
        add	esi, edx
        dec     ecx                     ;next glyph row
        jnz     DrawLoop
        jmp     SkipDraw

Draw1Byte:
	mov     al, [esi]               ;get byte from glyph
        add     esi, edx
	REQUIRE	1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw it
        dec     ecx                     ;next glyph line
        jnz     Draw1Byte
        jmp     SkipDraw

Draw2Bytes:
	mov     ax, [esi]               ;get two bytes from glyph
        add     esi, edx
	REQUIRE	1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw them
        dec     ecx                     ;next glyph line
        jnz     Draw2Bytes
        jmp     SkipDraw

Draw4Bytes:
	mov     eax, [esi]              ;get four bytes from glyph
        add     esi, edx
	REQUIRE	1, ebx
        mov     [ebp + grHOSTDATA], eax ;draw them
        dec     ecx                     ;next glyph line
        jnz     Draw4Bytes

SkipDraw:
if DRIVER_5465 AND HW_CLIPPING
	cmp	[ebx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR + CLIPEN
	je	@F
	REQUIRE	2, ebx
        mov     DWORD PTR [ebp + grDRAWBLTDEF], CACHE_EXPAND_XPAR + CLIPEN
	mov	[ebx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR + CLIPEN
@@:                                     ;enable off-screen expansion & clipping
else
	cmp	[ebx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR
	je	@F
	REQUIRE	2, ebx
        mov     DWORD PTR [ebp + grDRAWBLTDEF], CACHE_EXPAND_XPAR
	mov	[ebx].shadowDRAWBLTDEF, CACHE_EXPAND_XPAR
@@:					;enable off-screen expansion
endif
GoIncrement:
        pop_    ebx
        pop_    edi
        pop_    edx
        pop_    eax
        jmp     Increment

ClipTextOut ENDP

ENDIF ; USE_ASM

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\5465bw.c ===
/**********************************************************
* Copyright Cirrus Logic, 1997. All rights reserved.
***********************************************************
*
*  5465BW.C - Bandwidth functions for CL-GD5465
*
***********************************************************
*
*  Author: Rick Tillery
*  Date:   03/20/97
*
*  Revision History:
*  -----------------
*  WHO             WHEN            WHAT/WHY/HOW
*  ---             ----            ------------
*
***********************************************************/

#include "precomp.h"

#if defined WINNT_VER35      // WINNT_VER35
// If WinNT 3.5 skip all the source code
#elif defined (NTDRIVER_546x)
// If WinNT 4.0 and 5462/64 build skip all the source code
#else

#ifndef WINNT_VER40
#include "5465BW.h"
#endif

/**********************************************************
*
* ScaleMultiply()
*
* Calculates product of two DWORD factors supplied.  If the
*  result would overflow a DWORD, the larger of the two factors
*  is divided by 2 (shifted right) until the overflow will
*  not occur.
*
* Returns: Number of right shifts applied to the product.
*          Product of the factors shifted by the value above.
*
***********************************************************
* Author: Rick Tillery
* Date:   11/18/95
*
* Revision History:
* -----------------
* WHO WHEN     WHAT/WHY/HOW
* --- ----     ------------
*********************************************************/
static int ScaleMultiply(DWORD   dw1,
                         DWORD   dw2,
                         LPDWORD pdwResult)
{
  int   iShift = 0;   // Start with no shifts
  DWORD dwLimit;

//  ODS("ScaleMultiply() called.\n");

  // Either factor 0 will be a zero result and also cause a problem
  //  in our divide below.
  if((0 == dw1) || (0 == dw2))
  {
    *pdwResult = 0;
  }
  else
  {
    // Determine which factor is larger
    if(dw1 > dw2)
    {
      // Determine largest number by with dw2 can be multiplied without
      //  overflowing a DWORD.
      dwLimit = 0xFFFFFFFFul / dw2;
      // Shift dw1, keeping track of how many times, until it won't
      //  overflow when multiplied by dw2.
      while(dw1 > dwLimit)
      {
        dw1 >>= 1;
        iShift++;
      }
    }
    else
    {
      // Determine largest number by with dw1 can be multiplied without
      //  overflowing a DWORD.
      dwLimit = 0xFFFFFFFFul / dw1;
      // Shift dw2, keeping track of how many times, until it won't
      //  overflow when multiplied by dw1.
      while(dw2 > dwLimit)
      {
        dw2 >>= 1;
        iShift++;
      }
    }
    // Calculate (scaled) product
    *pdwResult = dw1 * dw2;
  }
  // Return the number of shifts we had to use
  return(iShift);
}

/**********************************************************
*
* ChipCalcMCLK()
*
* Determines currently set memory clock (MCLK) based on
*  register values provided.
*
* Returns: Success and current MCLK in Hz.
*
***********************************************************
* Author: Rick Tillery
* Date:   03/21/97
*
* Revision History:
* -----------------
* WHO WHEN     WHAT/WHY/HOW
* --- ----     ------------
*********************************************************/
BOOL ChipCalcMCLK(LPBWREGS pBWRegs,
                  LPDWORD  pdwMCLK)
{
  BOOL  fSuccess = FALSE;
  // We make the assumption that if the BCLK_Denom /4 is set, the reference
  //  xtal is 27MHz.  If it is not set, we assume the ref xtal is 14.31818MHz.
  //  This means that 1/2 the 27MHz (13.5MHz) should not be used.
  DWORD dwRefXtal = (pBWRegs->BCLK_Denom & 0x02) ? (TVO_XTAL / 4) : REF_XTAL;

  ODS("ChipCalcMCLK() called.\n");

  *pdwMCLK = (dwRefXtal * (DWORD)pBWRegs->BCLK_Mult) >> 2;

  ODS("ChipCalcMCLK(): MCLK = %ld\n", *pdwMCLK);

  if(0 == *pdwMCLK)
  {
    ODS("ChipCalcMCLK(): Calculated invalid MCLK (0).\n");
    goto Error;
  }

  fSuccess = TRUE;
Error:
  return(fSuccess);
}


/**********************************************************
*
* ChipCalcVCLK()
*
* Determines currently set pixel clock (VCLK) based on
*  register values provided.
*
* Returns: Success and current VCLK in Hz.
*
***********************************************************
* Author: Rick Tillery
* Date:   11/18/95
*
* Revision History:
* -----------------
* WHO WHEN     WHAT/WHY/HOW
* --- ----     ------------
*********************************************************/
BOOL ChipCalcVCLK(LPBWREGS pBWRegs,
                  LPDWORD  pdwVCLK)
{
  BOOL fSuccess = FALSE;
  BYTE bNum, bDenom;
  int  iShift;
  // We make the assumption that if the BCLK_Denom /4 is set, the reference
  //  xtal is 27MHz.  If it is not set, we assume the ref xtal is 14.31818MHz.
  //  This means that 1/2 the 27MHz (13.5MHz) should not be used.
  //  Add 20000000ul to increas Bandwidth.
  DWORD dwRefXtal = (pBWRegs->BCLK_Denom & 0x02) ? (TVO_XTAL + 2000000ul)  : REF_XTAL;

  ODS("ChipCalcVCLK() called dwRef= %ld\n",dwRefXtal);

  if(pBWRegs->VCLK3Num & 0x80)
  {
    fSuccess = ChipCalcMCLK(pBWRegs, pdwVCLK);
    goto Error;
  }

  /*
   * VCLK is normally based on one of 4 sets of numerator and
   *  denominator pairs.  However, the CL-GD5465 can only access
   *  VCLK 3 through the MMI/O.
   */
  if((pBWRegs->MISCOutput & 0x0C) != 0x0C)
  {
    ODS("ChipCalcVCLK(): VCLK %d in use.  MMI/O can only access VCLK 3.\n",
        (int)((pBWRegs->MISCOutput & 0x0C) >> 2));
//    goto Error;
  }

  bNum = pBWRegs->VCLK3Num & 0x7F;
  bDenom = (pBWRegs->VCLK3Denom & 0xFE) >> 1;

  if(pBWRegs->VCLK3Denom & 0x01)
  {
    // Apply post scalar
    bDenom <<= 1;
  }

  if(0 == bDenom)
  {
    ODS("ChipCalcVCLK(): Invalid VCLK denominator (0).\n");
    goto Error;
  }

  // Calculate actual VCLK frequency (Hz)
  iShift = ScaleMultiply(dwRefXtal, (DWORD)bNum, pdwVCLK);
  *pdwVCLK /= (DWORD)bDenom;
  *pdwVCLK >>= iShift;


  //Check PLL output Frequency  
  iShift = ( pBWRegs->GfVdFormat >> 14 );
  *pdwVCLK >>= iShift;

  ODS("ChipCalcVCLK(): VCLK = %ld\n", *pdwVCLK);

  if(0 == *pdwVCLK)
  {
    ODS("ChipCalcVCLK(): Calculated invalid VCLK (0).\n");
    goto Error;
  }

  fSuccess = TRUE;
Error:
  return(fSuccess);
}


/**********************************************************
*
* ChipIsEnoughBandwidth()
*
* Determines whether their is enough bandwidth for the video
*  configuration specified in the VIDCONFIG structure with
*  the system configuration specified in the BWREGS structure
*  and returns the values that need to be programmed into the
*  bandwidth related registers.  The pProgRegs parameter
*  may be NULL to allow checking a configuration only.  This
*  function gets the register values and passes them to
*  ChipCheckBW() to check the bandwidth.
*  
*
* Returns: BOOLean indicating whether there is sufficient
*           bandwidth for the configuration specified.
*          Values to program into bandwidth related registers
*           if the pProgRegs parameter is not NULL.
*
***********************************************************
* Author: Rick Tillery
* Date:   03/20/97
*
* Revision History:
* -----------------
* WHO WHEN     WHAT/WHY/HOW
* --- ----     ------------
*********************************************************/
BOOL ChipIsEnoughBandwidth(LPPROGREGS  pProgRegs,
                           LPVIDCONFIG pConfig,
                           LPBWREGS    pBWRegs )
{
  BOOL   fSuccess = FALSE;
  DWORD  dwMCLK, dwVCLK;
  DWORD dwDenom;
  int iNumShift, iDenomShift;
  DWORD dwGfxFetch, dwBLTFetch;
  DWORD dwGfxFill, dwBLTFill;
  DWORD dwMaxGfxThresh, dwMinGfxThresh;
  DWORD dwMaxVidThresh, dwMinVidThresh;
  DWORD dwHitLatency, dwRandom;
  BOOL  f500MHZ,fConCurrent;  
  DWORD dwTemp;
  BOOL  f585MHZ = TRUE;  			//PDR#11521

// There are some modes that have the same bandwidth parameters
//  like MCLK, VCLK, but have different dwScreenWidht. The bandwidth
//  related register settings have major differences for these mode.
//  For this reason, dwScreenWidth need to be passed for this function. 
   DWORD dwScreenWidth;
 
//  ODS("ChipIsEnoughBandwidth() called.\n");

  if(!ChipCalcMCLK(pBWRegs, &dwMCLK))
  {
    ODS("ChipIsEnoughBandwidth(): Unable to calculate MCLK.\n");
    goto Error;
  }

  if(!ChipCalcVCLK(pBWRegs, &dwVCLK))
  {
    ODS("ChipIsEnoughBandwidth(): Unable to calculate VCLK.\n");
    goto Error;
  }

  if( dwMCLK > 70000000 )
        f500MHZ = FALSE;
   else
        f500MHZ = TRUE;

  if ((dwMCLK > 70000000) && ( dwMCLK < 72000000))	  //PDR#11521
	  f585MHZ = TRUE;
	else
	  f585MHZ = FALSE;


  dwScreenWidth = (pBWRegs->CR1 + 1 ) << 3;
  if( pBWRegs->CR1E & 0x40 )
    dwScreenWidth += 0x1000;
  
  ODS("ChipIsEnoughBandwidth(): dwScreenWidth = %ld\n",dwScreenWidth);

  dwBLTFetch = (pBWRegs->Control2 & 0x0010) ? 256ul : 128ul;

  dwGfxFetch = (pBWRegs->DispThrsTiming & 0x0040) ? 256ul : 128ul;

ODS("GraphicDepth%ld,VideoDepth=%ld",pConfig->uGfxDepth,pConfig->uSrcDepth);

  if(pBWRegs->RIFControl & 0xC000)
  {
    ODS("ChipIsEnoughBandwidth(): Concurrent RDRAM detected!\n");
    dwHitLatency = CONC_HIT_LATENCY;
    dwRandom = CONC_RANDOM;
    fConCurrent = TRUE;
  }
  else
  {
    ODS("ChipIsEnoughBandwidth(): Normal RDRAM detected.\n");
    dwHitLatency = NORM_HIT_LATENCY;
    dwRandom = NORM_RANDOM;
    fConCurrent = FALSE;
  }
  
  // Determine the number of MCLKs to transfer to the graphics FIFO.
  dwGfxFill = (dwGfxFetch * 8ul) / FIFOWIDTH;
  // And BLTer FIFO.
  dwBLTFill = (dwBLTFetch * 8ul) / FIFOWIDTH;

  //
  // Determine maximum graphics threshold
  //

  dwMaxGfxThresh = dwHitLatency + dwGfxFill + (GFXFIFOSIZE / 2ul) -10ul;

  //    ( K * VCLK * GfxDepth )   GFXFIFOSIZE
  // INT( ------------------- ) + ----------- - 1
  //    ( FIFOWIDTH * MCLK    )        2
  iNumShift = ScaleMultiply(dwMaxGfxThresh, dwVCLK, &dwMaxGfxThresh);
  iNumShift += ScaleMultiply(dwMaxGfxThresh, (DWORD)pConfig->uGfxDepth,
                             &dwMaxGfxThresh);

  iDenomShift = ScaleMultiply(FIFOWIDTH, dwMCLK, &dwDenom);

  if(iNumShift > iDenomShift)
  {
    dwDenom >>= (iNumShift - iDenomShift);
  }
  else
  {
    dwMaxGfxThresh >>= (iDenomShift - iNumShift);
  }

  dwMaxGfxThresh /= dwDenom;

  dwMaxGfxThresh += (GFXFIFOSIZE / 2ul) - 1ul;
  
  if(dwMaxGfxThresh > GFXFIFOSIZE -1 )
        dwMaxGfxThresh = GFXFIFOSIZE -1;
  ODS("ChipIsEnoughBandwidth(): Max graphics thresh = %ld.\n", dwMaxGfxThresh);

  /*
   * Determine minimum graphics threshold
   */
  if(pConfig->dwFlags & VCFLG_DISP)
  {
    // Video enabled

    DWORD dwMinGfxThresh1, dwMinGfxThresh2;

    if(pConfig->dwFlags & VCFLG_420)
    {
      // 4:2:0

      dwMinGfxThresh1 = DISP_LATENCY + dwRandom + dwBLTFill
                        + dwRandom - RIF_SAVINGS + dwBLTFill
                        + dwRandom - RIF_SAVINGS + VID420FILL
                        + dwRandom - RIF_SAVINGS + VID420FILL
                        + dwRandom - RIF_SAVINGS + 1ul;

      dwMinGfxThresh2 = DISP_LATENCY + dwRandom + dwBLTFill
                        + dwRandom - RIF_SAVINGS + dwBLTFill
                        + dwRandom - RIF_SAVINGS + VID420FILL
                        + dwRandom - RIF_SAVINGS + VID420FILL
                        + dwRandom - RIF_SAVINGS + dwGfxFill
                        + dwRandom - RIF_SAVINGS + dwBLTFill
                        + dwRandom - RIF_SAVINGS + VID420FILL
                        + dwRandom - RIF_SAVINGS + VID420FILL
                        + dwRandom - RIF_SAVINGS + 1ul;

    }
    else
    {
      // 4:2:2, 5:5:5, 5:6:5, or X:8:8:8

      dwMinGfxThresh1 = DISP_LATENCY + dwRandom + dwBLTFill
                        + dwRandom - RIF_SAVINGS + dwBLTFill
                        + dwRandom - RIF_SAVINGS + VIDFILL
                        + dwRandom - RIF_SAVINGS + 1ul;

      dwMinGfxThresh2 = DISP_LATENCY + dwRandom + dwBLTFill
                        + dwRandom - RIF_SAVINGS + dwBLTFill
                        + dwRandom - RIF_SAVINGS + VIDFILL
                        + dwRandom - RIF_SAVINGS + dwGfxFill
                        + dwRandom - RIF_SAVINGS + dwBLTFill
                        + dwRandom - RIF_SAVINGS + VIDFILL
                        + dwRandom - RIF_SAVINGS + 1ul;
    }

    //
    // Finish dwMinGfxThresh1
    //
    //    ( K * VCLK * GfxDepth   FIFOWIDTH * MCLK) - 1 )
    // INT( ------------------- + --------------------- ) + 1
    //    (  FIFOWIDTH * MCLK       FIFOWIDTH * MCLK    )
    //
    iNumShift = ScaleMultiply(dwMinGfxThresh1, dwVCLK, &dwMinGfxThresh1);
    iNumShift += ScaleMultiply(dwMinGfxThresh1, (DWORD)pConfig->uGfxDepth,
                               &dwMinGfxThresh1);

    iDenomShift = ScaleMultiply(FIFOWIDTH, dwMCLK, &dwDenom);

    if(iNumShift > iDenomShift)
    {
      dwDenom >>= (iNumShift - iDenomShift);
    }
    else
    {
      dwMinGfxThresh1 >>= (iDenomShift - iNumShift);
    }

    // Be sure rounding below doesn't overflow.
    while((dwMinGfxThresh1 + dwDenom - 1ul) < dwMinGfxThresh1)
    {
      dwMinGfxThresh1 >>= 1;
      dwDenom >>= 1;
    }
    // Round up
    dwMinGfxThresh1 += dwDenom - 1ul;

    dwMinGfxThresh1 /= dwDenom;

    dwMinGfxThresh1++;  // Compensate for decrement by 2

    //
    // Finish dwMinGfxThresh2
    //
    //    ( K * VCLK * GfxDepth   (FIFOWIDTH * MCLK) - 1 )   GfxFetch * 8
    // INT( ------------------- + ---------------------- ) - ------------ + 1
    //    (  FIFOWIDTH * MCLK        FIFOWIDTH * MCLK    )    FIFOWIDTH
    //
    iNumShift = ScaleMultiply(dwMinGfxThresh2, dwVCLK, &dwMinGfxThresh2);
    iNumShift += ScaleMultiply(dwMinGfxThresh2, (DWORD)pConfig->uGfxDepth,
                               &dwMinGfxThresh2);

    iDenomShift = ScaleMultiply(FIFOWIDTH, dwMCLK, &dwDenom);

    if(iNumShift > iDenomShift)
    {
      dwDenom >>= (iNumShift - iDenomShift);
    }
    else
    {
      dwMinGfxThresh2 >>= (iDenomShift - iNumShift);
    }

    // Be sure rounding below doesn't overflow.
    while((dwMinGfxThresh2 + dwDenom - 1ul) < dwMinGfxThresh2)
    {
      dwMinGfxThresh2 >>= 1;
      dwDenom >>= 1;
    }
    // Round up
    dwMinGfxThresh2 += dwDenom - 1ul;

    dwMinGfxThresh2 /= dwDenom;

    // Adjust for second transfer
    dwMinGfxThresh2 -= ((dwGfxFetch * 8ul) / FIFOWIDTH);

    // Adjust for decrement by 2
    dwMinGfxThresh2++;

    if( fConCurrent)
    {
        if( f500MHZ)
        {
            if( (pConfig->uGfxDepth == 32) && ( dwVCLK >= 64982518ul ))
            {
                 dwTemp = ( dwVCLK - 64982518ul) /1083333ul  + 1ul;
                 dwMinGfxThresh2 -= dwTemp;
                 dwMinGfxThresh1 -= 10;
            }
            else if( (pConfig->uGfxDepth == 24) && (dwVCLK > 94500000ul))
                dwMinGfxThresh2 -=5;        //Adjust again for 24 bit #xc
        }
        else        //600MHZ
        {
            if( (pConfig->uGfxDepth == 16) && ( dwVCLK > 156000000ul))
                dwMinGfxThresh2 -= 4;
            else if( (pConfig->uGfxDepth == 24) && ( dwVCLK > 104000000ul))
            {
                dwMinGfxThresh2 -= (5ul+ 8ul * (dwVCLK - 104000000ul) / 17000000ul);
            }
            else if( (pConfig->uGfxDepth == 32) )
            {  
                if( dwVCLK > 94000000ul)
                    dwMinGfxThresh2 -= 16;
               if( dwVCLK > 70000000ul)
                    dwMinGfxThresh2 -= 4;
					 else
						  dwMinGfxThresh2 +=6; //#PDR#11506 10x7x32bit could not
													  //support YUV420.
            }

        }

        if( (pConfig->uGfxDepth == 8) && (dwVCLK > 18000000ul))
                dwMinGfxThresh2 += 6;
    } 
    else    //Normal RDRam
    {   
        if( f500MHZ )
        {
            if( (pConfig->uGfxDepth == 32) && ( dwVCLK > 49500000ul ))
            {
                dwMinGfxThresh1 -= 4;
                dwMinGfxThresh2 -= (( dwVCLK - 49715909ul) / 726981ul + 3ul);
            }
            else if( (pConfig->uGfxDepth == 24) && ( dwVCLK > 60000000ul ) 
                &&  (dwVCLK < 95000000ul))
            {
                dwTemp= ((dwVCLK - 64982518ul) / 1135287ul + 3ul);

                dwMinGfxThresh2 -=dwTemp;
                dwMinGfxThresh1 -= 10;
             }

        }
        else        //600MHZ case
        {
            if( (pConfig->uGfxDepth == 32) && ( dwVCLK > 49700000ul ))
            {
                dwTemp= ((dwVCLK - 49700000ul) / 1252185ul + 5ul);
                dwMinGfxThresh2 -= dwTemp;
                dwMinGfxThresh1 -= 4ul;
            }
            else  if( (pConfig->uGfxDepth == 24) && ( dwVCLK > 60000000ul ))
            {  
                dwTemp= ((dwVCLK - 64982518ul) / 2270575ul + 4ul);

               dwMinGfxThresh2 -=dwTemp;
               dwMinGfxThresh1 -= 8;

            }
            else  if( pConfig->uGfxDepth == 16) 
            {
                  dwMinGfxThresh2 -= 4;
            }
            else  if( pConfig->uGfxDepth == 8)
            {
               if(dwVCLK >170000000)
                  dwMinGfxThresh1 += 10;
               else
                  dwMinGfxThresh1 += 4;
                  
            }
        }
    }

    ODS("ChipIsEnoughBandwidth(): Min graphics thresh1 2 = %ld,%ld.\n",
          dwMinGfxThresh1, dwMinGfxThresh2);
    // Adjust for unsigned overflow
    if(dwMinGfxThresh2 > GFXFIFOSIZE + 20ul)
    {
      dwMinGfxThresh2 = 0ul;
    }

    //
    // Whichever is higher should be the right one
    //
    dwMinGfxThresh = __max(dwMinGfxThresh1, dwMinGfxThresh2);
  }
  else
  {
    // No video enabled

    dwMinGfxThresh = DISP_LATENCY + dwRandom + dwBLTFill
                     + dwRandom - RIF_SAVINGS + 1ul;

    //    ( K * VCLK * GfxDepth   (FIFOWIDTH * MCLK) - 1 )
    // INT( ------------------- + ---------------------- )
    //    (  FIFOWIDTH * MCLK        FIFOWIDTH * MCLK    )
    iNumShift = ScaleMultiply(dwMinGfxThresh, dwVCLK, &dwMinGfxThresh);
    iNumShift += ScaleMultiply(dwMinGfxThresh, (DWORD)pConfig->uGfxDepth,
                               &dwMinGfxThresh);

    iDenomShift = ScaleMultiply(FIFOWIDTH, dwMCLK, &dwDenom);

    if(iNumShift > iDenomShift)
    {
      dwDenom >>= (iNumShift - iDenomShift);
    }
    else
    {
      dwMinGfxThresh >>= (iDenomShift - iNumShift);
    }

    // Be sure rounding below doesn't overflow.
    while((dwMinGfxThresh + dwDenom - 1ul) < dwMinGfxThresh)
    {
      dwMinGfxThresh >>= 1;
      dwDenom >>= 1;
    }
    // Round up
    dwMinGfxThresh += dwDenom - 1ul;

    dwMinGfxThresh /= dwDenom;

    dwMinGfxThresh++; // Compensate for decrement by 2
  }

  ODS("ChipIsEnoughBandwidth(): Min graphics thresh = %ld.\n", dwMinGfxThresh);

  if(dwMaxGfxThresh < dwMinGfxThresh)
  {
    ODS("ChipIsEnoughBandwidth(): Minimum graphics threshold exceeds maximum.\n");
    goto Error;
  }
 
  if(pProgRegs)
  {
    pProgRegs->DispThrsTiming = (WORD)dwMinGfxThresh;
  }
ODS("xfer=%x,cap=%x,src=%x,dsp=%x\n",pConfig->sizXfer.cx,pConfig->sizCap.cx,
    pConfig->sizSrc.cx,pConfig->sizDisp.cx);
  // Start-of-line check is only for capture
  if(pConfig->dwFlags & VCFLG_CAP)
  {
    DWORD dwNonCapMCLKs, dwCapMCLKs;

    // Do start-of-line check to be sure capture FIFO does not overflow.

    // First determine the number of MCLK cycles at the start of the line.
    //  We'll compare this to the number of levels of the capture FIFO
    //  filled during the same time to make sure the capture FIFO doesn't
    //  overflow.

    // Start of line:  BLT + HC + V + G + V + G
    dwNonCapMCLKs = dwRandom + dwBLTFill;
    // Hardware cursor is only necessary if it is on, however, since it can
    //  be enabled or disabled, and VPM has no way of knowing when this
    //  occurs, we must always assume it is on.
    dwNonCapMCLKs += dwRandom - RIF_SAVINGS + CURSORFILL;

    if(pConfig->dwFlags & VCFLG_DISP)
    {
      // Only one video fill is required, however if the video FIFO threshold
      //  is greater than 1/2, the second fill will be done.  Also, because of
      //  the tiled architecture, even though the video might not be aligned,
      //  the transfer will occur on a tile boundary.  If the transfer of a
      //  single tile cannot fulfill the FIFO request, the second fill will be
      //  done.  Since the pitch will vary, and the client can move the source
      //  around, we must always assume that the second video FIFO fill will
      //  be done.
      if(pConfig->dwFlags & VCFLG_420)
      {
        dwNonCapMCLKs += 4ul * (dwRandom - RIF_SAVINGS + VID420FILL);
      }
      else
      {
        dwNonCapMCLKs += 2ul * (dwRandom - RIF_SAVINGS + VIDFILL);
      }
    }
    // The graphics FIFO fill depends on the fetch size.  We also assume that
    //  the pitch is a multiple of the fetch width.
    dwNonCapMCLKs += dwRandom - RIF_SAVINGS + dwGfxFill;
    // The second graphics FIFO fill will be done if:
    //  1. The graphics is not aligned on a fetch boundary (panning).
    //  2. The FIFO threshold is over 1/2 the FIFO (the fill size).
    if((dwMinGfxThresh >= dwGfxFill) || (pConfig->dwFlags & VCFLG_PAN))
    {
      dwNonCapMCLKs += dwRandom - RIF_SAVINGS + dwGfxFill;
    }

    dwNonCapMCLKs += 3; // Magic number that seems to work for now.

    ODS("ChipIsEnoughBandwidth(): dwNonCapMCLKs = %ld\n", dwNonCapMCLKs);

    // sizXfer.cx * FIFOWIDTH * (CAPFIFOSIZE / 2) * dwMCLK
    // ---------------------------------------------------
    //         dwXferRate * uCapDepth * sizCap.cx

    iNumShift = ScaleMultiply((DWORD)pConfig->sizXfer.cx, FIFOWIDTH,
                              &dwCapMCLKs);
    iNumShift += ScaleMultiply(dwCapMCLKs, (CAPFIFOSIZE / 2), &dwCapMCLKs);
    iNumShift += ScaleMultiply(dwCapMCLKs, dwMCLK, &dwCapMCLKs);

    iDenomShift = ScaleMultiply(pConfig->dwXferRate, (DWORD)pConfig->uCapDepth,
                                &dwDenom);
    iDenomShift += ScaleMultiply(dwDenom, (DWORD)pConfig->sizCap.cx, &dwDenom);

    if(iNumShift > iDenomShift)
    {
      dwDenom >>= (iNumShift - iDenomShift);
    }
    else
    {
      dwCapMCLKs >>= (iDenomShift - iNumShift);
    }

    dwCapMCLKs /= dwDenom;

    ODS("ChipIsEnoughBandwidth(): dwCapMCLKs = %ld\n", dwCapMCLKs);
    if(fConCurrent)
    {
        if( pConfig->uGfxDepth == 32) 
            dwCapMCLKs -= 44;     //adjust 32 bit 
    }

    if(dwNonCapMCLKs > dwCapMCLKs)
    {
      ODS("ChipIsEnoughBandwidth(): Capture overflow at start of line.\n");
      goto Error;
    }
  }

  if(pConfig->dwFlags & VCFLG_DISP)
  {
    /*
     * Determine maximum video threshold
     */
    dwMaxVidThresh = dwHitLatency;
    if(pConfig->dwFlags & VCFLG_420)
    {
      dwMaxVidThresh += VID420FILL;
      if( !f500MHZ && fConCurrent )
         dwMaxVidThresh += 5;
    }
    else
    {
      dwMaxVidThresh += VIDFILL;
    }

    //    ( K * VCLK * VidDepth * SrcWidth )
    // INT( ------------------------------ ) + VidFill (/ 2) - 1
    //    ( FIFOWIDTH * MCLK * DispWidth   )             ^non-4:2:0 only
    iNumShift = ScaleMultiply(dwMaxVidThresh, dwVCLK, &dwMaxVidThresh);
    iNumShift += ScaleMultiply(dwMaxVidThresh, (DWORD)pConfig->uSrcDepth,
                                &dwMaxVidThresh);
    iNumShift += ScaleMultiply(dwMaxVidThresh, (DWORD)pConfig->sizSrc.cx,
                                &dwMaxVidThresh);

    iDenomShift = ScaleMultiply(FIFOWIDTH, (DWORD)pConfig->sizDisp.cx, &dwDenom);
    iDenomShift += ScaleMultiply(dwDenom, dwMCLK, &dwDenom);

    if(iNumShift > iDenomShift)
    {
      dwDenom >>= (iNumShift - iDenomShift);
    }
    else
    {
      dwMaxVidThresh >>= (iDenomShift - iNumShift);
    }

    dwMaxVidThresh /= dwDenom;

    if(pConfig->dwFlags & VCFLG_420)
    {
      dwMaxVidThresh += VID420FILL;
    }
    else
    {
      dwMaxVidThresh += VIDFILL;
      // Threshold is programmed in DQWORDS for non-4:2:0
      dwMaxVidThresh /= 2ul;
    }
    dwMaxVidThresh--;

    ODS("ChipIsEnoughBandwidth(): Max video thresh = %ld.\n", dwMaxVidThresh);

     if( fConCurrent && f500MHZ && ( dwVCLK < 66000000ul))
         dwMaxVidThresh = __min(dwMaxVidThresh, 8); 
    /*
     * Determine minimum video threshold
     */
    {
      DWORD dwMinVidThresh1, dwMinVidThresh2;

      if(pConfig->dwFlags & VCFLG_420)
      {
        // 4:2:0

        dwMinVidThresh1 = DISP_LATENCY + dwRandom + dwGfxFill
                          + dwRandom - RIF_SAVINGS + VID420FILL
                          + dwRandom - RIF_SAVINGS + 1;

        dwMinVidThresh2 = DISP_LATENCY + dwRandom + dwGfxFill
                          + dwRandom - RIF_SAVINGS + VID420FILL
                          + dwRandom - RIF_SAVINGS + VID420FILL
                          + dwRandom - RIF_SAVINGS + VID420FILL
                          + dwRandom - RIF_SAVINGS + 1;
      }
      else
      {
        // 4:2:2, 5:5:5, 5:6:5, or X:8:8:8

        dwMinVidThresh1 = DISP_LATENCY + dwRandom + dwGfxFill
                          + dwRandom - RIF_SAVINGS + 2;

        dwMinVidThresh2 = DISP_LATENCY + dwRandom + dwGfxFill
                          + dwRandom - RIF_SAVINGS + VIDFILL
                          + 15ul        //#xc
  //                        + 10ul
                          + dwRandom - RIF_SAVINGS + dwGfxFill
                          + dwRandom - RIF_SAVINGS + 2ul;
        if(fConCurrent)
        {
           if(f500MHZ )
           { 
               if( (pConfig->uGfxDepth == 32) && ( dwVCLK > 60000000ul ))
               {
                    if( dwVCLK > 94000000ul)
                        dwMinVidThresh1 += 105;
                    else if( dwVCLK > 74000000ul)
                        dwMinVidThresh1 += 90;
                     else
                        dwMinVidThresh1 += 65;
                    if(pConfig->dwFlags & VCFLG_CAP) 
                    {
                        if(dwVCLK > 78000000ul)
                            dwMinVidThresh1 += 260; //disable video
                        else if( dwVCLK > 74000000ul)
                            dwMinVidThresh1 += 70;
                    }                
               }  
               else if( pConfig->uGfxDepth == 24)
               {
                      if( dwVCLK > 94500000ul)
                      {
                        if(dwScreenWidth == 1024)
                           dwMinVidThresh2 += 50ul;
                        else
                           dwMinVidThresh2 += 90ul; 
                      }
                      else if( dwVCLK < 41000000ul)
                      {
                        dwMinVidThresh2 += 4;
                      }    
                      else  if(dwVCLK < 80000000ul)
                      {
                         if( (dwVCLK > 74000000ul) && (dwVCLK < 76000000ul))
                         {
                              dwMinVidThresh2 -= 1;
                         }
                         else
                            dwMinVidThresh2 -= 8;
                         dwMinVidThresh1 -= 4;
    
                      }   
                    
                    if(pConfig->dwFlags & VCFLG_CAP) 
                      if( dwVCLK > 94000000ul)
                      { 
                            if((dwVCLK < 95000000ul) && ( dwGfxFetch == 256 ))
                                dwMinVidThresh2 += 60; 
                            else
                                dwMinVidThresh2 += 120; 
                      }                 
                }
               else if( (pConfig->uGfxDepth == 16) && ( dwVCLK > 60000000ul ))
               {                    
                   if( dwVCLK < 94000000ul)
                   {  
                        dwMinVidThresh2 -= 10;
                        dwMinVidThresh1 -= 6;
                   }
                   else if( dwVCLK > 105000000ul)
                        dwMinVidThresh2 += 50;
                } 
               else if( (pConfig->uGfxDepth == 8) && ( dwVCLK > 60000000ul ))
               {
                  if( dwVCLK > 216000000ul)
                  {
                    dwMinVidThresh2 += 50;
                    dwMinVidThresh1 += 20;
                   }   
                  else if( (dwVCLK < 95000000ul) && ( dwScreenWidth <= 1024))
                  {  
                    dwMinVidThresh2 -= 12;
                    dwMinVidThresh1 -= 10;
                    dwMaxVidThresh = __min(dwMaxVidThresh, 9); 
                  }
                  else if(dwVCLK < 109000000ul)
                  {
                    dwMinVidThresh2 += ( 14 -  4 * ( dwVCLK - 94000000ul ) / 14000000ul );
                    dwMinVidThresh1 += 10;
                    dwMaxVidThresh = __min(dwMaxVidThresh, 8); 
                  }  
                  else
                  {
                     dwMinVidThresh2 += 7;
                     dwMinVidThresh1 += 4;
                  }
               }
            }
#if 1//PDR#11521
	        else if (f585MHZ)       //585MHZ
   	     {
                if( (pConfig->uGfxDepth == 8) && ( dwVCLK > 56000000ul))
                {
                    if( dwVCLK > 200000000ul)
                    {
                        dwMaxVidThresh++;
                        dwMinVidThresh1 += 7;
                        dwMinVidThresh2 += 14;    

                    }
                    else if( dwVCLK  < 60000000ul)
                    {
                     dwMinVidThresh2 += 8;
                    }
                    else if( dwVCLK < 160000000ul)
                    {
                        dwMinVidThresh1 -=20;
                        dwMinVidThresh2 -=10;    
                    }
 
                    if(pConfig->dwFlags & VCFLG_CAP)
                    {
                        if( dwVCLK < 76000000ul)
                           dwMinVidThresh2 +=8; 
                        else if( dwVCLK < 140000000ul)    
                           dwMinVidThresh2 +=25;     
                        else                        
                           dwMinVidThresh2 +=32;     
                    }
                }
                else  if( (pConfig->uGfxDepth == 16) && ( dwVCLK > 60000000ul))
                {
                        if( dwVCLK > 157000000ul)
                        {
                            dwMinVidThresh1 += 27;    
                            dwMaxVidThresh ++;
                        }
                        if( dwVCLK > 125000000ul)
                        {
                          dwMinVidThresh1 += 40;
                        }    
                        else if( dwVCLK > 107000000ul)
                        {
                          dwMinVidThresh1 += 34;
                        }
                        else 
                        if( dwVCLK > 74000000ul)
                        {
                          dwMinVidThresh1 += 18;
                        }

                    if( dwVCLK > 189000000ul)     //PDR11521
                            dwMaxVidThresh ++;   

                       if(pConfig->dwFlags & VCFLG_CAP)
                       {
                            if( dwVCLK > 74000000ul)
                               dwMinVidThresh1 +=2; 
                        }
                }
                else  if( pConfig->uGfxDepth == 24)
                {
                    if( dwVCLK < 60000000ul)
                    {
                        dwMinVidThresh1 -= 8;
                        dwMinVidThresh2 -= 16;
                    }
                    else if( dwVCLK  > 107000000ul )
                          dwMinVidThresh2 += 84;
                    else if( (dwVCLK > 94000000ul) && (dwScreenWidth >= 1152))
                    {
                        dwMinVidThresh2 += 40;
                    }

                    if( dwVCLK > 126000000ul)     //PDR11521
                            dwMaxVidThresh ++;   

                    if(pConfig->dwFlags & VCFLG_CAP)
                    {
                         if( dwVCLK > 74000000ul)
                            dwMinVidThresh2 +=12; 
                    }

                }
                else  if(( pConfig->uGfxDepth == 32) && ( dwVCLK > 60000000ul))
                {
                    if( dwVCLK > 74000000ul)
                    {
                        if( (dwVCLK > 77000000ul) && ( dwVCLK < 80000000ul))
                            dwMinVidThresh2 += 120;
                        else
                            dwMinVidThresh2 += 83;       
                    }
                    else                
                        dwMinVidThresh2 += 30;

                    if( dwVCLK > 94000000ul)     //PDR11521
                            dwMaxVidThresh ++;   
    
                    if(pConfig->dwFlags & VCFLG_CAP)
                    {
                          if( dwVCLK > 94000000ul)
                            dwMinVidThresh2 +=2; 
                    }
                }
                else  if(( pConfig->uGfxDepth == 32) && ( dwVCLK > 49000000ul))
                {
                    
                    if(pConfig->dwFlags & VCFLG_CAP)
                            dwMinVidThresh2 +=2; 
                }

      	  }
#endif
            else        //600MZH concurrent
            {
                if( (pConfig->uGfxDepth == 8) && ( dwVCLK > 56000000ul))
                {
                    if( dwVCLK > 200000000ul)
                    {
//PDR#11541                        dwMaxVidThresh++;
                        dwMinVidThresh1 += 7;
                        dwMinVidThresh2 += 14;    

                    }
                    else if( dwVCLK  < 60000000ul)
                    {
                     dwMinVidThresh2 += 8;
                    }
                    else if( dwVCLK < 160000000ul)
                    {
                        dwMinVidThresh1 -=20;
                        dwMinVidThresh2 -=10;    
                    }
 
                    if(pConfig->dwFlags & VCFLG_CAP)
                    {
                        if( dwVCLK < 76000000ul)
                           dwMinVidThresh2 +=8; 
                        else if( dwVCLK < 140000000ul)    
                           dwMinVidThresh2 +=25;     
                        else                        
                           dwMinVidThresh2 +=32;     
                    }
                }
                else  if( (pConfig->uGfxDepth == 16) && ( dwVCLK > 60000000ul))
                {
                        if( dwVCLK > 157000000ul)
                        {
                            dwMinVidThresh1 += 27;    
//PDR#11541                            dwMaxVidThresh ++;
                        }
                        if( dwVCLK > 125000000ul)
                        {
                          dwMinVidThresh1 += 40;
                        }    
                        else if( dwVCLK > 107000000ul)
                        {
                          dwMinVidThresh1 += 34;
                        }
                        else 
                        if( dwVCLK > 74000000ul)
                        {
                          dwMinVidThresh1 += 18;
                        }


                       if(pConfig->dwFlags & VCFLG_CAP)
                       {
                            if( dwVCLK > 74000000ul)
                               dwMinVidThresh1 +=2; 
                        }
                }
                else  if( pConfig->uGfxDepth == 24)
                {
                    if( dwVCLK < 60000000ul)
                    {
                        dwMinVidThresh1 -= 8;
                        dwMinVidThresh2 -= 16;
                    }
                    else if( dwVCLK  > 107000000ul )
                          dwMinVidThresh2 += 84;
                    else if( (dwVCLK > 94000000ul) && (dwScreenWidth >= 1152))
                    {
                        dwMinVidThresh2 += 40;
                    }

                    if(pConfig->dwFlags & VCFLG_CAP)
                    {
                         if( dwVCLK > 74000000ul)
                            dwMinVidThresh2 +=12; 
                    }

                }
                else  if(( pConfig->uGfxDepth == 32) && ( dwVCLK > 60000000ul))
                {
                    if( dwVCLK > 74000000ul)
                    {
                        if( (dwVCLK > 77000000ul) && ( dwVCLK < 80000000ul))
                            dwMinVidThresh2 += 120;
                        else
                            dwMinVidThresh2 += 83;       
                    }
                    else                
                        dwMinVidThresh2 += 30;        
    
                    if(pConfig->dwFlags & VCFLG_CAP)
                    {
                          if( dwVCLK > 94000000ul)
                            dwMinVidThresh2 +=2; 
                    }
                }
                else  if(( pConfig->uGfxDepth == 32) && ( dwVCLK > 49000000ul))
                {
                    
                    if(pConfig->dwFlags & VCFLG_CAP)
                            dwMinVidThresh2 +=2; 
                }

            }
        }
        else     //Normal RDRam case
        {  
           if(f500MHZ )
           { 
             if( (pConfig->uGfxDepth == 32) && ( dwVCLK > 60000000ul ))
             {
                 dwMinVidThresh1 += 75;
                 if(pConfig->dwFlags & VCFLG_CAP)
                    dwMinVidThresh1 +=20;
             }
             else if( (pConfig->uGfxDepth == 24) && ( dwVCLK > 7800000ul ))
             {
                 dwMinVidThresh2 += 52;
                 if(pConfig->dwFlags & VCFLG_CAP)
                 {
                     dwMinVidThresh2 += 50;
                  }
             }   
             else if(pConfig->uGfxDepth == 16)
             {
                 if((dwVCLK > 36000000 ) && ( dwVCLK < 57000000))
                 {
                      dwMinVidThresh2 += 22 - ( dwVCLK - 36000000) * 3L /
                                 4000000; 
                 } 
                 else
                 {
                    dwMinVidThresh2 -= 18;
                    dwMinVidThresh1 -= 8;
                 }   
                if(pConfig->dwFlags & VCFLG_CAP)
                {
                     dwMinVidThresh2 += 5;
                }
              }
              else if((pConfig->uGfxDepth == 8) && ( dwVCLK > 36000000ul )) 
              { 
                if(dwVCLK > 160000000ul)
                    dwMinVidThresh2 -= 6;
                else if( (dwVCLK > 94000000 ) && (dwVCLK < 109000000) && (dwScreenWidth == 1152))
                {
                    dwMinVidThresh2 -=  2 + 4 * ( dwVCLK - 94000000 ) / 13500000;
                }
                else if( (dwVCLK < 109000000) && (dwScreenWidth == 1280))
                {
                     dwMinVidThresh2 -= 5;   
                }
                else if( dwVCLK > 60000000ul)
                {
                     dwMinVidThresh2 -= 18;
                     if(pConfig->dwFlags & VCFLG_CAP)
                     {
                         dwMinVidThresh2 += 5;
                     }
                }
                else 
                    dwMinVidThresh2 += 6;
                dwMinVidThresh1 -= 8;
             } 

           }
           else     //600 MHZ
           { 
                if(pConfig->uGfxDepth == 32)
                { 
                   if( dwVCLK > 60000000ul )
                   {
                        dwTemp = ( dwVCLK - 60000000ul ) /300000ul + 38ul;
                        dwMinVidThresh1 +=  dwTemp;
                   }
                   if((pConfig->dwFlags & VCFLG_CAP) && (dwVCLK > 40000000ul))
                   {
                        if(dwVCLK > 94000000ul)
                            dwTemp = 120;           //disable capture;
                        else
                            dwTemp = ( dwVCLK - 40006685ul) /1085905ul + 5;
                        dwMinVidThresh1 +=dwTemp;
                    }
                }
                else if( pConfig->uGfxDepth == 24) 
                {
                   if( dwVCLK < 50000000ul)
                       dwMinVidThresh2 -= 5;
                   else      
                       dwMinVidThresh2 -= 18;
                   dwMinVidThresh1 -= 8;
                   if((pConfig->dwFlags & VCFLG_CAP) && (dwVCLK > 94000000ul))
                       dwMinVidThresh2 += 8;

                }
                else  if(pConfig->uGfxDepth == 16)
                {
                   if( (dwVCLK < 100000000ul ) && (dwVCLK > 66000000ul))
                   { 
                        dwTemp =   31ul -  (dwVCLK -60000000ul) / 1968750ul;
                    }
                    else  if( dwVCLK <= 66000000ul)  //after 1024X768 only adjust constantly
                    {  
                       if( dwVCLK < 57000000ul) 
                       { 
                          dwTemp = 0ul;
                          dwMinVidThresh2 += 10ul;
                        }
                        else
                          dwTemp = 5ul;  
                    }
                    if(dwVCLK > 100000000ul)
                    {
                        dwMinVidThresh2 += 40ul;
                        dwMinVidThresh1 += 20ul;
                    }
                    else
                    {
                        dwMinVidThresh2 -= dwTemp;
                        dwMinVidThresh1 -= 8ul;
                    }
                }
                else if(pConfig->uGfxDepth == 8) 
                {
                    if((dwVCLK > 94000000ul) && ( dwScreenWidth >=1152))
                    {
                       if(dwVCLK > 108000000ul) 
                           dwMinVidThresh2 += 10;
                       else
                           dwMinVidThresh2 += 20;
                       dwMinVidThresh1 += 1;
                    }
                    else if( dwVCLK > 64000000ul )
                    {
                        if( dwVCLK > 70000000ul)
                            dwTemp = 25;  
                        else
                            dwTemp = 5;

                        if(pConfig->dwFlags & VCFLG_CAP)
                        {
                            if(dwVCLK < 760000000ul )
                                dwTemp = 0;
                            else if(dwVCLK < 950000000ul)
                                dwTemp -= 10;
                        }
                        dwMinVidThresh2 -= dwTemp;

                        dwMinVidThresh1 -= 15;
                    }
                }
           }
        }    
      }

      //
      // Finish dwMinVidThresh1
      //
      //    ( K * VidDepth * SrcWidth * VCLK   (FIFOWIDTH * DispWidth * MCLK) - 1 )
      // INT( ------------------------------ + ---------------------------------- ) (/ 2) + 1
      //    ( FIFOWIDTH * DispWidth * MCLK        FIFOWIDTH * DispWidth * MCLK    )
      iNumShift = ScaleMultiply(dwMinVidThresh1, (DWORD)pConfig->uSrcDepth,
                                &dwMinVidThresh1);
      iNumShift += ScaleMultiply(dwMinVidThresh1, (DWORD)pConfig->sizSrc.cx,
                                &dwMinVidThresh1);
      iNumShift += ScaleMultiply(dwMinVidThresh1, dwVCLK, &dwMinVidThresh1);

      iDenomShift = ScaleMultiply(FIFOWIDTH, (DWORD)pConfig->sizDisp.cx,
                                  &dwDenom);
      iDenomShift += ScaleMultiply(dwDenom, dwMCLK, &dwDenom);

      if(iNumShift > iDenomShift)
      {
        dwDenom >>= (iNumShift - iDenomShift);
      }
      else
      {
        dwMinVidThresh1 >>= (iDenomShift - iNumShift);
      }

      // Be sure rounding below doesn't overflow (it happened!)
      while((dwMinVidThresh1 + dwDenom - 1ul) < dwMinVidThresh1)
      {
        dwMinVidThresh1 >>= 1;
        dwDenom >>= 1;
      }
      dwMinVidThresh1 += dwDenom - 1ul;

      dwMinVidThresh1 /= dwDenom;

      if(!(pConfig->dwFlags & VCFLG_420))
      {
        // Threshold is programmed in DQWORDS for non-4:2:0
        dwMinVidThresh1 /= 2ul;
      }

      dwMinVidThresh1++;  // Adjust for -2 decrement of FIFO count done to
                          //  synchronize MCLK with faster VCLK.

      //
      // Finish dwMinVidThresh2
      //
      // K * VidDepth * VidWidth * VCLK   (FIFOWIDTH * DispWidth * MCLK) - 1
      // ------------------------------ + ----------------------------------
      // FIFOWIDTH * DispWidth * MCLK        FIFOWIDTH * DispWidth * MCLK
      //
      //   VIDFIFOSIZE
      // - ----------- (/ 2) + 1
      //        2        ^non-4:2:0 only
      iNumShift = ScaleMultiply(dwMinVidThresh2, (DWORD)pConfig->uSrcDepth,
                                &dwMinVidThresh2);
      iNumShift += ScaleMultiply(dwMinVidThresh2, (DWORD)pConfig->sizSrc.cx,
                                &dwMinVidThresh2);

      iNumShift += ScaleMultiply(dwMinVidThresh2, dwVCLK, &dwMinVidThresh2);

      iDenomShift = ScaleMultiply(FIFOWIDTH, (DWORD)pConfig->sizDisp.cx,
                                  &dwDenom);
      iDenomShift += ScaleMultiply(dwDenom, dwMCLK, &dwDenom);

      if(iNumShift > iDenomShift)
      {
        dwDenom >>= (iNumShift - iDenomShift);
      }
      else
      {
        dwMinVidThresh2 >>= (iDenomShift - iNumShift);
      }

      // Be sure rounding below doesn't overflow (it happened!)
      while((dwMinVidThresh2 + dwDenom - 1ul) < dwMinVidThresh2)
      {
        dwMinVidThresh2 >>= 1;
        dwDenom >>= 1;
      }
      dwMinVidThresh2 += dwDenom - 1ul;

      dwMinVidThresh2 /= dwDenom;

      if(dwMinVidThresh2 > (VIDFIFOSIZE /2ul) )
          dwMinVidThresh2 -= (VIDFIFOSIZE / 2ul);
      else
          dwMinVidThresh2 = 0;
        
      if(!(pConfig->dwFlags & VCFLG_420))
      {
        // Threshold is programmed in DQWORDS for non-4:2:0
        dwMinVidThresh2 /= 2ul;
      }

      dwMinVidThresh2++;  // Adjust for -2 decrement of FIFO count done to
                          //  synchronize MCLK with faster VCLK.


    ODS("ChipIsEnoughBandwidth(): Min video thresh1 and 2 = %ld %ld.\n", 
                dwMinVidThresh1, dwMinVidThresh2);

      if(dwMinVidThresh2 > VIDFIFOSIZE -1)
      {
        dwMinVidThresh2 = VIDFIFOSIZE -1;
      }
      //
      // Whichever is higher should be the right one
      //
      dwMinVidThresh = __max(dwMinVidThresh1, dwMinVidThresh2);
    }

    ODS("ChipIsEnoughBandwidth(): Min video thresh = %ld.\n", dwMinVidThresh);

    if(dwMaxVidThresh < dwMinVidThresh)
    {
      ODS("ChipIsEnoughBandwidth(): Minimum video threshold exceeds maximum.\n");
      goto Error;
    }
    //I don't know why, but it need checked for capture. #xc
    if((pConfig->dwFlags & VCFLG_CAP) && (dwMaxVidThresh > 8) 
        && ((pConfig->uGfxDepth != 8) || fConCurrent) && ( f500MHZ || !fConCurrent))
    {
      ODS("ChipIsEnoughBandwidth(): Video threshold exceeds non-aligned safe value.\n");
      goto Error;
    }
    if(pProgRegs)
    {
      if((((pConfig->uGfxDepth == 8) && (dwVCLK > 60000000)) || 
          ((pConfig->uGfxDepth != 8)  && ( dwVCLK > 56000000)) ||
         ( !f500MHZ && fConCurrent)) && !(pConfig->dwFlags & VCFLG_CAP))
        pProgRegs->VW0_FIFO_THRSH = (WORD)dwMaxVidThresh;
      else 
        pProgRegs->VW0_FIFO_THRSH = (WORD)__min( 8, dwMaxVidThresh);
    ODS("ChipIsEnoughBandwidth(): thresh = %ld.\n", pProgRegs->VW0_FIFO_THRSH);
    }
  }
  fSuccess = TRUE;
Error:
  return(fSuccess);
}

#endif // WINNT_VER35




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\bltmm.c ===
/******************************Module*Header*******************************\
*
* $Workfile:   BLTMM.C  $
*
* Contains the low-level memory-mapped IO blt functions.  This module
* mirrors 'bltio.c'.
*
* Hopefully, if you're basing your display driver on this code, to
* support all of DrvBitBlt and DrvCopyBits, you'll only have to implement
* the following routines.  You shouldn't have to modify much in
* 'bitblt.c'.  I've tried to make these routines as few, modular, simple,
* and efficient as I could, while still accelerating as many calls as
* possible that would be cost-effective in terms of performance wins
* versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates
*       that haven't yet had the offscreen bitmap (DFB) offset applied.
*       'Absolute' coordinates have had the offset applied.  For example,
*       we may be told to blt to (1, 1) of the bitmap, but the bitmap may
*       be sitting in offscreen memory starting at coordinate (0, 768) --
*       (1, 1) would be the 'relative' start coordinate, and (1, 769)
*       would be the 'absolute' start coordinate'.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1997 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/BLTMM.C  $
*
*    Rev 1.3   Mar 04 1998 15:11:50   frido
* Added new shadow macros.
*
*    Rev 1.2   Nov 03 1997 11:44:02   frido
* Added REQUIRE macros.
*
\**************************************************************************/

#include "precomp.h"

#define BLTMM_DBG_LEVEL 0

extern BYTE gajRop[];

/******************************Public*Routine******************************\
* VOID vMmFillSolid
*
* Fills a list of rectangles with a solid colour.
*
\**************************************************************************/

VOID vMmFillSolid(              // Type FNFILL
PDEV*     ppdev,
LONG      c,                    // Can't be zero
RECTL*    prcl,                 // List of rectangles to be filled, in relative
                                                //  coordinates
ULONG     ulHwForeMix,  // Hardware mix mode
ULONG     ulHwBackMix,  // Not used
BRUSHOBJ* pbo,          // Drawing colour is pbo->iSolidColor
POINTL*   pptlBrush)    // Not used
{
        ULONG  ulColor;         // color

        ulColor = pbo->iSolidColor;
    switch (ppdev->ulBitCount)
        {
                case 8:
                        ulColor |= ulColor << 8;

                case 16:
                        ulColor |= ulColor << 16;
        }
        REQUIRE(4);
        LL_BGCOLOR(ulColor, 0);
        LL_DRAWBLTDEF((ppdev->uBLTDEF << 16) | ulHwForeMix, 0);

    do
    {
        REQUIRE(5);
        LL_OP0(prcl->left + ppdev->ptlOffset.x, prcl->top + ppdev->ptlOffset.y);
                LL_BLTEXT(prcl->right - prcl->left, prcl->bottom - prcl->top);

        prcl++;
    }
        while (--c != 0);
}

/******************************Public*Routine******************************\
* VOID vMmFillPatFast
*
* This routine uses the S3 pattern hardware to draw a patterned list of
* rectangles.
*
\**************************************************************************/

VOID vMmFillPatFast(            // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           ulHwForeMix,    // Hardware mix mode (foreground mix mode if
                                //   the brush has a mask)
ULONG           ulHwBackMix,    // Not used (unless the brush has a mask, in
                                //   which case it's the background mix mode)
BRUSHOBJ*                pbo,            // pbo
POINTL*         pptlBrush)      // Pattern alignment
{
        ULONG ulBltDef = ppdev->uBLTDEF;

        if (!SetBrush(ppdev, &ulBltDef, pbo, pptlBrush))
        {
                return;
        }

    REQUIRE(2);
    LL_DRAWBLTDEF((ulBltDef << 16) | ulHwForeMix, 2);

    do
    {
                REQUIRE(5);
                LL_OP0(prcl->left + ppdev->ptlOffset.x, prcl->top + ppdev->ptlOffset.y);
                LL_BLTEXT(prcl->right - prcl->left, prcl->bottom - prcl->top);

                prcl++;
    }
    while (--c != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\i386\patblt.asm ===
;===============================================================================
;
;	$Workfile:   PATBLT.ASM  $
;
;	Contents:
;	This file contains the assembly code for the pattern blit routine.
;
;	Copyright (c) 1996, Cirrus Logic, Inc.
;
;	$Log:   X:/log/laguna/nt35/displays/cl546x/i386/PATBLT.ASM  $
; 
;    Rev 1.21   Mar 04 1998 15:45:14   frido
; Added more shadowing.
; 
;    Rev 1.20   Jan 20 1998 11:45:22   frido
; Added shadowing for DRAWBLTDEF and BGCOLOR registers.
; 
;    Rev 1.19   Nov 04 1997 09:26:10   frido
; Fixed a typo (PPDEV into PDEV).
; 
;    Rev 1.18   Nov 03 1997 16:38:56   frido
; Added REQUIRE macros.
; 
;    Rev 1.17   29 Apr 1997 16:29:38   noelv
; Merged in new SWAT code.
; SWAT: 
; SWAT:    Rev 1.4   24 Apr 1997 10:52:56   frido
; SWAT: NT140b09 merge.
; SWAT: 
; SWAT:    Rev 1.3   19 Apr 1997 16:32:18   frido
; SWAT: Added automatic include file dependencies for BUILD.EXE.
; SWAT: Added SWAT.h include file.
; SWAT: 
; SWAT:    Rev 1.2   18 Apr 1997 00:26:12   frido
; SWAT: NT140b07 merge.
; SWAT: 
; SWAT:    Rev 1.1   15 Apr 1997 19:13:42   frido
; SWAT: Added SWAT6: striping in PatBlt.
; 
;    Rev 1.16   08 Apr 1997 11:47:28   einkauf
; 
; add call to SYNC_W_3D for MCD coordination
; 
;    Rev 1.15   21 Mar 1997 10:10:18   noelv
; Synced PDEV between C code and ASM code.
; Added macro to log QFREE data.
; Consolidated do_flag and sw_test_flag into a single pointer_switch flag.
; 
;    Rev 1.14   07 Mar 1997 09:41:56   SueS
; Added NULL_BITBLT flag to assembly code.  Changed order of include files.
; 
;    Rev 1.13   04 Feb 1997 11:57:34   SueS
; Added support for hardware clipping for the 5465.
; 
;    Rev 1.12   26 Nov 1996 11:38:02   bennyn
; Fixed the DSURF save bug
; 
;    Rev 1.11   21 Nov 1996 15:02:40   noelv
; DSURF (in EBX) was getting hammered before call to bCreateScreenFromDib.
; 
;    Rev 1.10   07 Oct 1996 09:51:00   bennyn
; Fixed push/pop worng order bug
; 
;    Rev 1.9   04 Oct 1996 16:47:50   bennyn
; 
; Added DirectDraw YUV support
; 
;    Rev 1.8   22 Aug 1996 18:15:18   noelv
; Frido bug fix release 8-22.
; 
;    Rev 1.2   22 Aug 1996 17:12:52   frido
; #ddblt - Added check for bDirectDrawInUse.
; 
;    Rev 1.1   17 Aug 1996 15:32:14   frido
; #1244 - Fixed brush rotation for off-screen bitmaps.
; 
;    Rev 1.0   14 Aug 1996 17:14:36   frido
; Initial revision.
; 
;    Rev 1.6   01 May 1996 11:06:20   bennyn
; 
; Modified for NT 4.0
; 
;    Rev 1.5   10 Apr 1996 13:39:32   NOELV
; Frido release 27
;       
;          Rev 1.15   08 Apr 1996 16:43:06   frido
;       Changed EngBitBlt into PuntBitBlt.
;       
;          Rev 1.14   29 Feb 1996 22:57:24   frido
;       Added check for destination in ROP and updated grDRAWBLTDEF.
;       
;          Rev 1.13   28 Feb 1996 22:40:18   frido
;       Added Optimize.h.
;       
;          Rev 1.12   27 Feb 1996 16:39:52   frido
;       Added device bitmap store/restore.
;       
;          Rev 1.11   26 Feb 1996 23:39:12   frido
;        
;       
;          Rev 1.10   24 Feb 1996 01:22:52   frido
;       Added device bitmaps.
;       
;          Rev 1.9   17 Feb 1996 21:46:26   frido
;       Revamped brushing algorithmn.
;       
;          Rev 1.8   13 Feb 1996 16:51:36   frido
;       Changed the layout of the PDEV structure.
;       Changed the layout of all brush caches.
;       Changed the number of brush caches.
;       
;          Rev 1.7   10 Feb 1996 21:49:46   frido
;       Split monochrome and colored translation cache.
;       
;          Rev 1.6   08 Feb 1996 00:09:58   frido
;       Added i386\ to include files.
;       Changed meaning of cache_slot index.
;
;	   Rev 1.5   05 Feb 1996 17:35:20   frido
;	Added translation cache.
;  
;	   Rev 1.4   03 Feb 1996 12:21:58   frido
;	Added more delays and checks for FIFOs.
;  
;	   Rev 1.3   31 Jan 1996 17:05:52   frido
;	Added more delays in the complex clipping.
;  
;	   Rev 1.2   31 Jan 1996 13:47:36   frido
;	Jumped to EngBitBlt in case of error.
;	Added comments.
;	Added delay in complex clipping.
;	Fixed bug in rectangle clipping.
;  
;	   Rev 1.1   25 Jan 1996 22:45:56   frido
;	Removed bug in complex clipping.
;  
;	   Rev 1.0   25 Jan 1996 22:03:28   frido
;	Initial release.
;	
;===============================================================================

.386
.MODEL FLAT, STDCALL

OPTION	PROLOGUE:None
OPTION	EPILOGUE:None

.NOLIST
INCLUDE i386\Macros.inc
INCLUDE i386\WinNT.inc
INCLUDE Optimize.h
INCLUDE i386\Laguna.inc
INCLUDE SWAT.h		;SWAT optimizations
COMMENT !		;automatic include file dependencies for BUILD.EXE
#include "i386\Macros.inc"
#include "i386\WinNT.inc"
#include "Optimize.h"
#include "i386\Laguna.inc"
#include "SWAT.h"
!
.LIST

IF USE_ASM

.DATA

IF POINTER_SWITCH_ENABLED
EXTERN pointer_switch: DWORD 
ENDIF

EXTERN		ropFlags:BYTE
ROP_PAT		= 1
ROP_SRC		= 2
ROP_DEST	= 4

.CODE

;-------------------------------------------------------------------------------
; Function prototypes.
;-------------------------------------------------------------------------------
i386BitBlt	PROTO		PROC,
		psoTrg		:DWORD,
		psoSrc		:DWORD,
		psoMask		:DWORD,
		pco		:DWORD,
		pxlo		:DWORD,
		prclTrg		:DWORD,
		pptlSrc		:DWORD,
		pptlMask	:DWORD,
		pbo		:DWORD,
		pptlBrush	:DWORD,
		rop4		:DWORD
PuntBitBlt	PROTO		PROC,
		psoTrg		:DWORD,
		psoSrc		:DWORD,
		psoMask		:DWORD,
		pco		:DWORD,
		pxlo		:DWORD,
		prclTrg		:DWORD,
		pptlSrc		:DWORD,
		pptlMask	:DWORD,
		pbo		:DWORD,
		pptlBrush	:DWORD,
		rop4		:DWORD
CacheBrush	PROTO		PROC,
		ppdev		:DWORD,
		pRbrush		:DWORD
CacheDither	PROTO		PROC,
		ppdev		:DWORD,
		pRbrush		:DWORD
CacheMono	PROTO		PROC,
		ppdev		:DWORD,
		pRbrush		:DWORD
Cache4BPP	PROTO		PROC,
		ppdev		:DWORD,
		pRbrush		:DWORD
bCreateScreenFromDib PROTO	PROC,
		ppdev		:DWORD,
		pdsurf		:DWORD
IF SWAT6
StripePatBlt	PROTO		PROC,
		ppdev		:DWORD,
		x		:DWORD,
		y		:DWORD,
		cWidth		:DWORD,
		cHeight		:DWORD
ENDIF
ifdef WINNT_VER40
Sync_w_3d_proc	PROTO		PROC,
		ppdev		:PTR PDEV
endif

;-------------------------------------------------------------------------------
; Stack frame for DrvBitBlt.
;-------------------------------------------------------------------------------
espPTR		=	0
frmPTR		=	0
psoTrg_		TEXTEQU	<DWORD PTR [esp +  4 + espPTR]>
psoSrc_		TEXTEQU	<DWORD PTR [esp +  8 + espPTR]>
psoMask_	TEXTEQU	<DWORD PTR [esp + 12 + espPTR]>
pco_		TEXTEQU	<DWORD PTR [esp + 16 + espPTR]>
pxlo_		TEXTEQU	<DWORD PTR [esp + 20 + espPTR]>
prclTrg_	TEXTEQU	<DWORD PTR [esp + 24 + espPTR]>
pptlSrc_	TEXTEQU	<DWORD PTR [esp + 28 + espPTR]>
pptlMask_	TEXTEQU	<DWORD PTR [esp + 32 + espPTR]>
pbo_		TEXTEQU	<DWORD PTR [esp + 36 + espPTR]>
pptlBrush_	TEXTEQU <DWORD PTR [esp + 40 + espPTR]>
rop4_		TEXTEQU <DWORD PTR [esp + 44 + espPTR]>

;-------------------------------------------------------------------------------
;
; Function:	DrvBitBlt
;
; Description:	Bit blit entry point for DDI.
;
; On entry:	See Windows NT 3.51 DDK.
;
; Returns:	BOOL - TRUE if the function was successful, FALSE otherwise.
;
; Destroyed:	EAX, ECX, EDX.
;
;-------------------------------------------------------------------------------
DrvBitBlt PROC PUBLIC,
	psoTrg		:DWORD,
	psoSrc		:DWORD,
	psoMask		:DWORD,
	pco		:DWORD,
	pxlo		:DWORD,
	prclTrg		:DWORD,
	pptlSrc		:DWORD,
	pptlMask	:DWORD,
	pbo		:DWORD,
	pptlBrush	:DWORD,
	rop4		:DWORD

IF NULL_BITBLT
	cmp	pointer_switch, 0		; Has the cursor been moved to (0,0)?
	je	NotNull			; No - continue on
	mov	eax, 1			; Make GDI think we succeeded
	ret	44			; Return and release stack frame
NotNull:
ENDIF

	mov	ecx, [psoTrg_]		;get pointer to target device
	ASSUME	ecx:PTR SURFOBJ
	mov	eax, [rop4_]		;get ROP4 code
	push_	esi
	push_	ebp
	push_	ebx
	push_	edi
	test	ecx, ecx		;no target?
	jz	Error			;indeed... pass the blit to GDI
	mov	edi, [ecx].dhpdev	;get pointer to physical device
	ASSUME	edi:PTR PDEV

        ;NVH test for bad PDEV pointer.
        test    edi,edi
        jz      Error
        
        
ifdef WINNT_VER40
;SYNC_W_3D macro equivalent
    cmp [edi].NumMCDContexts, 0 ; is MCD alive?
	jle	Sync_end    			; no
    push    eax                 ; save
    push    ecx                 ; save
    push    edi                 ; input to Sync_w_3d_proc
    call Sync_w_3d_proc         
    pop     ecx                 ; restore
    pop     eax                 ; restore
Sync_end:
endif

        ; Turn_PTAG_on
	test	[edi].DriverData.DrvSemaphore, DRVSEM_YUV_ON	
        jz      no_yuv_screen
        push    ecx
	mov	ecx, [edi].pLgREGS_real	; points to the MMIO registers
	mov	DWORD PTR [ecx + grDRAWBLTDEF], 20002000h
	mov	[edi].shadowDRAWBLTDEF, 20002000h
	mov	WORD PTR [ecx + grPTAG], 0FFFFH
        pop     ecx
no_yuv_screen:

	sub	ah, al			;the ROP must be ternary
	jnz	GoSlow			;not a ternary ROP... use the "C" code
	test	edi, edi		;any physical device?
	jz	GoSlow			;nope... use the "C" code
	test	[ropFlags + eax], ROP_SRC
					;does the ROP need a source?
	mov	ebx, [edi].hsurfEng	;get handle of surface
	jnz	GoSlow			;yes it does... use the "C" code
	cmp	[ecx].hsurf, ebx	;blit to screen?
	mov	ebx, [ecx].dhsurf	;get pointer to device bitmap
	ASSUME	ebx:PTR DSURF
	je	@F			;yes
	cmp	[ecx].iType, STYPE_DEVBITMAP
					;blit to device bitmap?
	jne	GoSlow			;no... use the "C" code

                            ; NVH - Save EBX cause we need it 
    push    ebx             ;     if we call bCreateScreenFromDib
	mov 	ebx, [ebx].pso	; get pointer to DIB
	ASSUME	ebx:PTR SURFOBJ
	or	    ebx, ebx		; do we have a DIB? (Is the bitmap on the host?)
    pop     ebx             ; NVH - Restore EBX.
	ASSUME	ebx:PTR DSURF
	jz	@F			        ; No. Device bitmap is already in the frame buffer.

    ; Move the device bitmap back into the frame buffer.
	push_	eax                     ; Save the rop code.
	INVOKE	bCreateScreenFromDib,	; copy the DIB to off-screen
			edi,    ; PPDEV
			ebx     ; PDSURF
	or	eax, eax                    ; Test for success.
	pop_	eax                     ; Restore the ROP code.
    jz	Simulate	; Failed to move device bitmap into frame buffer.
	save_	1

IF 1 ;#1244
@@:	mov	esi, [psoTrg_]		;get target object
	ASSUME	esi:PTR SURFOBJ
	xor	ecx, ecx		;zero x/y offset
	cmp	[esi].iType, STYPE_DEVBITMAP
	mov	esi, [esi].dhsurf
	jne	@F			;destination is screen
	ASSUME	esi:PTR DSURF
	mov	ecx, [esi].packedXY	;get x/y offset of device bitmap
@@:	mov	[edi].ptlOffset.x, ecx	;store packed x/y coordinate in PDEV
ELSE
@@:
ENDIF
	mov	esi, [pbo_]		;get pointer to brush
	ASSUME	esi:PTR BRUSHOBJ
	mov	cl, [ropFlags + eax]	;get ROP flags
	lea	ebx, [eax + 10000000h]	;EBX holds tne DRAWBLTDEF value
	test	cl, ROP_DEST		;test for destination
	jz	@F			;no destination, keep DRAWBLTDEF
	or	ebx, 01000000h		;set destination as frame buffer
@@:	test	cl, ROP_PAT
	mov	ebp, [edi].pLgREGS_real	;EBP points to the MMIO registers
	jz	DoBlit			;the ROP doesn't need a pattern
	mov	eax, [esi].iSolidColor	;get the solid color from the brush
	cmp	eax, -1			;do we have a solid color?
	jne	SolidColor		;yes...
IF 0 ;#ddblt
	cmp	[edi].bDirectDrawInUse, 0
					;is DirectDraw in use
	jne	Error			;
ENDIF
	mov	eax, [esi].pvRbrush	;get the pointer to the realized brush
	or	eax, eax
	jnz	@F			;the brush is already realized...
	INVOKE	BRUSHOBJ_pvGetRbrush,	;realize the brush
			esi
	or	eax, eax
	jz	Error			;we couldn't realize the brush...
@@:	mov	esi, eax		;ESI holds the pointer to the brush
	ASSUME	esi:PTR RBRUSH
	mov	eax, [esi].iType	;get the brush type
	mov	edx, [esi].cache_slot	;get the cache index for this brush
	mov	ecx, [esi].iUniq	;get the unique value from brush
	cmp	eax, BRUSH_4BPP		;dispatch brush
	jb	MonoBrush		;monochrome brush
	je	XlateBrush		;4-bpp brush
	cmp	eax, BRUSH_DITHER
	je	DitherBrush		;dither brush

;-------------------------------------------------------------------------------
; Load the patterned brush.
;-------------------------------------------------------------------------------
	cmp	[edi].Ctable[edx].brushID, esi
					;is it still the same brush?
	je	BrushIsCached		;yes
	INVOKE	CacheBrush,		;cache the brush into off-screen memory
			edi,
			esi
	jmp	BrushIsCached

;-------------------------------------------------------------------------------
; Load the dithered brush.
;-------------------------------------------------------------------------------
DitherBrush:
	cmp	[edi].Dtable[edx].ulColor, ecx
					;does the color still match?
	je	BrushIsCached		;yes...
	INVOKE	CacheDither,		;cache the brush into off-screen memory
			edi,
			esi
	jmp	BrushIsCached

;-------------------------------------------------------------------------------
; Load the 4-bpp brush.
;-------------------------------------------------------------------------------
XlateBrush:
	cmp	[edi].Xtable[edx].iUniq, ecx
					;does the ID still match?
	je	BrushIsCached		;yes...
	INVOKE	Cache4BPP,		;cache the brush into off-screen memory
			edi,
			esi
	jmp	BrushIsCached

;-------------------------------------------------------------------------------
; Load the monochrome brush.
;-------------------------------------------------------------------------------
MonoBrush:
	cmp	[edi].Mtable[edx].iUniq, ecx
					;does the ID still match?
	je	IsMono			;yes...
	INVOKE	CacheMono,		;cache the brush into off-screen memory
			edi,
			esi
IsMono:
	or	ebx, 000D0000h		;monochrome pattern
	mov	eax, [esi].ulForeColor	;copy brush fore- and background colors
	mov	edx, [esi].ulBackColor
	cmp	[edi].shadowFGCOLOR, eax
	je	@F
	REQUIRE	2, edi
	mov	[ebp + grOP_opFGCOLOR], eax
	mov	[edi].shadowFGCOLOR, eax
@@:	cmp	[edi].shadowBGCOLOR, edx
	je	@F
	REQUIRE	2, edi
	mov	[ebp + grOP_opBGCOLOR], edx
	mov	[edi].shadowBGCOLOR, edx
@@:

BrushIsCached:
	mov	ecx, [pptlBrush_]	;get pointer to brush origin
	ASSUME	ecx:PTR POINTL
	or	ebx, 00090000h		;assume colored pattern
	mov	dl, BYTE PTR [ecx].x	;get the brush x origin
	mov	dh, BYTE PTR [ecx].y	;get the brush y origin
IF 1 ;#1244
	add	dl, BYTE PTR [edi].ptlOffset.x[0]
	add	dh, BYTE PTR [edi].ptlOffset.x[2]
ENDIF
	dec	dl			;convert brush origin -x & 7
	dec	dh
	xor	edx, -1
	mov	eax, [esi].cache_xy	;get the off-screen y position of brush
	and	edx, 0707h
	REQUIRE	3, edi
	mov	[ebp + grOP2_opMRDRAM], eax
	mov	[ebp + grPATOFF], dx	;store brush origin
	jmp	DoBlit

;-------------------------------------------------------------------------------
; Load the solid color for the pattern blit.
;-------------------------------------------------------------------------------
SolidColor:
	cmp	[edi].iBytesPerPixel, 2	;test the number of bytes per pixel
	ja	XlateDone		;larger than 2 (24-bpp or 32-bpp)...
	je	@F
	mov	ah, al			;expand the 8-bpp into AX
@@:	mov	ecx, eax		;expand the 16-bpp into EAX
	shl	eax, 16
	or	eax, ecx
XlateDone:
	or	ebx, 00070000h		;source is solid color
	cmp	[edi].shadowBGCOLOR, eax
	je	@F
	REQUIRE	2, edi
	mov	[ebp + grOP_opBGCOLOR], eax;store the solid color in background
	mov	[edi].shadowBGCOLOR, eax
@@:

;-------------------------------------------------------------------------------
; Perform the blitting.
;-------------------------------------------------------------------------------
DoBlit:
        ; Turn off the PTAG
        cmp     BYTE PTR [rop4_], 5ah
        jnz     no_yuv_in_the_world

	test	[edi].DriverData.DrvSemaphore, DRVSEM_YUV_ON	
        jz      no_yuv_in_the_world

;; v-normmi   ebp already set to MMIO address
;;      push    ecx
;;	mov	ecx, [edi].pLgREGS_real	; points to the MMIO registers
	REQUIRE 3, edi
	mov	DWORD PTR [ebp + grDRAWBLTDEF], 20002000h
	mov	[edi].shadowDRAWBLTDEF, 20002000h
	mov	WORD  PTR [ebp + grPTAG], 0  ;if an xor rubber band, turn off ptag mask
;;      pop     ecx

no_yuv_in_the_world:

IF 1 ;#1244
	mov	ecx, [edi].ptlOffset.x	;get packed x/y offset
ELSE
	mov	edi, [psoTrg_]		;get target object
	ASSUME	edi:PTR SURFOBJ
	xor	ecx, ecx		;zero x/y offset
	cmp	[edi].iType, STYPE_DEVBITMAP
	mov	edi, [edi].dhsurf
	jne	@F			;destination is screen
	ASSUME	edi:PTR DSURF
	mov	ecx, [edi].packedXY	;get x/y offset of device bitmap
@@:
ENDIF
	mov	edx, edi		;store pointer to PDEV
	ASSUME	edx:PTR PDEV
	mov	edi, [prclTrg_]		;get pointer to destination rectangle
	ASSUME	edi:PTR RECTL
	mov	esi, [pco_]		;get pointer to clipping object
	ASSUME	esi:PTR CLIPOBJ
	cmp	[edx].shadowDRAWBLTDEF, ebx
	je	@F
	REQUIRE	2, edx
	mov	[ebp + grDRAWBLTDEF], ebx
	mov	[edx].shadowDRAWBLTDEF, ebx
@@:					;store DRAWBLTDEF register

	or	esi, esi		;any clipping object?
	jz	@F			;no...
	cmp	[esi].iDComplexity, DC_TRIVIAL
					;clipping required?
	jne	TestClip		;yes...
IF SWAT6
@@:	mov	eax, [edi].left		;get coordinates
	mov	ebx, [edi].top
	mov	esi, [edi].right
	mov	edi, [edi].bottom
	sub	esi, eax		;build width/height
	sub	edi, ebx
	mov	ebp, ecx		;split x/y offset into ECX(x) EBP(y)
	and	ecx, 0000FFFFh
	shr	ebp, 16
	add	eax, ecx		;add x/y offset
	add	ebx, ebp
	INVOKE	StripePatBlt, edx, eax, ebx, esi, edi
ELSE
@@:	push_	edx			;push ppdev on stack
	mov	ebx, [edi].top		;EBX = prclTrg->top
	mov	edx, [edi].bottom	;EDX = prclTrg->bottom
	mov	eax, [edi].left		;EAX = prclTrg->left
	sub	edx, ebx		;EDX = bottom - top (height)
	shl	ebx, 16			;EBX = top << 16
	mov	esi, [edi].right	;ESI = prclTrg->right
	shl	edx, 16			;EDX = height << 16
	sub	esi, eax		;ESI = right - left (width)
	or	ebx, eax		;EBX = (top << 16) | left
	or	edx, esi		;EDX = (height << 16) | width
	add	ebx, ecx		;add xyOffset
	pop_	edi			;restore ppdev from stack
	REQUIRE	5, edi
	mov	[ebp + grOP0_opRDRAM], ebx
					;do the blit
	mov	[ebp + grBLTEXT_EX], edx
ENDIF
Done:
	pop	edi
	pop	ebx
	pop	ebp
	pop	esi
	mov	eax, 1
	ret	44

TestClip:
	cmp	[esi].iDComplexity, DC_RECT
					;complex clipping required?
	jne	ComplexClip		;yes...
;-------------------------------------------------------------------------------
; We have a clipped rectangle to check with.
;-------------------------------------------------------------------------------
	push	edx			;store pointer to PDEV on stack
	push	ecx			;store xyOffset on stack
	mov	eax, [edi].left		;EAX = prclTrg->left
	mov	ebx, [edi].top		;EBX = prclTrg->top
	mov	ecx, [edi].right	;ECX = prclTrg->right
	mov	edx, [edi].bottom	;EDX = prclTrg->bottom
	cmp	eax, [esi].rclBounds.left
					;EAX = max(pco->rclBounds.left, left)
	jg	@F
	mov	eax, [esi].rclBounds.left
@@:	cmp	ebx, [esi].rclBounds.top;EBX = max(pco->rclBounds.top, top)
	jg	@F
	mov	ebx, [esi].rclBounds.top
@@:	cmp	ecx, [esi].rclBounds.right
					;ECX = min(pco->rclBounds.right, right)
	jl	@F
	mov	ecx, [esi].rclBounds.right
@@:	cmp	edx, [esi].rclBounds.bottom
					;EDX = min(pco->rclBounds.bottom,
	jl	@F			;	bottom)
	mov	edx, [esi].rclBounds.bottom
@@:	pop	esi			;restore xyOffset from stack
	pop	edi			;restore pointer to PDEV from stack
	sub	ecx, eax		;ECX = right - left (width)
	jle	Done
	sub	edx, ebx		;EDX = bottom - top (height)
	jle	Done
IF SWAT6
	mov	ebp, esi		;split x/y offset into ESI(x) EBP(y)
	and	esi, 0000FFFFh
	shr	ebp, 16
	add	eax, esi		;add x/y offset
	add	ebx, ebp
	INVOKE	StripePatBlt, edi, eax, ebx, ecx, edx
ELSE
	shl	ebx, 16			;EBX = top << 16
	shl	edx, 16			;EDX = height << 16
	or	ebx, eax		;EBX = (top << 16) | left
	or	edx, ecx		;EDX = (height << 16) | width
	add	ebx, esi		;add xyOffset
	REQUIRE	5, edi
	mov	[ebp + grOP0_opRDRAM], ebx
					;do the blit
	mov	[ebp + grBLTEXT_EX], edx
ENDIF ; SWAT6
	pop	edi
	pop	ebx
	pop	ebp
	pop	esi
	mov	eax, 1
	ret	44

;-------------------------------------------------------------------------------
; We have a complex clipping object to check with.
;-------------------------------------------------------------------------------
ComplexClip:
	enter_	<8 + SIZEOF(ENUMRECTS8)>;create stack frame
offset_	TEXTEQU <DWORD PTR [esp + 0 + frmPTR]>
pdev_	TEXTEQU <DWORD PTR [esp + 4 + frmPTR]>
enum_	TEXTEQU	<ENUMRECTS8 PTR [esp + 8 + frmPTR]>
	mov	[pdev_], edx		;store offset to PDEV structure
	mov	[offset_], ecx		;store xyOffset
	INVOKE	CLIPOBJ_cEnumStart,	;start enumeration
			esi,
			0,
			CT_RECTANGLES,
			CD_ANY,
			0
if DRIVER_5465 AND HW_CLIPPING AND (NOT SWAT6)
	;; Set up hardware clipping
	mov	eax, [pdev_]
	REQUIRE 6, eax
	add	ebx, CLIPEN
	cmp	[eax].shadowDRAWBLTDEF, ebx
	jne	@F
	mov	[ebp + grDRAWBLTDEF], ebx; use clipping
	mov	[eax].shadowDRAWBLTDEF, ebx
@@:

	mov	ebx, [edi].top		; ebx = prclTrg->top
	shl	ebx, 16			; 
	add	ebx, [edi].left		; prclTrg->left
	add	ebx, [offset_]		; add xyOffset
	mov	[ebp + grOP0_opRDRAM], ebx

	push	eax
	mov	eax, [edi].bottom
	shl	eax, 16
	add	eax, [edi].right
	add	eax, [offset_]		; add xyOffset
	sub	eax, ebx
	mov	[ebp + grBLTEXT], eax
	pop	eax
endif
MoreComplex:
	lea	ebx, [enum_]		;get a batch of rectangles
	INVOKE	CLIPOBJ_bEnum,
			esi,
			SIZEOF(ENUMRECTS8),
			ebx
	cmp	[enum_]._c, 0		;any rectangles at all?
	je	SkipArray		;no
	push_	esi			;store loop registers
	push_	eax
	lea	esi, [enum_].arcl	;load pointer to rectangles
	ASSUME	esi:PTR RECTL
ArrayLoop:
if DRIVER_5465 AND HW_CLIPPING AND (NOT SWAT6)
	mov	eax, [esi].left		;EAX = prcl->left
	mov	ebx, [esi].top		;EBX = prcl->top
	mov	ecx, [esi].right	;ECX = prcl->right
	mov	edx, [esi].bottom	;EDX = prcl->bottom
else
	mov	eax, [edi].left		;EAX = prclTrg->left
	mov	ebx, [edi].top		;EBX = prclTrg->top
	mov	ecx, [edi].right	;ECX = prclTrg->right
	mov	edx, [edi].bottom	;EDX = prclTrg->bottom
	cmp	eax, [esi].left		;EAX = max(prcl->left, left)
	jg	@F
	mov	eax, [esi].left
@@:	cmp	ebx, [esi].top		;EBX = max(prcl->top, top)
	jg	@F
	mov	ebx, [esi].top
@@:	cmp	ecx, [esi].right	;ECX = min(prcl->right, right)
	jl	@F
	mov	ecx, [esi].right
@@:	cmp	edx, [esi].bottom	;EDX = min(prcl->bottom, bottom)
	jl	@F
	mov	edx, [esi].bottom
endif
@@:	sub	ecx, eax		;ECX = right - left (width)
	jle	SkipClip		;nothing to draw
	sub	edx, ebx		;EDX = bottom - top (height)
	jle	SkipClip		;nothing to draw
IF SWAT6
	push_	edi
	mov	ebp, [offset_]		;get x/y offset
	mov	edi, ebp		;split x/y offset into EBP(x) EDI(y)
	and	ebp, 000FFFFh
	shr	edi, 16
	add	eax, ebp		;add x/y offset
	add	ebx, edi
	mov	edi, [pdev_]		;get pointer to PDEV
	INVOKE	StripePatBlt, edi, eax, ebx, ecx, edx
	pop_	edi
ELSE
	shl	ebx, 16			;EBX = top << 16
	shl	edx, 16			;EDX = height << 16
	or	ebx, eax		;EBX = (top << 16) | left
	or	edx, ecx		;EDX = (height << 16) | width
	mov	eax, [pdev_]		;get offset to PDEV structure
	add	ebx, [offset_]		;add xyOffset
	REQUIRE 5, eax
if DRIVER_5465 AND HW_CLIPPING
	mov	[ebp + grCLIPULE], ebx
	add	edx, ebx
					;do the blit
	mov	[ebp + grCLIPLOR_EX], edx
else
	mov	[ebp + grOP0_opRDRAM], ebx
					;do the blit
	mov	[ebp + grBLTEXT_EX], edx
endif
ENDIF ; SWAT6
SkipClip:
	add	esi, SIZEOF(RECTL)	;next clipping rectangle
	dec	[enum_]._c
	jnz	ArrayLoop
	pop_	eax			;restore loop registers
	pop_	esi
	ASSUME	esi:PTR CLIPOBJ
SkipArray:
	or	eax, eax		;are there more rectangles?
	jnz	MoreComplex		;yes
	leave_	<8 + SIZEOF(ENUMRECTS8)>;clean up stack frame
	pop	edi
	pop	ebx
	pop	ebp
	pop	esi
	mov	eax, 1
	ret	44

;-------------------------------------------------------------------------------
; Pass the bit blit to the "C" code.
;-------------------------------------------------------------------------------
GoSlow:
	pop	edi
	pop	ebx
	pop	ebp
	pop	esi
	jmp	i386BitBlt

;-------------------------------------------------------------------------------
; Pass the bit blit to the engine since we can't handle it.
;-------------------------------------------------------------------------------
Simulate:
	load_	1
	mov 	ebx, [ebx].pso	; get pointer to DIB
	mov	[psoTrg_], ebx		;store the new DIB surface

;-------------------------------------------------------------------------------
; Pass the bit blit to the engine since we can't handle it.
;-------------------------------------------------------------------------------
Error:
	pop	edi
	pop	ebx
	pop	ebp
	pop	esi
	jmp	PuntBitBlt

DrvBitBlt ENDP


;*****************************************************************************
;------ YUVBLT ---------------------------------------------------------------
;*****************************************************************************
; pmBLTDEF contents
BD_op2		equ	0001h	; start of OP2 field
BD_op1		equ	0010h	; start of OP1 field
BD_op0		equ	0100h	; start of OP0 field
BD_same		equ	0800h	; OP1/OP2 use same data if set
BD_res		equ	1000h	; start of RES field
BD_ydir		equ	8000h	; y direction bit

; field values for BD_opN, BD_res.
; example:
;	WRITE2	pmBLTDEF,(BD_op1*is_host_mono)+(BD_op2*(is_vram+is_pattern))+(BD_res*is_vram)

is_vram			equ	1
is_host			equ	2	; not for BD_op0
	; for BD_opN
is_sram			equ	0
	; for BD_op1/2
is_sram_mono		equ	4
is_vram_mono		equ	5
is_host_mono		equ	6
is_solid		equ	7
is_pattern		equ	8
	; for BD_res
is_sram0		equ	4
is_sram1		equ	5
is_sram2		equ	6
is_sram12		equ	7
is_mono			equ	4	; already part of is_XXXX_mono above


push_1	MACRO	vArg:REQ
	push	vArg
YUVespPTR = YUVespPTR + 4
YUVfrmPTR = YUVfrmPTR + 4
	ENDM

pop_1	MACRO	vArg:REQ
	pop	vArg
YUVespPTR = YUVespPTR - 4
YUVfrmPTR = YUVfrmPTR - 4
	ENDM

enter_1	MACRO	vArg:REQ
	sub	esp, vArg
YUVespPTR = YUVespPTR + vArg
YUVfrmPTR = 0
	ENDM

leave_1	MACRO	vArg:REQ
	add	esp, vArg
YUVespPTR = YUVespPTR - vArg
	ENDM

;-------------------------------------------------------------------------------
; Stack frame for YUVBlt.
;-------------------------------------------------------------------------------
YUVespPTR   	=	0
YUVfrmPTR   	=	0
YUVpsoTrg_	TEXTEQU	<DWORD PTR [esp +  4 + YUVespPTR]>
YUVpsoSrc_	TEXTEQU	<DWORD PTR [esp +  8 + YUVespPTR]>
YUVpco_		TEXTEQU	<DWORD PTR [esp + 12 + YUVespPTR]>
YUVpxlo_	TEXTEQU	<DWORD PTR [esp + 16 + YUVespPTR]>
YUVprclTrg_	TEXTEQU	<DWORD PTR [esp + 20 + YUVespPTR]>
YUVpptlSrc_	TEXTEQU	<DWORD PTR [esp + 24 + YUVespPTR]>


;-------------------------------------------------------------------------------
;
; Function:	YUVBlt
;
; Description:	Check and perform the YUV BLT
;
; Returns:	BOOL - TRUE if YUV BLT was successful, FALSE otherwise.
;
;-------------------------------------------------------------------------------
YUVBlt PROC PUBLIC,
	YUVpsoTrg	:DWORD,
	YUVpsoSrc	:DWORD,
	YUVpco		:DWORD,
	YUVpxlo		:DWORD,
	YUVprclTrg	:DWORD,
	YUVpptlSrc	:DWORD

        ;-----------------------------------------------------------
        ; Get the PDEV associated with the destination.
	mov	ecx, [YUVpsoTrg_] 	;get pointer to target device
	ASSUME	ecx:PTR SURFOBJ
	test	ecx, ecx		;no source?
        jz      Gen_blt

	mov	ecx, [ecx].dhpdev	;get pointer to physical device
        test    ecx, ecx
        jnz     yuv_blt_str

	mov	ecx, [YUVpsoSrc_] 	;get pointer to source device
	test	ecx, ecx		;no source?
        jz      Gen_blt

	mov	ecx, [ecx].dhpdev	;get pointer to physical device
        test    ecx, ecx
        jz      Gen_blt

        ;-----------------------------------------------------------
        ; Check the source is the frame buffer.
        ; (YUVpsoSrc != NULL) &&                 // Is there a source?
        ; (psoSrc->hsurf == ppdev->hsurfEng)  // Is it the screen?
        ;
yuv_blt_str:
	ASSUME	ecx:PTR PDEV
        mov     edx, ecx
	ASSUME	edx:PTR PDEV

        ; Turn PTAG on
	test	[ecx].DriverData.DrvSemaphore, DRVSEM_YUV_ON	
        jz      yuv_blt_str_1
        push    ecx
	mov	ecx, [ecx].pLgREGS_real	; points to the MMIO registers


;; v-normmi: REQUIRE defaults to ebp for LgREGS, need to specify ecx explicitly
;;	REQUIRE 3, edx
	REQUIRE 3, edx, ecx
	cmp	[edx].shadowDRAWBLTDEF, 20002000h
	je	@F
	mov	DWORD PTR [ecx + grDRAWBLTDEF], 20002000h
	mov	[edx].shadowDRAWBLTDEF, 20002000h
@@:	mov	WORD PTR [ecx + grPTAG], 0FFFFH
        pop     ecx
yuv_blt_str_1:

        ; Determine whether is screen to screen BLT
	mov	eax, [ecx].hsurfEng	;get handle of surface

	mov	ecx, [YUVpsoSrc_] 	;get pointer to source device
	ASSUME	ecx:PTR SURFOBJ
	test	ecx, ecx		;no source?
        jz      Gen_blt

	cmp	[ecx].hsurf, eax	;blit to screen?
        jne     Gen_blt

        ;-----------------------------------------------------------
        ; Check the destination is the frame buffer.
        ; (psoDest != NULL) &&                 // Is there a dest?
        ; (psoDest->hsurf == ppdev->hsurfEng)  // Is it the screen?
	mov	ecx, [YUVpsoTrg_] 	;get pointer to target device
	ASSUME	ecx:PTR SURFOBJ
	test	ecx, ecx		;no source?
        jz      Gen_blt

	cmp	[ecx].hsurf, eax	;blit to screen?
        je      DevBlt_s2s_YUV_Window

Gen_blt:
        mov     eax, 0
        ret     24

;------------------------------------------------------------------------
; DEVBLT_S2S_YUV_WINDOW
;
; A yuv-ly code block to perform a laguna mixed frame buffer window blt.
;
ESPOFFSET       equ     28

DevBlt_s2s_YUV_Window:

	enter_1	<ESPOFFSET>  ;create stack frame
        push_1  ebp
        mov     ebp, esp

        push_1  ebx
        push_1  edi
        push_1  esi

LocptrPDEV_     TEXTEQU <DWORD PTR [ebp + 4]>
LocSrcxOrg_     TEXTEQU <WORD  PTR [ebp + 8]>
LocSrcyOrg_     TEXTEQU <WORD  PTR [ebp + 10]>
LocSrcxExt_     TEXTEQU <WORD  PTR [ebp + 12]>
LocSrcyExt_     TEXTEQU <WORD  PTR [ebp + 14]>
LocYUVLeft_     TEXTEQU <WORD  PTR [ebp + 16]>
LocYUVTop_      TEXTEQU <WORD  PTR [ebp + 18]>
LocYUVXExt_     TEXTEQU <WORD  PTR [ebp + 20]>
LocYUVYExt_     TEXTEQU <WORD  PTR [ebp + 22]>
LocDstxOrg_     TEXTEQU <WORD  PTR [ebp + 24]>
LocDstyOrg_     TEXTEQU <WORD  PTR [ebp + 26]>

        ;Save the argument pointers into local variables
        mov     edi, edx
	ASSUME	edi:PTR PDEV

        mov     [LocptrPDEV_], edi

        ;-----------------------------------------------------------
        ; Test SRC rectange included the YUV rectange
	mov	ecx, [YUVpptlSrc_]	;get pointer to src POINTER struct
	ASSUME	ecx:PTR POINTL
        mov     edx, [ecx].x
        mov     [LocSrcxOrg_], dx
        shl     edx, 16
        mov     eax, [ecx].y
        mov     [LocSrcyOrg_], ax
        mov     dx, ax

        push_1  edx                     ;save the src org

	mov	ecx, [YUVprclTrg_] 	;get pointer to dst RECTL struct
	ASSUME	ecx:PTR RECTL
        mov     eax, [ecx].bottom
        mov     edx, [ecx].top
        mov     [LocDstyOrg_], dx
        sub     eax, edx
        mov     [LocSrcyExt_], ax
        shl     eax, 16
        mov     ebx, eax
        mov     eax, [ecx].right
        mov     edx, [ecx].left
        mov     [LocDstxOrg_], dx
        sub     eax, edx
        mov     [LocSrcxExt_], ax
        mov     bx, ax
        push_1  ebx                     ;save the XY extend

        ;get coords for last known YUV rectangle
        mov     edi, [LocptrPDEV_]
	ASSUME	edi:PTR PDEV

	mov	cx, [edi].DriverData.YUVLeft
        mov     [LocYUVLeft_], cx
	shl	ecx, 16
	mov	cx, [edi].DriverData.YUVTop
        mov     [LocYUVTop_], cx

	mov	dx, [edi].DriverData.YUVYExt
        mov     [LocYUVYExt_], dx
	shl	edx, 16		     	;get yuv extents, x low (for later...)
	mov	dx, [edi].DriverData.YUVXExt
        mov     [LocYUVXExt_], dx

        pop_1   ebx
        pop_1   eax

        ; At this point eax = SRC org, ebx = SRC extend
        ;               ecx = YUV org, edx = YUV extend

	;test for invalidated yuv rectangle...
	test	edx, edx
	jz	normalBLT		;all zero indicates invalid rectangle	

	cmp	ax, cx
	jge	normalBLT		;checked top
	rol	eax, 16
	rol	ecx, 16
	cmp	ax, cx
	jge	normalBLT		;checked left, x values now low

	add	eax, ebx    		;now we have right/bottom sides,
	add	ecx, edx    		;with the x values low
	
	cmp	ax, cx
	jle	normalBLT
	rol	eax, 16
	rol	ecx, 16
	cmp	ax, cx
	jle	normalBLT

        ; Okay... it's time for the show.  We have now established that:
        ; 1 - It's an onscreen to onscreen blt.
        ; 2 - The last YUV rectangle drawn by Direct Draw is completely inside
        ;     of the source rectangle.
        ; 3 - The last YUV rectangle is valid.
        ;
        ; We're going to do seven blts:
        ; 
        ; Five are shown here:
        ;
        ;  --5--
        ;  |   |
        ;  4 3 1
        ;  |   |
        ;  --2--
        ;
        ; Region 3 is the YUV area.
        ;
        ; The two extra blts are dummy ones around the YUV blt, to prevent
        ; screen corruption on the last packets of the surrounding blts.	
        ;
        ; There are four movement cases, depending on the movement direction.
        ; Because the rectangle is broken into five blts, I'm going to
        ; "lead with a corner."
        ; Up and to the right would result in an order of:   5-1-dummy-3-dummy-4-2
        ; Down and to the right would result in an order of: 2-1-dummy-3-dummy-4-5
        ; Down and to the left would result in an order of:  2-4-dummy-3-dummy-1-5
        ; Up and to the left would result in an order of:    5-4-dummy-3-dummy-1-2

        ; make the drawbltdef...
	mov	edi, 00cch + \
        	     ((BD_op0*is_vram+BD_op1*is_vram+BD_res*is_vram) shl 16)

        ; Determine the case, then push the necessary jump offsets on the stack,
        ; in reverse order...	
	push	YUV_exit            	;jump address for when we are done

        mov     ax, [LocSrcxOrg_]            ;get coords for src rect
        shl     eax, 16	
        mov     ax, [LocSrcyOrg_]

        mov     cx, [LocDstxOrg_]            ;get coords for dst rect
        shl     ecx, 16	
        mov     cx, [LocDstyOrg_]

	mov	esi, ecx
	sub	esi, eax 		;get delta from src to dest, useful later.

	cmp	ax, cx
	jle	YUV_going_down

	push	YUV_blt_two	;going up
	mov	ebx, YUV_blt_five
	jmp	YUV_check_left_right

YUV_going_down:
	push	YUV_blt_five	;going down
	mov	ebx, YUV_blt_two	
	or	edi, 80000000h		;turn on blt upside-down-ness

YUV_check_left_right:			;okay, we've handled up/down, how about left/right?
	rol	eax, 16
	rol	ecx, 16
	cmp	ax, cx
	jl	YUV_going_right

	push	YUV_blt_one	;going left
	mov	edx, YUV_blt_four
	jmp	YUV_finish_offsets

YUV_going_right:
	push	YUV_blt_four	 ;going right
	mov	edx, YUV_blt_one

YUV_finish_offsets:
	push	YUV_blt_three
	push	edx	;blt four or one, whichever isn't already on the stack

;no need to add pdevice origins... it's onscreen, eh?

;right now, level cases have the y_dir bit turned on.  if it's a move-left, we need to turn
;it off, so that we don't wind up in the striping code.
	test	edi, 80000000h
	jz	YUV_go_do_it

	rol	eax, 16
	rol	ecx, 16
	cmp	ax, cx
	jnz	YUV_go_do_it	;it's not a perfectly level move...
	
	rol	eax, 16
	rol	ecx, 16
	cmp	ax, cx
	jl	YUV_go_do_it	;if to the right, leave it on.
	and	edi, 7fffffffh	;level move to the left.		

YUV_go_do_it:
	jmp	ebx	;blt two or five, let's rock and roll!

YUV_blt_one:
;src x prime:  yuv left + yuv xext
;src y prime:  yuv top
;x ext prime:  (src x + xext) - (yuv left + yuv xext)
;y ext prime:  yuv yext

	mov	ax, [LocYUVLeft_]
	add	ax, [LocYUVXExt_]
	shl	eax, 16
	mov	ax, [LocYUVTop_] ;source point, y low

        mov	ecx, eax
	add	ecx, esi	;dest point, y low

	mov	dx,  [LocYUVYExt_]
	shl	edx, 16
	mov	dx, [LocSrcxOrg_]    
	add	dx, [LocSrcxExt_]  ;(src x + xext)
	mov	bx, [LocYUVLeft_]
	add	bx, [LocYUVXExt_]  ;(yuv left + yuv xext)
	sub	dx, bx		 ;x ext prime
	jz	yuv_one_done	 ;no right rgb rect, off screen edge

	test	edi, 80000000h	 ;are we in upside down mode?
	jz	@f
	mov	ebx, edx
	rol	ebx, 16		 ;get y extent
	dec	bx
	add	ax, bx
	add	cx, bx		 ;bump srcy prime and desty prime by yext-1
@@:
	cmp	ax, cx
	jnz	@f
	test	edi, 80000000h
	jnz	YUV_i_really_hate_level_moves_to_the_right
@@:
	rol	eax, 16
	rol	ecx, 16

        push	esi
	push	ebp
        mov     esi, [LocptrPDEV_] 
	ASSUME	esi:PTR PDEV
	mov	ebp, [esi].pLgREGS_real	; points to the MMIO registers

	REQUIRE	9, esi
	cmp	[esi].shadowDRAWBLTDEF, edi
	je	@F
	mov	DWORD PTR [ebp + grDRAWBLTDEF], edi
	mov	[esi].shadowDRAWBLTDEF, edi
@@:	mov	DWORD PTR [ebp + grOP0_opRDRAM], ecx
	mov	DWORD PTR [ebp + grOP1_opRDRAM], eax
	mov	DWORD PTR [ebp + grBLTEXT_EX], edx
	pop	ebp
        pop     esi

yuv_one_done:
	pop	eax
	jmp	eax		 ;boing!	

YUV_blt_two:
;src x prime:  known
;src y prime:  yuv top + yuv yext
;x ext prime:  known
;y ext prime:  (src y + yext) - (yuv top + yuv yext)

	mov	ax, [LocSrcxOrg_]
	shl	eax, 16
	mov	ax, [LocYUVTop_]
	add	ax, [LocYUVYExt_] ;source point, y low

	mov	ecx, eax
	add	ecx, esi	 ;dest point, y low

	mov	dx, [LocSrcyOrg_]
	add	dx, [LocSrcyExt_]  ;(src y + yext)
	mov	bx, [LocYUVTop_]
	add	bx, [LocYUVYExt_]  ;(yuv top + yuv yext)
	sub	dx, bx		 ;y ext prime
	jz	yuv_two_done	 ;no bottom rgb rect, off screen
	shl	edx, 16
	mov	dx, [LocSrcxExt_] ;extents, x low

	test	edi, 80000000h	 ;are we in upside down mode?
	jz	@f
	mov	ebx, edx
	rol	ebx, 16		 ;get y extent
	dec	bx
	add	ax, bx
	add	cx, bx			;bump srcy prime and desty prime by yext-1
@@:
	cmp	ax, cx
	jnz	@f
	test	edi, 80000000h
	jnz	YUV_i_really_hate_level_moves_to_the_right
@@:
	rol	eax, 16
	rol	ecx, 16

        push    esi
	push	ebp
        mov     esi, [LocptrPDEV_] 
	ASSUME	esi:PTR PDEV
	mov	ebp, [esi].pLgREGS_real	; points to the MMIO registers

	REQUIRE 9, esi
	cmp	[esi].shadowDRAWBLTDEF, edi
	je	@F
	mov	DWORD PTR [ebp + grDRAWBLTDEF], edi
	mov	[esi].shadowDRAWBLTDEF, edi
@@:	mov	DWORD PTR [ebp + grOP0_opRDRAM], ecx
	mov	DWORD PTR [ebp + grOP1_opRDRAM], eax
	mov	DWORD PTR [ebp + grBLTEXT_EX], edx
	pop	ebp
        pop     esi

yuv_two_done:
	pop	eax
	jmp	eax			;boing!	

YUV_blt_three:                          ;the YUV blt itself...
;just use the yuv coords

;YUV_blt_dummy_off

	mov	ebx, 400000CCh		;bogus move from rdram to sram

        push    esi
	push	ebp
        mov     esi, [LocptrPDEV_] 
	ASSUME	esi:PTR PDEV
	mov	ebp, [esi].pLgREGS_real	;points to the MMIO registers

	REQUIRE	5, esi
	cmp	[esi].shadowDRAWBLTDEF, edi
	je	@F
	mov	DWORD PTR [ebp + grDRAWBLTDEF], edi
	mov	[esi].shadowDRAWBLTDEF, edi
@@:	mov	DWORD PTR [ebp + grBLTEXT_EX], 00010001h
	pop	ebp
        pop     esi

;------

	mov	ax, [LocYUVLeft_]
	shl	eax, 16
	mov	ax, [LocYUVTop_] ;y low

	mov	ecx, eax
	add	ecx, esi	;dest, y low

	mov	dx, [LocYUVYExt_]
	shl	edx, 16
	mov	dx, [LocYUVXExt_]  ;extents, x lot

	test	edi, 80000000h	;are we in upside down mode?
	jz	@f
	mov	ebx, edx
	rol	ebx, 16		;get y extent
	dec	bx
	add	ax, bx
	add	cx, bx		;bump srcy prime and desty prime by yext-1
@@:
	rol	eax, 16
	rol	ecx, 16

	mov	ebx, edi
	or	ebx, 0400h	;do that funky 9th bit thing.

        push    esi
	push	ebp
        mov     esi, [LocptrPDEV_] 
	ASSUME	esi:PTR PDEV
	mov	ebp, [esi].pLgREGS_real	;points to the MMIO registers

	REQUIRE 9, esi
	cmp	[esi].shadowDRAWBLTDEF, ebx
	je	@F
	mov	DWORD PTR [ebp + grDRAWBLTDEF], ebx
	mov	[esi].shadowDRAWBLTDEF, ebx
@@:	mov	DWORD PTR [ebp + grOP0_opRDRAM], ecx
	mov	DWORD PTR [ebp + grOP1_opRDRAM], eax
	mov	DWORD PTR [ebp + grBLTEXT_EX], edx
	pop	ebp
        pop     esi

;YUV_blt_dummy_on

	mov	ebx, 400004CCh		;bogus move from rdram to sram

        push    esi
	push	ebp
        mov     esi, [LocptrPDEV_] 
	ASSUME	esi:PTR PDEV
	mov	ebp, [esi].pLgREGS_real	;points to the MMIO registers

	REQUIRE 5, esi
	cmp	[esi].shadowDRAWBLTDEF, edi
	je	@F
	mov	DWORD PTR [ebp + grDRAWBLTDEF], edi
	mov	[esi].shadowDRAWBLTDEF, edi
@@:	mov	DWORD PTR [ebp + grBLTEXT_EX], 00010001h
	pop	ebp
        pop     esi

;------

	pop	eax
	jmp	eax			;boing!	

YUV_blt_four:
;src x prime:  known
;src y prime:  yuv top
;x ext prime:  yuv left - src x
;y ext prime:  yuv yext

	mov	ax, [LocSrcxOrg_]
	shl	eax, 16
	mov	ax, [LocYUVTop_] ;source point, y low

	mov	ecx, eax
	add	ecx, esi	;dest point, y low

	mov	dx, [LocYUVYExt_]
	shl	edx, 16
	mov	dx, [LocYUVLeft_]
	sub	dx, [LocSrcxOrg_]  ;extents, x low
	jz	yuv_four_done	 ;no left rgb rect, off screen edge

	test	edi, 80000000h	 ;are we in upside down mode?
	jz	@f
	mov	ebx, edx
	rol	ebx, 16		 ;get y extent
	dec	bx
	add	ax, bx
	add	cx, bx		 ;bump srcy prime and desty prime by yext-1
@@:
	cmp	ax, cx
	jnz	@f
	test	edi, 80000000h
	jnz	YUV_i_really_hate_level_moves_to_the_right
@@:
	rol	eax, 16
	rol	ecx, 16

        push    esi
	push	ebp
        mov     esi, [LocptrPDEV_] 
	ASSUME	esi:PTR PDEV
	mov	ebp, [esi].pLgREGS_real	;points to the MMIO registers

	REQUIRE 9, esi
	cmp	[esi].shadowDRAWBLTDEF, edi
	je	@F
	mov	DWORD PTR [ebp + grDRAWBLTDEF], edi
	mov	[esi].shadowDRAWBLTDEF, edi
@@:	mov	DWORD PTR [ebp + grOP0_opRDRAM], ecx
	mov	DWORD PTR [ebp + grOP1_opRDRAM], eax
	mov	DWORD PTR [ebp + grBLTEXT_EX], edx
	pop	ebp
        pop     esi

yuv_four_done:
	pop	eax
	jmp	eax		 ;boing!	

YUV_blt_five:
;src xy prime:  known
;x ext prime :  known
;y ext prime :  yuv top - src top

        mov     ax, [LocSrcxOrg_]      ;;source point, y low
        shl     eax, 16	
        mov     ax, [LocSrcyOrg_]

	mov	ecx, eax
	add	ecx, esi		;dest point, y low

	mov	dx, [LocYUVTop_]
	sub	dx, word ptr [LocSrcyOrg_]
	shl	edx, 16
	mov	dx, [LocSrcxExt_]	;x low

	test	edi, 80000000h		;are we in upside down mode?
	jz	@f
	mov	ebx, edx
	rol	ebx, 16			;get y extent
	dec	bx
	add	ax, bx
	add	cx, bx			;bump srcy prime and desty prime by yext-1
@@:
	cmp	ax, cx
	jnz	@f
	test	edi, 80000000h
	jnz	YUV_i_really_hate_level_moves_to_the_right
@@:
	rol	eax, 16
	rol	ecx, 16

        push    esi
	push	ebp
        mov     esi, [LocptrPDEV_] 
	ASSUME	esi:PTR PDEV
	mov	ebp, [esi].pLgREGS_real	;points to the MMIO registers

	REQUIRE 9, esi
	cmp	[esi].shadowDRAWBLTDEF, edi
	je	@F
	mov	DWORD PTR [ebp + grDRAWBLTDEF], edi
	mov	[esi].shadowDRAWBLTDEF, edi
@@:	mov	DWORD PTR [ebp + grOP0_opRDRAM], ecx
	mov	DWORD PTR [ebp + grOP1_opRDRAM], eax
	mov	DWORD PTR [ebp + grBLTEXT_EX], edx
	pop	ebp
        pop     esi

	pop	eax
	jmp	eax			;boing!	

YUV_i_really_hate_level_moves_to_the_right:

        push    esi
	push	ebp
        mov     esi, [LocptrPDEV_] 
	ASSUME	esi:PTR PDEV
	mov	ebp, [esi].pLgREGS_real	;points to the MMIO registers

	cmp	[esi].shadowDRAWBLTDEF, edi
	je	@F
	REQUIRE 2, esi
	mov	DWORD PTR [ebp + grDRAWBLTDEF], edi
	mov	[esi].shadowDRAWBLTDEF, edi
@@:	pop	ebp
        pop     esi

	; now get ready for inner loop. shift x-coordinates into place

	mov	ebx, ecx
	rol	ebx, 16			;dest, x low

	mov	ecx, eax
	rol	ecx, 16			;src, x low

	; translate the x coordinates

	add	bx, dx
	add	cx, dx

	mov	eax, edx

        ; Because in Win95 LG_SRAM_PIXELS has difference values depends on
        ; the pixel depth.
        ;     LG_SRAM_PIXELS:   32bpp    30
        ;                       24bpp    40
        ;                       16bpp    60
        ;                        8bpp   120
        ;
        ; The following code is the equivalent to
        ;    mov  ax, LG_SRAM_PIXELS	; make it wide as possible
        push    esi
        mov     esi, [LocptrPDEV_] 
	ASSUME	esi:PTR PDEV
	mov	esi, [esi].iBytesPerPixel
        mov     ax, 30
        cmp     esi, 4
        je      got_LG_SRAM_PIXELS
        mov     ax, 40
        cmp     esi, 3
        je      got_LG_SRAM_PIXELS
        mov     ax, 60
        cmp     esi, 2
        je      got_LG_SRAM_PIXELS
        mov     ax, 120
got_LG_SRAM_PIXELS:
        pop     esi

;	mov	ax, LG_SRAM_PIXELS	; make it wide as possible

align   2
YUV_STRIPE_loop:
	cmp	ax, dx			; wider than blit?
	jle	@f			; no, use the actual width
	mov	ax, dx			; load remaining width
@@:
	sub	cx, ax			; offset srcX by width
	sub	bx, ax			; offset dstX by width

        push    esi
	push	ebp
        mov     esi, [LocptrPDEV_] 
	ASSUME	esi:PTR PDEV
	mov	ebp, [esi].pLgREGS_real	;points to the MMIO registers

	REQUIRE 7, esi
	mov	DWORD PTR [ebp + grOP0_opRDRAM], ebx
	mov	DWORD PTR [ebp + grOP1_opRDRAM], ecx
	mov	DWORD PTR [ebp + grBLTEXT_EX], eax
	pop	ebp
        pop     esi

	sub	dx, ax			; update remaining width count
	jnz	YUV_STRIPE_loop		; any pixels left?

	pop	eax
	jmp	eax			; boing!

YUV_exit:

; Good has triumphed over evil... the mixed mode window has moved without flickering.

; We need to update the YUV rectangle location.  It just moved, right?  

	mov	ax, [LocYUVLeft_]
	shl	eax, 16
	mov	ax, [LocYUVTop_]	;source, y low

	add	eax, esi		;dest, y low

        mov     edi, [LocptrPDEV_] 
	mov	[edi].DriverData.YUVTop, ax
	rol	eax, 16
        mov	[edi].DriverData.YUVLeft, ax   	;all better.

        mov     eax, 1                  ; indicate it is YUV exit
        jmp     YUV_ret

normalBLT:
        ; But before we go... invalidate the yuv rect!
        mov     edi, [LocptrPDEV_] 
	mov	[edi].DriverData.YUVXExt, word ptr 0
	mov	[edi].DriverData.YUVYExt, word ptr 0

        mov     eax, 0           ; indicate it is normalBLT

YUV_ret:
        pop_1   esi
        pop_1   edi
        pop_1   ebx
        pop_1   ebp
	leave_1	<ESPOFFSET>      ;clean up stack frame
	ret	24               ;we're done.  it's time to go home.

YUVBlt ENDP

ENDIF ; USE_ASM

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\i386\macros.inc ===
;===============================================================================
;
;	$Workfile:   MACROS.INC  $
;
;	Contents:
;	Several macros to track the stack status.
;
;	Copyright (c) 1996, Cirrus Logic, Inc.
;
;	$Log:   X:/log/laguna/nt35/displays/cl546x/i386/MACROS.INC  $
; 
;    Rev 1.5   20 Aug 1996 11:29:02   noelv
; Bugfix release from Frido 8-19-96
; 
;    Rev 1.0   14 Aug 1996 17:14:36   frido
; Initial revision.
; 
;    Rev 1.4   04 Apr 1996 13:22:24   noelv
; Frido version 26
;	
;	   Rev 1.2   30 Jan 1996 21:49:52   frido
;	Added OPTION switches for all .ASM files to disable MASM 5.1 compatibility.
;	
;	   Rev 1.1   25 Jan 1996 12:43:08   frido
;	Added more stack tracing macros.
;	
;	   Rev 1.0   24 Jan 1996 23:13:42   frido
;	 Initial release.
;
;===============================================================================

OPTION	NOM510
OPTION	CASEMAP:NONE
OPTION	NODOTNAME
OPTION	NOOLDMACROS
OPTION	NOOLDSTRUCTS
OPTION	SCOPED
OPTION	EXPR32
OPTION	LJMP

push_	MACRO	vArg:REQ
	push	vArg
espPTR = espPTR + 4
frmPTR = frmPTR + 4
	ENDM

pop_	MACRO	vArg:REQ
	pop	vArg
espPTR = espPTR - 4
frmPTR = frmPTR - 4
	ENDM

enter_	MACRO	vArg:REQ
	sub	esp, vArg
espPTR = espPTR + vArg
frmPTR = 0
	ENDM

leave_	MACRO	vArg:REQ
	add	esp, vArg
espPTR = espPTR - vArg
	ENDM

save_	MACRO	n:REQ
espPTR_&n = espPTR
frmPTR_&n = frmPTR
	ENDM

load_	MACRO	n:REQ
espPTR = espPTR_&n
frmPTR = frmPTR_&n
	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\i386\winnt.inc ===
;===============================================================================
;
;	$Workfile:   WINNT.INC  $
;
;	Contents:
;	This include file contains the standard Windows NT structures used by
;	the display driver.
;
;	Copyright (c) 1996, Cirrus Logic, Inc.
;
;	$Log:   X:/log/laguna/nt35/displays/cl546x/i386/WINNT.INC  $
; 
;    Rev 1.6   20 Aug 1996 11:29:04   noelv
; Bugfix release from Frido 8-19-96
; 
;    Rev 1.0   14 Aug 1996 17:14:40   frido
; Initial revision.
; 
;    Rev 1.5   01 May 1996 11:07:06   bennyn
; 
; Modified for NT 4.0
; 
;    Rev 1.4   04 Apr 1996 13:22:26   noelv
; Frido version 26
;	
;	   Rev 1.4   10 Feb 1996 21:47:18   frido
;	Added debugging routines.
;	
;	   Rev 1.3   08 Feb 1996 00:10:52   frido
;	Added more objects from WinDDI.h.
;	Reordered objects.
;	
;	   Rev 1.2   25 Jan 1996 22:03:46   frido
;	Yes, added some more stuff.
;	
;	   Rev 1.1   25 Jan 1996 12:45:04   frido
;	Added some more functon prototypes.
;	
;	   Rev 1.0   24 Jan 1996 23:13:44   frido
;	 Initial release.
;
;===============================================================================

UINT			TYPEDEF		DWORD
LONG			TYPEDEF		SDWORD
ULONG			TYPEDEF		DWORD
PBYTE			TYPEDEF		PTR BYTE
FLONG			TYPEDEF		LONG
BOOL			TYPEDEF		SDWORD
PVOID			TYPEDEF		PTR
HANDLE			TYPEDEF		PVOID
USHORT			TYPEDEF		WORD
LPCTSTR			TYPEDEF		PTR BYTE

RTL_CRITICAL_SECTION STRUCT
  DebugInfo		DWORD		?
  LockCount		LONG		?
  RecursionCount	LONG		?
  OwningThread		HANDLE		?
  LockSemaphore		HANDLE		?
  Reserved		DWORD		?
RTL_CRITICAL_SECTION ENDS

CRITICAL_SECTION	TYPEDEF		RTL_CRITICAL_SECTION

RECTL STRUCT
  left			LONG		?
  top			LONG		?
  right			LONG		?
  bottom		LONG		?
RECTL ENDS

POINTL STRUCT
  x			LONG		?
  y			LONG		?
POINTL ENDS

SIZEL STRUCT
  _cx			LONG		?
  _cy			LONG		?
SIZEL ENDS

FONTOBJ STRUCT
  iUniq			DWORD		?
  iFace			DWORD		?
  cxMax			DWORD		?
  flFontType		DWORD		?
  iTTUniq		DWORD		?
  iFile			DWORD		?
  sizLogResPpi		SIZEL		{}
  ulStyleSize		DWORD		?
  pvConsumer		DWORD		?
  pvProducer		DWORD		?
FONTOBJ ENDS

GLYPHBITS STRUCT
  ptlOrigin		POINTL		{}
  sizlBitmap		SIZEL		{}
  aj			BYTE		0 DUP(?)
GLYPHBITS ENDS

GLYPHDEF STRUCT
  pgb			DWORD		?
  ppo			DWORD		?
GLYPHDEF ENDS

GLYPHPOS STRUCT
  hg			DWORD		?
  pgdf			DWORD		?
  ptl			POINTL		{}
GLYPHPOS ENDS

OutputDebugStringA	PROTO		PROC,
			lpOutputString	:LPCTSTR

ifdef WINNT_VER40
EngAllocMem		PROTO		PROC,
			uFlags		:UINT,
			uBytes		:UINT,
			uTag		:UINT

FL_ZERO_MEMORY      	=		00000001h

else
LocalAlloc		PROTO		PROC,
			uFlags		:UINT,
			uBytes		:UINT

LocalFree		PROTO		PROC,
			hMem		:HANDLE

LMEM_FIXED		=		00000000h
LMEM_MOVEABLE		=		00000002h
LMEM_NOCOMPACT		=		00000010h
LMEM_NODISCARD		=		00000020h
LMEM_ZEROINIT		=		00000040h
LMEM_MODIFY		=		00000080h
LMEM_LOCKCOUNT		=		000000FFh
LMEM_DISCARDABLE	=		00000F00h
LMEM_VALID_FLAGS	=		00000F72h
LMEM_DISCARDED		=		00004000h
LMEM_INVALID_HANDLE	=		00008000h
endif

HS_DDI_MAX		=		6

;-------------------------------------------------------------------------------
; STROBJ
;-------------------------------------------------------------------------------
SO_FLAG_DEFAULT_PLACEMENT	=	00000001h
SO_HORIZONTAL			=	00000002h
SO_VERTICAL			=	00000004h
SO_RESERVED			=	00000008h
SO_ZERO_BEARINGS		=	00000010h
SO_CHAR_INC_EQUAL_BM_BASE	=	00000020h
SO_MAXEXT_EQUAL_BM_SIDE		=	00000040h

STROBJ STRUCT
  cGlyphs		ULONG		?
  flAccel		FLONG		?
  ulCharInc		ULONG		?
  rclBkGround		RECTL		{}
  pgp			DWORD		?
  pwzsOrg		DWORD		?
STROBJ ENDS

STROBJ_vEnumStart	PROTO		PROC,
			pstro		:PTR STROBJ

STROBJ_bEnum		PROTO		PROC,
			pstro		:PTR STROBJ,
			pc		:ULONG,
			ppgpos		:PTR GLYPHPOS

SGI_EXTRASPACE		=		0

;-------------------------------------------------------------------------------
; SURFOBJ
;-------------------------------------------------------------------------------
SURFOBJ STRUCT
  dhsurf		DWORD		?
  hsurf			DWORD		?
  dhpdev		DWORD		?
  hdev			DWORD		?
  sizlBitmap		SIZEL		{}
  cjBits		ULONG		?
  pvBits		PVOID		?
  pvScan0		PVOID		?
  lDelta		LONG		?
  iUniq			ULONG		?
  iBitmapFormat		ULONG		?
  iType			USHORT		?
  fjBitmap		USHORT		?
SURFOBJ ENDS

STYPE_BITMAP		=		0
STYPE_DEVICE		=		1
STYPE_JOURNAL		=		2
STYPE_DEVBITMAP		=		3

BMF_1BPP		=		1
BMF_4BPP		=		2
BMF_8BPP		=		3
BMF_16BPP		=		4
BMF_24BPP		=		5
BMF_32BPP		=		6
BMF_4RLE		=		7
BMF_8RLE		=		8

BMF_TOPDOWN		=		0001h
BMF_NOZEROINIT		=		0004h
BMF_DONTCACHE		=		0008h

;-------------------------------------------------------------------------------
; BRUSHOBJ
;-------------------------------------------------------------------------------
BRUSHOBJ STRUCT
  iSolidColor		ULONG		?
  pvRbrush		PVOID		?
BRUSHOBJ ENDS

BRUSHOBJ_pvAllocRbrush	PROTO		PROC,
			pbo		:PTR BRUSHOBJ,
			cj		:ULONG

BRUSHOBJ_pvGetRbrush	PROTO		PROC,
			pbo		:PTR BRUSHOBJ

RB_DITHERCOLOR		=		80000000h

;-------------------------------------------------------------------------------
; CLIPOBJ
;-------------------------------------------------------------------------------
CLIPOBJ STRUCT
  iUniq			ULONG		?
  rclBounds		RECTL		{}
  iDComplexity		BYTE		?
  iFComplexity		BYTE		?
  iMode			BYTE		?
  fjOptions		BYTE		?
CLIPOBJ ENDS

DC_TRIVIAL		=		0
DC_RECT			=		1
DC_COMPLEX		=		3

FC_RECT			=		1
FC_RECT4		=		2
FC_COMPLEX		=		3

TC_RECTANGLES		=		0
TC_PATHOBJ		=		2

OC_BANK_CLIP		=		1

CT_RECTANGLES		=		0

CD_RIGHTDOWN		=		0
CD_LEFTDOWN		=		1
CD_RIGHTUP		=		2
CD_LEFTUP		=		3
CD_ANY			=		4

CD_LEFTWARDS		=		1
CD_UPWARDS		=		2

ENUMRECTS STRUCT
  _c			ULONG		?
  arcl			RECTL		1 DUP({})
ENUMRECTS ENDS

CLIPOBJ_cEnumStart	PROTO		PROC,
			pco		:PTR CLIPOBJ,
			bAll		:BOOL,
			iType		:ULONG,
			iDirection	:ULONG,
			cLimit		:ULONG

CLIPOBJ_bEnum		PROTO		PROC,
			pco		:PTR CLIPOBJ,
			cj		:ULONG,
			pul		:PTR ULONG

CLIPOBJ_ppoGetPath	PROTO		PROC,
			pci		:PTR CLIPOBJ

;-------------------------------------------------------------------------------
; XLATEOBJ
;-------------------------------------------------------------------------------
XLATEOBJ STRUCT
  iUniq			ULONG		?
  flXlate		FLONG		?
  iSrcType		USHORT		?
  iDstType		USHORT		?
  cEntries		ULONG		?
  pulXlate		DWORD		?
XLATEOBJ ENDS

XO_TRIVIAL		=		00000001h
XO_TABLE		=		00000002h
XO_TO_MONO		=		00000004h

XO_SRCPALETTE		=		1
XO_DESTPALETTE		=		2
XO_DESTDCPALETTE	=		3

XLATEOBJ_iXlate		PROTO		PROC,
			pxlo		:PTR XLATEOBJ,
			iColor		:ULONG

XLATEOBJ_piVector	PROTO		PROC,
			pxlo		:PTR XLATEOBJ

XLATEOBJ_cGetPalette	PROTO		PROC,
			pxlo		:PTR XLATEOBJ,
			iPal		:ULONG,
			cPal		:ULONG,
			pPal		:ULONG

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\5465over.c ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1997, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         5465over.c
*
* DESCRIPTION:
*
* REVISION HISTORY:
*
* $Log:   \\uinac\log\log\laguna\ddraw\src\5465over.c  $
* 
*    Rev 1.75   19 May 1998 09:54:36   xcong
* Assign GfVdFormat in ChipIOReadBWRegs() for TV-Out support.
* 
*    Rev 1.74   07 Apr 1998 17:28:58   xcong
* Get CR1 and CR1E in ChipIOBWRead()
* 
*    Rev 1.73   Mar 30 1998 13:06:52   frido
* Changed some parenthesis so the Codewright source parser can find the
* functions.
* 
*    Rev 1.72   08 Jan 1998 10:45:28   xcong
* Don't pass lpDDHALData in ComputeVWPositionData() for NT.
* 
*    Rev 1.71   07 Jan 1998 17:55:32   xcong
* Delete *lpDDHALData in SetPostion() for NT only.
* 
* 
*    Rev 1.70   06 Jan 1998 14:43:54   xcong
* Pass lpDDHALData in CurrentVLine().
* 
*    Rev 1.69   06 Jan 1998 11:42:06   xcong
* Change pDriverData into local lpDDHALData for multi-monitor support.
* 
*    Rev 1.68   Dec 11 1997 14:03:28   frido
* PDR#11011: A workaround has been added to convert a "dummy"
* update into a SHOW update when certain criteria are met.
* 
*    Rev 1.67   Dec 10 1997 13:41:32   frido
* Merged from 1.62 branch.
* 
*    Rev 1.63.2.0   Dec 03 1997 14:44:54   frido
* PDR#11017. The hardware is broken when shrinking videos horizontally with
* RGB32 format. A software workaround has been added to disable overlay in
* this case.
* 
*    Rev 1.66   Dec 10 1997 13:32:08   frido
* Merged from 1.62 branch.
* 
*    Rev 1.65   14 Nov 1997 13:04:18   XCONG
* Undo the modification for dwOverlayOffset for NT.
* 
*    Rev 1.64   06 Nov 1997 15:46:14   XCONG
* When update dwOverlayOffset, update this variable for all the attached surf
* too.
* 
*    Rev 1.63.2.0   Dec 03 1997 14:44:54   frido
* PDR#11017. The hardware is broken when shrinking videos horizontally with
* RGB32 format. A software workaround has been added to disable overlay in
* this case.
* 
*    Rev 1.63   04 Nov 1997 13:41:34   RUSSL
* Fix for PDR #10815
*
*    Rev 1.62   04 Nov 1997 12:57:02   RUSSL
* Removed forcing of min stretch in 24bpp to start at 1000 (for new bweq code)
*
*    Rev 1.61   30 Oct 1997 14:34:18   RUSSL
* Mods to support new interface to bweqn code
* Moved KillOverlay function here from 5465bw.c
* ChipIOReadBWRegs reads additional regs that are new to the BWREGS struct
* Added code in ChipIOReadBWRegs to clear bits 4 & 7 (the 256 byte fetch
*   related bits) of the BWREGS Control2 value.  The bweqn should use
*   256 byte fetch off values, since we are disabling 256 byte fetch
*   when overlay or videoport surfaces are created.
*
*    Rev 1.60   08 Oct 1997 11:15:02   RUSSL
* Fix for NT40 build without overlay support
*
*    Rev 1.59   25 Sep 1997 17:33:40   RUSSL
* Modified HeapAlloc calls to use HEAP_ALLOC macro
*      and HeapFree calls to use HEAP_FREE macro
*
*    Rev 1.58   19 Sep 1997 14:35:04   bennyn
* Fixed NT4.0 5462/64 build problem
*
*    Rev 1.57   17 Sep 1997 16:27:20   RUSSL
* Looks like setting the HardwareOwner is FlipOverlayStatus is an NT only
* thing.
*
*    Rev 1.56   16 Sep 1997 15:28:38   bennyn
* Modified for NT DD overlay
*
*    Rev 1.55   04 Sep 1997 09:43:26   RUSSL
* Fixed up Xing's changes so they compile for NT
*
*    Rev 1.54   04 Sep 1997 10:07:52   XCONG
* Delete f256Fetch, since the code to disable 256 byte fetch is moved to
* surface.c, nobody use this variable anymore.
*
*    Rev 1.53   03 Sep 1997 18:40:12   XCONG
* Disable overlay in 640*480*32 at 85Hz by calling KillOverlay().
* This is temporary fix for PDR#10381.
*
*    Rev 1.52   03 Sep 1997 16:35:02   RUSSL
*
*    Rev 1.51   02 Sep 1997 12:35:48   RUSSL
* Added GET_SURFACE_DATA_PTR macro and modified relevant code to get ptr
* using macro.  This will minimize the remaining changes needed for NT.
*
*    Rev 1.50   29 Aug 1997 16:47:26   RUSSL
* Added support for NT
* It's not quite complete, we need to allocate a LP_SURFACE_DATA structure
*   for each overlay surface and store it somewhere in the DD_SURFACE_LOCAL
*   structure (this needs to be done by CreateSurface).  And then add code
*   in here to get access to that struct when necessary.  #pragma message's
*   indicate where.
* Removed code to disable 256 byte fetch, its done by CreateSurface32
*
*    Rev 1.49   15 Aug 1997 16:38:30   XCONG
* Put overlay source alignment back to 1.  This is screen alignment instead o
*
*    Rev 1.48   14 Aug 1997 16:47:42   XCONG
* If overlay window is created, disable 256 byte fetch.
* Move gwNormalDTTR initialization into CreateSurface function.
*
*    Rev 1.47   29 Jul 1997 15:29:14   XCONG
* For autoflip overlay make sure dwNumAutoFlip == 2
*
*    Rev 1.46   28 Jul 1997 09:19:46   RUSSL
* Modified GetOverlayFlipStatus to check arm bit in hw rather than determine
*  elapsed time since previous flip
* Added video window index argument to GetOverlayFlipStatus function
* Made dwNumVideoWindows a global var rather than static
* Moved GetVideoWindowIndex inline function to overlay.h
*
*    Rev 1.45   24 Jul 1997 17:50:14   RUSSL
* modified src alignment values reported in ddhalinfo
* fixed error with disabling dst colorkey at 24bpp, I was turning off
* src colorkey related caps bits
*
*    Rev 1.44   16 Jul 1997 17:15:32   XCONG
* Add and use dwOverlayOffset and more in SURFACE_DATA structure in order
* to eliminate global variables.
*
*    Rev 1.43   14 Jul 1997 13:11:50   RUSSL
* added ChipIOReadBWRegs (moved here from 5465bw.c)
*
*    Rev 1.42   11 Jul 1997 11:57:26   XCONG
* Fix ptich problem in FlipOverlay for interleaved surface.
*
*    Rev 1.41   11 Jul 1997 08:57:02   RUSSL
* Fixed y clipping of CLPL surfaces in FlipOverlaySurface and
*   ComputeVWPositionData
*
*    Rev 1.40   09 Jul 1997 15:27:44   RUSSL
* Implemented CLPL lobotomy mode
*   allocates a block of system memory for the app to write the UV data to,
*   when the app locks the surface the system memory addresses are returned
*   so the app writes to system memory, and when the app unlocks the surface,
*   the data is copied into the frame buffer.  The copy is done from left to
*   right a scanline at a time.  There appears to be a hw bug when writing
*   to aperture 3 from right to left.  Roughly every other 4 dwords is
*   dropped.  This bug showed up when allowing the Compcore MPEG player to
*   write directly to aperture 3.  (also see comments in SysToFBCopy)
* Added GetUserSettings to read user controllable options from registry
* Current user controllable settings are:
*   OverlayBW   - enables/disables use of bandwidth equation (default=enabled)
*   OverlayCLPL - enables/disables support for CLPL format (default=enabled)
* 	OverlayCLPLLobotomyMode - enables/disables above described CLPL
*                             lobotomy mode (default=enabled)
* For forward compatibility, assume future chips have one video window
*
*    Rev 1.39   30 Jun 1997 10:37:20   RUSSL
* Added global var to control whether or not CLPL is supported
* CLPL support is based on a registry key "OverlayCLPL", set to "on" to
*   enable CLPL, default is "off"
*
*    Rev 1.38   23 Jun 1997 10:50:10   RUSSL
* Modified for reduced size of CLPL surfaces
*
*    Rev 1.37   20 Jun 1997 13:47:44   RUSSL
* Enabled CLPL overlay surface support (aka YUV420 & YUVPLANAR)
* Enabled 32 bit overlay surface support
* Removed REQUIREs and HW_(UN)LOCK_SEMAPHOREs (they didn't do anything anyway)
* CreateSurface now returns an HRESULT
*
*    Rev 1.36   09 Jun 1997 13:46:22   XCONG
* In FlipOverlaySurface(), Update VW_CONTROL0 too for DDFLIP_EVEN.
*
*    Rev 1.35   03 Jun 1997 09:52:50   RUSSL
* Added setting of VWEnable bit in CONTROL0 register in SetPosition and
* FlipOverlaySurface functions
*
*    Rev 1.34   22 May 1997 16:27:46   RUSSL
* Disable overlay shrink at 24bpp
*
*    Rev 1.33   15 May 1997 17:36:38   RUSSL
* Set ddCaps.dwAlignStrideAlign to bytes per pixel in Init5465Overlay
* Set bNoOverlayInThisMode to TRUE if in interlaced mode
*
*    Rev 1.32   15 May 1997 15:48:20   XCONG
* Change all the BWE flags back (in bw.h).
*
*    Rev 1.31   15 May 1997 10:56:54   RUSSL
* Changed IsFormatValid to return an HRESULT rather than a BOOL so
* CanCreateSurface32 can return a reasonable error code if the surface
* can't be created
*
*    Rev 1.30   13 May 1997 09:53:04   RUSSL
* Removed code in Init5465Info that was initializing the VW0_TEST0 register
*
*    Rev 1.29   12 May 1997 17:22:32   XCONG
* Change wVPortCreated in VideoPortEx into wNotify
*
*    Rev 1.28   10 May 1997 12:51:02   EDWINW
* Fix PDR 9574.  DestroySurface trashes tile size when trying to restore the
* DTTR's FIFO threshold.
*
*    Rev 1.27   09 May 1997 16:26:36   XCONG
* Only check VPE_ON and OVERLAY_ON flags in DX5
*
*    Rev 1.26   09 May 1997 11:10:22   XCONG
* Uses the flags in overlay.h for BWE flags. Befor save and restore
* gwNormIDTTR check VPE is still running or not, because VPE will do the same
* thing.
*
*    Rev 1.25   08 May 1997 17:57:40   XCONG
* Make the BWE variables global.  Set uDispDepth as the same as
* sourc depth instead of graphic depth.
*
*    Rev 1.24   24 Apr 1997 14:36:46   XCONG
* For SW playback only use smooth-interlaced mode when BOB and INTERLEAVE
* flags are both set.
*
*    Rev 1.23   24 Apr 1997 12:02:54   RUSSL
* Reenabled writing 0x52 to TEST0 reg on 5465AC if bw eqn is in use.
* 800x600x16 @ 85Hz looks like it's running on the hairy edge of
* stability with this.  All other modes (at all resolutions, colordepths
* and refresh rates) with sufficient bandwidth to use overlay looked
* stable although there is still some static in some modes.
*
*    Rev 1.22   17 Apr 1997 09:38:22   RUSSL
* Fix for PDR #9339, disable destination colorkeying support at 24bpp.
*   This looks like its a HWBUG.  This code can be disabled by defining
*   HWBUG_24BPP_DST_COLORKEY as zero.
* Write DTTR FIFO value returned by ChipIsEnoughBandwidth, original DTTR
*   setting is saved in a global var which is restored when final overlay
*   surface is destroyed
*
*    Rev 1.21   16 Apr 1997 10:19:28   RUSSL
* Had to update list of parms passed to GetBooleanSetting
*
*    Rev 1.20   15 Apr 1997 17:46:46   RUSSL
* Added use of PDC's bandwidth equation
* Added use of registry key/system.ini entry to disable use of BWEqn
* Removed IsSufficientBandwidth functions
* Modified Init5465Info to determine min & max zoom factors in current
*   mode by calling BWEqn
* ComputeVWFifoThreshold sets VW fifo threshold to value returned previously
*   by bandwidth equation (or it uses 8 if use of BWEqn is disabled)
*
*    Rev 1.19   04 Apr 1997 16:11:56   XCONG
* Add support for SW double-buffer and BOB palyback. Change the way to
* calculate VACCUM_STP for interleaved BOB.
*
*    Rev 1.18   03 Apr 1997 09:58:42   RUSSL
* Disable writing 0x42 or 0x52 to TEST0 reg, it's more grief than it's worth
*   Wait until we get a real bandwidth equation
* Made IsFormatValid always return FALSE when we're in an interlaced mode,
*   this essentially disables use of overlay in interlaced modes
*
*    Rev 1.17   28 Mar 1997 14:57:26   RUSSL
* Need to write 0x42 to TEST0 in 24bpp modes
* Display driver now puts 32bit linear address of pDevice in
*   pDriverData->lpPDevice, so don't need to call MapSLFix
*
*    Rev 1.16   24 Mar 1997 22:54:58   XCONG
* Add auto-flip overlay support. Include SSD_STRT_ADDR in tagVWDATA for
* all the version of DDRAW.
*
*    Rev 1.15   24 Mar 1997 16:44:56   RUSSL
* Changed CreateSurface so that CreateSurface32 fills in the blocksize, etc.
*
*    Rev 1.14   24 Mar 1997 12:12:40   RUSSL
* Added write of 0x52 to TEST0 reg on 5465AC, this enables some hw fixes
*
*    Rev 1.13   19 Mar 1997 11:47:40   cjl
* Simply added line to include new ddshared.h file.
*
*    Rev 1.12   12 Mar 1997 14:59:00   RUSSL
* replaced a block of includes with include of precomp.h for
*   precompiled headers
* Removed unneeded pragma message related to mapping in YUY2 aperture
*
*    Rev 1.11   07 Mar 1997 12:43:22   RUSSL
* Modified DDRAW_COMPAT usage
* Merged in PDC's VPE code for DX5
* Made IsSufficientBandwidth5465 global rather than static
*
*    Rev 1.10   24 Feb 1997 13:49:52   RUSSL
* Enabled YUY2 format
* Added RBGtoYCbCr function
* Modified DetermineVWColorKeyData to handle source color keying of UYVY
*   and YUY2 surfaces
*
*    Rev 1.9   14 Feb 1997 10:01:14   RUSSL
* Added more conditional compilation flags to enable/disable horizontal
*   mirroring, use of REQUIRE for qfree checking and use of HW_IN_USE
*   driver semaphore.
* If building debug version, change inline functions to not be inline.
*   WINICE can't deal with inline functions, so source code doesn't line
*   up correctly.
* Added ASSERT to make sure post immediately bit is clear in TEST0 reg
*   before updating video window registers
* Ignore DDOVER_DDFX flag in UpdateSurface because Microsoft's WHQL Overfly
*   test program sets this flag but fills overlayFX.dwDDFX with junk.
*   In some cases they set the DDOVERFX_MIRRORLEFTRIGHT bit even though
*   we don't even say we support that capability!  In order to get Overfly
*   to work, we need to ignore the overlayFX.dwDDFX flags that we don't
*   support (which is currently all of them)  This fixes BPR #8528
*
*    Rev 1.8   04 Feb 1997 14:15:48   RUSSL
* Added check in IsFormatValid to see if VPM is using the hardware
* Added SaveRectangles to reduce duplicate code in UpdateSurface
* Adjusted zoom code calculation for x shrink so don't go past end of src
*
*    Rev 1.7   31 Jan 1997 08:59:30   RUSSL
* Added better video window support checking based on chip id in
*   Init5465Overlay
* Adjusted init code alignment requirements reported to ddraw
* Addressed most of pragma message statements
* Fixed bug in FlipOverlaySurface when surface is clipped
* Enabled overlay shrink caps and added shrink zoom code calculations
*
*    Rev 1.6   29 Jan 1997 18:00:30   RUSSL
* Added use of require macro before register writes
* Modified zoom code calculations
*
*    Rev 1.5   28 Jan 1997 17:34:58   RUSSL
* VEND is the last line shown by the overlay
* Karl and I figured out how to make source color key work (at least at 16bpp)
*   hopefully the code matches what we did manually.  We need an app
*   that uses source color keying to really test it.
*
*    Rev 1.4   28 Jan 1997 15:29:42   RUSSL
* destination color keying is actually done using the hardware CLRKEY
*   registers and setting OCCLUDE in CONTROL0 to 1 (the documentation
*   appears to have the source color key settings & the destination color
*   key settings swapped)
* source color keying doesn't appear to work
*
*    Rev 1.3   27 Jan 1997 19:10:26   RUSSL
* Use a variable dwNumVideoWindows rather than a hardcoded define
* Added WaitForArmToClear, Set5465FlipDuration & PanOverlay1_Init
* Made IsFormatValid return TRUE only for UYVY overlay surfaces for now
* Made CreateSurface use rectangular allocation, specify block size for
*   rgb surfaces if we are managing surface creation, let CreateSurface
*   return NOTHANDLED so DDraw will fill in the surface ptr
* Added error checking for dwReserved1 of local surface struct in case
*   it's NULL
* Added additional debug output
* Put code in ComputeVWZoomCodes, ComputeVWPosData, DetermineColorKeyData,
*   ComputeVWFifoThreshold
* Added programming of the hw registers in RegInitVideoVW & RegMoveVideoVW
*
*    Rev 1.2   21 Jan 1997 15:44:40   RUSSL
* Okay this didn't compile and link last time
*
*    Rev 1.1   21 Jan 1997 14:55:14   RUSSL
* Port of 5480 overlay code from CirrusMM driver to 5465
*
*    Rev 1.0   15 Jan 1997 10:36:22   RUSSL
* Initial revision.
*
***************************************************************************
***************************************************************************/

/***************************************************************************
* I N C L U D E S
****************************************************************************/

#include "precomp.h"

#if defined WINNT_VER35      // WINNT_VER35
// If WinNT 3.5 skip all the source code
#elif defined (NTDRIVER_546x)
// If WinNT 4.0 and 5462/64 build skip all the source code
#elif defined(WINNT_VER40) && !defined(OVERLAY)
// if nt40 without overlay, skip all the source code
#else

#ifndef WINNT_VER40
#include "ddshared.h"
#include "flip.h"
#include "surface.h"
#include "blt.h"
#include "overlay.h"

#if DDRAW_COMPAT >= 50
#include "vp.h"
#endif

#include "settings.h"
#include "5465bw.h"
#include "swat.inc"
#endif

/***************************************************************************
* D E F I N E S
****************************************************************************/

#ifdef WINNT_VER40
#define ENABLE_YUY2                 0
#define ENABLE_YUVPLANAR            0
#define DISABLE_MOST_MODES          0
#else
#define ENABLE_YUY2                 1
#define ENABLE_YUVPLANAR            1
#define DISABLE_MOST_MODES          0
#endif

#define ENABLE_SD_RGB32             1

#define ENABLE_MIRRORING            0

#define HWBUG_24BPP_DST_COLORKEY    1

#ifdef DEBUG
#define INLINE
#else
#define INLINE  __inline
#endif

// VW_CAP0 bits
#define VWCAP_VW_PRESENT      0x00000001

// VW_CONTROL1 bits
#define VW_ByPassClrSpc       0x00000002
#define VW_YShrinkEn          0x00000001

// VW_CONTROL0 bits
#define VW_XShrinkBy2         0x80000000
#define VW_ClkMode2x          0x40000000
#define VW_FIFO_THRSH_EN      0x20000000
#define VW_ALPHA_KEYCMP_EN    0x10000000

#define VW_DB_VPORT_ID_MASK   0x0F000000
#define VW_DB_VSM_ID_MASK     0x00F00000
#define VW_DB_CTL_MASK        0x000F0000

#define VW_SD_FRMT_MASK       0x0000FF00
#define VW_OCCLUDE_MASK       0x000000F0

#define VW_SMTH_INT           0x00000008
#define VW_HMIRR_EN           0x00000004
#define VW_VWE                0x00000002
#define VW_ARM                0x00000001

// Source Data Formats for SD_FRMT
#define SD_YUV422             0x00    // ITU 601 compliant YUV data
#define SD_YUV420             0x03    // ITU 601 compliant YUV data
#define SD_YUV422_FS          0x04    // Full Scale YUV data
#define SD_YVU420_FS          0x07    // Full Scale YUV data
#define SD_RGB16_555          0x08    // 5:5:5
#define SD_RGB16_565          0x09    // 5:6:5
#define SD_RGB32              0x0B    // ARGB

#define SD_FRMT_SHIFT         8

// Occlude types for OCCLUDE
#define NO_OCCLUSION          0       // video window always displayed
#define COLOR_KEY             1       // destination color keying
#define CHROMA_KEY            2       // source color keying

#define OCCLUDE_SHIFT         4

// VW_TEST0 bits
#define VW_PostImed           1
#define VWVRepEnable          0x4

// defines used in Init5465Info()
#define SRC_WIDTH              160
#define SRC_HEIGHT             120
#define MAX_ZOOM              8000
#define MIN_ZOOM               500
#define ZOOM_STEP              100

#ifdef WINNT_VER40
#define lpDDHALData       ((DRIVERDATA *)(&(ppdev->DriverData)))
#define ASSERT(x)
#define DRAW_ENGINE_BUSY  DrawEngineBusy(lpDDHALData)
#endif

#ifdef WINNT_VER40
#define GET_SURFACE_DATA_PTR(lpSurface)   (LP_SURFACE_DATA)((lpSurface)->dwReserved1)
#else
#define GET_SURFACE_DATA_PTR(lpSurface)   (LP_SURFACE_DATA)((lpSurface)->dwReserved1)
#endif

#if ENABLE_256_BYTE_FETCH
// bit defs for PERFORMANCE register
#define ECO_256_BYTES_FIX_EN      0x4000
// bit defs for CONTROL2 register
#define MONO_SAFETY_256           0x0080
#define BYTE_REQ_256              0x0010
#endif

/***************************************************************************
* T Y P E D E F S
****************************************************************************/

typedef struct tagVWDATA
{
  WORD  HSTRT;
  WORD  HSDSZ;
  WORD  HEND;
  DWORD HACCUM_STP;
  DWORD HACCUM_SD;
  WORD  VSTRT;
  WORD  VEND;
  DWORD VACCUM_STP;
  DWORD VACCUM_SDA;
  DWORD VACCUM_SDB;
  DWORD PSD_STRT_ADDR;
  DWORD SSD_STRT_ADDR;
#if ENABLE_YUVPLANAR
  DWORD PSD_UVSTRT_ADDR;
  DWORD SSD_UVSTRT_ADDR;
#endif
  WORD  SD_PITCH;
  DWORD CLRKEY_MIN;
  DWORD CLRKEY_MAX;
  DWORD CHRMKEY_MIN;
  DWORD CHRMKEY_MAX;
//  WORD  BRIGHT_ADJ;
//  BYTE  Z_ORDER;
  WORD  FIFO_THRSH;
  DWORD CONTROL1;
  DWORD CONTROL0;
//  DWORD CAP1;
//  DWORD CAP0;
//  DWORD TEST0;
} VWDATA;

typedef struct tagUSERSETTINGS
{
  BOOL  *pVar;
  char  *pRegKey;
  BOOL  defaultVal;
} USERSETTINGS;

#if ENABLE_YUVPLANAR
// structure for CLPL (YUV planar) surface
typedef struct tagCLPLInfo
{
  LPVOID  fpYSurface;     // Y data in first aperture
  LPVOID  fpUSurface;     // U data in 0-2M of fourth aperture
  LPVOID  fpVSurface;     // V data in 2-4M of fourth aperture

  // pointers for CLPLLobotomyMode
  LPVOID  fpUSystemSurface;
  LPVOID  fpVSystemSurface;
  LPVOID  fpRealUSurface; // U data in 0-2M of fourth aperture
  LPVOID  fpRealVSurface; // V data in 2-4M of fourth aperture
} CLPLInfo;

typedef CLPLInfo  *LPCLPLSURFACE;
#endif

/***************************************************************************
* E X T E R N A L   V A R I A B L E S
****************************************************************************/

#ifndef WINNT_VER40
#if DDRAW_COMPAT >= 50
 extern WORD gwNotify;       //#xc
#endif
#endif

/***************************************************************************
* S T A T I C   V A R I A B L E S
****************************************************************************/

#ifdef WINNT_VER40

// For NT these are in ppdev->DriverData
#define bUseBWEqn               ppdev->DriverData.bUseBWEqn
#define bNoOverlayInThisMode    ppdev->DriverData.bNoOverlayInThisMode

#define lpHardwareOwner         ppdev->DriverData.lpHardwareOwner
#define lpColorSurfaceVW        ppdev->DriverData.lpColorSurfaceVW
#define lpSrcColorSurfaceVW     ppdev->DriverData.lpSrcColorSurfaceVW

#define grOverlaySrc            ppdev->DriverData.grOverlaySrc
#define grOverlayDest           ppdev->DriverData.grOverlayDest
#define gdwFourccVW             ppdev->DriverData.gdwFourccVW
#if ENABLE_MIRRORING
#define bIsVWMirrored           ppdev->DriverData.bIsVWMirrored
#endif

#define gdwAvailVW              ppdev->DriverData.gdwAvailVW              // Next available video window
//#define gwZOrder                ppdev->DriverData.gwZOrder                // default primary on top.
#define gdwColorKey             ppdev->DriverData.gdwColorKey
#define gdwSrcColorKeyLow       ppdev->DriverData.gdwSrcColorKeyLow
#define gdwSrcColorKeyHigh      ppdev->DriverData.gdwSrcColorKeyHigh
#define gdwDestColorKeyOwnerVW  ppdev->DriverData.gdwDestColorKeyOwnerVW  // DstColorKey owner (NULL or FLG_VWX)
#define gdwSrcColorKeyOwnerVW   ppdev->DriverData.gdwSrcColorKeyOwnerVW   // SrcColorKey owner (NULL or FLG_VWX)

#define giOvlyCnt               ppdev->DriverData.giOvlyCnt
#if ENABLE_YUVPLANAR                                            // YUV Planar surfaces cannot exist
#define giPlanarCnt             ppdev->DriverData.giPlanarCnt   // with other overlay surfaces
#define bCLPLLobotomyMode       ppdev->DriverData.bCLPLLobotomyMode
#endif
//#define gbDoubleClock           ppdev->DriverData.gbDoubleClock

#if DISABLE_MOST_MODES
#define bDisableMostModes       ppdev->DriverData.bDisableMostModes
#endif

#else   // Win95

ASSERTFILE("5465over.c");

STATIC DIBENGINE  *pPDevice;
STATIC BOOL       bUseBWEqn;
STATIC BOOL       bNoOverlayInThisMode;

STATIC LPDDRAWI_DDRAWSURFACE_LCL lpHardwareOwner[MAX_VIDEO_WINDOWS];
STATIC LPDDRAWI_DDRAWSURFACE_LCL lpColorSurfaceVW[MAX_VIDEO_WINDOWS];
STATIC LPDDRAWI_DDRAWSURFACE_LCL lpSrcColorSurfaceVW[MAX_VIDEO_WINDOWS];

STATIC RECTL      grOverlaySrc[MAX_VIDEO_WINDOWS];
STATIC RECTL      grOverlayDest[MAX_VIDEO_WINDOWS];
STATIC DWORD      gdwFourccVW[MAX_VIDEO_WINDOWS];
#if ENABLE_MIRRORING
STATIC BOOL       bIsVWMirrored[MAX_VIDEO_WINDOWS];
#endif

STATIC DWORD      gdwAvailVW;    // Next available video window
//STATIC WORD       gwZOrder = OVERLAYZ_PRIMARY_ON_TOP; // default primary on top.
STATIC DWORD      gdwColorKey;
STATIC DWORD      gdwSrcColorKeyLow;
STATIC DWORD      gdwSrcColorKeyHigh;
STATIC DWORD      gdwDestColorKeyOwnerVW = 0; // DstColorKey owner (NULL or FLG_VWX)
STATIC DWORD      gdwSrcColorKeyOwnerVW = 0;  // SrcColorKey owner (NULL or FLG_VWX)

STATIC int        giOvlyCnt[MAX_VIDEO_WINDOWS];
#if ENABLE_YUVPLANAR                          // YUV Planar surfaces cannot exist
STATIC int        giPlanarCnt = 0;            // with other overlay surfaces
STATIC BOOL       bCLPLLobotomyMode;
#endif
//STATIC BOOL       gbDoubleClock;

#if DISABLE_MOST_MODES
STATIC BOOL       bDisableMostModes;
#endif

#endif

/***************************************************************************
* G L O B A L   V A R I A B L E S
****************************************************************************/

#ifdef WINNT_VER40

// For NT these are in ppdev->DriverData
#define gsOverlayFlip       ppdev->DriverData.gsOverlayFlip
#define gsProgRegs          ppdev->DriverData.gsProgRegs
#define gvidConfig          ppdev->DriverData.gvidConfig
#define gwNormalDTTR        ppdev->DriverData.gwNormalDTTR
#define dwNumVideoWindows   ppdev->DriverData.dwNumVideoWindows

#if ENABLE_YUVPLANAR
#define bEnableCLPL         ppdev->DriverData.bEnableCLPL
#endif

#else

OVERLAYFLIPRECORD gsOverlayFlip;

PROGREGS    gsProgRegs = {0};  //Make them global so VPE can use the same ones
VIDCONFIG   gvidConfig = {0};
WORD        gwNormalDTTR;
DWORD       dwNumVideoWindows;

#if ENABLE_YUVPLANAR
BOOL        bEnableCLPL;
#endif

#endif

/***************************************************************************
* S T A T I C   F U N C T I O N   P R O T O T Y P E S
****************************************************************************/

#ifdef WINNT_VER40

static void    GetUserSettings      ( PDEV * );

STATIC HRESULT IsFormatValid        ( PDEV*, DWORD, DWORD );
STATIC HRESULT CreateOverlaySurface ( PDEV*, PDD_SURFACE_LOCAL, DWORD );
STATIC VOID    DestroyOverlaySurface( PDEV*, PDD_DESTROYSURFACEDATA );
STATIC DWORD   FlipOverlaySurface   ( PDEV*, PDD_FLIPDATA );
STATIC DWORD   LockSurface          ( PDEV*, PDD_LOCKDATA );
STATIC VOID    UnlockSurface        ( PDEV*, PDD_UNLOCKDATA );
STATIC VOID    SetColorKey          ( PDEV*, PDD_SETCOLORKEYDATA );
STATIC DWORD   UpdateSurface        ( PDEV*, PDD_UPDATEOVERLAYDATA );
STATIC DWORD   SetPosition          ( PDEV*, PDD_SETOVERLAYPOSITIONDATA );
STATIC DWORD   GetOverlayFlipStatus ( PDEV*, FLATPTR, DWORD );

STATIC BOOL    RegInitVideoVW ( PDEV*, DWORD, PDD_SURFACE_LOCAL );
STATIC VOID    RegMoveVideoVW ( PDEV*, DWORD, PDD_SURFACE_LOCAL );

#else

static void    GetUserSettings      ( void );

STATIC HRESULT IsFormatValid        ( LPGLOBALDATA, DWORD, DWORD );
STATIC HRESULT CreateSurface        ( LPDDRAWI_DDRAWSURFACE_LCL, DWORD,LPGLOBALDATA );
STATIC VOID    DestroySurface       ( LPDDHAL_DESTROYSURFACEDATA );
STATIC DWORD   FlipOverlaySurface   ( LPDDHAL_FLIPDATA );
STATIC DWORD   LockSurface          ( LPDDHAL_LOCKDATA );
STATIC VOID    UnlockSurface        ( LPDDHAL_UNLOCKDATA );
STATIC VOID    SetColorKey          ( LPDDHAL_SETCOLORKEYDATA);
STATIC DWORD   UpdateSurface        ( LPDDHAL_UPDATEOVERLAYDATA );
STATIC DWORD   SetPosition          ( LPDDHAL_SETOVERLAYPOSITIONDATA );
STATIC DWORD   GetOverlayFlipStatus (LPGLOBALDATA, FLATPTR, DWORD );

STATIC BOOL    RegInitVideoVW ( DWORD, LPDDRAWI_DDRAWSURFACE_LCL,LPGLOBALDATA );
STATIC VOID    RegMoveVideoVW ( DWORD, LPDDRAWI_DDRAWSURFACE_LCL,LPGLOBALDATA );

#endif

/***************************************************************************
* E X T E R N A L   F U N C T I O N   P R O T O T Y P E S
****************************************************************************/

#if WINNT_VER40
extern int  CurrentVLine  (PDEV *);
extern VOID GetFormatInfo (LPDDPIXELFORMAT, LPDWORD, LPDWORD);
#endif
#ifdef USE_OLD_BWEQ
extern BOOL KillOverlay
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#endif
  WORD wScreenX,
  UINT uScreenDepth
); //fix PDR#10381
#endif

BOOL ChipIOReadBWRegs
(
#ifdef WINNT_VER40
  PDEV      *ppdev,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  LPBWREGS  pBWRegs
);

/***************************************************************************
*
* FUNCTION:     MakeVideoWindowFlag
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE DWORD
MakeVideoWindowFlag ( DWORD dwVWIndex )
{
  ASSERT(dwNumVideoWindows > dwVWIndex);
  return ((1 << dwVWIndex) << FLG_VW_SHIFT);
}

#if 0
/***************************************************************************
*
* FUNCTION:     GetDoubleClockStatus
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE DWORD
GetDoubleClockStatus ( VOID )
{
#pragma message("GetDoubleClockStatus not implemented!")
  return FALSE;
}
#endif

/***************************************************************************
*
* FUNCTION:     GetDDHALContext
*
* DESCRIPTION:
*               Get shared data structure (SDATA) pointer
****************************************************************************/
#ifndef WINNT_VER40
INLINE LPGLOBALDATA  GetDDHALContext( LPDDRAWI_DIRECTDRAW_GBL lpGb )
{
#if (DDRAW_COMPAT >= 50)
    if(lpGb->dwReserved3)       //the SDATA pointer is passed by dwReserved3
                                //for DX50    
      return (LPGLOBALDATA)lpGb->dwReserved3;
    else
#endif
     return pDriverData;
}
#endif

/***************************************************************************
*
* FUNCTION:     IsHardwareInUseVW
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE BOOL IsVWHardwareInUse
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD dwVWIndex
)
{
  ASSERT(dwNumVideoWindows > dwVWIndex);
  if (VW_VWE & ((PVGAR)lpDDHALData->RegsAddress)->VideoWindow[dwVWIndex].grVW_CONTROL0)
    return TRUE;
  return FALSE;
}

/***************************************************************************
*
* FUNCTION:     WaitForArmToClear
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE VOID WaitForVWArmToClear
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD dwVWIndex
)
{
  // wait for previous register writes to post
  // the hardware clears the ARM bit at that time
  ASSERT(dwNumVideoWindows > dwVWIndex);
  while (((PVGAR)lpDDHALData->RegsAddress)->VideoWindow[dwVWIndex].grVW_CONTROL0 & VW_ARM)
    ;
}

/***************************************************************************
*
* FUNCTION:     EnableOverlay
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE VOID EnableOverlay
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD dwVWIndex
)
{
  ASSERT(dwNumVideoWindows > dwVWIndex);
#ifdef WINNT_VER40
  WaitForVWArmToClear(ppdev,dwVWIndex);
#else
  WaitForVWArmToClear(lpDDHALData,dwVWIndex);
#endif
  ((PVGAR)lpDDHALData->RegsAddress)->VideoWindow[dwVWIndex].grVW_CONTROL0 |= (VW_VWE | VW_ARM);
}

/***************************************************************************
*
* FUNCTION:     DisableOverlay
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE VOID DisableOverlay
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD dwVWIndex
)
{
  ASSERT(dwNumVideoWindows > dwVWIndex);
#ifdef WINNT_VER40
  WaitForVWArmToClear(ppdev,dwVWIndex);
#else
  WaitForVWArmToClear(lpDDHALData,dwVWIndex);
#endif
  ((PVGAR)lpDDHALData->RegsAddress)->VideoWindow[dwVWIndex].grVW_CONTROL0 &=
                ~(VW_FIFO_THRSH_EN | VW_VWE);
  ((PVGAR)lpDDHALData->RegsAddress)->VideoWindow[dwVWIndex].grVW_CONTROL0 |= VW_ARM;
}

/***************************************************************************
*
* FUNCTION:     Set5465FlipDuration
*
* DESCRIPTION:
*
****************************************************************************/

VOID Set5465FlipDuration
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#endif
  DWORD dwFlipDuration
)
{
  gsOverlayFlip.dwFlipDuration = dwFlipDuration;
}

/***************************************************************************
*
* FUNCTION:     GetUserSettings
*
* DESCRIPTION:
*
****************************************************************************/

VOID GetUserSettings
(
#ifdef WINNT_VER40
  PDEV  *ppdev
#else
  VOID
#endif
)
{
#ifdef WINNT_VER40

#pragma message("GetUserSettings: Where are laguna settings stored in the NT registry?")
  bUseBWEqn = TRUE;

#if ENABLE_YUVPLANAR
  bEnableCLPL = TRUE;
  bCLPLLobotomyMode = TRUE;
#endif

#else  // else Win95
  static const USERSETTINGS   UserSettings[] =
  {
    { &bUseBWEqn,         "OverlayBW",               TRUE },
#if ENABLE_YUVPLANAR
    { &bEnableCLPL,       "OverlayCLPL",             TRUE },
    { &bCLPLLobotomyMode, "OverlayCLPLLobotomyMode", TRUE },
#endif
#if DISABLE_MOST_MODES
    { &bDisableMostModes, "OverlayBWHack",           TRUE },
#endif
  };

  const USERSETTINGS *pUserSetting;


  for (pUserSetting = &UserSettings[0];
       pUserSetting < &UserSettings[sizeof(UserSettings)/sizeof(UserSettings[0])];
       pUserSetting++)
  {
    *(pUserSetting->pVar) = pUserSetting->defaultVal;
    GetBooleanSetting(pUserSetting->pRegKey,
                      pUserSetting->pVar,
                      LOCATION_OF_3D_PERFORMANCE);
  }
#endif
}

/***************************************************************************
*
* FUNCTION:     Init5465Overlay
*
* DESCRIPTION:
*
****************************************************************************/

VOID Init5465Overlay
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
  DWORD           dwChipType,
  PDD_HALINFO     pDDHALInfo,
  LPOVERLAYTABLE  pOverlayTable
#else
  DWORD           dwChipType,
  LPDDHALINFO     pDDHALInfo,
  LPOVERLAYTABLE  pOverlayTable,
  LPGLOBALDATA    lpDDHALData
#endif
)
{
  DWORD   dwNumFourCCs;


#ifdef WINNT_VER40
  GetUserSettings(ppdev);
#else
  GetUserSettings();
#endif

  if (! bUseBWEqn)
    gsProgRegs.VW0_FIFO_THRSH = 8;

  // We should check the capabilities register on the chip
  // but it's busted
#ifdef WINNT_VER40
  if (CL_GD5465 == dwChipType)
#else
  if (GD5465_PCI_DEVICE_ID == dwChipType)
#endif
    dwNumVideoWindows = 1;
  else
  {
#if 1
    dwNumVideoWindows = 1;
#else
    int     i;
    PVGAR   pREG = (PVGAR)lpDDHALData->RegsAddress;

    dwNumVideoWindows = 0;
    for (i = 0; i < MAX_VIDEO_WINDOWS; i++)
    {
      if (VWCAP_VW_PRESENT & pREG->VideoWindow[i].grVW_CAP0)
        dwNumVideoWindows++;
    }
#endif
  }

#ifdef WINNT_VER40
  if (NULL != pDDHALInfo)
#endif
  {
    pDDHALInfo->ddCaps.dwMaxVisibleOverlays  = dwNumVideoWindows;
    pDDHALInfo->ddCaps.dwCurrVisibleOverlays = 0;

#ifndef WINNT_VER40
    pPDevice = (DIBENGINE *)lpDDHALData->lpPDevice;
#endif

  // Fill in the caps
    pDDHALInfo->ddCaps.dwCaps |= DDCAPS_OVERLAY
                              |  DDCAPS_OVERLAYFOURCC
                              |  DDCAPS_OVERLAYSTRETCH
                              |  DDCAPS_ALIGNSTRIDE
                              |  DDCAPS_OVERLAYCANTCLIP
                              ;

    pDDHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_OVERLAY
                                      ;

    pDDHALInfo->ddCaps.dwFXCaps |= DDFXCAPS_OVERLAYARITHSTRETCHY
                                |  DDFXCAPS_OVERLAYSTRETCHX
                                |  DDFXCAPS_OVERLAYSTRETCHY
                                |  DDFXCAPS_OVERLAYSHRINKX
                                |  DDFXCAPS_OVERLAYSHRINKY
#if ENABLE_MIRRORING
                                |  DDFXCAPS_OVERLAYMIRRORLEFTRIGHT
#endif
                                ;
  }

  /* FOURCCs supported */
#if (MAX_FOURCCS < 3)
#error dwFourCC array too small
#endif
  dwNumFourCCs = 0;
  lpDDHALData->dwFourCC[dwNumFourCCs++] = FOURCC_UYVY;
#if ENABLE_YUY2
  lpDDHALData->dwFourCC[dwNumFourCCs++] = FOURCC_YUY2;
#endif
#if ENABLE_YUVPLANAR
  // add CLPL fourcc if registry key set to "on"
  if (bEnableCLPL)
    lpDDHALData->dwFourCC[dwNumFourCCs++] = FOURCC_YUVPLANAR;
#endif

#ifdef WINNT_VER40
  if (NULL != pDDHALInfo)
#endif
  {
    pDDHALInfo->ddCaps.dwNumFourCCCodes = dwNumFourCCs;

    // say we can handle byte alignment and any byte width
    pDDHALInfo->ddCaps.dwAlignBoundarySrc  = 1;   // src rect x byte alignment
    pDDHALInfo->ddCaps.dwAlignSizeSrc      = 1;   // src rect x byte size
    pDDHALInfo->ddCaps.dwAlignBoundaryDest = 1;   // dst rect x byte alignment
    pDDHALInfo->ddCaps.dwAlignSizeDest     = 1;   // dst rect x byte size
    // stride alignment
#ifdef WINNT_VER40
    pDDHALInfo->ddCaps.dwAlignStrideAlign = ppdev->cxMemory;
#else
    pDDHALInfo->ddCaps.dwAlignStrideAlign = pPDevice->deWidthBytes;
#endif

    pDDHALInfo->ddCaps.dwMinOverlayStretch = 500;   // min stretch is 0.5:1
    pDDHALInfo->ddCaps.dwMaxOverlayStretch = 8000;  // max stretch is 8:1
#ifdef WINNT_VER40
    ppdev->DriverData.dwMinOverlayStretch = 500;
    ppdev->DriverData.dwMaxOverlayStretch = 8000;
#endif
    pDDHALInfo->vmiData.dwOverlayAlign     = 8 * 8; // qword alignment in bits
  }

  // Initialize OverlayTable function pointers
  pOverlayTable->pfnCanCreateSurface = IsFormatValid;
#ifdef WINNT_VER40
  pOverlayTable->pfnCreateSurface    = CreateOverlaySurface;
  pOverlayTable->pfnDestroySurface   = DestroyOverlaySurface;
#else
  pOverlayTable->pfnCreateSurface    = CreateSurface;
  pOverlayTable->pfnDestroySurface   = DestroySurface;
#endif
  pOverlayTable->pfnLock             = LockSurface;
  pOverlayTable->pfnUnlock           = UnlockSurface;
  pOverlayTable->pfnSetColorKey      = SetColorKey;
  pOverlayTable->pfnFlip             = FlipOverlaySurface;
  pOverlayTable->pfnUpdateOverlay    = UpdateSurface;
  pOverlayTable->pfnSetOverlayPos    = SetPosition;
  pOverlayTable->pfnGetFlipStatus    = GetOverlayFlipStatus;

  // do mode specific initialization
#ifdef WINNT_VER40
  if (NULL != pDDHALInfo)
    Init5465Info(ppdev, pDDHALInfo);
#else
  Init5465Info(pDDHALInfo, lpDDHALData);
#endif
}

/***************************************************************************
*
* FUNCTION:     Init5465Info
*
* DESCRIPTION:
*
****************************************************************************/

VOID Init5465Info
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  PDD_HALINFO pDDHALInfo
#else
  LPDDHALINFO pDDHALInfo,
  LPGLOBALDATA  lpDDHALData  
#endif
)
{
  // assume we can use overlay in this mode
  bNoOverlayInThisMode = FALSE;

  if (! bUseBWEqn)
    gsProgRegs.DispThrsTiming =
    ((PVGAR)lpDDHALData->RegsAddress)->grDisplay_Threshold_and_Tiling & 0x3F;

  // Are we double clocked?
//  gbDoubleClock = GetDoubleClockStatus();

  // re-init these on mode change, we might tweak them below
  pDDHALInfo->ddCaps.dwAlignBoundaryDest = 1;
  pDDHALInfo->ddCaps.dwAlignSizeDest     = 1;
  pDDHALInfo->ddCaps.dwMinOverlayStretch = 500;
  pDDHALInfo->ddCaps.dwMaxOverlayStretch = 8000;
#ifdef WINNT_VER40
  ppdev->DriverData.dwMinOverlayStretch = 500;
  ppdev->DriverData.dwMaxOverlayStretch = 8000;
#endif

  // tell ddraw we can do colorkeying
  // we might undo this below
  pDDHALInfo->ddCaps.dwCKeyCaps |= DDCKEYCAPS_DESTOVERLAY
                                |  DDCKEYCAPS_DESTOVERLAYYUV
                                |  DDCKEYCAPS_DESTOVERLAYONEACTIVE
                                |  DDCKEYCAPS_SRCOVERLAY
                                |  DDCKEYCAPS_SRCOVERLAYYUV
                                |  DDCKEYCAPS_SRCOVERLAYONEACTIVE
                                |  DDCKEYCAPS_SRCOVERLAYCLRSPACE
                                |  DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV
                                ;
  if (bUseBWEqn)
  {
    DWORD     dwZoom;
    VIDCONFIG vidConfig;
    BWREGS    bwregs;


    // initialize vidConfig
    memset(&vidConfig, 0, sizeof(vidConfig));

    vidConfig.uSrcDepth  = 16;
#ifdef WINNT_VER40
    vidConfig.uDispDepth = ppdev->ulBitCount;
    vidConfig.uGfxDepth  = ppdev->ulBitCount;
#else
    vidConfig.uDispDepth = pPDevice->deBitsPixel;
    vidConfig.uGfxDepth  = pPDevice->deBitsPixel;
#endif
    vidConfig.dwFlags    =  VCFLG_COLORKEY | VCFLG_DISP;

    vidConfig.sizSrc.cx = SRC_WIDTH;
    vidConfig.sizSrc.cy = SRC_HEIGHT;
    if(gvidConfig.dwFlags & VCFLG_CAP)
    {
      //if video port is on, includes it for BWE
        vidConfig.dwFlags |= VCFLG_CAP;
        vidConfig.sizXfer = gvidConfig.sizXfer;
        vidConfig.sizCap = gvidConfig.sizCap;
        vidConfig.sizXfer = gvidConfig.sizXfer;
        vidConfig.dwXferRate = gvidConfig.dwXferRate;
        vidConfig.uXferDepth = gvidConfig.uXferDepth;
        vidConfig.uCapDepth = gvidConfig.uCapDepth;
        vidConfig.uSrcDepth = gvidConfig.uSrcDepth;
    }
#ifdef WINNT_VER40
    ChipIOReadBWRegs(ppdev, &bwregs);
#else
    ChipIOReadBWRegs(lpDDHALData, &bwregs);
#endif
#ifdef USE_OLD_BWEQ
    //Kill overlay for some modes
#ifdef WINNT_VER40
    if(KillOverlay(ppdev, (WORD)ppdev->cxScreen, (UINT)ppdev->ulBitCount))
#else
    if(KillOverlay( pPDevice->deWidth,pPDevice->deBitsPixel))
#endif
      bNoOverlayInThisMode = TRUE;
    else
#endif
    {
        // stupid linear search for min & max zoom factors

        // Check bandwidth to find the maximum zoom factor of 16 bit data
        // with colorkey
        dwZoom = MAX_ZOOM;
        do
        {
          vidConfig.sizDisp.cx = (SRC_WIDTH  * dwZoom) / 1000;
          vidConfig.sizDisp.cy = (SRC_HEIGHT * dwZoom) / 1000;

          if (ChipIsEnoughBandwidth(&gsProgRegs, &vidConfig, &bwregs))
          {
    #ifndef WINNT_VER40
            DBG_MESSAGE(("Maximum zoom factor: %d", dwZoom));
    #endif

            pDDHALInfo->ddCaps.dwMaxOverlayStretch = dwZoom;

    #ifdef WINNT_VER40
            ppdev->DriverData.dwMaxOverlayStretch = dwZoom;
    #endif
            break;
          }
          dwZoom -= ZOOM_STEP;
        } while (dwZoom > 4000);
        if (dwZoom != pDDHALInfo->ddCaps.dwMaxOverlayStretch)
          bNoOverlayInThisMode = TRUE;

        // Check bandwidth to find the minimum zoom factor of 16 bit data
        // with colorkey
        dwZoom = MIN_ZOOM;
#ifdef USE_OLD_BWEQ
        // disable overlay shrink in 24bpp modes
#ifdef WINNT_VER40
        if (24 == ppdev->ulBitCount)
#else
        if (24 == pPDevice->deBitsPixel)
#endif
          dwZoom = 1000;
#endif
        do
        {
          vidConfig.sizDisp.cx = (SRC_WIDTH  * dwZoom) / 1000;
          vidConfig.sizDisp.cy = (SRC_HEIGHT * dwZoom) / 1000;

          if (ChipIsEnoughBandwidth(&gsProgRegs, &vidConfig, &bwregs))
          {
    #ifndef WINNT_VER40
            DBG_MESSAGE(("Minimum zoom factor: %d", dwZoom));
    #endif

            pDDHALInfo->ddCaps.dwMinOverlayStretch = dwZoom;

    #ifdef WINNT_VER40
            ppdev->DriverData.dwMinOverlayStretch = dwZoom;
    #endif
            break;
          }
          dwZoom += ZOOM_STEP;
        } while (dwZoom < 4000);
        if (dwZoom != pDDHALInfo->ddCaps.dwMinOverlayStretch)
          bNoOverlayInThisMode = TRUE;
    }
    // I'll leave this code in here but so far I have only seen that if
    // we don't have enough bandwidth to use overlay with colorkey then
    // we don't have enough bandwidth period

    // try to see if there's enough bandwidth to use overlay without colorkey
    if (TRUE == bNoOverlayInThisMode)
    {
      // reset this in case we find enough bandwidth to use overlay
      // without colorkey
      bNoOverlayInThisMode = FALSE;

      // retry without colorkey available
      // tell ddraw we don't do colorkeying
      pDDHALInfo->ddCaps.dwCKeyCaps &= ~(DDCKEYCAPS_DESTOVERLAY
                                    |    DDCKEYCAPS_DESTOVERLAYYUV
                                    |    DDCKEYCAPS_DESTOVERLAYONEACTIVE
                                    |    DDCKEYCAPS_SRCOVERLAY
                                    |    DDCKEYCAPS_SRCOVERLAYYUV
                                    |    DDCKEYCAPS_SRCOVERLAYONEACTIVE
                                    |    DDCKEYCAPS_SRCOVERLAYCLRSPACE
                                    |    DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV)
                                    ;

#ifdef USE_OLD_BWEQ
#ifdef WINNT_VER40
      if(KillOverlay(ppdev, (WORD)ppdev->cxScreen, (UINT)ppdev->ulBitCount))
#else
      if(KillOverlay( pPDevice->deWidth,pPDevice->deBitsPixel))
#endif
          bNoOverlayInThisMode = TRUE;
      else
#endif
      {
           // Check bandwidth to find the maximum zoom factor of 16 bit data
          dwZoom = MAX_ZOOM;
          do
          {
            vidConfig.sizDisp.cx = (SRC_WIDTH  * dwZoom) / 1000;
            vidConfig.sizDisp.cy = (SRC_HEIGHT * dwZoom) / 1000;

            if (ChipIsEnoughBandwidth(&gsProgRegs, &vidConfig, &bwregs))
            {
    #ifndef WINNT_VER40
              DBG_MESSAGE(("Maximum zoom factor: %d", dwZoom));
    #endif

              pDDHALInfo->ddCaps.dwMaxOverlayStretch = dwZoom;

    #ifdef WINNT_VER40
              ppdev->DriverData.dwMaxOverlayStretch = dwZoom;
    #endif
              break;
            }
            dwZoom -= ZOOM_STEP;
          } while (dwZoom > 4000);
          if (dwZoom != pDDHALInfo->ddCaps.dwMaxOverlayStretch)
            bNoOverlayInThisMode = TRUE;

          // Check bandwidth to find the minimum zoom factor of 16 bit data
          dwZoom = MIN_ZOOM;
          // disable overlay shrink in 24bpp modes
    #ifdef WINNT_VER40
          if (24 == ppdev->ulBitCount)
    #else
          if (24 == pPDevice->deBitsPixel)
    #endif
            dwZoom = 1000;
          do
          {
            vidConfig.sizDisp.cx = (SRC_WIDTH  * dwZoom) / 1000;
            vidConfig.sizDisp.cy = (SRC_HEIGHT * dwZoom) / 1000;

            if (ChipIsEnoughBandwidth(&gsProgRegs, &vidConfig, &bwregs))
            {
    #ifndef WINNT_VER40
              DBG_MESSAGE(("Minimum zoom factor: %d", dwZoom));
    #endif

              pDDHALInfo->ddCaps.dwMinOverlayStretch = dwZoom;

    #ifdef WINNT_VER40
              ppdev->DriverData.dwMinOverlayStretch = dwZoom;
    #endif
              break;
            }
            dwZoom += ZOOM_STEP;
          } while (dwZoom < 4000);
          if (dwZoom != pDDHALInfo->ddCaps.dwMinOverlayStretch)
            bNoOverlayInThisMode = TRUE;
      }
#ifdef DEBUG
      if (bNoOverlayInThisMode)
      {
        ERRORLOG(("  overlay disabled in %ldx%ldx%ld",
                  (DWORD)pPDevice->deWidth,
                  (DWORD)pPDevice->deHeight,
                  (DWORD)pPDevice->deBitsPixel));
      }
      else
      {
        ERRORLOG(("  overlay colorkey not supported in %ldx%ldx%ld",
                  (DWORD)pPDevice->deWidth,
                  (DWORD)pPDevice->deHeight,
                  (DWORD)pPDevice->deBitsPixel));
      }
#endif
    }
    // see if we're in interlaced mode, if so disable overlay
    if (1 & ((PVGAR)lpDDHALData->RegsAddress)->grCR1A)
      bNoOverlayInThisMode = TRUE;

#if DISABLE_MOST_MODES
    if (bDisableMostModes)
    {
      PVGAR   pREG = (PVGAR)lpDDHALData->RegsAddress;

      // disable overlay support for 1024x768 and above
      if ((1024 <= pPDevice->deWidth) && ( 768 <= pPDevice->deHeight))
        bNoOverlayInThisMode = TRUE;
      // disable overlay support for 640x480x32@85Hz
      if ((640 == pPDevice->deWidth)     &&
          (480 == pPDevice->deHeight)    &&
          ( 32 == pPDevice->deBitsPixel) &&
          (0x33 == pREG->grSRE)          &&
          (0x7E == pREG->grSR1E))
        bNoOverlayInThisMode = TRUE;
      // disable overlay support for 800x600x32@85Hz
      if ((800 == pPDevice->deWidth)     &&
          (600 == pPDevice->deHeight)    &&
          ( 32 == pPDevice->deBitsPixel) &&
          (0x1C == pREG->grSRE)          &&
          (0x37 == pREG->grSR1E))
        bNoOverlayInThisMode = TRUE;
    }
#endif

#if 0
// TDDRAW.EXE error return from UpdateOverlay in to following cases
    if (ppdev->ulBitCount == 8 && ppdev->cxScreen == 1280)
    {
      if ( (ppdev->cyScreen == 1024 && ppdev->ulFreq >= 72) ||
           (ppdev->cyScreen ==  960 && ppdev->ulFreq >= 85) )
        bNoOverlayInThisMode = TRUE;
    }
    if ( ppdev->cxScreen == 640 &&
         ppdev->cyScreen == 350 )
       bNoOverlayInThisMode = TRUE;
#endif// 0

    // if no overlay in this mode set min & max overlay stretch to 0
    if (TRUE == bNoOverlayInThisMode)
    {
      pDDHALInfo->ddCaps.dwMinOverlayStretch = 0;
      pDDHALInfo->ddCaps.dwMaxOverlayStretch = 0;
#ifdef WINNT_VER40
      ppdev->DriverData.dwMinOverlayStretch = 0;
      ppdev->DriverData.dwMaxOverlayStretch = 0;
#endif
    }
  }

#if HWBUG_24BPP_DST_COLORKEY
#ifdef WINNT_VER40
  if (24 == ppdev->ulBitCount)
#else
  if (24 == pPDevice->deBitsPixel)
#endif
  {
    // disable destination colorkey support at 24bpp
    // the hardware appears to be busted
    pDDHALInfo->ddCaps.dwCKeyCaps &= ~(  DDCKEYCAPS_DESTOVERLAY
                                       | DDCKEYCAPS_DESTOVERLAYYUV
                                       | DDCKEYCAPS_DESTOVERLAYONEACTIVE);
  }
#endif

#if 0
  // When double clocking (i.e. 1280x1024), the minimum
  // zoom is 2X.
  if ((gbDoubleClock) && (pDDHALInfo->ddCaps.dwMinOverlayStretch < 2000))
  {
    pDDHALInfo->ddCaps.dwMinOverlayStretch = 2000;
  }

  // don't use overlay in the 1X case.
  if (pDDHALInfo->ddCaps.dwMinOverlayStretch < 1500)
  {
    pDDHALInfo->ddCaps.dwMinOverlayStretch = 1500;
  }

  // Specify destination requirements.
  if ((BITSPERPIXEL == 24) || gbDoubleClock)
  {
    pDDHALInfo->ddCaps.dwCaps |= DDCAPS_ALIGNBOUNDARYDEST
                              |  DDCAPS_ALIGNSIZEDEST
                              ;
    pDDHALInfo->ddCaps.dwAlignBoundaryDest = 4;
    pDDHALInfo->ddCaps.dwAlignSizeDest = 4;
  }
#endif
}

/***************************************************************************
*
* FUNCTION:     IsFormatValid
*
* DESCRIPTION:  This function verifies that the overlay hardware can
*               support the specified format.
*
****************************************************************************/

STATIC HRESULT IsFormatValid
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD dwFourcc,
  DWORD dwBitCount
)
{
  DWORD i;


#ifndef WINNT_VER40
  DBG_MESSAGE(("IsFormatValid (dwFourcc = 0x%08lX, dwBitCount = 0x%08lX)",
               dwFourcc, dwBitCount));
#endif

	// see if we're in interlaced mode
	// if so then don't allow overlay surface to be created
  // also if there isn't enough bandwidth then fail all
  // overlay surface CanCreate requests
  if (bNoOverlayInThisMode || (1 & ((PVGAR)lpDDHALData->RegsAddress)->grCR1A))
    return DDERR_CURRENTLYNOTAVAIL;

  for (i = 0; i < dwNumVideoWindows; i++)
  {
    // see if ddraw thinks the video window is available
    // and make sure VPM isn't using it
    if ((0 == giOvlyCnt[i]) &&
#ifdef WINNT_VER40
        (! IsVWHardwareInUse(ppdev,i))
#else
        (! IsVWHardwareInUse(lpDDHALData,i))
#endif
       )
    {
    #ifndef WINNT_VER40
      DBG_MESSAGE(("Video Window %d available", i));
    #endif

      // I'll say YUCK again!
      // I hate this, what if VPM sneaks in between a CanCreateSurface
      // call and a CreateSurface call and grabs this video window
      // Guess we'll just say the creation succeeded but then fail all use
      // of the video window
      gdwAvailVW = MakeVideoWindowFlag(i);
      break;
    }
  }
  if (dwNumVideoWindows == i)
  {
    DBG_MESSAGE(("All video windows in use, returning FALSE"));
    return DDERR_CURRENTLYNOTAVAIL;
  }

  // only support 5:5:5, 5:6:5 and UYVY overlay surfaces
  if (   ((dwFourcc != BI_RGB) || (dwBitCount != 16))
#if ENABLE_SD_RGB32
      && ((dwFourcc != BI_RGB) || (dwBitCount != 32))
#endif
      && (dwFourcc != BI_BITFIELDS)
      && (dwFourcc != FOURCC_UYVY)
#if ENABLE_YUY2
      && (dwFourcc != FOURCC_YUY2)
#endif
#if ENABLE_YUVPLANAR
      && (dwFourcc != FOURCC_YUVPLANAR)
#endif
     )
  {
#ifndef WINNT_VER40
    DBG_MESSAGE(("IsFormatValid5465: returning FALSE, FourCC = %08lX", dwFourcc));
#endif

    return DDERR_INVALIDPIXELFORMAT;
  }

#ifndef WINNT_VER40
  DBG_MESSAGE(("IsFormatValid5465: returning TRUE, FourCC = %08lX", dwFourcc));
#endif

  return DD_OK;
}

/***************************************************************************
*
* FUNCTION:     CreateSurface
*
* DESCRIPTION:  This function sets various flags depending on what
*               is happening.
*
****************************************************************************/

#ifdef WINNT_VER40
STATIC HRESULT CreateOverlaySurface(
#else
STATIC HRESULT CreateSurface(
#endif
#ifdef WINNT_VER40
  PDEV                      *ppdev,
  PDD_SURFACE_LOCAL         lpSurface,
  DWORD                     dwFourcc
#else
  LPDDRAWI_DDRAWSURFACE_LCL lpSurface,
  DWORD                     dwFourcc,
  LPGLOBALDATA               lpDDHALData
#endif
)
{
  LP_SURFACE_DATA   lpSurfaceData = GET_SURFACE_DATA_PTR(lpSurface);
  DWORD             dwVWIndex;


  // For non-RGB surfaces, we must always specify the block size.
#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay CreateSurface (lpSurface = %08lX, dwFourcc = %08lX)",
               lpSurface, dwFourcc));
#endif

  lpSurfaceData->dwOverlayFlags |= FLG_OVERLAY;

#ifdef WINNT_VER40
	if (gdwAvailVW == 0)
	{
		UINT i;
		for (i = 0; i < dwNumVideoWindows; i++)
		{
			// see if ddraw thinks the video window is available
			// and make sure VPM isn't using it
			if ( (giOvlyCnt[i] == 0) && ! IsVWHardwareInUse(ppdev,i) )
			{
				gdwAvailVW = MakeVideoWindowFlag(i);
				break;
			}
		}
		if (i == dwNumVideoWindows)
		{
			DBG_MESSAGE(("All video windows in use, returning FALSE"));
			return DDERR_CURRENTLYNOTAVAIL;
		}
	}
#endif

  dwVWIndex = GetVideoWindowIndex(gdwAvailVW);
  ASSERT(dwNumVideoWindows > dwVWIndex);
  lpSurfaceData->dwOverlayFlags |= gdwAvailVW;
  gdwFourccVW[dwVWIndex] = dwFourcc;

  if (   (dwFourcc == FOURCC_UYVY)
#if ENABLE_YUY2
      || (dwFourcc == FOURCC_YUY2)
#endif
#if ENABLE_YUVPLANAR
      || (dwFourcc == FOURCC_YUVPLANAR)
#endif
     )
  {
    lpSurface->lpGbl->ddpfSurface.dwYUVBitCount = 16;
    lpSurface->lpGbl->ddpfSurface.dwYBitMask = (DWORD) -1;
    lpSurface->lpGbl->ddpfSurface.dwUBitMask = (DWORD) -1;
    lpSurface->lpGbl->ddpfSurface.dwVBitMask = (DWORD) -1;

    if (dwFourcc == FOURCC_UYVY)
    {
      lpSurfaceData->dwOverlayFlags |= FLG_UYVY;
    }
#if ENABLE_YUY2
    else if (dwFourcc == FOURCC_YUY2)
    {
      lpSurfaceData->dwOverlayFlags |= FLG_YUY2;
    }
#endif
#if ENABLE_YUVPLANAR
    else // if (dwFourcc == FOURCC_YUVPLANAR)
    {
      lpSurfaceData->dwOverlayFlags |= FLG_YUVPLANAR;
      giPlanarCnt++;

      lpSurface->lpGbl->ddpfSurface.dwYUVBitCount = 12;

      //allocate a CLPLInfo structure
      lpSurfaceData->lpCLPLData = HEAP_ALLOC(hSharedHeap,
                                             HEAP_ZERO_MEMORY,
                                             sizeof(CLPLInfo),
                                             OWNER_OVERLAY,
                                             (DWORD)lpSurface);
      if (0 == lpSurfaceData->lpCLPLData)
      {
        return DDERR_OUTOFMEMORY;
      }
      if (bCLPLLobotomyMode)
      {
        LPCLPLSURFACE   lpCLPL = lpSurfaceData->lpCLPLData;
        DWORD           dwSize;

        dwSize = (lpSurface->lpGbl->wWidth * lpSurface->lpGbl->wHeight) / 2;
        lpCLPL->fpUSystemSurface = HEAP_ALLOC(hSharedHeap,
                                              HEAP_ZERO_MEMORY,
                                              dwSize,
                                              OWNER_OVERLAY,
                                              (DWORD)lpSurface);
        if (0 == lpCLPL->fpUSystemSurface)
        {
          return DDERR_OUTOFMEMORY;
        }
        lpCLPL->fpVSystemSurface = (LPVOID)((DWORD)(lpCLPL->fpUSystemSurface) + dwSize / 2);

        DBG_MESSAGE(("CLPL lobotomy mode addrs: USys=%08lX, VSys=%08lX, size=%08lX",
                     lpCLPL->fpUSystemSurface, lpCLPL->fpVSystemSurface, dwSize));
      }
    }
#endif
  }

  if(giOvlyCnt[dwVWIndex] == 0 )
  {
    // save copy of current DTTR value
#if DDRAW_COMPAT >= 50
    gwNotify |= OVERLAY_ON;
    //if VPE is created this variable is already initialized
    if(!(gwNotify & VPE_ON))
#endif
    {
      gwNormalDTTR = ((PVGAR)lpDDHALData->RegsAddress)->grDisplay_Threshold_and_Tiling;
    }
  }
  giOvlyCnt[dwVWIndex]++;

  // CreateSurface32 fills in block size
  return DD_OK;
}

/***************************************************************************
*
* FUNCTION:     DestroySurface
*
* DESCRIPTION:  This does misc things when an overlay surface is
*               destroyed.
*
****************************************************************************/

#ifdef WINNT_VER40
STATIC VOID DestroyOverlaySurface(
#else
STATIC VOID DestroySurface(
#endif
#ifdef WINNT_VER40
  PDEV                    *ppdev,
  PDD_DESTROYSURFACEDATA  lpInput
#else
  LPDDHAL_DESTROYSURFACEDATA lpInput
#endif
)
{
#ifndef WINNT_VER40
  LPGLOBALDATA    lpDDHALData = GetDDHALContext( lpInput->lpDD);
#endif
  LP_SURFACE_DATA lpSurfaceData;
  PVGAR           pREG = (PVGAR)lpDDHALData->RegsAddress;
  DWORD           dwVWIndex;

#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay DestroySurface (lpInput = 0x%08lX)", lpInput));
#endif

  if (0 == lpInput->lpDDSurface->dwReserved1)
  {
    lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return;
  }
  lpSurfaceData = GET_SURFACE_DATA_PTR(lpInput->lpDDSurface);

  dwVWIndex = GetVideoWindowIndex(lpSurfaceData->dwOverlayFlags);
  ASSERT(dwNumVideoWindows > dwVWIndex);

  if (lpSurfaceData->dwOverlayFlags & FLG_ENABLED)
  {
    // Turn the video off
#ifndef WINNT_VER40
    DBG_MESSAGE(("Turning off VW %ld in DestroySurface", dwVWIndex));
#endif

#ifdef WINNT_VER40
    DisableOverlay(ppdev, dwVWIndex);
#else
    DisableOverlay(lpDDHALData, dwVWIndex);
#endif

    lpHardwareOwner[dwVWIndex] = NULL;

    // clear show bit if panning of desktop enabled
  }

#if ENABLE_YUVPLANAR
  if (lpSurfaceData->dwOverlayFlags & FLG_YUVPLANAR)
  {
    if (giPlanarCnt > 0)
    {
      LPCLPLSURFACE   lpCLPL = lpSurfaceData->lpCLPLData;

      giPlanarCnt--;
      if (0 != lpCLPL)
      {
        if ((bCLPLLobotomyMode) && (0 != lpCLPL->fpUSystemSurface))
          HEAP_FREE(hSharedHeap, 0, (LPVOID)lpCLPL->fpUSystemSurface);
        // Free up the memory for the CLPLInfo structure
        HEAP_FREE(hSharedHeap, 0, (LPVOID)lpCLPL);
      }
    }
  }
#endif
  if (lpSurfaceData->dwOverlayFlags & FLG_VW_MASK)
  {
    if (giOvlyCnt[dwVWIndex] > 0)
    {
      if (0 == --giOvlyCnt[dwVWIndex])
      {
        // get current DTTR, mask off FIFO threshold
        WORD CurrentDTTR = pREG->grDisplay_Threshold_and_Tiling & 0xFFC0;

#if DDRAW_COMPAT >= 50
        gvidConfig.dwFlags    &= ~(VCFLG_COLORKEY | VCFLG_CHROMAKEY |
                                      VCFLG_DISP | VCFLG_420);

        gwNotify &= ~OVERLAY_ON;
        if(!(gwNotify & VPE_ON))
#endif
        {
        // Fix PDR 9574: Restore FIFO threshold value when overlay surface
        // is destroyed, do not restore the tile size.
        // If tile size has changed, we are likely in the middle of changing
        // video mode.  No need to resotre FIFO in this case.
          if ( CurrentDTTR == (gwNormalDTTR & 0xFFC0) ) {  // check tile size
             pREG->grDisplay_Threshold_and_Tiling =
                  CurrentDTTR | (gwNormalDTTR & 0x003F); // reset FIFO Threshold
           }
        }
      }
    }
  }

  // Clear up the ownership of Dest ColorKey.
  gdwDestColorKeyOwnerVW &= ~(lpSurfaceData->dwOverlayFlags & FLG_VW_MASK);

  // Clear up the ownership of Src ColorKey.
  gdwSrcColorKeyOwnerVW &= ~(lpSurfaceData->dwOverlayFlags & FLG_VW_MASK);

#if 0
  if (lpInput->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_LIVEVIDEO)
  {
    // Disable Video Capture.
#pragma message("Destroy Surface")
#pragma message("  Who the hell turned on video capture?")
#pragma message("  Shouldn't they shut it off?")
#pragma message("  How do I disable video capture on this fraggin' thing?")
  }
#endif
}

/***************************************************************************
*
* FUNCTION:     FlipOverlaySurface
*
* DESCRIPTION:  This function is called by DDDRV when it wants to flip the
*               overlay surface.
*
****************************************************************************/

STATIC DWORD FlipOverlaySurface
(
#ifdef WINNT_VER40
  PDEV          *ppdev,
  PDD_FLIPDATA  lpFlipData
#else
  LPDDHAL_FLIPDATA lpFlipData
#endif
)
{
#ifndef WINNT_VER40
  LPGLOBALDATA    lpDDHALData = GetDDHALContext( lpFlipData->lpDD);
#endif
  DWORD           dwOffset,dwOffset2;
  LP_SURFACE_DATA lpSurfaceData;
  DWORD           dwFourcc;
  DWORD           dwBitCount;
  PVGAR           pREG = (PVGAR)lpDDHALData->RegsAddress;
  DWORD           dwVWIndex;
#if DDRAW_COMPAT >= 50
  DWORD           dwControl0;
  DWORD           dwSrfFlags = FALSE;
#endif
  DWORD           dwSurfBase, dwSurfOffset;


#ifndef WINNT_VER40
  DBG_MESSAGE(("FlipOverlaySurface (lpFlipData = 0x%08lX)", lpFlipData));
#endif

  if (0 == lpFlipData->lpSurfCurr->dwReserved1)
  {
    lpFlipData->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return DDHAL_DRIVER_HANDLED;
  }
  lpSurfaceData = GET_SURFACE_DATA_PTR(lpFlipData->lpSurfCurr);

  dwVWIndex = GetVideoWindowIndex(lpSurfaceData->dwOverlayFlags);
  ASSERT(dwNumVideoWindows > dwVWIndex);

  // When TVTap/VPM is used with DirectDraw, things got more twisted.
  // VPM doesn't call UpdateSurface, so lpHardwareOwner
  // won't be set, nevertheless, the HW is grabbed by VPM.
  // In that case, should fail the Flip call to prevent bad VPM.

  // YUCK!!!
  // The VWE bit in the hardware seems to be the semaphore for sharing the
  // overlay with VPM

  if ((lpHardwareOwner[dwVWIndex] == NULL) &&
#ifdef WINNT_VER40
      IsVWHardwareInUse(ppdev, dwVWIndex)
#else
      IsVWHardwareInUse(lpDDHALData,dwVWIndex)
#endif
     )
  {
#ifndef WINNT_VER40
    DBG_MESSAGE(("VW %ld already in use, Out of Caps!", dwVWIndex));
#endif

    lpFlipData->ddRVal = DDERR_OUTOFCAPS;
    return (DDHAL_DRIVER_HANDLED);
  }

#ifdef WINNT_VER40
  if(GetOverlayFlipStatus(ppdev, 0, dwVWIndex) != DD_OK || DRAW_ENGINE_BUSY || IN_VBLANK)
#else
  if(GetOverlayFlipStatus(lpDDHALData,0, dwVWIndex) != DD_OK || DRAW_ENGINE_BUSY || IN_VBLANK)
#endif
  {
    lpFlipData->ddRVal = DDERR_WASSTILLDRAWING;
    return DDHAL_DRIVER_HANDLED;
  }

  // Determine the format of the video data
  if (lpFlipData->lpSurfTarg->dwFlags & DDRAWISURF_HASPIXELFORMAT)
  {
    GetFormatInfo (&(lpFlipData->lpSurfTarg->lpGbl->ddpfSurface),
                   &dwFourcc,
                   &dwBitCount);
  }
  else
  {
    dwBitCount = BITSPERPIXEL;
  }

  // Determine the offset to the new area.
#ifdef WINNT_VER40
  dwSurfBase = lpFlipData->lpSurfTarg->lpGbl->fpVidMem;
#else
  dwSurfBase = (lpFlipData->lpSurfTarg->lpGbl->fpVidMem - lpDDHALData->ScreenAddress);
#endif
  dwSurfOffset = lpSurfaceData->dwOverlayOffset;
  dwOffset = dwSurfBase + dwSurfOffset;

#if ENABLE_MIRRORING
  // Flip the overlay surface by changing PSD_STRT_ADDR
  if (bIsVWMirrored[dwVWIndex])
  {
    // for mirroring
    // point to the last byte of the last pixel on the right edge of the source
    dwOffset += (DWORD)(grOverlaySrc[dwVWIndex].right -
                        grOverlaySrc[dwVWIndex].left  - 1);
  }
#endif
  dwOffset2 = 0;
#if DDRAW_COMPAT >= 50
  dwControl0 =  pREG->VideoWindow[dwVWIndex].grVW_CONTROL0;
  if(lpFlipData->lpSurfTarg->lpSurfMore->lpVideoPort != NULL)
  {
     if(( lpFlipData->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_AUTOFLIP)
             &&(lpFlipData->lpSurfTarg->lpSurfMore->lpVideoPort->ddvpInfo.dwVPFlags
                      &DDVP_AUTOFLIP)
             && (lpFlipData->lpSurfTarg->lpAttachListFrom != NULL)
             && (lpFlipData->lpSurfTarg->lpAttachListFrom->lpAttached != NULL))
     {
        dwSrfFlags = DDOVER_AUTOFLIP;
     }
     else if(( lpFlipData->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_BOB)
         &&(lpFlipData->lpSurfTarg->lpSurfMore->lpVideoPort->ddvpInfo.dwVPFlags
           & DDVP_INTERLEAVE))
     {
        dwSrfFlags = DDOVER_BOB;
       //Smooth interlace
       dwOffset2 = dwOffset +
            lpFlipData->lpSurfTarg->lpGbl->lPitch; //point to the next line
     }
  }

  if(dwSrfFlags & DDOVER_BOB)
  {
       //Smooth interlace
       dwOffset2 = dwOffset +
            lpFlipData->lpSurfTarg->lpGbl->lPitch; //point to the next line

  }
  else if(dwSrfFlags & DDOVER_AUTOFLIP)
  {
    //Auto Flip Overlay
        dwOffset2 = lpSurfaceData->dwAutoBaseAddr2 + dwSurfOffset;
        if(dwOffset2 == dwOffset)
        {
           dwOffset = lpSurfaceData->dwAutoBaseAddr1 + dwSurfOffset;
        }
        //For non-smooth-interlaced auto-flip these two address need
        // to be switched.  HW BUG
        if(!(lpFlipData->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_BOB))
        {
           DWORD dwTmp = dwOffset;
           dwOffset = dwOffset2;
           dwOffset2 = dwTmp;
        }
  }
  else if( lpFlipData->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_INTERLEAVED)
  {
    dwControl0 &= ~0x30000;
    if(lpFlipData->dwFlags & DDFLIP_ODD)    //SW flip
    {
        dwOffset2 = dwOffset +
            lpFlipData->lpSurfTarg->lpGbl->lPitch ; //point to the next line
        dwControl0 |= 0x10000;  //use VW_SDD

    }
  }
  else if(lpFlipData->dwFlags & DDFLIP_ODD)    //SW flip
  {
        dwOffset2 = dwOffset;
        dwControl0 &= ~0x30000;
        dwControl0 |= 0x10000;  //use VW_SDD
  }
#endif

  // write new start address to hardware
#ifdef WINNT_VER40
  WaitForVWArmToClear(ppdev,dwVWIndex);
#else
  WaitForVWArmToClear(lpDDHALData,dwVWIndex);
#endif
  ASSERT(! (pREG->VideoWindow[dwVWIndex].grVW_TEST0 & VW_PostImed));

  LL32(VideoWindow[dwVWIndex].grVW_PSD_STRT_ADDR, dwOffset);
  LL32(VideoWindow[dwVWIndex].grVW_SSD_STRT_ADDR, dwOffset2);
#if ENABLE_YUVPLANAR
  if (lpSurfaceData->dwOverlayFlags & FLG_YUVPLANAR)
  {
    // PSD_STRT_ADDR has been set to the start of the Y data in aperture0
    // set PSD_UVSTRT_ADDR to start of UV interleaved data in aperture 0
    // UV data is only half the height of Y data
    LL32(VideoWindow[dwVWIndex].grVW_PSD_UVSTRT_ADDR,
         dwSurfBase +
         (((lpFlipData->lpSurfTarg->lpGbl->wHeight * lpFlipData->lpSurfTarg->lpGbl->lPitch) + 7) & ~7) +
         (dwSurfOffset / 2));
    LL32(VideoWindow[dwVWIndex].grVW_SSD_UVSTRT_ADDR, dwOffset2);
  }
#endif

#if DDRAW_COMPAT >= 50
  if (lpSurfaceData->dwOverlayFlags & FLG_ENABLED)
    pREG->VideoWindow[dwVWIndex].grVW_CONTROL0 = (dwControl0 |VW_VWE | VW_ARM);
  else
    pREG->VideoWindow[dwVWIndex].grVW_CONTROL0 = dwControl0 | VW_ARM;
#else
  if (lpSurfaceData->dwOverlayFlags & FLG_ENABLED)
    pREG->VideoWindow[dwVWIndex].grVW_CONTROL0 |= (VW_VWE | VW_ARM);
  else
    pREG->VideoWindow[dwVWIndex].grVW_CONTROL0 |= VW_ARM;
#endif

#ifdef WINNT_VER40
  // Update the hardware owner
  lpHardwareOwner[dwVWIndex] = lpFlipData->lpSurfTarg;
#endif

  // remember where/when we were when we did the flip
#ifdef WINNT_VER40
  EngQueryPerformanceCounter(&gsOverlayFlip.liFlipTime);
#else
  QueryPerformanceCounter((LARGE_INTEGER *)&gsOverlayFlip.liFlipTime);
#endif
#ifdef WINNT_VER40
  gsOverlayFlip.dwFlipScanline = CurrentVLine(ppdev);
#else
  gsOverlayFlip.dwFlipScanline = CurrentVLine(lpDDHALData);
#endif
  gsOverlayFlip.bFlipFlag = TRUE;
  gsOverlayFlip.fpFlipFrom = lpFlipData->lpSurfCurr->lpGbl->fpVidMem;
  gsOverlayFlip.bHaveEverCrossedVBlank = FALSE;

  if (IN_VBLANK)
  {
    gsOverlayFlip.bWasEverInDisplay = FALSE;
  }
  else
  {
    gsOverlayFlip.bWasEverInDisplay = TRUE;
  }

  lpFlipData->ddRVal = DD_OK;
  return DDHAL_DRIVER_HANDLED;
}

/***************************************************************************
*
* FUNCTION:     LockSurface
*
* DESCRIPTION:  Checks for flipping before allowing access to the surface.
*
****************************************************************************/

STATIC DWORD LockSurface
(
#ifdef WINNT_VER40
  PDEV          *ppdev,
  PDD_LOCKDATA  lpInput
#else
  LPDDHAL_LOCKDATA lpInput
#endif
)
{
#if ENABLE_YUVPLANAR
  LPCLPLSURFACE   lpCLPL;         // pointer to our YUV planar
  DWORD           dwUVOffset;
#endif
  LP_SURFACE_DATA lpSurfaceData;
  DWORD           dwVWIndex;
#ifndef WINNT_VER40
  LPGLOBALDATA    lpDDHALData = GetDDHALContext( lpInput->lpDD);
#endif

#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay LockSurface (lpInput = 0x%08lX)", lpInput));
#endif

  if (0 == lpInput->lpDDSurface->dwReserved1)
  {
    lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return DDHAL_DRIVER_HANDLED;
  }
  lpSurfaceData = GET_SURFACE_DATA_PTR(lpInput->lpDDSurface);

  dwVWIndex = GetVideoWindowIndex(lpSurfaceData->dwOverlayFlags);
  ASSERT(dwNumVideoWindows > dwVWIndex);

  // Check for flipping
  if ((gsOverlayFlip.bFlipFlag) &&
      (
#ifdef WINNT_VER40
       GetOverlayFlipStatus(ppdev, lpInput->lpDDSurface->lpGbl->fpVidMem, dwVWIndex)
#else
       GetOverlayFlipStatus(lpDDHALData,lpInput->lpDDSurface->lpGbl->fpVidMem, dwVWIndex)
#endif
        == DDERR_WASSTILLDRAWING))
  {
    lpInput->ddRVal = DDERR_WASSTILLDRAWING;
    return DDHAL_DRIVER_HANDLED;
  }

#if ENABLE_YUVPLANAR
  if (lpSurfaceData->dwOverlayFlags & FLG_YUVPLANAR)
  {
    // make sure CLPL aperture is mapped in
    if (! lpDDHALData->dwCLPLAperture)
    {
      lpInput->ddRVal = DD_OK;
      return DDHAL_DRIVER_NOTHANDLED;
    }

    // here's how this YUV420/YUVPLANAR/CLPL stuff works:
    // the CLPL surface consists of all the Y data followed by a region of
    // UV interleaved data.  We are currently supporting only linear surfaces
    // for CLPL so there will be wHeight lines of Y data followed by wHeight/2
    // lines of UV interleaved data.  CreateSurface32 has padded the surface
    // allocation such that the UV interleaved data will start on the first
    // quadword boundary following the Y data.
    //
    // We pass back a pointer to a structure containing the address of a Y
    // region, a U region and a V region to the app.  The app writes to the
    // U and V regions as if they are linear and the hardware converts this
    // data into the UV interleaved data in aperture 0.
    //
    // For the U ptr we give the app an address pointing somewhere in the
    // first four meg of aperture 3 and for the V ptr we give the app an
    // address pointing to the same somewhere but in the second four meg
    // of aperture 3.  When the app writes to these addresses, the data
    // shows up in aperture 0 such that:
    //    the U data is at   ap0_offset = ap3_offset * 2
    //    the V data is at   ap0_offset = (ap3_offset - 4MB) * 2 + 1
    //
    // what we need to do then is give the app the folloing ptrs:
    //   Y ptr = ap0_offset of the Y region (the beginning of the surface)
    //   U ptr = ap3_offset for U data = U_ap0_offset / 2
    //   V ptr = ap3_offset for V data = (V_ap0_offset - 1) / 2 + 4MB
    // where U_ap0_offset = offset we want the U data to start
    //   and V_ap0_offset = offset we want the V data to start
    // we also need V_ap0_offset = U_ap0_offset + 1

    // Compute Y and UV aperture in frame buffer
    lpCLPL = (LPCLPLSURFACE)lpSurfaceData->lpCLPLData;
    lpInput->lpSurfData = (LPVOID)lpCLPL;

    // Y data starts at beginning of surface in aperture0
    lpCLPL->fpYSurface = (LPVOID)lpInput->lpDDSurface->lpGbl->fpVidMem;

    DBG_MESSAGE(("Aperture0 Y offset = %08lX",
                 (lpInput->lpDDSurface->lpGbl->fpVidMem - lpDDHALData->ScreenAddress)));
    DBG_MESSAGE(("  surface height = %08lX, pitch = %08lX",
                 lpInput->lpDDSurface->lpGbl->wHeight,
                 lpInput->lpDDSurface->lpGbl->lPitch));

    // determine offset of UV data in aperture 0 (and make it qword aligned)
    dwUVOffset = (lpInput->lpDDSurface->lpGbl->fpVidMem - lpDDHALData->ScreenAddress) +
                 (((lpInput->lpDDSurface->lpGbl->wHeight * lpInput->lpDDSurface->lpGbl->lPitch) + 7) & ~7);
    DBG_MESSAGE(("Aperture0 UV offset = %08lX", dwUVOffset));

    // convert UV aperture0 offset to aperture3 offset
    DBG_MESSAGE(("Aperture3 UV offset = %08lX", dwUVOffset / 2));
    dwUVOffset = lpDDHALData->dwCLPLAperture + dwUVOffset / 2;

    if (bCLPLLobotomyMode)
    {
      lpCLPL->fpRealUSurface = (LPVOID)(dwUVOffset);
      lpCLPL->fpRealVSurface = (LPVOID)(dwUVOffset + 0x400000);
      DBG_MESSAGE(("CLPL lobotomy mode addrs: RealU=%08lX, RealV=%08lX",
                   lpCLPL->fpRealUSurface, lpCLPL->fpRealVSurface));
      lpCLPL->fpUSurface = lpCLPL->fpUSystemSurface;
      lpCLPL->fpVSurface = lpCLPL->fpVSystemSurface;
    }
    else
    {
      lpCLPL->fpUSurface = (LPVOID)(dwUVOffset);
      lpCLPL->fpVSurface = (LPVOID)(dwUVOffset + 0x400000);
    }

    DBG_MESSAGE(("CLPL addrs: Y=%08lX, U=%08lX, V=%08lX",
                 lpCLPL->fpYSurface, lpCLPL->fpUSurface, lpCLPL->fpVSurface));

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
  }
#endif

#if ENABLE_YUY2
  // Force them to use the byte swap aperture
  if (lpSurfaceData->dwOverlayFlags & FLG_YUY2)
  {
    // make sure the YUY2 aperture is mapped in
    if (! lpDDHALData->dwYUY2Aperture)
    {
      lpInput->ddRVal = DD_OK;
      return DDHAL_DRIVER_NOTHANDLED;
    }

    lpInput->lpSurfData = (LPVOID) ((lpInput->lpDDSurface->lpGbl->fpVidMem -
                                     lpDDHALData->ScreenAddress) +
                                     lpDDHALData->dwYUY2Aperture);

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
  }
#endif

  lpInput->ddRVal = DD_OK;
  return DDHAL_DRIVER_NOTHANDLED;
}

#if ENABLE_YUVPLANAR
/***************************************************************************
*
* FUNCTION:    SysToFBCopy()
*
* DESCRIPTION:
*
****************************************************************************/

#if 1
static INLINE VOID
SysToFBCopy ( BYTE *dst, LONG dstPitch, BYTE *src, LONG srcPitch, REG32 ext, LONG bpp )
{
  int yext = ext.pt.Y;
  int xext = ext.pt.X * bpp;

  while (0 < yext--)
  {
    memcpy(dst,src,xext);
    dst += dstPitch;
    src += srcPitch;
  }
}
#else
// writing the scanline from right to left shows the hwbug where roughly
// every other 4 dwords written to aperture3 is dropped
// and the video is generally display with a lovely flourescent green
// checkerboard pattern
//
// This duplicates the problem seen by allowing the Compcore MPEG player
// write directly to aperture3
#pragma optimize("", off)
// the compiler ignores __inline because of the inline assembly
static INLINE VOID
SysToFBCopy ( BYTE *dst, LONG dstPitch, BYTE *src, LONG srcPitch, REG32 ext, LONG bpp )
{
  int yext = ext.pt.Y;
  int xext = ext.pt.X * bpp;

  _asm    std

  dst += dstPitch - sizeof(DWORD);
  src += srcPitch - sizeof(DWORD);

  while (0 < yext--)
  {
    _asm
    {
          mov   eax,xext
          mov   edi,dst
          mov   esi,src
          mov   ecx,eax
          shr   ecx,2
      rep movsd
          mov   ecx,eax
          and   ecx,3
      rep movsb
    }
    dst += dstPitch;
    src += srcPitch;
  }

  _asm    cld
}
#pragma optimize("", on)
#endif
#endif

/***************************************************************************
*
* FUNCTION:     UnlockSurface
*
* DESCRIPTION:  This function is called by DDHAL when it is finished accessing
*               the frame buffer.
*
****************************************************************************/

STATIC VOID UnlockSurface
(
#ifdef WINNT_VER40
  PDEV            *ppdev,
  PDD_UNLOCKDATA  lpInput
#else
  LPDDHAL_UNLOCKDATA lpInput
#endif
)
{
#if ENABLE_YUVPLANAR
  LPCLPLSURFACE   lpCLPL;         // pointer to our YUV planar
#endif
  LP_SURFACE_DATA lpSurfaceData;


#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay UnlockSurface (lpInput = 0x%08lX)", lpInput));
#endif

  if (0 == lpInput->lpDDSurface->dwReserved1)
  {
    lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return;
  }
  lpSurfaceData = GET_SURFACE_DATA_PTR(lpInput->lpDDSurface);

#if ENABLE_YUVPLANAR
  if ((lpSurfaceData->dwOverlayFlags & FLG_YUVPLANAR) && bCLPLLobotomyMode)
  {
    REG32 ext;
    LONG  pitch;

    lpCLPL = (LPCLPLSURFACE)lpSurfaceData->lpCLPLData;

    ext.pt.X = lpInput->lpDDSurface->lpGbl->wWidth / 2;
    ext.pt.Y = lpInput->lpDDSurface->lpGbl->wHeight / 2;
    pitch = lpInput->lpDDSurface->lpGbl->lPitch / 2;

    SysToFBCopy(lpCLPL->fpRealUSurface, pitch, lpCLPL->fpUSystemSurface, pitch, ext, 1);
    SysToFBCopy(lpCLPL->fpRealVSurface, pitch, lpCLPL->fpVSystemSurface, pitch, ext, 1);
  }
#endif
}

/***************************************************************************
*
* FUNCTION:     SetColorKey
*
* DESCRIPTION:  Looks at the color key for changes in the while
*               overlay is active.
*
****************************************************************************/

STATIC VOID SetColorKey
(
#ifdef WINNT_VER40
  PDEV                  *ppdev,
  PDD_SETCOLORKEYDATA   lpInput
#else
  LPDDHAL_SETCOLORKEYDATA lpInput
#endif
)
{
  LP_SURFACE_DATA lpSurfaceData;
  LP_SURFACE_DATA lpHWOwnerData;
  DWORD           dwVWIndex;
#ifndef WINNT_VER40
  LPGLOBALDATA    lpDDHALData = GetDDHALContext( lpInput->lpDD);
#endif

#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay SetColorKey (lpInput = 0x%08lX)", lpInput));
#endif

  if (0 == lpInput->lpDDSurface->dwReserved1)
  {
    lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return;
  }
  lpSurfaceData = GET_SURFACE_DATA_PTR(lpInput->lpDDSurface);

  dwVWIndex = GetVideoWindowIndex(lpSurfaceData->dwOverlayFlags);
  ASSERT(dwNumVideoWindows > dwVWIndex);

  if ((lpInput->dwFlags & DDCKEY_DESTOVERLAY) &&
      (lpInput->lpDDSurface == lpColorSurfaceVW[dwVWIndex]))
  {
    // See if someone else is already using the colorkey.
    if ((gdwDestColorKeyOwnerVW & FLG_VW_MASK) &&
        (lpInput->lpDDSurface != lpColorSurfaceVW[dwVWIndex]))
    {
      // ColorKey already being used.
      lpInput->ddRVal = DDERR_OUTOFCAPS;
      return;
    }

    // You get here only when the call is issued AFTER UpdateOverlay.
    gdwColorKey = lpInput->ckNew.dwColorSpaceLowValue;

    if (0 == lpHardwareOwner[dwVWIndex]->dwReserved1)
    {
      lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
      return;
    }
    lpHWOwnerData = GET_SURFACE_DATA_PTR(lpHardwareOwner[dwVWIndex]);

    if ((lpInput->lpDDSurface == lpColorSurfaceVW[dwVWIndex]) &&
        (lpHardwareOwner[dwVWIndex]) &&
        (lpHWOwnerData->dwOverlayFlags & FLG_ENABLED))
    {
      gdwDestColorKeyOwnerVW = MakeVideoWindowFlag(dwVWIndex);
      lpHWOwnerData->dwOverlayFlags |= FLG_COLOR_KEY;
#ifdef WINNT_VER40
      RegInitVideoVW(ppdev, dwVWIndex, lpHardwareOwner[dwVWIndex]);
#else
      RegInitVideoVW(dwVWIndex, lpHardwareOwner[dwVWIndex],lpDDHALData);
#endif
    }
  }
  else if ((lpInput->dwFlags & DDCKEY_SRCOVERLAY) &&
           (lpInput->lpDDSurface == lpSrcColorSurfaceVW[dwVWIndex]))
  {
    // See if someone else already uses the colorkey.
    if ((gdwSrcColorKeyOwnerVW != 0 ) &&
        !(gdwSrcColorKeyOwnerVW & lpSurfaceData->dwOverlayFlags))
    {
      // ColorKey already been used.
      lpInput->ddRVal = DDERR_OUTOFCAPS;
      return;
    }
    gdwSrcColorKeyLow = lpInput->ckNew.dwColorSpaceLowValue;
    gdwSrcColorKeyHigh = lpInput->ckNew.dwColorSpaceHighValue;
    if (gdwSrcColorKeyLow > gdwSrcColorKeyHigh)
    {
      gdwSrcColorKeyHigh = gdwSrcColorKeyLow;
    }

    if (0 == lpHardwareOwner[dwVWIndex]->dwReserved1)
    {
      lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
      return;
    }
    lpHWOwnerData = GET_SURFACE_DATA_PTR(lpHardwareOwner[dwVWIndex]);

    if ((lpSurfaceData->dwOverlayFlags & FLG_VW_MASK) &&
        (lpHardwareOwner[dwVWIndex]) &&
        (lpHWOwnerData->dwOverlayFlags & FLG_ENABLED))
    {
      gdwSrcColorKeyOwnerVW = MakeVideoWindowFlag(dwVWIndex);
      lpHWOwnerData->dwOverlayFlags |= FLG_SRC_COLOR_KEY;
#ifdef WINNT_VER40
      RegInitVideoVW(ppdev, dwVWIndex, lpHardwareOwner[dwVWIndex]);
#else
      RegInitVideoVW(dwVWIndex, lpHardwareOwner[dwVWIndex],lpDDHALData);
#endif
    }
  }
}

/***************************************************************************
*
* FUNCTION:     SaveRectangles
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE BOOL SaveRectangles
(
#ifdef WINNT_VER40
  PDEV                        *ppdev,
#endif
  DWORD                       dwVWIndex,
  BOOL                        bCheckBandwidth,
  DWORD                       dwBitCount,
#ifdef WINNT_VER40
  PDD_UPDATEOVERLAYDATA       lpInput
#else
  LPDDHAL_UPDATEOVERLAYDATA   lpInput,
  LPGLOBALDATA                lpDDHALData
#endif
)
{
  SIZEL       Dst;
  SIZEL       Src;
  BWREGS      bwregs;

  // Is there sufficient bandwidth to work?

  gvidConfig.sizSrc.cx  = lpInput->rSrc.right  - lpInput->rSrc.left;
  gvidConfig.sizSrc.cy  = lpInput->rSrc.bottom - lpInput->rSrc.top;
  gvidConfig.sizDisp.cx = lpInput->rDest.right  - lpInput->rDest.left;
  gvidConfig.sizDisp.cy = lpInput->rDest.bottom - lpInput->rDest.top;
  gvidConfig.uSrcDepth  = dwBitCount;
  gvidConfig.uDispDepth = dwBitCount;   //video window has the same as source
  gvidConfig.uGfxDepth  = BITSPERPIXEL;
  gvidConfig.dwFlags    |= VCFLG_DISP;
#ifdef WINNT_VER40
  ChipIOReadBWRegs(ppdev, &bwregs);
#else
  ChipIOReadBWRegs(lpDDHALData, &bwregs);
#endif
  if (bCheckBandwidth && bUseBWEqn &&
      !ChipIsEnoughBandwidth(&gsProgRegs, &gvidConfig, &bwregs)
     )
  {
     gvidConfig.dwFlags    &= ~VCFLG_DISP;
    lpInput->ddRVal = DDERR_OUTOFCAPS;
    return FALSE;
  }

  // Save the rectangles
#ifndef WINNT_VER40
  DBG_MESSAGE(("rSrc          = %lX,%lX %lX,%lX",
               lpInput->rSrc.left,lpInput->rSrc.top,
               lpInput->rSrc.right,lpInput->rSrc.bottom));

  DBG_MESSAGE(("rcOverlaySrc  = %lX,%lX %lX,%lX",
               lpInput->lpDDSrcSurface->rcOverlaySrc.left,
               lpInput->lpDDSrcSurface->rcOverlaySrc.top,
               lpInput->lpDDSrcSurface->rcOverlaySrc.right,
               lpInput->lpDDSrcSurface->rcOverlaySrc.bottom));
#endif

  grOverlaySrc[dwVWIndex].left    = (int)lpInput->rSrc.left;
  grOverlaySrc[dwVWIndex].right   = (int)lpInput->rSrc.right;
  grOverlaySrc[dwVWIndex].top     = (int)lpInput->rSrc.top;
  grOverlaySrc[dwVWIndex].bottom  = (int)lpInput->rSrc.bottom;

#ifndef WINNT_VER40
  DBG_MESSAGE(("rDest         = %lX,%lX %lX,%lX",
               lpInput->rDest.left,lpInput->rDest.top,
               lpInput->rDest.right,lpInput->rDest.bottom));

  DBG_MESSAGE(("rcOverlayDest = %lX,%lX %lX,%lX",
               lpInput->lpDDSrcSurface->rcOverlayDest.left,
               lpInput->lpDDSrcSurface->rcOverlayDest.top,
               lpInput->lpDDSrcSurface->rcOverlayDest.right,
               lpInput->lpDDSrcSurface->rcOverlayDest.bottom));
#endif

  grOverlayDest[dwVWIndex].left   = (int)lpInput->rDest.left;
  grOverlayDest[dwVWIndex].right  = (int)lpInput->rDest.right;
  grOverlayDest[dwVWIndex].top    = (int)lpInput->rDest.top;
  grOverlayDest[dwVWIndex].bottom = (int)lpInput->rDest.bottom;

  // make sure resize is within hw capabilities
  // x can shrink down to 1/2 and stretch up to 8x
  // y can stretch up to 8x
  Dst.cx = grOverlayDest[dwVWIndex].right - grOverlayDest[dwVWIndex].left;
  Dst.cy = grOverlayDest[dwVWIndex].bottom - grOverlayDest[dwVWIndex].top;
  Src.cx = grOverlaySrc[dwVWIndex].right  - grOverlaySrc[dwVWIndex].left;
  Src.cy = grOverlaySrc[dwVWIndex].bottom  - grOverlaySrc[dwVWIndex].top;

#ifdef WINNT_VER40
  if (Dst.cx > (LONG)(lpDDHALData->dwMaxOverlayStretch * Src.cx / 1000))
#else
  if (Dst.cx > (LONG)(lpDDHALData->HALInfo.ddCaps.dwMaxOverlayStretch * Src.cx / 1000))
#endif
  {
    lpInput->ddRVal = DDERR_TOOBIGWIDTH;
    return FALSE;
  }
#ifdef WINNT_VER40
  else if (Dst.cy > (LONG)(lpDDHALData->dwMaxOverlayStretch * Src.cy / 1000))
#else
  else if (Dst.cy > (LONG)(lpDDHALData->HALInfo.ddCaps.dwMaxOverlayStretch * Src.cy / 1000))
#endif
  {
    lpInput->ddRVal = DDERR_TOOBIGHEIGHT;
    return FALSE;
  }
#ifdef WINNT_VER40
  else if (Dst.cx < (LONG)(lpDDHALData->dwMinOverlayStretch * Src.cx / 1000))
#else
  else if (Dst.cx < (LONG)(lpDDHALData->HALInfo.ddCaps.dwMinOverlayStretch * Src.cx / 1000))
#endif
  {
    lpInput->ddRVal = DDERR_UNSUPPORTED;    // too small width
    return FALSE;
  }

  if (MIN_OLAY_WIDTH >= Src.cx)
  {
    lpInput->ddRVal = DDERR_OUTOFCAPS;
    return FALSE;
  }

  return TRUE;
}

/***************************************************************************
*
* FUNCTION:     UpdateSurface
*
* DESCRIPTION:
*
****************************************************************************/

STATIC DWORD UpdateSurface
(
#ifdef WINNT_VER40
  PDEV                  *ppdev,
  PDD_UPDATEOVERLAYDATA lpInput
#else
  LPDDHAL_UPDATEOVERLAYDATA lpInput
#endif
)
{
  DWORD             dwOldStatus;
  DWORD             dwFourcc;
  BOOL              bCheckBandwidth;
  DWORD             dwBitCount;
  DWORD             dwDestColorKey;
  LP_SURFACE_DATA   lpSrcSurfaceData;
  DWORD             dwVWIndex;
  DWORD             dwVWFlag;
  BWREGS            bwregs;
  BOOL				bShowOverlay = FALSE;
#ifndef WINNT_VER40
  LPGLOBALDATA    lpDDHALData = GetDDHALContext( lpInput->lpDD);
#endif
#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay UpdateSurface (lpInput = 0x%08lX)", lpInput));
#endif

  if (0 == lpInput->lpDDSrcSurface->dwReserved1)
  {
    lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return DDHAL_DRIVER_HANDLED;
  }
  lpSrcSurfaceData = GET_SURFACE_DATA_PTR(lpInput->lpDDSrcSurface);

  if (lpInput->lpDDSrcSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT)
  {
    GetFormatInfo(&(lpInput->lpDDSrcSurface->lpGbl->ddpfSurface),
                  &dwFourcc, &dwBitCount);
  }
  else
  {
    dwBitCount = BITSPERPIXEL;
    if (16 == dwBitCount)
      dwFourcc = BI_BITFIELDS;    // 5:6:5
    else
      dwFourcc = BI_RGB;          // 8bpp, 5:5:5, 24bpp & 32bpp
  }

  gvidConfig.dwFlags &= ~(VCFLG_COLORKEY | VCFLG_CHROMAKEY |
                          VCFLG_DISP | VCFLG_420);
#if ENABLE_YUVPLANAR
  if (lpSrcSurfaceData->dwOverlayFlags & FLG_YUVPLANAR)
    gvidConfig.dwFlags |= VCFLG_420;
#endif

  // Are we color keying?
  bCheckBandwidth = TRUE;
  dwOldStatus = lpSrcSurfaceData->dwOverlayFlags;

  dwVWIndex = GetVideoWindowIndex(dwOldStatus);
  ASSERT(dwNumVideoWindows > dwVWIndex);
  dwVWFlag = MakeVideoWindowFlag(dwVWIndex);

  lpColorSurfaceVW[dwVWIndex] = lpSrcColorSurfaceVW[dwVWIndex] = NULL;
#if ENABLE_MIRRORING
  bIsVWMirrored[dwVWIndex] = FALSE;
#endif

  if ((lpInput->dwFlags & (DDOVER_KEYDEST | DDOVER_KEYDESTOVERRIDE)) &&
      (lpInput->dwFlags & (DDOVER_KEYSRC | DDOVER_KEYSRCOVERRIDE)))
  {
    // Cannot perform src colorkey and dest colorkey at the same time
    lpInput->ddRVal = DDERR_NOCOLORKEYHW;
    return DDHAL_DRIVER_HANDLED;
  }

#if HWBUG_24BPP_DST_COLORKEY
  if (
#ifdef WINNT_VER40
      (24 == ppdev->ulBitCount) &&
#else
      (24 == pPDevice->deBitsPixel) &&
#endif
      (lpInput->dwFlags & (DDOVER_KEYDEST | DDOVER_KEYDESTOVERRIDE)))
  {
    // destination colorkeying at 24bpp is busted in hardware
    lpInput->ddRVal = DDERR_NOCOLORKEYHW;
    return DDHAL_DRIVER_HANDLED;
  }
#endif

#ifdef WINNT_VER40
  ChipIOReadBWRegs(ppdev, &bwregs);
#else
  ChipIOReadBWRegs(lpDDHALData, &bwregs);
#endif

  lpSrcSurfaceData->dwOverlayFlags &= ~(FLG_COLOR_KEY|FLG_SRC_COLOR_KEY);

#ifndef WINNT_VER40
	if (   (lpInput->dwFlags == 0)
		&& (lpHardwareOwner[dwVWIndex] == NULL)
		&& (lpSrcSurfaceData->dwOverlayFlags & FLG_OVERLAY) )
	{
		bShowOverlay = TRUE;
	}
#endif

  if (lpInput->dwFlags & (DDOVER_KEYDEST | DDOVER_KEYDESTOVERRIDE))
  {
    dwDestColorKey = (lpInput->dwFlags & DDOVER_KEYDEST)
            ? lpInput->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue
            : lpInput->overlayFX.dckDestColorkey.dwColorSpaceLowValue;

    // Allow colorkey override only when it's the original
    // colorkey owner, or no one owns the colorkey so far.
    if (gdwDestColorKeyOwnerVW == 0)
    {
      gdwDestColorKeyOwnerVW = dwVWFlag;
    }
    else if ((dwDestColorKey != gdwColorKey) &&
	  		     (dwOldStatus & dwVWFlag) &&
	  		     !(gdwDestColorKeyOwnerVW & dwVWFlag))
    {
      // ColorKey already been used by someone else.
      // It's not the original colorkey owner,
      // and the key color is not the same as the other one.
      lpInput->ddRVal = DDERR_OUTOFCAPS;
      return DDHAL_DRIVER_HANDLED;
    }

    // Is there sufficient bandwidth to work?
    gvidConfig.sizSrc.cx  = lpInput->rSrc.right  - lpInput->rSrc.left;
    gvidConfig.sizSrc.cy  = lpInput->rSrc.bottom - lpInput->rSrc.top;
    gvidConfig.sizDisp.cx = lpInput->rDest.right  - lpInput->rDest.left;
    gvidConfig.sizDisp.cy = lpInput->rDest.bottom - lpInput->rDest.top;
    gvidConfig.uSrcDepth  = dwBitCount;
    gvidConfig.uDispDepth = dwBitCount; //video window has the same depth as
                                        //the source
    gvidConfig.uGfxDepth  = BITSPERPIXEL;
    gvidConfig.dwFlags   |=  VCFLG_COLORKEY | VCFLG_DISP;

    if (!bUseBWEqn ||
        ChipIsEnoughBandwidth(&gsProgRegs, &gvidConfig, &bwregs)
       )
    {
      bCheckBandwidth = FALSE;
      lpSrcSurfaceData->dwOverlayFlags |= FLG_COLOR_KEY;

      if (lpInput->dwFlags & DDOVER_KEYDEST)
      {
        gdwColorKey = lpInput->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue;
        lpColorSurfaceVW[dwVWIndex] = lpInput->lpDDDestSurface;
      }
      else
      {
        gdwColorKey = lpInput->overlayFX.dckDestColorkey.dwColorSpaceLowValue;
      }
    }
    else
    {
      gvidConfig.dwFlags    &=  ~(VCFLG_COLORKEY | VCFLG_DISP);
      lpInput->ddRVal = DDERR_NOCOLORKEYHW;
      return DDHAL_DRIVER_HANDLED;
    }
  }
  else if (lpInput->dwFlags & (DDOVER_KEYSRC | DDOVER_KEYSRCOVERRIDE))
  {
    // Allow SrcColorKey override only when it's the original
    // colorkey owner, or no one owns the colorkey so far.
    if (gdwSrcColorKeyOwnerVW == 0)
    {
      gdwSrcColorKeyOwnerVW = dwVWFlag;
    }
    else if (!(dwOldStatus & gdwSrcColorKeyOwnerVW))
    {
      // It's not the original colorkey owner
      lpInput->ddRVal = DDERR_OUTOFCAPS;
      return DDHAL_DRIVER_HANDLED;
    }
    // Is there sufficient bandwidth to work?
    gvidConfig.sizSrc.cx  = lpInput->rSrc.right  - lpInput->rSrc.left;
    gvidConfig.sizSrc.cy  = lpInput->rSrc.bottom - lpInput->rSrc.top;
    gvidConfig.sizDisp.cx = lpInput->rDest.right  - lpInput->rDest.left;
    gvidConfig.sizDisp.cy = lpInput->rDest.bottom - lpInput->rDest.top;
    gvidConfig.uSrcDepth  = dwBitCount;
    gvidConfig.uDispDepth = dwBitCount;   //video window has the same as source
    gvidConfig.uGfxDepth  = BITSPERPIXEL;
    gvidConfig.dwFlags   |=  VCFLG_CHROMAKEY | VCFLG_DISP;

    if (!bUseBWEqn ||
        ChipIsEnoughBandwidth(&gsProgRegs, &gvidConfig, &bwregs)
       )
    {
      bCheckBandwidth = FALSE;
      lpSrcSurfaceData->dwOverlayFlags |= FLG_SRC_COLOR_KEY;

      lpSrcColorSurfaceVW[dwVWIndex] = lpInput->lpDDSrcSurface;

      if (lpInput->dwFlags & DDOVER_KEYSRC)
      {
        gdwSrcColorKeyLow = lpInput->lpDDSrcSurface->ddckCKSrcOverlay.dwColorSpaceLowValue;
        gdwSrcColorKeyHigh = lpInput->lpDDSrcSurface->ddckCKSrcOverlay.dwColorSpaceHighValue;
      }
      else
      {
        gdwSrcColorKeyLow = lpInput->overlayFX.dckSrcColorkey.dwColorSpaceLowValue;
        gdwSrcColorKeyHigh = lpInput->overlayFX.dckSrcColorkey.dwColorSpaceHighValue;
      }
      if (gdwSrcColorKeyHigh < gdwSrcColorKeyHigh)
      {
        gdwSrcColorKeyHigh = gdwSrcColorKeyLow;
      }
    }
    else
    {
      gvidConfig.dwFlags &= ~(VCFLG_CHROMAKEY | VCFLG_DISP);
      lpInput->ddRVal = DDERR_NOCOLORKEYHW;
      return DDHAL_DRIVER_HANDLED;
    }
  }

#ifdef WINNT_VER40
#if 0
	// The hardware is broken when using RGB32 data and ShrinkXBy2.
	if (   (dwFourcc == BI_RGB) && (dwBitCount == 32)
		&& (gvidConfig.sizSrc.cx > gvidConfig.sizDisp.cx)
		&& (lpSrcSurfaceData->dwOverlayFlags & (FLG_ENABLED | 0x02000000)) )
	{
		if (lpSrcSurfaceData->dwOverlayFlags & FLG_ENABLED)
		{
			// Turn the video off.
			DisableOverlay(ppdev, dwVWIndex);
			lpHardwareOwner[dwVWIndex] = NULL;
			lpSrcSurfaceData->dwOverlayFlags &= ~FLG_ENABLED;
			lpSrcSurfaceData->dwOverlayFlags |= 0x02000000;
		}

		if (lpSrcSurfaceData->dwOverlayFlags & FLG_VW_MASK)
		{
	    	PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;

			if (giOvlyCnt[dwVWIndex] > 0)
			{
				if (--giOvlyCnt[dwVWIndex] == 0)
				{
					// Get current DTTR, mask off FIFO threshold.
					WORD CurrentDTTR = pREG->grDisplay_Threshold_and_Tiling
							& 0xFFC0;

					// Fix PDR 9574: Restore FIFO threshold value when overlay
					// surface is destroyed, do not restore the tile size.  If
					// tile size has changed, we are likely in the middle of
					// changing video mode.  No need to restore FIFO in this
					// case.
					if ( CurrentDTTR == (gwNormalDTTR & 0xFFC0) )
					{
						pREG->grDisplay_Threshold_and_Tiling = CurrentDTTR
								| (gwNormalDTTR & 0x003F);
					}
				}
			}
		}
		else if (giOvlyCnt[dwVWIndex] > 0)
		{
			giOvlyCnt[dwVWIndex]--;
		}

		// Clear up the ownership of Dest ColorKey.
		gdwDestColorKeyOwnerVW &= ~(lpSrcSurfaceData->dwOverlayFlags
				& FLG_VW_MASK);

		// Clear up the ownership of Src ColorKey.
		gdwSrcColorKeyOwnerVW &= ~(lpSrcSurfaceData->dwOverlayFlags
				& FLG_VW_MASK);

		lpInput->ddRVal = DDERR_OUTOFCAPS;
		return(DDHAL_DRIVER_HANDLED);
	}
#else
	// The hardware is broken when using RGB32 data and ShrinkXBy2.
	if (   (dwFourcc == BI_RGB) && (dwBitCount == 32)
		&& (gvidConfig.sizSrc.cx > gvidConfig.sizDisp.cx)
		&& (lpSrcSurfaceData->dwOverlayFlags & FLG_ENABLED) )
	{
		// Turn the video off.
		DisableOverlay(ppdev, dwVWIndex);
		lpHardwareOwner[dwVWIndex] = NULL;
		lpSrcSurfaceData->dwOverlayFlags &= ~FLG_ENABLED;
		lpSrcSurfaceData->dwOverlayFlags |= 0x02000000;

		if (lpSrcSurfaceData->dwOverlayFlags & FLG_VW_MASK)
		{
	    	PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;

			if (giOvlyCnt[dwVWIndex] > 0)
			{
				if (--giOvlyCnt[dwVWIndex] == 0)
				{
					// Get current DTTR, mask off FIFO threshold.
					WORD CurrentDTTR = pREG->grDisplay_Threshold_and_Tiling
							& 0xFFC0;

					// Fix PDR 9574: Restore FIFO threshold value when overlay
					// surface is destroyed, do not restore the tile size.  If
					// tile size has changed, we are likely in the middle of
					// changing video mode.  No need to restore FIFO in this
					// case.
					if ( CurrentDTTR == (gwNormalDTTR & 0xFFC0) )
					{
						pREG->grDisplay_Threshold_and_Tiling = CurrentDTTR
								| (gwNormalDTTR & 0x003F);
					}
				}
			}
		}
		else if (giOvlyCnt[dwVWIndex] > 0)
		{
			giOvlyCnt[dwVWIndex]--;
		}

		// Clear up the ownership of Dest ColorKey.
		gdwDestColorKeyOwnerVW &= ~(lpSrcSurfaceData->dwOverlayFlags
				& FLG_VW_MASK);

		// Clear up the ownership of Src ColorKey.
		gdwSrcColorKeyOwnerVW &= ~(lpSrcSurfaceData->dwOverlayFlags
				& FLG_VW_MASK);

		lpInput->ddRVal = DDERR_OUTOFCAPS;
		return(DDHAL_DRIVER_HANDLED);
	}
	else if (lpSrcSurfaceData->dwOverlayFlags & 0x02000000)
	{
		if (gvidConfig.sizSrc.cx > gvidConfig.sizDisp.cx)
		{
			lpInput->ddRVal = DDERR_OUTOFCAPS;
			return(DDHAL_DRIVER_HANDLED);
		}
		lpSrcSurfaceData->dwOverlayFlags &= ~0x02000000;
	}
#endif
#endif /* WINNT_VER40 */

  // Because of Microsoft's Overfly bug we must ignore DDOVER_DDFX completely
  // or Overfly reports DDERR_UNSUPPORTED at least in 1024x768x16
  // So these guys can't even write a test app for WHQL that abides by their
  // own rules?
  if (lpInput->dwFlags & DDOVER_DDFX)
  {
#ifndef WINNT_VER40
    DBG_MESSAGE(("  overlayFX.dwFlags = %08lX", lpInput->overlayFX.dwFlags));
    DBG_MESSAGE(("  overlayFX.dwDDFX  = %08lX", lpInput->overlayFX.dwDDFX));
#endif

#if ENABLE_MIRRORING
    if (lpInput->overlayFX.dwDDFX & DDOVERFX_MIRRORLEFTRIGHT)
    {
      bIsVWMirrored[dwVWIndex] = TRUE;
    }
    // For some bizarre reason, Microsoft's WHQL Overfly app sets the
    // DDOVER_DDFX flag but sets overlayFX.dwDDFX with complete junk
    // overlayFX.dwFlags also has junk
    // so we must ignore dwDDFX flags we don't support rather than return an
    // error.  Gee that sound like good practice!
#if 0
    else
    {
      lpInput->ddRVal = DDERR_UNSUPPORTED;
      return DDHAL_DRIVER_HANDLED;
    }
#endif
#endif
  }

#if DDRAW_COMPAT >= 50
  if( lpInput->dwFlags & DDOVER_AUTOFLIP)
  {
      if(lpInput->lpDDSrcSurface->lpSurfMore->lpVideoPort)
      {
         if(lpInput->lpDDSrcSurface->lpSurfMore->lpVideoPort->dwNumAutoflip
            != 2)
         {
             //Hardware only support autoflip between 2 surfaces
             lpInput->ddRVal = DDERR_GENERIC;
             return (DDHAL_DRIVER_HANDLED);
         }
      }
      else
      {
           //Autoflip must use vport
           lpInput->ddRVal = DDERR_INVALIDPARAMS;
           return (DDHAL_DRIVER_HANDLED);
      }
  }
#endif

  if ( (lpInput->dwFlags & DDOVER_SHOW) || bShowOverlay)
  {
    // Is somebody else using our hardware?
    if (((lpHardwareOwner[dwVWIndex] != NULL) &&
         (lpHardwareOwner[dwVWIndex] != lpInput->lpDDSrcSurface)) ||
        ((lpHardwareOwner[dwVWIndex] == NULL) &&
#ifdef WINNT_VER40
         IsVWHardwareInUse(ppdev, dwVWIndex)
#else
         IsVWHardwareInUse(lpDDHALData,dwVWIndex)
#endif
        ))
    {
      lpInput->ddRVal = DDERR_OUTOFCAPS;
      return DDHAL_DRIVER_HANDLED;
    }

    // Is a valid destination surface specified?
    if (!(lpInput->lpDDDestSurface->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE))
    {
      lpInput->ddRVal = DDERR_INVALIDPARAMS;
      return DDHAL_DRIVER_HANDLED;
    }

    // Save the rectangles
#ifdef WINNT_VER40
    if (! SaveRectangles(ppdev, dwVWIndex, bCheckBandwidth, dwBitCount, lpInput))
#else
    if (! SaveRectangles(dwVWIndex, bCheckBandwidth, dwBitCount,lpInput,lpDDHALData))
#endif
    {
      // SaveRectangles sets lpInput->ddRVal on error
      return DDHAL_DRIVER_HANDLED;
    }

#if DDRAW_COMPAT >= 50
    lpInput->lpDDSrcSurface->lpSurfMore->dwOverlayFlags = lpInput->dwFlags;
#endif

    lpHardwareOwner[dwVWIndex] = lpInput->lpDDSrcSurface;
    lpSrcSurfaceData->dwOverlayFlags |= FLG_ENABLED;
#ifdef WINNT_VER40
    RegInitVideoVW(ppdev, dwVWIndex, lpInput->lpDDSrcSurface);
#else
    RegInitVideoVW(dwVWIndex, lpInput->lpDDSrcSurface, lpDDHALData);
#endif
  }
  else if (lpInput->dwFlags & DDOVER_HIDE)
  {
    if (lpHardwareOwner[dwVWIndex] == lpInput->lpDDSrcSurface)
    {
      lpHardwareOwner[dwVWIndex] = NULL;
      // clear panning show bit here

      // Turn the video off
      lpSrcSurfaceData->dwOverlayFlags &= ~FLG_ENABLED;
#ifdef WINNT_VER40
      DisableOverlay(ppdev, dwVWIndex);
#else
      DisableOverlay(lpDDHALData, dwVWIndex);
#endif
    }
  }
  else if (lpHardwareOwner[dwVWIndex] == lpInput->lpDDSrcSurface)
  {
    //Save the rectangles
#ifdef WINNT_VER40
    if (! SaveRectangles(ppdev, dwVWIndex, bCheckBandwidth, dwBitCount, lpInput))
#else
    if (! SaveRectangles(dwVWIndex, bCheckBandwidth, dwBitCount,lpInput,lpDDHALData))
#endif
    {
      // SaveRectangles sets lpInput->ddRVal on error
      return DDHAL_DRIVER_HANDLED;
    }
#if DDRAW_COMPAT >= 50
    lpInput->lpDDSrcSurface->lpSurfMore->dwOverlayFlags = lpInput->dwFlags;
#endif

#ifdef WINNT_VER40
    RegInitVideoVW(ppdev, dwVWIndex, lpInput->lpDDSrcSurface);
#else
    RegInitVideoVW(dwVWIndex, lpInput->lpDDSrcSurface, lpDDHALData);
#endif
  }

  lpInput->ddRVal = DD_OK;
  return DDHAL_DRIVER_HANDLED;
}

/***************************************************************************
*
* FUNCTION:     SetPosition
*
* DESCRIPTION:
*
****************************************************************************/

STATIC DWORD SetPosition
(
#ifdef WINNT_VER40
  PDEV                        *ppdev,
  PDD_SETOVERLAYPOSITIONDATA  lpInput
#else
  LPDDHAL_SETOVERLAYPOSITIONDATA lpInput
#endif
)
{
  LP_SURFACE_DATA   lpSrcSurfaceData;
  DWORD             dwVWIndex;
#ifndef WINNT_VER40
  LPGLOBALDATA    lpDDHALData = GetDDHALContext( lpInput->lpDD);
#endif

#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay SetPosition (lpInput = 0x%08lX)", lpInput));
#endif

  if (0 == lpInput->lpDDSrcSurface->dwReserved1)
  {
    lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return DDHAL_DRIVER_HANDLED;
  }
  lpSrcSurfaceData = GET_SURFACE_DATA_PTR(lpInput->lpDDSrcSurface);

  dwVWIndex = GetVideoWindowIndex(lpSrcSurfaceData->dwOverlayFlags);
  ASSERT(dwNumVideoWindows > dwVWIndex);

  if (lpHardwareOwner[dwVWIndex] == lpInput->lpDDSrcSurface)
  {
    // Update the rectangles
    grOverlayDest[dwVWIndex].right =
              (int)(grOverlayDest[dwVWIndex].right - grOverlayDest[dwVWIndex].left)
                          + (int)lpInput->lXPos;
    grOverlayDest[dwVWIndex].left = (int) lpInput->lXPos;
    grOverlayDest[dwVWIndex].bottom =
              (int)(grOverlayDest[dwVWIndex].bottom - grOverlayDest[dwVWIndex].top)
                          + (int)lpInput->lYPos;
    grOverlayDest[dwVWIndex].top = (int) lpInput->lYPos;

#ifdef WINNT_VER40
    RegMoveVideoVW(ppdev, dwVWIndex, lpInput->lpDDSrcSurface);
#else
    RegMoveVideoVW(dwVWIndex, lpInput->lpDDSrcSurface, lpDDHALData);
#endif
  }

  lpInput->ddRVal = DD_OK;
  return DDHAL_DRIVER_HANDLED;
}

/***************************************************************************
*
* FUNCTION:     GetOverlayFlipStatus
*
* DESCRIPTION:
*
****************************************************************************/

STATIC DWORD GetOverlayFlipStatus
(
#ifdef WINNT_VER40
  PDEV    *ppdev,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  FLATPTR fpVidMem,
  DWORD   dwVWIndex
)
{
  if (gsOverlayFlip.bFlipFlag &&
      ((fpVidMem == 0) || (fpVidMem == gsOverlayFlip.fpFlipFrom)))
  {
#if 1
    // if arm bit is set then some action is still pending
    // so fail
    ASSERT(dwNumVideoWindows > dwVWIndex);
    if (VW_ARM & ((PVGAR)lpDDHALData->RegsAddress)->VideoWindow[dwVWIndex].grVW_CONTROL0)
      return (DWORD)DDERR_WASSTILLDRAWING;
#else
    __int64 ttime;
    int     iTemp;


    DBG_MESSAGE(("GetOverlayFlipStatus (fpVidMem = 0x%08lX)", fpVidMem));

    // If the current scanline is less than the flip scan line,
    // we know that a VSYNC has occurred.
    iTemp = CurrentVLine(lpDDHALData);
    if (gsOverlayFlip.dwFlipScanline > (DWORD) iTemp)
    {
      // Don't allow access during the vertical retrace
      if (iTemp == 0)
      {
        if (gsOverlayFlip.bWasEverInDisplay)
        {
          gsOverlayFlip.bHaveEverCrossedVBlank = TRUE;
        }
        return (DWORD)DDERR_WASSTILLDRAWING;
      }
    }

    // Otherwise, we can check to see if 1) we have ever
    // been in a vertical retrace or 2) if a fixed amount of time
    // has expired.
    else if (gsOverlayFlip.bHaveEverCrossedVBlank == FALSE)
    {
      gsOverlayFlip.bWasEverInDisplay = TRUE;
      QueryPerformanceCounter((LARGE_INTEGER *)&ttime);
      if ((ttime-gsOverlayFlip.liFlipTime) <= gsOverlayFlip.dwFlipDuration)
      {
        return (DWORD)DDERR_WASSTILLDRAWING;
      }
    }
#endif
    gsOverlayFlip.bFlipFlag = FALSE;
  }

  return DD_OK;
}

/***************************************************************************
*
* FUNCTION:     ComputeVWZoomCodes
*
* DESCRIPTION:  Computes HACCUM_STP, HACCUM_SD,
*                        VACCUM_STP, VACCUM_SDA and VACCUM_SDB
*
****************************************************************************/

STATIC VOID ComputeVWZoomCodes
(
#ifdef WINNT_VER40
  PDEV    *ppdev,
#endif
  DWORD   dwVWIndex,
  VWDATA  *pVWData
)
{
  SIZEL Dst;
  SIZEL Src;


  Dst.cx = grOverlayDest[dwVWIndex].right - grOverlayDest[dwVWIndex].left;
  Src.cx = grOverlaySrc[dwVWIndex].right  - grOverlaySrc[dwVWIndex].left;

  if (Dst.cx == Src.cx)
  {
    // no horizontal resize
    pVWData->HACCUM_STP = 0x00010000;
  }
  else if (Dst.cx > Src.cx)
  {
    // make sure we aren't going beyond hw capabilities
    ASSERT(Dst.cx <= 8 * Src.cx);

    // horizontal stretch
    //
    // ideally zoom code = 256 * (256 * Src.cx / Dst.cx)
    // we always want to truncate (256 * Src.cy / Dst.cx)
    // because truncating will give us back a Src.cx which is less than or
    // equal to the actual width of the source and we will never overrun the
    // source extent (and won't get the green stripe)
    pVWData->HACCUM_STP = (256 * 256 * Src.cx) / Dst.cx;
  }
  else
  {
    // make sure we aren't going beyond hw capabilities
    ASSERT(2 * Dst.cx >= Src.cx);

    // horizontal shrink
    //
    // this is the zoom code for Src.cx/2 be stretched to Dst.cx

    // using 128 seems to give a zoom code one too high
    // then we get the green stripe on the right edge of the video
    pVWData->HACCUM_STP = (256 * 127 * Src.cx) / Dst.cx;
    pVWData->CONTROL0 |= VW_XShrinkBy2;
  }
  // Just set horizontal seeds to zero for now
  pVWData->HACCUM_SD = 0;

  Dst.cy = grOverlayDest[dwVWIndex].bottom - grOverlayDest[dwVWIndex].top;
  Src.cy = grOverlaySrc[dwVWIndex].bottom  - grOverlaySrc[dwVWIndex].top;

  if (Dst.cy == Src.cy)
  {
    pVWData->VACCUM_STP = 0x00010000;
  }
  else if (Dst.cy > Src.cy)
  {
    // make sure we aren't going beyond hw capabilities
    ASSERT(Dst.cy <= 8 * Src.cy);

    // vertical stretch
    //
    // ideally zoom code = 256 * (256 * Src.cy / Dst.cy)
    // we always want to truncate (256 * Src.cy / Dst.cy)
    // because truncating will give us back a Src.cy which is less than or
    // equal to the actual size of the source and we will never overrun the
    // source extent (and won't get the green stripe)

    // using 256 seems to give a zoom code one too high for full screen
    // then we get garbage on the bottom of the screen
    pVWData->VACCUM_STP = (256 * 255 * Src.cy) / Dst.cy;
  }
  else
  {
    // vertical shrink
    //
    // ideally zoom code = 256 * (256 * Dst.cy / Src.cy)
    // we always want to round up (256 * Dst.cy / Src.cy)
    // because rounding up will give us back a Src.cy which is less than or
    // equal to the actual size of the source and we will never overrun the
    // source extent (and won't get the green stripe)
    pVWData->VACCUM_STP = (256 * 256 * Dst.cy + 256 * (Src.cy - 1)) / Src.cy;
    pVWData->CONTROL1 |= VW_YShrinkEn;
 }
  // Just set vertical seeds to zero for now
  pVWData->VACCUM_SDA = 0;
  pVWData->VACCUM_SDB = 0;
}

/***************************************************************************
*
* FUNCTION:     ComputeVWPositionData
*
* DESCRIPTION:  Computes HSTRT, HEND, HSDSZ, VSTRT, VEND,
*                        PD_STRT_ADDR and SD_PITCH
*
****************************************************************************/

STATIC VOID
ComputeVWPositionData ( PRECTL                      pVideoRect,
                        PRECTL                      pOverlaySrc,
                        PRECTL                      pOverlayDest,
#ifdef WINNT_VER40
                        PDD_SURFACE_GLOBAL          pGbl,
#else
                        LPDDRAWI_DDRAWSURFACE_GBL   pGbl,
                        LPGLOBALDATA                lpDDHALData,
#endif
                        DWORD                       dwBitCount,
                        VWDATA                      *pVWData,
                        BOOL                        bCLPL )
{
  DWORD   dwSurfBase,dwSurfOffset;


  pVWData->HSTRT = LOWORD(pVideoRect->left);
  pVWData->HEND  = LOWORD(pVideoRect->right) - 1;
  pVWData->HSDSZ = (WORD)(pOverlaySrc->right - pOverlaySrc->left);

  pVWData->VSTRT = LOWORD(pVideoRect->top);
  pVWData->VEND  = LOWORD(pVideoRect->bottom) - 1;

#ifdef WINNT_VER40
  dwSurfBase = pGbl->fpVidMem;
#else
  dwSurfBase = (pGbl->fpVidMem - lpDDHALData->ScreenAddress);
#endif
  dwSurfOffset = pOverlaySrc->top * pGbl->lPitch +
                 pOverlaySrc->left * (dwBitCount / 8);
  pVWData->PSD_STRT_ADDR = dwSurfBase + dwSurfOffset;

#if ENABLE_YUVPLANAR
  if (bCLPL)
  {
    // qword aligned offset of UV interleaved data in aperture 0
    // need same offset into UV data as offset into Y data
    // so it's just PSD_STRT_ADDR plus area of Y data
    pVWData->PSD_UVSTRT_ADDR = dwSurfBase +
                               (((pGbl->wHeight * pGbl->lPitch) + 7) & ~7) +
                               (dwSurfOffset / 2);
  }
  else
    pVWData->PSD_UVSTRT_ADDR = 0;
#endif

#if ENABLE_MIRRORING
  if (bIsVWMirrored[dwVWIndex])
  {
    // for mirroring
    // point to the last byte of the last pixel on the right edge of the source
    pVWData->PSD_STRT_ADDR += (DWORD)(pOverlaySrc->right - pOverlaySrc->left  - 1);
  }
#endif

  pVWData->SD_PITCH = (WORD)(pGbl->lPitch);
}

/***************************************************************************
*
* FUNCTION:     RGBtoYCrCb
*
* DESCRIPTION:  Conversion equations are from page 42 of the second edition
*               of "Video Demystified" by Keith Jack
*
****************************************************************************/

STATIC DWORD INLINE
RGBtoYCbCr ( DWORD dwRGB )
{
  long  Y, Cr, Cb;
  long  r, g, b;


  r = (dwRGB & 0xF800) >> 8;
  g = (dwRGB & 0x07E0) >> 3;
  b = (dwRGB & 0x001F) << 3;

  Y  = ( 77 * r + 150 * g +  29 * b) / 256;
  // max value of Y from this is if r, g & b are all 255 then Y = 255
  // min value of Y from this is if r, g & b are all   0 then Y = 0
  // so don't need to clamp Y

  Cb = (-44 * r -  87 * g + 131 * b) / 256 + 128;
  // max value of Cb is if r & g are 0 and b is 255 then Cb = 258
  // min value of Cb is if r & g are 255 and b is 0 then Cb =  -2
  // so need to clamp Cb between 0 and 255
  if (255 < Cb)
    Cb = 255;
  else if (0 > Cb)
    Cb = 0;

  Cr = (131 * r - 110 * g -  21 * b) / 256 + 128;
  // max value of Cr is if r is 255 and g & b are 0 then Cr = 258
  // min value of Cr is if r is 0 and g & b are 255 then Cr =  -2
  // so need to clamp Cr between 0 and 255
  if (255 < Cr)
    Cr = 255;
  else if (0 > Cr)
    Cr = 0;

  return (((Y & 0xFF) << 16) | ((Cb & 0xFF) << 8) | ((Cr & 0xFF)));
}

/***************************************************************************
*
* FUNCTION:     DetermineVWColorKeyData
*
* DESCRIPTION:  Determines CLRKEY_MIN & CLRKEY_MAX or
*                          CHRMKEY_MIN & CHRMKEY_MAX
*
****************************************************************************/

STATIC VOID DetermineVWColorKeyData
(
#ifdef WINNT_VER40
  PDEV    *ppdev,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD   dwOverlayFlags,
  DWORD   dwBitCount,
  VWDATA  *pVWData
)
{
  if (FLG_COLOR_KEY & dwOverlayFlags)
  {
    // destination color key, uses color key on 5465
    pVWData->CLRKEY_MIN = gdwColorKey;
    pVWData->CLRKEY_MAX = gdwColorKey;
    pVWData->CONTROL0 &= ~VW_OCCLUDE_MASK;
    pVWData->CONTROL0 |= (COLOR_KEY << OCCLUDE_SHIFT);
  }
  else if (FLG_SRC_COLOR_KEY & dwOverlayFlags)
  {
    PVGAR     pREG = (PVGAR)lpDDHALData->RegsAddress;
    BYTE      r,g,b;

    // source color key, uses chroma key on 5465
    switch (dwBitCount)
    {
      case  8:
        // read colors from the DAC
        LL8(grPalette_Read_Address,(BYTE)(gdwSrcColorKeyLow & 0xFF));
        r = pREG->grPalette_Data;
        g = pREG->grPalette_Data;
        b = pREG->grPalette_Data;
        pVWData->CHRMKEY_MIN = ((DWORD)(r) << 16) |
                               ((DWORD)(g) <<  8) |
                               ((DWORD)(b));
        LL8(grPalette_Read_Address,(BYTE)(gdwSrcColorKeyHigh & 0xFF));
        r = pREG->grPalette_Data;
        g = pREG->grPalette_Data;
        b = pREG->grPalette_Data;
        pVWData->CHRMKEY_MAX = ((DWORD)(r) << 16) |
                               ((DWORD)(g) <<  8) |
                               ((DWORD)(b));
        break;

      case 16:

        if ((FLG_UYVY | FLG_YUY2) & dwOverlayFlags)
        {
          // Since we are currently using ITU 601 compliant YUV data
          // convert color key to YCrCb
          pVWData->CHRMKEY_MIN = RGBtoYCbCr(gdwSrcColorKeyLow);
          pVWData->CHRMKEY_MAX = RGBtoYCbCr(gdwSrcColorKeyHigh);
        }
        else
        {
          // convert 5:6:5 to true color
          pVWData->CHRMKEY_MIN = ((gdwSrcColorKeyLow  & 0xF800) << 8) |   // red
                                 ((gdwSrcColorKeyLow  & 0x07E0) << 5) |   // green
                                 ((gdwSrcColorKeyLow  & 0x001F) << 3);    // blue
          pVWData->CHRMKEY_MAX = ((gdwSrcColorKeyHigh & 0xF800) << 8) |   // red
                                 ((gdwSrcColorKeyHigh & 0x07E0) << 5) |   // green
                                 ((gdwSrcColorKeyHigh & 0x001F) << 3);    // blue
        }
        break;

      case 24:
      case 32:
        pVWData->CHRMKEY_MIN = (gdwSrcColorKeyLow  & 0x00FFFFFF);
        pVWData->CHRMKEY_MAX = (gdwSrcColorKeyHigh & 0x00FFFFFF);
        break;
    }
    pVWData->CONTROL0 &= ~VW_OCCLUDE_MASK;
    pVWData->CONTROL0 |= (CHROMA_KEY << OCCLUDE_SHIFT);
  }
  else
  {
    pVWData->CONTROL0 &= ~VW_OCCLUDE_MASK;
    pVWData->CONTROL0 |= (NO_OCCLUSION << OCCLUDE_SHIFT);
  }
}

/***************************************************************************
*
* FUNCTION:     ComputeVWFifoThreshold
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE VOID ComputeVWFifoThreshold
(
#ifdef WINNT_VER40
  PDEV    *ppdev,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  VWDATA  *pVWData
)
{
  PVGAR   pREG = (PVGAR)lpDDHALData->RegsAddress;


  pREG->grDisplay_Threshold_and_Tiling =
                      (pREG->grDisplay_Threshold_and_Tiling & 0xFFC0) |
                      (gsProgRegs.DispThrsTiming & 0x003F);

  pVWData->FIFO_THRSH = gsProgRegs.VW0_FIFO_THRSH;
}

/***************************************************************************
*
* FUNCTION:     PanOverlay1_Init
*
* DESCRIPTION:  Save data for panning overlay window one.
*               Clip lpVideoRect to panning viewport.
*
****************************************************************************/

static INLINE VOID PanOverlay1_Init
(
#ifdef WINNT_VER40
  PDEV    *ppdev,
#endif
  LPRECTL lpVideoRect,
  LPRECTL lpOverlaySrc,
  LPRECTL lpOverlayDest
)
{
  // This is not necessary on Laguna since we can't pan the screen

  // clip left edge of destination
  if (0 > (lpVideoRect->left = lpOverlayDest->left))
    lpVideoRect->left = 0;

  // clip right edge of destination
#ifdef WINNT_VER40
  if ((LONG)ppdev->cxScreen < (lpVideoRect->right = lpOverlayDest->right))
    lpVideoRect->right = (LONG)ppdev->cxScreen;
#else
  if ((LONG)pPDevice->deWidth < (lpVideoRect->right = lpOverlayDest->right))
    lpVideoRect->right = (LONG)pPDevice->deWidth;
#endif

  // clip top edge of destination
  if (0 > (lpVideoRect->top = lpOverlayDest->top))
    lpVideoRect->top = 0;

  // clip bottom edge of destination
#ifdef WINNT_VER40
  if ((LONG)ppdev->cyScreen < (lpVideoRect->bottom = lpOverlayDest->bottom))
    lpVideoRect->bottom = (LONG)ppdev->cyScreen;
#else
  if ((LONG)pPDevice->deHeight < (lpVideoRect->bottom = lpOverlayDest->bottom))
    lpVideoRect->bottom = (LONG)pPDevice->deHeight;
#endif
}

/***************************************************************************
*
* FUNCTION:     RegInitVideoVW
*
* DESCRIPTION:  This function is called to program the video format and
*               the physical offset of the Video Window video data
*               in the frame buffer.
*
****************************************************************************/

STATIC BOOL RegInitVideoVW
(
#ifdef WINNT_VER40
  PDEV              *ppdev,
  DWORD             dwVWIndex,
  PDD_SURFACE_LOCAL lpSurface
#else
  DWORD                     dwVWIndex,
  LPDDRAWI_DDRAWSURFACE_LCL lpSurface,
  LPGLOBALDATA              lpDDHALData
#endif
)
{
  LP_SURFACE_DATA   lpSurfaceData = GET_SURFACE_DATA_PTR(lpSurface);
  VWDATA            VWData;
  BOOL              bOverlayTooSmall = FALSE;
  DWORD             dwFourcc;
  LONG              lPitch;
  DWORD             dwBitCount;
  RECTL             rVideoRect;
  PVGAR             pREG = (PVGAR)lpDDHALData->RegsAddress;
#if DDRAW_COMPAT >= 50
  DWORD             dwSrfFlags = FALSE;
#endif
  DWORD             width;
//////#ifndef WINNT_VER40
  PDD_ATTACHLIST    lpSurfaceAttached;
  LP_SURFACE_DATA   lpSurfaceDataTmp;
//////#endif

  ASSERT(dwNumVideoWindows > dwVWIndex);

  // Determine the format of the video data
  if (lpSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT)
  {
    GetFormatInfo(&(lpSurface->lpGbl->ddpfSurface), &dwFourcc, &dwBitCount);
  }
  else
  {
    dwBitCount = BITSPERPIXEL;
    if (16 == dwBitCount)
      dwFourcc = BI_BITFIELDS;    // 5:6:5
    else
      dwFourcc = BI_RGB;          // 8bpp, 5:5:5, 24bpp & 32bpp
  }

#ifdef WINNT_VER40
  PanOverlay1_Init(ppdev,&rVideoRect,&grOverlaySrc[dwVWIndex],&grOverlayDest[dwVWIndex]);
#else
  PanOverlay1_Init(&rVideoRect,&grOverlaySrc[dwVWIndex],&grOverlayDest[dwVWIndex]);
#endif

  // rVideoRect is now adjusted and clipped to the panning viewport.
  // Disable overlay if totally clipped by viewport.
  if (((rVideoRect.right - rVideoRect.left) <= 0) ||
      ((rVideoRect.bottom- rVideoRect.top ) <= 0))
  {
#ifdef WINNT_VER40
    DisableOverlay(ppdev, dwVWIndex);
#else
    DisableOverlay(lpDDHALData,dwVWIndex);
#endif
    return TRUE;
  }

  memset(&VWData, 0, sizeof(VWData));

  lPitch = lpSurface->lpGbl->lPitch;

#ifdef WINNT_VER40
  ComputeVWZoomCodes(ppdev, dwVWIndex, &VWData);
#else
  ComputeVWZoomCodes(dwVWIndex, &VWData);
#endif

  ComputeVWPositionData(&rVideoRect,
                        &grOverlaySrc[dwVWIndex],
                        &grOverlayDest[dwVWIndex],
                        lpSurface->lpGbl,
#ifndef     WINNT_VER40
                        lpDDHALData,
#endif
                        dwBitCount,
                        &VWData,
                        FOURCC_YUVPLANAR == dwFourcc);

   lpSurfaceData->dwOverlayOffset =  //This offset will be used in FlipOverlay
          VWData.PSD_STRT_ADDR  -  // and VPE
         lpSurface->lpGbl->fpVidMem
#ifndef WINNT_VER40
         + lpDDHALData->ScreenAddress
#endif
         ;

/////////#ifndef WINNT_VER40

 //Update all the attached surfaces
 lpSurfaceAttached = lpSurface->lpAttachListFrom;

 while( lpSurfaceAttached)
 {
    if(lpSurfaceAttached->lpAttached)
    {
       lpSurfaceDataTmp = GET_SURFACE_DATA_PTR(lpSurfaceAttached->lpAttached);
       lpSurfaceDataTmp->dwOverlayOffset = lpSurfaceData->dwOverlayOffset;
       lpSurfaceAttached = lpSurfaceAttached->lpAttached->lpAttachListFrom;
    }
    else
        break;

 }
 
 lpSurfaceAttached = lpSurface->lpAttachList;

 while( lpSurfaceAttached)
 {
    if(lpSurfaceAttached->lpAttached)
    {
       lpSurfaceDataTmp = GET_SURFACE_DATA_PTR(lpSurfaceAttached->lpAttached);
       lpSurfaceDataTmp->dwOverlayOffset = lpSurfaceData->dwOverlayOffset;
       lpSurfaceAttached = lpSurfaceAttached->lpAttached->lpAttachList;
    }
    else
        break;

 }

//////////#endif

#if ENABLE_MIRRORING
  // Mirror Video Windows support.
  if (bIsVWMirrored[dwVWIndex])
    VWData.CONTROL0 |= VW_HMIRR_EN;
#endif
  // Xing, isn't the memset above enough?
  VWData.SSD_STRT_ADDR = 0L;
#if DDRAW_COMPAT >= 50
  if (gwNotify & VPE_ON)
  {
    if((lpSurface->lpSurfMore->lpVideoPort != NULL)&&
       (lpSurface->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT))
    {
      if((lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_BOB)
         &&(lpSurface->lpSurfMore->lpVideoPort->ddvpInfo.dwVPFlags
                & DDVP_INTERLEAVE))
      {
        dwSrfFlags = DDOVER_BOB;
      }
      else if((lpSurface->lpSurfMore->lpVideoPort->ddvpInfo.dwVPFlags
                    &DDVP_AUTOFLIP)
            &&(lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_AUTOFLIP)
            && (lpSurface->lpAttachListFrom != NULL)
            && (lpSurface->lpAttachListFrom->lpAttached != NULL))
      {
          dwSrfFlags = DDOVER_AUTOFLIP;
      }
    }
  }

  if((dwSrfFlags & DDOVER_BOB)
   ||(!dwSrfFlags
    &&(lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_INTERLEAVED)))
  {
      RECTL   rcTemp;
       rcTemp = grOverlaySrc[dwVWIndex];
       grOverlaySrc[dwVWIndex].top >>=1;
       grOverlaySrc[dwVWIndex].bottom >>=1;    //use half source size to
       VWData.CONTROL1 &= ~VW_YShrinkEn;       //find zoom factor
       ComputeVWZoomCodes(dwVWIndex, &VWData);
       grOverlaySrc[dwVWIndex] = rcTemp;

       VWData.SD_PITCH <<= 1;
       VWData.CONTROL0 &= ~0x30000ul;
       if(dwSrfFlags & DDOVER_BOB)
       {
           VWData.SSD_STRT_ADDR = VWData.PSD_STRT_ADDR + lPitch;
           VWData.CONTROL0 |= 0x20000ul;        //enable buffer two
       }

  }
  else if(dwSrfFlags & DDOVER_AUTOFLIP)
  {

     VWData.SSD_STRT_ADDR =  lpSurfaceData->dwAutoBaseAddr2 +
                                  lpSurfaceData->dwOverlayOffset;
     if( VWData.PSD_STRT_ADDR == VWData.SSD_STRT_ADDR )
     {
          VWData.PSD_STRT_ADDR = lpSurfaceData->dwAutoBaseAddr1 +
                                   lpSurfaceData->dwOverlayOffset;
      }

      VWData.CONTROL0 &= ~0x30000ul;
      VWData.CONTROL0 |= 0x20000ul;     //enable the second buffer
      if(!(lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_BOB))
      {
        //For non-smooth-interlaced auto-flip these two address need
        // to be switched.  HW BUG
         DWORD dwTmp = VWData.PSD_STRT_ADDR;
         VWData.PSD_STRT_ADDR = VWData.SSD_STRT_ADDR;
         VWData.SSD_STRT_ADDR = dwTmp;
      }
  }

  if(lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_BOB)
  {
     BOOL fSDAHalf = TRUE;
#if ENABLE_MIRRORING
     if (lpInput->overlayFX.dwDDFX & DDOVERFX_MIRRORLEFTRIGHT)
         fSDAHalf = !fSDAHalf;
#endif
     if(VWData.VACCUM_STP >= 0x8000ul)
          fSDAHalf = !fSDAHalf;

     if(fSDAHalf)
     {
            VWData.VACCUM_SDA = 0x8000ul;
            VWData.VACCUM_SDB = 0ul;
     }
     else
     {
            VWData.VACCUM_SDA = 0ul;
            VWData.VACCUM_SDB = 0x8000ul;
     }
     VWData.CONTROL0 |= 0x8ul;
  }
#endif

  if (lpSurfaceData->dwOverlayFlags & FLG_ENABLED)
    VWData.CONTROL0 |= (VW_VWE | VW_ARM);

  // set source data format
  if (dwFourcc == BI_RGB)
  {
    if (dwBitCount == 16)
    {
      VWData.CONTROL0 |= (SD_RGB16_555 << SD_FRMT_SHIFT);
    }
#if ENABLE_SD_RGB32
    else if (dwBitCount == 32)
    {
      VWData.CONTROL0 |= (SD_RGB32 << SD_FRMT_SHIFT);
    }
#endif
  }
  else if (dwFourcc == BI_BITFIELDS)
  {
    VWData.CONTROL0 |= (SD_RGB16_565 << SD_FRMT_SHIFT);
  }
#if ENABLE_YUVPLANAR
  else if (dwFourcc == FOURCC_YUVPLANAR)
  {
    VWData.CONTROL0 |= (SD_YUV420 << SD_FRMT_SHIFT);
  }
#endif
  else if (FOURCC_UYVY == dwFourcc)
  {
    VWData.CONTROL0 |= (SD_YUV422 << SD_FRMT_SHIFT);
  }

#ifdef WINNT_VER40
  DetermineVWColorKeyData(ppdev, lpSurfaceData->dwOverlayFlags, dwBitCount, &VWData);
#else
  DetermineVWColorKeyData(lpDDHALData,lpSurfaceData->dwOverlayFlags, dwBitCount, &VWData);
#endif

#ifdef WINNT_VER40
  ComputeVWFifoThreshold(ppdev, &VWData);
#else
  ComputeVWFifoThreshold(lpDDHALData,&VWData);
#endif

  // Now start programming the registers
#ifdef WINNT_VER40
  WaitForVWArmToClear(ppdev, dwVWIndex);
#else
  WaitForVWArmToClear(lpDDHALData, dwVWIndex);
#endif
  ASSERT(! (pREG->VideoWindow[dwVWIndex].grVW_TEST0 & VW_PostImed));

  LL16(VideoWindow[dwVWIndex].grVW_HSTRT,         VWData.HSTRT);
  LL16(VideoWindow[dwVWIndex].grVW_HEND,          VWData.HEND);
  LL16(VideoWindow[dwVWIndex].grVW_HSDSZ,         VWData.HSDSZ);
  LL32(VideoWindow[dwVWIndex].grVW_HACCUM_STP,    VWData.HACCUM_STP);
  LL32(VideoWindow[dwVWIndex].grVW_HACCUM_SD,     VWData.HACCUM_SD);
  LL16(VideoWindow[dwVWIndex].grVW_VSTRT,         VWData.VSTRT);
  LL16(VideoWindow[dwVWIndex].grVW_VEND,          VWData.VEND);
  LL32(VideoWindow[dwVWIndex].grVW_VACCUM_STP,    VWData.VACCUM_STP);
  LL32(VideoWindow[dwVWIndex].grVW_VACCUM_SDA,    VWData.VACCUM_SDA);
  LL32(VideoWindow[dwVWIndex].grVW_VACCUM_SDB,    VWData.VACCUM_SDB);
  LL32(VideoWindow[dwVWIndex].grVW_PSD_STRT_ADDR, VWData.PSD_STRT_ADDR);
  LL32(VideoWindow[dwVWIndex].grVW_SSD_STRT_ADDR, VWData.SSD_STRT_ADDR);
#if ENABLE_YUVPLANAR
  if (dwFourcc == FOURCC_YUVPLANAR)
  {
    LL32(VideoWindow[dwVWIndex].grVW_PSD_UVSTRT_ADDR, VWData.PSD_UVSTRT_ADDR);
    LL32(VideoWindow[dwVWIndex].grVW_SSD_UVSTRT_ADDR, VWData.SSD_UVSTRT_ADDR);
  }
#endif
  LL16(VideoWindow[dwVWIndex].grVW_SD_PITCH,      VWData.SD_PITCH);

  if (FLG_SRC_COLOR_KEY & lpSurfaceData->dwOverlayFlags)
  {
    LL32(VideoWindow[dwVWIndex].grVW_CHRMKEY_MIN, VWData.CHRMKEY_MIN);
    LL32(VideoWindow[dwVWIndex].grVW_CHRMKEY_MAX, VWData.CHRMKEY_MAX);
  }
  else if (FLG_COLOR_KEY & lpSurfaceData->dwOverlayFlags)
  {
    LL32(VideoWindow[dwVWIndex].grVW_CLRKEY_MIN, VWData.CLRKEY_MIN);
    LL32(VideoWindow[dwVWIndex].grVW_CLRKEY_MAX, VWData.CLRKEY_MAX);
  }

  LL16(VideoWindow[dwVWIndex].grVW_FIFO_THRSH, VWData.FIFO_THRSH);
  LL32(VideoWindow[dwVWIndex].grVW_CONTROL1,   VWData.CONTROL1);

  // fix for PDR #10815
  // if src width >= 1536 bytes (or 3072 bytes for shrink)
  // disable vertical interpolation
  width = (grOverlaySrc[dwVWIndex].right - grOverlaySrc[dwVWIndex].left) * (dwBitCount / 8);
  if (VW_YShrinkEn & VWData.CONTROL1)
    width /= 2;
  if (width >= 1536)
  {
    // set replication bit in TEST0 reg
    pREG->VideoWindow[dwVWIndex].grVW_TEST0 |= VWVRepEnable;
  }
  else
  {
    // clear replication bit in TEST0 reg
    pREG->VideoWindow[dwVWIndex].grVW_TEST0 &= ~VWVRepEnable;
  }

  // write last to arm
  LL32(VideoWindow[dwVWIndex].grVW_CONTROL0,   VWData.CONTROL0);

  return TRUE;
}

/***************************************************************************
*
* FUNCTION:     RegMoveVideoVW
*
* DESCRIPTION:  This function is called to move the video window that has
*               already been programed.
*
****************************************************************************/

STATIC VOID RegMoveVideoVW
(
#ifdef WINNT_VER40
  PDEV              *ppdev,
  DWORD             dwVWIndex,
  PDD_SURFACE_LOCAL lpSurface
#else
  DWORD                     dwVWIndex,
  LPDDRAWI_DDRAWSURFACE_LCL lpSurface,
  LPGLOBALDATA              lpDDHALData
#endif
)
{
  LP_SURFACE_DATA   lpSurfaceData = GET_SURFACE_DATA_PTR(lpSurface);
  VWDATA            VWData;
  DWORD             dwFourcc;
  LONG              lPitch;
  DWORD             dwBitCount;
  RECTL             rVideoRect;
  PVGAR             pREG = (PVGAR)lpDDHALData->RegsAddress;


  ASSERT(dwNumVideoWindows > dwVWIndex);

  // Determine the format of the video data
  if (lpSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT)
  {
    GetFormatInfo (&(lpSurface->lpGbl->ddpfSurface), &dwFourcc, &dwBitCount);
  }
  else
  {
    dwBitCount = BITSPERPIXEL;
    if (16 == dwBitCount)
      dwFourcc = BI_BITFIELDS;    // 5:6:5
    else
      dwFourcc = BI_RGB;          // 8bpp, 5:5:5, 24bpp & 32bpp
  }

#ifdef WINNT_VER40
  PanOverlay1_Init(ppdev,&rVideoRect,&grOverlaySrc[dwVWIndex],&grOverlayDest[dwVWIndex]);
#else
  PanOverlay1_Init(&rVideoRect,&grOverlaySrc[dwVWIndex],&grOverlayDest[dwVWIndex]);
#endif

  // rVideoRect is now adjusted and clipped to the panning viewport.
  // Disable overlay if totally clipped by viewport.
  if (((rVideoRect.right - rVideoRect.left) <= 0) ||
      ((rVideoRect.bottom- rVideoRect.top ) <= 0))
  {
#ifdef WINNT_VER40
    DisableOverlay(ppdev, dwVWIndex);
#else
    DisableOverlay(lpDDHALData, dwVWIndex);
#endif
    return;
  }

  memset(&VWData, 0, sizeof(VWData));
  VWData.CONTROL0 = pREG->VideoWindow[dwVWIndex].grVW_CONTROL0;
  if (lpSurfaceData->dwOverlayFlags & FLG_ENABLED)
    VWData.CONTROL0 |= VW_VWE;
  VWData.CONTROL0 |= VW_ARM;

  lPitch = lpSurface->lpGbl->lPitch;

  // if shrink in x, set shrink x by 2 bit in CONTROL0
  // shrink in y is okay, because that bit is in CONTROL1 and
  // we aren't touching CONTROL1 here
  if ((grOverlayDest[dwVWIndex].right - grOverlayDest[dwVWIndex].left) <
      (grOverlaySrc[dwVWIndex].right  - grOverlaySrc[dwVWIndex].left))
  {
    VWData.CONTROL0 |= VW_XShrinkBy2;
  }

  ComputeVWPositionData(&rVideoRect,
                        &grOverlaySrc[dwVWIndex],
                        &grOverlayDest[dwVWIndex],
                        lpSurface->lpGbl,
#ifndef   WINNT_VER40
                        lpDDHALData,
#endif
                        dwBitCount,
                        &VWData,
                        FOURCC_YUVPLANAR == dwFourcc);

#if ENABLE_MIRRORING
  if (bIsVWMirrored[dwVWIndex])
    VWData.CONTROL0 |= VW_HMIRR_EN;
#endif
  // Xing, isn't the memset above enough?
  VWData.SSD_STRT_ADDR = 0;
#if DDRAW_COMPAT >= 50
  if( gwNotify & VPE_ON)
  {
   if(lpSurface->lpSurfMore->lpVideoPort != NULL)
   {
     if((lpSurface->lpSurfMore->lpVideoPort->ddvpInfo.dwVPFlags
                &DDVP_AUTOFLIP)
        && (lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_AUTOFLIP)
        && (lpSurface->lpAttachListFrom != NULL)
        && (lpSurface->lpAttachListFrom->lpAttached != NULL))
     {

         VWData.SSD_STRT_ADDR =  lpSurfaceData->dwAutoBaseAddr2 +
                                  lpSurfaceData->dwOverlayOffset;
         if( VWData.PSD_STRT_ADDR == VWData.SSD_STRT_ADDR )
         {
             VWData.PSD_STRT_ADDR = lpSurfaceData->dwAutoBaseAddr1 +
                                     lpSurfaceData->dwOverlayOffset;
         }
         VWData.CONTROL0 &= ~0x30000ul;
         VWData.CONTROL0 |= 0x20000ul;     //enable the second buffer

         if(!(lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_BOB))
         {
           //For non-smooth-interlaced auto-flip these two address need
           // to be switched.  HW BUG
           DWORD dwTmp = VWData.PSD_STRT_ADDR;
           VWData.PSD_STRT_ADDR = VWData.SSD_STRT_ADDR;
           VWData.SSD_STRT_ADDR = dwTmp;
         }
     }
    else if((lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_BOB)
         &&(lpSurface->lpSurfMore->lpVideoPort->ddvpInfo.dwVPFlags
                & DDVP_INTERLEAVE))
     {
          VWData.SSD_STRT_ADDR = VWData.PSD_STRT_ADDR + lPitch;
     }
    }
  }
#endif

  // Now start programming the registers
  ASSERT(! (pREG->VideoWindow[dwVWIndex].grVW_TEST0 & VW_PostImed));
#ifdef WINNT_VER40
  WaitForVWArmToClear(ppdev, dwVWIndex);
#else
  WaitForVWArmToClear(lpDDHALData, dwVWIndex);
#endif

  LL16(VideoWindow[dwVWIndex].grVW_HSTRT, VWData.HSTRT);
  LL16(VideoWindow[dwVWIndex].grVW_HEND,  VWData.HEND);
  LL16(VideoWindow[dwVWIndex].grVW_HSDSZ, VWData.HSDSZ);
  LL16(VideoWindow[dwVWIndex].grVW_VSTRT, VWData.VSTRT);
  LL16(VideoWindow[dwVWIndex].grVW_VEND,  VWData.VEND);
  LL32(VideoWindow[dwVWIndex].grVW_PSD_STRT_ADDR, VWData.PSD_STRT_ADDR);
  LL32(VideoWindow[dwVWIndex].grVW_SSD_STRT_ADDR, VWData.SSD_STRT_ADDR);
#if ENABLE_YUVPLANAR
  if (dwFourcc == FOURCC_YUVPLANAR)
  {
    LL32(VideoWindow[dwVWIndex].grVW_PSD_UVSTRT_ADDR, VWData.PSD_UVSTRT_ADDR);
    LL32(VideoWindow[dwVWIndex].grVW_SSD_UVSTRT_ADDR, VWData.SSD_UVSTRT_ADDR);
  }
#endif
  LL16(VideoWindow[dwVWIndex].grVW_SD_PITCH, VWData.SD_PITCH);
  LL32(VideoWindow[dwVWIndex].grVW_CONTROL0, VWData.CONTROL0);
}

/***************************************************************************
*
* FUNCTION:     ChipIOReadBWRegs
*
* DESCRIPTION:
*
****************************************************************************/

BOOL ChipIOReadBWRegs
(
#ifdef WINNT_VER40
  PDEV      *ppdev,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  LPBWREGS  pBWRegs
)
{
  PVGAR   pREG = (PVGAR)lpDDHALData->RegsAddress;


#ifdef WINNT_VER40
  pBWRegs->BCLK_Mult      = pREG->grBCLK_Multiplier;
#else
  pBWRegs->BCLK_Mult      = pREG->grBCLK_numerator;
#endif
  pBWRegs->MISCOutput     = pREG->grMISC;
  pBWRegs->VCLK3Denom     = pREG->grSRE;
  pBWRegs->VCLK3Num       = pREG->grSR1E;
  pBWRegs->DispThrsTiming = pREG->grDisplay_Threshold_and_Tiling;
  pBWRegs->RIFControl     = pREG->grRIF_CONTROL;
  pBWRegs->GfVdFormat     = pREG->grFormat;

#ifdef WINNT_VER40
  pBWRegs->BCLK_Denom     = pREG->grBCLK_Denominator;
#else
  pBWRegs->BCLK_Denom     = pREG->grBCLK_denom;
#endif
  pBWRegs->Control2       = pREG->grCONTROL2;
  pBWRegs->CR1            = pREG->grCR1;
  pBWRegs->CR1E           = pREG->grCR1E;

#if ENABLE_256_BYTE_FETCH
  // if we are disabling 256 byte fetch when overlay or videoport
  // surfaces are created, then wipe out the 256 byte fetch related
  // bits in CONTROL2
  // clear MONO_SAFETY_256 & BYTE_REQ_256 bits of CONTROL2 register
  pBWRegs->Control2 &= ~(MONO_SAFETY_256 | BYTE_REQ_256);
#endif

  return TRUE;
}

#ifdef USE_OLD_BWEQ
/***************************************************************************
*
* FUNCTION:     KillOverlay
*
* DESCRIPTION:  Disable overlay in the following cases
*
****************************************************************************/

BOOL KillOverlay
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#endif
  WORD  wScreenX,
  UINT  uScreenDepth
)
{
  BWREGS bwregs;
  DWORD  dwMCLK, dwVCLK;

#ifdef WINNT_VER40
  if(!ChipIOReadBWRegs(ppdev, &bwregs))
#else
  if(!ChipIOReadBWRegs(&bwregs))
#endif
  {
    return TRUE;
  }

  if(!ChipCalcMCLK(&bwregs, &dwMCLK))
  {
    return TRUE;
  }

  if(!ChipCalcVCLK(&bwregs, &dwVCLK))
  {
    return TRUE;
  }
  if(dwMCLK < 75000000)
  {
     if(uScreenDepth == 32 )
     {
        if(wScreenX == 640 )
        {
            if(dwVCLK > 32000000)
                return TRUE;
         }
     }
  }
  return FALSE;

}
#endif // USE_OLD_BWEQ

#endif // WINNT_VER35
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\blt_dl.c ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1996, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         blt_dl.c
*
* DESCRIPTION:  Display List blts for the 5464
*
* REVISION HISTORY:
*
* $Log:   X:\log\laguna\ddraw\src\blt_dl.c  $
* 
*    Rev 1.20   06 Jan 1998 15:20:04   xcong
* 
*    Rev 1.19   06 Jan 1998 11:56:22   xcong
* Change pDriverData into lpDDHALData for multi-monitor support.
*
*    Rev 1.18   03 Oct 1997 14:31:12   RUSSL
* Initial changes for use of hw clipped blts
* All changes wrapped in #if ENABLE_CLIPPEDBLTS/#endif blocks and
* ENABLE_CLIPPEDBLTS defaults to 0 (so the code is disabled)
*
*    Rev 1.17   15 Sep 1997 17:25:14   RUSSL
* Fix for PDR 10493 - Minor parenthesis change
*
*    Rev 1.16   24 Jul 1997 12:32:40   RUSSL
* Botched the overlap check, changed || to &&
*
*    Rev 1.15   24 Jul 1997 11:20:16   RUSSL
* Added DL_DrvStrBlt_OverlapCheck & DL_DrvStrMBlt_OverlapCheck
* inline functions
*
*    Rev 1.14   17 Jul 1997 14:31:58   RUSSL
* Fixed my copy & paste errors in the DD_LOG and ASSERTs in DL_DrvStrBlt65
*
*    Rev 1.13   15 Jul 1997 16:19:50   eleland
* removed the increment-and-immediate decrement of display list
* pointer at the end of each blt display list
*
*    Rev 1.12   14 Jul 1997 14:59:52   RUSSL
* Added DL_DrvStrBlt65
*
*    Rev 1.11   02 Jul 1997 19:13:10   eleland
* added wait instruction after each dl blit
*
*    Rev 1.10   03 Apr 1997 15:05:30   RUSSL
* Added DL_DrvDstMBlt function
*
*    Rev 1.9   26 Mar 1997 13:55:22   RUSSL
* Added DL_DrvSrcMBlt function
*
*    Rev 1.8   12 Mar 1997 15:01:20   RUSSL
* replaced a block of includes with include of precomp.h for
*   precompiled headers
*
*    Rev 1.7   07 Mar 1997 12:50:40   RUSSL
* Modified DDRAW_COMPAT usage
*
*    Rev 1.6   11 Feb 1997 11:40:34   bennyn
* Fixed the compiling error for NT
*
*    Rev 1.5   07 Feb 1997 16:30:34   KENTL
* Never mind the #ifdefs. The problems are deeper than that. We'd need
* ifdefs around half the code in the file.
*
*    Rev 1.4   07 Feb 1997 16:18:58   KENTL
* Addd #ifdef's around include qmgr.h
*
*    Rev 1.3   07 Feb 1997 13:22:36   KENTL
* Merged in Evan Leland's modifications to get Display List mode working:
* 	* include qmgr.h
* 	* Invoke qmAllocDisplayList to get pDisplayList pointer.
* 	* Invoke qmExecuteDisplayList on completed DL's
*
*    Rev 1.2   23 Jan 1997 17:08:48   bennyn
* Modified naming of registers
*
*    Rev 1.1   25 Nov 1996 16:15:48   bennyn
* Fixed misc compiling error for NT
*
*    Rev 1.0   25 Nov 1996 15:14:02   RUSSL
* Initial revision.
*
*    Rev 1.2   18 Nov 1996 16:18:56   RUSSL
* Added file logging for DDraw entry points and register writes
*
*    Rev 1.1   01 Nov 1996 13:08:40   RUSSL
* Merge WIN95 & WINNT code for Blt32
*
*    Rev 1.0   01 Nov 1996 09:28:02   BENNYN
* Initial revision.
*
*    Rev 1.0   25 Oct 1996 11:08:22   RUSSL
* Initial revision.
*
***************************************************************************
***************************************************************************/

/***************************************************************************
* I N C L U D E S
****************************************************************************/

#include "precomp.h"

// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else  // !WINNT_VER35

#ifdef WINNT_VER40      // WINNT_VER40

#define DBGLVL        1
#define AFPRINTF(n)

#else  // !WINNT_VER40

#include "l3system.h"
#include "l2d.h"
#include "bltP.h"
#include "qmgr.h"

#endif   // !WINNT_VER40

/***************************************************************************
* S T A T I C   V A R I A B L E S
****************************************************************************/

#ifndef WINNT_VER40
ASSERTFILE("blt_dl.c");
#endif

/***************************************************************************
*
* FUNCTION:    DL_Delay9BitBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_Delay9BitBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  BOOL        ninebit_on
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_Delay9BitBlt\r\n"));

  /* This is to ensure that the last packet of any previous blt */
  /* does no go out with 9th bit set incorrectly */
  /* The boolean paramter is the 9th bit of the PREVIOUS BLT */

  rc = qmAllocDisplayList(8*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 4, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | ((BD_RES + BD_OP0 + BD_OP1 + BD_OP2)*IS_VRAM);
  if (ninebit_on)
    *pDisplayList++ = (C_DRWDEF << 16) | (DD_PTAG | ROP_OP0_copy);
  else
    *pDisplayList++ = (C_DRWDEF << 16) | ROP_OP0_copy;

  // OP0_RDRAM
  *pDisplayList++ = (C_RX_0 << 16) | LOWORD(lpDDHALData->PTAGFooPixel);
  *pDisplayList++ = (C_RY_0 << 16) | HIWORD(lpDDHALData->PTAGFooPixel);

  // BLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXT_EX, 1, 0);
  *pDisplayList++ = MAKELONG(1,1);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_Delay9BitBlt */

/***************************************************************************
*
* FUNCTION:     DL_EdgeFillBlt
*
* DESCRIPTION:  Solid Fill BLT to fill in edges ( Pixel Coords / Extents )
*
****************************************************************************/

void DL_EdgeFillBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  int         xFill,
  int         yFill,
  int         cxFill,
  int         cyFill,
  DWORD       FillValue,
  BOOL        ninebit_on
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_EdgeFillBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          MAKELONG(xFill,yFill),MAKELONG(cxFill,cyFill),FillValue));

  rc = qmAllocDisplayList(10*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 6, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | (BD_RES * IS_VRAM + BD_OP1 * IS_SOLID);
  if (ninebit_on)
    *pDisplayList++ = (C_DRWDEF << 16) | (DD_PTAG | ROP_OP1_copy);
  else
    *pDisplayList++ = (C_DRWDEF << 16) | ROP_OP1_copy;

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(FillValue);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(FillValue);

  // OP0_opRDRAM
  *pDisplayList++ = (C_RX_0 << 16) | LOWORD(xFill);
  *pDisplayList++ = (C_RY_0 << 16) | LOWORD(yFill);

  // BLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXT_EX, 1, 0);
  *pDisplayList++ = MAKELONG(LOWORD(cxFill),LOWORD(cyFill));

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_EdgeFillBlt */

/***************************************************************************
*
* FUNCTION:     DL_MEdgeFillBlt
*
* DESCRIPTION:  Using BYTE BLT coords / Extents perform EdgeFill BLT
*
****************************************************************************/

void DL_MEdgeFillBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  int         xFill,
  int         yFill,
  int         cxFill,
  int         cyFill,
  DWORD       FillValue,
  BOOL        ninebit_on
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_MEdgeFillBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          MAKELONG(xFill,yFill),MAKELONG(cxFill,cyFill),FillValue));

  rc = qmAllocDisplayList(10*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 6, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | (BD_RES * IS_VRAM + BD_OP1 * IS_SOLID);
  if (ninebit_on)
    *pDisplayList++ = (C_DRWDEF << 16) | (DD_PTAG | ROP_OP1_copy);
  else
    *pDisplayList++ = (C_DRWDEF << 16) | ROP_OP1_copy;

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(FillValue);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(FillValue);

  // OP0_opMRDRAM
  *pDisplayList++ = (C_MRX_0 << 16) | LOWORD(xFill);
  *pDisplayList++ = (C_MRY_0 << 16) | LOWORD(yFill);

  // MBLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXT_EX, 1, 0);
  *pDisplayList++ = MAKELONG(LOWORD(cxFill),LOWORD(cyFill));

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_EdgeFillBlt */


/***************************************************************************
*
* FUNCTION:     DL_DrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_DrvDstBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvDstBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  rc = qmAllocDisplayList(10*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 6, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwBgColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwBgColor);

  // OP0_opRDRAM
  *pDisplayList++ = (C_RX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_RY_0 << 16) | HIWORD(dwDstCoord);

  // BLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXT_EX, 1, 0);
  *pDisplayList++ = dwExtents;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvDstBlt */

/***************************************************************************
*
* FUNCTION:     DL_DrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_DrvDstMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;

  DD_LOG(("DL_DrvDstMBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  rc = qmAllocDisplayList(10*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 6, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwBgColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwBgColor);

  // OP0_opMRDRAM
  *pDisplayList++ = (C_MRX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_MRY_0 << 16) | HIWORD(dwDstCoord);

  // MBLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXT_EX, 1, 0);
  *pDisplayList++ = dwExtents;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvDstMBlt */

/***************************************************************************
*
* FUNCTION:     DL_DrvSrcBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_DrvSrcBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;

  // Handle overlapped regions.
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DL_DrvSrcBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // Check for x overlap.
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0,-1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first.
      DL_DrvSrcBlt(
#ifdef WINNT_VER40
                   ppdev,
#endif
                   lpDDHALData,
                   dwDrawBlt,
                   dwDstCoord+dwDelta,
                   dwSrcCoord+dwDelta,
                   dwKeyCoord+dwDelta,
                   dwKeyColor,
                   dwExtents-dwDelta);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  rc = qmAllocDisplayList(14*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 10, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // OP0_opRDRAM
  *pDisplayList++ = (C_RX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_RY_0 << 16) | HIWORD(dwDstCoord);

  // OP1_opRDRAM
  *pDisplayList++ = (C_RX_1 << 16) | LOWORD(dwSrcCoord);
  *pDisplayList++ = (C_RY_1 << 16) | HIWORD(dwSrcCoord);

  // OP2_opRDRAM
  *pDisplayList++ = (C_RX_2 << 16) | LOWORD(dwKeyCoord);
  *pDisplayList++ = (C_RY_2 << 16) | HIWORD(dwKeyCoord);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwKeyColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwKeyColor);

  // BLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXT_EX, 1, 0);
  *pDisplayList++ = dwExtents;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvSrcBlt */

/***************************************************************************
*
* FUNCTION:     DL_DrvSrcMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_DrvSrcMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;

  // Handle overlapped regions.
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DL_DrvSrcMBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // Check for x overlap.
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0,-1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first.
      DL_DrvSrcMBlt(
#ifdef WINNT_VER40
                    ppdev,
#endif
                    lpDDHALData,
                    dwDrawBlt,
                    dwDstCoord+dwDelta,
                    dwSrcCoord+dwDelta,
                    dwKeyCoord+dwDelta,
                    dwKeyColor,
                    dwExtents-dwDelta);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  rc = qmAllocDisplayList(14*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 10, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // OP0_opMRDRAM
  *pDisplayList++ = (C_MRX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_MRY_0 << 16) | HIWORD(dwDstCoord);

  // OP1_opMRDRAM
  *pDisplayList++ = (C_MRX_1 << 16) | LOWORD(dwSrcCoord);
  *pDisplayList++ = (C_MRY_1 << 16) | HIWORD(dwSrcCoord);

  // OP2_opMRDRAM
  *pDisplayList++ = (C_MRX_2 << 16) | LOWORD(dwKeyCoord);
  *pDisplayList++ = (C_MRY_2 << 16) | HIWORD(dwKeyCoord);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwKeyColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwKeyColor);

  // MBLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXT_EX, 1, 0);
  *pDisplayList++ = dwExtents;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvSrcMBlt */

#if 0
/***************************************************************************
*
* FUNCTION:     DL_DrvStrBlt_OverlapCheck
*
* DESCRIPTION:
*
****************************************************************************/

static void INLINE DL_DrvStrBlt_OverlapCheck
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  int xdelta,ydelta;


  xdelta = abs(pblt->OP0_opRDRAM.pt.X - pblt->OP1_opRDRAM.pt.X);
  ydelta = abs(pblt->OP0_opRDRAM.pt.Y - pblt->OP1_opRDRAM.pt.Y);

  if ((xdelta < pblt->BLTEXT.pt.X) &&
      (ydelta < pblt->BLTEXT.pt.Y))
  {
    // hack, hack, cough, cough
    // pblt->MBLTEXT.DW has src exents

    // blt the src to the lower right of the dest
    DL_DrvSrcBlt(
#ifdef WINNT_VER40
                 ppdev,
                 lpDDHALData,
#endif
                 MAKELONG(ROP_OP1_copy, BD_RES * IS_VRAM | BD_OP1 * IS_VRAM),
                 pblt->OP0_opRDRAM.DW + pblt->BLTEXT.DW - pblt->MBLTEXT.DW,
                 pblt->OP1_opRDRAM.DW,
						     0UL,         // don't care
						     0UL,
                 pblt->MBLTEXT.DW);

    // update the src ptr to use this copy of the src
    pblt->OP1_opRDRAM.DW = pblt->OP0_opRDRAM.DW + pblt->BLTEXT.DW - pblt->MBLTEXT.DW;
  }
}
#endif

/***************************************************************************
*
* FUNCTION:     DL_DrvStrMBlt_OverlapCheck
*
* DESCRIPTION:
*
****************************************************************************/

static void INLINE DL_DrvStrMBlt_OverlapCheck
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  int xdelta,ydelta;


  xdelta = abs(pblt->OP0_opMRDRAM.pt.X - pblt->OP1_opMRDRAM.pt.X);
  ydelta = abs(pblt->OP0_opMRDRAM.pt.Y - pblt->OP1_opMRDRAM.pt.Y);

  if ((xdelta < pblt->MBLTEXTR_EX.pt.X) &&
      (ydelta < pblt->MBLTEXTR_EX.pt.Y))
  {
    // hack, hack, cough, cough
    // pblt->BLTEXT.DW has src exents (see DrvStretch65)

    // blt the src to the lower right of the dest
    DL_DrvSrcMBlt(
#ifdef WINNT_VER40
                  ppdev,
#endif
                  lpDDHALData,
                  MAKELONG(ROP_OP1_copy, BD_RES * IS_VRAM | BD_OP1 * IS_VRAM),
                  pblt->OP0_opMRDRAM.DW + pblt->MBLTEXTR_EX.DW - pblt->BLTEXT.DW,
                  pblt->OP1_opMRDRAM.DW,
						      0UL,         // don't care
						      0UL,
                  pblt->BLTEXT.DW);

    // update the src ptr to use this copy of the src
    pblt->OP1_opMRDRAM.DW = pblt->OP0_opMRDRAM.DW + pblt->MBLTEXTR_EX.DW - pblt->BLTEXT.DW;
  }
}

/***************************************************************************
*
* FUNCTION:     DL_DrvStrBlt
*
* DESCRIPTION:	 62/64 version
*
****************************************************************************/

void DL_DrvStrBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrBlt - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

  ASSERT( pblt->BLTEXT.pt.X != 0 );
  ASSERT( pblt->BLTEXT.pt.Y != 0 );

  DBG_MESSAGE(("DL_DrvStrBlt:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));

#if 0
    // check for overlap
    DL_DrvStrBlt_OverlapCheck(
#ifdef WINNT_VER40
                              ppdev,lpDDHALData,
#endif
                              pblt);
#endif

  rc = qmAllocDisplayList(19*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 15, 0);

  *pDisplayList++ = (C_LNCNTL << 16) | pblt->LNCNTL.W;
  *pDisplayList++ = (C_SHINC  << 16) | pblt->SHRINKINC.W;
  *pDisplayList++ = (C_SRCX   << 16) | pblt->SRCX;
  *pDisplayList++ = (C_MAJX   << 16) | pblt->MAJ_X;
  *pDisplayList++ = (C_MINX   << 16) | pblt->MIN_X;
  *pDisplayList++ = (C_ACCUMX << 16) | pblt->ACCUM_X;
  *pDisplayList++ = (C_MAJY   << 16) | pblt->MAJ_Y;
  *pDisplayList++ = (C_MINY   << 16) | pblt->MIN_Y;
  *pDisplayList++ = (C_ACCUMY << 16) | pblt->ACCUM_Y;
  *pDisplayList++ = (C_RX_0   << 16) | pblt->OP0_opRDRAM.pt.X;
  *pDisplayList++ = (C_RY_0   << 16) | pblt->OP0_opRDRAM.pt.Y;
  *pDisplayList++ = (C_RX_1   << 16) | pblt->OP1_opRDRAM.pt.X;
  *pDisplayList++ = (C_RY_1   << 16) | pblt->OP1_opRDRAM.pt.Y;
  *pDisplayList++ = (C_BLTDEF << 16) | pblt->DRAWBLTDEF.lh.HI;
  *pDisplayList++ = (C_DRWDEF << 16) | pblt->DRAWBLTDEF.lh.LO;

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXTR_EX, 1, 0);
  *pDisplayList++ = pblt->BLTEXT.DW;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvStrBlt */

/***************************************************************************
*
* FUNCTION:     DL_DrvStrBlt65
*
* DESCRIPTION:  65+ version
*
****************************************************************************/

void DL_DrvStrBlt65
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrBlt65 - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opMRDRAM.DW,pblt->MBLTEXTR_EX.DW,pblt->OP1_opMRDRAM.DW));

  ASSERT( pblt->MBLTEXTR_EX.pt.X != 0 );
  ASSERT( pblt->MBLTEXTR_EX.pt.Y != 0 );

  DBG_MESSAGE(("DL_DrvStrBlt65:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opMRDRAM.PT.X, pblt->OP1_opMRDRAM.PT.Y,
               pblt->OP0_opMRDRAM.PT.X, pblt->OP0_opMRDRAM.PT.Y,
               pblt->MBLTEXTR_EX.PT.X, pblt->MBLTEXTR_EX.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->STRETCH_CNTL.W));

    // check for overlap
    DL_DrvStrMBlt_OverlapCheck(
#ifdef WINNT_VER40
                               ppdev,
#endif
                               lpDDHALData,
                               pblt);

  rc = qmAllocDisplayList(19*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 15, 0);

  *pDisplayList++ = (C_STRCTL << 16) | pblt->STRETCH_CNTL.W;
  *pDisplayList++ = (C_SHINC  << 16) | pblt->SHRINKINC.W;
  *pDisplayList++ = (C_SRCX   << 16) | pblt->SRCX;
  *pDisplayList++ = (C_MAJX   << 16) | pblt->MAJ_X;
  *pDisplayList++ = (C_MINX   << 16) | pblt->MIN_X;
  *pDisplayList++ = (C_ACCUMX << 16) | pblt->ACCUM_X;
  *pDisplayList++ = (C_MAJY   << 16) | pblt->MAJ_Y;
  *pDisplayList++ = (C_MINY   << 16) | pblt->MIN_Y;
  *pDisplayList++ = (C_ACCUMY << 16) | pblt->ACCUM_Y;
  *pDisplayList++ = (C_MRX_0   << 16) | pblt->OP0_opMRDRAM.pt.X;
  *pDisplayList++ = (C_MRY_0   << 16) | pblt->OP0_opMRDRAM.pt.Y;
  *pDisplayList++ = (C_MRX_1   << 16) | pblt->OP1_opMRDRAM.pt.X;
  *pDisplayList++ = (C_MRY_1   << 16) | pblt->OP1_opMRDRAM.pt.Y;
  *pDisplayList++ = (C_BLTDEF << 16) | pblt->DRAWBLTDEF.lh.HI;
  *pDisplayList++ = (C_DRWDEF << 16) | pblt->DRAWBLTDEF.lh.LO;

  // MBLTEXTR_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXTR_EX, 1, 0);
  *pDisplayList++ = pblt->MBLTEXTR_EX.DW;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DIR_DrvStrBlt65 */

/***************************************************************************
*
* FUNCTION:     DL_DrvStrMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_DrvStrMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrMBlt - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

  ASSERT( pblt->BLTEXT.pt.X != 0 );
  ASSERT( pblt->BLTEXT.pt.Y != 0 );

  DBG_MESSAGE(("DL_DrvStrMBlt:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));

    // check for overlap
    DL_DrvStrMBlt_OverlapCheck(
#ifdef WINNT_VER40
                               ppdev,
#endif
                               lpDDHALData,
                               pblt);

  rc = qmAllocDisplayList(19*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 15, 0);

  *pDisplayList++ = (C_LNCNTL << 16) | pblt->LNCNTL.W;
  *pDisplayList++ = (C_SHINC  << 16) | pblt->SHRINKINC.W;
  *pDisplayList++ = (C_SRCX   << 16) | pblt->SRCX;
  *pDisplayList++ = (C_MAJX   << 16) | pblt->MAJ_X;
  *pDisplayList++ = (C_MINX   << 16) | pblt->MIN_X;
  *pDisplayList++ = (C_ACCUMX << 16) | pblt->ACCUM_X;
  *pDisplayList++ = (C_MAJY   << 16) | pblt->MAJ_Y;
  *pDisplayList++ = (C_MINY   << 16) | pblt->MIN_Y;
  *pDisplayList++ = (C_ACCUMY << 16) | pblt->ACCUM_Y;
  *pDisplayList++ = (C_MRX_0  << 16) | pblt->OP0_opRDRAM.pt.X;
  *pDisplayList++ = (C_MRY_0  << 16) | pblt->OP0_opRDRAM.pt.Y;
  *pDisplayList++ = (C_MRX_1  << 16) | pblt->OP1_opRDRAM.pt.X;
  *pDisplayList++ = (C_MRY_1  << 16) | pblt->OP1_opRDRAM.pt.Y;
  *pDisplayList++ = (C_BLTDEF << 16) | pblt->DRAWBLTDEF.lh.HI;
  *pDisplayList++ = (C_DRWDEF << 16) | pblt->DRAWBLTDEF.lh.LO;

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXTR_EX, 1, 0);
  *pDisplayList++ = pblt->BLTEXT.DW;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvStrMBlt */

/***************************************************************************
*
* FUNCTION:     DL_DrvStrMBltY
*
* DESCRIPTION:  Write regs that don't vary over the stripes
*               Used in conjunction with DL_DrvStrMBltX
*
****************************************************************************/

void DL_DrvStrMBltY
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrMBltY - dst.Y=%04X dstext.Y=%04X src=%04X\r\n",
          pblt->OP0_opRDRAM.pt.Y,pblt->BLTEXT.pt.Y,pblt->OP1_opRDRAM.pt.Y));

  ASSERT( pblt->BLTEXT.pt.Y != 0 );

  DBG_MESSAGE(("DrvStrMBltY:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));

  rc = qmAllocDisplayList(13*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 11, 0);

  *pDisplayList++ = (C_LNCNTL << 16) | pblt->LNCNTL.W;
  *pDisplayList++ = (C_SHINC  << 16) | pblt->SHRINKINC.W;
  *pDisplayList++ = (C_MAJX   << 16) | pblt->MAJ_X;
  *pDisplayList++ = (C_MINX   << 16) | pblt->MIN_X;
  *pDisplayList++ = (C_MAJY   << 16) | pblt->MAJ_Y;
  *pDisplayList++ = (C_MINY   << 16) | pblt->MIN_Y;
  *pDisplayList++ = (C_ACCUMY << 16) | pblt->ACCUM_Y;
  *pDisplayList++ = (C_MRY_0  << 16) | pblt->OP0_opRDRAM.pt.Y;
  *pDisplayList++ = (C_MRY_1  << 16) | pblt->OP1_opRDRAM.pt.Y;
  *pDisplayList++ = (C_BLTDEF << 16) | pblt->DRAWBLTDEF.lh.HI;
  *pDisplayList++ = (C_DRWDEF << 16) | pblt->DRAWBLTDEF.lh.LO;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvStrMBltY */

/***************************************************************************
*
* FUNCTION:     DL_DrvStrMBltX
*
* DESCRIPTION:  Write stripe specific regs
*               Used in conjunction with DL_DrvStrMBltY
*
****************************************************************************/

void DL_DrvStrMBltX
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrMBltX - dst.X=%04X dstext.X=%04X src.X=%04X\r\n",
          pblt->OP0_opRDRAM.pt.X,pblt->BLTEXT.pt.X,pblt->OP1_opRDRAM.pt.X));

  ASSERT( pblt->BLTEXT.pt.X != 0 );

  DBG_MESSAGE(("DrvStrMBltX:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));

  rc = qmAllocDisplayList(8*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 4, 0);

  *pDisplayList++ = (C_SRCX   << 16) | pblt->SRCX;
  *pDisplayList++ = (C_ACCUMX << 16) | pblt->ACCUM_X;
  *pDisplayList++ = (C_MRX_0  << 16) | pblt->OP0_opRDRAM.pt.X;
  *pDisplayList++ = (C_MRX_1  << 16) | pblt->OP1_opRDRAM.pt.X;

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXTR_EX, 1, 0);
  *pDisplayList++ = pblt->BLTEXT.DW;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvStrMBltX */

/***************************************************************************
*
* FUNCTION:     DL_DrvStrBltY
*
* DESCRIPTION:  Write regs that don't vary over the stripes
*               Used in conjunction with DL_DrvStrBltX
*
****************************************************************************/

void DL_DrvStrBltY
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrBltY\r\n"));

  DBG_MESSAGE(("DL_DrvStrBltY:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));

  rc = qmAllocDisplayList(12*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 10, 0);

  *pDisplayList++ = (C_LNCNTL << 16) | pblt->LNCNTL.W;
  *pDisplayList++ = (C_SHINC  << 16) | pblt->SHRINKINC.W;
  *pDisplayList++ = (C_SRCX   << 16) | pblt->SRCX;
  *pDisplayList++ = (C_MAJX   << 16) | pblt->MAJ_X;
  *pDisplayList++ = (C_MINX   << 16) | pblt->MIN_X;
  *pDisplayList++ = (C_MAJY   << 16) | pblt->MAJ_Y;
  *pDisplayList++ = (C_MINY   << 16) | pblt->MIN_Y;
  *pDisplayList++ = (C_ACCUMY << 16) | pblt->ACCUM_Y;
  *pDisplayList++ = (C_BLTDEF << 16) | pblt->DRAWBLTDEF.lh.HI;
  *pDisplayList++ = (C_DRWDEF << 16) | pblt->DRAWBLTDEF.lh.LO;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvStrBltY */

/***************************************************************************
*
* FUNCTION:     DL_DrvStrBltX
*
* DESCRIPTION:  Write stripe specific regs
*               Used in conjunction with DL_DrvStrMBltY
*
****************************************************************************/

void DL_DrvStrBltX
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrBltX - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

  ASSERT( pblt->BLTEXT.pt.X != 0 );
  ASSERT( pblt->BLTEXT.pt.Y != 0 );

  DBG_MESSAGE(("DL_DrvStrBltX:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));

  rc = qmAllocDisplayList(9*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 5, 0);

  *pDisplayList++ = (C_ACCUMX << 16) | pblt->ACCUM_X;
  *pDisplayList++ = (C_RX_0   << 16) | pblt->OP0_opRDRAM.pt.X;
  *pDisplayList++ = (C_RY_0   << 16) | pblt->OP0_opRDRAM.pt.Y;
  *pDisplayList++ = (C_RX_1   << 16) | pblt->OP1_opRDRAM.pt.X;
  *pDisplayList++ = (C_RY_1   << 16) | pblt->OP1_opRDRAM.pt.Y;

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXTR_EX, 1, 0);
  *pDisplayList++ = pblt->BLTEXT.DW;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvStrBltX */

#if ENABLE_CLIPPEDBLTS

/***************************************************************************
*
* FUNCTION:     DL_HWClippedDrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_HWClippedDrvDstBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD       *pDisplayList;
  qm_return   rc;
  QMDLHandle  Handle;


  DD_LOG(("DL_HWClippedDrvDstBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // check for negative dst coordinates, hw can't deal with negative OP0 values
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.X)
  {
    (short)((REG32 *)&dwExtents)->pt.X += (short)((REG32 *)&dwDstCoord)->pt.X;
    ((REG32 *)&dwDstCoord)->pt.X = 0;
  }
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.Y)
  {
    (short)((REG32 *)&dwExtents)->pt.Y += (short)((REG32 *)&dwDstCoord)->pt.Y;
    ((REG32 *)&dwDstCoord)->pt.Y = 0;
  }

  rc = qmAllocDisplayList((10+dwRectCnt*4)*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 8, 0);

  // setup blt, write BLTEXT reg with extent which doesn't fire off blt
  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwBgColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwBgColor);

  // OP0_opRDRAM
  *pDisplayList++ = (C_RX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_RY_0 << 16) | HIWORD(dwDstCoord);

  // BLTEXT
  *pDisplayList++ = (C_BLTEXT_X << 16) | LOWORD(dwExtents);
  *pDisplayList++ = (C_BLTEXT_Y << 16) | HIWORD(dwExtents);

  // loop over clip list
  do
  {
    REG32   UpperLeft;
    REG32   LowerRight;

    // compute cliprect coords
    UpperLeft.DW  = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    LowerRight.DW = dwDstBaseXY + MAKELONG(pDestRects->right, pDestRects->bottom);

    // write clipping regs
    // CLIPULE
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_CLIPULE, 1, 0);
    *pDisplayList++ = UpperLeft.DW;

    // CLIPLOR_EX
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_CLIPLOR_EX, 1, 0);
    *pDisplayList++ = LowerRight.DW;

    pDestRects++;
  } while (0 < --dwRectCnt);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_HWClippedDrvDstBlt */

/***************************************************************************
*
* FUNCTION:     DL_HWClippedDrvDstMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_HWClippedDrvDstMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  const int   nBytesPixel = BYTESPERPIXEL;
  DWORD       *pDisplayList;
  qm_return   rc;
  QMDLHandle  Handle;


  DD_LOG(("DL_HWClippedDrvDstMBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // check for negative dst coordinates, hw can't deal with negative OP0 values
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.X)
  {
    (short)((REG32 *)&dwExtents)->pt.X += (short)((REG32 *)&dwDstCoord)->pt.X;
    ((REG32 *)&dwDstCoord)->pt.X = 0;
  }
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.Y)
  {
    (short)((REG32 *)&dwExtents)->pt.Y += (short)((REG32 *)&dwDstCoord)->pt.Y;
    ((REG32 *)&dwDstCoord)->pt.Y = 0;
  }

  rc = qmAllocDisplayList((10+dwRectCnt*4)*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 8, 0);

  // setup blt, write BLTEXT reg with extent which doesn't fire off blt
  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwBgColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwBgColor);

  // OP0_opMRDRAM
  *pDisplayList++ = (C_MRX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_MRY_0 << 16) | HIWORD(dwDstCoord);

  // MBLTEXT
  *pDisplayList++ = (C_MBLTEXT_X << 16) | LOWORD(dwExtents);
  *pDisplayList++ = (C_MBLTEXT_Y << 16) | HIWORD(dwExtents);

  // loop over clip list
  do
  {
    REG32   UpperLeft;
    REG32   LowerRight;

    // compute cliprect coords
    UpperLeft.DW  = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    LowerRight.DW = dwDstBaseXY + MAKELONG(pDestRects->right, pDestRects->bottom);
    UpperLeft.pt.X  *= nBytesPixel;
    LowerRight.pt.X *= nBytesPixel;

    // write clipping regs
    // MCLIPULE
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MCLIPULE, 1, 0);
    *pDisplayList++ = UpperLeft.DW;

    // MCLIPLOR_EX
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MCLIPLOR_EX, 1, 0);
    *pDisplayList++ = LowerRight.DW;

    pDestRects++;
  } while (0 < --dwRectCnt);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_HWClippedDrvDstMBlt */

/***************************************************************************
*
* FUNCTION:     DL_HWClippedDrvSrcBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_HWClippedDrvSrcBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwSrcBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD       *pDisplayList;
  qm_return   rc;
  QMDLHandle  Handle;

  // Handle overlapped regions
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DL_HWClippedDrvSrcBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // check for negative dst coordinates, hw can't deal with negative OP0 values
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.X)
  {
    // reduce extent.X
    (short)((REG32 *)&dwExtents)->pt.X += (short)((REG32 *)&dwDstCoord)->pt.X;
    // bump src.X to right
    (short)((REG32 *)&dwSrcCoord)->pt.X -= (short)((REG32 *)&dwDstCoord)->pt.X;
    if ((DD_TRANS | DD_TRANSOP) & dwDrawBlt)
      // bump key.X to right
      (short)((REG32 *)&dwKeyCoord)->pt.X -= (short)((REG32 *)&dwKeyCoord)->pt.X;
    // clear dst.X
    ((REG32 *)&dwDstCoord)->pt.X = 0;
  }
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.Y)
  {
    // reduce extent.Y
    (short)((REG32 *)&dwExtents)->pt.Y += (short)((REG32 *)&dwDstCoord)->pt.Y;
    // bump src.Y down
    (short)((REG32 *)&dwSrcCoord)->pt.Y -= (short)((REG32 *)&dwDstCoord)->pt.Y;
    if ((DD_TRANS | DD_TRANSOP) & dwDrawBlt)
      // bump key.Y down
      (short)((REG32 *)&dwKeyCoord)->pt.Y -= (short)((REG32 *)&dwKeyCoord)->pt.Y;
    // clean dst.Y
    ((REG32 *)&dwDstCoord)->pt.Y = 0;
  }

  // Check for x overlap
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0, -1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first
      DL_HWClippedDrvSrcBlt(
#ifdef WINNT_VER40
                            ppdev,
                            lpDDHALData,
#endif
                            dwDrawBlt,
                            dwDstCoord+dwDelta,
                            dwSrcCoord+dwDelta,
                            dwKeyCoord+dwDelta,
                            dwKeyColor,
                            dwExtents-dwDelta,
                            dwDstBaseXY,
                            dwSrcBaseXY,
                            dwRectCnt,
                            pDestRects);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  rc = qmAllocDisplayList((14+dwRectCnt*4)*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 12, 0);

  // setup blt, write BLTEXT reg with extent which doesn't fire off blt
  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // OP0_opRDRAM
  *pDisplayList++ = (C_RX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_RY_0 << 16) | HIWORD(dwDstCoord);

  // OP1_opRDRAM
  *pDisplayList++ = (C_RX_1 << 16) | LOWORD(dwSrcCoord);
  *pDisplayList++ = (C_RY_1 << 16) | HIWORD(dwSrcCoord);

  // OP2_opRDRAM
  *pDisplayList++ = (C_RX_2 << 16) | LOWORD(dwKeyCoord);
  *pDisplayList++ = (C_RY_2 << 16) | HIWORD(dwKeyCoord);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwKeyColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwKeyColor);

  // BLTEXT
  *pDisplayList++ = (C_BLTEXT_X << 16) | LOWORD(dwExtents);
  *pDisplayList++ = (C_BLTEXT_Y << 16) | HIWORD(dwExtents);

  // loop over clip list
  do
  {
    REG32   UpperLeft;
    REG32   LowerRight;

    // compute cliprect coords
    UpperLeft.DW  = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    LowerRight.DW = dwDstBaseXY + MAKELONG(pDestRects->right, pDestRects->bottom);

    // write clipping regs
    // CLIPULE
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_CLIPULE, 1, 0);
    *pDisplayList++ = UpperLeft.DW;

    // CLIPLOR_EX
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_CLIPLOR_EX, 1, 0);
    *pDisplayList++ = LowerRight.DW;

    pDestRects++;
  } while (0 < --dwRectCnt);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_HWClippedDrvSrcBlt */

/***************************************************************************
*
* FUNCTION:     DL_SWClippedDrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_SWClippedDrvDstBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD       *pDisplayList;
  qm_return   rc;
  QMDLHandle  Handle;


  DD_LOG(("DL_SWClippedDrvDstBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // make sure DD_CLIP isn't set in drawdef
  dwDrawBlt &= ~DD_CLIP;

  rc = qmAllocDisplayList((6+dwRectCnt*4)*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 4, 0);

  // write regs that don't vary over rectangles
  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwBgColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwBgColor);

  // loop over clip list
  do
  {
    DDRECTL   DstDDRect;

    // compute cliprect coords
    DstDDRect.loc.DW = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    DstDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left);
    DstDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // write OP0 and bltext regs
    // OP0_opRDRAM
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_OP0_OPRDRAM, 1, 0);
    *pDisplayList++ = DstDDRect.loc.DW;

    // BLTEXT_EX
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXT_EX, 1, 0);
    *pDisplayList++ = DstDDRect.ext.DW;

    pDestRects++;
  } while (0 < --dwRectCnt);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_SWClippedDrvDstBlt */

/***************************************************************************
*
* FUNCTION:     DL_SWClippedDrvDstMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_SWClippedDrvDstMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  const int   nBytesPixel = BYTESPERPIXEL;
  DWORD       *pDisplayList;
  qm_return   rc;
  QMDLHandle  Handle;


  DD_LOG(("DL_SWClippedDrvDstMBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // make sure DD_CLIP isn't set in drawdef
  dwDrawBlt &= ~DD_CLIP;

  rc = qmAllocDisplayList((6+dwRectCnt*4)*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 4, 0);

  // write regs that don't vary over rectangles
  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwBgColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwBgColor);

  // loop over clip list
  do
  {
    DDRECTL   DstDDRect;

    // compute cliprect coords
    DstDDRect.loc.DW = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    DstDDRect.loc.pt.X *= nBytesPixel;
    DstDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left) * nBytesPixel;
    DstDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // write OP0 and bltext regs
    // OP0_opMRDRAM
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_OP0_OPMRDRAM, 1, 0);
    *pDisplayList++ = DstDDRect.loc.DW;

    // MBLTEXT_EX
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXT_EX, 1, 0);
    *pDisplayList++ = DstDDRect.ext.DW;

    pDestRects++;
  } while (0 < --dwRectCnt);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_SWClippedDrvDstMBlt */

/***************************************************************************
*
* FUNCTION:     DL_SWClippedDrvSrcBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_SWClippedDrvSrcBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwSrcBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD       *pDisplayList;
  qm_return   rc;
  QMDLHandle  Handle;

  // Handle overlapped regions
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DL_SWClippedDrvSrcBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // make sure DD_CLIP isn't set in drawdef
  dwDrawBlt &= ~DD_CLIP;

  // Check for x overlap
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0, -1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first
      DL_SWClippedDrvSrcBlt(
#ifdef WINNT_VER40
                            ppdev,
                            lpDDHALData,
#endif
                            dwDrawBlt,
                            dwDstCoord+dwDelta,
                            dwSrcCoord+dwDelta,
                            dwKeyCoord+dwDelta,
                            dwKeyColor,
                            dwExtents-dwDelta,
                            dwDstBaseXY,
                            dwSrcBaseXY,
                            dwRectCnt,
                            pDestRects);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  rc = qmAllocDisplayList((6+dwRectCnt*9)*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 4, 0);

  // write regs that don't vary over rectangles
  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwKeyColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwKeyColor);

  // loop over clip list
  do
  {
    DDRECTL   DstDDRect;
    DDRECTL   SrcDDRect;

    // compute dst cliprect coords
    DstDDRect.loc.DW = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    DstDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left);
    DstDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // compute src cliprect coords
    SrcDDRect.loc.DW = dwSrcBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    // don't care about src extent, it's the same as dst extent
    //SrcDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left);
    //SrcDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 6, 0);

    // write OP0, OP1, OP2 and bltext regs
    if ((DD_TRANS | DD_TRANSOP) == ((DD_TRANS | DD_TRANSOP) & dwDrawBlt))
    {
      // dst color key
      // OP2_opRDRAM
      *pDisplayList++ = (C_RX_2 << 16) | DstDDRect.loc.pt.X;
      *pDisplayList++ = (C_RY_2 << 16) | DstDDRect.loc.pt.Y;
    }
    else if (DD_TRANS == ((DD_TRANS | DD_TRANSOP) & dwDrawBlt))
    {
      // src color key
      // OP2_opRDRAM
      *pDisplayList++ = (C_RX_2 << 16) | SrcDDRect.loc.pt.X;
      *pDisplayList++ = (C_RY_2 << 16) | SrcDDRect.loc.pt.Y;
    }
    else
    {
      // OP2_opRDRAM
      *pDisplayList++ = (C_RX_2 << 16) | 0;
      *pDisplayList++ = (C_RY_2 << 16) | 0;
    }

    // OP0_opRDRAM
    *pDisplayList++ = (C_RX_0 << 16) | DstDDRect.loc.pt.X;
    *pDisplayList++ = (C_RY_0 << 16) | DstDDRect.loc.pt.Y;

    // OP1_opRDRAM
    *pDisplayList++ = (C_RX_1 << 16) | SrcDDRect.loc.pt.X;
    *pDisplayList++ = (C_RY_1 << 16) | SrcDDRect.loc.pt.Y;

    // BLTEXT_EX
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXT_EX, 1, 0);
    *pDisplayList++ = DstDDRect.ext.DW;

    pDestRects++;
  } while (0 < --dwRectCnt);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_SWClippedDrvSrcBlt */

#endif  // ENABLE_CLIPPEDBLTS

#endif // WINNT_VER35
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\bitblt.c ===
/******************************************************************************
* Module Name: BITBLT.c
* Author: Noel VanHook
* Purpose: Handle calls to DrvBitBlt
*
* Copyright (c) 1995,1996 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/BITBLT.C  $
* 
*    Rev 1.45   Mar 04 1998 15:11:56   frido
* Added new shadow macros.
* 
*    Rev 1.44   Feb 24 1998 13:24:40   frido
* Removed some warning messages for NT 5.0 build.
* 
*    Rev 1.43   Jan 22 1998 18:15:58   frido
* Revised the pattern blit filter for Access again.
* 
*    Rev 1.42   Jan 21 1998 17:33:56   frido
* Revised the 24-bpp filter for Access & Excel.
* 
*    Rev 1.41   Jan 20 1998 11:43:56   frido
* Added a filter for 24-bpp PatBlt.
*
*    Rev 1.40   Nov 03 1997 11:35:48   frido
* Added REQUIRE macros.
*
*    Rev 1.39   18 Aug 1997 09:24:04   FRIDO
*
* Changed all SWAT5 labels into MEMMGR (I forgot that during the merge).
* Added dynamic bitmap filter, borrowed from Windows 95.
*
*    Rev 1.38   29 May 1997 10:59:24   noelv
*
* Frido's fix for 9773
* SWAT:
* SWAT:    Rev 1.12   29 May 1997 12:12:20   frido
* SWAT: Changed striping code from 16-bit to 32-bit.
* SWAT:
* SWAT:    Rev 1.10   09 May 1997 12:57:30   frido
* SWAT: Added support for new memory manager.
*
*    Rev 1.37   29 Apr 1997 16:28:12   noelv
*
* Merged in new SWAT code.
* SWAT:
* SWAT:    Rev 1.9   24 Apr 1997 11:45:54   frido
* SWAT: NT140b09 merge.
* SWAT: Revised comments.
* SWAT:
* SWAT:    Rev 1.8   19 Apr 1997 16:42:30   frido
* SWAT: Added SWAT.h include file.
* SWAT:
* SWAT:    Rev 1.7   18 Apr 1997 00:14:58   frido
* SWAT: NT140b07 merge.
* SWAT:
* SWAT:    Rev 1.6   15 Apr 1997 19:13:34   frido
* SWAT: Added SWAT6: striping in PatBlt.
* SWAT:
* SWAT:    Rev 1.5   14 Apr 1997 15:30:12   frido
* SWAT: Enabled SWAT5 (new bitmap allocation scheme).
* SWAT:
* SWAT:    Rev 1.4   10 Apr 1997 17:37:12   frido
* SWAT: Started work on SWAT5 optimizations.
* SWAT:
* SWAT:    Rev 1.3   09 Apr 1997 20:24:18   frido
* SWAT: Revised SWAT1 once again.
* SWAT:
* SWAT:    Rev 1.2   09 Apr 1997 17:36:48   frido
* SWAT: Changed SWAT1 pre-allocation scheme.
* SWAT: Added SWAT1 and SWAT2 switches.
* SWAT:
* SWAT:    Rev 1.1   07 Apr 1997 17:48:06   frido
* SWAT: SWAT1: Added heap pre-allocation during WB97 pause.
*
*    Rev 1.36   08 Apr 1997 11:52:46   einkauf
*
* add SYNC_W_3D to coordination MCD and 2D hw access
*
*    Rev 1.35   21 Mar 1997 10:52:58   noelv
* Combined do_flag and sw_test_flag together into 'pointer_switch'.
*
*    Rev 1.34   04 Feb 1997 10:34:18   SueS
* Added support for hardware clipping for the 5465.
*
*    Rev 1.33   23 Jan 1997 11:03:18   noelv
*
* PuntBitBlt now handles device bitmaps stored on the host.
* bCreateScreenFromDIB now checks the return code from host to screen operati
*
*    Rev 1.32   17 Dec 1996 16:57:04   SueS
* Reject bitmaps of 32x64 or smaller.  This is based on WinBench97
* optimization.  Reject bitmaps that are larger than the visible screen
* width.  Added some things to log file writes.
*
*    Rev 1.31   27 Nov 1996 11:32:46   noelv
* Disabled Magic Bitmap.  Yeah!!!
*
*    Rev 1.30   26 Nov 1996 10:48:40   SueS
* Changed WriteLogFile parameters for buffering.
*
*    Rev 1.29   13 Nov 1996 17:05:12   SueS
* Changed WriteFile calls to WriteLogFile.
*
*    Rev 1.28   07 Nov 1996 16:07:08   bennyn
*
* Added no offscn mem allocation if DD enabled
*
*    Rev 1.27   18 Sep 1996 13:49:04   noelv
* Opps.  Forgot to unhook STROKEANDFILLPATH.
*
*    Rev 1.26   12 Sep 1996 09:18:42   noelv
* Fixed bug in infinite offscreen memory.
*
*    Rev 1.25   06 Sep 1996 09:03:54   noelv
*
* Cleaned up NULL driver code.
*
*    Rev 1.24   20 Aug 1996 11:03:10   noelv
* Bugfix release from Frido 8-19-96
*
*    Rev 1.3   18 Aug 1996 22:48:42   frido
* #lineto - Added DrvLineTo.
*
*    Rev 1.2   17 Aug 1996 19:35:36   frido
* Cleaned source.
* Changed ScreenToMemory bitblt.
*
*    Rev 1.1   15 Aug 1996 11:45:32   frido
* Added precompiled header.
*
*    Rev 1.0   14 Aug 1996 17:16:14   frido
* Initial revision.
*
*    Rev 1.23   07 Aug 1996 09:04:00   noelv
* Sync before punting.
*
*    Rev 1.22   11 Jul 1996 15:52:30   bennyn
* Changed constant 400 and 90 to #define variables
*
*    Rev 1.21   04 Jun 1996 15:56:32   noelv
* Debug code.
*
*    Rev 1.20   28 May 1996 15:11:02   noelv
* Updated data logging.
*
*    Rev 1.19   16 May 1996 15:05:54   bennyn
* Added PIXEL_ALIGN to allocoffscnmem()
*
*    Rev 1.18   16 May 1996 14:54:10   noelv
* Added logging code.
*
*    Rev 1.17   08 May 1996 17:02:46   noelv
*
* Preallocate device bitmap
*
*    Rev 1.16   03 May 1996 14:41:42   noelv
* Modified device bitmap allocation scheme.
*
*    Rev 1.15   01 May 1996 10:57:28   bennyn
*
* Modified for NT4.0
*
*    Rev 1.14   29 Apr 1996 14:16:20   noelv
* Clean up.
*
*    Rev 1.13   10 Apr 1996 14:13:52   NOELV
* Frido release 27
 *
 *    Rev 1.22   08 Apr 1996 16:47:44   frido
 * Added PuntBitBlt.
 *
 *    Rev 1.21   27 Mar 1996 13:06:58   frido
 * Added check for destination in ROP.
 * Masked color expansions.
 * Added return value to clipping routine.
 *
 *    Rev 1.20   25 Mar 1996 11:52:30   frido
 * Bellevue 102B03.
*
*    Rev 1.9   20 Mar 1996 14:17:30   bennyn
*
*    Rev 1.8   18 Mar 1996 11:42:30   noelv
* Added data loggin stuff.  Code cleanup.
*
*    Rev 1.7   13 Mar 1996 13:21:04   noelv
* Cleanup, documentation, and data logging.
*
*    Rev 1.6   12 Mar 1996 15:43:36   noelv
* Added data logging.
* Cleanup.
*
*    Rev 1.5   12 Mar 1996 11:17:48   noelv
* Code cleanup
*
*    Rev 1.4   08 Mar 1996 11:08:50   noelv
* Code cleanup and comments
*
*    Rev 1.3   05 Mar 1996 11:57:28   noelv
* Frido version 19
*
*    Rev 1.15   04 Mar 1996 20:21:44   frido
* Removed check for monochrome source and brush.
*
*    Rev 1.14   01 Mar 1996 17:47:58   frido
* Added check for destination in BLTDEF.
*
*    Rev 1.13   29 Feb 1996 20:17:32   frido
* Added test for special size device bitmaps.
* Check for bEnable in CreateScreenFromDib.
*
*    Rev 1.12   28 Feb 1996 22:37:12   frido
* Added Optimize.h.
* Added check for brushes with monochrome source.
*
*    Rev 1.11   27 Feb 1996 16:38:04   frido
* Added device bitmap store/restore.
*
*    Rev 1.10   26 Feb 1996 23:37:32   frido
* Fixed several bugs.
*
*    Rev 1.9   24 Feb 1996 01:25:12   frido
* Added device bitmaps.
* Removed old BitBlt code.
*
*    Rev 1.8   10 Feb 1996 21:39:28   frido
* Used SetBrush again for PatternBLT.
*
*    Rev 1.7   08 Feb 1996 00:19:50   frido
* Changed the interpretation of cache_slot.
*
*    Rev 1.6   05 Feb 1996 17:35:58   frido
* Added translation cache.
*
*    Rev 1.5   03 Feb 1996 13:58:28   frido
* Use the compile switch "-Dfrido=0" to disable my extensions.
*
*    Rev 1.4   31 Jan 1996 12:57:50   frido
* Called EngBitBlt in case of error.
* Changed clipping algorithmns.
*
*    Rev 1.3   25 Jan 1996 22:46:10   frido
* Removed bug in complex clipping.
*
*    Rev 1.2   25 Jan 1996 22:07:54   frido
* Speeded up the pattern blit.
*
\**************************************************************************/

#include "precomp.h"
#include "SWAT.h"               // SWAT optimizations.

#define BITBLT_DBG_LEVEL    1
#define CLIP_DBG_LEVEL      1
#define BITMAP_DBG_LEVEL    1
#define PUNT_DBG_LEVEL      1

#define P   1
#define S   2
#define D   4
#define PS  (P|S)
#define DP  (P|D)
#define DPS (P|D|S)
#define DS  (S|D)

//
// Table with ROP flags.
//
BYTE ropFlags[256] =
{
0,   DPS, DPS, PS,  DPS, DP,  DPS, DPS, DPS, DPS, DP,  DPS, PS,  DPS, DPS, P,
DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS,
DPS, DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS,
PS,  DPS, DPS, S,   DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, PS,  DPS, DPS, PS,
DPS, DPS, DPS, DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS,
DP,  DPS, DPS, DPS, DPS, D,   DPS, DPS, DPS, DPS, DP,  DPS, DPS, DPS, DPS, DP,
DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS,
DPS, DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS,
DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS,
DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS,
DP,  DPS, DPS, DPS, DPS, DP,  DPS, DPS, DPS, DPS, D,   DPS, DPS, DPS, DPS, DP,
DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS, DPS, DPS, DPS,
PS,  DPS, DPS, PS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, S,   DPS, DPS, PS,
DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS, DPS,
DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS,
P,   DPS, DPS, PS,  DPS, DP,  DPS, DPS, DPS, DPS, DP,  DPS, PS,  DPS, DPS, 0
};

COPYFN DoDeviceToDevice;
BOOL CopyDeviceBitmap(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclTrg,
    POINTL   *pptlSrc,
    ULONG    ulDRAWBLTDEF,
    COPYFN   *pfn);

BOOL PuntBitBlt(
    SURFOBJ*  psoDest,
    SURFOBJ*  psoSrc,
    SURFOBJ*  psoMask,
    CLIPOBJ*  pco,
    XLATEOBJ* pxlo,
    RECTL*    prclDest,
    POINTL*   pptlSrc,
    POINTL*   pptlMask,
    BRUSHOBJ* pbo,
    POINTL*   pptlBrush,
    ROP4      rop4);

#if SWAT6
void StripePatBlt(
        PPDEV   ppdev,
        ULONG   x,
        ULONG   y,
        ULONG   cx,
        ULONG   cy);
#endif


//
// If data logging is enabled, Prototype the logging files.
//
#if LOG_CALLS
    void LogBitBlt(
        int       acc,
        SURFOBJ*  psoSrc,
        SURFOBJ*  psoDest,
        ROP4 rop4,
        CLIPOBJ*  pco,
        BRUSHOBJ* pbo,
        XLATEOBJ* pxlo);

    void LogDrvCreateDevBmp(
        int acc,
        PPDEV  ppdev,
        SIZEL  sizl,
        PDSURF pdsurf);

    void LogDrvDeleteDevBmp(
        PDSURF pdsurf);

    void LogCreateDibFromScreen(
        int    acc,
        PPDEV  ppdev,
        PDSURF pdsurf);

    void LogCreateScreenFromDib(
        int acc,
        PPDEV  ppdev,
        PDSURF pdsurf);

//
// If data logging is not enabled, compile out the calls.
//
#else
    #define LogBitBlt(acc, psoSrc, psoDest, rop4, pco, pbo, pxlo)
    #define LogDrvCreateDevBmp(acc, ppdev, sizl, pdsurf)
    #define LogDrvDeleteDevBmp(pdsurf)
    #define LogCreateDibFromScreen(acc, ppdev, pdsurf)
    #define LogCreateScreenFromDib(acc, ppdev, pdsurf)
#endif


/****************************************************************************\
 * bIntersectTest                                                           *
 * Test for intersection between two rectangles.                            *
\****************************************************************************/
#define bIntersectTest(prcl1, prcl2) \
    (((prcl1)->left   < (prcl2)->right)  && \
     ((prcl1)->right  > (prcl2)->left)   && \
     ((prcl1)->top    < (prcl2)->bottom) && \
     ((prcl1)->bottom > (prcl2)->top))




/*****************************************************************************\
* BOOL DrvBitBlt                                                             *
\*****************************************************************************/
#if (USE_ASM && defined(i386))
BOOL i386BitBlt(
#else
BOOL DrvBitBlt(
#endif
SURFOBJ*  psoDest,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDest,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    PPDEV ppdev;
    ULONG fg_rop, bg_rop;
    ULONG bltdef = 0;
    BOOL  fSrc, fDest;

    #if NULL_BITBLT
    {
        if (pointer_switch)     return(TRUE);
    }
    #endif

    DISPDBG((BITBLT_DBG_LEVEL, "DrvBitBlt: Entry.\n"));
    ASSERTMSG(psoDest != NULL, "DrvBitBlt: No destination.\n");


    //
    // Get the PDEV associated with the destination.
    //
    ppdev = (PPDEV) ((psoDest != NULL) ? psoDest->dhpdev :
                    ((psoSrc != NULL) ? psoSrc->dhpdev : NULL));

    // Bad PDEV?
    if (ppdev == NULL) goto GoToEngine;

    SYNC_W_3D(ppdev);

    //
    // Set a flag to tell us if the source is the frame buffer.
    //
    fSrc = (psoSrc != NULL) &&                      // Is there a source?
            ((psoSrc->iType == STYPE_DEVBITMAP) ||  // Is it a device bmp?
             (psoSrc->hsurf == ppdev->hsurfEng) );  // Is it the screen?

    //
    // Set a flag telling us if the destination is the frame buffer.
    //
    fDest = (psoDest != NULL) &&                    // Is there a dest?
            ((psoDest->iType == STYPE_DEVBITMAP) || // Is it a device bmp?
             (psoDest->hsurf == ppdev->hsurfEng) ); // Is it the screen?

    //
    // If the destination is a DIB device bitmap, try copying it into
    // off-screen memory.
    //
    if ( fDest &&                               // If dest is supposed to be
                                                // the frame buffer,
         (psoDest->iType == STYPE_DEVBITMAP) && // and it's a device bitmap,
         ((PDSURF)psoDest->dhsurf)->pso )       // but it's really on the host,
    {
        // try to copy it back into off screen memory.
        if ( !bCreateScreenFromDib(ppdev, (DSURF*) psoDest->dhsurf) )
        {
            // If that fails, then the destination is now on the host.
            psoDest = ((PDSURF)psoDest->dhsurf)->pso;   // Host surface.
            fDest   = FALSE;                    // Dest is not frame buffer.
        }
    }

    //
    // If the source is a DIB device bitmap, try copying it into off-screen
    // memory.
    //
    if ( fSrc &&                                // If the source is supposed to
                                                // be the frame buffer,
         (psoSrc->iType == STYPE_DEVBITMAP) &&  // and it's a device bmp,
         ((PDSURF)psoSrc->dhsurf)->pso )        // but it's really on the host,
    {
        // try to copy it back into off-screen memory.
        if ( !bCreateScreenFromDib(ppdev, (DSURF*) psoSrc->dhsurf) )
        {
            // If that fails, then our source is really the host.
           psoSrc = ((PDSURF)psoSrc->dhsurf)->pso;  // Host surface.
           fSrc   = FALSE;                      // Src is not frame buffer.
        }
    }

    if ( fDest )
    {
        BYTE bROP;

        if (psoDest->iType == STYPE_DEVBITMAP)
            ppdev->ptlOffset = ((PDSURF)psoDest->dhsurf)->ptl;
        else
            ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;

        //
        // Extract the foreground and background ROP from the ROP4
        //
        ASSERTMSG( (rop4>>16) == 0, "DrvBitBlt: Upper word in ROP4 non-zero. \n");
        fg_rop = rop4 & 0x000000FF;
        bg_rop = (rop4>>8) & 0x000000FF;

        // Punt all true 4 op rops.
        // If fg_rop != bg_rop, then this is a true 4 op rop, so punt it.
        // If fg_rop == bg_rop, then it's really a three op rop.
        if ((fg_rop != bg_rop))        // It's a three op rop,
            goto GoToEngine;

        bROP = ropFlags[fg_rop];

        #if !(USE_ASM && defined(i386))
        {
            if (!(bROP & S))
            {
                // It is a PatBLT.  This is very important, so all calls to the
                // support routines are stretched into linear code, except for
                // the caching of the brushes, which should happen only once
                // for each brush.
                ULONG drawbltdef = 0x10000000 | fg_rop;
                if (bROP & D)
                    drawbltdef |= 0x01000000;

                // Do we have a pttern to load?
                if (bROP & P)
                {
                    ULONG color = pbo->iSolidColor;
                    if (color != (ULONG) -1)
                    {
                        // We have a solid color.
                        switch (ppdev->ulBitCount)
                        {
                        case 8:
                            color = (color << 8) | (color & 0xFF);
                        case 16:
                            color = (color << 16) | (color & 0xFFFF);
                        }
                        drawbltdef |= 0x00070000;
                        REQUIRE(2);
                        LL_BGCOLOR(color, 2);
                    }
                    else
                    {
                        if (!SetBrush(ppdev, &bltdef, pbo, pptlBrush))
                            goto GoToEngine;

                        drawbltdef |= bltdef << 16;
                    }
                }


                // Test for no clipping.
                if ( (pco == NULL) || (pco->iDComplexity == DC_TRIVIAL) )
                {
#if SWAT6
                    REQUIRE(2);
                    LL_DRAWBLTDEF(drawbltdef, 2);
                                        StripePatBlt(ppdev, prclDest->left + ppdev->ptlOffset.x,
                                                        prclDest->top + ppdev->ptlOffset.y,
                                                        prclDest->right - prclDest->left,
                                                        prclDest->bottom - prclDest->top);
#else
                    REQUIRE(7);
                    LL_DRAWBLTDEF(drawbltdef, 0);
                    LL_OP0(prclDest->left + ppdev->ptlOffset.x,
                           prclDest->top + ppdev->ptlOffset.y);
                    LL_BLTEXT(prclDest->right - prclDest->left,
                              prclDest->bottom - prclDest->top);
#endif
                }

                // Test for rectangle clipping.
                else if (pco->iDComplexity == DC_RECT)
                {
                    LONG x, y, cx, cy;
                    x  = max(prclDest->left,   pco->rclBounds.left);
                    y  = max(prclDest->top,    pco->rclBounds.top);
                    cx = min(prclDest->right,  pco->rclBounds.right)  - x;
                    cy = min(prclDest->bottom, pco->rclBounds.bottom) - y;
                    if ( (cx > 0) && (cy > 0) )
                    {
#if SWAT6
                        REQUIRE(2);
                        LL_DRAWBLTDEF(drawbltdef, 2);
                                                StripePatBlt(ppdev, x + ppdev->ptlOffset.x,
                                                                y + ppdev->ptlOffset.y, cx, cy);
#else
                        REQUIRE(7);
                        LL_DRAWBLTDEF(drawbltdef, 0);
                        LL_OP0(x + ppdev->ptlOffset.x, y + ppdev->ptlOffset.y);
                        LL_BLTEXT(cx, cy);
#endif
                    }
                }

                // Complex clipping.
                else
                {
                    BOOL       bMore;
                    ENUMRECTS8 ce;
                    RECTL*     prcl;

                 #if DRIVER_5465 && HW_CLIPPING
                    // Get a chunk of rectangles.
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                    // Enable clipping
                    REQUIRE(6);
                    LL_DRAWBLTDEF(drawbltdef | DD_CLIPEN, 0);
                    LL_CLIPULE(prclDest->left + ppdev->ptlOffset.x,
                               prclDest->top + ppdev->ptlOffset.y);
                    LL_CLIPLOR(prclDest->right + ppdev->ptlOffset.x,
                               prclDest->bottom + ppdev->ptlOffset.y);

                    do
                    {
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *) &ce);
                        for (prcl = ce.arcl; ce.c--; prcl++)
                        {
                            if ((prcl->right > prcl->left) &&
                                (prcl->bottom > prcl->top))
                            {
#if SWAT6
                                                                StripePatBlt(ppdev,
                                                                                prcl->left + ppdev->ptlOffset.x,
                                                                                prcl->top + ppdev->ptlOffset.y,
                                                                                prcl->right - prcl->left,
                                                                                prcl->bottom - prcl->top);
#else
                                REQUIRE(5);
                                LL_OP0(prcl->left + ppdev->ptlOffset.x,
                                       prcl->top + ppdev->ptlOffset.y);
                                LL_BLTEXT(prcl->right - prcl->left,
                                          prcl->bottom - prcl->top);
#endif
                            }
                        }
                    } while (bMore);
                 #else
                    REQUIRE(2);
                    LL_DRAWBLTDEF(drawbltdef, 2);

                    // Get a chunk of rectangles.
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
                    do
                    {
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *) &ce);
                        for (prcl = ce.arcl; ce.c--; prcl++)
                        {
                            LONG x, y, cx, cy;
                            x  = max(prclDest->left,   prcl->left);
                            y  = max(prclDest->top,    prcl->top);
                            cx = min(prclDest->right,  prcl->right)  - x;
                            cy = min(prclDest->bottom, prcl->bottom) - y;
                            if ( (cx > 0) && (cy > 0) )
                            {
#if SWAT6
                                                                StripePatBlt(ppdev, x + ppdev->ptlOffset.x,
                                                                                y + ppdev->ptlOffset.y, cx, cy);
#else
                                REQUIRE(5);
                                LL_OP0(x + ppdev->ptlOffset.x,
                                       y + ppdev->ptlOffset.y);
                                LL_BLTEXT(cx, cy);
#endif
                            }
                        }
                    }
                    while (bMore);
                 #endif
                }
                LogBitBlt(0, psoSrc, psoDest, rop4, pco, pbo, pxlo);
                return(TRUE);
            }
        }
        #endif // !(USE_ASM && defined(i386))

        // We only support HostToScreen blits where the Host is either
        // 1-bpp, 4-bpp, 8-bpp, or the same format as the screen.
        if ( ((psoSrc->iBitmapFormat > BMF_8BPP) &&
             (psoSrc->iBitmapFormat != psoDest->iBitmapFormat)) )
        {
            goto GoToEngine;
        }

        if (bROP & P)
        {
            // Realize the brush.
            if (!SetBrush(ppdev, &bltdef, pbo, pptlBrush))
            {
                goto GoToEngine;
            }
        }

        // If the destination is part of the ROP, set the bit.
        if (bROP & D)
        {
            bltdef |= 0x0100;
        }

        // Do the blit.
        if (CopyDeviceBitmap(psoDest, psoSrc, pco, pxlo, prclDest,
                             pptlSrc, (bltdef << 16) | fg_rop,
                             fSrc ? DoDeviceToDevice : ppdev->pfnHostToScreen))
        {
            LogBitBlt(0, psoSrc, psoDest, rop4, pco, pbo, pxlo);
            return(TRUE);
        }
    } // fDest

    else if (fSrc) // Destination is bitmap, source is screen or device bitmap.
    {
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
            ppdev->ptlOffset = ((PDSURF) psoSrc->dhsurf)->ptl;
        }
        else
        {
            ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;
        }

        #if S2H_USE_ENGINE
        {
            // ROP3?
            fg_rop = (BYTE) rop4;
            if (fg_rop == (rop4 >> 8))
            {
                BYTE bROP = ropFlags[fg_rop];

                // We dont's support ROPs where the destination is part of.
                if ( !(bROP & D) )
                {
                    // If we need a brush, load it.
                    if (bROP & P)
                    {
                        if (!SetBrush(ppdev, &bltdef, pbo, pptlBrush))
                        {
                            goto GoToEngine;
                        }
                    }
                    // Now, call the routine through the clip manager.
                    if (CopyDeviceBitmap(psoDest, psoSrc, pco, pxlo,
                                         prclDest, pptlSrc,
                                         (bltdef << 16) | fg_rop,
                                         ppdev->pfnScreenToHost))
                    {
                        LogBitBlt(0, psoSrc, psoDest, rop4, pco, pbo, pxlo);
                        return(TRUE);
                    }
                }
            }
        }
        #else
        {
            // We only support SRCCOPY.
            if (rop4 == 0x0000CCCC)
            {
                // Now, call the routine through the clip manager.
                if (CopyDeviceBitmap(psoDest, psoSrc, pco, pxlo, prclDest,
                                     pptlSrc, 0x000000CC,
                                     ppdev->pfnScreenToHost))
                {
                    LogBitBlt(0, psoSrc, psoDest, rop4, pco, pbo, pxlo);
                    return(TRUE);
                }
            }
        }
        #endif
    }

GoToEngine:

    // BLT is too complex. Punt it to GDI.

    DISPDBG((BITBLT_DBG_LEVEL, "DrvBitBlt: Exit (punt). ROP4 = 0x%02X%02X.\n",
             bg_rop,fg_rop));
    LogBitBlt(1, psoSrc, psoDest, rop4, pco, pbo, pxlo);
    return PuntBitBlt(psoDest, psoSrc, psoMask, pco, pxlo, prclDest, pptlSrc,
                      pptlMask, pbo, pptlBrush, rop4);
}

/*****************************************************************************\
 * DrvCreateDeviceBitmap
 *
 * This routine creates a device bitmap that is allocated off-screen.
 *
 * On entry:    dhpdev      Handle of PDEV structure.
 *      sizl        Size of the device bitmap to create.
 *      iFormat     Bitmap format of the device bitmap to create.
 *
 * Returns: We return the handle of a surface object that holds our device
 *      bitmap or 0 if there is an error.
\*****************************************************************************/
HBITMAP DrvCreateDeviceBitmap(
    DHPDEV dhpdev,
    SIZEL  sizl,
    ULONG  iFormat
)
{
    PPDEV   ppdev = (PPDEV) dhpdev;
    POFMHDL pofm;
    HBITMAP hbmDevice;
    PDSURF  pdsurf;
    FLONG   flHooks =   HOOK_SYNCHRONIZEACCESS | HOOK_TEXTOUT
                      | HOOK_BITBLT | HOOK_COPYBITS | HOOK_PAINT
                      | HOOK_STROKEPATH | HOOK_FILLPATH
                          #ifdef WINNT_VER40
                      | HOOK_LINETO
                      #endif
                  ;

    SYNC_W_3D(ppdev);

    #if WINBENCH96
        //
        // We support only device bitmaps that WinBench is going to use.  This
        // to circumvent the limitations of the heap management when there is
        // not so much video memory.
        //
        // Only support bitmaps with a width between 20 and 31, and bitmaps
        // wider than 100.
        if ( (sizl.cx < 20) || ((sizl.cx >= 32) && (sizl.cx < 100)) )
        {
            LogDrvCreateDevBmp(1, ppdev, sizl, NULL);
            return(0);
        }

    #else
        // We don't support anything under or equal to 8x8 (brushes) since
        // these will only slow us down.
        if ((sizl.cx <= 8) || (sizl.cy <= 8))
        {
            LogDrvCreateDevBmp(2, ppdev, sizl, NULL);
            return(0);
        }

                #if MEMMGR
                // New bitmap filter, borrowed from Windows 95.
                if (ppdev->fBitmapFilter)
                {
                        if ((  (sizl.cx <= ppdev->szlBitmapMin.cx)
                                && (sizl.cy <= ppdev->szlBitmapMin.cy)
                                )
                                || (sizl.cx > ppdev->szlBitmapMax.cx)
                                || (sizl.cy > ppdev->szlBitmapMax.cy)
                        )
                        {
                LogDrvCreateDevBmp(8, ppdev, sizl, NULL);
                DISPDBG((BITMAP_DBG_LEVEL, "DrvCreateDeviceBitmap - Rejected\n"));
                return(0);
                        }
                }
                #else
        // Reject any x<=32, or y<=64, for 16 or 24 bpp.
        // Improves WinBench97 scores.
        if ((iFormat == BMF_16BPP) || (iFormat == BMF_24BPP))
        {
            if ((sizl.cx <= 32) || (sizl.cy <= 64))
            {
                LogDrvCreateDevBmp(8, ppdev, sizl, NULL);
                DISPDBG((BITMAP_DBG_LEVEL, "DrvCreateDeviceBitmap - Reject x<=32||y<=64\n"));
                return(0);
            }
        }
                #endif

    #endif

    // Reject if bigger than current screen size
    if ((ULONG)sizl.cx > ppdev->cxScreen)
    {
       LogDrvCreateDevBmp(9, ppdev, sizl, NULL);
       DISPDBG((BITMAP_DBG_LEVEL, "DrvCreateDeviceBitmap - Reject > cxScreen\n"));
       return(0);
    }

    // If the hardware is not in graphics mode, don't create a device bitmap!
    if (!ppdev->bEnable)
    {
        LogDrvCreateDevBmp(3, ppdev, sizl, NULL);
        return(0);
    }

    // We don't support device bitmaps in any other mode than the hardware.
    if (iFormat != ppdev->iBitmapFormat)
    {
        return(0);
    }

    #ifdef ALLOC_IN_CREATESURFACE
        if (ppdev->bDirectDrawInUse)
           return (0);
    #endif
#if SWAT1
        // Is this the very first device bitmap?
        if (ppdev->fPreAllocate == FALSE)
        {
                // Setup step-down counter.
                ppdev->fPreAllocate = TRUE;
                ppdev->nPages = 10;
        }

        // Is this the WinBench 97 pause bitmap?
        else if (sizl.cx == 300 && sizl.cy == 150)
        {
                if (ppdev->nPages == 0)
                {
                        PVOID p;
                        // Allocate 8 full-screen pages from the heap.
                        #ifdef WINNT_VER40
                        p = MEM_ALLOC(FL_ZERO_MEMORY, 8 * ppdev->cxScreen *
                                        ppdev->iBytesPerPixel * ppdev->cyScreen, ALLOC_TAG);
                        #else
                        p = MEM_ALLOC(LPTR, 8 * ppdev->cxScreen * ppdev->iBytesPerPixel *
                                        ppdev->cyScreen);
                        #endif
                        // Free it again.
                        MEMORY_FREE(p);
                }
                else
                {
                        // Decrement step-down counter.
                        ppdev->nPages--;
                }
        }

        // Is this a full-screen device bitmap?
        else if (  (ppdev->nPages == 0)
                        && (sizl.cx == (LONG) ppdev->cxScreen)
                        && (sizl.cy == (LONG) ppdev->cyScreen)
        )
        {
                PVOID p;
                // Allocate 8 full-screen pages from the heap.
                #ifdef WINNT_VER40
                p = MEM_ALLOC(FL_ZERO_MEMORY, 8 * ppdev->cxScreen *
                                ppdev->iBytesPerPixel * ppdev->cyScreen, ALLOC_TAG);
                #else
                p = MEM_ALLOC(LPTR, 8 * ppdev->cxScreen * ppdev->iBytesPerPixel *
                                ppdev->cyScreen);
                #endif
                // Free it again.
                MEMORY_FREE(p);
        }
#endif // SWAT1

#if SWAT2
        // Is this a full-screen device bitmap?
        if (   (sizl.cx == (LONG) ppdev->cxScreen)
                && (sizl.cy == (LONG) ppdev->cyScreen)
        )
        {
                #if MEMMGR
                // Hostify all device bitmaps.
                extern void HostifyAllBitmaps(PPDEV ppdev);
                HostifyAllBitmaps(ppdev);
                #else
                POFMHDL pofm, pofmNext;

                // Hostify all current off-screen device bitmaps.
                for (pofm = ppdev->OFM_UsedQ; pofm; pofm = pofmNext)
                {
                        pofmNext = pofm->nexthdl;

                        if (pofm->pdsurf && pofm->pdsurf->pofm)
                        {
                                bCreateDibFromScreen(ppdev, pofm->pdsurf);
                        }
                        else if (pofm->alignflag & SAVESCREEN_FLAG)
                        {
                                FreeOffScnMem(ppdev, pofm);
                        }
                }
                #endif
        }
#endif // SWAT2

    //
    // Allocate off-screen memory.
    //
    {
       #if INFINITE_OFFSCREEN_MEM
        //
        // This is our "infinite offscreen memory" test.  Here we always
        // succeed in memory allocation.  We do this by always allocating
        // bitmaps at screen 0,0.
        // It looks ugly, but we can use it to tell of our memory management
        // is hurting our benchmark scores.
        // This option is turned off for the retail version of the driver.
        // 'pointer_switch' is turned on and off in POINTER.C by moving the pointer
        // to a special place on the screen.
        //
        if (pointer_switch)
        {
            pofm = ppdev->ScrnHandle;
        }
        else
        #endif // INFINITE_OFFSCREEN_MEM
        {
            #if WINBENCH96
            //
            // This is our Magic Bitmap.
            // Winbench 96 allocates one special bitmap into which it does *lots*
            // of drawing.  If the allocation for this bitmap fails, our WinBench
            // score will be poor.  We ensure that this allocation succeeds
            // by pre-allocating it at boot time.
            //
            // If the size of the requested bitmap matches our magic bitmap, we
            // assume that Winbench is requesting it's special bitmap, and so we
            // use the magic bitmap.
            //
            if ( (sizl.cx == MAGIC_SIZEX) && (sizl.cy == MAGIC_SIZEY) &&
                 ppdev->pofmMagic && !ppdev->bMagicUsed)
            {
                // If fits.  Use pre-allocated bitmap.
                DISPDBG((BITMAP_DBG_LEVEL,
                         "DrvCreateDeviceBitmap - Using the Magic Bitmap.\n"));
                ppdev->bMagicUsed = 1;
                pofm = ppdev->pofmMagic;
            }
            else
            #endif
            {
                DISPDBG((BITMAP_DBG_LEVEL,
                "DrvCreateDeviceBitmap - Allocating a %d x %d device bitmap.\n",
                 sizl.cx, sizl.cy));
                                #if MEMMGR
                                if (ppdev->fBitmapFilter)
                                {
                                        pofm = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
                                        if (pofm == NULL)
                                        {
                                                HostifyAllBitmaps(ppdev);
                                                pofm = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
                                        }
                                }
                                else if (sizl.cx <= ppdev->must_have_width)
                                {
                        pofm = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN | MUST_HAVE,
                                NULL);
                                }
                                else
                                #endif
                pofm = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
            }
        }
    }

    //
    // If we got the offscreen memory we need, then let's do some work.
    //
    if (pofm != NULL)
    {
        // Allocate device bitmap structure.

        #ifdef WINNT_VER40
            pdsurf = MEM_ALLOC(FL_ZERO_MEMORY, sizeof(DSURF), ALLOC_TAG);
        #else
            pdsurf = MEM_ALLOC(LPTR, sizeof(DSURF));
        #endif

        if (pdsurf != NULL)
        {
            // Create the device bitmap object.
            hbmDevice = EngCreateDeviceBitmap((DHSURF) pdsurf, sizl, iFormat);
            if (hbmDevice != NULL)
            {
                // Associate the device bitmap with the surface.
                if (EngAssociateSurface((HSURF) hbmDevice,
                                                                ppdev->hdevEng,
                                                                                flHooks)
                )
                {
                    // Store a pointer to the surface.
                    {
                        #if INFINITE_OFFSCREEN_MEM
                            //
                            // If we're using screen(0,0) as a device bitmap
                            // then don't walk on ScrnHandle->pdsurf!
                            //
                            if (pofm != ppdev->ScrnHandle)
                        #endif
                        pofm->pdsurf = pdsurf;
                    }

                    // Initialize the device bitmap structure.
                    pdsurf->ppdev = ppdev;
                    pdsurf->pofm = pofm;
                    pdsurf->ptl.x = pofm->aligned_x / ppdev->iBytesPerPixel;
                    pdsurf->ptl.y = pofm->aligned_y;
                    pdsurf->packedXY = (pdsurf->ptl.y << 16) | pdsurf->ptl.x;
                    pdsurf->sizl = sizl;
                    LogDrvCreateDevBmp(0, ppdev, sizl, pdsurf);

                    return(hbmDevice);
                }
                else
                {
                    LogDrvCreateDevBmp(4, ppdev, sizl, NULL);
                }
                // Delete the surface
                EngDeleteSurface((HSURF) hbmDevice);
            }
            else
            {
                LogDrvCreateDevBmp(5, ppdev, sizl, NULL);
            }
            // Free the device bitmap structure.
            MEMORY_FREE(pdsurf);
        }
        else
        {
            LogDrvCreateDevBmp(6, ppdev, sizl, NULL);
        }

        #if WINBENCH96
        // Free the off-screen memory.
        if (pofm == ppdev->pofmMagic)
        {
            // We were using the preallocated memory block.  Don't free it,
            // just mark it as unused.
            ppdev->bMagicUsed = 0;
        }
        else
        #endif
        {
            #if INFINITE_OFFSCREEN_MEM
                // But don't free it if the device bitmap is at screen(0,0)...
                if (pofm != ppdev->ScrnHandle)
            #endif
            FreeOffScnMem(ppdev, pofm);
        }
    }
    else
    {
        LogDrvCreateDevBmp(7, ppdev, sizl, NULL);
    }

    return(0);
}

/*****************************************************************************\
 * DrvDeleteDeviceBitmap
 *
 * This routine deletes a device bitmap and frees the off-screen memory.
 *
 * On entry:    pdsurf          Pointer to device bitmap to delete.
\*****************************************************************************/
void DrvDeleteDeviceBitmap(DHSURF dhsurf)
{

        PDSURF pdsurf = (PDSURF) dhsurf;

    //
    // Log this call to a file.
    //
    LogDrvDeleteDevBmp(pdsurf);

    // Is the device bitmap stored in a DIB?
    if (pdsurf->pso)
    {
        // Delete the in-memory DIB.
        HSURF hsurfDib = pdsurf->pso->hsurf;
        EngUnlockSurface(pdsurf->pso);
        EngDeleteSurface(hsurfDib);
    }
    else
    {
        PPDEV ppdev = pdsurf->ppdev;

        #if INFINITE_OFFSCREEN_MEM
            //
            // If we're using screen(0,0) as a device bitmap
            // then don't walk on ScrnHandle->pdsurf!
            //
            if (pdsurf->pofm != ppdev->ScrnHandle)
        #endif

        pdsurf->pofm->pdsurf = NULL;

        #if WINBENCH96
        if ( pdsurf->pofm == ppdev->pofmMagic)
        {
            // We were using the preallocated chunk of memory.  Don't free
            // it, just mark it as unused.
            ppdev->bMagicUsed = 0;
        }
        else
        #endif
        {
            // Free the off-screen memory.
            #if INFINITE_OFFSCREEN_MEM
                // unless our device bitmap is at screen(0,0)...
                if (pdsurf->pofm != ppdev->ScrnHandle)
            #endif
            FreeOffScnMem(pdsurf->ppdev, pdsurf->pofm);
        }
    }

    // Free the device bitmap structure.
    MEMORY_FREE(pdsurf);
}


/*****************************************************************************\
 * bCreateDibFromScreen
 *
 * This routine copy a device bitmap into a DIB and frees the off-screen
 * memory.
 *
 * On entry:    ppdev           Pointer to physical device.
 *      pdsurf          Pointer to device bitmap to copy.
 *
 * Returns: TRUE if the off-screen device bitmap was sucessfully copied
 *      into a memory DIB.
\*****************************************************************************/
BOOL bCreateDibFromScreen(
    PPDEV  ppdev,
    PDSURF pdsurf
)
{
    HBITMAP hbmDib;

    // Create a DIB.
    hbmDib = EngCreateBitmap(pdsurf->sizl, 0, ppdev->iBitmapFormat,
                             BMF_TOPDOWN, NULL);
    if (hbmDib)
    {
        // Associate the surface with the driver.
        if (EngAssociateSurface((HSURF) hbmDib, ppdev->hdevEng, 0))
        {
            // Lock the surface.
            SURFOBJ* pso = EngLockSurface((HSURF) hbmDib);
            if (pso != NULL)
            {
                SIZEL sizl;
                PBYTE pjScreen, pjBits;

                // Calculate the size of the blit.
                sizl.cx = pdsurf->sizl.cx * ppdev->iBytesPerPixel;
                sizl.cy = pdsurf->sizl.cy;

                // Calculate the destination variables.
                pjBits = (PBYTE) pso->pvScan0;

                // Calculate the screen address.
                pjScreen = ppdev->pjScreen
                         + (pdsurf->ptl.x * ppdev->iBytesPerPixel)
                         + (pdsurf->ptl.y * ppdev->lDeltaScreen);

                // Wait for the hardware to become idle.
                while (LLDR_SZ(grSTATUS) != 0) ;

                while (sizl.cy--)
                {
                    // Copy all pixels from screen to memory.
                    memcpy(pjBits, pjScreen, sizl.cx);

                    // Next line.
                    pjScreen += ppdev->lDeltaScreen;
                    pjBits += pso->lDelta;
                }

                #if WINBENCH96
                    //
                    // If the block we are freeing is our preallocated
                    // piece, then invalidate it's pointer.
                    //
                    if ( pdsurf->pofm == ppdev->pofmMagic)
                        ppdev->pofmMagic = 0;
                #endif

                                #if !MEMMGR
                // Free the off-screen memory handle.
                #if INFINITE_OFFSCREEN_MEM
                    // unless our device bitmap is at screen(0,0)...
                    if (pdsurf->pofm != ppdev->ScrnHandle)
                #endif
                FreeOffScnMem(pdsurf->ppdev, pdsurf->pofm);
                                #endif

                // Mark the device bitmap as DIB.
                pdsurf->pofm = NULL;
                pdsurf->pso = pso;

                // Done.
                LogCreateDibFromScreen(0, ppdev, pdsurf);
                return(TRUE);
            }
            else
            {
                // Failed to lock host surface
                LogCreateDibFromScreen(1, ppdev, pdsurf);
            }
        }
        else
        {
            // Failed to associate host surface
            LogCreateDibFromScreen(2, ppdev, pdsurf);
        }

        // Delete the DIB.
        EngDeleteSurface((HSURF) hbmDib);
    }
    else
    {
        // Failed to create host surface.
        LogCreateDibFromScreen(3, ppdev, pdsurf);
    }

    // Error.
    return(FALSE);
}

/*****************************************************************************\
 * bCreateScreenFromDib
 *
 * This routine copys a DIB into a device bitmap and frees the DIB from memory.
 *
 * On entry:    ppdev           Pointer to physical device.
 *      pdsurf          Pointer to device bitmap to copy.
 *
 * Returns:     TRUE if the DIB was sucessfully copied into an off-screen
 *          device bitmap.
\*****************************************************************************/
BOOL bCreateScreenFromDib(
    PPDEV     ppdev,
    PDSURF    pdsurf
)
{
    POFMHDL  pofm;
    HSURF    hsurf;
    SURFOBJ* pso;

        #if MEMMGR
        // In low memory situations, bitmaps will be hostified very frequently, so
        // don't copy them back to the off-screen...
        if (ppdev->fBitmapFilter)
        {
                return FALSE;
        }
        #endif

    // If the hardware is not in graphics mode, keep the device bitmap in
    // memory.
    if (!ppdev->bEnable)
    {
        LogCreateScreenFromDib (1, ppdev, pdsurf);
        return(FALSE);
    }

    #ifdef ALLOC_IN_CREATESURFACE
        if (ppdev->bDirectDrawInUse)
            return (FALSE);
    #endif

    // Allocate off-screen memory.
    pofm = AllocOffScnMem(ppdev, &pdsurf->sizl, PIXEL_AlIGN, NULL);
    if (pofm != NULL)
    {
        SURFOBJ psoDest;
        RECTL   rclDest;
        POINTL  ptlSrc;

        //
        // Tell the device bitmap where it lives in offscreen memory.
        //
        pdsurf->ptl.x = pofm->aligned_x / ppdev->iBytesPerPixel;
        pdsurf->ptl.y = pofm->aligned_y;
        pdsurf->packedXY = (pdsurf->ptl.y << 16) | pdsurf->ptl.x;

        //
        // Create a two way link between the device bitmap and
        // its offscreen memory block.
        //
        pdsurf->pofm = pofm;   // Attach offscreen memory block to device bitmap
        pofm->pdsurf = pdsurf; // Attach device bitmap to offscreen memory block

        //
        // Disattach the host bitmap from the device bitmap.
        // Save the pointer, because if we fail to move the device bitmap
        // into the frame buffer, it will remain in host memory, and we
        // will have to restore this pointer.
        //
        pso = pdsurf->pso;     // Save pointer to bitmap in host memory.
        pdsurf->pso = NULL;    // disattach host memory

        //
        // Wrap the offscreen memory in a destination surface object.
        // This is so we can use a host to screen BLT to move the bitmap
        // from the host to the offscreen memory.
        //
        psoDest.dhsurf = (DHSURF) pdsurf;
        psoDest.iType = STYPE_DEVBITMAP;

        //
        // Build a destination rectangle that describes where to put the
        // bitmap in offscreen memory.  This rectangle is relative to
        // upper left corner of the allocated block of offscreen memory.
        //
        rclDest.left = 0;
        rclDest.top = 0;
        rclDest.right = pdsurf->sizl.cx;
        rclDest.bottom = pdsurf->sizl.cy;

        //
        // Build a source point.
        // Since we're moving the entire bitmap, its (0,0).
        //
        ptlSrc.x = ptlSrc.y = 0;

        //
        // Use our host to screen code to copy the DIB into off-screen memory.
        //
        if (!ppdev->pfnHostToScreen(&psoDest, pso, NULL, &rclDest, &ptlSrc,
                               0x000000CC))
        {
            //
            // BLT engine couldn't put it back into off screen memory.
            // Maybe the DIB engine can.
            //
            DISPDBG (( 0, "Couldn't BLT device bitmap back into framebuffer.\n"));

            if (! PuntBitBlt(&psoDest, pso, NULL, NULL, NULL,
                             &rclDest, &ptlSrc, NULL, NULL, NULL, 0x0000CCCC))
            {
                // Nope!  We can't move it back to the frame buffer.
                DISPDBG (( 0, "Couldn't punt device bitmap back into framebuffer.\n"));
                DISPDBG (( 0, "Device bitmap will remain in offscreen memory.\n"));

                // Restore the surface object pointers.
                pdsurf->pofm = NULL; // This device bitmap has no offscreen memory.
                pdsurf->pso = pso;   // This device bitmap lives here, on the host.

                // Free the offscreen memory we allocated and fail.
                FreeOffScnMem(ppdev, pofm);
                return FALSE;
            }
        }

        // Delete the DIB.
        hsurf = pso->hsurf;
        EngUnlockSurface(pso);
        EngDeleteSurface(hsurf);

        // Done.
        LogCreateScreenFromDib (0, ppdev, pdsurf);
        return(TRUE);
    }

    // Error.
    LogCreateScreenFromDib (2, ppdev, pdsurf);
    return(FALSE);
}

#if LOG_CALLS
// ============================================================================
//
//    Everything from here down is for data logging and is not used in the
//    production driver.
//
// ============================================================================
extern long lg_i;
extern char lg_buf[256];


// ****************************************************************************
//
// LogBitBlt()
// This routine is called only from DrvBitBlt()
// Dump information to a file about what is going on in BitBlt land.
//
// ****************************************************************************
void LogBitBlt(
        int       acc,
        SURFOBJ*  psoSrc,
        SURFOBJ*  psoDest,
        ROP4 rop4,
        CLIPOBJ*  pco,
        BRUSHOBJ* pbo,
        XLATEOBJ* pxlo)
{
    PPDEV dppdev,sppdev,ppdev;
    BYTE fg_rop, bg_rop;
    ULONG iDComplexity;

    dppdev = (PPDEV) (psoDest ? psoDest->dhpdev : 0);
    sppdev = (PPDEV) (psoSrc  ? psoSrc->dhpdev  : 0);
    ppdev = dppdev ? dppdev : sppdev;

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    lg_i = sprintf(lg_buf,"DBB: ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    if (acc)
    {
        lg_i = sprintf(lg_buf,"PNT ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }

    fg_rop = (BYTE) (rop4 & 0xff);
    bg_rop = (BYTE) ((rop4>>8) & 0xff);


    //
    // Check the SRC
    //
    if ( (ropFlags[fg_rop] & S) &&
         (psoSrc))
    {
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
            lg_i = sprintf(lg_buf, "Src Id=%p ", psoSrc->dhsurf);
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

            if ( ((PDSURF)psoSrc->dhsurf)->pso  )
                lg_i = sprintf(lg_buf,"S=DH ");
            else
                lg_i = sprintf(lg_buf,"S=DF ");
        }
        else if (psoSrc->hsurf == ppdev->hsurfEng)
            lg_i = sprintf(lg_buf,"S=S ");
        else
            lg_i = sprintf(lg_buf,"S=H ");
    }
    else
        lg_i = sprintf(lg_buf,"S=N ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    //
    // Check the DEST
    //
    if (psoDest)
    {
        if (psoDest->iType == STYPE_DEVBITMAP)
        {
            lg_i = sprintf(lg_buf, "Dst Id=%p ", psoDest->dhsurf);
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

            if (  ((PDSURF)psoDest->dhsurf)->pso   )
                lg_i = sprintf(lg_buf,"D=DH ");
            else
                lg_i = sprintf(lg_buf,"D=DF ");
        }
        else if (psoDest->hsurf == ppdev->hsurfEng)
            lg_i = sprintf(lg_buf,"D=S ");
        else
            lg_i = sprintf(lg_buf,"D=H ");
    }
    else
        lg_i = sprintf(lg_buf,"D=N ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);



    //
    // Check the ROP
    //
    if (fg_rop == bg_rop)
        lg_i = sprintf(lg_buf,"R3=%02X ", fg_rop);
    else
        lg_i = sprintf(lg_buf,"R4=%04X ", rop4&0xFFFF);
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    //
    // Check the type of clipping.
    //
    iDComplexity = (pco ? pco->iDComplexity : DC_TRIVIAL);
    lg_i = sprintf(lg_buf,"C=%s ",
                (iDComplexity==DC_TRIVIAL ? "T":
                (iDComplexity == DC_RECT ? "R" : "C" )));
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    //
    // Type of pattern.
    //
   if (ropFlags[fg_rop] & P)
   {
      if (pbo->iSolidColor == 0xFFFFFFFF )
      {
        lg_i = sprintf(lg_buf,"BR=P ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
      }
      else
      {
        lg_i = sprintf(lg_buf,"BR=0x%X ",(pbo->iSolidColor));
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
      }
    }
    else
    {
        lg_i = sprintf(lg_buf,"BR=N ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }


    //
    // Type of translation
    //
    if (!pxlo)
    {
        lg_i = sprintf(lg_buf,"TR=N ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else if (pxlo->flXlate & XO_TRIVIAL)
    {
        lg_i = sprintf(lg_buf,"TR=T ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else
    {
        lg_i = sprintf(lg_buf,"TR=NT ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }

    lg_i = sprintf(lg_buf,"\r\n");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    return;
}



// ****************************************************************************
//
// LogDrvCreateDevBmp()
// This routine is called only from DrvCreateDeviceBitmap()
// Dump information to a file about what is going on in device bitmap land.
//
// ****************************************************************************
void LogDrvCreateDevBmp(
    int acc,
    PPDEV  ppdev,
    SIZEL  sizl,
    PDSURF pdsurf)
{

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    switch(acc)
    {
    case 0: // Accelerated
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Id: 0x%08X  Loc: %d,%d \r\n",
                sizl.cx, sizl.cy, pdsurf, pdsurf->pofm->x, pdsurf->pofm->y );
        break;

    case 1: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt size.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 2: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt 8x8.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 3: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt mode.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 4: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt assoc.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 5: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt bitmap.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 6: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt DSURF.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 7: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt FB alloc.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 8: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt 32x64.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 9: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt > cxScreen.\r\n",
                sizl.cx, sizl.cy);
        break;

    default:
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt unknown.\r\n",
                sizl.cx, sizl.cy);
        break;

    }
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
 }



// ****************************************************************************
//
// LogDrvDeleteDevBmp()
// This routine is called only from DrvDeleteDeviceBitmap()
// Dump information to a file about what is going on in device bitmap land.
//
// ****************************************************************************
void LogDrvDeleteDevBmp(
    PDSURF pdsurf)
{

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    lg_i = sprintf(lg_buf, "DrvDeleteDeviceBitmap:   Id: 0x%08X. ", pdsurf);
    WriteLogFile(pdsurf->ppdev->pmfile, lg_buf,
                 lg_i, pdsurf->ppdev->TxtBuff, &pdsurf->ppdev->TxtBuffIndex);

    if (pdsurf->pso)
    {
        lg_i = sprintf(lg_buf, "Loc: HOST\r\n");
        WriteLogFile(pdsurf->ppdev->pmfile, lg_buf, lg_i,
                     pdsurf->ppdev->TxtBuff, &pdsurf->ppdev->TxtBuffIndex);
    }
    else
    {
        lg_i = sprintf(lg_buf, "Loc: %d,%d\r\n", pdsurf->pofm->x, pdsurf->pofm->y);
        WriteLogFile(pdsurf->ppdev->pmfile, lg_buf, lg_i,
                     pdsurf->ppdev->TxtBuff, &pdsurf->ppdev->TxtBuffIndex);
    }
}



// ****************************************************************************
//
// LogCreateDibFromScreen()
// This routine is called only from bCreateDibFromScreen()
// Dump information to a file about what is going on in device bitmap land.
//
// ****************************************************************************
void LogCreateDibFromScreen(
    int acc,
    PPDEV  ppdev,
    PDSURF pdsurf
)
{

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    lg_i = sprintf(lg_buf, "CreateDibFromScreen:     Id: 0x%08X ", pdsurf);
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    switch(acc)
    {
    case 0: // Succeeded
        lg_i = sprintf(lg_buf, " \r\n");
        break;

    case 1: // Failed
        lg_i = sprintf(lg_buf, "Fail lock\r\n");
        break;

    case 2: // Failed
        lg_i = sprintf(lg_buf,  "Fail assoc\r\n");
        break;

    case 3: // Failed
        lg_i = sprintf(lg_buf,   " Fail create\r\n");
        break;

    default:
        lg_i = sprintf(lg_buf,  "Failed unknown\r\n");
        break;
    }

    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}



// ****************************************************************************
//
// LogCreateScreenFromDib()
// This routine is called only from bCreateScreenFromDib()
// Dump information to a file about what is going on in device bitmap land.
//
// ****************************************************************************
void LogCreateScreenFromDib(
    int acc,
    PPDEV  ppdev,
    PDSURF pdsurf
)
{
    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    lg_i = sprintf(lg_buf,   "CreateScreenFromDib: ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    switch(acc)
    {
    case 0: // Succeeded
        lg_i = sprintf(lg_buf, "Id: 0x%08X  Dest: %d,%d\r\n",
                pdsurf, pdsurf->pofm->x, pdsurf->pofm->y );
        break;

    case 1: // Failed
        lg_i = sprintf(lg_buf, "Fail mode\r\n");
        break;

    case 2: // Failed
        lg_i = sprintf(lg_buf, "Fail alloc\r\n");
        break;

    default: // Failed
        lg_i = sprintf(lg_buf, "Fail unknown\r\n");
        break;

    }

    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}

#endif // LOG_CALLS


// ============================================================================
//
// Punt a drawing operation back to GDI.
//      Return TRUE if punt was successful.
//      Return FALSE if punt failed.
//
BOOL PuntBitBlt(
    SURFOBJ*  psoDest,
    SURFOBJ*  psoSrc,
    SURFOBJ*  psoMask,
    CLIPOBJ*  pco,
    XLATEOBJ* pxlo,
    RECTL*    prclDest,
    POINTL*   pptlSrc,
    POINTL*   pptlMask,
    BRUSHOBJ* pbo,
    POINTL*   pptlBrush,
    ROP4      rop4)
{
    HBITMAP hbmDibSrc = 0;
    HBITMAP hbmDibDest = 0;
    PBYTE   pjScreen;
    BOOL    bStatus;
    PDSURF  pdsurf;
    PPDEV   ppdev = 0;

    DISPDBG((PUNT_DBG_LEVEL, "PuntBitBlt: Entry.\n"));


    //
    // If the source is a device bitmap, build a wrapper around it.
    //
    if ( psoSrc && (psoSrc->iType == STYPE_DEVBITMAP))
    {
        // Source is a device bitmap.
        pdsurf = (PDSURF) psoSrc->dhsurf;
        ppdev = pdsurf->ppdev;

        if ( pdsurf->pofm )  // If it's in the frame buffer.
        {
            DISPDBG((PUNT_DBG_LEVEL,
                "    Source is device bitmap at (%d,%d).\n",
                (pdsurf->ptl.x), (pdsurf->ptl.y)));

            // Calculate the off-screen address.
            // This is the upper left pixel in the device bitmap.
            pjScreen = ppdev->pjScreen
                     + (pdsurf->ptl.x * ppdev->iBytesPerPixel)
                     + (pdsurf->ptl.y * ppdev->lDeltaScreen);

            // Create a DIB. Point it's bits at the device bitmap.
            hbmDibSrc = EngCreateBitmap(pdsurf->sizl, ppdev->lDeltaScreen,
                                        ppdev->iBitmapFormat, BMF_TOPDOWN,
                                        pjScreen);

            // Associate the DIB surface with the driver.
            EngAssociateSurface((HSURF) hbmDibSrc, ppdev->hdevEng, 0);

            // Lock the DIB surface.
            psoSrc = EngLockSurface((HSURF) hbmDibSrc);
        }

        else // The device bitmap is on the host.
        {
            DISPDBG((PUNT_DBG_LEVEL, "    Source is device bitmap on host.\n"));
            psoSrc = pdsurf->pso;   // This is where it lives on the host.
        }
    }


    //
    // If the destination is a device bitmap, build a wrapper around it.
    //
    if ( psoDest && (psoDest->iType == STYPE_DEVBITMAP))
    {
        // Destination is a device bitmap.
        pdsurf = (PDSURF) psoDest->dhsurf;
        ppdev = pdsurf->ppdev;

        if ( pdsurf->pofm )  // If it's in the frame buffer.
        {
            DISPDBG((PUNT_DBG_LEVEL,
                "    Dest is device bitmap at (%d,%d).\n",
                (pdsurf->ptl.x), (pdsurf->ptl.y)));

            // Calculate the off-screen address.
            // This is the upper left pixel in the device bitmap.
            pjScreen = ppdev->pjScreen
                     + (pdsurf->ptl.x * ppdev->iBytesPerPixel)
                     + (pdsurf->ptl.y * ppdev->lDeltaScreen);

            // Create a DIB. Point it's bits at the device bitmap.
            hbmDibDest = EngCreateBitmap(pdsurf->sizl, ppdev->lDeltaScreen,
                                         ppdev->iBitmapFormat, BMF_TOPDOWN,
                                         pjScreen);

            // Associate the DIB surface with the driver.
            EngAssociateSurface((HSURF) hbmDibDest, ppdev->hdevEng, 0);

            // Lock the DIB surface.
            psoDest = EngLockSurface((HSURF) hbmDibDest);
        }

        else // The device bitmap is on the host.
        {
            DISPDBG((PUNT_DBG_LEVEL, "    Dest is device bitmap on host.\n"));
            psoDest = pdsurf->pso;
        }
    }


    //
    // We're fooling GDI into thinking it's drawing to memory, when it's really
    // drawing to the frame buffer.  This means GDI won't call DrvSync() before
    // drawing.
    //
    if (ppdev == 0)
    {
         ppdev = (PPDEV) psoDest->dhpdev;
         if (ppdev == 0)
             ppdev = (PPDEV) psoSrc->dhpdev;
    }
    ASSERTMSG(ppdev,"Panic.  No ppdev in PuntBitBlt()!");
    DrvSynchronize((DHPDEV) ppdev, NULL);

    // Now, call the GDI.
    bStatus = EngBitBlt(psoDest, psoSrc, psoMask, pco, pxlo, prclDest, pptlSrc,
                        pptlMask, pbo, pptlBrush, rop4);

    // Delete the wrappers if they are created.
    if (hbmDibSrc)
    {
        EngUnlockSurface(psoSrc);
        EngDeleteSurface((HSURF) hbmDibSrc);
    }
    if (hbmDibDest)
    {
        EngUnlockSurface(psoDest);
        EngDeleteSurface((HSURF) hbmDibDest);
    }

    DISPDBG((PUNT_DBG_LEVEL, "PuntBitBlt: Exit.\n"));

    // Return the status.
    return(bStatus);
}

#if SWAT6
/******************************************************************************\
* FUNCTION:             StripePatBlt
*
* DESCRIPTION:  Perform a PatBlt with striping.
*
* ON ENTRY:             ppdev           Pointer to physical device.
*                               x                       X coordinate of blit.
*                               y                       Y coordinate of blit.
*                               cx                      Width of blit.
*                               cy                      Height of blit.
*
* RETURNS:              void            Nothing.
\******************************************************************************/
void
StripePatBlt(
        PPDEV   ppdev,
        ULONG   x,
        ULONG   y,
        ULONG   cx,
        ULONG   cy
)
{
        ULONG cxWidth;
        ULONG TileWidth;

        // Determine number of pixels per tile.
        switch (ppdev->iBytesPerPixel)
        {
                case 1:
                        // 8-bpp.
                        TileWidth = (ULONG) ppdev->lTileSize;
                        break;

                case 2:
                        // 16-bpp.
                        TileWidth = (ULONG) (ppdev->lTileSize) / 2;
                        break;

                case 3:
                        // 24-bpp, perform the PatBlt at once since we don't have a nice
                        // number of pixels per tile.
                        REQUIRE(5);
                        LL_OP0(x, y);
                        LL_BLTEXT(cx, cy);
                        if (cx >= 0x391 && cy >= 0x24B)
                        {
                                ENDREQUIRE();
                        }
                        return;

                case 4:
                        // 32-bpp.
                        TileWidth = (ULONG) (ppdev->lTileSize) / 4;
                        break;
        }

        // Determine number of pixels left in first tile.
        cxWidth = TileWidth - (x & (TileWidth - 1));
        if ( (cxWidth >= cx) || (cy == 1) )
        {
                // PatBlt width fits in a single tile.
                REQUIRE(5);
                LL_OP0(x, y);
                LL_BLTEXT(cx, cy);
                return;
        }

        // Perform the PatBlt in the first tile.
        REQUIRE(5);
        LL_OP0(x, y);
        LL_BLTEXT(cxWidth, cy);
        cx -= cxWidth;
        x += cxWidth;

        // Keep looping until we reach the last tile of the PatBlt.
        while (cx > TileWidth)
        {
                // Perform the PatBlt on a complete tile (only x changes).
                REQUIRE(5);
                LL_OP0(x, y);
                LL_BLTEXT(TileWidth, cy);
                cx -= TileWidth;
                x += TileWidth;
        }

        // Perform the PatBlt in the last tile (only x changes).
        REQUIRE(5);
        LL_OP0(x, y);
        LL_BLTEXT(cx, cy);

} // StripePatBlt();
#endif // SWAT6
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\copybits.c ===
/******************************Module*Header*******************************\
* Module Name: COPYBITS.c
*
* Author: Noel VanHook
* Date: May. 31, 1995
* Purpose: Handle calls to DrvCopyBits
*
* Copyright (c) 1997 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/COPYBITS.C  $
*
*    Rev 1.50   Mar 04 1998 15:22:54   frido
* Added new shadow macros.
*
*    Rev 1.49   Feb 25 1998 16:43:48   frido
* Fixed a 16-bpp color translation problem for NT 5.0.
*
*    Rev 1.48   Feb 24 1998 13:19:10   frido
* Removed a few warning messages for NT 5.0.
*
*    Rev 1.47   Dec 10 1997 13:29:54   frido
* Merged from 1.62 branch.
*
*    Rev 1.46.1.0   Nov 10 1997 14:58:46   frido
* PDR#10893: With monochrome color translations in 8-bpp (palette) NT
* decides that a 2-color translation table with values 0 and 1 is a TRIVIAL
* translation table. But this breaks our assumption that the background is
* always black (0) and the foreground if white (FF). Lucky for us NT sets
* an extra bit in this case: the translation table is both TRIVIAL and has a
* TABLE.
*
*    Rev 1.46   Nov 04 1997 17:36:58   frido
* Fixed 8-bpp path when no color translation is required.
*
*    Rev 1.45   Nov 04 1997 09:41:10   frido
* Added COLOR_TRANSLATE switches around hardware color translation code.
* Removed unaccessed local variables.
*
*    Rev 1.44   Nov 03 1997 15:09:24   frido
* Added REQUIRE and WRITE_STRING macros.
*
*    Rev 1.43   15 Oct 1997 12:02:26   noelv
* Added host to screen color translation
*
*    Rev 1.42   08 Aug 1997 17:23:34   FRIDO
*
* Updatded SWAT7 code for monochrome hardware bug.
*
*    Rev 1.41   25 Jun 1997 16:01:36   noelv
* Check for NULL translation table before using it.
*
*    Rev 1.40   12 Jun 1997 14:46:12   noelv
* Frido's optimized workaround for MONO HOSTDATA bug (SWAT7)
* SWAT:
* SWAT:    Rev 1.3   06 Jun 1997 10:42:34   frido
* SWAT: Changed 896 pixel width into 888.
* SWAT:
* SWAT:    Rev 1.2   05 Jun 1997 14:48:14   frido
* SWAT: Added SWAT7 code (monochrome bitblt cut-off).
*
*    Rev 1.39   08 Apr 1997 12:14:16   einkauf
*
* add SYNC_W_3D to coordinate MCD/2D HW access
*
*    Rev 1.38   21 Mar 1997 10:54:16   noelv
*
* Combined 'do_flag' and 'sw_test_flag' together into 'pointer_switch'
*
*    Rev 1.37   19 Feb 1997 13:14:50   noelv
* Moved default xlate table to xlate.c
*
*    Rev 1.36   06 Feb 1997 10:37:38   noelv
*
* Put device to device stuff in it's own file.
*
*    Rev 1.35   28 Jan 1997 11:13:42   noelv
*
* Removed extra dword requirements from 5465 driver.
*
*    Rev 1.34   23 Jan 1997 17:26:36   bennyn
* Modified to support 5465 DD
*
*    Rev 1.33   23 Jan 1997 11:26:10   noelv
*
* Modified the '62 workaround to only happen on the '62
*
*    Rev 1.32   17 Jan 1997 10:10:30   noelv
* Workaround (punt) for HOSTDATA lockup on '62
*
*    Rev 1.31   18 Dec 1996 11:35:30   noelv
* Official workaround for mono hostdata bug.
*
*    Rev 1.30   17 Dec 1996 17:05:48   SueS
* Added test for writing to log file based on cursor at (0,0).  Added more
* information to the log file.
*
*    Rev 1.29   11 Dec 1996 14:18:54   noelv
*
* Punt 24bpp mono host to screen with rop=66 (hw bug?)
*
*    Rev 1.28   26 Nov 1996 10:47:34   SueS
* Changed WriteLogFile parameters for buffering.
*
*    Rev 1.27   13 Nov 1996 17:21:38   SueS
* Changed WriteFile calls to WriteLogFile.  Ifdef'ed out YUVBlt code
* if USE_ASM is turned off.
*
*    Rev 1.26   04 Oct 1996 16:52:00   bennyn
*
* Added DirectDraw YUV support
*
*    Rev 1.25   06 Sep 1996 09:14:46   noelv
*
* Cleaned up NULL driver code.
*
*    Rev 1.24   20 Aug 1996 11:03:20   noelv
* Bugfix release from Frido 8-19-96
*
*    Rev 1.3   18 Aug 1996 20:39:08   frido
* Changed DrvCopyBits' detection of memory bitmaps. This fixes some GPF's.
*
*    Rev 1.2   17 Aug 1996 13:18:14   frido
* New release from Bellevue.
*
*    Rev 1.1   15 Aug 1996 11:44:08   frido
* Added precompiled header.
*
*    Rev 1.0   14 Aug 1996 17:16:16   frido
* Initial revision.
*
*    Rev 1.22   28 May 1996 15:11:18   noelv
* Updated data logging.
*
*    Rev 1.21   24 Apr 1996 20:41:46   noelv
* Fixed syntax error in C code (not used when using inline assembler)
*
*    Rev 1.20   16 Apr 1996 22:48:42   noelv
* accelerated color xlate for device to device.
*
*    Rev 1.22   15 Apr 1996 17:26:46   frido
* Added color translation in DeviceToDevice.
*
*    Rev 1.21   12 Apr 1996 11:27:00   frido
* Fixed a type in DeviceToHost24.
*
*    Rev 1.20   08 Apr 1996 16:45:08   frido
* Added call to PuntBitBlt.
* Added check for translation in ScreenToHost.
* Added SolidBrush cache.
*
*    Rev 1.19   04 Apr 1996 09:57:10   frido
* Added test for bitmap format in ScreenToHost.
*
*    Rev 1.18   30 Mar 1996 22:12:16   frido
* Refined checking for invalid translation flags.
*
*    Rev 1.17   29 Mar 1996 14:53:52   frido
* Fixed problem with grayed icons.
*
*    Rev 1.16   27 Mar 1996 16:56:14   frido
* Added return values to Do... routines.
* Added check for undocumented translation flags.
* Added check for translation tables.
* Removed OP0 field in BLTDEF.
*
*    Rev 1.15   25 Mar 1996 12:03:58   frido
* Changed #ifdef frido into #if frido.
*
*    Rev 1.14   25 Mar 1996 11:53:30   frido
* Removed assembly for DoDeviceToDevice.
*
*    Rev 1.13   25 Mar 1996 11:52:38   frido
* Bellevue 102B03.
*
*    Rev 1.9   20 Mar 1996 17:16:08   BENNYN
* Fixed the BPR910 & BPR920 Phostone problems
*
*    Rev 1.8   20 Mar 1996 14:17:42   bennyn
*
*
*    Rev 1.7   19 Mar 1996 11:37:32   noelv
*
* Added data logging.
*
*    Rev 1.6   14 Mar 1996 09:38:46   andys
*
* Added if def on DoDeviceToDevice
*
*    Rev 1.5   07 Mar 1996 18:20:58   bennyn
* Removed read/modify/write on CONTROL reg
*
*    Rev 1.4   06 Mar 1996 12:51:30   noelv
* Frido ver 19b
*
*    Rev 1.9   06 Mar 1996 14:59:06   frido
* Added 'striping' wide bitmaps in 16-bpp and higher.
*
*    Rev 1.8   04 Mar 1996 20:22:50   frido
* Cached grCONTROL register.
*
*    Rev 1.7   01 Mar 1996 17:48:12   frido
* Added in-line assembly.
*
*    Rev 1.6   29 Feb 1996 20:23:46   frido
* Added 8-bpp source translation in 24- and 32-bpp HostToScreen.
*
*    Rev 1.5   28 Feb 1996 22:35:20   frido
* Added 8-bpp source translation in 16-bpp HostToScreen.
*
*    Rev 1.4   27 Feb 1996 16:38:06   frido
* Added device bitmap store/restore.
*
*    Rev 1.3   26 Feb 1996 23:37:08   frido
* Added comments.
* Rewritten ScreenToHost and HostToScreen routines.
* Removed several other bugs.
*
\**************************************************************************/

#include "precomp.h"
#include "SWAT.h"


#define COPYBITS_DBG_LEVEL 1

#if LOG_CALLS
    void LogCopyBits(
        int       acc,
        SURFOBJ*  psoSrc,
        SURFOBJ*  psoDest,
        CLIPOBJ*  pco,
        XLATEOBJ* pxlo);
#else
    #define LogCopyBits(acc, psoSrc, psoDest, pco, pxlo)
#endif

//
// Top level BLT functions.
//

#if (defined(i386) && USE_ASM)
BOOL YUVBlt(SURFOBJ*  psoTrg, SURFOBJ* psoSrc,  CLIPOBJ* pco,
            XLATEOBJ* pxlo,   RECTL*   prclTrg, POINTL*  pptlSrc);
#endif

BOOL CopyDeviceBitmap(SURFOBJ* psoTrg, SURFOBJ* psoSrc, CLIPOBJ* pco,
              XLATEOBJ* pxlo, RECTL* prclTrg, POINTL* pptlSrc,
              ULONG ulDRAWBLTDEF, COPYFN* pfn);
BOOL DoDeviceToDevice(SURFOBJ* psoTrg, SURFOBJ* psoSrc, XLATEOBJ* pxlo,
              RECTL* prclTrg, POINTL* pptlSrc, ULONG ulDRAWBLTDEF);
BOOL PuntBitBlt(SURFOBJ* psoDest, SURFOBJ* psoSrc, SURFOBJ* psoMask,
        CLIPOBJ* pco, XLATEOBJ* pxlo, RECTL* prclDest, POINTL* pptlSrc,
        POINTL* pptlMask, BRUSHOBJ* pbo, POINTL* pptlBrush, ROP4 rop4);

BOOL DoDeviceToDeviceWithXlate(SURFOBJ* psoTrg, SURFOBJ* psoSrc, ULONG* pulXlate,
              RECTL* prclTrg, POINTL* pptlSrc, ULONG ulDRAWBLTDEF);


#if SOLID_CACHE
    VOID CacheSolid(PDEV* ppdev);
#endif


/******************************************************************************\
*                                                                                                                                                          *
*  DrvCopyBits                                                                                             *
*                                                                                                                  *
\******************************************************************************/
BOOL DrvCopyBits(
    SURFOBJ*  psoTrg,
    SURFOBJ*  psoSrc,
    CLIPOBJ*  pco,
    XLATEOBJ* pxlo,
    RECTL*    prclTrg,
    POINTL*   pptlSrc)
{
    BOOL  fSrc, fDest;
    PDEV* ppdev;

    #if NULL_COPYBITS
    {
        if (pointer_switch)   return(TRUE);
    }
    #endif

    DISPDBG((COPYBITS_DBG_LEVEL, "DrvCopyBits\n"));

    // Determine if the source and target are the screen or a device bitmap.  I
    // have seen several cases where memory bitmaps are created with the dhpdev
    // set to the screen, so we must check if the surface handles to the screen
    // match.
    fDest = (psoTrg->dhpdev != 0);
    if (fDest)
    {
                // The destination must be either the screen or a device bitmap.
                if ((psoTrg->hsurf != ((PDEV*)(psoTrg->dhpdev))->hsurfEng) &&
                        (psoTrg->iType != STYPE_DEVBITMAP))
                {
                        fDest = FALSE;  // The destination is a memory bitmap.
                }
    }

    fSrc = (psoSrc->dhpdev != 0);
    if (fSrc)
    {
        // The source must be either the screen or a device bitmap.
        if ((psoSrc->hsurf != ((PDEV*)(psoSrc->dhpdev))->hsurfEng) &&
            (psoSrc->iType != STYPE_DEVBITMAP))
        {
            fSrc = FALSE;       // The source is a memory bitmap.
        }
    }

    ppdev = (PDEV*) (fSrc ? psoSrc->dhpdev : (fDest ? psoTrg->dhpdev : NULL));

    SYNC_W_3D(ppdev);

#if (defined(i386) && USE_ASM)
    if (ppdev->dwLgDevID < CL_GD5465)
    {
       if (YUVBlt(psoTrg, psoSrc, pco, pxlo, prclTrg, pptlSrc))
          return TRUE;
    };
#endif

    // If the destination is a DIB device bitmap, try copying it into
    // off-screen memory.
    if ( fDest &&                                       // Is destination valid?
         (psoTrg->iType == STYPE_DEVBITMAP) &&          // Is it a device bitmap?
                 ((DSURF*) psoTrg->dhsurf)->pso )       // Has it a surface?
    {
        if ( !bCreateScreenFromDib(ppdev, (DSURF*) psoTrg->dhsurf) )
        {
                psoTrg = ((DSURF*) psoTrg->dhsurf)->pso;
                fDest  = FALSE; // Destination is memory.
        }
    }

    // If the source is a DIB device bitmap, try copying it into off-screen
    // memory.
    if ( fSrc &&                                        // Is source valid?
         (psoSrc->iType == STYPE_DEVBITMAP) &&          // Is it a device bitmap?
                 ((DSURF*) psoSrc->dhsurf)->pso )       // Has it a surface?
    {
        if ( !bCreateScreenFromDib(ppdev, (DSURF*) psoSrc->dhsurf) )
        {
            psoSrc = ((DSURF*) psoSrc->dhsurf)->pso;
            fSrc   = FALSE;     // Source is memory.
        }
    }

    if (fDest)
    {
        // The target is the screen.
        if (fSrc)
        {
             // The source is the screen.
             if (CopyDeviceBitmap(psoTrg, psoSrc, pco, pxlo, prclTrg, pptlSrc,
                                 0x000000CC, DoDeviceToDevice))
             {
                 LogCopyBits(0, psoSrc,  psoTrg, pco, pxlo);
                 return(TRUE);
             }
        }
        else if ( (psoSrc->iBitmapFormat <= BMF_8BPP) ||
                  (psoSrc->iBitmapFormat == psoTrg->iBitmapFormat) )
        {
            // Ths source is main memory. We only support 1-bpp, 4-bpp, 8-bpp,
            // or the device-bpp formats.
            if (CopyDeviceBitmap(psoTrg, psoSrc, pco, pxlo, prclTrg, pptlSrc,
                                 0x000000CC, ppdev->pfnHostToScreen))
            {
                LogCopyBits(0, psoSrc,  psoTrg, pco, pxlo);
                return(TRUE);
            }
        }
    }


    else if (fSrc)
    {
        // The source is the screen.
        if (CopyDeviceBitmap(psoTrg, psoSrc, pco, pxlo, prclTrg, pptlSrc,
                             0x000000CC, ppdev->pfnScreenToHost))
        {
            LogCopyBits(0, psoSrc,  psoTrg, pco, pxlo);
            return(TRUE);
        }
    }

    // We have a memory to memory blit. Let NT handle it!
    LogCopyBits(1, psoSrc,  psoTrg, pco, pxlo);
    return PuntBitBlt(psoTrg, psoSrc, NULL, pco, pxlo, prclTrg, pptlSrc, NULL,
                      NULL, NULL, 0x0000CCCC);
}

#if LOG_CALLS
// ****************************************************************************
//
// LogCopyBlt()
// This routine is called only from DrvCopyBits()
// Dump information to a file about what is going on in CopyBit land.
//
// ****************************************************************************
void LogCopyBits(
        int       acc,
        SURFOBJ*  psoSrc,
        SURFOBJ*  psoDest,
        CLIPOBJ*  pco,
        XLATEOBJ* pxlo)
{
    PPDEV dppdev,sppdev,ppdev;
    char buf[256];
    int i;
    BYTE fg_rop, bg_rop;
    ULONG iDComplexity;

    dppdev = (PPDEV) (psoDest ? psoDest->dhpdev : 0);
    sppdev = (PPDEV) (psoSrc  ? psoSrc->dhpdev  : 0);
    ppdev = dppdev ? dppdev : sppdev;

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    i = sprintf(buf,"DCB: ");
        WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

        switch(acc)
    {
        case 0: // Accelerated
            i = sprintf(buf, "ACCL ");
            break;

        case 1: // Punted
            i = sprintf(buf, "PUNT BitBlt ");
            break;

        default:
            i = sprintf(buf, "PUNT unknown ");
            break;

    }
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    //
    // Check the SRC
    //
    if (psoSrc)
    {
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
            i = sprintf(buf, "Src Id=%p ", psoSrc->dhsurf);
            WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
            if ( ((PDSURF)psoSrc->dhsurf)->pso  )
                i = sprintf(buf,"S=DH ");
            else
                i = sprintf(buf,"S=DF ");
        }
        else if (psoSrc->hsurf == ppdev->hsurfEng)
            i = sprintf(buf,"S=S ");
        else
            i = sprintf(buf,"S=H ");
    }
    else
        i = sprintf(buf,"S=N ");
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    //
    // Check the DEST
    //
    if (psoDest)
    {
        if (psoDest->iType == STYPE_DEVBITMAP)
        {
            i = sprintf(buf, "Dst Id=%p ", psoDest->dhsurf);
            WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
            if (  ((PDSURF)psoDest->dhsurf)->pso   )
                i = sprintf(buf,"D=DH ");
            else
                i = sprintf(buf,"D=DF ");
        }
        else if (psoDest->hsurf == ppdev->hsurfEng)
            i = sprintf(buf,"D=S ");
        else
            i = sprintf(buf,"D=H ");
    }
    else
        i = sprintf(buf,"D=N ");
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);




    //
    // Check the type of clipping.
    //
    iDComplexity = (pco ? pco->iDComplexity : DC_TRIVIAL);
    i = sprintf(buf,"C=%s ",
                (iDComplexity==DC_TRIVIAL ? "T":
                (iDComplexity == DC_RECT ? "R" : "C" )));
        WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    //
    // Type of translation
    //
    if (!pxlo)
    {
        i = sprintf(buf,"T=N ");
        WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else if (pxlo->flXlate & XO_TRIVIAL)
    {
        i = sprintf(buf,"T=T ");
                WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else
    {
        i = sprintf(buf,"T=NT ");
                WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }

    i = sprintf(buf,"\r\n");
        WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}

#endif

/*****************************************************************************\
 * CopyDeviceBitmap
 *
 * This is the main entry routine for all bitblt functions. It will dispatch
 * the blit to the correct handler and performs the clipping.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pco                             Pointer to clip object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags. It will be filled
 *                                                              by the dispatch routine.
 *                              pfn                             Pointer to dispatch function.
 *
 * Returns:             TRUE if successful, FALSE if we cannot handle this blit.
\*****************************************************************************/
BOOL CopyDeviceBitmap(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        CLIPOBJ  *pco,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF,
        COPYFN   *pfn
)
{
        // Check for no clipping.
        if ( (pco == NULL) || (pco->iDComplexity == DC_TRIVIAL) )
        {
                return(pfn(psoTrg, psoSrc, pxlo, prclTrg, pptlSrc, ulDRAWBLTDEF));
        }

        // Check for single rectangle clipping.
        else if (pco->iDComplexity == DC_RECT)
        {
                RECTL  rcl;
                POINTL ptl;

                // Intersect the destination rectangle with the clipping rectangle.
                rcl.left = max(prclTrg->left, pco->rclBounds.left);
                rcl.top = max(prclTrg->top, pco->rclBounds.top);
                rcl.right = min(prclTrg->right, pco->rclBounds.right);
                rcl.bottom = min(prclTrg->bottom, pco->rclBounds.bottom);

                // Do we have a valid rectangle?
                if ( (rcl.left < rcl.right) && (rcl.top < rcl.bottom) )
                {
                        // Setup the source offset.
                        ptl.x = pptlSrc->x + (rcl.left - prclTrg->left);
                        ptl.y = pptlSrc->y + (rcl.top - prclTrg->top);
                        // Dispatch the blit.
                        return(pfn(psoTrg, psoSrc, pxlo, &rcl, &ptl, ulDRAWBLTDEF));
                }
        }

        // Complex clipping.
        else
        {
                BOOL       bMore;
                ENUMRECTS8 ce;
                RECTL*     prcl;
                ULONG      ulDirClip = CD_ANY;

                // If we have a screen to screen blit, we must specify the sorting of
                // the rectangles since we must take care not to draw on a destination
                // before that destination itself may be used as the source for a blit.
                // This only accounts for the same physical surface, not between
                // different device bitmaps.
                if ( (pfn == DoDeviceToDevice) && (psoSrc->dhsurf == psoTrg->dhsurf) )
                {
                        if (prclTrg->left > pptlSrc->x)
                        {
                                ulDirClip =
                                        (prclTrg->top > pptlSrc->y) ? CD_LEFTUP : CD_LEFTDOWN;
                        }
                        else
                        {
                                ulDirClip =
                                        (prclTrg->top > pptlSrc->y) ? CD_RIGHTUP : CD_RIGHTDOWN;
                        }
                }

                // Start the enumeration process.
                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, ulDirClip, 0);
                do
                {
                        // Get a bunch of clipping rectangles.
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *) &ce);

                        // Loop through all clipping rectangles.
                        for (prcl = ce.arcl; ce.c--; prcl++)
                        {
                                RECTL  rcl;
                                POINTL ptl;

                                // Intersect the destination rectangle with the clipping
                                // rectangle.
                                rcl.left = max(prclTrg->left, prcl->left);
                                rcl.top = max(prclTrg->top, prcl->top);
                                rcl.right = min(prclTrg->right, prcl->right);
                                rcl.bottom = min(prclTrg->bottom, prcl->bottom);

                                if ( (rcl.left < rcl.right) && (rcl.top < rcl.bottom) )
                                {
                                        // Setup the source offset.
                                        ptl.x = pptlSrc->x + (rcl.left - prclTrg->left);
                                        ptl.y = pptlSrc->y + (rcl.top - prclTrg->top);
                                        // Dispatch the blit.
                                        if (!pfn(psoTrg, psoSrc, pxlo, &rcl, &ptl, ulDRAWBLTDEF))
                                        {
                                                return(FALSE);
                                        }
                                }
                        }
                }
                while (bMore);
        }

        // Always return TRUE.
        return(TRUE);
}




/*****************************************************************************\
 *                                                                                                                                                       *
 *                                                                      8 - B P P                                                                *
 *                                                                                                                                                       *
\*****************************************************************************/

/*****************************************************************************\
 * DoHost8ToDevice
 *
 * This routine performs a HostToScreen or HostToDevice blit. The host data
 * can be either monochrome, 4-bpp, or 8-bpp. Color translation is supported.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoHost8ToDevice(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlDest, ptlSrc;
        SIZEL  sizl;
        PPDEV  ppdev;
        PBYTE  pBits;
        LONG   lDelta, i, n, lLeadIn, lExtra;
        ULONG  *pulXlate;
        FLONG  flXlate;

        // Calculate the source offset.
        ptlSrc.x = pptlSrc->x;
        ptlSrc.y = pptlSrc->y;

        // Determine the destination type and calculate the destination offset.
        if (psoTrg->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF) psoTrg->dhsurf;

                ptlDest.x = prclTrg->left + pdsurf->ptl.x;
                ptlDest.y = prclTrg->top + pdsurf->ptl.y;
                ppdev = pdsurf->ppdev;
        }
        else
        {
                ptlDest.x = prclTrg->left;
                ptlDest.y = prclTrg->top;
                ppdev = (PPDEV) psoTrg->dhpdev;
        }

        // Calculate the size of the blit.
    sizl.cx = prclTrg->right - prclTrg->left;
    sizl.cy = prclTrg->bottom - prclTrg->top;

        // Get the source variables and offset into source bits.
        lDelta = psoSrc->lDelta;
        pBits = (PBYTE)psoSrc->pvScan0 + (ptlSrc.y * lDelta);


        /*      -----------------------------------------------------------------------
                Test for monochrome source.
        */
        if (psoSrc->iBitmapFormat == BMF_1BPP)
        {
                ULONG  bgColor, fgColor;
#if SWAT7
                SIZEL  sizlTotal;
#endif
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if ( (flXlate & XO_TRIVIAL) && !(flXlate & XO_TABLE) )
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Set background and foreground colors.
                if (pulXlate == NULL)
                {
                        bgColor = 0x00000000;
                        fgColor = 0xFFFFFFFF;
                }
                else
                {
                        bgColor = pulXlate[0];
                        fgColor = pulXlate[1];

                        // Expand the colors.
                        bgColor |= bgColor << 8;
                        fgColor |= fgColor << 8;
                        bgColor |= bgColor << 16;
                        fgColor |= fgColor << 16;
                }

                //
                // Special case: when we are expanding monochrome sources and we
                // already have a colored brush, we must make sure the monochrome color
                // translation can be achived by setting the saturation bit (expanding
                // 0's to 0 and 1's to 1). If the monochrome source also requires color
                // translation, we simply punt this blit back to GDI.
                //
                if (ulDRAWBLTDEF & 0x00040000)
                {
                        if ( (bgColor == 0x00000000) && (fgColor == 0xFFFFFFFF) )
                        {
                                // Enable saturation for source (OP1).
                                ulDRAWBLTDEF |= 0x00008000;
                        }
                        #if SOLID_CACHE
                        else if ( ((ulDRAWBLTDEF & 0x000F0000) == 0x00070000) &&
                                          ppdev->Bcache )
                        {
                                CacheSolid(ppdev);
                                ulDRAWBLTDEF ^= (0x00070000 ^ 0x00090000);
                                REQUIRE(4);
                                LL_BGCOLOR(bgColor, 2);
                                LL_FGCOLOR(fgColor, 2);
                        }
                        #endif
                        else
                        {
                                // Punt this call to the GDI.
                                return(FALSE);
                        }
                }
                else
                {
                        REQUIRE(4);
                        LL_BGCOLOR(bgColor, 2);
                        LL_FGCOLOR(fgColor, 2);
                }

                REQUIRE(9);
#if SWAT7
                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);

                sizlTotal = sizl;
                while (sizlTotal.cx)
                {
                        sizl.cx = min(sizlTotal.cx, 864);
                        sizl.cy = sizlTotal.cy;

                        #if 1 // SWAT: 08/08/97
                        // In 8-bpp the 5465AD has a hardware bug when 64 < width < 128.
                        if (sizl.cx > 64 && sizl.cx < 128)
                        {
                                sizl.cx = 64;
                        }
                        #endif
#endif
                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we must setup the source phase.
                lLeadIn = ptlSrc.x & 31;
                pBits += (ptlSrc.x >> 3) & ~3;
                n = (sizl.cx + lLeadIn + 31) >> 5;

#if !SWAT7
                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);
#endif

                // Start the blit.
// added REQUIRE above
//              REQUIRE(7);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // Copy all the bits to the screen, 32-bits at a time. We don't have to
                // worry about crossing any boundary since NT is always DWORD aligned.
                while (sizl.cy--)
                {
                        WRITE_STRING(pBits, n);
                        pBits += lDelta;
                }
#if SWAT7
                sizlTotal.cx -= sizl.cx;
                ptlSrc.x += sizl.cx;
                ptlDest.x += sizl.cx;

                // Reload pBits.
                pBits = (PBYTE) psoSrc->pvScan0 + (ptlSrc.y * lDelta);
                }
#endif

                // Disable the swizzle bit in the grCONTROL register.
                ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
        }

        /*      -----------------------------------------------------------------------
                Test for 4-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_4BPP)
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Calculate the source parameters. We are going to BYTE adjust the
                // source, so we also set the source phase.
                lLeadIn = ptlSrc.x & 1;
                pBits += ptlSrc.x >> 1;
                n = sizl.cx + (ptlSrc.x & 1);

        #if ! DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
        if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx, lLeadIn, ptlDest.x) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx, lLeadIn, ptlDest.x)];
        }
        else
            lExtra = 0;
        #endif

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // If there is no translation table, use the default translation table.
                if (pulXlate == NULL)
                {
                        pulXlate = ulXlate;
                }

                // Now we are ready to copy all the pixels to the hardware.
                while (sizl.cy--)
                {
                        BYTE  *p = pBits;
                        BYTE  data[4];

                        // First, we convert 4 pixels at a time to create a 32-bit value to
                        // write to the hardware.
                        for (i = n; i >= 4; i -= 4)
                        {
                                data[0] = (BYTE) pulXlate[p[0] >> 4];
                                data[1] = (BYTE) pulXlate[p[0] & 0x0F];
                                data[2] = (BYTE) pulXlate[p[1] >> 4];
                                data[3] = (BYTE) pulXlate[p[1] & 0x0F];
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], *(DWORD *)data);
                                p += 2;
                        }

                        // Now, write any remaining pixels.
                        switch (i)
                        {
                                case 1:
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], pulXlate[p[0] >> 4]);
                                        break;

                                case 2:
                                        data[0] = (BYTE) pulXlate[p[0] >> 4];
                                        data[1] = (BYTE) pulXlate[p[0] & 0x0F];
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *(DWORD *)data);
                                        break;

                                case 3:
                                        data[0] = (BYTE) pulXlate[p[0] >> 4];
                                        data[1] = (BYTE) pulXlate[p[0] & 0x0F];
                                        data[2] = (BYTE) pulXlate[p[1] >> 4];
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *(DWORD *)data);
                                        break;
                        }

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
        }

        /*      -----------------------------------------------------------------------
                Source is in same color depth as screen.
        */
        else
        {
        //
        // If color translation is required, attempt to load the translation
        // table into the chip.
        //
                #if COLOR_TRANSLATE
        ULONG UseHWxlate = bCacheXlateTable(ppdev, &pulXlate, psoTrg, psoSrc,
                                            pxlo, (BYTE)(ulDRAWBLTDEF & 0xCC));
                #else
                if ( (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) )
                {
                        pulXlate = NULL;
                }
                else if (pxlo->flXlate & XO_TABLE)
                {
                        pulXlate = pxlo->pulXlate;
                }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }
                #endif

        // pulXlate == NULL if there is no color translation is required.
        // pulXlate == translation table if color translation is required.
        // UseHWxlate == FALSE if the hardware will do the xlate for us.
        // UseHWxlate == TRUE if we must do the translation in software.

                // If we have invalid translation flags, punt the blit.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
                if (flXlate & 0x10)
                {
                        return(FALSE);
                }

                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we also set the source phase.
                pBits += ptlSrc.x;
                lLeadIn = (DWORD)pBits & 3;
                pBits -= lLeadIn;
                n = (sizl.cx + lLeadIn + 3) >> 2;

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
            {
                if (MAKE_HD_INDEX(sizl.cx, lLeadIn, ptlDest.x) == 3788)
                {
                                // We have a problem with the HOSTDATA TABLE.
                                // Punt till we can figure it out.
                                return(FALSE);
                        }
                        lExtra =
                                        ExtraDwordTable[MAKE_HD_INDEX(sizl.cx, lLeadIn, ptlDest.x)];
                }
                else
                {
                        lExtra = 0;
                }
        #endif

                // Setup the Laguna registers.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);

                // Start the blit.
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);

                // Test for SW color translation.
#if COLOR_TRANSLATE
                if (UseHWxlate)
#else
                if (pulXlate == NULL)
#endif
        {    // HW color translate, or no translate required.

            if (pulXlate)
            {
                DISPDBG((COPYBITS_DBG_LEVEL, "Host8ToDevice: "
                   "Attempting HW color translation on 8bpp Host to Screen.\n"));
                LL_BLTEXT_XLATE(8, sizl.cx, sizl.cy); // HW xlate.
            }
            else
            {
                DISPDBG((COPYBITS_DBG_LEVEL, "Host8ToDevice: "
                   "No color translation required on 8bpp Host to Screen.\n"));
                        LL_BLTEXT(sizl.cx, sizl.cy); // No xlate.
            }

                        while (sizl.cy--)
                        {
                                // Copy all data in 32-bit. We don't have to worry about
                                // crossing any boundaries, since within NT everything is DWORD
                                // aligned.
                                WRITE_STRING(pBits, n);

                #if !DRIVER_5465
                                // Now, write the extra DWORDS.
                                REQUIRE(lExtra);
                                for (i = 0; i < lExtra; i++)
                                {
                                        LL32(grHOSTDATA[0], 0);
                                }
                #endif

                                // Next line.
                                pBits += lDelta;
                        }
                }
                else  // Software color translation is required.
                {
            DISPDBG((COPYBITS_DBG_LEVEL, "Host8ToDevice: "
                  "Attempting SW color translation on 8bpp Host to Screen.\n"));
            ASSERTMSG(pulXlate,
                "Host8ToDevice: No translation table for SW color translation.\n");

                LL_BLTEXT(sizl.cx, sizl.cy);

                        while (sizl.cy--)
                        {
                                BYTE *p = pBits;

                                // We copy 4 pixels to fill an entire 32-bit DWORD.
                                for (i = 0; i < n; i++)
                                {
                                        BYTE data[4];

                                        data[0] = (BYTE) pulXlate[p[0]];
                                        data[1] = (BYTE) pulXlate[p[1]];
                                        data[2] = (BYTE) pulXlate[p[2]];
                                        data[3] = (BYTE) pulXlate[p[3]];
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *(DWORD *)data);
                                        p += 4;
                                }

                #if !DRIVER_5465
                                // Now, write the extra DWORDS.
                                REQUIRE(lExtra);
                                for (i = 0; i < lExtra; i++)
                                {
                                        LL32(grHOSTDATA[0], 0);
                                }
                #endif

                                // Next line.
                                pBits += lDelta;
                        }
                }
   }
   return(TRUE);
}

/*****************************************************************************\
 * DoDeviceToHost8
 *
 * This routine performs a DeviceToHost for either monochrome or 8-bpp
 * destinations.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoDeviceToHost8(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlSrc;
        PPDEV  ppdev;
        SIZEL  sizl;
        PBYTE  pBits;
        #if !S2H_USE_ENGINE
        PBYTE  pjScreen;
        #endif
        LONG   lDelta;
        ULONG  i, n;

        // Determine the source type and calculate the offset.
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF)psoSrc->dhsurf;

                ppdev = pdsurf->ppdev;
                ptlSrc.x = pptlSrc->x + pdsurf->ptl.x;
                ptlSrc.y = pptlSrc->y + pdsurf->ptl.y;
        }
        else
        {
                ppdev = (PPDEV)psoSrc->dhpdev;
                ptlSrc.x = pptlSrc->x;
                ptlSrc.y = pptlSrc->y;
        }

        // Calculate the size of the blit.
        sizl.cx = prclTrg->right - prclTrg->left;
        sizl.cy = prclTrg->bottom - prclTrg->top;

        // Calculate the destination variables.
        lDelta = psoTrg->lDelta;
        pBits = (PBYTE)psoTrg->pvScan0 + (prclTrg->top * lDelta);

        #if S2H_USE_ENGINE
        // Setup the Laguna registers.
        REQUIRE(9);
        LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x20100000, 0);
        LL_OP0(0, 0);
        #else
        // Calculate the screen address.
        pjScreen = ppdev->pjScreen + ptlSrc.x + ptlSrc.y * ppdev->lDeltaScreen;

        // Wait for the hardware to become idle.
        while (LLDR_SZ(grSTATUS) != 0) ;
        #endif

        // Test for monochrome destination.
        if (psoTrg->iBitmapFormat == BMF_1BPP)
        {
                BYTE  data, leftMask, rightMask, fgColor;
                DWORD *pulXlate;
                LONG  leftCount, rightCount, leftSkip;
                #if S2H_USE_ENGINE
                BYTE  pixels[4];
                #endif

                // Calculate the monochrome masks.
                pBits += prclTrg->left >> 3;
                leftSkip = prclTrg->left & 7;
                leftCount = (8 - leftSkip) & 7;
                leftMask = 0xFF >> leftSkip;
                rightCount = prclTrg->right & 7;
                rightMask = 0xFF << (8 - rightCount);

                // If we only have pixels in one byte, we combine rightMask with
                // leftMask and set the routines to skip everything but the rightMask.
                if (leftCount > sizl.cx)
                {
                        rightMask &= leftMask;
                        leftMask = 0xFF;
                        n = 0;
                }
                else
                {
                        n = (sizl.cx - leftCount) >> 3;
                }

                // Lookup the foreground color in the translation table. We scan from
                // the back since in most cases it will be entry 255.
                pulXlate = pxlo->pulXlate;
                for (fgColor = 255; pulXlate[fgColor] != 1; fgColor--);

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x - leftSkip, ptlSrc.y);
                LL_BLTEXT(sizl.cx + leftSkip, sizl.cy);
                #else
                pjScreen -= leftSkip;
                #endif

                while (sizl.cy--)
                {
                        PBYTE pDest = pBits;
                        #if !S2H_USE_ENGINE
                        PBYTE pSrc = pjScreen;
                        #endif

                        // If we have a left mask specified, we get the pixels and store
                        // them with the destination.
                        if (leftMask != 0xFF)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(ULONG *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (pixels[0] == fgColor) data |= 0x80;
                                if (pixels[1] == fgColor) data |= 0x40;
                                if (pixels[2] == fgColor) data |= 0x20;
                                if (pixels[3] == fgColor) data |= 0x10;
                                *(ULONG *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (pixels[0] == fgColor) data |= 0x08;
                                if (pixels[1] == fgColor) data |= 0x04;
                                if (pixels[2] == fgColor) data |= 0x02;
                                if (pixels[3] == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                pSrc += 8;
                                #endif
                                *pDest++ = (*pDest & ~leftMask) | (data & leftMask);
                        }

                        // Translate all pixels that don't require masking.
                        for (i = 0; i < n; i++)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(ULONG *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (pixels[0] == fgColor) data |= 0x80;
                                if (pixels[1] == fgColor) data |= 0x40;
                                if (pixels[2] == fgColor) data |= 0x20;
                                if (pixels[3] == fgColor) data |= 0x10;
                                *(ULONG *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (pixels[0] == fgColor) data |= 0x08;
                                if (pixels[1] == fgColor) data |= 0x04;
                                if (pixels[2] == fgColor) data |= 0x02;
                                if (pixels[3] == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                pSrc += 8;
                                #endif
                                *pDest++ = data;
                        }

                        // If we have a right mask specified, we get the pixels and store
                        // them with the destination.
                        if (rightMask != 0x00)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(ULONG *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (pixels[0] == fgColor) data |= 0x80;
                                if (pixels[1] == fgColor) data |= 0x40;
                                if (pixels[2] == fgColor) data |= 0x20;
                                if (pixels[3] == fgColor) data |= 0x10;
                                *(ULONG *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (pixels[0] == fgColor) data |= 0x08;
                                if (pixels[1] == fgColor) data |= 0x04;
                                if (pixels[2] == fgColor) data |= 0x02;
                                if (pixels[3] == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                #endif
                                *pDest = (*pDest & ~rightMask) | (data & rightMask);
                        }

                        // Next line.
                        #if !S2H_USE_ENGINE
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }

        // We only support destination bitmaps with the same color depth and we
        // do not support any color translation.
        else if ( (psoTrg->iBitmapFormat != BMF_8BPP) ||
                          (pxlo && !(pxlo->flXlate & XO_TRIVIAL)) )
        {
                return(FALSE);
        }

        /*
                If the GetPixel routine is being called, we get here with both cx and
                cy set to 1 and the ROP to 0xCC (source copy). In this special case we
                read the pixel directly from memory. Of course, we must be sure the
                blit engine is finished working since it may still update the very
                pixel we are going to read! We could use the hardware for this, but it
                seems there is a HARDWARE BUG that doesn't seem to like the 1-pixel
                ScreenToHost very much.
        */
        #if S2H_USE_ENGINE
        else if ( (sizl.cx == 1) && (sizl.cy == 1) && (ulDRAWBLTDEF == 0x000000CC) )
        {
                // Wait for the hardware to become idle.
                while (LLDR_SZ(grSTATUS) != 0) ;

                // Get the pixel from screen.
                pBits[prclTrg->left] =
                        ppdev->pjScreen[ptlSrc.x + ptlSrc.y * ppdev->lDeltaScreen];
        }
        #endif

        else
        {
                #if S2H_USE_ENGINE
                // The hardware requires us to get QWORDS.
                BOOL fExtra = ((sizl.cx + 3) >> 2) & 1;
                #endif
                pBits += prclTrg->left;

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x, ptlSrc.y);
                LL_BLTEXT(sizl.cx, sizl.cy);
                #endif

                while (sizl.cy--)
                {
                        #if S2H_USE_ENGINE
                        DWORD *p = (DWORD *)pBits;

                        // First, we get pixels in chunks of 4 so the 32-bit HOSTDATA is
                        // happy.
                        for (i = sizl.cx; i >= 4; i -= 4)
                        {
                                *p++ = LLDR_SZ(grHOSTDATA[0]);
                        }

                        // Then, we have to do the remainig pixel(s).
                        switch (i)
                        {
                                case 1:
                                        *(BYTE *)p = (BYTE)LLDR_SZ(grHOSTDATA[0]);
                                        break;

                                case 2:
                                        *(WORD *)p = (WORD)LLDR_SZ(grHOSTDATA[0]);
                                        break;

                                case 3:
                                        i = LLDR_SZ(grHOSTDATA[0]);
                                        ((WORD *)p)[0] = (WORD)i;
                                        ((BYTE *)p)[2] = (BYTE)(i >> 16);
                                        break;
                        }

                        // Get the extra pixel required for QWORD alignment.
                        if (fExtra)
                        {
                                LLDR_SZ(grHOSTDATA[0]);
                        }
                        #else
                        // Copy all pixels from screen to memory.
                        memcpy(pBits, pjScreen, sizl.cx);

                        // Next line.
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }
        return(TRUE);
}

/*****************************************************************************\
 *                                                                                                                                                       *
 *                                                                 1 6 - B P P                                                           *
 *                                                                                                                                                       *
\*****************************************************************************/

/*****************************************************************************\
 * DoHost16ToDevice
 *
 * This routine performs a HostToScreen or HostToDevice blit. The host data
 * can be either monochrome, 4-bpp, or 16-bpp. Color translation is only
 * supported for monochrome and 4-bpp modes.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoHost16ToDevice(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlDest, ptlSrc;
        SIZEL  sizl;
        PPDEV  ppdev;
        PBYTE  pBits;
        LONG   lDelta, i, n, lLeadIn, lExtra, i1;
        ULONG  *pulXlate;
        FLONG  flXlate;

        // Calculate te source offset.
        ptlSrc.x = pptlSrc->x;
        ptlSrc.y = pptlSrc->y;

        // Determine the destination type and calculate the destination offset.
        if (psoTrg->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF) psoTrg->dhsurf;
                ptlDest.x = prclTrg->left + pdsurf->ptl.x;
                ptlDest.y = prclTrg->top + pdsurf->ptl.y;
                ppdev = pdsurf->ppdev;
        }
        else
        {
                ptlDest.x = prclTrg->left;
                ptlDest.y = prclTrg->top;
                ppdev = (PPDEV) psoTrg->dhpdev;
        }

        // Calculate the size of the blit.
    sizl.cx = prclTrg->right - prclTrg->left;
    sizl.cy = prclTrg->bottom - prclTrg->top;

        // Get the source variables and offset into source bits.
        lDelta = psoSrc->lDelta;
        pBits = (PBYTE)psoSrc->pvScan0 + (ptlSrc.y * lDelta);


        /*      -----------------------------------------------------------------------
                Test for monochrome source.
        */
        if (psoSrc->iBitmapFormat == BMF_1BPP)
        {
                ULONG  bgColor, fgColor;
#if SWAT7
                SIZEL  sizlTotal;
#endif

        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Set background and foreground colors.
                if (pulXlate == NULL)
                {
                        bgColor = 0x00000000;
                        fgColor = 0xFFFFFFFF;
                }
                else
                {
                        bgColor = pulXlate[0];
                        fgColor = pulXlate[1];

                        // Expand the colors.
                        bgColor |= bgColor << 16;
                        fgColor |= fgColor << 16;
                }

                //
                // Special case: when we are expanding monochrome sources and we
                // already have a colored brush, we must make sure the monochrome color
                // translation can be achived by setting the saturation bit (expanding
                // 0's to 0 and 1's to 1). If the monochrome source also requires color
                // translation, we simply punt this blit back to GDI.
                //
                if (ulDRAWBLTDEF & 0x00040000)
                {
                        if ( (bgColor == 0x00000000) && (fgColor == 0xFFFFFFFF) )
                        {
                                // Enable saturation for source (OP1).
                                ulDRAWBLTDEF |= 0x00008000;
                        }
                        #if SOLID_CACHE
                        else if ( ((ulDRAWBLTDEF & 0x000F0000) == 0x00070000) &&
                                          ppdev->Bcache )
                        {
                                CacheSolid(ppdev);
                                ulDRAWBLTDEF ^= (0x00070000 ^ 0x00090000);
                                REQUIRE(4);
                                LL_BGCOLOR(bgColor, 2);
                                LL_FGCOLOR(fgColor, 2);
                        }
                        #endif
                        else
                        {
                                // Punt this call to the GDI.
                                return(FALSE);
                        }
                }
                else
                {
                        REQUIRE(4);
                        LL_BGCOLOR(bgColor, 2);
                        LL_FGCOLOR(fgColor, 2);
                }

                REQUIRE(9);
#if SWAT7
                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);

                sizlTotal = sizl;
                while (sizlTotal.cx)
                {
                        sizl.cx = min(sizlTotal.cx, 864);
                        sizl.cy = sizlTotal.cy;
#endif
                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we must setup the source phase.
                lLeadIn = ptlSrc.x & 31;
                pBits += (ptlSrc.x >> 3) & ~3;
                n = (sizl.cx + lLeadIn + 31) >> 5;

#if !SWAT7
                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);
#endif

                // Start the blit.
// added REQUIRE above
//              REQUIRE(7);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // Copy all the bits to the screen, 32-bits at a time. We don't have to
                // worry about crossing any boundary since NT is always DWORD aligned.
                while (sizl.cy--)
                {
                        WRITE_STRING(pBits, n);
                        pBits += lDelta;
                }
#if SWAT7
                sizlTotal.cx -= sizl.cx;
                ptlSrc.x += sizl.cx;
                ptlDest.x += sizl.cx;

                // Reload pBits.
                pBits = (PBYTE) psoSrc->pvScan0 + (ptlSrc.y * lDelta);
                }
#endif

                // Disable the swizzle bit in the grCONTROL register.
                ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
        }

        /*      -----------------------------------------------------------------------
                Test for 4-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_4BPP)
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Calculate the source parameters. We are going to BYTE adjust the
                // source, so we also set the source phase.
                lLeadIn = (ptlSrc.x & 1) * 2;
                pBits += ptlSrc.x >> 1;
                n = sizl.cx + (ptlSrc.x & 1);

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx * 2, lLeadIn, ptlDest.x * 2) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                    lExtra = ExtraDwordTable[
                                MAKE_HD_INDEX(sizl.cx * 2, lLeadIn, ptlDest.x * 2)];
        }
        else
        {
                lExtra = 0;
                }
        #endif

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // If there is no translation table, use the default translation table.
                if (pulXlate == NULL)
                {
                        pulXlate = ulXlate;
                }

                // Now we are ready to copy all the pixels to the hardware.
                while (sizl.cy--)
                {
                        BYTE  *p = pBits;

                        // First, we convert 2 pixels at a time to create a 32-bit value
                        // to write to the hardware.
                        for (i = n; i >= 2; i -= 2)
                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], pulXlate[p[0] >> 4] |
                                                                        (pulXlate[p[0] & 0x0F] << 16));
                                p++;
                        }

                        // Now, write any remaining pixel.
                        if (i)
                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], pulXlate[p[0] >> 4]);
                        }

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
        }

        /*      -----------------------------------------------------------------------
                Test for 8-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_8BPP)
        {
        //
        // Attempt to load the translation table into the chip.
        // After this call:
        //   pulXlate == NULL if there is no color translation is required.
        //   pulXlate == translation table if color translation is required.
        //   UseHWxlate == FALSE if the hardware will do the xlate for us.
        //   UseHWxlate == TRUE if we must do the translation in software.
        //
                #if COLOR_TRANSLATE
        ULONG UseHWxlate = bCacheXlateTable(ppdev, &pulXlate, psoTrg, psoSrc,
                                                                                        pxlo, (BYTE)(ulDRAWBLTDEF&0xCC));
                #else
                if ( (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) )
                {
                        pulXlate = NULL;
                }
                else if (pxlo->flXlate & XO_TABLE)
                {
                        pulXlate = pxlo->pulXlate;
                }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }
                #endif

        //
        // NVH:  5465 Color XLATE bug!!!
        // Color translation is broken on the 5465 in 16, 24 and 32 bpp.
        //
#if COLOR_TRANSLATE
        if (UseHWxlate)
        {
            DWORD phase = ( ((DWORD)(pBits + ptlSrc.x)) & 3);
            if (XLATE_IS_BROKEN(sizl.cx, 2, phase))
                UseHWxlate = FALSE; // force SW translation.
        }

        if (UseHWxlate)
        {
            // Use Hardware color translation.

            DISPDBG((COPYBITS_DBG_LEVEL, "Host16ToDevice: "
            "Attempting HW color translation on 8bpp Host to 16bpp Screen.\n"));

                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we also set the source phase.
                pBits += ptlSrc.x;               // Start of source data on the host.
                    lLeadIn = (DWORD)pBits & 3;      // Source phase.
                pBits -= lLeadIn;                // Backup to DWORD boundry.
                n = (sizl.cx + lLeadIn + 3) >> 2;// Number of HOSTDATA per scanline.

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT_XLATE(8, sizl.cx, sizl.cy); // HW xlate.

                        while (sizl.cy--)
                        {
                                // Copy all data in 32-bit. We don't have to worry about
                                // crossing any boundaries, since within NT everything is DWORD
                                // aligned.
                                WRITE_STRING(pBits, n);
                                pBits += lDelta;
                        }
        }
        else
#endif
        {
            //
            // Use SW color translation.
            //
            DISPDBG((COPYBITS_DBG_LEVEL, "Host16ToDevice: "
            "Attempting SW color translation on 8bpp Host to 16bpp Screen.\n"));

            // To do 8bpp host to 16bpp screen we must have a translation table.
            ASSERTMSG(pulXlate,
                "Host16ToDevice: No translation table for color translation.\n");

            #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
                        {
                                if (MAKE_HD_INDEX(sizl.cx * 2, 0, ptlDest.x * 2) == 3788)
                                {
                                        // We have a problem with the HOSTDATA TABLE.
                                        // Punt till we can figure it out.
                                        return FALSE;
                                }
                                lExtra = ExtraDwordTable[
                                                MAKE_HD_INDEX(sizl.cx * 2, 0, ptlDest.x * 2)];
                        }
                        else
                        {
                                lExtra = 0;
                        }
            #endif

                // Calculate the source parameters.
                pBits += ptlSrc.x; // Start of source data on the host.

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(0, 0);
                    LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                while (sizl.cy--)
                {
                        BYTE *p = pBits;

                        // We need to copy 2 pixels at a time to create a 32-bit value
                        // for the HOSTDATA register.
                        for (i = sizl.cx; i >= 2; i -= 2)
                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], pulXlate[p[0]] |
                                                (pulXlate[p[1]] << 16));
                                p += 2;
                        }

                        // Write any remainig pixels.
                        if (i)
                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], pulXlate[p[0]]);
                        }

                #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
                #endif

                        // Next line.
                        pBits += lDelta;
                }
        }
        }

        /*      -----------------------------------------------------------------------
                Source is in same color depth as screen.
        */
        else
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // If we have a translation table, punt it.
#if _WIN32_WINNT >= 0x0500
                if ( pulXlate || (flXlate & 0x0200) )
#else
                if ( pulXlate || (flXlate & 0x0010) )
#endif
                {
                        return(FALSE);
                }

                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we also set the source phase.
                pBits += ptlSrc.x * 2;
                lLeadIn = (DWORD)pBits & 3;
                pBits -= lLeadIn;
                n = ((sizl.cx * 2) + lLeadIn + 3) >> 2;

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx * 2, lLeadIn, ptlDest.x * 2) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                    lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 2, lLeadIn, ptlDest.x * 2)];
        }
        else
            lExtra = 0;
        #endif

                // Setup the Laguna registers.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);

                // Start the blit.
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // Copy all data in 32-bit. We don't have to worry about crossing any
                // boundaries, since within NT everything is DWORD aligned.
                while (sizl.cy--)
                {
                        WRITE_STRING(pBits, n);

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[i], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
   }
   return(TRUE);
}

/*****************************************************************************\
 * DoDeviceToHost16
 *
 * This routine performs a DeviceToHost for either monochrome or 16-bpp
 * destinations.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoDeviceToHost16(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlSrc;
        PPDEV  ppdev;
        SIZEL  sizl;
        PBYTE  pBits;
        #if !S2H_USE_ENGINE
        PBYTE  pjScreen;
        #endif
        LONG   lDelta;
        ULONG  i, n;

        // Determine the source type and calculate the offset.
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF)psoSrc->dhsurf;
                ppdev = pdsurf->ppdev;
                ptlSrc.x = pptlSrc->x + pdsurf->ptl.x;
                ptlSrc.y = pptlSrc->y + pdsurf->ptl.y;
        }
        else
        {
                ppdev = (PPDEV)psoSrc->dhpdev;
                ptlSrc.x = pptlSrc->x;
                ptlSrc.y = pptlSrc->y;
        }

        // Calculate the size of the blit.
        sizl.cx = prclTrg->right - prclTrg->left;
        sizl.cy = prclTrg->bottom - prclTrg->top;

        // Calculate the destination variables.
        lDelta = psoTrg->lDelta;
        pBits = (PBYTE)psoTrg->pvScan0 + (prclTrg->top * lDelta);

        #if S2H_USE_ENGINE
        // Setup the Laguna registers.
        REQUIRE(9);
        LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x20100000, 0);
        LL_OP0(0, 0);
        #else
        // Calculate the screen address.
        pjScreen = ppdev->pjScreen + ptlSrc.x * 2 + ptlSrc.y * ppdev->lDeltaScreen;

        // Wait for the hardware to become idle.
        while (LLDR_SZ(grSTATUS) != 0) ;
        #endif

        // Test for monochrome destination.
        if (psoTrg->iBitmapFormat == BMF_1BPP)
        {
                BYTE  data, leftMask, rightMask;
                WORD  fgColor;
                DWORD *pulXlate;
                LONG  leftCount, rightCount, leftSkip;
                #if S2H_USE_ENGINE
                BYTE  pixels[4];
                #endif

                // Calculate the monochrome masks.
                pBits += prclTrg->left >> 3;
                leftSkip = prclTrg->left & 7;
                leftCount = (8 - leftSkip) & 7;
                leftMask = 0xFF >> leftSkip;
                rightCount = prclTrg->right & 7;
                rightMask = 0xFF << (8 - rightCount);

                // If we only have pixels in one byte, we combine rightMask with
                // leftMask and set the routines to skip everything but the rightMask.
                if (leftCount > sizl.cx)
                {
                        rightMask &= leftMask;
                        leftMask = 0xFF;
                        n = 0;
                }
                else
                {
                        n = (sizl.cx - leftCount) >> 3;
                }

                // Get the the foreground color from the translation table.
                pulXlate = XLATEOBJ_piVector(pxlo);
                fgColor = pulXlate ? (WORD) *pulXlate : 0;

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x - leftSkip, ptlSrc.y);
                LL_BLTEXT(sizl.cx + leftSkip, sizl.cy);
                #else
                pjScreen -= leftSkip * 2;
                #endif

                while (sizl.cy--)
                {
                        PBYTE pDest = pBits;
                        #if !S2H_USE_ENGINE
                        PWORD pSrc = (WORD *)pjScreen;
                        #endif

                        // If we have a left mask specified, we get the pixels and store
                        // them with the destination.
                        if (leftMask != 0xFF)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x80;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x40;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x20;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x10;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x08;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x04;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x02;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                pSrc += 8;
                                #endif
                                *pDest++ = (*pDest & ~leftMask) | (data & leftMask);
                        }

                        // Translate all pixels that don't require masking.
                        for (i = 0; i < n; i++)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x80;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x40;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x20;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x10;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x08;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x04;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x02;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                pSrc += 8;
                                #endif
                                *pDest++ = data;
                        }

                        // If we have a right mask specified, we get the pixels and store
                        // them with the destination.
                        if (rightMask != 0x00)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x80;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x40;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x20;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x10;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x08;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x04;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x02;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                #endif
                                *pDest = (*pDest & ~rightMask) | (data & rightMask);
                        }

                        // Next line.
                        #if !S2H_USE_ENGINE
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }

        // We only support destination bitmaps with the same color depth and we
        // do not support any color translation.
        else if ( (psoTrg->iBitmapFormat != BMF_16BPP) ||
                          (pxlo && !(pxlo->flXlate & XO_TRIVIAL)) )
        {
                return(FALSE);
        }

        /*
                If the GetPixel routine is being called, we get here with both cx and
                cy set to 1 and the ROP to 0xCC (source copy). In this special case we
                read the pixel directly from memory. Of course, we must be sure the
                blit engine is finished working since it may still update the very
                pixel we are going to read! We could use the hardware for this, but it
                seems there is a HARDWARE BUG that doesn't seem to like the 1-pixel
                ScreenToHost very much.
        */
        #if S2H_USE_ENGINE
        else if ( (sizl.cx == 1) && (sizl.cy == 1) && (ulDRAWBLTDEF == 0x000000CC) )
        {
                // Wait for the hardware to become idle.
                while (LLDR_SZ(grSTATUS) != 0) ;

                // Get the pixel from screen.
                *(WORD *)pBits[prclTrg->left] = *(WORD *)
                        &ppdev->pjScreen[ptlSrc.x * 2 + ptlSrc.y * ppdev->lDeltaScreen];
        }
        #endif

        else
        {
                #if S2H_USE_ENGINE
                // The hardware requires us to get QWORDS.
                BOOL fExtra = ((sizl.cx * 2 + 3) >> 2) & 1;
                #endif
                pBits += prclTrg->left * 2;

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x, ptlSrc.y);
                LL_BLTEXT(sizl.cx, sizl.cy);
                #endif

                while (sizl.cy--)
                {
                        #if S2H_USE_ENGINE
                        DWORD *p = (DWORD *)pBits;

                        // First, we get pixels in chunks of 2 so the 32-bit HOSTDATA is
                        // happy.
                        for (i = sizl.cx; i >= 2; i -= 2)
                        {
                                *p++ = LLDR_SZ(grHOSTDATA[0]);
                        }

                        // Then, we have to do the remainig pixel.
                        if (i)
                        {
                                *(WORD *)p = (WORD)LLDR_SZ(grHOSTDATA[0]);
                        }

                        // Get the extra pixel required for QWORD alignment.
                        if (fExtra)
                        {
                                LLDR_SZ(grHOSTDATA[0]);
                        }
                        #else
                        // Copy all pixels from screen to memory.
                        memcpy(pBits, pjScreen, sizl.cx * 2);

                        // Next line.
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }
        return(TRUE);
}

/*****************************************************************************\
 *                                                                                                                                                       *
 *                                                                 2 4 - B P P                                                           *
 *                                                                                                                                                       *
\*****************************************************************************/

/*****************************************************************************\
 * DoHost24ToDevice
 *
 * This routine performs a HostToScreen or HostToDevice blit. The host data
 * can be either monochrome, 4-bpp, or 24-bpp. Color translation is only
 * supported for monochrome and 4-bpp modes.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoHost24ToDevice(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlDest, ptlSrc;
        SIZEL  sizl;
        PPDEV  ppdev;
        PBYTE  pBits;
        LONG   lDelta, i, n, lLeadIn, lExtra, i1;
        ULONG  *pulXlate;
        FLONG  flXlate;

        // Calculate te source offset.
        ptlSrc.x = pptlSrc->x;
        ptlSrc.y = pptlSrc->y;

        // Determine the destination type and calculate the destination offset.
        if (psoTrg->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF) psoTrg->dhsurf;
                ptlDest.x = prclTrg->left + pdsurf->ptl.x;
                ptlDest.y = prclTrg->top + pdsurf->ptl.y;
                ppdev = pdsurf->ppdev;
        }
        else
        {
                ptlDest.x = prclTrg->left;
                ptlDest.y = prclTrg->top;
                ppdev = (PPDEV) psoTrg->dhpdev;
        }

        // Calculate the size of the blit.
    sizl.cx = prclTrg->right - prclTrg->left;
    sizl.cy = prclTrg->bottom - prclTrg->top;

        // Get the source variables and ofsfet into source bits.
        lDelta = psoSrc->lDelta;
        pBits = (PBYTE)psoSrc->pvScan0 + (ptlSrc.y * lDelta);


        /*      -----------------------------------------------------------------------
                Test for monochrome source.
        */
        if (psoSrc->iBitmapFormat == BMF_1BPP)
        {
                ULONG bgColor, fgColor;
#if SWAT7
                SIZEL sizlTotal;
#endif

        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Set background and foreground colors.
                if (pulXlate == NULL)
                {
                        bgColor = 0x00000000;
                        fgColor = 0x00FFFFFF;
                }
                else
                {
                        bgColor = pulXlate[0] & 0x00FFFFFF;
                        fgColor = pulXlate[1] & 0x00FFFFFF;
                }

                //
                // Special case: when we are expanding monochrome sources and we
                // already have a colored brush, we must make sure the monochrome color
                // translation can be achived by setting the saturation bit (expanding
                // 0's to 0 and 1's to 1). If the monochrome source also requires color
                // translation, we simply punt this blit back to GDI.
                //
                if (ulDRAWBLTDEF & 0x00040000)
                {
                        if ( (bgColor == 0x00000000) && (fgColor == 0x00FFFFFF) )
                        {
                                // Enable saturation for source (OP1).
                                ulDRAWBLTDEF |= 0x00008000;
                        }
                        #if SOLID_CACHE
                        else if ( ((ulDRAWBLTDEF & 0x000F0000) == 0x00070000) &&
                                          ppdev->Bcache )
                        {
                                CacheSolid(ppdev);
                                ulDRAWBLTDEF ^= (0x00070000 ^ 0x00090000);
                                REQUIRE(4);
                                LL_BGCOLOR(bgColor, 2);
                                LL_FGCOLOR(fgColor, 2);
                        }
                        #endif
                        else
                        {
                                // Punt this call to the GDI.
                                return(FALSE);
                        }
                }
                else
                {
                        REQUIRE(4);
                        LL_BGCOLOR(bgColor, 2);
                        LL_FGCOLOR(fgColor, 2);
                }

                REQUIRE(9);
#if SWAT7
                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);

                sizlTotal = sizl;
                while (sizlTotal.cx)
                {
                        sizl.cx = min(sizlTotal.cx, 864);
                        sizl.cy = sizlTotal.cy;
#endif
                // Calculate the source parameters. We are going to BYTE
                // adjust the source, so we must setup the source phase.
                lLeadIn = ptlSrc.x & 7;
                pBits += ptlSrc.x >> 3;
                n = (sizl.cx + lLeadIn + 7) >> 3;

#if !SWAT7
        //
        // Chip bug. Laguna locks with more than 15 dwords HOSTDATA
        //
        if (n > 120) // 15 qwords = 120 bytes
        {
            return FALSE;
        }

                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);
#endif

                // Start the blit.
// added REQUIRE above
//              REQUIRE(7);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // Copy all the bits to the screen, 32-bits at a time. We don't have to
                // worry about crossing any boundary since NT is always DWORD aligned.
                while (sizl.cy--)
                {
                        BYTE *p = pBits;
                        BYTE pixels[4];

                        // First, we draw 32-pixels at a time to keep HOSTDATA happy.
                        for (i = n; i >= 4; i -= 4)
                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], *(DWORD *)p);
                                p += 4;
                        }

                        // Draw any remainig pixls.
                        switch (i)
                        {
                                case 1:
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *p);
                                        break;

                                case 2:
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *(WORD *)p);
                                        break;

                                case 3:
                                        pixels[0] = p[0];
                                        pixels[1] = p[1];
                                        pixels[2] = p[2];
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *(DWORD *)pixels);
                                        break;
                        }

                        // Next line.
                        pBits += lDelta;
                }
#if SWAT7
                sizlTotal.cx -= sizl.cx;
                ptlSrc.x += sizl.cx;
                ptlDest.x += sizl.cx;

                #if 1 // SWAT: 08/08/97
                // Reload pBits.
                pBits = (PBYTE) psoSrc->pvScan0 + (ptlSrc.y * lDelta);
                #endif
                }
#endif

                // Disable the swizzle bit in the grCONTROL register.
                ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
        }

        /*      -----------------------------------------------------------------------
                Test for 4-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_4BPP)
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Calculate the source parameters. We are going to BYTE adjust the
                // source, so we also set the source phase.
                lLeadIn = (ptlSrc.x & 1) * 3;
                pBits += ptlSrc.x >> 1;
                n = sizl.cx + (ptlSrc.x & 1);

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx * 3, lLeadIn, ptlDest.x * 3) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 3, lLeadIn, ptlDest.x * 3)];
        }
        else
            lExtra = 0;
        #endif

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // If there is no translation table, use the default translation table.
                if (pulXlate == NULL)
                {
                        pulXlate = ulXlate;
                }

                // Now we are ready to copy all the pixels to the hardware.
                while (sizl.cy--)
                {
                        BYTE  *p = pBits;
                        ULONG pixels[4];

                        // First, we convert 4 pixels at a time to create three 32-bit
                        // values to write to the hardware.
                        for (i = n; i >= 4; i -= 4)
                        {
                                pixels[0] = pulXlate[p[0] >> 4];
                                pixels[1] = pulXlate[p[0] & 0x0F];
                                pixels[2] = pulXlate[p[1] >> 4];
                                pixels[3] = pulXlate[p[1] & 0x0F];
                                // 1000
                                REQUIRE(3);
                                LL32(grHOSTDATA[0], pixels[0] | (pixels[1] << 24));
                                // 2211
                                LL32(grHOSTDATA[1], (pixels[1] >> 8) | (pixels[2] << 16));
                                // 3332
                                LL32(grHOSTDATA[2], (pixels[2] >> 16) | (pixels[3] << 8));
                                p += 2;
                        }

                        // Now, write any remaining pixels.
                        switch (i)
                        {
                                case 1:
                                        // x000
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], pulXlate[p[0] >> 4]);
                                        break;

                                case 2:
                                        pixels[0] = pulXlate[p[0] >> 4];
                                        pixels[1] = pulXlate[p[0] & 0x0F];
                                        // 1000
                                        REQUIRE(2);
                                        LL32(grHOSTDATA[0], pixels[0] | (pixels[1] << 24));
                                        // xx11
                                        LL32(grHOSTDATA[1], pixels[1] >> 8);
                                        break;

                                case 3:
                                        pixels[0] = pulXlate[p[0] >> 4];
                                        pixels[1] = pulXlate[p[0] & 0x0F];
                                        pixels[2] = pulXlate[p[1] >> 4];
                                        // 1000
                                        REQUIRE(3);
                                        LL32(grHOSTDATA[0], pixels[0] | (pixels[1] << 24));
                                        // 2211
                                        LL32(grHOSTDATA[1], (pixels[1] >> 8) | (pixels[2] << 16));
                                        // xxx2
                                        LL32(grHOSTDATA[2], pixels[2] >> 16);
                                        break;
                        }

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
        }

        /*      -----------------------------------------------------------------------
                Test for 8-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_8BPP)
        {

        //
        // Attempt to load the translation table into the chip.
        // After this call:
        //   pulXlate == NULL if there is no color translation is required.
        //   pulXlate == translation table if color translation is required.
        //   UseHWxlate == FALSE if the hardware will do the xlate for us.
        //   UseHWxlate == TRUE if we must do the translation in software.
        //
                #if COLOR_TRANSLATE
        ULONG UseHWxlate = bCacheXlateTable(ppdev, &pulXlate, psoTrg, psoSrc,
                                                                                        pxlo, (BYTE)(ulDRAWBLTDEF&0xCC));
                #else
                if ( (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) )
                {
                        pulXlate = NULL;
                }
                else if (pxlo->flXlate & XO_TABLE)
                {
                        pulXlate = pxlo->pulXlate;
                }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }
                #endif

        // A translation table is required.
        // "Well, DUH!" you might say, but I've seen it missing before...
        if (!pulXlate)
        {
            DISPDBG((0, "\n\nHost24ToDevice: !!! WARNING !!! 8BPP source "
            "bitmap does not have a translation table.  Punting!\n\n"));
            return FALSE;
        }

#if COLOR_TRANSLATE
        //
        // NVH:  5465 Color XLATE bug!!!
        // Color translation is broken on the 5465 in 16, 24 and 32 bpp.
        //
        if (UseHWxlate)
        {
            DWORD phase = ( ((DWORD)(pBits + ptlSrc.x)) & 3);
            if (XLATE_IS_BROKEN(sizl.cx, 3, phase))
                UseHWxlate = FALSE; // force SW translation.
        }

        if (UseHWxlate)
        {
            // Use Hardware color translation.

            DISPDBG((COPYBITS_DBG_LEVEL, "Host24ToDevice: "
            "Attempting HW color translation on 8bpp Host to 24bpp Screen.\n"));

                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we also set the source phase.
                pBits += ptlSrc.x;               // Start of source data on the host.
            lLeadIn = (DWORD)pBits & 3;      // Source phase.
                pBits -= lLeadIn;                // Backup to DWORD boundry.
                n = (sizl.cx + lLeadIn + 3) >> 2;// Number of HOSTDATA per scanline.


                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(lLeadIn, 0);
                    LL_OP0(ptlDest.x, ptlDest.y);
            LL_BLTEXT_XLATE(8, sizl.cx, sizl.cy); // HW xlate.


                        while (sizl.cy--)
                        {
                                // Copy all data in 32-bit. We don't have to worry about
                                // crossing any boundaries, since within NT everything is DWORD
                                // aligned.
                                WRITE_STRING(pBits, n);
                                pBits += lDelta;
                        }

        }
        else
#endif
        {
            //
            // Use SW color translation.
            //

                // Calculate the source parameters.
                pBits += ptlSrc.x;

            #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
            {
                if (MAKE_HD_INDEX(sizl.cx * 3, 0, ptlDest.x * 3) == 3788)
                {
                    // We have a problem with the HOSTDATA TABLE.
                    // Punt till we can figure it out.
                    return FALSE;
                }
                        lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 3, 0, ptlDest.x * 3)];
            }
            else
            {
                lExtra = 0;
                        }
            #endif

                // Setup the Laguna registers.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);

                // Start the blit.
                LL_OP1_MONO(0, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                while (sizl.cy--)
                {
                        BYTE *p = pBits;

                        // We need to copy 4 pixels at a time to create three 32-bit values
                        // for the HOSTDATA register and stay in sync.
                        for (i = sizl.cx; i >= 4; i -= 4)
                        {
                                REQUIRE(3);
                                LL32(grHOSTDATA[0],
                                         pulXlate[p[0]] | (pulXlate[p[1]] << 24));
                                LL32(grHOSTDATA[1],
                                         (pulXlate[p[1]] >> 8) | (pulXlate[p[2]] << 16));
                                LL32(grHOSTDATA[2],
                                         (pulXlate[p[2]] >> 16) | (pulXlate[p[3]] << 8));
                                p += 4;
                        }

                        // Write any remainig pixels.
                        switch (i)
                        {
                                case 1:
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], pulXlate[p[0]]);
                                        break;

                                case 2:
                                        REQUIRE(2);
                                        LL32(grHOSTDATA[0],
                                                 pulXlate[p[0]] | (pulXlate[p[1]] << 24));
                                        LL32(grHOSTDATA[1], pulXlate[p[1]] >> 8);
                                        break;

                                case 3:
                                        REQUIRE(3);
                                        LL32(grHOSTDATA[0],
                                                 pulXlate[p[0]] | (pulXlate[p[1]] << 24));
                                        LL32(grHOSTDATA[1],
                                                 (pulXlate[p[1]] >> 8) | (pulXlate[p[2]] << 16));
                                        LL32(grHOSTDATA[2], pulXlate[p[2]] >> 16);
                                        break;
                        }

                #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
                #endif

                        // Next line.
                        pBits += lDelta;
            }
                }
        }

        /*      -----------------------------------------------------------------------
                Source is in same color depth as screen.
        */
        else
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // If we have a translation table, punt it.
                if ( pulXlate || (flXlate & 0x10) )
                {
                        return(FALSE);
                }

                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we also set the source phase.
                pBits += ptlSrc.x * 3;
                lLeadIn = (DWORD)pBits & 3;
                pBits -= lLeadIn;
                n = (sizl.cx * 3 + lLeadIn + 3) >> 2;

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx * 3, lLeadIn, ptlDest.x * 3) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 3, lLeadIn, ptlDest.x * 3)];
        }
        else
            lExtra = 0;
        #endif

                // Setup the Laguna registers.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);

                // Start the blit.
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // Copy all data in 32-bit. We don't have to worry about crossing any
                // boundaries, since within NT everything is DWORD aligned.
                while (sizl.cy--)
                {
                        WRITE_STRING(pBits, n);

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
   }
   return(TRUE);
}

/*****************************************************************************\
 * DoDeviceToHost24
 *
 * This routine performs a DeviceToHost for either monochrome or 24-bpp
 * destinations.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoDeviceToHost24(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlSrc;
        PPDEV  ppdev;
        SIZEL  sizl;
        PBYTE  pBits;
        #if !S2H_USE_ENGINE
        PBYTE  pjScreen;
        #endif
        LONG   lDelta;
        ULONG  i, n;

        // Determine the source type and calculate the offset.
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF)psoSrc->dhsurf;
                ppdev = pdsurf->ppdev;
                ptlSrc.x = pptlSrc->x + pdsurf->ptl.x;
                ptlSrc.y = pptlSrc->y + pdsurf->ptl.y;
        }
        else
        {
                ppdev = (PPDEV)psoSrc->dhpdev;
                ptlSrc.x = pptlSrc->x;
                ptlSrc.y = pptlSrc->y;
        }

        // Calculate the size of the blit.
        sizl.cx = prclTrg->right - prclTrg->left;
        sizl.cy = prclTrg->bottom - prclTrg->top;

        // Calculate the destination variables.
        lDelta = psoTrg->lDelta;
        pBits = (PBYTE)psoTrg->pvScan0 + (prclTrg->top * lDelta);

        #if S2H_USE_ENGINE
        // Setup the Laguna registers.
        REQUIRE(9);
        LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x20100000, 0);
        LL_OP0(0, 0);
        #else
        // Calculate the screen address.
        pjScreen = ppdev->pjScreen + ptlSrc.x * 3 + ptlSrc.y * ppdev->lDeltaScreen;

        // Wait for the hardware to become idle.
        while (LLDR_SZ(grSTATUS) != 0) ;
        #endif

        // Test for a monochrome destination.
        if (psoTrg->iBitmapFormat == BMF_1BPP)
        {
                BYTE  data, leftMask, rightMask;
                ULONG fgColor;
                DWORD *pulXlate;
                LONG  leftCount, rightCount, leftSkip;
                BYTE  pixels[12];

                // Calculate the monochrome masks.
                pBits += prclTrg->left >> 3;
                leftSkip = prclTrg->left & 7;
                leftCount = (8 - leftSkip) & 7;
                leftMask = 0xFF >> leftSkip;
                rightCount = prclTrg->right & 7;
                rightMask = 0xFF << (8 - rightCount);

                // If we only have pixels in one byte, we combine rightMask with
                // leftMask and set the routine to skip everything but the rightMask.
                if (leftCount > sizl.cx)
                {
                        rightMask &= leftMask;
                        leftMask = 0xFF;
                        n = 0;
                }
                else
                {
                        n = (sizl.cx - leftCount) >> 3;
                }

                // Get the foreground color from the translation table.
                pulXlate = XLATEOBJ_piVector(pxlo);
                fgColor = pulXlate ? *pulXlate : 0;

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x - leftSkip, ptlSrc.y);
                LL_BLTEXT(sizl.cx + leftSkip, sizl.cy);
                #else
                pjScreen -= leftSkip * 3;
                #endif

                while (sizl.cy--)
                {
                        PBYTE pDest = pBits;
                        #if !S2H_USE_ENGINE
                        DWORD *pSrc = (DWORD *)pjScreen;
                        #endif

                        // If we have a leftMask specified, we get the pixels and store
                        // them in the destination.
                        if (leftMask != 0xFF)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(DWORD *)&pixels[0] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[4] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[8] = LLDR_SZ(grHOSTDATA[0]);
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x80;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x40;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x20;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x10;
                                *(DWORD *)&pixels[0] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[4] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[8] = LLDR_SZ(grHOSTDATA[0]);
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x08;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x04;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x02;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x01;
                                #else
                                *(DWORD *)&pixels[0] = pSrc[0];
                                *(DWORD *)&pixels[4] = pSrc[1];
                                *(DWORD *)&pixels[8] = pSrc[2];
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x80;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x40;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x20;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x10;
                                *(DWORD *)&pixels[0] = pSrc[3];
                                *(DWORD *)&pixels[4] = pSrc[4];
                                *(DWORD *)&pixels[8] = pSrc[5];
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x08;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x04;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x02;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x01;
                                pSrc += 6;
                                #endif
                                *pDest++ = (*pDest & ~leftMask) | (data & leftMask);
                        }

                        // Translate all pixels that don't require masking.
                        for (i = 0; i < n; i++)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(DWORD *)&pixels[0] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[4] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[8] = LLDR_SZ(grHOSTDATA[0]);
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x80;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x40;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x20;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x10;
                                *(DWORD *)&pixels[0] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[4] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[8] = LLDR_SZ(grHOSTDATA[0]);
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x08;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x04;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x02;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x01;
                                #else
                                *(DWORD *)&pixels[0] = pSrc[0];
                                *(DWORD *)&pixels[4] = pSrc[1];
                                *(DWORD *)&pixels[8] = pSrc[2];
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x80;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x40;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x20;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x10;
                                *(DWORD *)&pixels[0] = pSrc[3];
                                *(DWORD *)&pixels[4] = pSrc[4];
                                *(DWORD *)&pixels[8] = pSrc[5];
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x08;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x04;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x02;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x01;
                                pSrc += 6;
                                #endif
                                *pDest++ = data;
                        }

                        // If we have a rightMask specified, we get the pixels and store
                        // them in the destination.
                        if (rightMask != 0x00)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(DWORD *)&pixels[0] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[4] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[8] = LLDR_SZ(grHOSTDATA[0]);
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x80;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x40;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x20;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x10;
                                *(DWORD *)&pixels[0] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[4] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[8] = LLDR_SZ(grHOSTDATA[0]);
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x08;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x04;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x02;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x01;
                                #else
                                *(DWORD *)&pixels[0] = pSrc[0];
                                *(DWORD *)&pixels[4] = pSrc[1];
                                *(DWORD *)&pixels[8] = pSrc[2];
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x80;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x40;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x20;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x10;
                                *(DWORD *)&pixels[0] = pSrc[3];
                                *(DWORD *)&pixels[4] = pSrc[4];
                                *(DWORD *)&pixels[8] = pSrc[5];
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x08;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x04;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x02;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x01;
                                #endif
                                *pDest = (*pDest & ~rightMask) | (data & rightMask);
                        }

                        // Next line.
                        #if !S2H_USE_ENGINE
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }

        // We only support destination bitmaps with the same color depth and we
        // do not support any color translation.
        else if ( (psoTrg->iBitmapFormat != BMF_24BPP) ||
                          (pxlo && !(pxlo->flXlate & XO_TRIVIAL)) )
        {
                return(FALSE);
        }

        /*
                If the GetPixel routine is being called, we get here with both cx and
                cy set to 1 and the ROP to 0xCC (source copy). In this special case we
                read the pixel directly from memory. Of course, we must be sure the
                blit engine is finished working since it may still update the very
                pixel we are going to read! We could use the hardware for this, but it
                seems there is a HARDWARE BUG that doesn't seem like the 1-pixel
                ScreenToHost very much.
        */
        #if S2H_USE_ENGINE
        else if ( (sizl.cx == 1) && (sizl.cy == 1) && (ulDRAWBLTDEF == 0x000000CC) )
        {
                DWORD data;

                // Wait for the hardware to become idle.
                while (LLDR_SZ(grSTATUS) != 0) ;

                // Get the pixel from screen.
                pBits += prclTrg->left * 3;
                data = *(DWORD *)
                        &ppdev->pjScreen[ptlSrc.x * 3 + ptlSrc.y * ppdev->lDeltaScreen];
                *(WORD *)&pBits[0] = (WORD)data;
                *(BYTE *)&pBits[2] = (BYTE)(data >> 16);
        }
        #endif

        else
        {
                #if S2H_USE_ENGINE
                // The hardware requires us to get QWORDS.
                BOOL fExtra = ((sizl.cx * 3 + 3) >> 2) & 1;
                #endif
                pBits += prclTrg->left * 3;

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x, ptlSrc.y);
                LL_BLTEXT(sizl.cx, sizl.cy);
                #endif

                while (sizl.cy--)
                {
                        #if S2H_USE_ENGINE
                        DWORD *p = (DWORD *)pBits;

                        // First, we get pixels in chunks of 4 so the 32-bit HOSTDATA is
                        // happy and we are still in phase.
                        for (i = sizl.cx; i >= 4; i -= 4)
                        {
                                *p++ = LLDR_SZ(grHOSTDATA[0]);
                                *p++ = LLDR_SZ(grHOSTDATA[0]);
                                *p++ = LLDR_SZ(grHOSTDATA[0]);
                        }

                        // Then, we have to do the remaining pixel(s).
                        switch (i)
                        {
                                case 1:
                                        i = LLDR_SZ(grHOSTDATA[0]);
                                        ((WORD *)p)[0] = (WORD)i;
                                        ((BYTE *)p)[2] = (BYTE)(i >> 16);
                                        break;

                                case 2:
                                        *p++ = LLDR_SZ(grHOSTDATA[0]);
                                        *(WORD *)p = (WORD)LLDR_SZ(grHOSTDATA[0]);
                                        break;

                                case 3:
                                        *p++ = LLDR_SZ(grHOSTDATA[0]);
                                        *p++ = LLDR_SZ(grHOSTDATA[0]);
                                        *(BYTE *)p = (BYTE)LLDR_SZ(grHOSTDATA[0]);
                                        break;
                        }

                        // Get the extra pixel required for QWORD alignment.
                        if (fExtra)
                        {
                                LLDR_SZ(grHOSTDATA[0]);
                        }
                        #else
                        // Copy all pixels from screen to memory.
                        memcpy(pBits, pjScreen, sizl.cx * 3);

                        // Next line.
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }
        return(TRUE);
}

/*****************************************************************************\
 *                                                                                                                                                       *
 *                                                                 3 2 - B P P                                                           *
 *                                                                                                                                                       *
\*****************************************************************************/

/*****************************************************************************\
 * DoHost32ToDevice
 *
 * This routine performs a HostToScreen or HostToDevice blit. The host data
 * can be either monochrome, 4-bpp, or 32-bpp. Color translation is only
 * supported for monochrome and 4-bpp modes.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoHost32ToDevice(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlDest, ptlSrc;
        SIZEL  sizl;
        PPDEV  ppdev;
        PBYTE  pBits;
        LONG   lDelta, i, n, lLeadIn, lExtra, i1;
        ULONG  *pulXlate;
        FLONG  flXlate;

        // Calculate te source offset.
        ptlSrc.x = pptlSrc->x;
        ptlSrc.y = pptlSrc->y;

        // Determine the destination type and calculate the destination offset.
        if (psoTrg->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF) psoTrg->dhsurf;
                ptlDest.x = prclTrg->left + pdsurf->ptl.x;
                ptlDest.y = prclTrg->top + pdsurf->ptl.y;
                ppdev = pdsurf->ppdev;
        }
        else
        {
                ptlDest.x = prclTrg->left;
                ptlDest.y = prclTrg->top;
                ppdev = (PPDEV) psoTrg->dhpdev;
        }

        // Calculate the size of the blit.
    sizl.cx = prclTrg->right - prclTrg->left;
    sizl.cy = prclTrg->bottom - prclTrg->top;

        // Get the source variables and ofFset into source bits.
        lDelta = psoSrc->lDelta;
        pBits = (PBYTE)psoSrc->pvScan0 + (ptlSrc.y * lDelta);

        /*      -----------------------------------------------------------------------
                Test for monochrome source.
        */
        if (psoSrc->iBitmapFormat == BMF_1BPP)
        {
                ULONG  bgColor, fgColor;
#if SWAT7
                SIZEL  sizlTotal;
#endif

        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }


                // Set background and foreground colors.
                if (pulXlate == NULL)
                {
                        bgColor = 0x00000000;
                        fgColor = 0xFFFFFFFF;
                }
                else
                {
                        bgColor = pulXlate[0];
                        fgColor = pulXlate[1];
                }

                //
                // Special case: when we are expanding monochrome sources and we
                // already have a colored brush, we must make sure the monochrome color
                // translation can be achived by setting the saturation bit (expanding
                // 0's to 0 and 1's to 1). If the monochrome source also requires color
                // translation, we simply punt this blit back to GDI.
                //
                if (ulDRAWBLTDEF & 0x00040000)
                {
                        if ( (bgColor == 0x00000000) &&
                                 ((fgColor & 0x00FFFFFF) == 0x00FFFFFF) )
                        {
                                // Enable saturation for source (OP1).
                                ulDRAWBLTDEF |= 0x00008000;
                        }
                        #if SOLID_CACHE
                        else if ( ((ulDRAWBLTDEF & 0x000F0000) == 0x00070000) &&
                                          ppdev->Bcache )
                        {
                                CacheSolid(ppdev);
                                ulDRAWBLTDEF ^= (0x00070000 ^ 0x00090000);
                REQUIRE(4);
                                LL_BGCOLOR(bgColor, 2);
                                LL_FGCOLOR(fgColor, 2);
                        }
                        #endif
                        else
                        {
                                // Punt this call to the GDI.
                                return(FALSE);
                        }
                }
                else
                {
                        REQUIRE(4);
                        LL_BGCOLOR(bgColor, 2);
                        LL_FGCOLOR(fgColor, 2);
                }

                REQUIRE(9);
#if SWAT7
                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);

                sizlTotal = sizl;
                while (sizlTotal.cx)
                {
                        sizl.cx = min(sizlTotal.cx, 864);
                        sizl.cy = sizlTotal.cy;
#endif
                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we must setup the source phase.
                lLeadIn = ptlSrc.x & 31;
                pBits += (ptlSrc.x >> 3) & ~3;
                n = (sizl.cx + lLeadIn + 31) >> 5;

#if !SWAT7
        //
        // Chip bug. Laguna locks with more than 14 dwords HOSTDATA
        //
        if (n > 28) // 14 qwords = 28 dwords
        {
            return FALSE;
        }

                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);
#endif

                // Start the blit.
// added REQUIRE above
//              REQUIRE(7);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // Copy all the bits to the screen, 32-bits at a time. We don't have to
                // worry about crossing any boundary since NT is always DWORD aligned.
                while (sizl.cy--)
                {
                        WRITE_STRING(pBits, n);
                        pBits += lDelta;
                }
#if SWAT7
                sizlTotal.cx -= sizl.cx;
                ptlSrc.x += sizl.cx;
                ptlDest.x += sizl.cx;

                // Reload pBits.
                pBits = (PBYTE) psoSrc->pvScan0 + (ptlSrc.y * lDelta);
                }
#endif

                // Disable the swizzle bit in the grCONTROL register.
                ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
        }

        /*      -----------------------------------------------------------------------
                Test for 4-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_4BPP)
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Calculate the source parameters.
                pBits += ptlSrc.x >> 1;

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx * 4, 0, ptlDest.x * 4) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 4, 0, ptlDest.x * 4)];
        }
        else
            lExtra = 0;
        #endif

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(0, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // If there is no translation table, use the default translation table.
                if (pulXlate == NULL)
                {
                        pulXlate = ulXlate;
                }

                // Now we are ready to copy all the pixels to the hardware.
                while (sizl.cy--)
                {
                        BYTE  *p = pBits;

                        // First, we must align the source to a BYTE boundary.
                        if (ptlSrc.x & 1)
                        {
                                // We convert 2 pixels at a time to create two 32-bit values
                                // to write to the hardware.
                                for (i = sizl.cx; i >= 2; i -= 2)
                                {
                                        REQUIRE(2);
                                        LL32(grHOSTDATA[0], pulXlate[p[0] & 0x0F]);
                                        LL32(grHOSTDATA[1], pulXlate[p[1] >> 4]);
                                        p++;
                                }

                                // Now, write any remaining pixel.
                                if (i)
                                {
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], pulXlate[*p & 0x0F]);
                                }
                        }
                        else
                        {
                                // We convert 2 pixels at a time to create two 32-bit values
                                // to write to the hardware.
                                for (i = sizl.cx; i >= 2; i -= 2)
                                {
                                        REQUIRE(2);
                                        LL32(grHOSTDATA[0], pulXlate[p[0] >> 4]);
                                        LL32(grHOSTDATA[1], pulXlate[p[0] & 0x0F]);
                                        p++;
                                }

                                // Now, write any remaining pixel.
                                if (i)
                                {
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], pulXlate[*p >> 4]);
                                }
                        }

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
        }

        /*      -----------------------------------------------------------------------
                Test for 8-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_8BPP)
        {

        //
        // Attempt to load the translation table into the chip.
        // After this call:
        //   pulXlate == NULL if there is no color translation is required.
        //   pulXlate == translation table if color translation is required.
        //   UseHWxlate == FALSE if the hardware will do the xlate for us.
        //   UseHWxlate == TRUE if we must do the translation in software.
        //
                #if COLOR_TRANSLATE
        ULONG UseHWxlate = bCacheXlateTable(ppdev, &pulXlate, psoTrg, psoSrc,
                                                                                        pxlo, (BYTE)(ulDRAWBLTDEF&0xCC));
                #else
                if ( (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) )
                {
                        pulXlate = NULL;
                }
                else if (pxlo->flXlate & XO_TABLE)
                {
                        pulXlate = pxlo->pulXlate;
                }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }
                #endif

        // A translation table is required.
        // "Well, DUH!" you might say, but I've seen it missing before...
        if (!pulXlate)
        {
            DISPDBG((0, "\n\nHost32ToDevice: !!! WARNING !!! 8BPP source "
            "bitmap does not have a translation table.  Punting!\n\n"));
            return FALSE;
        }

#if COLOR_TRANSLATE
        //
        // NVH:  5465 Color XLATE bug!!!
        // Color translation is broken on the 5465 in 16, 24 and 32 bpp.
        //
        if (UseHWxlate)
        {
            DWORD phase = ( ((DWORD)(pBits + ptlSrc.x)) & 3);
            if (XLATE_IS_BROKEN(sizl.cx, 4, phase))
                UseHWxlate = FALSE; // force SW translation.
        }

        if (UseHWxlate)
        {
            // Use Hardware color translation.

             DISPDBG((COPYBITS_DBG_LEVEL, "Host32ToDevice: "
            "Attempting HW color translation on 8bpp Host to 32bpp Screen.\n"));

                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we also set the source phase.
                pBits += ptlSrc.x;               // Start of source data on the host.
            lLeadIn = (DWORD)pBits & 3;      // Source phase.
                pBits -= lLeadIn;                // Backup to DWORD boundry.
                n = (sizl.cx + lLeadIn + 3) >> 2;// Number of HOSTDATA per scanline.

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(lLeadIn, 0);
                    LL_OP0(ptlDest.x, ptlDest.y);
            LL_BLTEXT_XLATE(8, sizl.cx, sizl.cy); // HW xlate.

                        while (sizl.cy--)
                        {
                                // Copy all data in 32-bit. We don't have to worry about
                                // crossing any boundaries, since within NT everything is DWORD
                                // aligned.
                                WRITE_STRING(pBits, n);
                                pBits += lDelta;
                        }

        }
        else
#endif
        {
            //
            // Use SW color translation.
            //
            DISPDBG((COPYBITS_DBG_LEVEL, "Host32ToDevice: "
            "Attempting SW color translation on 8bpp Host to 32bpp Screen.\n"));

            // To do 8bpp host to 32bpp screen we must have a translation table.
            ASSERTMSG(pulXlate,
                "Host32ToDevice: No translation table for color translation.\n");

                // Calculate the source parameters.
                pBits += ptlSrc.x;   // Start of source data on the host.

            #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
            {
                if (MAKE_HD_INDEX(sizl.cx * 4, 0, ptlDest.x * 4) == 3788)
                {
                    // We have a problem with the HOSTDATA TABLE.
                    // Punt till we can figure it out.
                    return FALSE;
                }
                        lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 4, 0, ptlDest.x * 4)];
            }
            else
            {
                lExtra = 0;
                        }
            #endif

                // Setup the Laguna registers.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);

                // Start the blit.
                LL_OP1_MONO(0, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                while (sizl.cy--)
                {
                        BYTE *p = pBits;

                        // Copy the pixels.
                        for (i = sizl.cx; i > 0; i--)
                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], pulXlate[*p]);
                                p++;
                        }

                #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
                #endif

                        // Next line.
                        pBits += lDelta;
                }
        }
        }

        /*      -----------------------------------------------------------------------
                Source is in same color depth as screen.
        */
        else
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // If we have a translation table, punt it.
                if ( pulXlate || (flXlate & 0x10) )
                {
                        return(FALSE);
                }

                // Calculate the source parameters.
                pBits += ptlSrc.x * 4;

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx * 4, 0, ptlDest.x * 4) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 4, 0, ptlDest.x * 4)];
        }
        else
            lExtra = 0;
        #endif

                // Setup the Laguna registers.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);

                // Start the blit.
                LL_OP1_MONO(0, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                while (sizl.cy--)
                {
                        WRITE_STRING(pBits, sizl.cx);

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
   }
   return(TRUE);
}

/*****************************************************************************\
 * DoDeviceToHost32
 *
 * This routine performs a DeviceToHost for either monochrome or 32-bpp
 * destinations.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoDeviceToHost32(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlSrc;
        PPDEV  ppdev;
        SIZEL  sizl;
        PBYTE  pBits;
        #if !S2H_USE_ENGINE
        PBYTE  pjScreen;
        #endif
        LONG   lDelta;
        ULONG  i, n;

        // Determine the source type and calculate the offset.
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF)psoSrc->dhsurf;
                ppdev = pdsurf->ppdev;
                ptlSrc.x = pptlSrc->x + pdsurf->ptl.x;
                ptlSrc.y = pptlSrc->y + pdsurf->ptl.y;
        }
        else
        {
                ppdev = (PPDEV)psoSrc->dhpdev;
                ptlSrc.x = pptlSrc->x;
                ptlSrc.y = pptlSrc->y;
        }

        // Calculate the size of the blit.
        sizl.cx = prclTrg->right - prclTrg->left;
        sizl.cy = prclTrg->bottom - prclTrg->top;

        // Calculate the destination variables.
        lDelta = psoTrg->lDelta;
        pBits = (PBYTE)psoTrg->pvScan0 + (prclTrg->top * lDelta);

        #if S2H_USE_ENGINE
        // Setup the Laguna registers.
        REQUIRE(9);
        LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x20100000, 0);
        LL_OP0(0, 0);
        #else
        // Calculate the screen address.
        pjScreen = ppdev->pjScreen + ptlSrc.x * 4 + ptlSrc.y * ppdev->lDeltaScreen;

        // Wait for the hardware to become idle.
        while (LLDR_SZ(grSTATUS) != 0) ;
        #endif

        // Test for a monochrome destination.
        if (psoTrg->iBitmapFormat == BMF_1BPP)
        {
                BYTE  data, leftMask, rightMask;
                ULONG fgColor;
                DWORD *pulXlate;
                LONG  leftCount, rightCount, leftSkip;

                // Calculate the monochrome masks.
                pBits += prclTrg->left >> 3;
                leftSkip = prclTrg->left & 7;
                leftCount = (8 - leftSkip) & 7;
                leftMask = 0xFF >> leftSkip;
                rightCount = prclTrg->right & 7;
                rightMask = 0xFF << (8 - rightCount);

                // If we only have pixels in one byte, we combine rightMask with
                // leftMask and set the routine to skip everything but the rightMask.
                if (leftCount > sizl.cx)
                {
                        rightMask &= leftMask;
                        leftMask = 0xFF;
                        n = 0;
                }
                else
                {
                        n = (sizl.cx - leftCount) >> 3;
                }

                // Get the foreground color from the translation table.
                pulXlate = XLATEOBJ_piVector(pxlo);
                fgColor = pulXlate ? *pulXlate : 0;

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x - leftSkip, ptlSrc.y);
                LL_BLTEXT(sizl.cx + leftSkip, sizl.cy);
                #else
                pjScreen -= leftSkip * 4;
                #endif

                while (sizl.cy--)
                {
                        PBYTE pDest = pBits;
                        #if !S2H_USE_ENGINE
                        DWORD *pSrc = (DWORD *)pjScreen;
                        #endif

                        // If we have a left mask specified, we get the pixels and store
                        // them in the destination.
                        if (leftMask != 0xFF)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x80;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x40;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x20;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x10;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x08;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x04;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x02;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                pSrc += 8;
                                #endif
                                *pDest++ = (*pDest & ~leftMask) | (data & leftMask);
                        }

                        // Translate all pixels that don't require masking.
                        for (i = 0; i < n; i++)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x80;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x40;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x20;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x10;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x08;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x04;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x02;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                pSrc += 8;
                                #endif
                                *pDest++ = data;
                        }

                        // If we have a right mask specified, we get the pixels and store
                        // them in the destination.
                        if (rightMask != 0x00)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x80;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x40;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x20;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x10;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x08;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x04;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x02;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                #endif
                                *pDest = (*pDest & ~rightMask) | (data & rightMask);
                        }

                        // Next line.
                        #if !S2H_USE_ENGINE
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }

        // We only support destination bitmaps with the same color depth and we
        // do not support any color translation.
        else if ( (psoTrg->iBitmapFormat != BMF_32BPP) ||
                          (pxlo && !(pxlo->flXlate & XO_TRIVIAL)) )
        {
                return(FALSE);
        }

        /*
                If the GetPixel routine is being called, we get here with both cx and
                cy set to 1 and the ROP to 0xCC (source copy). In this special case we
                read the pixel directly from memory. Of course, we must be sure the
                blit engine is finished working since it may still update the very
                pixel we are going to read! We could use the hardware for this, but it
                seems there is a HARDWARE BUG that doesn't seem to like the 1-pixel
                ScreenToHost very much.
        */
        #if S2H_USE_ENGINE
        else if ( (sizl.cx == 1) && (sizl.cy == 1) && (ulDRAWBLTDEF == 0x000000CC) )
        {
                // Wait for the hardware to become idle.
                while (LLDR_SZ(grSTATUS) != 0) ;

                // Get the pixel from screen.
                *(DWORD *)pBits[prclTrg->left] = *(DWORD *)
                        &ppdev->pjScreen[ptlSrc.x * 4 + ptlSrc.y * ppdev->lDeltaScreen];
        }
        #endif

        else
        {
                #if S2H_USE_ENGINE
                // The hardware requires us to get QWORDS.
                BOOL fExtra = sizl.cx & 1;
                #endif
                pBits += prclTrg->left * 4;

                #if S2H_USE_ENGINE
                // Start the bit.
                LL_OP1(ptlSrc.x, ptlSrc.y);
                LL_BLTEXT(sizl.cx, sizl.cy);
                #endif

                while (sizl.cy--)
                {
                        #if S2H_USE_ENGINE
                        DWORD *p = (DWORD *)pBits;

                        // Copy all pixels from screen to memory.
                        for (i = sizl.cx; i >= 1; i -= 1)
                        {
                                *p++ = LLDR_SZ(grHOSTDATA[0]);
                        }

                        // Get the extra pixel required for QWORD alignment.
                        if (fExtra)
                        {
                                LLDR_SZ(grHOSTDATA[0]);
                        }
                        #else
                        // Copy all pixels from screen to memory.
                        memcpy(pBits, pjScreen, sizl.cx * 4);

                        // Next line.
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }
        return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\blt65.c ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1997, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         blt65.c
*
* DESCRIPTION:
*
* REVISION HISTORY:
*
* $Log:   //uinac/log/log/laguna/ddraw/src/Blt65.c  $
*
*    Rev 1.47   Jun 21 1998 12:16:46   clang
* Fixed PDR#11507 CK with ConCurrent RAM has the same transparent
* blt problem with AC
*
*    Rev 1.46   May 01 1998 15:47:06   frido
* Fixed the checks for the programmable blitter stride.
*
*    Rev 1.45   May 01 1998 13:37:06   frido
* Copied programmable blitter stride to Windows 95 code as well.
*
*    Rev 1.44   May 01 1998 11:12:38   frido
* Added test for programmable blitter stride.
*
*    Rev 1.43   Feb 24 1998 11:36:56   frido
* The overlay data has been changed in Windows NT 5.0.
*
*    Rev 1.42   Feb 16 1998 16:23:06   frido
* Moved the PFN_UPDATEFLIPSTATUS into Windows 95 specific region.
*
*    Rev 1.41   14 Jan 1998 06:14:02   eleland
*
* added support for display list flipping: calls to UpdateFlipStatus are
* thru function pointer pfnUpdateFlipStatus
*
*    Rev 1.40   06 Jan 1998 15:01:58   xcong
* Pass lpDDHALData into some functions and macros for multi-monitor support.
*
*    Rev 1.39   06 Jan 1998 11:52:16   xcong
* change pDriverData into local lpDDHALData for multi-monitor support.
*
*    Rev 1.38   28 Oct 1997 15:33:24   RUSSL
* src colorkey blts are faster and less work for the hw if just OP2 is used
* with a rop of F0 rather than using both OP1 & OP2 with a rop of CC
* To get back the old way, set the OP2_ONLY_SRC_COLORKEY define to 0
*
*    Rev 1.37   16 Oct 1997 17:01:34   RUSSL
* In Blt65, if REMOVE_GLOBAL_VARS is nonzero, get pdevice pointer from
*   DDRAWI_DIRECTDRAW_GBL struct.  It's a 16:16 ptr so call an asm function
*   to convert it to a 32 bit linear address and then store this in
*   DDRAWI_DIRECTDRAW_GBL dwReserved1 element.
*
*    Rev 1.36   03 Oct 1997 15:45:12   RUSSL
* Initial changes for use of hw clipped blts
* All changes wrapped in #if ENABLE_CLIPPEDBLTS/#endif blocks and
* ENABLE_CLIPPEDBLTS defaults to 0 (so the code is disabled)
*
*    Rev 1.35   01 Oct 1997 12:57:20   eleland
* added check in blt65() to detect blts to host texture surfaces and
* punt those blts back to the ddraw hel
*
*    Rev 1.34   20 Aug 1997 15:36:30   RUSSL
* Added ColorKeyBlt24 function.
* With 256 byte fetch disabled, SrcColorKey blts seem to be working
* correctly at 24bpp and DstColorKey blts appear to be working correctly
* for the tddraw BLT, single DESTKEY, VMem to Primary case but running
* foxbear in 24bpp modes with only DDCKEYCAPS_DESTBLT set doesn't look
* correct.  The best I've been able to do is run the tddraw DESTKEY case
* and force ColorKeyBlt24 to go though each path and verify that they
* each work correctly.  This leads me to expect that foxbear using
* DstColorKeying wasn't debugged very thoroughly (now that's probably a big
* surprise to everyone).  We need more dest color key blt tests.
* For Win95, this was basically a wasted effort since 256 byte fetch appears
* to break 24bpp colorkey blts in some other way, which would require yet
* another workaround.
*
*    Rev 1.33   18 Aug 1997 15:00:42   bennyn
* For NT, if DDBLTFX dwSize not equal to sizeof(DDBLTFX), set dwColor to 0.
*
*    Rev 1.32   13 Aug 1997 12:20:48   bennyn
* For NT, punt if no scratch buffer and DDBLTFX dwSize is not sizeof(DDBLTFX)
*
*    Rev 1.31   29 Jul 1997 17:18:18   bennyn
* Fixed the Foxbear F8 bug
*
*    Rev 1.30   29 Jul 1997 10:51:40   bennyn
* NT only, punt if it is a host to screen BLT
*
*    Rev 1.29   24 Jul 1997 12:30:36   RUSSL
* Added check for NULL src surface ptr in Blt65 before nonlocal vidmem test
*
*    Rev 1.28   24 Jul 1997 11:17:14   RUSSL
* cover up various wickle crimes against humanity
* which means disabling interpolated stretch blts among other things
*
*    Rev 1.27   18 Jul 1997 10:21:50   RUSSL
* Added check for zero extent blts in TransparentStretch65
*
*    Rev 1.26   14 Jul 1997 13:15:14   RUSSL
* Fix for PDR 9947 - include support for all surface formats for blts
* between overlay surfaces
*
*    Rev 1.25   08 Jul 1997 11:50:48   RUSSL
* Rewrite of TransparentStretch65, similar to TransparentStretch in ddblt.c
* but can blt each scanline's full x extent without striping.
* Modified calls to do stretch blt with source colorkeying in Blt65.
*
*    Rev 1.24   07 Jul 1997 13:43:52   dzenz
* Added check of DRVSEM_DISPLAY_LIST semaphore to ascertain if
* qmRequestDirectAccess needs to be called.
*
*    Rev 1.23   20 Jun 1997 09:45:32   RUSSL
* Added FBToFBCopy to handle blts to/from a linear surface
*   (currently these can be overlay or videoport surfaces only)
* Fixed one of our seemingly inevitable NT/Win95 collisions
*
*    Rev 1.22   12 Jun 1997 17:30:46   bennyn
* For 24 & 32 BPP use StretchColor() instead of TransparentStretch()
*
*    Rev 1.21   23 May 1997 15:41:28   noelv
* Added nt method for chip revision test.
*
*    Rev 1.20   22 May 1997 16:46:38   RUSSL
* Fix for PDRs 9710 & 9706, remove xext <= 8 check on striping of src
* colorkey blts on 65AC (this is a workaround for a hw bug)
* Add check for 65AC or earlier and do striping of src colorkey blts
* on 65AD striping isn't needed so just do single blt
*
*    Rev 1.19   19 May 1997 13:08:10   noelv
* Put NT4.0 wrapper around DrvSrcMBlt call.
*
*    Rev 1.18   16 May 1997 15:32:02   RUSSL
* Added blt case to handle blts from a UYVY surface to another UYVY surface
* This fixes the VFW bugs, WinBench 97 video bugs and Encarta 97 video bugs
* PDRs 9557, 9604, 9692, 9268 & 9270
* Thanks to Peter Hou
*
*    Rev 1.17   16 Apr 1997 18:40:48   RUSSL
* Fix for PDR #9340, for color conversion and resize blts calculate surface
* offset based on frame buffer pixel format then calculate offset into surface
* based on surface pixel format.  Pass DrvStretch65 byte based coordinates
* rather than pixel based coordinates.
*
*    Rev 1.16   16 Apr 1997 10:50:54   bennyn
* Eliminated the warning due to Win95 DBG_MESSAGE call.
*
*    Rev 1.15   08 Apr 1997 11:50:46   einkauf
* WINNT_VER40 affected only:add SYNC_W_3D to coordinate MCD and 2D hw access
*
*    Rev 1.14   03 Apr 1997 15:25:34   RUSSL
* Modified DDBLT_DEPTHFILL case in Blt65 to blt based on surface colordepth
*   it was clearing 16bit zbuffers in 32bit modes with pixel blts so would
*   wipe out everything to the right of the actual zbuffer
*   Fixes at least PDRs #9152, 9150 & 8789 (maybe others as well)
*
*    Rev 1.13   02 Apr 1997 15:44:54   RUSSL
* Stripe src color key blts at 24bpp, fixes PDR #9113
* Added TransparentStretch65 but hw doesn't work so it's #if'd out
*
*    Rev 1.12   27 Mar 1997 16:12:36   RUSSL
* Tossed the whole bloody mess in the bit bucket.  Reverted to rev 1.1
* Changed name of DrvStretch to DrvStretch65
* Modified DrvStretch65 to do 65-style resize blts using stretch_cntl
*   rather than lncntl
* Added use of original src & dst rectangle (if available) to compute
*   error terms.  Walk DDA's in DrvStretch65 for clipped rect's.
* Changed Blt65 locals dwDstCoord, dwDstWidth, dwDstHeight and dwSrcCoord,
*   dwSrcWidth, dwSrcHeight to DstDDRect and SrcDDRect DDRECTL structures
* Moved sync with queue manager in front of call to updateFlipStatus since
*   updateFlipStatus might access the hardware
* Added workaround for hw bug for src colorkey blts less than one qword
*   wide that require fetching from two src qwords but writing to only
*   one dst qword.  Fixes white lines on foxbear that used to appear in
*   some modes
*
*    Rev 1.11   21 Mar 1997 18:08:38   RUSSL
* Fixups in StretchRect so Foxbear now runs correctly in a window at
* all 4 colordepths
*
*    Rev 1.10   18 Mar 1997 07:51:44   bennyn
* Resolved NT comiling error by #ifdef queue manager sync call
*
*    Rev 1.9   12 Mar 1997 14:59:50   RUSSL
* replaced a block of includes with include of precomp.h for
*   precompiled headers
*
*    Rev 1.8   07 Mar 1997 12:47:10   RUSSL
* Modified DDRAW_COMPAT usage
*
*    Rev 1.7   03 Mar 1997 10:31:40   eleland
* inserted queue manager sync call to blt65(), removed #ifdef
* USE_QUEUE_MANAGER
*
*    Rev 1.6   21 Feb 1997 15:40:38   RUSSL
* Anybody know why we were doing every 1:1 blt through the
* resize engine rather than just a normal blt ???????
*
*    Rev 1.5   06 Feb 1997 13:09:36   BENNYN
* Fixed DWORD alignment for DD resizing code
*
*    Rev 1.4   31 Jan 1997 13:44:06   BENNYN
* Added clipping support and no interpolation set for 24BPP & YUV src shrink
*
*    Rev 1.3   27 Jan 1997 17:29:14   BENNYN
* Added Win95 support
*
*    Rev 1.2   23 Jan 1997 17:10:10   bennyn
* Modified to support 5465 DD
*
*    Rev 1.1   21 Jan 1997 15:09:28   RUSSL
* Added include of ddinline.h
*
*    Rev 1.0   15 Jan 1997 10:35:20   RUSSL
* Initial revision.
*
***************************************************************************
***************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/

#include "precomp.h"

// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35
#else  // !WinNT 3.51

#ifdef WINNT_VER40     // WINNT_VER40

#define DBGLVL        1

#else  // Win95

#include "flip.h"
#include "surface.h"
#include "blt.h"
#include "palette.h"

#include "bltP.h"
#include "ddinline.h"
#include "qmgr.h"

#include "ddshared.h"
#include "overlay.h"

#endif // WINNT_VER40

/*----------------------------- DEFINES -----------------------------------*/

#define OP2_ONLY_SRC_COLORKEY   1

#ifdef WINNT_VER40
#define UPDATE_FLIP_STATUS(arg)   vUpdateFlipStatus(&ppdev->flipRecord,(arg))
#else   // Win95
#define UPDATE_FLIP_STATUS(arg)   updateFlipStatus((arg),lpDDHALData)
#endif  // WINNT_VER40

#define LOCK_HW_SEMAPHORE()    (lpDDHALData->DrvSemaphore |= DRVSEM_IN_USE)
#define UNLOCK_HW_SEMAPHORE()  (lpDDHALData->DrvSemaphore &= ~ DRVSEM_IN_USE)

// defines for STRETCH_CNTL register
#define RGB_8_FMT          0
#define RGB_555_FMT        1
#define RGB_565_FMT        2
#define RGB_24_FMT         3
#define RGB_32_FMT         4
#define YUV_422_FMT        9

#define SRC_FMT_SHIFT     12
#define DST_FMT_SHIFT      8
#define SRC_FMT_MASK      0xF000
#define DST_FMT_MASK      0x0F00

#define YSHRINK_ENABLE    0x8
#define XSHRINK_ENABLE    0x4
#define YINTERP_ENABLE    0x2
#define XINTERP_ENABLE    0x1

// bltdef defines
#define BD_TYPE_RESIZE    (1 << 9)
#define BD_TYPE_NORMAL    0

/*----------------------------- TYPEDEFS ----------------------------------*/

typedef short DDAX;
typedef struct tagAxis
{
  DDAX accum;
  DDAX maj;
  DDAX min;
} AXIS;

#if !ENABLE_CLIPPEDBLTS
typedef struct _DDRECTL
{
  REG32   loc;
  REG32   ext;
} DDRECTL;
#endif

/*------------------------- FUNCTION PROTOTYPES ---------------------------*/

#ifdef DEBUG
extern VOID SaveSurfaceToBmp ( DDRAWI_DDRAWSURFACE_LCL *pSurface );
#endif

/*-------------------------- STATIC VARIABLES -----------------------------*/

#ifndef WINNT_VER40

ASSERTFILE("blt65.c");
extern PFN_UPDATEFLIPSTATUS    pfnUpdateFlipStatus;

#endif

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/

/***************************************************************************
*
* FUNCTION:    DrvStretch65()
*
* DESCRIPTION:
*
****************************************************************************/

void DrvStretch65
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DDRECTL     SrcDDRect,
  DDRECTL     DstDDRect,
  DWORD       Stretch_Cntl,
  DDRECTL     OrigSrcDDRect,
  DDRECTL     OrigDstDDRect
)
{
  const int nBytesPixel = BYTESPERPIXEL;

  autoblt_regs  bltr;
  AXIS          axis[2];
  int           nDst[2];
  int           nSrc[2];
  int           i;
  int           ext;


#ifndef WINNT_VER40
  DBG_MESSAGE(("DrvStretch65: %4d,%4d %4dx%4d -> %4d,%4d %4dx%4d",
               SrcDDRect.loc.pt.X, SrcDDRect.loc.pt.Y,
               SrcDDRect.ext.pt.X, SrcDDRect.ext.pt.Y,
               DstDDRect.loc.pt.X, DstDDRect.loc.pt.Y,
               DstDDRect.ext.pt.X, DstDDRect.ext.pt.Y));
#endif // WINNT_VER40

  if ((0 == DstDDRect.ext.pt.X) || (0 == DstDDRect.ext.pt.Y) ||
      (0 == SrcDDRect.ext.pt.X) || (0 == SrcDDRect.ext.pt.Y))
  {
    // nothing to do, so get outta here!
    return;
  }

#ifdef WINNT_VER40
  SYNC_W_3D(ppdev);
#endif

  bltr.DRAWBLTDEF.DW = MAKELONG(ROP_OP1_copy, BD_RES * IS_VRAM |
                                              BD_OP1 * IS_VRAM |
                                              BD_TYPE_RESIZE);

  // dst coords
  bltr.OP0_opMRDRAM.DW = DstDDRect.loc.DW;

  // src coords
  bltr.OP1_opMRDRAM.DW = SrcDDRect.loc.DW;

  // blt extent
  bltr.MBLTEXTR_EX.DW = DstDDRect.ext.DW;
#if 1
  // tddraw agp Case 47 puts the goofy happy face with arms image in the middle
  // of the screen and then expects us to stretch it over the top of itself
  // if we don't handle the overlap somehow, the result is trash at the bottom
  // we blt the original src to the lower right of the dest and then stretch
  // that copy of the src to the dest
  // hack, hack, cough, cough
  bltr.BLTEXT.DW = SrcDDRect.ext.DW;        // stuff this here for overlap check
#endif

  bltr.STRETCH_CNTL.W = (WORD)Stretch_Cntl;

  bltr.SHRINKINC.W = 0x0000;

  bltr.SRCX = SrcDDRect.ext.pt.X;

  // convert back to pixels for error term computations
  DstDDRect.ext.pt.X /= (USHORT)nBytesPixel;
  OrigDstDDRect.ext.pt.X /= (USHORT)nBytesPixel;
  if ((YUV_422_FMT << SRC_FMT_SHIFT) == (SRC_FMT_MASK & Stretch_Cntl))
  {
    bltr.OP1_opMRDRAM.pt.X &= 0xFFFC;
    SrcDDRect.ext.pt.X /= 2;
    OrigSrcDDRect.ext.pt.X /= 2;
  }
  else
  {
    SrcDDRect.ext.pt.X /= (USHORT)nBytesPixel;
    OrigSrcDDRect.ext.pt.X /= (USHORT)nBytesPixel;
  }
  if (DstDDRect.ext.pt.X < SrcDDRect.ext.pt.X)
  {
    bltr.STRETCH_CNTL.W |= XSHRINK_ENABLE;
    bltr.STRETCH_CNTL.W &= ~XINTERP_ENABLE;
    bltr.SHRINKINC.pt.X = SrcDDRect.ext.pt.X / DstDDRect.ext.pt.X;
  }
  if (DstDDRect.ext.pt.Y < SrcDDRect.ext.pt.Y)
  {
    bltr.STRETCH_CNTL.W |= YSHRINK_ENABLE;
    bltr.STRETCH_CNTL.W &= ~YINTERP_ENABLE;
    bltr.SHRINKINC.pt.Y = SrcDDRect.ext.pt.Y / DstDDRect.ext.pt.Y;
  }

  // Compute DDA terms.
  nDst[0] = OrigDstDDRect.ext.pt.X;
  nDst[1] = OrigDstDDRect.ext.pt.Y;
  nSrc[0] = OrigSrcDDRect.ext.pt.X;
  nSrc[1] = OrigSrcDDRect.ext.pt.Y;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

    if (bltr.STRETCH_CNTL.W & ((i==0) ? XINTERP_ENABLE : YINTERP_ENABLE))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }

    if (bltr.STRETCH_CNTL.W & ((i==0) ? XSHRINK_ENABLE : YSHRINK_ENABLE))
    { /* Shrink Terms */
      axis[i].maj   =  (short)nDst[i];
      axis[i].min   = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj   =  kDst * nDst[i];
      axis[i].min   = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }

  bltr.MAJ_X   = axis[0].maj;
  bltr.MIN_X   = axis[0].min;
  bltr.ACCUM_X = axis[0].accum;

  bltr.MAJ_Y   = axis[1].maj;
  bltr.MIN_Y   = axis[1].min;
  bltr.ACCUM_Y = axis[1].accum;

#define DO_SW_CLIPPING
#ifdef DO_SW_CLIPPING
  // walk DDA's to get correct initial ACCUM terms
  ext = DstDDRect.loc.pt.X - OrigDstDDRect.loc.pt.X;
  while (0 < ext--)
  {
    bltr.ACCUM_X += bltr.MIN_X;
    if (0 > (short)bltr.ACCUM_X)
    {
      bltr.ACCUM_X += bltr.MAJ_X;
    }
  }
  ext = DstDDRect.loc.pt.Y - OrigDstDDRect.loc.pt.Y;
  while (0 < ext--)
  {
    bltr.ACCUM_Y += bltr.MIN_Y;
    if (0 > (short)bltr.ACCUM_Y)
    {
      bltr.ACCUM_Y += bltr.MAJ_Y;
    }
  }
#else
#pragma message("Add hw clipping")
#endif

#ifdef WINNT_VER40
  ppdev->pfnDrvStrBlt(ppdev, lpDDHALData,
#else
  pfnDrvStrBlt(
                lpDDHALData,
#endif
               &bltr);
}

/***************************************************************************
*
* FUNCTION:    TransparentStretch65()
*
* DESCRIPTION:
*
****************************************************************************/

void TransparentStretch65
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DDRECTL     SrcDDRect,
  DDRECTL     DstDDRect,
  DWORD       Stretch_Cntl,
  DWORD       ColorKey
)
{
  const int nBytesPixel = BYTESPERPIXEL;

  autoblt_regs  SrcToScratch;

  AXIS  axis[2];
  int   nDst[2];
  int   nSrc[2];
  int   i;


  // currently this only supports same src & dst formats
#ifndef WINNT_VER40
  ASSERT(((SRC_FMT_MASK & Stretch_Cntl) >> SRC_FMT_SHIFT) ==
         ((DST_FMT_MASK & Stretch_Cntl) >> DST_FMT_SHIFT));

  DBG_MESSAGE(("TransparentStretch65: %4X,%4X %4Xx%4X -> %4X,%4X %4Xx%4X",
               SrcDDRect.loc.pt.X, SrcDDRect.loc.pt.Y,
               SrcDDRect.ext.pt.X, SrcDDRect.ext.pt.Y,
               DstDDRect.loc.pt.X, DstDDRect.loc.pt.Y,
               DstDDRect.ext.pt.X, DstDDRect.ext.pt.Y));

#endif

  if ((0 == DstDDRect.ext.pt.X) || (0 == DstDDRect.ext.pt.Y) ||
      (0 == SrcDDRect.ext.pt.X) || (0 == SrcDDRect.ext.pt.Y))
  {
    // nothing to do, so get outta here!
    return;
  }

  // initialize auto blt struct for src to scratch buffer
  SrcToScratch.DRAWBLTDEF.DW  = MAKELONG(ROP_OP1_copy, BD_RES * IS_VRAM |
                                                       BD_OP1 * IS_VRAM |
                                                       BD_TYPE_RESIZE);

  // dst coords in bytes (scratch buffer)
  SrcToScratch.OP0_opMRDRAM.DW = lpDDHALData->ScratchBufferOrg;
  SrcToScratch.OP0_opMRDRAM.pt.X *= (USHORT)nBytesPixel;

  // src coords in bytes
  SrcToScratch.OP1_opMRDRAM.DW = SrcDDRect.loc.DW;
  SrcToScratch.OP1_opMRDRAM.pt.X *= (USHORT)nBytesPixel;

  // blt extent in bytes (1 scanline at a time)
  SrcToScratch.MBLTEXTR_EX.DW = MAKELONG(DstDDRect.ext.pt.X * nBytesPixel,1);

  SrcToScratch.STRETCH_CNTL.W = (WORD)Stretch_Cntl;

  SrcToScratch.SHRINKINC.W = 0x0000;

  SrcToScratch.SRCX = SrcDDRect.ext.pt.X * nBytesPixel;

  if (DstDDRect.ext.pt.X < SrcDDRect.ext.pt.X)
  {
    SrcToScratch.STRETCH_CNTL.W |= XSHRINK_ENABLE;
    SrcToScratch.STRETCH_CNTL.W &= ~XINTERP_ENABLE;
    SrcToScratch.SHRINKINC.pt.X = SrcDDRect.ext.pt.X / DstDDRect.ext.pt.X;
  }

  if (DstDDRect.ext.pt.Y < SrcDDRect.ext.pt.Y)
  {
    SrcToScratch.STRETCH_CNTL.W |= YSHRINK_ENABLE;
    SrcToScratch.STRETCH_CNTL.W &= ~YINTERP_ENABLE;
    SrcToScratch.SHRINKINC.pt.Y = SrcDDRect.ext.pt.Y / DstDDRect.ext.pt.Y;
  }

  // Compute DDA terms

  nDst[0] = DstDDRect.ext.pt.X;
  nDst[1] = DstDDRect.ext.pt.Y;
  nSrc[0] = SrcDDRect.ext.pt.X;
  nSrc[1] = SrcDDRect.ext.pt.Y;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

    if (SrcToScratch.STRETCH_CNTL.W & ((i==0) ? XINTERP_ENABLE : YINTERP_ENABLE))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }

    if (SrcToScratch.STRETCH_CNTL.W & ((i==0) ? XSHRINK_ENABLE : YSHRINK_ENABLE))
    { /* Shrink Terms */
      axis[i].maj   =  (short)nDst[i];
      axis[i].min   = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj   =  kDst * nDst[i];
      axis[i].min   = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }

  SrcToScratch.MAJ_X   = axis[0].maj;
  SrcToScratch.MIN_X   = axis[0].min;
  SrcToScratch.ACCUM_X = axis[0].accum;

  SrcToScratch.MAJ_Y   = axis[1].maj;
  SrcToScratch.MIN_Y   = axis[1].min;
  SrcToScratch.ACCUM_Y = axis[1].accum;



  // loop over scanlines in dst
  // do two blts for each, one from src to scratch buffer
  //   then one from scratch buffer to dst
  while (0 < DstDDRect.ext.pt.Y)
  {
    // blt one scanline high from src to scratch buffer
#ifdef WINNT_VER40
    ppdev->pfnDrvStrBlt(ppdev, lpDDHALData,
#else
    pfnDrvStrBlt(
                lpDDHALData,
#endif
                 &SrcToScratch);

    // walk Y DDA for src to scratch buffer blt
    SrcToScratch.ACCUM_Y += SrcToScratch.MIN_Y;
    SrcToScratch.OP1_opMRDRAM.pt.Y += SrcToScratch.SHRINKINC.pt.Y;
    if (0 > (short)SrcToScratch.ACCUM_Y)
    {
      SrcToScratch.ACCUM_Y += SrcToScratch.MAJ_Y;
      SrcToScratch.OP1_opMRDRAM.pt.Y++;
    }


    // blt from scratch buffer to dst
    // 1:1 in X, 1:1 in Y, uses colorkey
#ifdef WINNT_VER40
    ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
    pfnDrvSrcBlt(
            lpDDHALData,
#endif
#if OP2_ONLY_SRC_COLORKEY
                 MAKELONG((DD_TRANS | ROP_OP2_copy),
                          ((BD_RES+BD_OP2)*IS_VRAM)),
#else
                 MAKELONG((DD_TRANS | ROP_OP1_copy),
                          ((BD_RES+BD_OP1+BD_OP2)*IS_VRAM)),
#endif
                 DstDDRect.loc.DW,
                 lpDDHALData->ScratchBufferOrg,
                 lpDDHALData->ScratchBufferOrg,
                 ColorKey,
                 MAKELONG(DstDDRect.ext.pt.X,1));
    DstDDRect.loc.pt.Y++;
    DstDDRect.ext.pt.Y--;
  }
}

#ifndef WINNT_VER40
/***************************************************************************
*
* FUNCTION:    FBToFBCopy()
*
* DESCRIPTION:
*
****************************************************************************/

VOID
FBToFBCopy ( BYTE *dst, LONG dstPitch, BYTE *src, LONG srcPitch, REG32 ext, LONG bpp )
{
  int yext = ext.pt.Y;
  int xext = ext.pt.X * bpp;

  while (0 < yext--)
  {
    memcpy(dst,src,xext);
    dst += dstPitch;
    src += srcPitch;
  }
}
#endif

/***************************************************************************
*
* FUNCTION:    ColorKeyBlt24()
*
* DESCRIPTION:
*
****************************************************************************/

#define MIN_WIDTH     21    // empirically determined that most widths less than this don't work
#define STRIPE_WIDTH  40    // max is 128 / 3 = 42 pixels, but use 40 to account for phase

STATIC VOID ColorKeyBlt24
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       drawbltdef,
  DDRECTL     DstDDRect,
  DDRECTL     SrcDDRect,
  DDRECTL     KeyDDRect,
  DWORD       dwColorKey
)
{
  short   xStep = 1;
  short   yStep = 1;
  WORD    xExt;


  // check for overlap
  if ((abs(DstDDRect.loc.pt.X - SrcDDRect.loc.pt.X) < DstDDRect.ext.pt.X) &&
      (abs(DstDDRect.loc.pt.Y - SrcDDRect.loc.pt.Y) < DstDDRect.ext.pt.Y))
  {
    // see if we need to blt from bottom to top
    if (DstDDRect.loc.pt.Y > SrcDDRect.loc.pt.Y)
    {
      // point to bottom scanline and update bltdef
      drawbltdef |= MAKELONG(0, BD_YDIR);
      DstDDRect.loc.pt.Y += (DstDDRect.ext.pt.Y - 1);
      SrcDDRect.loc.pt.Y += (DstDDRect.ext.pt.Y - 1);
      KeyDDRect.loc.pt.Y += (DstDDRect.ext.pt.Y - 1);
      yStep = -1;
    }
    // see if we need to blt from right to left
    if (DstDDRect.loc.pt.X > SrcDDRect.loc.pt.X)
    {
      // point to right edge pixel
      DstDDRect.loc.pt.X += (DstDDRect.ext.pt.X - 1);
      SrcDDRect.loc.pt.X += (DstDDRect.ext.pt.X - 1);
      KeyDDRect.loc.pt.X += (DstDDRect.ext.pt.X - 1);
      xStep = -1;
    }
  }

  // if width is too narrow, do blt a pixel at a time
  // Also blt a pixel at a time for certain overlapping src/dst combinations
  // that won't work correctly otherwise.  While setting BD_YDIR to blt from
  // bottom to top and also bltting in SRAM width stripes from right to left
  // do work at 24bpp, they unfortunately don't work for certain overlap cases.
  // In particular BD_YDIR doesn't work when you need it (period!) and bltting
  // in SRAM width stripes from right to left doesn't work if the src and dst
  // have the same y.  Take out the two || cases and try the tddraw
  // BLT_BltFast, SRCKEY, From/To same surface test and see for yourself.
  if (   (MIN_WIDTH >= DstDDRect.ext.pt.X)
      || (0 > yStep)
      || ((0 > xStep) && (DstDDRect.loc.pt.Y == SrcDDRect.loc.pt.Y))
     )
  {
BltOnePixelAtATime:
    // loop over scanlines
    while (0 < DstDDRect.ext.pt.Y)
    {
      DWORD   dst  = DstDDRect.loc.DW;
      DWORD   src  = SrcDDRect.loc.DW;
      DWORD   key  = KeyDDRect.loc.DW;

      xExt = DstDDRect.ext.pt.X;

      // loop over pixels in scanline
      while (0 < xExt)
      {
#ifdef WINNT_VER40
        ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
        pfnDrvSrcBlt(
                lpDDHALData,
#endif
                     drawbltdef, dst, src, key, dwColorKey, MAKELONG(1,1));
        // adjust extent and ptrs (x is in low word)
        xExt--;
        dst += xStep;
        src += xStep;
        key += xStep;
      }
      // adjust extent and ptrs (y is in high word)
      DstDDRect.ext.pt.Y--;
      SrcDDRect.loc.pt.Y += yStep;
      DstDDRect.loc.pt.Y += yStep;
      KeyDDRect.loc.pt.Y += yStep;
    }
  }
  // if width is less than SRAM width, just do a single blt
  else if (STRIPE_WIDTH >= DstDDRect.ext.pt.X)
  {
    // except if there's overlap, do it the slow way
    //if ((0 > xStep) || (0 > yStep))
    if (0 > xStep)          // check for (0 > yStep) already handled above
      goto BltOnePixelAtATime;

    // just blt it
#ifdef WINNT_VER40
    ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
    pfnDrvSrcBlt(
                lpDDHALData,
#endif
                 drawbltdef,
                 DstDDRect.loc.DW,
                 SrcDDRect.loc.DW,
                 KeyDDRect.loc.DW,
                 dwColorKey,
                 DstDDRect.ext.DW);
  }
  // stripe the blt into SRAM width blts
  else
  {
    xExt = STRIPE_WIDTH;

    // blt from right to left
    if (0 > xStep)
    {
      DstDDRect.loc.pt.X++;
      SrcDDRect.loc.pt.X++;
      KeyDDRect.loc.pt.X++;

      while (1)
      {
        // adjust ptrs to start of stripe
        DstDDRect.loc.pt.X -= xExt;
        SrcDDRect.loc.pt.X -= xExt;
        KeyDDRect.loc.pt.X -= xExt;

        // blt the stripe
#ifdef WINNT_VER40
        ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
        pfnDrvSrcBlt(
                    lpDDHALData,
#endif
                     drawbltdef,
                     DstDDRect.loc.DW,
                     SrcDDRect.loc.DW,
                     KeyDDRect.loc.DW,
                     dwColorKey,
                     MAKELONG(xExt,DstDDRect.ext.pt.Y));

        // adjust remaining extent
        DstDDRect.ext.pt.X -= xExt;
        // are we done?
        if (0 == DstDDRect.ext.pt.X)
          break;

        // last stripe might not be STRIPE_WIDTH wide
        if (xExt > DstDDRect.ext.pt.X)
        {
          xExt = DstDDRect.ext.pt.X;

          // if the last stripe is too narrow,
          // finish the blt the even slower way
          if (MIN_WIDTH >= xExt)
          {
            // but first point to x pixel to start with
            SrcDDRect.loc.pt.X--;
            DstDDRect.loc.pt.X--;
            KeyDDRect.loc.pt.X--;
            goto BltOnePixelAtATime;
          }
        }
      }
    }
    // blt from left to right
    else
    {
      while (1)
      {
        // blt the stripe
#ifdef WINNT_VER40
        ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
        pfnDrvSrcBlt(
                    lpDDHALData,
#endif
                     drawbltdef,
                     DstDDRect.loc.DW,
                     SrcDDRect.loc.DW,
                     KeyDDRect.loc.DW,
                     dwColorKey,
                     MAKELONG(xExt,DstDDRect.ext.pt.Y));

        // adjust remaining extent
        DstDDRect.ext.pt.X -= xExt;
        // are we done?
        if (0 >= DstDDRect.ext.pt.X)
          break;

        // adjust ptrs to start of next stripe
        SrcDDRect.loc.pt.X += xExt;
        DstDDRect.loc.pt.X += xExt;
        KeyDDRect.loc.pt.X += xExt;

        // last stripe might not be STRIPE_WIDTH wide
        if (xExt > DstDDRect.ext.pt.X)
        {
          xExt = DstDDRect.ext.pt.X;

          // if the last stripe is too narrow,
          // finish the blt the even slower way
          if (MIN_WIDTH >= xExt)
          {
            // ptrs already set
            goto BltOnePixelAtATime;
          }
        }
      }
    }
  }
}

/***************************************************************************
*
* FUNCTION:    Blt65()
*
* DESCRIPTION:
*
****************************************************************************/

#ifdef WINNT_VER40
DWORD Blt65(PDD_BLTDATA pbd)
{
  DRIVERDATA* lpDDHALData;
  PDEV*    ppdev;
  PVGAR    pREG;
#else   // Win95
DWORD __stdcall
Blt65 ( LPDDHAL_BLTDATA pbd)
{
LPGLOBALDATA lpDDHALData = GetDDHALContext( pbd->lpDD);
#endif

  HRESULT  ddrval;
  DWORD    dwFlags;

  DDRECTL DstDDRect;
  DDRECTL SrcDDRect;

#ifdef WINNT_VER40

  PDD_SURFACE_GLOBAL  dst;
  PDD_SURFACE_GLOBAL  src;

  DISPDBG((DBGLVL, "DDraw - Blt65\n"));

  ppdev = (PDEV*) pbd->lpDD->dhpdev;
  lpDDHALData = (DRIVERDATA*) &ppdev->DriverData;  //why ?
  pREG = (PVGAR) lpDDHALData->RegsAddress;

#else   // Win95

  LPDDRAWI_DDRAWSURFACE_GBL  dst;
  LPDDRAWI_DDRAWSURFACE_GBL  src;

#if defined(REMOVE_GLOBAL_VARS) && (REMOVE_GLOBAL_VARS != 0)
  PDEV  *ppdev;

  ppdev = GetPDevice(pbd->lpDD);
#endif
#endif  // WINNT_VER40

  DD_LOG(("Blt65 Entry\r\n"));

#ifdef WINNT_VER40
  SYNC_W_3D(ppdev);

  // Punt, we don't support Host memory to Screen BLT
  if ((NULL != pbd->lpDDSrcSurface) &&
      (pbd->lpDDSrcSurface->lpGbl->xHint != 0) &&
      (pbd->lpDDSrcSurface->lpGbl->yHint != 0) &&
      (pbd->lpDDSrcSurface->dwReserved1 == 0))
  {
    pbd->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
  }
#endif

#if 1 // PC98
#ifdef WINNT_VER40
	if (   (pbd->lpDDSrcSurface != NULL)
		&& (pbd->lpDDSrcSurface->lpGbl->lPitch < ppdev->lDeltaScreen)
	)
	{
		pbd->ddRVal = DDERR_UNSUPPORTED;
		return DDHAL_DRIVER_NOTHANDLED;
	}
#else
	if (   (pbd->lpDDSrcSurface != NULL)
		&& (pbd->lpDDSrcSurface->lpGbl->lPitch < pDriverData->HALInfo.vmiData.lDisplayPitch)
	)
	{
		pbd->ddRVal = DDERR_UNSUPPORTED;
		return DDHAL_DRIVER_NOTHANDLED;
	}
#endif
#endif

  // NOTES:
  //   Everything you need is in lpBlt->bltFX .
  //   Look at lpBlt->dwFlags to determine what kind of blt you are doing,
  //   DDBLT_xxxx are the flags.
  //
  // COLORKEY NOTES:
  //   ColorKey ALWAYS comes in BLTFX. You don't have to look it up in
  //   the surface.

#ifdef WINNT_VER40      // WINNT_VER40

#else   // ----- #elseif WINNT_VER40 -----
  // if direct draw is NOT using display list, it must sync here
  // updateFlipStatus may access the hardware!
  if (!lpDDHALData->DisplayListDDraw && ((lpDDHALData->DrvSemaphore & DRVSEM_3D_BUSY) || (lpDDHALData->DrvSemaphore & DRVSEM_DISPLAY_LIST)))
  {
     qmRequestDirectAccess();
  }
#endif // WINNT_VER40

  // is a flip in progress?
#ifdef WINNT_VER40
  ddrval = vUpdateFlipStatus(&ppdev->flipRecord,pbd->lpDDDestSurface->lpGbl->fpVidMem);
#else
#if defined(DDRAW_COMPAT_10)
  ddrval = pfnUpdateFlipStatus(pbd->lpDDDestSurface->lpData->fpVidMem,lpDDHALData);
#else
  ddrval = pfnUpdateFlipStatus(pbd->lpDDDestSurface->lpGbl->fpVidMem,lpDDHALData);
#endif
#endif

  if (ddrval != DD_OK)
  {
    pbd->ddRVal = ddrval;
    DD_LOG(("Blt65 Exit - flip in progress, returning %08lX\r\n", ddrval));
    return (DDHAL_DRIVER_HANDLED);
  }

  // If async, then only work if blter isn't busy.
  // This should probably be a little more specific to each call !!!
  dwFlags = pbd->dwFlags;

#if 1
  // billy and dah boyz strike again
  // tddraw agp Case 59 asks us to blt between to nonlocal video memory
  // surfaces even though we report that we don't support offscreen
  // plain nonlocal video memory surfaces
  // why is ddraw allocating offscreen plain surfaces in agp memory?
#if DDRAW_COMPAT >= 50
  // see if the dest is in nonlocal video memory
  if (DDSCAPS_NONLOCALVIDMEM & pbd->lpDDDestSurface->ddsCaps.dwCaps)
  {
    pbd->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
  }
  // if there is a src, see if it's in nonlocal video memory
  if ((NULL != pbd->lpDDSrcSurface) &&
      (DDSCAPS_NONLOCALVIDMEM & pbd->lpDDSrcSurface->ddsCaps.dwCaps))
  {
    pbd->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
  }
#endif
#endif

#ifndef WINNT_VER40
  // if the destination surface of this blt is a texture
  if (DDSCAPS_TEXTURE & pbd->lpDDDestSurface->ddsCaps.dwCaps)
  {
    LP_SURFACE_DATA lpSurfaceData;

    lpSurfaceData = (LP_SURFACE_DATA)(pbd->lpDDDestSurface->dwReserved1);

    // if the texture is a non-agp host texture (i.e. pci memory)
    if (lpSurfaceData->dwFlags & SURF_HOST_BASED_TEXTURE)
    {
        // punt the blt to direct draw hel
        pbd->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_NOTHANDLED;
    }
  }

  // if the source surface of this blt is non-null and is a texture
  if ((NULL != pbd->lpDDSrcSurface) &&
      (DDSCAPS_TEXTURE & pbd->lpDDSrcSurface->ddsCaps.dwCaps))
  {
    LP_SURFACE_DATA lpSurfaceData;

    lpSurfaceData = (LP_SURFACE_DATA)(pbd->lpDDSrcSurface->dwReserved1);

    // if the texture is a non-agp host texture (i.e. pci memory)
    if (lpSurfaceData->dwFlags & SURF_HOST_BASED_TEXTURE)
    {
        // punt the blt to direct draw hel
        pbd->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_NOTHANDLED;
    }
  }
#endif

  // get offset, width, and height for destination
#if defined(DDRAW_COMPAT_10)
  dst  = pbd->lpDDDestSurface->lpData;
#else
  dst  = pbd->lpDDDestSurface->lpGbl;
#endif

#ifdef WINNT_VER40
  DstDDRect.loc.DW = cvlxy(ppdev->lDeltaScreen,dst->fpVidMem,BYTESPERPIXEL);
#else   // Win95
  DstDDRect.loc.DW = cvlxy(lpDDHALData,dst->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
#endif
  DstDDRect.loc.DW  += MAKELONG(pbd->rDest.left,pbd->rDest.top);
  DstDDRect.ext.pt.X = (WORD)(pbd->rDest.right  - pbd->rDest.left);
  DstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);

  // If someone is running a full-screen exclusive app it is the
  // responsibility of the app to take care of the cursor. We don't
  // call BeginAccess or EndAccess for them.
  //
  // However, if someone is running a windowed app and they have
  // attached a clipper object to the destination surface then they
  // are more like a normal windows app and we call BeginAccess and
  // EndAccess for them around a blt. That is the only circumstance
  // where we currently do cursor exclusion.
  //
  // We do intend to add calls to BeginAccess and EndAccess around
  // a rectangle lock of the primary surface. In this case, we
  // would only do cursor exclusion if a lock rect is specified.
  // This will be implemented with DirectDraw 2.0.
  //
  // I believe that you should not do automatic cursor exclusion in
  // the driver because you will penalize all blts and locks.

  // Grab the hardware - disable HW cursor updates.
  LOCK_HW_SEMAPHORE();

  // Decipher the flags.
  if (dwFlags & DDBLT_ROP)
  {
    static const WORD mix2blt[] =
    {  // all ops color vram
      BD_RES                  ,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES          | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0         ,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0         ,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES          | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES
    };  // all ops color vram

    DWORD dwROP = pbd->bltFX.dwROP;
    WORD  rop = (WORD) LOBYTE( HIWORD( dwROP ) );
    WORD  mix = rop & 0x0f;
    WORD  bdf = mix2blt[mix];

    if (bdf & BD_OP1) // SRC rops
    {
#if defined(DDRAW_COMPAT_10)
      src  = pbd->lpDDSrcSurface->lpData;
#else
      src  = pbd->lpDDSrcSurface->lpGbl;
#endif

#ifdef WINNT_VER40
      SrcDDRect.loc.DW = cvlxy(ppdev->lDeltaScreen,src->fpVidMem,BYTESPERPIXEL);
#else   // Win95
      SrcDDRect.loc.DW = cvlxy(lpDDHALData,src->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
#endif
      SrcDDRect.loc.DW  += MAKELONG(pbd->rSrc.left,pbd->rSrc.top);
      SrcDDRect.ext.pt.X = (WORD)(pbd->rSrc.right  - pbd->rSrc.left);
      SrcDDRect.ext.pt.Y = (WORD)(pbd->rSrc.bottom - pbd->rSrc.top);

      if (dwFlags & DDBLT_KEYSRCOVERRIDE) // Source Color Key
      {
        DWORD dwColor =
#ifdef WINNT_VER40
                        DupColor(ppdev,
#else
                        DupColor(
                                 lpDDHALData,
#endif
                                 pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue);

        DD_LOG(("Src Color Key Blt\r\n"));

#ifdef DEBUG
        if (FALSE)
          SaveSurfaceToBmp(pbd->lpDDSrcSurface);
#endif

        if ((SrcDDRect.ext.pt.X != DstDDRect.ext.pt.X) ||
            (SrcDDRect.ext.pt.Y != DstDDRect.ext.pt.Y))
        {
#ifdef WINNT_VER40
           // If there is no scratch buffer allocated then punt the
           // transparent stretch BLT
           if (lpDDHALData->ScratchBufferOrg == 0)
           {
              ddrval = DDERR_UNSUPPORTED;
              goto blt_exit;
           };
#endif

          if ( !(pbd->lpDDSrcSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
               (rop == 0x00CC) )
          {
            if (16 >= BITSPERPIXEL)
            {
              DWORD     StretchCntl;


              if (8 == BITSPERPIXEL)
              {
                StretchCntl = (RGB_8_FMT << SRC_FMT_SHIFT) |
                              (RGB_8_FMT << DST_FMT_SHIFT) |
                              0;
              }
              else
              {
                // this only works because the src & dst fmt's in stretch control
                // for 565, 24bpp & 32bpp are the same as the bytes/pixel
                StretchCntl = (BYTESPERPIXEL << SRC_FMT_SHIFT) |
                              (BYTESPERPIXEL << DST_FMT_SHIFT) |
                              0;
              }
#ifdef WINNT_VER40
              TransparentStretch65(ppdev, lpDDHALData,
#else
              TransparentStretch65(
                                   lpDDHALData,
#endif
                                   SrcDDRect, DstDDRect, StretchCntl, dwColor);
            }
            else
            {
#ifdef WINNT_VER40
              StretchColor(ppdev, lpDDHALData,
#else
              StretchColor(
                           lpDDHALData,
#endif
                           DstDDRect.loc.pt.X, DstDDRect.loc.pt.Y,
                           DstDDRect.ext.pt.X, DstDDRect.ext.pt.Y,
                           SrcDDRect.loc.pt.X, SrcDDRect.loc.pt.Y,
                           SrcDDRect.ext.pt.X, SrcDDRect.ext.pt.Y,
                           dwColor);
            }
            goto blt_exit;
          }
          else
          {
            DD_LOG(("Unsupported SrcColorKey Blt -> punt\r\n"));
            ddrval = DDERR_UNSUPPORTED;
            goto blt_exit;
          }
        }

        if (24 != BITSPERPIXEL)
        {
          // if it's 5465AC or earlier, do hw transparency bug workaround
#ifdef WINNT_VER40
          if (1 >= ppdev->dwLgDevRev)
#else
#if 1 //PDR#11507 CK with ConCurrent RAM has the same transparent blt problem with AC.
          if (1 >= lpDDHALData->bLgRevID)
#else
			 if ( ( 1 >= lpDDHALData->bLgRevID ) ||
				 ( (0x25 == lpDDHALData->bLgRevID) &&
					 lpDDHALData->bConCurrentRAM) )
#endif
#endif
          {
            // convert to byte extents and positions
            SrcDDRect.loc.pt.X *= (WORD)BYTESPERPIXEL;
            SrcDDRect.ext.pt.X *= (WORD)BYTESPERPIXEL;
            DstDDRect.loc.pt.X *= (WORD)BYTESPERPIXEL;
            DstDDRect.ext.pt.X *= (WORD)BYTESPERPIXEL;

            if (//(8 >= SrcDDRect.ext.pt.X) &&
                ((7 & SrcDDRect.loc.pt.X) > (7 & DstDDRect.loc.pt.X)))
            {
              WORD  x_ext;

              x_ext = 8 - (SrcDDRect.loc.pt.X & 7);
              if (x_ext < SrcDDRect.ext.pt.X)
              {
#ifdef WINNT_VER40
                ppdev->pfnDrvSrcMBlt(ppdev, lpDDHALData,
#else
                pfnDrvSrcMBlt(
                               lpDDHALData,
#endif
#if OP2_ONLY_SRC_COLORKEY
                              MAKELONG((DD_TRANS | ROP_OP2_copy),
                                       ((BD_RES+BD_OP2)*IS_VRAM)),
#else
                              MAKELONG(rop|DD_TRANS, bdf | BD_OP2),
#endif
                              DstDDRect.loc.DW,
                              SrcDDRect.loc.DW,
                              SrcDDRect.loc.DW,  // Src transparency
                              dwColor,
                              MAKELONG(x_ext,DstDDRect.ext.pt.Y));
                SrcDDRect.loc.pt.X += x_ext;
                DstDDRect.loc.pt.X += x_ext;
                SrcDDRect.ext.pt.X -= x_ext;
                DstDDRect.ext.pt.X -= x_ext;
              }
            }
#ifdef WINNT_VER40
            ppdev->pfnDrvSrcMBlt(ppdev, lpDDHALData,
#else
            pfnDrvSrcMBlt(
                            lpDDHALData,
#endif
#if OP2_ONLY_SRC_COLORKEY
                          MAKELONG((DD_TRANS | ROP_OP2_copy),
                                   ((BD_RES+BD_OP2)*IS_VRAM)),
#else
                          MAKELONG(rop|DD_TRANS, bdf | BD_OP2),
#endif
                          DstDDRect.loc.DW,
                          SrcDDRect.loc.DW,
                          SrcDDRect.loc.DW,  // Src transparency
                          dwColor,
                          DstDDRect.ext.DW);
          }
          // 5465AD and later can do it as a single blt
          else
          {
#ifdef WINNT_VER40
            ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
            pfnDrvSrcBlt(
                        lpDDHALData,
#endif
#if OP2_ONLY_SRC_COLORKEY
                         MAKELONG((DD_TRANS | ROP_OP2_copy),
                                  ((BD_RES+BD_OP2)*IS_VRAM)),
#else
                         MAKELONG(rop|DD_TRANS, bdf | BD_OP2),
#endif
                         DstDDRect.loc.DW,
                         SrcDDRect.loc.DW,
                         SrcDDRect.loc.DW,  // Src transparency
                         dwColor,
                         DstDDRect.ext.DW);
          }
        }
        else // 24bpp workaround (needed on 5465AD also)
        {
#ifdef WINNT_VER40
          ColorKeyBlt24(ppdev,lpDDHALData,
#else
          ColorKeyBlt24(
                        lpDDHALData,
#endif
#if OP2_ONLY_SRC_COLORKEY
                        MAKELONG((DD_TRANS | ROP_OP2_copy),
                                 ((BD_RES+BD_OP2)*IS_VRAM)),
#else
                        MAKELONG(rop|DD_TRANS, bdf|BD_OP2),
#endif
                        DstDDRect,
                        SrcDDRect,
                        SrcDDRect,   // src transparency
                        dwColor);
        }
#ifdef DEBUG
        if (FALSE)
          SaveSurfaceToBmp(pbd->lpDDDestSurface);
#endif

      } // (dwFlags & DDBLT_KEYSRCOVERRIDE) // Source Color Key
      else if (dwFlags & DDBLT_KEYDESTOVERRIDE) // Destination Color Key
      {
        DWORD dwColor;

        dwColor =
#ifdef WINNT_VER40
                        DupColor(ppdev,
#else
                        DupColor(
                                 lpDDHALData,
#endif
                                 pbd->bltFX.ddckDestColorkey.dwColorSpaceLowValue);

        DD_LOG(("Dst Color Key Blt\r\n"));

        // Punt if stretch or shrink requested.
        if ((SrcDDRect.ext.pt.X != DstDDRect.ext.pt.X) ||
            (SrcDDRect.ext.pt.Y != DstDDRect.ext.pt.Y))
        {
          DD_LOG(("Unsupported DstColorKey Blt -> punt\r\n"));
          ddrval = DDERR_UNSUPPORTED;
          goto blt_exit;
        }

#ifdef WINNT_VER40
        // If the dwSize not equal to the size of DDBLTFX structure
        // Punt it.
        //
        // For the WHQL TDDRAW test case 29, for some reason, the DDBLTFX
        // structure in DD_BLTDATA is invalid. The dwSize and the
        // ddckDestColorkey fields contain garbage value.
        // In order to pass the test, we force the dwColor to zero if
        // the dwSize of DDBLTFX is invalid.
        if (pbd->bltFX.dwSize != sizeof(DDBLTFX))
        {
//           ddrval = DDERR_UNSUPPORTED;
//           goto blt_exit;
            dwColor = 0;
        };
#endif

        if (24 != BITSPERPIXEL)
        {
#ifdef WINNT_VER40
          ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
          pfnDrvSrcBlt(
                        lpDDHALData,
#endif
                       MAKELONG(rop|DD_TRANS|DD_TRANSOP, bdf | BD_OP2),
                       DstDDRect.loc.DW,
                       SrcDDRect.loc.DW,
                       DstDDRect.loc.DW,  // Dst transparency
                       dwColor,     //
                       DstDDRect.ext.DW);
        }
        else
        {
#ifdef WINNT_VER40
          ColorKeyBlt24(ppdev,lpDDHALData,
#else
          ColorKeyBlt24(
                        lpDDHALData,
#endif
                        MAKELONG(rop|DD_TRANS|DD_TRANSOP, bdf|BD_OP2),
                        DstDDRect,
                        SrcDDRect,
                        DstDDRect,   // dst transparency
                        dwColor);
        }
      } // (dwFlags & DDBLT_KEYDESTOVERRIDE) // Destination Color Key
      else
      {
#if _WIN32_WINNT >= 0x0500
	#define BLAM  (DDRAWISURF_HASPIXELFORMAT)
#else
	#define BLAM  (DDRAWISURF_HASPIXELFORMAT | DDRAWISURF_HASOVERLAYDATA)
#endif
        if ((BLAM == (BLAM & pbd->lpDDDestSurface->dwFlags)) &&
            (BLAM == (BLAM & pbd->lpDDSrcSurface->dwFlags))
#if _WIN32_WINNT >= 0x0500
			&& (pbd->lpDDDestSurface->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
			&& (pbd->lpDDSrcSurface->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
#endif
		)
        {
          if (//(FOURCC_UYVY == dst->ddpfSurface.dwFourCC) &&
              //(FOURCC_UYVY == src->ddpfSurface.dwFourCC) &&
              (SrcDDRect.ext.pt.X == DstDDRect.ext.pt.X) &&
              (SrcDDRect.ext.pt.Y == DstDDRect.ext.pt.Y))
          {
#ifndef WINNT_VER40
            LP_SURFACE_DATA lpSrcSurfaceData;
            LP_SURFACE_DATA lpDstSurfaceData;
#endif
            DWORD   dstbpp,srcbpp;

            dstbpp = pbd->lpDDDestSurface->lpGbl->ddpfSurface.dwRGBBitCount / 8;
            srcbpp = pbd->lpDDSrcSurface->lpGbl->ddpfSurface.dwRGBBitCount / 8;
            if (dstbpp != srcbpp)
            {
              ddrval = DDERR_UNSUPPORTED;
              goto blt_exit;
            }

#ifndef WINNT_VER40
            // see if either the src or dst is a linear surface
            // if so do a CPU memcpy
            lpSrcSurfaceData = (LP_SURFACE_DATA)(pbd->lpDDSrcSurface->dwReserved1);
            lpDstSurfaceData = (LP_SURFACE_DATA)(pbd->lpDDDestSurface->dwReserved1);
            if ((FLG_LINEAR & lpSrcSurfaceData->dwOverlayFlags) ||
                (FLG_LINEAR & lpDstSurfaceData->dwOverlayFlags))
            {
              if (ROP_OP1_copy == rop)
              {
                // mind numbing fb to fb copy
                FBToFBCopy((BYTE *)(lpDDHALData->ScreenAddress + DstDDRect.loc.pt.Y * PITCH + DstDDRect.loc.pt.X * 2),
                           dst->lPitch,
                           (BYTE *)(lpDDHALData->ScreenAddress + SrcDDRect.loc.pt.Y * PITCH + SrcDDRect.loc.pt.X * 2),
                           src->lPitch,
                           DstDDRect.ext,
                           dstbpp);
              }
              else
              {
                // punt it
                ddrval = DDERR_UNSUPPORTED;
                goto blt_exit;
              }
            }
            else
#endif
            {
              SrcDDRect.loc.pt.X *= (WORD)BYTESPERPIXEL;
              DstDDRect.loc.pt.X *= (WORD)BYTESPERPIXEL;
              SrcDDRect.ext.pt.X *= (WORD)dstbpp;
              DstDDRect.ext.pt.X *= (WORD)dstbpp;
#ifdef WINNT_VER40
              ppdev->pfnDrvSrcMBlt(ppdev, lpDDHALData,
#else
              pfnDrvSrcMBlt(
                        lpDDHALData,
#endif
                            MAKELONG(rop, bdf),
                            DstDDRect.loc.DW,
                            SrcDDRect.loc.DW,
                            0UL,         // don't care
                            0UL,
                            DstDDRect.ext.DW);
            }
          }
          else
          {
            ddrval = DDERR_UNSUPPORTED;
            goto blt_exit;
          }
        }
        else if ((SrcDDRect.ext.pt.X != DstDDRect.ext.pt.X) ||
                 (SrcDDRect.ext.pt.Y != DstDDRect.ext.pt.Y) ||
                 (DDRAWISURF_HASPIXELFORMAT & pbd->lpDDSrcSurface->dwFlags))
        {
          DWORD     StretchCntl;
          DDRECTL   OrigSrcDDRect;
          DDRECTL   OrigDstDDRect;
          int       nDstBytesPixel = BYTESPERPIXEL;
          int       nSrcBytesPixel = BYTESPERPIXEL;


          if (8 == BITSPERPIXEL)
          {
            StretchCntl = (RGB_8_FMT << SRC_FMT_SHIFT) |
                          (RGB_8_FMT << DST_FMT_SHIFT) |
                          0;
          }
          else if ((DDRAWISURF_HASPIXELFORMAT & pbd->lpDDSrcSurface->dwFlags) &&
                   (DDPF_FOURCC & src->ddpfSurface.dwFlags) &&
                   (FOURCC_UYVY == src->ddpfSurface.dwFourCC))
          {
            StretchCntl =   (YUV_422_FMT << SRC_FMT_SHIFT)
                          | (BYTESPERPIXEL << DST_FMT_SHIFT)
                          | XINTERP_ENABLE | YINTERP_ENABLE
                          ;
            nSrcBytesPixel = 2;
          }
          else
          {
            // this only works because the src & dst fmt's in stretch control
            // for 565, 24bpp & 32bpp are the same as the bytes/pixel
            StretchCntl =   (BYTESPERPIXEL << SRC_FMT_SHIFT)
                          | (BYTESPERPIXEL << DST_FMT_SHIFT)
#if 0
            // tddraw agp Cases 21, 23 & 42 do stretch blts with ddraw and
            // the same stretch through gdi, then they expect the results
            // to be identical
            // Since our display driver is not using interpolation on stretch
            // blts then we either need to rewrite StretchBlt in the display
            // driver (lots of days of work) or disable interpolation in
            // ddraw (a one line change)
                          | XINTERP_ENABLE | YINTERP_ENABLE
#endif
                          ;
          }

          // now compute byte coordinates of src and dst
          // upper left of surface is based on frame buffer pixel format
          // offset into surface is based on surface pixel format
#ifdef WINNT_VER40
          OrigDstDDRect.loc.DW = cvlxy(ppdev->lDeltaScreen,dst->fpVidMem,BYTESPERPIXEL);
#else
          OrigDstDDRect.loc.DW = cvlxy(lpDDHALData,dst->fpVidMem-lpDDHALData->ScreenAddress,
                                       BYTESPERPIXEL);
#endif
          OrigDstDDRect.loc.pt.X *= (USHORT)nDstBytesPixel;
          DstDDRect.loc.DW = OrigDstDDRect.loc.DW;

#ifdef WINNT_VER40
          OrigSrcDDRect.loc.DW = cvlxy(ppdev->lDeltaScreen,src->fpVidMem,BYTESPERPIXEL);
#else
          OrigSrcDDRect.loc.DW = cvlxy(lpDDHALData,src->fpVidMem-lpDDHALData->ScreenAddress,
                                       BYTESPERPIXEL);
#endif
          OrigSrcDDRect.loc.pt.X *= (USHORT)nDstBytesPixel; // YES, it's nDstBytesPixel
          SrcDDRect.loc.DW = OrigSrcDDRect.loc.DW;

#ifndef WINNT_VER40   // nt doesn't get this info
          if (pbd->IsClipped)
          {
            OrigDstDDRect.loc.DW += MAKELONG(pbd->rOrigDest.left * nDstBytesPixel,
                                             pbd->rOrigDest.top);
            OrigDstDDRect.ext.pt.X = (WORD)((pbd->rOrigDest.right - pbd->rOrigDest.left) *
                                            nDstBytesPixel);
            OrigDstDDRect.ext.pt.Y = (WORD)(pbd->rOrigDest.bottom - pbd->rOrigDest.top);

            OrigSrcDDRect.loc.DW += MAKELONG(pbd->rOrigSrc.left * nSrcBytesPixel,
                                             pbd->rOrigSrc.top);
            OrigSrcDDRect.ext.pt.X = (WORD)((pbd->rOrigSrc.right - pbd->rOrigSrc.left) *
                                            nSrcBytesPixel);
            OrigSrcDDRect.ext.pt.Y = (WORD)(pbd->rOrigSrc.bottom - pbd->rOrigSrc.top);

            DstDDRect.loc.DW += MAKELONG(pbd->rDest.left * nDstBytesPixel,
                                         pbd->rDest.top);
            DstDDRect.ext.pt.X = (WORD)((pbd->rDest.right - pbd->rDest.left) *
                                        nDstBytesPixel);
            DstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);

            SrcDDRect.loc.DW += MAKELONG(pbd->rSrc.left * nSrcBytesPixel,
                                         pbd->rSrc.top);
            SrcDDRect.ext.pt.X = (WORD)((pbd->rSrc.right - pbd->rSrc.left) *
                                        nSrcBytesPixel);
            SrcDDRect.ext.pt.Y = (WORD)(pbd->rSrc.bottom - pbd->rSrc.top);
          }
          else
#endif
          {
            OrigDstDDRect.loc.DW += MAKELONG(pbd->rDest.left * nDstBytesPixel,
                                             pbd->rDest.top);
            DstDDRect.loc.DW = OrigDstDDRect.loc.DW;
            OrigDstDDRect.ext.pt.X = (WORD)((pbd->rDest.right - pbd->rDest.left) *
                                            nDstBytesPixel);
            DstDDRect.ext.pt.X = OrigDstDDRect.ext.pt.X;
            OrigDstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);
            DstDDRect.ext.pt.Y = OrigDstDDRect.ext.pt.Y;

            OrigSrcDDRect.loc.DW += MAKELONG(pbd->rSrc.left * nSrcBytesPixel,
                                             pbd->rSrc.top);
            SrcDDRect.loc.DW = OrigSrcDDRect.loc.DW;
            OrigSrcDDRect.ext.pt.X = (WORD)((pbd->rSrc.right - pbd->rSrc.left) *
                                            nSrcBytesPixel);
            SrcDDRect.ext.pt.X = OrigSrcDDRect.ext.pt.X;
            OrigSrcDDRect.ext.pt.Y = (WORD)(pbd->rSrc.bottom - pbd->rSrc.top);
            SrcDDRect.ext.pt.Y = OrigSrcDDRect.ext.pt.Y;
          }

#ifdef WINNT_VER40
          DrvStretch65(ppdev, lpDDHALData,
#else
          DrvStretch65(
                        lpDDHALData,
#endif
                     SrcDDRect,
                     DstDDRect,
                     StretchCntl,
                     OrigSrcDDRect,
                     OrigDstDDRect);
        }
        else
        {
#if ENABLE_CLIPPEDBLTS
          DWORD   dstBaseXY;
          DWORD   srcBaseXY;

#ifdef WINNT_VER40
          dstBaseXY = cvlxy(ppdev->lDeltaScreen,dst->fpVidMem,BYTESPERPIXEL);
          srcBaseXY = cvlxy(ppdev->lDeltaScreen,src->fpVidMem,BYTESPERPIXEL);
#else   // Win95
          dstBaseXY = cvlxy(dst->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
          srcBaseXY = cvlxy(src->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
#endif

          if (pbd->IsClipped)
          {
            // compute original dst coordinates
            DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rOrigDest.left, pbd->rOrigDest.top);
            DstDDRect.ext.pt.X = (WORD)(pbd->rOrigDest.right - pbd->rOrigDest.left);
            DstDDRect.ext.pt.Y = (WORD)(pbd->rOrigDest.bottom - pbd->rOrigDest.top);

            // compute original src coordinates
            SrcDDRect.loc.DW   = srcBaseXY + MAKELONG(pbd->rOrigSrc.left, pbd->rOrigSrc.top);
            SrcDDRect.ext.pt.X = (WORD)(pbd->rOrigSrc.right - pbd->rOrigSrc.left);
            SrcDDRect.ext.pt.Y = (WORD)(pbd->rOrigSrc.bottom - pbd->rOrigSrc.top);

            // do the blts
#ifdef WINNT_VER40
            ppdev->pfnClippedDrvSrcBlt(ppdev, lpDDHALData,
#else
            pfnClippedDrvSrcBlt(
                        lpDDHALData,
#endif
                                MAKELONG(rop|DD_CLIP, bdf),
						                    DstDDRect.loc.DW,
						                    SrcDDRect.loc.DW,
						                    0UL,         // don't care
						                    0UL,
						                    DstDDRect.ext.DW,
                                dstBaseXY,
                                srcBaseXY,
                                pbd->dwRectCnt,
                                pbd->prDestRects);
          }
          else  // just do a single blt
          {
            // compute dst coordinates
            DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rDest.left, pbd->rDest.top);
            DstDDRect.ext.pt.X = (WORD)(pbd->rDest.right - pbd->rDest.left);
            DstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);

            // compute src coordinates
            SrcDDRect.loc.DW   = srcBaseXY + MAKELONG(pbd->rSrc.left, pbd->rSrc.top);
            SrcDDRect.ext.pt.X = (WORD)(pbd->rSrc.right - pbd->rSrc.left);
            SrcDDRect.ext.pt.Y = (WORD)(pbd->rSrc.bottom - pbd->rSrc.top);
#endif  // ENABLE_CLIPPEDBLTS

            // do the blt
#ifdef WINNT_VER40
            ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
            pfnDrvSrcBlt(
                        lpDDHALData,
#endif
                         MAKELONG(rop, bdf),
						             DstDDRect.loc.DW,
						             SrcDDRect.loc.DW,
						             0UL,         // don't care
						             0UL,
						             DstDDRect.ext.DW);
#if ENABLE_CLIPPEDBLTS
          }
#endif  // ENABLE_CLIPPEDBLTS
				}
      }
    }
    else // DST ONLY rops
    {
#if ENABLE_CLIPPEDBLTS
      DWORD   dstBaseXY;
#endif  // ENABLE_CLIPPEDBLTS

      DD_LOG(("Dst Only Blt\r\n"));

#if ENABLE_CLIPPEDBLTS
#ifdef WINNT_VER40
      dstBaseXY = cvlxy(ppdev->lDeltaScreen,dst->fpVidMem,BYTESPERPIXEL);
#else   // Win95
      dstBaseXY = cvlxy(dst->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
#endif

      if (pbd->IsClipped)
      {
        // compute original dst coordinates
        DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rOrigDest.left, pbd->rOrigDest.top);
        DstDDRect.ext.pt.X = (WORD)(pbd->rOrigDest.right - pbd->rOrigDest.left);
        DstDDRect.ext.pt.Y = (WORD)(pbd->rOrigDest.bottom - pbd->rOrigDest.top);

        // do the blts
#ifdef WINNT_VER40
        ppdev->pfnDrvClippedDstBlt(ppdev, lpDDHALData,
#else
        pfnDrvClippedDstBlt(
                        lpDDHALData,
#endif
                            MAKELONG(rop|DD_CLIP, bdf),
                            DstDDRect.loc.DW,
                            0UL,         // don't care
                            DstDDRect.ext.DW,
                            dstBaseXY,
                            pbd->dwRectCnt,
                            pbd->prDestRects);
      }
      else  // just do a single blt
      {
        // compute dst coordinates
        DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rDest.left, pbd->rDest.top);
        DstDDRect.ext.pt.X = (WORD)(pbd->rDest.right - pbd->rDest.left);
        DstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);
#endif  // ENABLE_CLIPPEDBLTS

#ifdef WINNT_VER40
        ppdev->pfnDrvDstBlt(ppdev, lpDDHALData,
#else
        pfnDrvDstBlt(
                        lpDDHALData,
#endif
                     MAKELONG(rop, bdf),
                     DstDDRect.loc.DW,
                     0UL,  // don't care
                     DstDDRect.ext.DW);
#if ENABLE_CLIPPEDBLTS
      }
#endif  // ENABLE_CLIPPEDBLTS
    }  // endif (bdf & BD_OP1) // SRC rops
  } // (dwFlags & DDBLT_ROP)
  else if (dwFlags & DDBLT_COLORFILL)
  {
    DWORD dwColor;
#if ENABLE_CLIPPEDBLTS
    DWORD   dstBaseXY;
#endif


    DD_LOG(("Solid Color Fill\r\n"));

#ifdef WINNT_VER40
    dwColor = DupColor(ppdev,pbd->bltFX.dwFillColor);
#else
    dwColor = DupColor(lpDDHALData,pbd->bltFX.dwFillColor);
#endif

#if ENABLE_CLIPPEDBLTS
#ifdef WINNT_VER40
    dstBaseXY = cvlxy(ppdev->lDeltaScreen,dst->fpVidMem,BYTESPERPIXEL);
#else   // Win95
    dstBaseXY = cvlxy(dst->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
#endif

    if (pbd->IsClipped)
    {
      // compute original dst coordinates
      DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rOrigDest.left, pbd->rOrigDest.top);
      DstDDRect.ext.pt.X = (WORD)(pbd->rOrigDest.right - pbd->rOrigDest.left);
      DstDDRect.ext.pt.Y = (WORD)(pbd->rOrigDest.bottom - pbd->rOrigDest.top);

      // do the blts
#ifdef WINNT_VER40
      ppdev->pfnClippedDrvDstBlt(ppdev, lpDDHALData,
#else
      pfnDrvClippedDstBlt(
                        lpDDHALData,
#endif
                          MAKELONG(ROP_OP1_copy | DD_CLIP, BD_RES | (BD_OP1 * IS_SOLID)),
                          DstDDRect.loc.DW,
                          dwColor,
                          DstDDRect.ext.DW,
                          dstBaseXY,
                          pbd->dwRectCnt,
                          pbd->prDestRects);
    }
    else  // just do a single blt
    {
      // compute dst coordinates
      DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rDest.left, pbd->rDest.top);
      DstDDRect.ext.pt.X = (WORD)(pbd->rDest.right - pbd->rDest.left);
      DstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);
#endif  // ENABLE_CLIPPEDBLTS

#ifdef WINNT_VER40
      ppdev->pfnDrvDstBlt(ppdev, lpDDHALData,
#else
      pfnDrvDstBlt(
                        lpDDHALData,
#endif
                   MAKELONG(ROP_OP1_copy, BD_RES | (BD_OP1 * IS_SOLID)),
                   DstDDRect.loc.DW,
                   dwColor,  // fill color
                   DstDDRect.ext.DW);
#if ENABLE_CLIPPEDBLTS
    }
#endif
  }
#ifndef WINNT_VER40     // Not WINNT_VER40
  else if (bD3DInit && dwFlags & DDBLT_DEPTHFILL)
  {
    DWORD   dwFillDepth;
#if ENABLE_CLIPPEDBLTS      // I don't think we'll ever get a clipped zbuffer but you never know ...
    DWORD   dstBaseXY;
#endif // ENABLE_CLIPPEDBLTS


    DD_LOG(("Depth Fill Blt\r\n"));

#ifdef WINNT_VER40
    dwFillDepth = DupZFill(ppdev,pbd->bltFX.dwFillDepth,dst->ddpfSurface.dwZBufferBitDepth);
#else
    dwFillDepth = DupZFill(lpDDHALData,pbd->bltFX.dwFillDepth,dst->ddpfSurface.dwZBufferBitDepth);
#endif

#if ENABLE_CLIPPEDBLTS
#ifdef WINNT_VER40
    dstBaseXY = cvlxy(ppdev->lDeltaScreen,dst->fpVidMem,BYTESPERPIXEL);
#else   // Win95
    dstBaseXY = cvlxy(dst->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
#endif

    if (pbd->IsClipped)
    {
      // compute original dst coordinates
      DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rOrigDest.left, pbd->rOrigDest.top);
      DstDDRect.ext.pt.X = (WORD)(pbd->rOrigDest.right - pbd->rOrigDest.left);
      DstDDRect.ext.pt.Y = (WORD)(pbd->rOrigDest.bottom - pbd->rOrigDest.top);

      // convert to byte blt
      // 16 bit zbuffer in 32 bit frame buffer trashes everything to right
      // of zbuffer
      // Fixes PDR #9152
      DstDDRect.loc.pt.X *= (WORD)(dst->ddpfSurface.dwZBufferBitDepth / 8);
      DstDDRect.ext.pt.X *= (WORD)(dst->ddpfSurface.dwZBufferBitDepth / 8);

      // do the blts
#ifdef WINNT_VER40
      ppdev->pfnClippedDrvDstMBlt(ppdev, lpDDHALData,
#else
      pfnClippedDrvDstMBlt(
                        lpDDHALData,
#endif
                           MAKELONG(ROP_OP1_copy | DD_CLIP, BD_RES | (BD_OP1 * IS_SOLID)),
                           DstDDRect.loc.DW,
                           dwFillDepth,
                           DstDDRect.ext.DW,
                           dstBaseXY,
                           pbd->dwRectCnt,
                           pbd->prDestRects);
    }
    else  // just do a single blt
    {
      // compute dst coordinates
      DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rDest.left, pbd->rDest.top);
      DstDDRect.ext.pt.X = (WORD)(pbd->rDest.right - pbd->rDest.left);
      DstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);
#endif  // ENABLE_CLIPPEDBLTS

      // convert to byte blt
      // 16 bit zbuffer in 32 bit frame buffer trashes everything to right
      // of zbuffer
      // Fixes PDR #9152
      DstDDRect.loc.pt.X *= (WORD)(dst->ddpfSurface.dwZBufferBitDepth / 8);
      DstDDRect.ext.pt.X *= (WORD)(dst->ddpfSurface.dwZBufferBitDepth / 8);

#ifdef WINNT_VER40
      ppdev->pfnDrvDstMBlt(ppdev, lpDDHALData,
#else
      pfnDrvDstMBlt(
                    lpDDHALData,
#endif
                    MAKELONG(ROP_OP1_copy, BD_RES | (BD_OP1 * IS_SOLID)),
                    DstDDRect.loc.DW,
                    dwFillDepth,
                    DstDDRect.ext.DW);
#if ENABLE_CLIPPEDBLTS
    }
#endif // ENABLE_CLIPPEDBLTS
  }
#endif
  else
  {
    DD_LOG(("Unsupported blt - dwFlags = %08lX\r\n", dwFlags));
    ddrval = DDERR_UNSUPPORTED;
    goto blt_exit;
  } // endif (dwFlags & DDBLT_ROP)

blt_exit:

  // Release the hardware - enable HW cursor updates.
  UNLOCK_HW_SEMAPHORE();

  if (ddrval != DD_OK)
     return DDHAL_DRIVER_NOTHANDLED;

  pbd->ddRVal = DD_OK;

  DD_LOG(("Blt65 Exit\r\n"));

  return DDHAL_DRIVER_HANDLED;
} /* Blt65 */

#endif // WINNT_VER35
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\blt_dir.c ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1996, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         blt_dir.c
*
* DESCRIPTION:  Direct blts for the 546x
*
* REVISION HISTORY:
*
* $Log:   X:/log/laguna/ddraw/src/blt_dir.c  $
* 
*    Rev 1.21   Mar 04 1998 15:07:10   frido
* Added new shadow macros.
* 
*    Rev 1.20   06 Jan 1998 11:40:56   xcong
* Change pDriverData into local lpDDHALData for multi-monitor support.
* 
*    Rev 1.19   Nov 04 1997 09:36:16   frido
* Argh! This file is shared with WIndows 95 and it breaks there because I added
* the REQUIRE macro. So I have defined it for non Windows NT as the WaitForRoom
* macro.
* 
*    Rev 1.18   Nov 03 1997 12:48:22   frido
* Added REQUIRE macros.
* Removed redundant WaitForRoom macros.
* 
*    Rev 1.17   03 Oct 1997 14:29:50   RUSSL
* Initial changes for use of hw clipped blts
* All changes wrapped in #if ENABLE_CLIPPEDBLTS/#endif blocks and
* ENABLE_CLIPPEDBLTS defaults to 0 (so the code is disabled)
*
*    Rev 1.16   19 Aug 1997 09:18:42   RUSSL
* Updated require counts in DIR_DrvStrBlt & DIR_DrvStrBlt65
*
*    Rev 1.15   30 Jul 1997 20:55:52   RANDYS
* Added code to check for zero extent blts
*
*    Rev 1.14   24 Jul 1997 12:32:02   RUSSL
* Botched the overlap check, changed || to &&
*
*    Rev 1.13   24 Jul 1997 11:19:02   RUSSL
* Added DIR_DrvStrBlt_OverlapCheck & DIR_DrvStrMBlt_OverlapCheck
* inline functions
*
*    Rev 1.12   14 Jul 1997 14:55:50   RUSSL
* For Win95, split DIR_DrvStrBlt into two versions, one version for 62/64
* and one version for 65+.  BltInit points pfnDrvStrBlt to the appropriate
* version.
*
*    Rev 1.11   08 Jul 1997 11:17:28   RUSSL
* Modified chip check in DIR_DrvStrBlt to a one bit test rather a two dword
* compare (for Win95 only)
*
*    Rev 1.10   19 May 1997 14:02:02   bennyn
* Removed all #ifdef NT for WaitForRoom macro
*
*    Rev 1.9   03 Apr 1997 15:04:48   RUSSL
* Added DIR_DrvDstMBlt function
*
*    Rev 1.8   26 Mar 1997 13:54:24   RUSSL
* Added DIR_DrvSrcMBlt function
* Changed ACCUM_X workaround to just write 0 to LNCNTL
*
*    Rev 1.7   21 Mar 1997 18:05:04   RUSSL
* Added workaround writing ACCUM_X in DIR_DrvStrBlt
*
*    Rev 1.6   12 Mar 1997 15:00:38   RUSSL
* replaced a block of includes with include of precomp.h for
*   precompiled headers
*
*    Rev 1.5   07 Mar 1997 12:49:16   RUSSL
* Modified DDRAW_COMPAT usage
*
*    Rev 1.4   27 Jan 1997 17:28:34   BENNYN
* Added Win95 support
*
*    Rev 1.3   23 Jan 1997 16:55:56   bennyn
* Added 5465 DD support
*
*    Rev 1.2   25 Nov 1996 16:52:20   RUSSL
* NT change broke Win95 build
*
*    Rev 1.1   25 Nov 1996 16:13:54   bennyn
* Fixed misc compiling error for NT
*
*    Rev 1.0   25 Nov 1996 15:11:12   RUSSL
* Initial revision.
*
*    Rev 1.3   18 Nov 1996 16:20:12   RUSSL
* Added file logging for DDraw entry points and register writes
*
*    Rev 1.2   10 Nov 1996 12:36:24   CRAIGN
* Frido's 1111 release.
* Minor parenthesis change - bug fix.
*
*    Rev 1.1   01 Nov 1996 13:08:32   RUSSL
* Merge WIN95 & WINNT code for Blt32
*
*    Rev 1.0   01 Nov 1996 09:27:42   BENNYN
* Initial revision.
*
*    Rev 1.0   25 Oct 1996 11:08:18   RUSSL
* Initial revision.
*
***************************************************************************
***************************************************************************/

/***************************************************************************
* I N C L U D E S
****************************************************************************/

#include "precomp.h"

// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else

#ifdef WINNT_VER40      // WINNT_VER40

#define DBGLVL        1
#define AFPRINTF(n)

#else

#include "bltP.h"

#endif // !WINNT_VER40

/***************************************************************************
* D E F I N E S
****************************************************************************/

#ifndef WINNT_VER40
#define REQUIRE( size ) while ( (volatile)pREG->grQFREE < size )
#endif

/***************************************************************************
* S T A T I C   V A R I A B L E S
****************************************************************************/

#ifndef WINNT_VER40

ASSERTFILE("blt_dir.c");
#define LL_DRAWBLTDEF(drawbltdef, r)	LL32(grDRAWBLTDEF.DW, drawbltdef)
#define LL_BGCOLOR(color, r)			LL32(grOP_opBGCOLOR.DW, color)
#define LL_FGCOLOR(color, r)			LL32(grOP_opFGCOLOR.DW, color)
#endif

/***************************************************************************
*
* FUNCTION:    DIR_Delay9BitBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_Delay9BitBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,  
#endif
  BOOL        ninebit_on
)
{
  PVGAR   pREG  = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_Delay9BitBlt\r\n"));

  /* This is to ensure that the last packet of any previous blt */
  /* does no go out with 9th bit set incorrectly */
  /* The boolean paramter is the 9th bit of the PREVIOUS BLT */

  REQUIRE(7);
  if (ninebit_on)
  {
    LL_DRAWBLTDEF(((BD_RES * IS_VRAM + BD_OP1 * IS_SOLID) << 16) |
                           (DD_PTAG | ROP_OP1_copy), 0);
  }
  else
  {
    LL_DRAWBLTDEF(((BD_RES * IS_VRAM + BD_OP1 * IS_SOLID) << 16) |
                           (ROP_OP1_copy), 0);
  }
  LL32(grOP0_opRDRAM.DW, lpDDHALData->PTAGFooPixel);
  LL32(grBLTEXT_EX.DW,   MAKELONG(1,1));
} /* DIR_Delay9BitBlt */

/***************************************************************************
*
* FUNCTION:     DIR_EdgeFillBlt
*
* DESCRIPTION:  Solid Fill BLT to fill in edges ( Pixel Coords / Extents )
*
****************************************************************************/

void DIR_EdgeFillBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,  
#endif
  int         xFill,
  int         yFill,
  int         cxFill,
  int         cyFill,
  DWORD       FillValue,
  BOOL        ninebit_on
)
{
  PVGAR   pREG  = (PVGAR) lpDDHALData->RegsAddress;


#ifdef WINNT_VER40
  DISPDBG((DBGLVL, "DIR_EdgeFillBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          MAKELONG(xFill,yFill),MAKELONG(cxFill,cyFill),FillValue));
#endif
  DD_LOG(("DIR_EdgeFillBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          MAKELONG(xFill,yFill),MAKELONG(cxFill,cyFill),FillValue));

  REQUIRE(9);
  if (ninebit_on)
  {
    LL_DRAWBLTDEF(((BD_RES * IS_VRAM + BD_OP1 * IS_SOLID) << 16) |
                           (DD_PTAG | ROP_OP1_copy), 0);
  }
  else
  {
    LL_DRAWBLTDEF(((BD_RES * IS_VRAM + BD_OP1 * IS_SOLID) << 16) |
                           (ROP_OP1_copy), 0);
  }
  LL_BGCOLOR(FillValue, 0);
  LL32(grOP0_opRDRAM.DW,  MAKELONG(xFill,yFill));
  LL32(grBLTEXT_EX.DW,    MAKELONG(cxFill,cyFill));

#ifndef WINNT_VER40
  DBG_MESSAGE((" Direct Edge Fill %d,%d %d x %d %08X %s", xFill, yFill, cxFill, cyFill, FillValue, (ninebit_on ? "TRUE" : "FALSE")));
#endif // WINNT_VER40

} /* DIR_EdgeFillBlt */

/***************************************************************************
*
* FUNCTION:     DIR_MEdgeFillBlt
*
* DESCRIPTION:  Using BYTE BLT coords / Extents perform EdgeFill BLT
*
****************************************************************************/

void DIR_MEdgeFillBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  int         xFill,
  int         yFill,
  int         cxFill,
  int         cyFill,
  DWORD       FillValue,
  BOOL        ninebit_on
)
{
  PVGAR   pREG  = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_MEdgeFillBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          MAKELONG(xFill,yFill),MAKELONG(cxFill,cyFill),FillValue));

  REQUIRE(9);
  if (ninebit_on)
  {
    LL_DRAWBLTDEF(((BD_RES * IS_VRAM + BD_OP1 * IS_SOLID) << 16) |
                           (DD_PTAG | ROP_OP1_copy), 0);
  }
  else
  {
    LL_DRAWBLTDEF(((BD_RES * IS_VRAM + BD_OP1 * IS_SOLID) << 16) |
                           (ROP_OP1_copy), 0);
  }
  LL_BGCOLOR(FillValue, 0);
  LL32(grOP0_opMRDRAM.DW, MAKELONG(xFill,yFill));
  LL32(grMBLTEXT_EX.DW,   MAKELONG(cxFill,cyFill));

#ifndef WINNT_VER40     // Not WINNT_VER40
  DBG_MESSAGE((" (M) Edge Fill %d,%d %d x %d %08X %s", xFill, yFill, cxFill, cyFill, FillValue, (ninebit_on ? "TRUE" : "FALSE")));
#endif // WINNT_VER40

} /* DIR_MEdgeFillBlt */


/***************************************************************************
*
* FUNCTION:     DIR_DrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_DrvDstBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,  
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvDstBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  REQUIRE(9);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwBgColor, 0);
  LL32(grOP0_opRDRAM.DW,  dwDstCoord);
  LL32(grBLTEXT_EX.DW,    dwExtents);
} /* DIR_DrvDstBlt */

/***************************************************************************
*
* FUNCTION:     DIR_DrvDstMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_DrvDstMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,  
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvDstMBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  REQUIRE(9);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwBgColor, 0);
  LL32(grOP0_opMRDRAM.DW, dwDstCoord);
  LL32(grMBLTEXT_EX.DW,   dwExtents);
} /* DIR_DrvDstMBlt */

/***************************************************************************
*
* FUNCTION:     DIR_DrvSrcBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_DrvSrcBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;
  // Handle overlapped regions.
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DIR_DrvSrcBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // Check for x overlap.
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0, -1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first.
      DIR_DrvSrcBlt(
#ifdef WINNT_VER40
                    ppdev,
#endif
                    lpDDHALData,
                    dwDrawBlt,
                    dwDstCoord+dwDelta,
                    dwSrcCoord+dwDelta,
                    dwKeyCoord+dwDelta,
                    dwKeyColor,
                    dwExtents-dwDelta);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  // Blt the rest.
  REQUIRE(13);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwKeyColor, 0);
  LL32(grOP0_opRDRAM.DW,  dwDstCoord);
  LL32(grOP1_opRDRAM.DW,  dwSrcCoord);
  LL32(grOP2_opRDRAM.DW,  dwKeyCoord);
  LL32(grBLTEXT_EX.DW,    dwExtents);
} /* DIR_DrvSrcBlt */

/***************************************************************************
*
* FUNCTION:     DIR_DrvSrcMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_DrvSrcMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;
  // Handle overlapped regions.
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DIR_DrvSrcMBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // Check for x overlap.
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0, -1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first.
      DIR_DrvSrcMBlt(
#ifdef WINNT_VER40
                     ppdev,
#endif
                     lpDDHALData,
                     dwDrawBlt,
                     dwDstCoord+dwDelta,
                     dwSrcCoord+dwDelta,
                     dwKeyCoord+dwDelta,
                     dwKeyColor,
                     dwExtents-dwDelta);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  // Blt the rest.
  REQUIRE(13);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwKeyColor, 0);
  LL32(grOP0_opMRDRAM.DW, dwDstCoord);
  LL32(grOP1_opMRDRAM.DW, dwSrcCoord);
  LL32(grOP2_opMRDRAM.DW, dwKeyCoord);
  LL32(grMBLTEXT_EX.DW,   dwExtents);
} /* DIR_DrvSrcMBlt */

#if 0
/***************************************************************************
*
* FUNCTION:     DIR_DrvStrBlt_OverlapCheck
*
* DESCRIPTION:
*
****************************************************************************/

static void INLINE DIR_DrvStrBlt_OverlapCheck
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  int xdelta,ydelta;


  xdelta = abs(pblt->OP0_opRDRAM.pt.X - pblt->OP1_opRDRAM.pt.X);
  ydelta = abs(pblt->OP0_opRDRAM.pt.Y - pblt->OP1_opRDRAM.pt.Y);

  if ((xdelta < pblt->BLTEXT.pt.X) &&
      (ydelta < pblt->BLTEXT.pt.Y))
  {
    // hack, hack, cough, cough
    // pblt->MBLTEXT.DW has src exents (see DrvStretch)

    // blt the src to the lower right of the dest
    DIR_DrvSrcBlt(
#ifdef WINNT_VER40
                  ppdev,
#endif
                  lpDDHALData,
                  MAKELONG(ROP_OP1_copy, BD_RES * IS_VRAM | BD_OP1 * IS_VRAM),
                  pblt->OP0_opRDRAM.DW + pblt->BLTEXT.DW - pblt->MBLTEXT.DW,
                  pblt->OP1_opRDRAM.DW,
						      0UL,         // don't care
						      0UL,
                  pblt->MBLTEXT.DW);

    // update the src ptr to use this copy of the src
    pblt->OP1_opRDRAM.DW = pblt->OP0_opRDRAM.DW + pblt->BLTEXT.DW - pblt->MBLTEXT.DW;
  }
}
#endif

/***************************************************************************
*
* FUNCTION:     DIR_DrvStrMBlt_OverlapCheck
*
* DESCRIPTION:
*
****************************************************************************/

static void INLINE DIR_DrvStrMBlt_OverlapCheck
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  int xdelta,ydelta;


  xdelta = abs(pblt->OP0_opMRDRAM.pt.X - pblt->OP1_opMRDRAM.pt.X);
  ydelta = abs(pblt->OP0_opMRDRAM.pt.Y - pblt->OP1_opMRDRAM.pt.Y);

  if ((xdelta < pblt->MBLTEXTR_EX.pt.X) &&
      (ydelta < pblt->MBLTEXTR_EX.pt.Y))
  {
    // hack, hack, cough, cough
    // pblt->BLTEXT.DW has src exents (see DrvStretch65)

    // blt the src to the lower right of the dest
    DIR_DrvSrcMBlt(
#ifdef WINNT_VER40
                   ppdev,
#endif
                   lpDDHALData,
                   MAKELONG(ROP_OP1_copy, BD_RES * IS_VRAM | BD_OP1 * IS_VRAM),
                   pblt->OP0_opMRDRAM.DW + pblt->MBLTEXTR_EX.DW - pblt->BLTEXT.DW,
                   pblt->OP1_opMRDRAM.DW,
						       0UL,         // don't care
						       0UL,
                   pblt->BLTEXT.DW);

    // update the src ptr to use this copy of the src
    pblt->OP1_opMRDRAM.DW = pblt->OP0_opMRDRAM.DW + pblt->MBLTEXTR_EX.DW - pblt->BLTEXT.DW;
  }
}

#ifdef WINNT_VER40
/***************************************************************************
*
* FUNCTION:     DIR_DrvStrBlt
*
* DESCRIPTION:  NT version
*
****************************************************************************/

void DIR_DrvStrBlt
(
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrBlt - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

  if (ppdev->dwLgDevID >= CL_GD5465)
  {
    // check for overlap
    DIR_DrvStrMBlt_OverlapCheck(
#ifdef WINNT_VER40
                                ppdev,lpDDHALData,
#endif
                                pblt);
	REQUIRE(19);
    LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);
// hw clipping currently not used
//    LL32(grCLIPULE.DW,      pblt->CLIPULE.DW);
//    LL32(grCLIPLOR.DW,      pblt->CLIPLOR.DW);
    LL16(grSRCX,            pblt->SRCX);
    LL16(grSHRINKINC.W,     pblt->SHRINKINC.W);
    LL16(grMIN_X,           pblt->MIN_X);
    LL16(grMAJ_X,           pblt->MAJ_X);
#if 0
    LL16(grACCUM_X,         pblt->ACCUM_X);
#else
    // workaround for hw bug when writing to ACCUM_X
    // writing LNCNTL changes STRETCH_CNTL so write
    // STRETCH_CNTL after this
    *(DWORD *)((BYTE *)(pREG)+0x50C) = MAKELONG(pblt->ACCUM_X,0);
    LG_LOG(0x50C,MAKELONG(pblt->ACCUM_X,0));
#endif
    LL16(grSTRETCH_CNTL.W,  pblt->STRETCH_CNTL.W);
    LL16(grMAJ_Y,           pblt->MAJ_Y);
    LL16(grMIN_Y,           pblt->MIN_Y);
    LL16(grACCUM_Y,         pblt->ACCUM_Y);
    LL32(grOP0_opMRDRAM.DW, pblt->OP0_opMRDRAM.DW);
    LL32(grOP1_opMRDRAM.DW, pblt->OP1_opMRDRAM.DW);

    LL32(grMBLTEXTR_EX.DW, pblt->MBLTEXTR_EX.DW);
  }
  else
  {
#if 0
#pragma message("This needs to be checked out on 62/64")
    // check for overlap
    DIR_DrvStrBlt_OverlapCheck(
#ifdef WINNT_VER40
                               ppdev,lpDDHALData,
#endif
                               pblt);
#endif

	REQUIRE(18);
    LL16(grLNCNTL.W,       pblt->LNCNTL.W);
    LL16(grSHRINKINC.W,    pblt->SHRINKINC.W);
    LL16(grSRCX,           pblt->SRCX);
    LL16(grMAJ_X,          pblt->MAJ_X);
    LL16(grMIN_X,          pblt->MIN_X);
    LL16(grACCUM_X,        pblt->ACCUM_X);
    LL16(grMAJ_Y,          pblt->MAJ_Y);
    LL16(grMIN_Y,          pblt->MIN_Y);
    LL16(grACCUM_Y,        pblt->ACCUM_Y);
    LL32(grOP0_opRDRAM.DW, pblt->OP0_opRDRAM.DW);
    LL32(grOP1_opRDRAM.DW, pblt->OP1_opRDRAM.DW);
    LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);
    LL32(grBLTEXTR_EX.DW,  pblt->BLTEXT.DW);
  }   // endif (ppdev->dwLgDevID >= CL_GD5465)
} /* DIR_DrvStrBlt */
#endif

#ifndef WINNT_VER40
/***************************************************************************
*
* FUNCTION:     DIR_DrvStrBlt
*
* DESCRIPTION:  Win95 62/64 version
*
****************************************************************************/

void DIR_DrvStrBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrBlt - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

#if 0
#pragma message("This needs to be checked out on 62/64")
  // check for overlap
  DIR_DrvStrBlt_OverlapCheck(
#ifdef WINNT_VER40
                             ppdev,
#endif
                             lpDDHALData,
                             pblt);
#endif

  REQUIRE(18);
  LL16(grLNCNTL.W,       pblt->LNCNTL.W);
  LL16(grSHRINKINC.W,    pblt->SHRINKINC.W);
  LL16(grSRCX,           pblt->SRCX);
  LL16(grMAJ_X,          pblt->MAJ_X);
  LL16(grMIN_X,          pblt->MIN_X);
  LL16(grACCUM_X,        pblt->ACCUM_X);
  LL16(grMAJ_Y,          pblt->MAJ_Y);
  LL16(grMIN_Y,          pblt->MIN_Y);
  LL16(grACCUM_Y,        pblt->ACCUM_Y);
  LL32(grOP0_opRDRAM.DW, pblt->OP0_opRDRAM.DW);
  LL32(grOP1_opRDRAM.DW, pblt->OP1_opRDRAM.DW);
  LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);
  LL32(grBLTEXTR_EX.DW,  pblt->BLTEXT.DW);
} /* DIR_DrvStrBlt */

/***************************************************************************
*
* FUNCTION:     DIR_DrvStrBlt65
*
* DESCRIPTION:  Win95 65+ version
*
****************************************************************************/

void DIR_DrvStrBlt65
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
   LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrBlt65 - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opMRDRAM.DW,pblt->MBLTEXT.DW,pblt->OP1_opMRDRAM.DW));

  // check for overlap
  DIR_DrvStrMBlt_OverlapCheck(
#ifdef WINNT_VER40
                              ppdev,
#endif
                              lpDDHALData,
                              pblt);

  REQUIRE(19);
  LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);
  LL16(grSRCX,            pblt->SRCX);
  LL16(grSHRINKINC.W,     pblt->SHRINKINC.W);
  LL16(grMIN_X,           pblt->MIN_X);
  LL16(grMAJ_X,           pblt->MAJ_X);
#if 0
  LL16(grACCUM_X,         pblt->ACCUM_X);
#else
  // workaround for hw bug when writing to ACCUM_X
  // writing LNCNTL changes STRETCH_CNTL so write
  // STRETCH_CNTL after this
  *(DWORD *)((BYTE *)(pREG)+0x50C) = MAKELONG(pblt->ACCUM_X,0);
  LG_LOG(0x50C,MAKELONG(pblt->ACCUM_X,0));
#endif
  LL16(grSTRETCH_CNTL.W,  pblt->STRETCH_CNTL.W);
  LL16(grMAJ_Y,           pblt->MAJ_Y);
  LL16(grMIN_Y,           pblt->MIN_Y);
  LL16(grACCUM_Y,         pblt->ACCUM_Y);
  LL32(grOP0_opMRDRAM.DW, pblt->OP0_opMRDRAM.DW);
  LL32(grOP1_opMRDRAM.DW, pblt->OP1_opMRDRAM.DW);

	LL32(grMBLTEXTR_EX.DW, pblt->MBLTEXTR_EX.DW);
} /* DIR_DrvStrBlt65 */
#endif

/***************************************************************************
*
* FUNCTION:     DIR_DrvStrMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_DrvStrMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
   LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrMBlt - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

#ifndef WINNT_VER40

  /* Check for a zero extent blt */

  if ((pblt->BLTEXT.pt.X == 0) || (pblt->BLTEXT.pt.Y == 0))
    return;

  DBG_MESSAGE(("DIR_DrvStrMBlt:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
  APRINTF(("DIR_DrvStrMBlt:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
           pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
           pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
           pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
           pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
#endif //!WINNT_VER40

  REQUIRE(18);
  LL16(grLNCNTL.W,        pblt->LNCNTL.W);
  LL16(grSHRINKINC.W,     pblt->SHRINKINC.W);
  LL16(grSRCX,            pblt->SRCX);
  LL16(grMAJ_X,           pblt->MAJ_X);
  LL16(grMIN_X,           pblt->MIN_X);
  LL16(grACCUM_X,         pblt->ACCUM_X);
  LL16(grMAJ_Y,           pblt->MAJ_Y);
  LL16(grMIN_Y,           pblt->MIN_Y);
  LL16(grACCUM_Y,         pblt->ACCUM_Y);
  LL32(grOP0_opMRDRAM.DW, pblt->OP0_opRDRAM.DW);
  LL32(grOP1_opMRDRAM.DW, pblt->OP1_opRDRAM.DW);
  LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);

#ifndef WINNT_VER40
  // MBLTEXTR_EX.pt.Y is broken in the 5464.
  // We can use BLTEXTR_EX.pt.Y instead.
  //pREG->grMBLTEXTR_EX  = pblt->BLTEXT;

  LL16(grMBLTEXTR_EX.pt.X, pblt->BLTEXT.pt.X);
  LL16(grBLTEXTR_EX.pt.Y,  pblt->BLTEXT.pt.Y);
#else
  LL32(grMBLTEXTR_EX.DW, pblt->BLTEXT.DW);
#endif
} /* DIR_DrvStrMBlt */

/***************************************************************************
*
* FUNCTION:     DIR_DrvStrMBltY
*
* DESCRIPTION:  Write regs that don't vary over the stripes
*               Used in conjunction with DIR_DrvStrMBltX
*
****************************************************************************/

void DIR_DrvStrMBltY
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrMBltY - dst.Y=%04X dstext.Y=%04X src=%04X\r\n",
          pblt->OP0_opRDRAM.pt.Y,pblt->BLTEXT.pt.Y,pblt->OP1_opRDRAM.pt.Y));

#ifndef WINNT_VER40

  /* Check for a zero extent */

  if (pblt->BLTEXT.pt.Y == 0)
    return;

  DBG_MESSAGE(("DIR_DrvStrMBltY:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
  APRINTF(("DIR_DrvStrMBltY:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
           pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
           pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
           pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
           pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
#endif  //!WINNT_VER40

  REQUIRE(12);
  LL16(grLNCNTL.W,          pblt->LNCNTL.W);
  LL16(grSHRINKINC.W,       pblt->SHRINKINC.W);
  LL16(grMAJ_X,             pblt->MAJ_X);
  LL16(grMIN_X,             pblt->MIN_X);
  LL16(grMAJ_Y,             pblt->MAJ_Y);
  LL16(grMIN_Y,             pblt->MIN_Y);
  LL16(grACCUM_Y,           pblt->ACCUM_Y);
  LL16(grOP0_opMRDRAM.pt.Y, pblt->OP0_opRDRAM.pt.Y);
  LL16(grOP1_opMRDRAM.pt.Y, pblt->OP1_opRDRAM.pt.Y);
  LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);
  LL16(grMBLTEXTR_XEX.pt.Y, pblt->BLTEXT.pt.Y);
} /* DIR_DrvStrMBltY */

/***************************************************************************
*
* FUNCTION:     DrvStrMBltX
*
* DESCRIPTION:  Write stripe specific regs
*               Used in conjunction with DIR_DrvStrMBltY
*
****************************************************************************/

void DIR_DrvStrMBltX
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrMBltX - dst.X=%04X dstext.X=%04X src.X=%04X\r\n",
          pblt->OP0_opRDRAM.pt.X,pblt->BLTEXT.pt.X,pblt->OP1_opRDRAM.pt.X));

#ifndef WINNT_VER40

  /* Check for a zero extent */

  if (pblt->BLTEXT.pt.X == 0)
    return;

  DBG_MESSAGE(("DIR_DrvStrMBltX:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
  APRINTF(("DIR_DrvStrMBltX:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
           pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
           pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
           pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
           pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
#endif //!WINNT_VER40

  REQUIRE(6);
  LL16(grSRCX,              pblt->SRCX);
  LL16(grACCUM_X,           pblt->ACCUM_X);
  LL16(grOP0_opMRDRAM.pt.X, pblt->OP0_opRDRAM.pt.X);
  LL16(grOP1_opMRDRAM.pt.X, pblt->OP1_opRDRAM.pt.X);
  LL16(grMBLTEXTR_XEX.pt.X, pblt->BLTEXT.pt.X);
} /* DIR_DrvStrMBltX */

/***************************************************************************
*
* FUNCTION:     DIR_DrvStrBltY
*
* DESCRIPTION:  Write regs that don't vary over the stripes
*               Used in conjunction with DIR_DrvStrBltX
*
****************************************************************************/

void DIR_DrvStrBltY
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrBltY\r\n"));

#ifndef WINNT_VER40

  /* Check for a zero extent */

  if (pblt->BLTEXT.pt.Y == 0)
    return;

  DBG_MESSAGE(("DIR_DrvStrBltY:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
  APRINTF(("DIR_DrvStrBltY:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
           pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
           pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
           pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
           pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
#endif //!WINNT_VER40

  REQUIRE(10);
  LL16(grLNCNTL.W,      pblt->LNCNTL.W);
  LL16(grSHRINKINC.W,   pblt->SHRINKINC.W);
  LL16(grSRCX,          pblt->SRCX);
  LL16(grMAJ_X,         pblt->MAJ_X);
  LL16(grMIN_X,         pblt->MIN_X);
  LL16(grMAJ_Y,         pblt->MAJ_Y);
  LL16(grMIN_Y,         pblt->MIN_Y);
  LL16(grACCUM_Y,       pblt->ACCUM_Y);
  LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);
} /* DIR_DrvStrBltY */

/***************************************************************************
*
* FUNCTION:     DIR_DrvStrBltX
*
* DESCRIPTION:  Write stripe specific regs
*               Used in conjunction with DIR_DrvStrMBltY
*
****************************************************************************/

void DIR_DrvStrBltX
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrBltX - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

#ifndef WINNT_VER40

  /* Check for a zero extent */

  if (pblt->BLTEXT.pt.X == 0)
    return;

  DBG_MESSAGE(("DIR_DrvStrMBltX:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
  APRINTF(("DIR_DrvStrMBltX:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
           pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
           pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
           pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
           pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
#endif //!WINNT_VER40

  REQUIRE(8);
  LL16(grACCUM_X,        pblt->ACCUM_X);
  LL32(grOP0_opRDRAM.DW, pblt->OP0_opRDRAM.DW);
  LL32(grOP1_opRDRAM.DW, pblt->OP1_opRDRAM.DW);
  LL32(grBLTEXTR_EX.DW,  pblt->BLTEXT.DW);
} /* DIR_DrvStrBltX */

#if ENABLE_CLIPPEDBLTS

/***************************************************************************
*
* FUNCTION:     DIR_HWClippedDrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_HWClippedDrvDstBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,  
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_HWClippedDrvDstBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // check for negative dst coordinates, hw can't deal with negative OP0 values
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.X)
  {
    (short)((REG32 *)&dwExtents)->pt.X += (short)((REG32 *)&dwDstCoord)->pt.X;
    ((REG32 *)&dwDstCoord)->pt.X = 0;
  }
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.Y)
  {
    (short)((REG32 *)&dwExtents)->pt.Y += (short)((REG32 *)&dwDstCoord)->pt.Y;
    ((REG32 *)&dwDstCoord)->pt.Y = 0;
  }

  // setup blt, write BLTEXT reg with extent which doesn't fire off blt
  REQUIRE(8);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwBgColor, 0);
  LL32(grOP0_opRDRAM.DW,  dwDstCoord);
  LL32(grBLTEXT.DW,       dwExtents);

  // loop over clip list
  do
  {
    REG32   UpperLeft;
    REG32   LowerRight;

    // compute cliprect coords
    UpperLeft.DW  = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    LowerRight.DW = dwDstBaseXY + MAKELONG(pDestRects->right, pDestRects->bottom);

    // write clipping regs
    REQUIRE(5);
    LL32(grCLIPULE.DW, UpperLeft.DW);
    LL32(grCLIPLOR_EX.DW, LowerRight.DW);

    pDestRects++;
  } while (0 < --dwRectCnt);
} /* DIR_HWClippedDrvDstBlt */

/***************************************************************************
*
* FUNCTION:     DIR_HWClippedDrvDstMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_HWClippedDrvDstMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBLDATA   lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
  const int nBytesPixel = BYTESPERPIXEL;
  PVGAR     pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_HWClippedDrvDstMBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // check for negative dst coordinates, hw can't deal with negative OP0 values
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.X)
  {
    (short)((REG32 *)&dwExtents)->pt.X += (short)((REG32 *)&dwDstCoord)->pt.X;
    ((REG32 *)&dwDstCoord)->pt.X = 0;
  }
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.Y)
  {
    (short)((REG32 *)&dwExtents)->pt.Y += (short)((REG32 *)&dwDstCoord)->pt.Y;
    ((REG32 *)&dwDstCoord)->pt.Y = 0;
  }

  // setup blt, write MBLTEXT reg with extent which doesn't fire off blt
  REQUIRE(8);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwBgColor, 0);
  LL32(grOP0_opMRDRAM.DW, dwDstCoord);
  LL32(grMBLTEXT.DW,      dwExtents);

  // loop over clip list
  do
  {
    REG32   UpperLeft;
    REG32   LowerRight;

    // compute cliprect coords
    UpperLeft.DW  = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    LowerRight.DW = dwDstBaseXY + MAKELONG(pDestRects->right, pDestRects->bottom);
    UpperLeft.pt.X  *= nBytesPixel;
    LowerRight.pt.X *= nBytesPixel;

    // write clipping regs
    REQUIRE(5);
    LL32(grMCLIPULE.DW, UpperLeft.DW);
    LL32(grMCLIPLOR_EX.DW, LowerRight.DW);

    pDestRects++;
  } while (0 < --dwRectCnt);
} /* DIR_HWClippedDrvDstMBlt */

/***************************************************************************
*
* FUNCTION:     DIR_HWClippedDrvSrcBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_HWClippedDrvSrcBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwSrcBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;
  // Handle overlapped regions
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DIR_HWClippedDrvSrcBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // check for negative dst coordinates, hw can't deal with negative OP0 values
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.X)
  {
    // reduce extent.X
    (short)((REG32 *)&dwExtents)->pt.X += (short)((REG32 *)&dwDstCoord)->pt.X;
    // bump src.X to right
    (short)((REG32 *)&dwSrcCoord)->pt.X -= (short)((REG32 *)&dwDstCoord)->pt.X;
    if ((DD_TRANS | DD_TRANSOP) & dwDrawBlt)
      // bump key.X to right
      (short)((REG32 *)&dwKeyCoord)->pt.X -= (short)((REG32 *)&dwKeyCoord)->pt.X;
    // clear dst.X
    ((REG32 *)&dwDstCoord)->pt.X = 0;
  }
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.Y)
  {
    // reduce extent.Y
    (short)((REG32 *)&dwExtents)->pt.Y += (short)((REG32 *)&dwDstCoord)->pt.Y;
    // bump src.Y down
    (short)((REG32 *)&dwSrcCoord)->pt.Y -= (short)((REG32 *)&dwDstCoord)->pt.Y;
    if ((DD_TRANS | DD_TRANSOP) & dwDrawBlt)
      // bump key.Y down
      (short)((REG32 *)&dwKeyCoord)->pt.Y -= (short)((REG32 *)&dwKeyCoord)->pt.Y;
    // clear dst.Y
    ((REG32 *)&dwDstCoord)->pt.Y = 0;
  }

  // Check for x overlap
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0, -1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first
      DIR_HWClippedDrvSrcBlt(
#ifdef WINNT_VER40
                             ppdev,
#endif
                             lpDDHALData,
                             dwDrawBlt,
                             dwDstCoord+dwDelta,
                             dwSrcCoord+dwDelta,
                             dwKeyCoord+dwDelta,
                             dwKeyColor,
                             dwExtents-dwDelta,
                             dwDstBaseXY,
                             dwSrcBaseXY,
                             dwRectCnt,
                             pDestRects);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  // setup blt, write BLTEXT reg with extent which doesn't fire off blt
  REQUIER(12);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwKeyColor, 0);
  LL32(grOP0_opRDRAM.DW,  dwDstCoord);
  LL32(grOP1_opRDRAM.DW,  dwSrcCoord);
  LL32(grOP2_opRDRAM.DW,  dwKeyCoord);
  LL32(grBLTEXT.DW,       dwExtents);

  // loop over clip list
  do
  {
    REG32   UpperLeft;
    REG32   LowerRight;

    // compute cliprect coords
    UpperLeft.DW  = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    LowerRight.DW = dwDstBaseXY + MAKELONG(pDestRects->right, pDestRects->bottom);

    // write clipping regs
    REQUIRE(5);
    LL32(grCLIPULE.DW, UpperLeft.DW);
    LL32(grCLIPLOR_EX.DW, LowerRight.DW);

    pDestRects++;
  } while (0 < --dwRectCnt);
} /* DIR_HWClippedDrvSrcBlt */

/***************************************************************************
*
* FUNCTION:     DIR_SWClippedDrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_SWClippedDrvDstBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_SWClippedDrvDstBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // make sure DD_CLIP isn't set in drawdef
  dwDrawBlt &= ~DD_CLIP;

  // write regs that don't vary over rectangles
  REQUIRE(4);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwBgColor, 0);

  // loop over clip list
  do
  {
    DDRECTL   DstDDRect;

    // compute cliprect coords
    DstDDRect.loc.DW = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    DstDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left);
    DstDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // write OP0 and bltext regs
    REQUIRE(5);
    LL32(grOP0_opRDRAM.DW, DstDDRect.loc.DW);
    LL32(grBLTEXT_EX.DW,   DstDDRect.ext.DW);

    pDestRects++;
  } while (0 < --dwRectCnt);
} /* DIR_SWClippedDrvDstBlt */

/***************************************************************************
*
* FUNCTION:     DIR_SWClippedDrvDstMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_SWClippedDrvDstMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBLADATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
  const int nBytesPixel = BYTESPERPIXEL;
  PVGAR     pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_SWClippedDrvDstMBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // make sure DD_CLIP isn't set in drawdef
  dwDrawBlt &= ~DD_CLIP;

  // write regs that don't vary over rectangles
  REQUIRE(4);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwBgColor, 0);

  // loop over clip list
  do
  {
    DDRECTL   DstDDRect;

    // compute cliprect coords
    DstDDRect.loc.DW = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    DstDDRect.loc.pt.X *= nBytesPixel;
    DstDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left) * nBytesPixel;
    DstDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // write OP0 and bltext regs
    REQUIRE(5);
    LL32(grOP0_opMRDRAM.DW, DstDDRect.loc.DW);
    LL32(grMBLTEXT_EX.DW,   DstDDRect.ext.DW);

    pDestRects++;
  } while (0 < --dwRectCnt);
} /* DIR_SWClippedDrvDstMBlt */

/***************************************************************************
*
* FUNCTION:     DIR_SWClippedDrvSrcBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_SWClippedDrvSrcBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwSrcBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;
  // Handle overlapped regions
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DIR_SWClippedDrvSrcBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // make sure DD_CLIP isn't set in drawdef
  dwDrawBlt &= ~DD_CLIP;

  // Check for x overlap
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0, -1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first
      DIR_SWClippedDrvSrcBlt(
#ifdef WINNT_VER40
                             ppdev,
#endif
                             lpDDHALData,
                             dwDrawBlt,
                             dwDstCoord+dwDelta,
                             dwSrcCoord+dwDelta,
                             dwKeyCoord+dwDelta,
                             dwKeyColor,
                             dwExtents-dwDelta,
                             dwDstBaseXY,
                             dwSrcBaseXY,
                             dwRectCnt,
                             pDestRects);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  // write regs that don't vary over rectangles
  REQUIRE(4);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwKeyColor, 0);

  // loop over clip list
  do
  {
    DDRECTL   DstDDRect;
    DDRECTL   SrcDDRect;

    // compute dst cliprect coords
    DstDDRect.loc.DW = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    DstDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left);
    DstDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // compute src cliprect coords
    SrcDDRect.loc.DW = dwSrcBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    // don't care about src extent, it's the same as dst extent
    //SrcDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left);
    //SrcDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // write OP0, OP1, OP2 and bltext regs
    if ((DD_TRANS | DD_TRANSOP) == ((DD_TRANS | DD_TRANSOP) & dwDrawBlt))
    {
      // dst color key
      REQUIRE(9);
      LL32(grOP2_opRDRAM.DW, DstDDRect.loc.DW);
    }
    else if (DD_TRANS == ((DD_TRANS | DD_TRANSOP) & dwDrawBlt))
    {
      // src color key
      REQUIRE(9);
      LL32(grOP2_opRDRAM.DW, SrcDDRect.loc.DW);
    }
    else
    {
      REQUIRE(7);
      //LL32(grOP2_opRDRAM.DW, 0);
    }
    LL32(grOP0_opRDRAM.DW, DstDDRect.loc.DW);
    LL32(grOP1_opRDRAM.DW, SrcDDRect.loc.DW);
    LL32(grBLTEXT_EX.DW,   DstDDRect.ext.DW);

    pDestRects++;
  } while (0 < --dwRectCnt);
} /* DIR_SWClippedDrvSrcBlt */

#endif  // ENABLE_CLIPPEDBLTS

#endif // WINNT_VER35
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\color.c ===
/******************************Module*Header*******************************\
 *
 * Module Name: color.c
 *
 * This algorithm for color dithering is patent pending and its use is
 * restricted to Microsoft products and drivers for Microsoft products.
 * Use in non-Microsoft products or in drivers for non-Microsoft product is
 * prohibited without written permission from Microsoft.
 *
 * The patent application is the primary reference for the operation of the
 * color dithering code.
 *
 * Note that in the comments and variable names, "vertex" means "vertex of
 * either the inner (half intensity) or outer (full intensity) color cube."
 * Vertices map to colors 0-6 and 248-255 of the Windows standard (required)
 * 256-color palette, where vertices 0-6 and 248 are the vertices of the inner
 * color cube, and 0 plus 249-255 are the vertices of the full color cube.
 * Vertex 7 is 75% gray; this could be used in the dither, but that would break
 * apps that depend on the exact Windows 3.1 dithering. This code is Window 3.1
 * compatible.
 *
 * Copyright (c) 1992 Microsoft Corporation
 *
 * $Log:   X:/log/laguna/nt35/displays/cl546x/COLOR.C  $
* 
*    Rev 1.4   20 Aug 1996 11:03:18   noelv
* Bugfix release from Frido 8-19-96
* 
*    Rev 1.1   15 Aug 1996 11:44:24   frido
* Added precompiled header.
* 
*    Rev 1.0   14 Aug 1996 17:16:16   frido
* Initial revision.
* 
*    Rev 1.3   05 Mar 1996 11:57:44   noelv
* Frido version 19
 * 
 *    Rev 1.2   03 Feb 1996 13:36:14   frido
 * Use the compile switch "-Dfrido=0" to disable my extensions.
 * 
 *    Rev 1.1   20 Jan 1996 22:14:52   frido
 * Moved the colored dithering to a seperate routine for the new dither cache.
 *
\**************************************************************************/

#include "precomp.h"

#ifndef frido
  #define frido 1
#endif

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
	PALETTEENTRY pal;
	ULONG ul;
} PAL_ULONG;

typedef struct _VERTEX_DATA {
	ULONG ulCount;  // # of pixels in this vertex
	ULONG ulVertex; // vertex #
} VERTEX_DATA;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
	0, 4, 0, 4, 2, 6, 2, 6,
	0, 4, 0, 4, 2, 6, 2, 6,
	1, 5, 1, 5, 3, 7, 3, 7,
	1, 5, 1, 5, 3, 7, 3, 7,
	0, 4, 0, 4, 2, 6, 2, 6,
	0, 4, 0, 4, 2, 6, 2, 6,
	1, 5, 1, 5, 3, 7, 3, 7,
	1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
	0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
	0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
	0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
	0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
	0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
	0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
	0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
	0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
	0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
	0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
	0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
	0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
	0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
	0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
	0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDwordWithConvert[16] = {
	0x00000000,
	0x01010101,
	0x02020202,
	0x03030303,
	0x04040404,
	0x05050505,
	0x06060606,
	0xF8F8F8F8,
	0x07070707,
	0xF9F9F9F9,
	0xFAFAFAFA,
	0xFBFBFBFB,
	0xFCFCFCFC,
	0xFDFDFDFD,
	0xFEFEFEFE,
	0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.

BYTE ajConvert[] =
{
	0,
	1,
	2,
	3,
	4,
	5,
	6,
	248,
	7,
	249,
	250,
	251,
	252,
	253,
	254,
	255
};

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA colors
*
\**************************************************************************/

ULONG DrvDitherColor(
IN  DHPDEV dhpdev,
IN  ULONG  iMode,
IN  ULONG  rgb,
OUT ULONG *pul)
{
	ULONG   ulGrey, ulRed, ulGreen, ulBlue;

	// Figure out if we need a full color dither or only a monochrome dither
	if (iMode != DM_MONOCHROME)
	{
		// Full color dither
		#if !frido
		/*
		 *	I have moved all code here to a seperate routine for faster dither
		 *	realization. It doesn't effect the original code so I just keep it
		 *	split.
		 */
		#endif
		vDitherColor(rgb, pul);
	}
	else
	{
		// For monochrome we will only use the Intensity (grey level)
		RtlFillMemory((PVOID) pul, PATTERNSIZE / 2, 0); // zero the dither bits

		ulRed	= (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
		ulGreen	= (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
		ulBlue	= (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

		// I = .30R + .59G + .11B
		// For convience the following ratios are used:
		//
		//  77/256 = 30.08%
		// 151/256 = 58.98%
		//  28/256 = 10.94%

		ulGrey = (((ulRed * 77) + (ulGreen * 151) + (ulBlue * 28)) >> 8) & 255;

		// Convert the RGBI from 0-255 to 0-64 notation.

		ulGrey = (ulGrey + 1) >> 2;

		while(ulGrey)
		{
			ulGrey--;
			pul[ajByte[ulGrey]] |= (ULONG) ajBits[ulGrey];
		}
	}

	return(DCR_DRIVER);
}

VOID vDitherColor(ULONG rgb, ULONG *pul)
{
	ULONG		ulRed, ulGreen, ulBlue, ulSymmetry;
	ULONG		ulRedTemp, ulGreenTemp, ulBlueTemp, ulTemp;
	VERTEX_DATA	vVertexData[4];
	VERTEX_DATA	*pvVertexData;
	VERTEX_DATA	*pvVertexDataEnd;
	ULONG		*pulDitherOrder;
	ULONG		ulNumPixels;
	BYTE		jColor;
	ULONG		ulColor;
	VERTEX_DATA	*pvMaxVertex;
	ULONG		ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;
	BYTE		*pjDither = (BYTE *)pul;
	int			i;

	// Split the color into red, green, and blue components
	ulRedTemp	= ((PAL_ULONG *) &rgb)->pal.peRed;
	ulGreenTemp	= ((PAL_ULONG *) &rgb)->pal.peGreen;
	ulBlueTemp	= ((PAL_ULONG *) &rgb)->pal.peBlue;

	// Sort the RGB so that the point is transformed into subspace 0, and
	// keep track of the swaps in ulSymmetry so we can unravel it again
	// later.  We want r >= g >= b (subspace 0).
	ulSymmetry = 0;
	if (ulBlueTemp > ulRedTemp)
	{
		SWAPTHEM(ulBlueTemp,ulRedTemp);
		ulSymmetry = SWAP_RB;
	}

	if (ulBlueTemp > ulGreenTemp)
	{
		SWAPTHEM(ulBlueTemp,ulGreenTemp);
		ulSymmetry |= SWAP_GB;
	}

	if (ulGreenTemp > ulRedTemp)
	{
		SWAPTHEM(ulGreenTemp,ulRedTemp);
		ulSymmetry |= SWAP_RG;
	}

	ulSymmetry <<= 4;   // for lookup purposes

	// Scale the values from 0-255 to 0-64. Note that the scaling is not
	// symmetric at the ends; this is done to match Windows 3.1 dithering
	ulRed	= (ulRedTemp + 1) >> 2;
	ulGreen	= (ulGreenTemp + 1) >> 2;
	ulBlue	= (ulBlueTemp + 1) >> 2;

	// Compute the subsubspace within subspace 0 in which the point lies,
	// then calculate the # of pixels to dither in the colors that are the
	// four vertexes of the tetrahedron bounding the color we're emulating.
	// Only vertices with more than zero pixels are stored, and the
	// vertices are stored in order of increasing intensity, saving us the
	// need to sort them later
	if ((ulRedTemp + ulGreenTemp) > 256)
	{
		// Subsubspace 2 or 3
		if ((ulRedTemp + ulBlueTemp) > 256)
		{
			// Subsubspace 3
			// Calculate the number of pixels per vertex, still in
			// subsubspace 3, then convert to original subspace. The pixel
			// counts and vertex numbers are matching pairs, stored in
			// ascending intensity order, skipping vertices with zero
			// pixels. The vertex intensity order for subsubspace 3 is:
			// 7, 9, 0x0B, 0x0F
			pvVertexData = vVertexData;
			if ((ulVertex0Temp = (64 - ulRed) << 1) != 0)
			{
				pvVertexData->ulCount = ulVertex0Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
			}
			ulVertex2Temp = ulGreen - ulBlue;
			ulVertex3Temp = (ulRed - 64) + ulBlue;
			if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
					ulVertex2Temp) - ulVertex3Temp) != 0)
			{
				pvVertexData->ulCount = ulVertex1Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
			}
			if (ulVertex2Temp != 0)
			{
				pvVertexData->ulCount = ulVertex2Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
			}
			if (ulVertex3Temp != 0)
			{
				pvVertexData->ulCount = ulVertex3Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
			}
		}
		else
		{
			// Subsubspace 2
			// Calculate the number of pixels per vertex, still in
			// subsubspace 2, then convert to original subspace. The pixel
			// counts and vertex numbers are matching pairs, stored in
			// ascending intensity order, skipping vertices with zero
			// pixels. The vertex intensity order for subsubspace 2 is:
			// 3, 7, 9, 0x0B
			pvVertexData = vVertexData;
			ulVertex1Temp = ulBlue << 1;
			ulVertex2Temp = ulRed - ulGreen;
			ulVertex3Temp = (ulRed - 32) + (ulGreen - 32);
			if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
					ulVertex2Temp) - ulVertex3Temp) != 0)
			{
				pvVertexData->ulCount = ulVertex0Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
			}
			if (ulVertex1Temp != 0)
			{
				pvVertexData->ulCount = ulVertex1Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
			}
			if (ulVertex2Temp != 0)
			{
				pvVertexData->ulCount = ulVertex2Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
			}
			if (ulVertex3Temp != 0)
			{
				pvVertexData->ulCount = ulVertex3Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
			}
		}
	}
	else
	{
		// Subsubspace 0 or 1
		if (ulRedTemp > 128)
		{
			// Subsubspace 1
			// Calculate the number of pixels per vertex, still in
			// subsubspace 1, then convert to original subspace. The pixel
			// counts and vertex numbers are matching pairs, stored in
			// ascending intensity order, skipping vertices with zero
			// pixels. The vertex intensity order for subsubspace 1 is:
			// 1, 3, 7, 9
			pvVertexData = vVertexData;
			if ((ulVertex0Temp = ((32 - ulGreen) + (32 - ulRed)) << 1) != 0)
			{
				pvVertexData->ulCount = ulVertex0Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
			}
			ulVertex2Temp = ulBlue << 1;
			ulVertex3Temp = (ulRed - 32) << 1;
			if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
					ulVertex2Temp) - ulVertex3Temp) != 0)
			{
				pvVertexData->ulCount = ulVertex1Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
			}
			if (ulVertex2Temp != 0)
			{
				pvVertexData->ulCount = ulVertex2Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
			}
			if (ulVertex3Temp != 0)
			{
				pvVertexData->ulCount = ulVertex3Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
			}
		}
		else
		{
			// Subsubspace 0
			// Calculate the number of pixels per vertex, still in
			// subsubspace 0, then convert to original subspace. The pixel
			// counts and vertex numbers are matching pairs, stored in
			// ascending intensity order, skipping vertices with zero
			// pixels. The vertex intensity order for subsubspace 0 is:
			// 0, 1, 3, 7
			pvVertexData = vVertexData;
			if ((ulVertex0Temp = (32 - ulRed) << 1) != 0)
			{
				pvVertexData->ulCount = ulVertex0Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
			}
			if ((ulVertex1Temp = (ulRed - ulGreen) << 1) != 0)
			{
				pvVertexData->ulCount = ulVertex1Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
			}
			ulVertex3Temp = ulBlue << 1;
			if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
					ulVertex1Temp) - ulVertex3Temp) != 0)
			{
				pvVertexData->ulCount = ulVertex2Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
			}
			if (ulVertex3Temp != 0)
			{
				pvVertexData->ulCount = ulVertex3Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
			}
		}
	}

	// Now that we have found the bounding vertices and the number of
	// pixels to dither for each vertex, we can create the dither pattern

	// Handle 1, 2, and 3 & 4 vertices per dither separately
	ulTemp = pvVertexData - vVertexData;	// # of vertices with more than
											// zero pixels
	if (ulTemp > 2)
	{
		// There are 3 or 4 vertices in this dither

		if (ulTemp == 3)
		{
			// There are 3 vertices in this dither

			// Find the vertex with the most pixels, and fill the whole
			// destination bitmap with that vertex's color, which is faster
			// than dithering it
			if (vVertexData[1].ulCount >= vVertexData[2].ulCount)
			{
				pvMaxVertex = &vVertexData[1];
				ulTemp = vVertexData[1].ulCount;
			}
			else
			{
				pvMaxVertex = &vVertexData[2];
				ulTemp = vVertexData[2].ulCount;
			}
		}
		else
		{
			// There are 4 vertices in this dither

			// Find the vertex with the most pixels, and fill the whole
			// destination bitmap with that vertex's color, which is faster
			// than dithering it
			if (vVertexData[2].ulCount >= vVertexData[3].ulCount)
			{
				pvMaxVertex = &vVertexData[2];
				ulTemp = vVertexData[2].ulCount;
			}
			else
			{
				pvMaxVertex = &vVertexData[3];
				ulTemp = vVertexData[3].ulCount;
			}
		}

		if (vVertexData[1].ulCount > ulTemp)
		{
			pvMaxVertex = &vVertexData[1];
			ulTemp = vVertexData[1].ulCount;
		}
		if (vVertexData[0].ulCount > ulTemp)
		{
			pvMaxVertex = &vVertexData[0];
		}

		pvVertexDataEnd = pvVertexData;

		// Prepare a dword version of the most common vertex number (color)
		ulColor = ulNibbleToDwordWithConvert[pvMaxVertex->ulVertex];

		// Mark that the vertex we're about to do doesn't need to be done
		// later
		pvMaxVertex->ulVertex = 0xFF;

		// Block fill the dither pattern with the more common vertex
		for (i = 0; i < 16; i++)
		{
			pul[i] = ulColor;
		}

		// Now dither all the remaining vertices in order 0->2 or 0->3
		// (in order of increasing intensity)
		pulDitherOrder = aulDitherOrder;
		pvVertexData = vVertexData;
		do
		{
			if (pvVertexData->ulVertex == 0xFF)
			{
				// This is the max vertex, which we already did, but we
				// have to account for it in the dither order
				pulDitherOrder += pvVertexData->ulCount;
			}
			else
			{
				jColor = ajConvert[pvVertexData->ulVertex];
				ulNumPixels = pvVertexData->ulCount;
				switch (ulNumPixels & 3)
				{
					case 3:
						pjDither[*(pulDitherOrder+2)] = jColor;

					case 2:
						pjDither[*(pulDitherOrder+1)] = jColor;

					case 1:
						pjDither[*(pulDitherOrder+0)] = jColor;
						pulDitherOrder += ulNumPixels & 3;

					case 0:
						break;
				}
				if ((ulNumPixels >>= 2) != 0)
				{
					do
					{
						pjDither[*pulDitherOrder] = jColor;
						pjDither[*(pulDitherOrder+1)] = jColor;
						pjDither[*(pulDitherOrder+2)] = jColor;
						pjDither[*(pulDitherOrder+3)] = jColor;
						pulDitherOrder += 4;
					}
					while (--ulNumPixels);
				}
			}
		}
		while (++pvVertexData < pvVertexDataEnd);
	}
	else if (ulTemp == 2)
	{
		// There are exactly two vertices with more than zero pixels; fill
		// in the dither array as follows: block fill with vertex with more
		// points first, then dither in the other vertex
		if (vVertexData[0].ulCount >= vVertexData[1].ulCount)
		{
			// There are no more vertex 1 than vertex 0 pixels, so do
			// the block fill with vertex 0
			ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
			// Do the dither with vertex 1
			jColor = ajConvert[vVertexData[1].ulVertex];
			ulNumPixels = vVertexData[1].ulCount;
			// Set where to start dithering with vertex 1 (vertex 0 is
			// lower intensity, so its pixels come first in the dither
			// order)
			pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
		}
		else
		{
			// There are more vertex 1 pixels, so do the block fill
			// with vertex 1
			ulColor = ulNibbleToDwordWithConvert[vVertexData[1].ulVertex];
			// Do the dither with vertex 0
			jColor = ajConvert[vVertexData[0].ulVertex];
			ulNumPixels = vVertexData[0].ulCount;
			// Set where to start dithering with vertex 0 (vertex 0 is
			// lower intensity, so its pixels come first in the dither
			// order)
			pulDitherOrder = aulDitherOrder;
		}

		// Block fill the dither pattern with the more common vertex
		for (i = 0; i < 16; i++)
		{
			pul[i] = ulColor;
		}

		// Dither in the less common vertex
		switch (ulNumPixels & 3)
		{
			case 3:
				pjDither[*(pulDitherOrder+2)] = jColor;

			case 2:
				pjDither[*(pulDitherOrder+1)] = jColor;

			case 1:
				pjDither[*(pulDitherOrder+0)] = jColor;
				pulDitherOrder += ulNumPixels & 3;

			case 0:
				break;
		}
		if ((ulNumPixels >>= 2) != 0)
		{
			do
			{
				pjDither[*pulDitherOrder] = jColor;
				pjDither[*(pulDitherOrder+1)] = jColor;
				pjDither[*(pulDitherOrder+2)] = jColor;
				pjDither[*(pulDitherOrder+3)] = jColor;
				pulDitherOrder += 4;
			}
			while (--ulNumPixels);
		}
	}
	else
	{
		// There is only one vertex in this dither

		// No sorting or dithering is needed for just one color; we can
		// just generate the final DIB directly
		ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
		for (i = 0; i < 16; i++)
		{
			pul[i] = ulColor;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\brush.c ===
/******************************Module*Header*******************************\
*
* Module Name: Brush.c
* Author: Noel VanHook
* Purpose: Handle calls to DrvRealizeBrush
*
* Copyright (c) 1995 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/BRUSH.C  $
*
*    Rev 1.29   Mar 04 1998 15:11:18   frido
* Added new shadow macros.
*
*    Rev 1.28   Feb 24 1998 13:19:16   frido
* Removed a few warning messages for NT 5.0.
*
*    Rev 1.27   Nov 03 1997 12:51:52   frido
* Added REQUIRE macros.
*
*    Rev 1.26   25 Aug 1997 16:01:22   FRIDO
* Removed resetting of brush unique ID counters in vInvalidateBrushCache.
*
*    Rev 1.25   08 Aug 1997 15:33:16   FRIDO
* Changed brush cache width to bytes for new memory manager.
*
*    Rev 1.24   06 Aug 1997 17:29:56   noelv
* Don't RIP on brush cache alloc failure.  This failure is normal for modes
* without enough offscreen memory for a cache.
*
*    Rev 1.23   09 Apr 1997 10:48:52   SueS
* Changed sw_test_flag to pointer_switch.
*
*    Rev 1.22   08 Apr 1997 12:12:32   einkauf
*
* add SYNC_W_3D to coordinate MCD/2D HW access
*
*    Rev 1.21   19 Feb 1997 13:06:20   noelv
* Added vInvalidateBrushCache()
*
*    Rev 1.20   17 Dec 1996 16:51:00   SueS
* Added test for writing to log file based on cursor at (0,0).
*
*    Rev 1.19   26 Nov 1996 10:18:22   SueS
* Changed WriteLogFile parameters for buffering.  Added test for null
* pointer in logging function.
*
*    Rev 1.18   13 Nov 1996 15:57:54   SueS
* Changed WriteFile calls to WriteLogFile.
*
*    Rev 1.17   22 Aug 1996 18:14:18   noelv
* Frido bug fix release 8-22.
*
*    Rev 1.6   22 Aug 1996 19:12:44   frido
* #1308 - Added extra checks for empty cache slots.
*
*    Rev 1.5   18 Aug 1996 15:19:58   frido
* #nbr - Added brush translation.
*
*    Rev 1.4   17 Aug 1996 14:03:10   frido
* Removed extraneous #include directives.
*
*    Rev 1.3   17 Aug 1996 13:12:12   frido
* New release from Bellevue.
* #1244 - Fixed brush rotation for off-screen bitmaps.
*
*    Rev 1.2   15 Aug 1996 12:26:40   frido
* Moved BRUSH_DBG_LEVEL down.
*
*    Rev 1.1   15 Aug 1996 11:45:14   frido
* Added precompiled header.
*
*    Rev 1.0   14 Aug 1996 17:16:16   frido
* Initial revision.
*
*    Rev 1.14   25 Jul 1996 15:55:24   bennyn
*
* Modified to support DirectDraw
*
*    Rev 1.13   04 Jun 1996 15:57:34   noelv
*
* Added debug code
*
*    Rev 1.12   28 May 1996 15:11:14   noelv
* Updated data logging.
*
*    Rev 1.11   16 May 1996 14:54:20   noelv
* Added logging code.
*
*    Rev 1.10   11 Apr 1996 09:25:16   noelv
* Fided debug messages.
*
*    Rev 1.9   10 Apr 1996 14:14:04   NOELV
*
* Frido release 27
*
*    Rev 1.19   08 Apr 1996 16:45:56   frido
* Added SolidBrush cache.
* Added new check for 32-bpp brushes.
*
*    Rev 1.18   01 Apr 1996 14:00:08   frido
* Added check for valid brush cache.
* Changed layout of brush cache.
*
*    Rev 1.17   30 Mar 1996 22:16:02   frido
* Refined checking for invalid translation flags.
*
*    Rev 1.16   27 Mar 1996 13:07:38   frido
* Added check for undocumented translation flags.
*
*    Rev 1.15   25 Mar 1996 12:03:06   frido
* Changed #ifdef LOG_CALLS into #if LOG_CALLS.
*
*    Rev 1.14   25 Mar 1996 11:50:16   frido
* Bellevue 102B03.
*
*    Rev 1.5   20 Mar 1996 16:20:06   noelv
* 32 bpp color brushes are broken in the chip
*
*    Rev 1.4   20 Mar 1996 16:09:32   noelv
*
* Updated data logging
*
*    Rev 1.3   05 Mar 1996 11:57:38   noelv
* Frido version 19
*
*    Rev 1.13   05 Mar 1996 00:56:30   frido
* Some changes here and there.
*
*    Rev 1.12   04 Mar 1996 23:48:50   frido
* Removed bug in realization of dithered brush.
*
*    Rev 1.11   04 Mar 1996 20:22:30   frido
* Removed bug in BLTDEF register with colored brushes.
*
*    Rev 1.10   28 Feb 1996 22:37:42   frido
* Added Optimize.h.
*
*    Rev 1.9   17 Feb 1996 21:45:28   frido
* Revamped brushing algorithmn.
*
*    Rev 1.8   13 Feb 1996 16:51:18   frido
* Changed the layout of the PDEV structure.
* Changed the layout of all brush caches.
* Changed the number of brush caches.
*
*    Rev 1.7   10 Feb 1996 21:44:32   frido
* Split monochrome and colored translation cache.
*
*    Rev 1.6   08 Feb 1996 00:19:24   frido
* Optimized the entire brushing for non-intel CPU's.
* Removed DrvRealizeBrush for i386 since it is now in assembly.
*
*    Rev 1.5   05 Feb 1996 17:35:32   frido
* Added translation cache.
*
*    Rev 1.4   05 Feb 1996 11:34:02   frido
* Added support for 4-bpp brushes.
*
*    Rev 1.3   03 Feb 1996 14:20:04   frido
* Use the compile switch "-Dfrido=0" to disable my extensions.
*
*    Rev 1.2   20 Jan 1996 22:13:14   frido
* Added dither cache.
* Optimized loading of brush cache bits.
*
\**************************************************************************/

/*

We have two versions of DrvRealizeBrush, a 'C' version and an 'ASM' version.
These must be both be kept up to date.  The ASM version is used for production
drivers. The C version is used for debugging, prototyping, data gathering and
anything else that requires rapid, non-performance-critical changes to the
driver.

Brushes:
=========
Here is a general feel for how brush information flows between NT and the
driver components.

    NT calls DrvBitBlt() with a drawing request.
    DrvBitBlt() determines it needs a brush and calls SetBrush().
    SetBrush() determins the brush has not been realized yet and calls NT
        (BRUSHOBJ_pvGetRbrush()).
    NT calls DrvRealizeBrush().
    DrvRealizeBrush() creates a BrushObject and returns it to NT.
    NT returns brush object to SetBrush().
    SetBrush calls CacheBrush() if the brush is not cached.
    SetBrush() sets up pattern on chip.
    SetBrush() returns DRAWDEF value to BitBlt.


There are 5 seperate brush caches maintained:  A mono cache, a color cache, a
dither cache, a 4bpp cache, and a solid cache.  We do not handle brushes with
masks.  Some of the code for this is in place, but work was stopped on it.

Realizing Brushes:
==================

When we realize a brush we keep a bit of information about it.

  ajPattern[0]   = The bitmap that makes up the pattern.
  nPatSize       = The size of the bitmap.
  iBitmapFormat  = BMF_1BPP, BMF_4BPP, etc.
  ulForeColor    = For mono brushes.
  ulBackColor    = For mono brushes.
  iType          = Type of brush.
  iUniq          = Unique value for brush.
  cache_slot     = Where we cached it last time we used it. It may still be
                   there, or it may have been ejected from the cache since we
                   used it last.
  cache_xy       = The off-screen location of the brush bits.
  cjMask         = Offset to mask bits in ajPattern[].


The memory for the brush data structure is managed by the operating system.
When we realize a brush, we tell NT how much memory we need to hold our brush
data, and NT gives us a pointer.  When NT discards the brush, it frees the
memory it gave us *without* notifing us first!  This means we can't keep lists
of pointers to realized brushes and access them at our leisure, because they
may not exist anymore.  This is a pain when caching brushes.  It would be nice
if we could track cached/not-cached states in the brush itself, but we have no
way of notifing a brush that it has been uncached, because NT way have already
unrealized the brush.

The solution to this is to keep brush ID information in the cache.  The realized
brush tracks where it is in the cache.  The cache tracks which realized brush is
in each slot.



Caching brushes:
================

        We allocate 3 128-byte wide rectangles, side by side. The
        layout of this brush cache region is:

        +----------------+----------------+----------------+
        |                |                |   MONOCHROME   |
        |     COLOR      |      4BPP      +----------------+
        |    BRUSHES     |    BRUSHES     |     DITHER     |
        |                |                |    BRUSHES     |
        |                |                +----------------+
        |                |                | SOLID BRUSHES  |
        +----------------+----------------+----------------+

Mono brushes use 1 bit per pixel (1 byte per scan line, 8 bytes per brush) and
are stored 16 to a line.  Replacement policy is round robin.  We work out way
through the cache table entries, and when the cache is full, we go back to 0 and
start again.

The pdev holds a counter that increments every time we cache a brush. We MOD
this counter with the number of table entries to find the next place to put a
brush.  When we store the brush, we store a unswizzled copy in the cache table
itself, and a swizzled copy in the cache.  After storing the brush, we give it a
'serial number' which is stored in both the cache, and the realized brush.  We
then copy the brushes X,Y address into the realized brush for easy access.  So,
for index I in the cache, things look like this:

Realized Brush
--------------
cache_slot  = I  - tells us which cache table entry to use;
cache_xy         - x,y address of brush in offscreen memory.  Copied from cache
                   table.
iUniq            - matches iUniq in CacheTable[I]

Cache Table [I]
---------------
xy        - x,y address of brush in offscreen memory.  Computed at init time.
ajPattern - brush bits.
iUniq     - matches iUniq in RealizedBrush


Now, in the future, if we are given this brush again, we first check cache_slot
in the realized brush to see where we cached it last time we used it.  Then we
compare iUniq values to see if our brush is *still* cached there.



Dither brushes use 1 byte per pixel (8 bytes per scan line, 64 bytes per brush)
        and are stored 2 to a line.

4bpp brushes use 1 DWORD per pixel (32 bytes per scan line, 256 bytes per brush)
        and use two lines per brush.

Solid brushes use 1 DWORD per pixel (32 bytes  scan line, 256 bytes per brush)
        and use two lines per brush.

Color brushes:
        8 bpp     - 1 byte per pixel, two brushes per scan line.
        16 bpp    - 2 bytes per pixel, 1 brush per scan line.
        24,32 bpp - 4 bytes per pixel, two scan lines per brush.

Brushes are put in the cache using direct frame buffer access.  To make using
cached brushes fast, we maintain a seperate cache table for each cache.  Each
entry in the cache table tracks the (x,y) address of the brush in a format
directly usable by the chip, and the linear address of the brush for storing the
brush quickly.



Initialization:
-----------------
Brush cache initialization is done during surface initialization.
        DrvEnableSurface() => binitSurf() => vInitBrushCache().




*/

#include "precomp.h"
#include "SWAT.h"
#define BRUSH_DBG_LEVEL 1

void vRealizeBrushBits(
        PPDEV     ppdev,
        SURFOBJ  *psoPattern,
        PBYTE     pbDest,
        PULONG    pulXlate,
        PRBRUSH   pRbrush);

BOOL CacheMono(PPDEV ppdev, PRBRUSH pRbrush);
BOOL Cache4BPP(PPDEV ppdev, PRBRUSH pRbrush);
BOOL CacheDither(PPDEV ppdev, PRBRUSH pRbrush);
BOOL CacheBrush(PPDEV ppdev, PRBRUSH pRbrush);

//
// These are test/debugging/information-gathering functions that
// get compiled out under a free build.
//

#if LOG_CALLS
void LogRealizeBrush(
        ULONG     acc,
        PPDEV     ppdev,
        SURFOBJ  *psoPattern,
        SURFOBJ  *psoMask,
        XLATEOBJ *pxlo
    );
#else
    #define LogRealizeBrush(acc, ppdev, psoPattern, psoMask, pxlo)
#endif

//
// These aren't part of the driver.  They are debugging support functions
// that can be inserted where needed.
//

// This dumps useful information about brushes that NT gives us.
void PrintBrush(SURFOBJ  *psoPattern);

// This dumps useful information about brushes we have realized.
void PrintRealizedBrush(PRBRUSH pRbrush);

//
// Mono brushes must be swizzled before they are stored away.
// We do this with this look up table.
//
BYTE Swiz[] = {
0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
};






/**************************************************************************\
*                                                                          *
* DrvRealizeBrush                                                          *
*                                                                          *
\**************************************************************************/

//#nbr (begin)
#if USE_ASM && defined(i386)
BOOL i386RealizeBrush(
#else
BOOL DrvRealizeBrush(
#endif
//#nbr (end)
        BRUSHOBJ *pbo,
        SURFOBJ  *psoTarget,
        SURFOBJ  *psoPattern,
        SURFOBJ  *psoMask,
        XLATEOBJ *pxlo,
        ULONG    iHatch)
{
        PPDEV   ppdev;
        INT     cjPattern, // size of the brush pattern (in bytes).
            cjMask;    // size of the brush mask (in bytes).
        PRBRUSH pRbrush;   // Our brush structure.
        PULONG  pulXlate;  // Color translation table.
        FLONG   flXlate;   // Translation flags.
#if 1 //#nbr
        LONG    lDelta;
#endif

        DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: Entry.\n"));

        //
        // Reality check.
        //
        ASSERTMSG(psoTarget != 0,  "DrvRealizeBrush: No target.\n");

        //
        // Is the screen the target?
        //
        ppdev = (PPDEV) (psoTarget ? psoTarget->dhpdev : 0);

        if (!ppdev)
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: punted (no pdev).\n"));
                LogRealizeBrush(1, ppdev, psoPattern, psoMask, pxlo);
                return FALSE;
        }

    SYNC_W_3D(ppdev);

    //
    // If we don't have a brush cache (maybe we're low on offscreen memory?)
    // then we can't do brushes.
    //
        if (ppdev->Bcache == NULL)
        {
                LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                return(FALSE);
        }

        if (iHatch & RB_DITHERCOLOR)
        {
                ULONG rgb = iHatch & 0x00FFFFFF;
                int       i;

                // Allocate the memory.
                pRbrush = (PRBRUSH) BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH));
                if (pRbrush == NULL)
                {
                        LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                        return(FALSE);
                }

                // Init the brush structure.
                pRbrush->nPatSize = 0;
                pRbrush->iBitmapFormat = BMF_8BPP;
                pRbrush->cjMask = 0;
                pRbrush->iType = BRUSH_DITHER;
                pRbrush->iUniq = rgb;

                // Lookup the dither in the dither cache.
                for (i = 0; i < NUM_DITHER_BRUSHES; i++)
                {
                        if (ppdev->Dtable[i].ulColor == rgb)
                        {
                                pRbrush->cache_slot = i * sizeof(ppdev->Dtable[i]);
                                pRbrush->cache_xy = ppdev->Dtable[i].xy;
                                LogRealizeBrush(0, ppdev, psoPattern, psoMask, pxlo);
                                return(TRUE);
                        }
                }

                // Create the dither and cache it.
                LogRealizeBrush(99, ppdev, psoPattern, psoMask, pxlo);
                return(CacheDither(ppdev, pRbrush));
        }

        ASSERTMSG(psoPattern != 0, "DrvRealizeBrush: No pattern.\n");

        // Is it an 8x8 brush?
        if ((psoPattern->sizlBitmap.cx != 8) || (psoPattern->sizlBitmap.cy != 8))
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: punted (not 8x8).\n"));
                LogRealizeBrush(3, ppdev, psoPattern, psoMask, pxlo);
                return FALSE;
        }

        // Does it have a mask?
        // Some of the mask code is in place, but not all of it.
        if ((psoMask != NULL) && (psoMask->pvScan0 != psoPattern->pvScan0))
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: punted (has a mask).\n"));
                LogRealizeBrush(4, ppdev, psoPattern, psoMask, pxlo);
                return FALSE;
        }

        // Is it a standard format brush?
        if (psoPattern->iType != STYPE_BITMAP)
        {
                DISPDBG((BRUSH_DBG_LEVEL,
                                 "DrvRealizeBrush: punted (not standard bitmap).\n"));
                LogRealizeBrush(2, ppdev, psoPattern, psoMask, pxlo);
                return FALSE;
        }

        //
        // Get the color translation.
        //
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
                pulXlate = XLATEOBJ_piVector(pxlo);
        }
    else
    {
        // Some kind of translation we don't handle.
        return FALSE;
    }


        // The hardware does not support colored bitmaps in 32-bpp.
        if ( (psoPattern->iBitmapFormat > BMF_1BPP) &&
                 (ppdev->iBitmapFormat == BMF_32BPP) )
        {
                LogRealizeBrush(5, ppdev, psoPattern, psoMask, pxlo);
                return(FALSE);
        }

        if (psoPattern->iBitmapFormat == BMF_4BPP)
        {
                int i;

                // Check if we support this bitmap.
                if ( (psoPattern->cjBits != XLATE_PATSIZE) ||
                         (pxlo->cEntries != XLATE_COLORS) )
                {
                        // We don't support other bitmaps than 8x8 and 16 translation
                        // entries.
                        LogRealizeBrush(10, ppdev, psoPattern, psoMask, pxlo);
                        return(FALSE);
                }

                // Allocate the brush.
                pRbrush = BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH) + XLATE_PATSIZE +
                                                                                 XLATE_COLORS * sizeof(ULONG));
                if (pRbrush == NULL)
                {
                LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                        return(FALSE);
                }

                //
                // Init the brush structure.
                //
                pRbrush->nPatSize       = XLATE_PATSIZE + XLATE_COLORS * sizeof(ULONG);
                pRbrush->iBitmapFormat  = BMF_4BPP;
                pRbrush->cjMask         = 0;
                pRbrush->iType          = BRUSH_4BPP;

                // Copy the 4-bpp pattern and translation palette to the brush.
                if (psoPattern->lDelta == 4)
                {
                        memcpy(pRbrush->ajPattern, psoPattern->pvBits, XLATE_PATSIZE);
                }
                else
                {
                        BYTE *pSrc = psoPattern->pvScan0;
                        for (i = 0; i < 8; i++)
                        {
                                ((DWORD *) pRbrush->ajPattern)[i] = *(DWORD *) pSrc;
                                pSrc += psoPattern->lDelta;
                        }
                }
                memcpy(pRbrush->ajPattern + XLATE_PATSIZE, pulXlate,
                           XLATE_COLORS * sizeof(ULONG));

                // Lookup the pattern and palette in the translation cache.
                for (i = 0; i < NUM_4BPP_BRUSHES; i++)
                {
                        if ((memcmp(ppdev->Xtable[i].ajPattern, pRbrush->ajPattern,
                                            XLATE_PATSIZE + XLATE_COLORS * sizeof(ULONG)) == 0)
#if 1 //#1308
                                && (ppdev->Xtable[i].iUniq != 0)
#endif
                        )
                        {
                                // We have a match!
                                pRbrush->iUniq = ppdev->Xtable[i].iUniq;
                                pRbrush->cache_slot = i * sizeof(ppdev->Xtable[i]);
                                pRbrush->cache_xy = ppdev->Xtable[i].xy;
                        LogRealizeBrush(0, ppdev, psoPattern, psoMask, pxlo);
                                return(TRUE);
                        }
                }

                // Cache the brush now.
            LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                return(Cache4BPP(ppdev, pRbrush));
        }

        if (psoPattern->iBitmapFormat == BMF_1BPP)
        {
                int       i;
                PBYTE pSrc;

                // Check if we support this bitmap.
                if (pulXlate == 0)
                {
                    LogRealizeBrush(11, ppdev, psoPattern, psoMask, pxlo);
                        return(FALSE);
                }

                // Allocate the brush.
                pRbrush = BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH) + 8);
                if (pRbrush == NULL)
                {
                    LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                        return(FALSE);
                }

                //
                // Init the brush structure.
                //
                pRbrush->nPatSize = 8;
                pRbrush->iBitmapFormat = BMF_1BPP;
                pRbrush->cjMask = 0;
                pRbrush->iType = BRUSH_MONO;

                // Copy the 4-bpp pattern and translation palette to the brush.
                pRbrush->ulBackColor = ExpandColor(pulXlate[0], ppdev->ulBitCount);
                pRbrush->ulForeColor = ExpandColor(pulXlate[1], ppdev->ulBitCount);
                pSrc = (PBYTE) psoPattern->pvScan0;
                for (i = 0; i < 8; i++)
                {
                        pRbrush->ajPattern[i] = *pSrc;
                        pSrc += psoPattern->lDelta;
                }

                // Lookup the pattern and palette in the translation cache.
                for (i = 0; i < NUM_MONO_BRUSHES; i++)
                {
                        if ((*(DWORD *) &ppdev->Mtable[i].ajPattern[0] ==
                                 *(DWORD *) &pRbrush->ajPattern[0]) &&
#if 1 //#1308
                                (ppdev->Mtable[i].iUniq != 0) &&
#endif
                                (*(DWORD *) &ppdev->Mtable[i].ajPattern[4] ==
                                 *(DWORD *) &pRbrush->ajPattern[4]) )
                        {
                                // We have a match!
                                pRbrush->iUniq = ppdev->Mtable[i].iUniq;
                                pRbrush->cache_slot = i * sizeof(ppdev->Mtable[i]);
                                pRbrush->cache_xy = ppdev->Mtable[i].xy;
                            LogRealizeBrush(0, ppdev, psoPattern, psoMask, pxlo);
                                return(TRUE);
                        }
                }

                // Cache the brush now.
            LogRealizeBrush(0, ppdev, psoPattern, psoMask, pxlo);
                return(CacheMono(ppdev, pRbrush));
        }

#if 1 //#nbr
        // How much memory do we need for the pattern?
        lDelta = (ppdev->iBytesPerPixel * 8);
        if (ppdev->iBytesPerPixel == 3)
        {
                lDelta += 8;
        }
        cjPattern = lDelta * 8;

        // Allocate the memory.
        pRbrush = BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH) + cjPattern);
        if (pRbrush == NULL)
        {
                DISPDBG((BRUSH_DBG_LEVEL,
                                 "DrvRealizeBrush: punted (Mem alloc failed).\n"));
                LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                return(FALSE);
        }

        // Initialize the brush fields.
        pRbrush->nPatSize          = cjPattern;
        pRbrush->iBitmapFormat = ppdev->iBitmapFormat;
        pRbrush->cjMask            = 0;
        pRbrush->iType             = BRUSH_COLOR;

        // Can we realize the bits directly?
        if ((psoPattern->iBitmapFormat == ppdev->iBitmapFormat) &&
                (flXlate & XO_TRIVIAL))
        {
                // Realize the brush bits.
                vRealizeBrushBits(ppdev, psoPattern, &pRbrush->ajPattern[0], pulXlate,
                                                  pRbrush);
        }
        else
        {
                HBITMAP  hBrush;
                SURFOBJ* psoBrush;
                RECTL    rclDst = {     0, 0, 8, 8 };
                BOOL     bRealized = FALSE;

                DISPDBG((BRUSH_DBG_LEVEL, "DrvRealizeBrush: Translating brush.\n"));

                // Create a bitmap wrapper for the brush bits.
                hBrush = EngCreateBitmap(psoPattern->sizlBitmap, lDelta,
                                                                 ppdev->iBitmapFormat, BMF_TOPDOWN,
                                                                 pRbrush->ajPattern);
                if (hBrush != 0)
                {
                        // Associate the bitmap wrapper with the device.
                        if (EngAssociateSurface((HSURF) hBrush, ppdev->hdevEng, 0))
                        {
                                // Lock the bitmap wrapper.
                                psoBrush = EngLockSurface((HSURF) hBrush);
                                if (psoBrush != NULL)
                                {
                                        // Copy the pattern bits to the bitmap wrapper.
                                        if (EngCopyBits(psoBrush, psoPattern, NULL, pxlo, &rclDst,
                                                                         (POINTL*) &rclDst))
                                        {
                                                // In 24-bpp, the brush bits have a different layout.
                                                if (ppdev->iBytesPerPixel == 3)
                                                {
                                                        INT    y;
                                                        ULONG* pulDst = (ULONG*) pRbrush->ajPattern;

                                                        // Walk through every line.
                                                        for (y = 0; y < 8; y++)
                                                        {
                                                                // Copy bytes 0-7 to bytes 25-31.
                                                                pulDst[6] = pulDst[0];
                                                                pulDst[7] = pulDst[1];
                                                                // Next line.
                                                                pulDst   += 8;
                                                        }
                                                }
                                                // Mark the brush as realized.
                                                bRealized = TRUE;
                                        }
                                        else
                                        {
                                                DISPDBG((BRUSH_DBG_LEVEL, "  EngCopyBits failed.\n"));
                                        }
                                        // Unlock the bitmap wrapper.
                                        EngUnlockSurface(psoBrush);
                                }
                                else
                                {
                                        DISPDBG((BRUSH_DBG_LEVEL, "  EngLockSurface failed.\n"));
                                }
                        }
                        else
                        {
                                DISPDBG((BRUSH_DBG_LEVEL, "  EngAssociateSurface failed.\n"));
                        }
                        // Delete the bitmap wrapper.
                        EngDeleteSurface((HSURF) hBrush);
                }
                else
                {
                        DISPDBG((BRUSH_DBG_LEVEL, "(EngCreateBitmap failed)\n"));
                }

                if (!bRealized)
                {
                        // The brush was not realized.
                        return(FALSE);
                }
        }
#else
        if (flXlate & 0x10)
        {
                // Punt to GDI.
                LogRealizeBrush(9, ppdev, psoPattern, psoMask, pxlo);
                return(FALSE);
        }

        // Is it a supported color depth?
        if (psoPattern->iBitmapFormat != ppdev->iBitmapFormat)
        {
                DISPDBG((BRUSH_DBG_LEVEL,
                                "DrvRealizeBrush: punted (unsupported color depth).\n"));
                LogRealizeBrush(5, ppdev, psoPattern, psoMask, pxlo);
                return FALSE;
        }

        //
        // We don't handle color xlates yet.
        // If there is an xlate table, punt it.
        //
        if ( pulXlate )
        {
                DISPDBG((BRUSH_DBG_LEVEL,
                         "DrvRealizeBrush: punted (Xlate required).\n"));
                LogRealizeBrush(9, ppdev, psoPattern, psoMask, pxlo);
                return FALSE;
        }

        //
        // Alloc memory from GDI for brush storage.
        //

        // How much memory to we need for the pattern?
        cjPattern = psoPattern->cjBits;
        if (psoPattern->iBitmapFormat == BMF_24BPP)
                cjPattern += 64;

        // We need memory for the mask too.
        // Check for mask bits equal to pattern bits.
        // If psoMask is NULL, the mask is never used, so no memory is needed.

        if ((psoMask != NULL) && (psoMask->pvScan0 != psoPattern->pvScan0))
                cjMask = psoMask->cjBits;
        else
                cjMask = 0;

        // Allocate the memory.
        pRbrush =
           (PRBRUSH) BRUSHOBJ_pvAllocRbrush(pbo,sizeof(RBRUSH)+cjPattern+cjMask);
        if (!pRbrush)
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: punted (Mem alloc failed).\n"));
                LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                return (FALSE);
        }

        //
        // Init the brush structure.
        //
        pRbrush->nPatSize          = cjPattern;
        pRbrush->iBitmapFormat = psoPattern->iBitmapFormat;
        pRbrush->cjMask            = (cjMask ? cjPattern : 0);
        pRbrush->iType             = BRUSH_COLOR;

        //
        // Realize the brush and mask.  Actually we punted masks a while ago.
        //
        vRealizeBrushBits(ppdev, psoPattern, &pRbrush->ajPattern[0], pulXlate,
                                          pRbrush);
#endif

        //
        // Cache the brush now.
        //
        CacheBrush(ppdev, pRbrush);

        //
        // Dump brush data to the profiling file.
        // Gets compiled out under a free build.
        //
        LogRealizeBrush(0, ppdev, psoPattern, psoMask, pxlo);
        DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: Done.\n"));

        return (TRUE);

}



/***********************************************************************\
*                                                                       *
* vRealizeBrushBits()                                                   *
*                                                                       *
* Copies the brush pattern from GDI to our realized brush.              *
* Called by DrvRealizeBrush()                                           *
*                                                                       *
\***********************************************************************/

void vRealizeBrushBits(
        PPDEV     ppdev,
        SURFOBJ  *psoPattern,
        PBYTE     pbDest,
        PULONG    pulXlate,
        PRBRUSH   pRbrush
)
{
        PBYTE     pbSrc;
        INT i,j;
        LONG lDelta;


        //
        // Find the top scan line in the brush, and it's scan line delta
        // This works for both top down and bottom up brushes.
        //
        pbSrc = psoPattern->pvScan0;
        lDelta = (psoPattern->lDelta);


        //
        // At this point all brushs are 8x8.
        // Currently we only support mono brushes, and brushes with the same
        // color depth as the screen.  Color translations aren't supported.
        //
        // Mono brushes must be swizzled as we copy them.  We do this using
        // a 256 byte lookup table.
        //
        // We store the brushes in host memory as a linear string of bytes.
        // Before we use the brush we will cache it off screen memory in a
        // format that the BLT engine can use.
        //

        switch (psoPattern->iBitmapFormat)
        {
                case BMF_8BPP:
                        //
                        // Store the pattern as 64 consecutive bytes.
                        //

                        if (lDelta == 8)
                        {
                                memcpy(pbDest, pbSrc, 8 * 8);
                        }
                        else
                        {
                                // For each row in the pattern.
                                for (j = 0; j < 8; j++)
                                {
                                        // Copy the row.
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[0];
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[4];

                                        // Move to next row.
                                        pbSrc += lDelta;
                                }
                        }
                        return;

                case BMF_16BPP:
                        //
                        // Store the pattern as 128 consecutive bytes.
                        //
                        if (lDelta == 16)
                        {
                                memcpy(pbDest, pbSrc, 16 * 8);
                        }
                        else
                        {
                                // For each row in the pattern.
                                for (j = 0; j < 8; j++)
                                {
                                        // Copy the row.
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[0];
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[4];
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[8];
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[12];

                                        // Move to next row.
                                        pbSrc += lDelta;
                                }
                        }
                        return;

                case BMF_24BPP:
                        //
                        // Store the pattern as 256 consecutive bytes.
                        //
                        //
                        // Each row in the pattern needs 24 bytes.  The pattern is stored
                        // with 32 bytes per row though, with the last 8 bytes being a
                        // copy of the first 8 bytes, like so:
                        //
                        // RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RG
                        // 1   2   3   4   5   6   7   8   1   2   3
                        // \___________________________/   \________/
                        //             |                       |
                        //     pattern scan line        copy of first 8
                        //                              bytes of scan line
                        //

                        // For each row in the pattern.
                        for (j = 0; j < 8; j++)
                        {
                                //
                                // Copy the row.
                                //
                                for (i = 0; i < 24; i += sizeof(ULONG))
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[i];

                                //
                                // Pad the last 8 bytes with a copy of the first 8 bytes.
                                //
                                *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[0];
                                *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[4];

                                // Move to next row.
                                pbSrc += lDelta;
                        }
                        return;

                case BMF_32BPP:
                        //
                        // Store the pattern as 256 consecutive bytes.
                        //

                        if (lDelta == 32)
                        {
                                memcpy(pbDest, pbSrc, 32 * 8);
                        }
                        else
                        {
                                // For each row in the pattern.
                                for (j = 0; j < 8; j++)
                                {
                                        // Copy the row.
                                        for (i = 0; i < 32; i += sizeof(ULONG))
                                                *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[i];

                                        // Move to next row.
                                        pbSrc += lDelta;
                                }
                        }
                        return;
        }
}

// ===========================================================================+
//                                                                           ||
// ExpandColor()                                                             ||
// Expands a color value to 32 bits by replication.                          ||
// Called by vRealizeBrushBits()                                             ||
//                                                                           ||
// ===========================================================================+

ULONG ExpandColor(ULONG iSolidColor, ULONG ulBitCount)
{
        ULONG color;

        //
        // If the color is an 8 or 16 bit color, it needs to be
        // extended (by replication) to fill a 32 bit register.
        //

        switch (ulBitCount)
        {
                case 8: // For 8 bpp duplicate byte 0 into bytes 1,2,3.
                        color = iSolidColor & 0x00000000FF; // Clear upper 24 bits.
                        return ((color << 24) | (color << 16) | (color << 8) | color);

                case 16: // For 16 bpp, duplicate the low word into the high word.
                        color = (iSolidColor) & 0x0000FFFF; // Clear upper 16 bits.
                        return ((color << 16) | color);

                case 24: // For 24 bpp clear the upper 8 bits.
                        return (iSolidColor & 0x00FFFFFF);

                default: // For 32 bpp just use the color supplied by NT.
                        return (iSolidColor); // Color of fill
        }

}

/**************************************************************************\
 *                                                                                                                                                *
 *      CacheMono()                                                                                                                       *
 *      Cache a realized monochrome brush.                                                                        *
 *                                                                                                                                                *
\**************************************************************************/
BOOL CacheMono(PPDEV ppdev, PRBRUSH pRbrush)
{
        int   i;
        ULONG tbl_idx = ppdev->MNext % NUM_MONO_BRUSHES;
        PBYTE pdest;

        // Copy the monochrome pattern to the cache and off-screen.
        pdest = ppdev->Mtable[tbl_idx].pjLinear;
        for (i = 0; i < 8; i++)
        {
                ppdev->Mtable[tbl_idx].ajPattern[i] = pRbrush->ajPattern[i];
                pdest[i] = Swiz[pRbrush->ajPattern[i]];
        }

        // Store the new uniq ID in the cache slot.
        pRbrush->iUniq = ppdev->Mtable[tbl_idx].iUniq = ++ppdev->MNext;
        pRbrush->cache_slot = tbl_idx * sizeof(ppdev->Mtable[tbl_idx]);
        pRbrush->cache_xy = ppdev->Mtable[tbl_idx].xy;
        return(TRUE);
}

/**************************************************************************\
 *                                                                                                                                                *
 *      Cache4BPP()                                                                                                                       *
 *      Cache a realized 4-bpp brush.                                                                             *
 *                                                                                                                                                *
\**************************************************************************/
BOOL Cache4BPP(PPDEV ppdev, PRBRUSH pRbrush)
{
        ULONG tbl_idx = ppdev->XNext % NUM_4BPP_BRUSHES;
        int       i, j;
        PBYTE psrc, pdest;
        ULONG *pulPalette;

        // Copy the 4-bpp pattern to the cache.
        memcpy(ppdev->Xtable[tbl_idx].ajPattern, pRbrush->ajPattern,
                   XLATE_PATSIZE + XLATE_COLORS * sizeof(ULONG));

        psrc = ppdev->Xtable[tbl_idx].ajPattern;
        pulPalette = ppdev->Xtable[tbl_idx].ajPalette;
        pdest = ppdev->Xtable[tbl_idx].pjLinear;
        switch (ppdev->ulBitCount)
        {
                case 8:
                        for (i = 0; i < 8; i++)
                        {
                                for (j = 0; j < 4; j++)
                                {
                                        *pdest++ = (BYTE) pulPalette[psrc[j] >> 4];
                                        *pdest++ = (BYTE) pulPalette[psrc[j] & 0x0F];
                                }
                                psrc += 4;
                        }
                        break;

                case 16:
                        for (i = 0; i < 8; i++)
                        {
                                for (j = 0; j < 4; j++)
                                {
                                        *((WORD *)pdest)++ = (WORD) pulPalette[psrc[j] >> 4];
                                        *((WORD *)pdest)++ = (WORD) pulPalette[psrc[j] & 0x0F];
                                }
                                psrc += 4;
                        }
                        break;

                case 24:
                        for (i = 0; i < 4; i++)
                        {
                                for (j = 0; j < 4; j += 2)
                                {
                                        ULONG p1, p2, p3, p4;

                                        p1 = pulPalette[psrc[j] >> 4];
                                        p2 = pulPalette[psrc[j] & 0x0F];
                                        p3 = pulPalette[psrc[j + 1] >> 4];
                                        p4 = pulPalette[psrc[j + 1] & 0x0F];
                                        *((DWORD *)pdest)++ = p1 | (p2 << 24);
                                        *((DWORD *)pdest)++ = (p2 >> 8) | (p3 << 16);
                                        *((DWORD *)pdest)++ = (p3 >> 16) | (p4 << 8);
                                }
                                psrc += 4;
                                *((DWORD *)pdest)++ = *(DWORD *) &pdest[-24];
                                *((DWORD *)pdest)++ = *(DWORD *) &pdest[-24];
                        }
                        pdest += ppdev->lDeltaScreen - 4 * 8 * 4;
                        for (i = 0; i < 4; i++)
                        {
                                for (j = 0; j < 4; j += 2)
                                {
                                        ULONG p1, p2, p3, p4;

                                        p1 = pulPalette[psrc[j] >> 4];
                                        p2 = pulPalette[psrc[j] & 0x0F];
                                        p3 = pulPalette[psrc[j + 1] >> 4];
                                        p4 = pulPalette[psrc[j + 1] & 0x0F];
                                        *((DWORD *)pdest)++ = p1 | (p2 << 24);
                                        *((DWORD *)pdest)++ = (p2 >> 8) | (p3 << 16);
                                        *((DWORD *)pdest)++ = (p3 >> 16) | (p4 << 8);
                                }
                                psrc += 4;
                                *((DWORD *)pdest)++ = *(DWORD *) &pdest[-24];
                                *((DWORD *)pdest)++ = *(DWORD *) &pdest[-24];
                        }
                        break;

                case 32:
                        for (i = 0; i < 4; i++)
                        {
                                for (j = 0; j < 4; j++)
                                {
                                        *((DWORD *)pdest)++ = pulPalette[psrc[j] >> 4];
                                        *((DWORD *)pdest)++ = pulPalette[psrc[j] & 0x0F];
                                }
                                psrc += 4;
                        }
                        pdest += ppdev->lDeltaScreen - 4 * 8 * 4;
                        for (i = 0; i < 4; i++)
                        {
                                for (j = 0; j < 4; j++)
                                {
                                        *((DWORD *)pdest)++ = pulPalette[psrc[j] >> 4];
                                        *((DWORD *)pdest)++ = pulPalette[psrc[j] & 0x0F];
                                }
                                psrc += 4;
                        }
                        break;
        }

        // Store the new uniq ID in the cache slot.
        pRbrush->iUniq = ppdev->Xtable[tbl_idx].iUniq = ++ppdev->XNext;
        pRbrush->cache_slot = tbl_idx * sizeof(ppdev->Xtable[tbl_idx]);
        pRbrush->cache_xy = ppdev->Xtable[tbl_idx].xy;
        return(TRUE);
}

/**************************************************************************\
 *                                                                                                                                                *
 *      CacheDither()                                                                                                             *
 *      Cache a realized dither brush.                                                                            *
 *                                                                                                                                                *
\**************************************************************************/
BOOL CacheDither(PPDEV ppdev, PRBRUSH pRbrush)
{
        ULONG tbl_idx = ppdev->DNext++ % NUM_DITHER_BRUSHES;

        // Create the dither directly in off-screen memory.
        vDitherColor(pRbrush->iUniq, (ULONG *) ppdev->Dtable[tbl_idx].pjLinear);

        // Store the color in the cache slot.
        ppdev->Dtable[tbl_idx].ulColor = pRbrush->iUniq;
        pRbrush->cache_slot = tbl_idx * sizeof(ppdev->Dtable[tbl_idx]);
        pRbrush->cache_xy = ppdev->Dtable[tbl_idx].xy;
        return(TRUE);
}

/**************************************************************************\
 *                                                                                                                                                *
 *      CacheBrush()                                                                                                              *
 *      Cache a realized color brush.                                                                             *
 *                                                                                                                                                *
\**************************************************************************/
BOOL CacheBrush(PPDEV ppdev, PRBRUSH pRbrush)
{
        PBYTE psrc, pdest;
        ULONG tbl_idx = ppdev->CNext;

        if (++ppdev->CNext == ppdev->CLast)
        {
                ppdev->CNext = 0;
        }

        // Copy the brush bits to off-screen.
        psrc = pRbrush->ajPattern;
        pdest = ppdev->Ctable[tbl_idx].pjLinear;
        if (pRbrush->iBitmapFormat < BMF_24BPP)
        {
                memcpy(pdest, pRbrush->ajPattern, pRbrush->nPatSize);
        }
        else
        {
                memcpy(pdest, psrc, 32 * 4);
                memcpy(pdest + ppdev->lDeltaScreen, psrc + 32 * 4, 32 * 4);
        }

        ppdev->Ctable[tbl_idx].brushID = pRbrush;
        pRbrush->cache_slot = tbl_idx * sizeof(ppdev->Ctable[tbl_idx]);
        pRbrush->cache_xy = ppdev->Ctable[tbl_idx].xy;
        return(TRUE);
}

//--------------------------------------------------------------------------//
//                                                                          //
//  SetBrush()                                                              //
//  Used by op2BLT(), HostToScreenBLT() and ScreenToScreenBLT() in BITBLT.C //
//  to setup the chip to use the current brush.                             //
//                                                                          //
//--------------------------------------------------------------------------//
BOOL SetBrush(
                PPDEV     ppdev,
                ULONG     *bltdef, // local copy of the BLTDEF register.
                BRUSHOBJ  *pbo,
                POINTL    *pptlBrush)
{

        ULONG color;
        PRBRUSH pRbrush = 0;
        USHORT patoff_x, patoff_y;

        if (ppdev->bDirectDrawInUse)
                return(FALSE);

        //
        // See if the brush is really a solid color.
        //
        if (pbo->iSolidColor != 0xFFFFFFFF)  // It's a solid brush.
        {
                // Expand the color to a full 32 bit DWORD.
                switch (ppdev->ulBitCount)
                {
                        case 8:
                                color = pbo->iSolidColor & 0x000000FF;
                                color |= color << 8;
                                color |= color << 16;
                                break;

                        case 16:
                                color = pbo->iSolidColor & 0x0000FFFF;
                                color |= color << 16;
                                break;

                        case 24:
                                color = pbo->iSolidColor & 0x00FFFFFF;
                                break;

                        case 32:
                                color = pbo->iSolidColor;
                                break;
                }

                #if SOLID_CACHE
                        ppdev->Stable[ppdev->SNext].ulColor = color;
                #endif

                // Load the fg and bg color registers.
                REQUIRE(2);
                LL_BGCOLOR(color, 2);

                // Set the operation
                *bltdef |= 0x0007;   // OP2=FILL.

                return TRUE;  // That's it!
        }

        //
        // It's not a solid color, it's a pattern.
        //
        // Get the pointer to our drivers realization of the brush.
        if (pbo->pvRbrush != NULL)
        {
                pRbrush = pbo->pvRbrush;
        }
        else // we haven't realized it yet, so do so now.
        {
                pRbrush = BRUSHOBJ_pvGetRbrush(pbo);
                if (pRbrush == NULL)
                {
                        return(FALSE);  // Fail if we do not handle the brush.
                }
        }

        //
        // Set pattern offset.
        // NT specifies patttern offset as which pixel on the screen to align
        // with pattern(0,0).  Laguna specifies pattern offset as which pixel
        // of the pattern to align with screen(0,0).  Only the lowest three
        // bits are significant, so we can ignore any overflow when converting.
        // Also, even though PATOFF is a reg_16, we can't do byte wide writes
        // to it.  We have to write both PATOFF.pt.X and PATOFF.pt.Y in a single
        // 16 bit write.
        //
#if 1 //#1244
        patoff_x = (USHORT)(-(pptlBrush->x + ppdev->ptlOffset.x) & 7);
        patoff_y = (USHORT)(-(pptlBrush->y + ppdev->ptlOffset.y) & 7);
#else
        patoff_x = ((pptlBrush->x - 1) ^ 0x07) & 0x07;
        patoff_y = ((pptlBrush->y - 1) ^ 0x07) & 0x07;
#endif
        REQUIRE(1);
        LL16(grPATOFF.w, (patoff_y << 8) | patoff_x);

        //
        // What kind of brush is it?
        //
        if (pRbrush->iType == BRUSH_MONO) // Monochrome brush.
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: Using MONO Brush.\n"));
                #define mb ((MC_ENTRY*)(((BYTE*)ppdev->Mtable) + pRbrush->cache_slot))
                if (mb->iUniq != pRbrush->iUniq)
                {
                        CacheMono(ppdev, pRbrush);
                }

                // Load the fg and bg color registers.
                REQUIRE(6);
                LL_FGCOLOR(pRbrush->ulForeColor, 0);
                LL_BGCOLOR(pRbrush->ulBackColor, 0);

                LL32(grOP2_opMRDRAM, pRbrush->cache_xy);
                *bltdef |= 0x000D;
                return(TRUE);
        }
        else if (pRbrush->iType == BRUSH_4BPP) // 4-bpp brush.
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: Using 4bpp Brush.\n"));
                #define xb ((XC_ENTRY*)(((BYTE*)ppdev->Xtable) + pRbrush->cache_slot))
                if (xb->iUniq != pRbrush->iUniq)
                {
                        Cache4BPP(ppdev, pRbrush);
                }
                REQUIRE(2);
                LL32(grOP2_opMRDRAM, pRbrush->cache_xy);
                *bltdef |= 0x0009;
                return(TRUE);
        }
        else if (pRbrush->iType == BRUSH_DITHER) // Dither brush.
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: Using dither Brush.\n"));
                #define db ((DC_ENTRY*)(((BYTE*)ppdev->Dtable) + pRbrush->cache_slot))
                if (db->ulColor != pRbrush->iUniq)
                {
                        CacheDither(ppdev, pRbrush);
                }
                REQUIRE(2);
                LL32(grOP2_opMRDRAM, pRbrush->cache_xy);
                *bltdef |= 0x0009;
                return(TRUE);
        }
        else // Color brush.
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: Using color Brush.\n"));
                #define cb ((BC_ENTRY*)(((BYTE*)ppdev->Ctable) + pRbrush->cache_slot))
                if (cb->brushID != pRbrush)
                {
                        CacheBrush(ppdev, pRbrush);
                }
                REQUIRE(2);
                LL32(grOP2_opMRDRAM, pRbrush->cache_xy);
                *bltdef |= 0x0009;
                return(TRUE);
        }
}



// ==========================================================================+
//                                                                          ||
// vInitBrushCache()                                                        ||
// Called by bInitSURF in SCREEN.C                                          ||
// Allocate some off screen memory to cache brushes in.                     ||
// Initialize the brush caching tables.                                     ||
//                                                                          ||
// ==========================================================================+
void vInitBrushCache(
                PPDEV ppdev
)
{
        SIZEL sizel;
        int i;
        ULONG x, y;

        //
        // NOTE: The size and location of the brush cache itself
        //       is in pixel coordinates.  The offsets of the
        //       individual brushes within the cache are BYTE offsets.
        //

        //
        // We need to allocate a 128 BYTE wide rectangle.
        // The offscreen memory manager wants the size of the requested
        // rectangle in PIXELS.  So firure out how many pixels are in 128 bytes.
        //
        /*
                We are going to allocate 3 128-byte wide rectangles, side by side. The
                layout of this brush cache region is:

                +----------------+----------------+----------------+
                |                |                |   MONOCHROME   |
                |     COLOR      |      4BPP      +----------------+
                |    BRUSHES     |    BRUSHES     |     DITHER     |
                |                |                |    BRUSHES     |
                +----------------+----------------+----------------+
        */
        sizel.cy = max(max(NUM_COLOR_BRUSHES / 2,
                                           NUM_4BPP_BRUSHES * 2),
                                           NUM_MONO_BRUSHES / 16 + NUM_DITHER_BRUSHES / 2 + 2);
#if MEMMGR
        sizel.cx = 128 * 3;
#else
        sizel.cx = (128 * 3) / ppdev->iBytesPerPixel;
#endif

        //
        // Allocate the offscreen memory
        //
        DISPDBG((BRUSH_DBG_LEVEL,"Allocating the brush cache.\n"));
        ppdev->Bcache =  AllocOffScnMem(ppdev, &sizel, 0, 0);

        // Did the allocate succeed?
        if (! ppdev->Bcache)
        {
                //
                // We failed to allocate a brush cache.
                // Return while the entire cache is still marked as as unusable,
                // This will cause anything needing a brush to punt.
                //
                return;
        }

        //
        // Init the cache table.
        // The X offests of all the brushes in the cache are BYTE
        // offsets.
        //

        // Init the monochrome cache table. The x offsets are bit offsets.
    // Brushes are stored 16 to a row.
        for (i = 0; i < NUM_MONO_BRUSHES; i++)
        {
                x = ppdev->Bcache->x + (128 * 2) + (i % 16) * 8; // byte offset
                y = ppdev->Bcache->y + (i / 16);
                ppdev->Mtable[i].xy = (y << 16) | (x << 3); // convert to bit offset
                ppdev->Mtable[i].pjLinear = ppdev->pjScreen
                                                                  + x + (y * ppdev->lDeltaScreen);
                ppdev->Mtable[i].iUniq = 0;
        }
        ppdev->MNext = 0;

        // Init the 4-bpp cache table. The x offsets are byte offsets.
        // Each brush takes 2 rows.
        for (i = 0; i < NUM_4BPP_BRUSHES; i++)
        {
                x = ppdev->Bcache->x + (128 * 1);
                y = ppdev->Bcache->y + (i * 2);
                ppdev->Xtable[i].xy = (y << 16) | x;
                ppdev->Xtable[i].pjLinear = ppdev->pjScreen
                                                                  + x + (y * ppdev->lDeltaScreen);
                ppdev->Xtable[i].iUniq = 0;
        }
        ppdev->XNext = 0;

        // Init the dither cache table. The x offsets are byte offsets.
        // Two brushes per row.
        for (i = 0; i < NUM_DITHER_BRUSHES; i++)
        {
                x = ppdev->Bcache->x + (128 * 2) + (i % 2) * 64;
                y = ppdev->Bcache->y + (i / 2) + (NUM_MONO_BRUSHES / 16);
                ppdev->Dtable[i].xy = (y << 16) | x;
                ppdev->Dtable[i].pjLinear = ppdev->pjScreen
                                                                  + x + (y * ppdev->lDeltaScreen);
                ppdev->Dtable[i].ulColor = (ULONG) -1;
        }
        ppdev->DNext = 0;

        #if SOLID_CACHE
                // Solid brush cache is for using a mono brush with a mono source.
                // The mono brush is converted to a solid color brush.
                // Each brush takes two rows.
                for (i = 0; i < NUM_SOLID_BRUSHES; i++)
                {
                        x = ppdev->Bcache->x + (128 * 2);
                        y = ppdev->Bcache->y + (i * 2) + (NUM_MONO_BRUSHES / 16)
                          + (NUM_DITHER_BRUSHES / 2);
                        ppdev->Stable[i].xy = (y << 16) | x;
                        ppdev->Stable[i].pjLinear = ppdev->pjScreen
                                                                          + x + (y * ppdev->lDeltaScreen);
                }
                ppdev->SNext = 0;
        #endif

        // Init the color cache table. The x offsets are byte offsets.
        switch (ppdev->ulBitCount)
        {
                case 8: // 8-bpp
                        ppdev->CLast = NUM_8BPP_BRUSHES;
                        for (i = 0; i < NUM_8BPP_BRUSHES; i++)
                        {
                                x = ppdev->Bcache->x + (i % 2) * 64;
                                y = ppdev->Bcache->y + (i / 2);
                                ppdev->Ctable[i].xy = (y << 16) | x;
                                ppdev->Ctable[i].pjLinear = ppdev->pjScreen
                                                                                  + x + (y * ppdev->lDeltaScreen);
                                ppdev->Ctable[i].brushID = 0;
                        }
                        break;

                case 16: // 16-bpp
                        ppdev->CLast = NUM_16BPP_BRUSHES;
                        for (i = 0; i < NUM_16BPP_BRUSHES; i++)
                        {
                                x = ppdev->Bcache->x;
                                y = ppdev->Bcache->y + i;
                                ppdev->Ctable[i].xy = (y << 16) | x;
                                ppdev->Ctable[i].pjLinear = ppdev->pjScreen
                                                                                  + x + (y * ppdev->lDeltaScreen);
                                ppdev->Ctable[i].brushID = 0;
                        }
                        break;

                default: // 24-bpp or 32-bpp
                        ppdev->CLast = NUM_TC_BRUSHES;
                        for (i = 0; i < NUM_TC_BRUSHES; i++)
                        {
                                x = ppdev->Bcache->x;
                                y = ppdev->Bcache->y + (i * 2);
                                ppdev->Ctable[i].xy = (y << 16) | x;
                                ppdev->Ctable[i].pjLinear = ppdev->pjScreen
                                                                                  + x + (y * ppdev->lDeltaScreen);
                                ppdev->Ctable[i].brushID = 0;
                        }
                        break;
        }
        ppdev->CNext = 0;
}

// ==========================================================================+
//                                                                          ||
// vInvalidateBrushCache()                                                  ||
//                                                                          ||
// Invalidate the brush caching tables.                                     ||
//                                                                          ||
// ==========================================================================+
void vInvalidateBrushCache(PPDEV ppdev)
{
    ULONG i;

        // Invalidate the entire monochrome brush cache.
        for (i = 0; i < NUM_MONO_BRUSHES; i++)
        {
                ppdev->Mtable[i].iUniq = 0;
                memset(ppdev->Mtable[i].ajPattern, 0,
                           sizeof(ppdev->Mtable[i].ajPattern));
        }
//      ppdev->MNext = 0;

        // Invalidate the entire 4-bpp brush cache.
        for (i = 0; i < NUM_4BPP_BRUSHES; i++)
        {
                ppdev->Xtable[i].iUniq = 0;
                memset(ppdev->Xtable[i].ajPattern, 0,
                           sizeof(ppdev->Xtable[i].ajPattern));
        }
//      ppdev->XNext = 0;

        // Invalidate the entire dither brush cache.
        for (i = 0; i < NUM_DITHER_BRUSHES; i++)
        {
                ppdev->Dtable[i].ulColor = (ULONG) -1;
        }
//      ppdev->DNext = 0;

        // Invalidate the entire color brush cache.
        for (i = 0; i < (int) ppdev->CLast; i++)
        {
                ppdev->Ctable[i].brushID = 0;
        }
//      ppdev->CNext = 0;
}


#if LOG_CALLS
/* --------------------------------------------------------------------*\
|                                                                       |
| Dump information on what brushes are requested from GDI to the        |
| profiling file.  Allows us to track what gets accellerated and        |
| what gets punted.  This function gets compiled out under a free       |
| build.                                                                |
|                                                                       |
\*---------------------------------------------------------------------*/

extern long lg_i;
extern char lg_buf[256];

void LogRealizeBrush(
ULONG     acc,
PPDEV     ppdev,
SURFOBJ  *psoPattern,
SURFOBJ  *psoMask,
XLATEOBJ *pxlo
)
{

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    lg_i = sprintf(lg_buf,"DrvRealizeBrush: ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    // Did we realize it?  If not, why?
    switch (acc)
    {
        case  0: lg_i = sprintf(lg_buf,"(Realized) ");                   break;
        case  1: lg_i = sprintf(lg_buf,"(Punted - No PDEV) ");           break;
        case  2: lg_i = sprintf(lg_buf,"(Punted - Not STYPE_BITMAP) ");  break;
        case  3: lg_i = sprintf(lg_buf,"(Punted - Not 8x8) ");           break;
        case  4: lg_i = sprintf(lg_buf,"(Punted - Has mask) ");          break;
        case  5: lg_i = sprintf(lg_buf,"(Punted - Bad color depth) ");   break;
        case  6: lg_i = sprintf(lg_buf,"(Punted - ALLOC failed) ");      break;
        case  7: lg_i = sprintf(lg_buf,"(Punted - Color Bottom-Up) ");   break;
        case  8: lg_i = sprintf(lg_buf,"(Punted - No 1BPP Xlate) ");     break;
        case  9: lg_i = sprintf(lg_buf,"(Punted - Has Color Xlate) ");   break;
        case 10: lg_i = sprintf(lg_buf,"(Punted - 4bpp format) ");         break;
        case 11: lg_i = sprintf(lg_buf,"(Punted - 1bpp XLATE) ");          break;
        case 99: lg_i = sprintf(lg_buf,"(Dithered) ");             break;
        default: lg_i = sprintf(lg_buf,"(STATUS UNKNOWN) ");             break;
    }
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    if (psoPattern == NULL)
    {
        lg_i = sprintf(lg_buf,"FMT=NULL");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else
    {
        switch (psoPattern->iBitmapFormat)
        {
            case BMF_1BPP :  lg_i = sprintf(lg_buf,"FMT=1_bpp ");      break;
            case BMF_4BPP :  lg_i = sprintf(lg_buf,"FMT=4_bpp ");      break;
            case BMF_8BPP :  lg_i = sprintf(lg_buf,"FMT=8_bpp ");      break;
            case BMF_16BPP:  lg_i = sprintf(lg_buf,"FMT=16bpp ");      break;
            case BMF_24BPP:  lg_i = sprintf(lg_buf,"FMT=24bpp ");      break;
            case BMF_32BPP:  lg_i = sprintf(lg_buf,"FMT=32bpp ");      break;
            case BMF_4RLE :  lg_i = sprintf(lg_buf,"FMT=4_rle ");      break;
            case BMF_8RLE :  lg_i = sprintf(lg_buf,"FMT=8_rle ");      break;
            default:         lg_i = sprintf(lg_buf,"FMT=OTHER ");      break;
        }
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

        lg_i = sprintf(lg_buf,"CX=%d CY=%d ", psoPattern->sizlBitmap.cx, psoPattern->sizlBitmap.cy);
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    }

    lg_i = sprintf(lg_buf,"MASK=%s ",
                                ((psoMask == NULL) ? "NONE":
                                ((psoMask->pvScan0 == psoPattern->pvScan0) ? "SAME" : "DIFF")));
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    if (pxlo == NULL)
    {
        lg_i = sprintf(lg_buf,"XLAT=NONE ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else
    {
        if (pxlo->flXlate & XO_TRIVIAL)
        {
            lg_i = sprintf(lg_buf,"XLAT=TRIVIAL ");
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
        }
        if (pxlo->flXlate & XO_TABLE)
        {
            lg_i = sprintf(lg_buf,"XLAT=TABLE ");
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
        }
        if (pxlo->flXlate & XO_TO_MONO)
        {
            lg_i = sprintf(lg_buf,"XLAT=TO_MONO ");
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
        }

        switch (pxlo->iSrcType)
        {
            case PAL_INDEXED:   lg_i = sprintf(lg_buf,"SRCPAL=INDEXED  "); break;
            case PAL_BITFIELDS: lg_i = sprintf(lg_buf,"SRCPAL=BITFIELD "); break;
            case PAL_RGB:       lg_i = sprintf(lg_buf,"SRCPAL=R_G_B    "); break;
            case PAL_BGR:       lg_i = sprintf(lg_buf,"SRCPAL=B_G_R    "); break;
            default:            lg_i = sprintf(lg_buf,"SRCPAL=NONE     "); break;
        }
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

        switch (pxlo->iDstType)
        {
            case PAL_INDEXED:  lg_i = sprintf(lg_buf,"DSTPAL=INDEXED  "); break;
            case PAL_BITFIELDS:lg_i = sprintf(lg_buf,"DSTPAL=BITFIELD "); break;
            case PAL_RGB:      lg_i = sprintf(lg_buf,"DSTPAL=R_G_B    "); break;
            case PAL_BGR:      lg_i = sprintf(lg_buf,"DSTPAL=B_G_R    "); break;
            default:           lg_i = sprintf(lg_buf,"DSTPAL=NONE     "); break;
        }
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }

    lg_i = sprintf(lg_buf,"\r\n");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}
#endif

#if SOLID_CACHE
/******************************************************************************
 *                                                                                                                                                        *
 * Name:                CacheSolid                                                                                                        *
 *                                                                                                                                                        *
 * Function:    Convert a solid color into a colored brush for use when a         *
 *                              monochrome source blt requires a solid brush. This will speed *
 *                              up WinBench 96 tests 5 and 9.                                                             *
 *                                                                                                                                                        *
 ******************************************************************************/
void CacheSolid(PPDEV ppdev)
{
        PBYTE pjBrush = ppdev->Stable[ppdev->SNext].pjLinear;
        ULONG color = ppdev->Stable[ppdev->SNext].ulColor;
        int   i, j;

        switch (ppdev->iBitmapFormat)
        {
                case BMF_8BPP:
                        for (i = 0; i < 64; i += 4)
                        {
                                // Remember, the color is already expanded!
                                *(ULONG *) &pjBrush[i] = color;
                        }
                        break;

                case BMF_16BPP:
                        for (i = 0; i < 128; i += 4)
                        {
                                // Remember, the color is already expanded!
                                *(ULONG *) &pjBrush[i] = color;
                        }
                        break;

                case BMF_24BPP:
                        for (j = 0; j < 4; j++)
                        {
                                for (i = 0; i < 24; i += 3)
                                {
                                        *(ULONG *) &pjBrush[i] = color;
                                }
                                *(ULONG *) &pjBrush[i + 0] = *(ULONG *) &pjBrush[0];
                                *(ULONG *) &pjBrush[i + 4] = *(ULONG *) &pjBrush[4];
                                pjBrush += 32;
                        }
                        pjBrush += ppdev->lDeltaScreen - 128;
                        for (j = 0; j < 4; j++)
                        {
                                for (i = 0; i < 24; i += 3)
                                {
                                        *(ULONG *) &pjBrush[i] = color;
                                }
                                *(ULONG *) &pjBrush[i + 0] = *(ULONG *) &pjBrush[0];
                                *(ULONG *) &pjBrush[i + 4] = *(ULONG *) &pjBrush[4];
                                pjBrush += 32;
                        }
                        break;

                case BMF_32BPP:
                        for (i = 0; i < 128; i += 4)
                        {
                                *(ULONG *) &pjBrush[i] = color;
                        }
                        pjBrush += ppdev->lDeltaScreen;
                        for (i = 0; i < 128; i += 4)
                        {
                                *(ULONG *) &pjBrush[i] = color;
                        }
                        break;
        }

        REQUIRE(2);
        LL32(grOP2_opMRDRAM, ppdev->Stable[ppdev->SNext].xy);
        ppdev->SNext = (ppdev->SNext + 1) % NUM_SOLID_BRUSHES;
}
#endif

#if DBG

//
// The rest of this file is debugging functions.
//

/* --------------------------------------------------------------------*\
|                                                                       |
| PrintBrush()                                                          |
| Dump a 1 bpp brush as 'X's and ' 's to the debuger so we can see what |
| it looks like.                                                        |
|                                                                       |
| We don't currently use this, but it can be useful to have for         |
| debugging purposes.                                                   |
|                                                                       |
\*---------------------------------------------------------------------*/
void PrintBrush(
        SURFOBJ  *psoPattern
)
{
        int i,j;
        char c;

        // Only do this for 1bpp brushes.
        if (psoPattern->iBitmapFormat != BMF_1BPP)
                return;

        DISPDBG((BRUSH_DBG_LEVEL,"Brush information:\n"));

        DISPDBG((BRUSH_DBG_LEVEL,"Brush delta is %d bytes.\n",psoPattern->lDelta));
        DISPDBG((BRUSH_DBG_LEVEL,"Brush uses %d bytes.\n",psoPattern->cjBits));
        DISPDBG((BRUSH_DBG_LEVEL,"Brush bits are at 0x%08X.\n",psoPattern->pvBits));
        DISPDBG((BRUSH_DBG_LEVEL,"Scan 0 is at 0x%08X.\n",psoPattern->pvScan0));
        if (psoPattern->fjBitmap & BMF_TOPDOWN)
                        DISPDBG((BRUSH_DBG_LEVEL,"Brush is top down.\n",psoPattern->pvScan0));
        else
                        DISPDBG((BRUSH_DBG_LEVEL,"Brush is bottom up.\n",psoPattern->pvScan0));


        DISPDBG((BRUSH_DBG_LEVEL,"PATTERN:\n"));

        for (i=0; i<8; ++i)
        {
            c = (unsigned char)((long*)psoPattern->pvBits)[i];

            DISPDBG((BRUSH_DBG_LEVEL,"'"));
            for (j=7; (7>=j && j>=0) ; --j)
            {
                 if (c&1)
                        DISPDBG((BRUSH_DBG_LEVEL,"X"));
                 else
                        DISPDBG((BRUSH_DBG_LEVEL," "));
                 c = c >> 1;
            }
            DISPDBG((BRUSH_DBG_LEVEL,"'\n"));
        }

}


//
// ===========================================================================
// Dumps all kind of cool stuff about realized brushes to the debugger.
//
// Here's the realized brush structure:
/*

typedef struct {
        ULONG   nPatSize;
        ULONG   iBitmapFormat;
        ULONG   ulForeColor;
        ULONG   ulBackColor;
        ULONG   isCached;           // 1 if this brush is cached, 0 if not.
        ULONG   cache_slot;         // Slot number of cache table entry.
        ULONG   cache_x;            // These are the (x,y) location of
        ULONG   cache_y;            // the cached brush from screen(0,0)
        ULONG   cjMask;             // offset to mask bits in ajPattern[]
        BYTE    ajPattern[1];       // pattern bits followed by mask bits
} RBRUSH, *PRBRUSH;

*/
// ============================================================================
//
void PrintRealizedBrush(
        PRBRUSH pRbrush)
{
        int i,j;
        char c;

        // Only do this for 1bpp brushes.
        if (pRbrush->iBitmapFormat != BMF_1BPP)
                return;

        DISPDBG((BRUSH_DBG_LEVEL,"\nRealized brush information:\n"));

        DISPDBG((BRUSH_DBG_LEVEL,"Brush colors:  FG = 0x%08X  BG = 0x%08X \n",
                                pRbrush->ulForeColor, pRbrush->ulForeColor));

        DISPDBG((BRUSH_DBG_LEVEL,"Brush pattern size is  %d bytes.\n",
                                pRbrush->nPatSize));

        DISPDBG((BRUSH_DBG_LEVEL,"PATTERN:\n"));

        for (i=0; i<8; ++i)
        {
                c = pRbrush->ajPattern[i];

                DISPDBG((BRUSH_DBG_LEVEL,"'"));
                for (j=7; (7>=j && j>=0) ; --j)
                {
                         if (c&1)
                                        DISPDBG((BRUSH_DBG_LEVEL,"X"));
                         else
                                        DISPDBG((BRUSH_DBG_LEVEL," "));
                         c = c >> 1;
                }
                DISPDBG((BRUSH_DBG_LEVEL,"'\n"));
        }

                DISPDBG((BRUSH_DBG_LEVEL,"\n"));

}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

#if DBG
  
ULONG DebugLevel = 0;

#endif // DBG

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

#if DRIVER_5465

#define STANDARD_DEBUG_PREFIX "CL5465:"

#else // if DRIVER_5465

#define STANDARD_DEBUG_PREFIX "CL546X:"

#endif // if DRIVER_5465


VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

#if DBG

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel) {

#ifdef WINNT_VER40
	     EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
#else
        char buffer[128];

        vsprintf(buffer, DebugMessage, ap);

        OutputDebugStringA(buffer);
#endif

    }

    va_end(ap);

#endif // DBG

} // DebugPrint()

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl546x\ddblt.c ===
/***************************************************************************
*
*                ******************************************
*                * Copyright (c) 1996, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna I (CL-GD546x) -
*
* FILE:     ddblt.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module implements the DirectDraw BLT components
*           for the Laguna NT driver.
*
* MODULES:
*           WINNT                   WIN95
*             DdGetBltStatus()        GetBltStatus32()
*             SetGamma()
*             DrvStretch64()          DrvStretch64()
*             DrvStretch62()          DrvStretch62()
*             DdBlt()                 Blt32()
*             DupColor()              DupColor()
*             EnoughFifoForBlt()      EnoughFifoForBlt()
*                                     RGBResizeBOF64()
*                                     RGB16ShrinkBOF64()
*
* REVISION HISTORY:
*   7/12/96     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/ddraw/src/ddblt.c  $
*
*    Rev 1.25   Feb 16 1998 16:20:02   frido
* Fixed a NT 4.0 compilation bug (lpData is called lpGbl).
*
*    Rev 1.24   14 Jan 1998 06:18:58   eleland
*
* support for display list page-flipping: calls to UpdateFlipStatus are
* thru pointer to function pfnUpdateFlipStatus
*
*    Rev 1.23   07 Jan 1998 17:45:30   xcong
* Fix the change for WIN95 which breaks NT in DUP_COLOR macro.
*
*    Rev 1.22   06 Jan 1998 14:31:28   xcong
* Change all the macros to use lpDDHALData instead of pDriverData.
*
*    Rev 1.21   06 Jan 1998 11:44:42   xcong
* Change pDriverData into local lpDDHALData for multi-monitor support.
*
*    Rev 1.20   03 Oct 1997 14:46:50   RUSSL
* Initial changes for use of hw clipped blts
* All changes wrapped in #if ENABLE_CLIPPEDBLTS/#endif blocks and
* ENABLE_CLIPPEDBLTS defaults to 0 (so the code is disabled)
*
*    Rev 1.19   01 Oct 1997 17:44:24   eleland
* added check in blt32() to detect blts to host texture surfaces and
* punt those blts back to the ddraw HEL
*
*    Rev 1.18   30 Jul 1997 20:56:22   RANDYS
*
* Added code to check for zero extent blts
*
*    Rev 1.17   18 Jul 1997 10:23:34   RUSSL
* Modified StretchColor to use function ptr to blt routines rather than
* directly program registers.  This is for compatiblity with display lists
*
*    Rev 1.16   14 Jul 1997 14:49:32   RUSSL
* Modified BltInit's initialization of pfnDrvStrBlt for Win95
*
*    Rev 1.15   08 Jul 1997 11:15:20   RUSSL
* Removed an ASSERT that is no longer valid in StretchColor
*
*    Rev 1.14   07 Jul 1997 10:57:14   dzenz
* Added check of DRVSEM_DISPLAY_LIST semaphore to ascertain if
* qmRequestDirectAccess needs to be called.
*
*    Rev 1.13   08 Apr 1997 12:17:06   einkauf
* WINNT_VER40 affected only: add SYNC_W_3D to coordinate MCD/2D HW access
*
*    Rev 1.12   03 Apr 1997 15:24:48   RUSSL
* Added pfnDrvDstMBlt global var
* Added initializing pfnDrvDstMBlt in BltInit
* Modified DDBLT_DEPTHFILL case in Blt32 to blt based on surface colordepth
*   it was clearing 16bit zbuffers in 32bit modes with pixel blts so would
*   wipe out everything to the right of the actual zbuffer
*   Fixes at least PDRs #9152, 9150 & 8789 (maybe others as well)
*
*    Rev 1.11   01 Apr 1997 09:15:24   RUSSL
* Added calls to SyncWithQueueManager in GetBltStatus32
*
*    Rev 1.10   26 Mar 1997 14:08:22   RUSSL
* Added pfnDrvSrcMBlt global var
* Added initializing pfnDrvSrcMBlt in BltInit
* Moved sync with queue manager in Blt32 in front of updateFlipStatus since
*   updateFlipStatus may access the hardware
*
*    Rev 1.9   18 Mar 1997 07:50:24   bennyn
* Resolved NT compiling error by #ifdef queue manager sync call
*
*    Rev 1.8   12 Mar 1997 15:02:02   RUSSL
* replaced a block of includes with include of precomp.h for
*   precompiled headers
*
*    Rev 1.7   07 Mar 1997 12:51:38   RUSSL
* Modified DDRAW_COMPAT usage
*
*    Rev 1.6   03 Mar 1997 10:32:34   eleland
* modified queue manager sync call to check 2d display list
* flag; removed USE_QUEUE_MANAGER #ifdef
*
*    Rev 1.5   07 Feb 1997 13:22:36   KENTL
* Merged in Evan Leland's modifications to get Display List mode working:
* 	* include qmgr.h
* 	* Call qmRequesetDirectAcces() if 3D is busy (Disabled)
*
*    Rev 1.4   21 Jan 1997 14:45:42   RUSSL
* Added include of ddinline.h
*
*    Rev 1.3   15 Jan 1997 10:45:20   RUSSL
* Made Win95 function ptr vars global
* Moved following inline functions to bltP.h: DupZFill, DupColor &
*   EnoughFifoForBlt
*
*    Rev 1.2   13 Dec 1996 15:28:32   CRAIGN
* Added a Frido YUV move fix.
*
*    Rev 1.1   25 Nov 1996 16:16:10   bennyn
* Fixed misc compiling errors for NT
*
*    Rev 1.0   25 Nov 1996 14:43:02   RUSSL
* Initial revision.
*
*    Rev 1.6   25 Nov 1996 14:40:02   RUSSL
* Yet another merge of winNT & win95 code
*
*    Rev 1.5   25 Nov 1996 11:39:02   RUSSL
* Added TransparentStretch function
*
*    Rev 1.4   18 Nov 1996 16:16:18   RUSSL
* Added file logging for DDraw entry points and register writes
*
*    Rev 1.3   12 Nov 1996 09:42:02   CRAIGN
* Frido 1112s2 release... fixes TDDRAW case 26.
* Changed transparency for DDBLT_KEYDESTOVERRIDE to "not equal."
*
*    Rev 1.2   11 Nov 1996 12:36:48   CRAIGN
* Frido 1112 release - added software color key stretch.
*
*    Rev 1.1   06 Nov 1996 12:28:42   CRAIGN
* Frido 1106 - added check for rectangle movement.
*
*    Rev 1.0   01 Nov 1996 13:09:30   RUSSL
* Merge WIN95 & WINNT code for Blt32
*
*    Rev 1.9   01 Nov 1996 09:23:24   BENNYN
* Initial copy of shareable DD blt code
*
* COMBINED WINNT & WIN95 VERSIONS OF BLT CODE
*
*    Rev 1.17   25 Oct 1996 11:55:54   RUSSL
* Forgot to remove the undef RDRAM_8BIT
*
*    Rev 1.16   25 Oct 1996 11:50:16   RUSSL
* Added use of function pointers for all the short blt functions (like
* DrvDstBlt, DrvSrcBlt, etc.).  Moved the short blt functions to a
* separate file (blt_dir.c).  Modified DrvStretch64, DrvStretch62,
* RGBResizeBOF64 & RGB16ShrinkBOF64 to use the blt function pointers
* rather than directly call one of the short blt functions or write
* directly to the registers.  This enables the short blt functions to
* be written as display lists rather than directly writing to the
* registers (in fact, that's whats in blt_dl.c)
*
* Added BltInit function to initialize the function pointers.  BltInit
* needs to be called by buildHALInfo32.
*
*    Rev 1.15   21 Oct 1996 11:56:08   RUSSL
* Added RGB16ShrinkBOF64 to handle 16bpp shrink blts on the 5464
* Now RGBResizeBOF64 only handles 8bpp stretches, 8bpp shrinks and
*   16bpp stretches on the 5464
* Added QFREE checking before blts in both RGB???BOF64 functions
*
*    Rev 1.14   16 Oct 1996 16:10:40   RUSSL
* Added RGBResizeBOF64 to handle resize blts on 5464
* 8bpp stretches, 8bpp shrinks and 16bpp stretches ain't perfect but
*   hopefully they're acceptable
* 16bpp shrinks are still broken
*
*    Rev 1.13   07 Oct 1996 09:03:04   RUSSL
* Modified DDRAW_COMPAT_xx conditionally compiled stuff
*
*    Rev 1.12   04 Oct 1996 11:39:10   KENTL
* Fixed PDR#6799 - playing two AVI's result in first window replicated in
* second. Changed the way Blt32 does an x-coordinate computation.
*
*    Rev 1.11   04 Oct 1996 10:46:50   KENTL
* Added fix for 32bpp video bug: we were trying to do stretches in 32bpp,
* which a) is not supported in HW and b) was being interpreted as 16bpp
* which cause really lousy things to happen on the screen.
*
*    Rev 1.9   04 Sep 1996 17:32:06   MARTINB
* Corrected shrink by 8 bug in odd sized mpegs.
* Corrected multiple mpeg sources corrupting working stroage.
*
*    Rev 1.8   22 Aug 1996 10:37:14   MARTINB
* Corrected a number of QFREE check constants for the strech62 routines that
* were causing sound breakup on moving / resizing a video window.
*
*    Rev 1.7   14 Aug 1996 16:53:20   MARTINB
* Yet another last minute fix to the last minute fix. This one fixes
* the banding in 422 video caused by doing the blt twice. The second time
* incorrectly !!
*
*    Rev 1.6   13 Aug 1996 13:25:02   MARTINB
* Moved shrink rejection for 565/8bit formats to correct place in blt32 logic
*
*    Rev 1.5   13 Aug 1996 08:31:12   MARTINB
* Added stretch routines for CL-GD5464 support
* renamed previous stretch logic to DrvStretch62.
*
*    Rev 1.4   23 Jul 1996 11:20:04   KENTL
* Merged in Jeff Orts D3D integration changes.
*   * Created DupZFill()
*   * Added code to do Z-Fill blits.
*
*    Rev 1.3   19 Jul 1996 16:24:38   CRAIGN
* Removed two int 3s that I left in the code.
*
*    Rev 1.2   19 Jul 1996 09:31:20   CRAIGN
* Added workaround for Stretch Bug o' Death.
* Instead of doing SRAM blts to make sure that PTAG is set/reset,
* use a destcopy blt to PTAGFooPixel.  This x/y coordinate is set by the
* display driver to be one pixel below the bottom of the screen (where the
* scratch buffer lives).
*
*    Rev 1.1   15 Jul 1996 16:58:40   RUSSL
* Added support for DirectDraw 3.0
*
*    Rev 1.0   26 Jun 1996 11:05:06   RUSSL
* Initial revision.
*
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/

#include "precomp.h"

// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifndef WINNT_VER40     // Not WINNT_VER40

#include "flip.h"
#include "surface.h"
#include "blt.h"
#include "palette.h"
#include "qmgr.h"
#include "bltP.h"
#include "ddinline.h"
#include "ddshared.h"
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

/*----------------------------- DEFINES -----------------------------------*/

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

// DBGBREAKPOINT();
#define AFPRINTF(n)

#define DBGLVL        1
#define DBGLVL1       1
#define DBGLVL2       1      // DrvSrcBlt & SrvDstBlt
#define DBGLVL3       1      // DrvStretchBlt

#define LGDEVID              ppdev->dwLgDevID
#define OFFSCR_YUV_VAR       ppdev->offscr_YUV
#define MEMCMP(A,B)          memcmp(&ppdev->offscr_YUV.SrcRect, (A),(B))

#define DRAW_ENGINE_BUSY     DrawEngineBusy(lpDDHALData)
#define ENOUGH_FIFO_FOR_BLT  EnoughFifoForBlt(DRIVERDATA* lpDDHALData)
#define SET_GAMMA            SetGamma(PDEV* ppdev, DRIVERDATA* lpDDHALData)
#define UPDATE_FLIP_STATUS(arg)  vUpdateFlipStatus(&ppdev->flipRecord, (arg))

#define DRVSTRETCH64      DrvStretch64(PDEV* ppdev, DRIVERDATA* lpDDHALData,
#define DRVSTRETCH62      DrvStretch62(PDEV* ppdev, DRIVERDATA* lpDDHALData,
#define DUP_COLOR         DupColor(PDEV* ppdev,
#define RGB_RESIZEBOF64   RGBResizeBOF64(PDEV* ppdev, DRIVERDATA* lpDDHALData,
#define RGB_16SHRINKBOF64 RGB16ShrinkBOF64(PDEV* ppdev, DRIVERDATA* lpDDHALData,
#define DUPZFILL          DupZFill(PDEV* ppdev,

#define CALL_ENOUGH_FIFO_FOR_BLT  EnoughFifoForBlt(lpDDHALData)

#define CALL_DELAY_9BIT_BLT(arg)          ppdev->pfnDelay9BitBlt(ppdev,lpDDHALData, (arg))
#define CALL_EDGE_FILL_BLT(A,B,C,D,E,F)   ppdev->pfnEdgeFillBlt(ppdev,lpDDHALData, (A),(B),(C),(D),(E),(F))
#define CALL_MEDGE_FILL_BLT(A,B,C,D,E,F)  ppdev->pfnMEdgeFillBlt(ppdev,lpDDHALData, (A),(B),(C),(D),(E),(F))
#define CALL_DRV_DST_BLT(A,B,C,D)         ppdev->pfnDrvDstBlt(ppdev,lpDDHALData, (A),(B),(C),(D))
#define CALL_DRV_DST_MBLT(A,B,C,D)        ppdev->pfnDrvDstMBlt(ppdev,lpDDHALData, (A),(B),(C),(D))
#define CALL_DRV_SRC_BLT(A,B,C,D,E,F)     ppdev->pfnDrvSrcBlt(ppdev,lpDDHALData, (A),(B),(C),(D),(E),(F))
#define CALL_DRV_STR_BLT(A)               ppdev->pfnDrvStrBlt(ppdev,lpDDHALData, (A))
#define CALL_DRV_STR_MBLT(A)              ppdev->pfnDrvStrMBlt(ppdev,lpDDHALData, (A))
#define CALL_DRV_STR_MBLTX(A)             ppdev->pfnDrvStrMBltX(ppdev,lpDDHALData, (A))
#define CALL_DRV_STR_MBLTY(A)             ppdev->pfnDrvStrMBltY(ppdev,lpDDHALData, (A))
#define CALL_DRV_STR_BLTY(A)              ppdev->pfnDrvStrBltY(ppdev,lpDDHALData, (A))
#define CALL_DRV_STR_BLTX(A)              ppdev->pfnDrvStrBltX(ppdev,lpDDHALData, (A))

#define CALL_DIR_DELAY_9BIT_BLT(arg)          DIR_Delay9BitBlt(ppdev,lpDDHALData, (arg))
#define CALL_DIR_EDGE_FILL_BLT(A,B,C,D,E,F)   DIR_EdgeFillBlt(ppdev,lpDDHALData, (A),(B),(C),(D),(E),(F))
#define CALL_DIR_MEDGE_FILL_BLT(A,B,C,D,E,F)  DIR_MEdgeFillBlt(ppdev,lpDDHALData, (A),(B),(C),(D),(E),(F))
#define CALL_DIR_DRV_DST_BLT(A,B,C,D)         DIR_DrvDstBlt(ppdev,lpDDHALData, (A),(B),(C),(D))
#define CALL_DIR_DRV_STR_BLT(A)               DIR_DrvStrBlt(ppdev,lpDDHALData, (A))
#define CALL_DIR_DRV_STR_MBLT(A)              DIR_DrvStrMBlt(ppdev,lpDDHALData, (A))
#define CALL_DIR_DRV_STR_MBLTX(A)             DIR_DrvStrMBltX(ppdev,lpDDHALData, (A))
#define CALL_DIR_DRV_STR_MBLTY(A)             DIR_DrvStrMBltY(ppdev,lpDDHALData, (A))

#define CALL_DRVSTRETCH64(A,B,C,D,E,F,G,H,I,J,K,L)    DrvStretch64(ppdev,lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L))
#define CALL_DRVSTRETCH62(A,B,C,D,E,F,G,H,I,J,K,L)    DrvStretch62(ppdev,lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L))
#define CALL_DUP_COLOR(A)                             DupColor(ppdev, (A))
#define CALL_RGB_RESIZEBOF64(A,B,C,D,E,F,G,H)    RGBResizeBOF64(ppdev,lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H))
#define CALL_RGB_16SHRINKBOF64(A,B,C,D,E,F,G,H)  RGB16ShrinkBOF64(ppdev,lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H))
#define CALL_DUPZFILL(A,B)                       DupZFill(ppdev, (A),(B))

#define STRETCHCOLOR                                StretchColor(PDEV* ppdev, DRIVERDATA* lpDDHALData,
#define CALL_STRETCHCOLOR(A,B,C,D,E,F,G,H,I)        StretchColor(ppdev,lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I))
#define TRANSPARENTSTRETCH                          TransparentStretch(PDEV* ppdev, DRIVERDATA* lpDDHALData,
#define CALL_TRANSPARENTSTRETCH(A,B,C,D,E,F,G,H,I)  TransparentStretch(ppdev,lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I))

#else   // ----- #elseif WINNT_VER40-----

#define TRACE_STRETCH 1
#define TRACE_ALL     1

#define LGDEVID                   lpDDHALData->dwLgVenDevID
#define OFFSCR_YUV_VAR            offscr_YUV
#define MEMCMP(A,B)               memcmp(&offscr_YUV.SrcRect, (A),(B))

#define ENOUGH_FIFO_FOR_BLT       EnoughFifoForBlt(lpDDHALData)
#define SET_GAMMA                 SetGamma(lpDDHALData)
#define UPDATE_FLIP_STATUS(arg)   updateFlipStatus((arg), lpDDHALData)

#define DRVSTRETCH64              DrvStretch64(
#define DRVSTRETCH62              DrvStretch62(
#define DUP_COLOR                 DupColor(
#define RGB_RESIZEBOF64           RGBResizeBOF64(
#define RGB_16SHRINKBOF64         RGB16ShrinkBOF64(
#define DUPZFILL                  DupZFill(

#define CALL_ENOUGH_FIFO_FOR_BLT              EnoughFifoForBlt(lpDDHALData)
#define CALL_DELAY_9BIT_BLT(arg)              pfnDelay9BitBlt(lpDDHALData,(arg))
#define CALL_EDGE_FILL_BLT(A,B,C,D,E,F)       pfnEdgeFillBlt(lpDDHALData,(A),(B),(C),(D),(E),(F))
#define CALL_MEDGE_FILL_BLT(A,B,C,D,E,F)      pfnMEdgeFillBlt(lpDDHALData,(A),(B),(C),(D),(E),(F))
#define CALL_DRV_DST_BLT(A,B,C,D)             pfnDrvDstBlt(lpDDHALData,(A),(B),(C),(D))
#define CALL_DRV_DST_MBLT(A,B,C,D)            pfnDrvDstMBlt(lpDDHALData,(A),(B),(C),(D))
#define CALL_DRV_SRC_BLT(A,B,C,D,E,F)         pfnDrvSrcBlt(lpDDHALData,(A),(B),(C),(D),(E),(F))
#define CALL_DRV_STR_BLT(A)                   pfnDrvStrBlt(lpDDHALData,(A))
#define CALL_DRV_STR_MBLT(A)                  pfnDrvStrMBlt(lpDDHALData,(A))
#define CALL_DRV_STR_MBLTX(A)                 pfnDrvStrMBltX(lpDDHALData,(A))
#define CALL_DRV_STR_MBLTY(A)                 pfnDrvStrMBltY(lpDDHALData,(A))
#define CALL_DRV_STR_BLTY(A)                  pfnDrvStrBltY(lpDDHALData,(A))
#define CALL_DRV_STR_BLTX(A)                  pfnDrvStrBltX(lpDDHALData,(A))

#define CALL_DIR_DELAY_9BIT_BLT(arg)          DIR_Delay9BitBlt(lpDDHALData,(arg))
#define CALL_DIR_EDGE_FILL_BLT(A,B,C,D,E,F)   DIR_EdgeFillBlt(lpDDHALData,(A),(B),(C),(D),(E),(F))
#define CALL_DIR_MEDGE_FILL_BLT(A,B,C,D,E,F)  DIR_MEdgeFillBlt(lpDDHALData,(A),(B),(C),(D),(E),(F))
#define CALL_DIR_DRV_DST_BLT(A,B,C,D)         DIR_DrvDstBlt(lpDDHALData,(A),(B),(C),(D))
#define CALL_DIR_DRV_STR_BLT(A)               DIR_DrvStrBlt(lpDDHALData,(A))
#define CALL_DIR_DRV_STR_MBLT(A)              DIR_DrvStrMBlt(lpDDHALData,(A))
#define CALL_DIR_DRV_STR_MBLTX(A)             DIR_DrvStrMBltX(lpDDHALData,(A))
#define CALL_DIR_DRV_STR_MBLTY(A)             DIR_DrvStrMBltY(lpDDHALData,(A))

#define CALL_DRVSTRETCH64(A,B,C,D,E,F,G,H,I,J,K,L)    DrvStretch64(lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L))
#define CALL_DRVSTRETCH62(A,B,C,D,E,F,G,H,I,J,K,L)    DrvStretch62(lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L))
#define CALL_DUP_COLOR(A)                             DupColor(lpDDHALData,(A))
#define CALL_RGB_RESIZEBOF64(A,B,C,D,E,F,G,H)         RGBResizeBOF64(lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H))
#define CALL_RGB_16SHRINKBOF64(A,B,C,D,E,F,G,H)       RGB16ShrinkBOF64(lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H))
#define CALL_DUPZFILL(A,B)                            DupZFill(lpDDHALData,(A),(B))

#define STRETCHCOLOR                                StretchColor(
#define CALL_STRETCHCOLOR(A,B,C,D,E,F,G,H,I)        StretchColor(lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I))
#define TRANSPARENTSTRETCH                          TransparentStretch(
#define CALL_TRANSPARENTSTRETCH(A,B,C,D,E,F,G,H,I)  TransparentStretch(lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I))


#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

typedef short DDAX;
typedef struct {DDAX accum; DDAX maj; DDAX min;} AXIS;

#define EDGE_CLIP     // Trim excess pixels from edges (>= 10%) in 8Bpp Mode
#define EDGE_CLIP_16  // Trim excess pixels from edges (>= 10%) in 8Bpp Mode
#define BOGUS_YUV  0x0081 // Top of palette below Windows reserved area
//#define BOGUS_8BIT

#define LOCK_HW_SEMAPHORE()    (lpDDHALData->DrvSemaphore |= DRVSEM_IN_USE)
#define UNLOCK_HW_SEMAPHORE()  (lpDDHALData->DrvSemaphore &= ~ DRVSEM_IN_USE)


/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/
#ifdef WINNT_VER40
static __inline DWORD DUP_COLOR   DWORD dwColor );
#else
static __inline DWORD DUP_COLOR   LPGLOBALDATA lpDDHALData, DWORD dwColor );
#endif
static __inline BOOL ENOUGH_FIFO_FOR_BLT;

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/

/*-------------------------- STATIC VARIABLES -----------------------------*/
static const WORD lncntl[] = {LN_8BIT, LN_RGB565, LN_24PACK, LN_24ARGB,};


// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifndef WINNT_VER40     // Not WINNT_VER40

ASSERTFILE("blt.c");
OFFSCR_YUV  offscr_YUV = {{ 0, 0, 0, 0}, FALSE};

PFN_DELAY9BLT    pfnDelay9BitBlt;
PFN_EDGEFILLBLT  pfnEdgeFillBlt;
PFN_MEDGEFILLBLT pfnMEdgeFillBlt;
PFN_DRVDSTBLT    pfnDrvDstBlt;
PFN_DRVDSTMBLT   pfnDrvDstMBlt;
PFN_DRVSRCBLT    pfnDrvSrcBlt;
PFN_DRVSRCMBLT   pfnDrvSrcMBlt;
PFN_DRVSTRBLT    pfnDrvStrBlt;
PFN_DRVSTRMBLT   pfnDrvStrMBlt;
PFN_DRVSTRMBLTY  pfnDrvStrMBltY;
PFN_DRVSTRMBLTX  pfnDrvStrMBltX;
PFN_DRVSTRBLTY   pfnDrvStrBltY;
PFN_DRVSTRBLTX   pfnDrvStrBltX;

extern PFN_UPDATEFLIPSTATUS pfnUpdateFlipStatus;

#if ENABLE_CLIPPEDBLTS
PFN_CLIPPEDDRVDSTBLT  pfnClippedDrvDstBlt;
PFN_CLIPPEDDRVDSTMBLT pfnClippedDrvDstMBlt;
PFN_CLIPPEDDRVSRCBLT  pfnClippedDrvSrcBlt;
#endif

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>


/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

//***** SetGamma ********************************************************
// Use only for YUV 8BPP
//
#define LOWER_YUV       16
#define UPPER_YUV       240
#define LOWER_PALETTE   0
#define UPPER_PALETTE   255

void SetGamma(PDEV* ppdev, DRIVERDATA* lpDDHALData)
{
  int indx;
  PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;

  DISPDBG((DBGLVL, "DDraw - SetGamma\n"));

  for ( indx = LOWER_PALETTE ; indx <= UPPER_PALETTE ; indx++ )
  { // Initialise gamma palette

    int  value;
    value = ((indx - LOWER_YUV) * UPPER_PALETTE) / (UPPER_YUV - LOWER_YUV);
    if ( value < LOWER_PALETTE )
      value = LOWER_PALETTE;

    if ( value > UPPER_PALETTE )
      value = UPPER_PALETTE;

    LL8(grPalette_Write_Address, (BYTE)(indx));
    LL8(grPalette_Data, (BYTE)(value)); // Red
    LL8(grPalette_Data, (BYTE)(value)); // Grn
    LL8(grPalette_Data, (BYTE)(value)); // Blu
  };
} // SetGamma

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>


/***************************************************************************
*
* FUNCTION:     RGBResizeBOF64
*
* DESCRIPTION:  Handles 8bpp RGB stretches, 8bpp RGB shrinks and
*               16bpp RGB stretches on the 5464
*
****************************************************************************/

#define SRAM_SIZE     128

void RGB_RESIZEBOF64
#ifndef WINNT_VER40
         LPGLOBALDATA lpDDHALData,
#endif
         int xDst, int yDst, int cxDst, int cyDst,
         int xSrc, int ySrc, int cxSrc, int cySrc )
{
  const int nBytesPixel = BYTESPERPIXEL;

  // setting nSRAMPixels to the number of pixels that fit in sram divided
  // by two gives better shrinks at 8bpp and doesn't lock up the chip on
  // stretches at 16bpp
  const int nSRAMPixels = (SRAM_SIZE / nBytesPixel) / 2;
  const int nSRAMMask   = nSRAMPixels - 1;

  autoblt_regs  bltr;

  AXIS  axis[2];
  int   nDst[2];
  int   nSrc[2];
  int   i;

  DDAX  accx;
  int   srcxext;
  int   dstxext;
  int   srcx;
  int   xext;


  DD_LOG(("RGBResizeBOF64 - %d bpp %s in X\r\n", nBytesPixel,
          (cxDst < cxSrc) ? "shrink" : "stretch"));
  DD_LOG(("dst=%08lX dstext=%08lX src=%08lX srcext=%08lX\r\n",
          MAKELONG(xDst,yDst),MAKELONG(cxDst,cyDst),
          MAKELONG(xSrc,ySrc),MAKELONG(cxSrc,cySrc)));

#ifndef WINNT_VER40
  // Verify this is an 8bpp shrink or stretch
  //     or its a 16bpp stretch
  ASSERT((1 == nBytesPixel) || (cxSrc <= cxDst));

  DBG_MESSAGE((" RGBResizeBOF64 - Dst %08lXh,%08lXh  %08lX,%08lX",xDst,yDst,cxDst,cyDst));
  DBG_MESSAGE(("                  Src %08lXh,%08lXh  %08lX,%08lX",xSrc,ySrc,cxSrc,cySrc));
#endif

  // initialize auto blt struct
  bltr.DRAWBLTDEF.DW  = MAKELONG(ROP_OP1_copy, (BD_RES+BD_OP1)*IS_VRAM);

  bltr.OP0_opRDRAM.DW = MAKELONG(LOWORD(xDst),LOWORD(yDst));
  bltr.OP1_opRDRAM.DW = MAKELONG(LOWORD(xSrc),LOWORD(ySrc));
  bltr.BLTEXT.DW      = MAKELONG(LOWORD(cxDst),LOWORD(cyDst));

  bltr.LNCNTL.W       = lncntl[nBytesPixel-1] << LN_YUV_SHIFT;

  bltr.SRCX           = cxSrc * nBytesPixel;

  // Enable interpolation unless we have a palette (8bpp)
  if (1 < nBytesPixel)
    bltr.LNCNTL.W |= (LN_XINTP_EN | LN_YINTP_EN);

  bltr.SHRINKINC.W = 0x0000;

  if (cxDst < cxSrc)
  {
    bltr.LNCNTL.W |= LN_XSHRINK;
    bltr.LNCNTL.W &= ~LN_XINTP_EN;
    bltr.SHRINKINC.pt.X = (cxSrc / cxDst);
  }

  if ( cyDst < cySrc )
  {
    bltr.LNCNTL.W |= LN_YSHRINK;
    bltr.LNCNTL.W &= ~LN_YINTP_EN;
    bltr.SHRINKINC.pt.Y = (cySrc / cyDst);
  }

  // Compute DDA terms.

  nDst[0] = cxDst;
  nDst[1] = cyDst;
  nSrc[0] = cxSrc;
  nSrc[1] = cySrc;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

    if (bltr.LNCNTL.W & ((i==0) ? LN_XINTP_EN : LN_YINTP_EN))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }

    if (bltr.LNCNTL.W & ((i==0) ? LN_XSHRINK : LN_YSHRINK))
    { /* Shrink Terms */
      axis[i].maj   =  (short)nDst[i];
      axis[i].min   = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj   =  kDst * nDst[i];
      axis[i].min   = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }

  bltr.MAJ_X   = axis[0].maj;
  bltr.MIN_X   = axis[0].min;
  bltr.ACCUM_X = axis[0].accum;

  bltr.MAJ_Y   = axis[1].maj;
  bltr.MIN_Y   = axis[1].min;
  bltr.ACCUM_Y = axis[1].accum;

  // write settings that don't vary over stripes to the chip
  CALL_DRV_STR_BLTY(&bltr);

  if (bltr.LNCNTL.W & LN_XSHRINK)
  {
    // 8bpp shrink in X
    accx = bltr.ACCUM_X;

    while (cxDst > 0)
    {
      // walk DDA to determine number of src & dst pixels to blt in
      // current stripe
      // computes error term (accx) for next stripe also
      srcxext = 0;
      dstxext = 0;
      for (;;)
      {
        // check for worst case srcxext larger than num pixels that
        // fit in sram
        if ((srcxext + bltr.SHRINKINC.pt.X + 1) > nSRAMPixels)
          break;

        accx += bltr.MIN_X;
        srcxext += bltr.SHRINKINC.pt.X;
        if (0 > accx)
        {
          accx += bltr.MAJ_X;
          srcxext++;
        }

        dstxext++;
        if (dstxext >= cxDst)
          break;
      }

      // adjust dst extent
      bltr.BLTEXT.pt.X = (USHORT)dstxext;

      // blt current stripe
      CALL_DRV_STR_BLTX(&bltr);

      // adjust dst extent remaining
      cxDst -= dstxext;

      // update auto blt struct settings
      // increment xDst & xSrc
      // store error term for next stripe
      bltr.OP0_opRDRAM.pt.X += (USHORT)dstxext;
      bltr.OP1_opRDRAM.pt.X += (USHORT)srcxext;
      bltr.ACCUM_X          = accx;
    }
  }
  else
  {
    // stretch in X

    // set values for initial stripe
    xext = ((xDst + nSRAMPixels) & (~nSRAMMask)) - xDst;
    accx = bltr.ACCUM_X;
    srcx = xSrc;

    while (cxDst > xext)
    {
      // update auto blt struct settings
      bltr.OP0_opRDRAM.pt.X = (USHORT)xDst;
      bltr.OP1_opRDRAM.pt.X = (USHORT)srcx;
      bltr.ACCUM_X          = accx;
      bltr.BLTEXT.pt.X      = (USHORT)xext;

      // blt current stripe
      CALL_DRV_STR_BLTX(&bltr);

      // increment xDst and decrement remaining dst extent
      xDst  += xext;
      cxDst -= xext;

      // walk DDA to compute error term (accx) and xSrc for next stripe
      for (i = 0; i < xext; i++)
      {
        accx += bltr.MIN_X;
        if (0 > accx)
        {
          accx += bltr.MAJ_X;
          srcx++;
        }
      }
      // set dst ext of current stripe
      xext = nSRAMPixels;
    }

    // if there's some area left to blt, then do it
    if (0 < cxDst)
    {
      // update auto blt struct settings
      bltr.OP0_opRDRAM.pt.X = (USHORT)xDst;
      bltr.OP1_opRDRAM.pt.X = (USHORT)srcx;
      bltr.ACCUM_X          = accx;
      bltr.BLTEXT.pt.X      = (USHORT)cxDst;

      // blt final stripe
      CALL_DRV_STR_BLTX(&bltr);
    }
  }
}

/***************************************************************************
*
* FUNCTION:     RGB16ShrinkBOF64
*
* DESCRIPTION:  Handles 16bpp RGB shrinks on the 5464
*
****************************************************************************/

#define ENABLE_INTERPOLATED_BLTS    1

void RGB_16SHRINKBOF64
#ifndef WINNT_VER40
        LPGLOBALDATA lpDDHALData,
#endif
         int xDst, int yDst, int cxDst, int cyDst,
         int xSrc, int ySrc, int cxSrc, int cySrc )
{
  const int nBytesPixel = BYTESPERPIXEL;
  const int nSRAMPixels = (SRAM_SIZE / nBytesPixel) / 2;
  const int nSRAMMask   = nSRAMPixels - 1;

  autoblt_regs  SrcToScratch;
  autoblt_regs  ScratchToDst;

  int   xScratch, yScratch;
  int   cxScratch, cyScratch;

  AXIS  axis[2];
  int   nDst[2];
  int   nSrc[2];
  int   i;

  DDAX  accx;
  int   srcx;
  int   xext;

  int   nSRAMext;
  int   cxTemp;
  int   xTemp;


  DD_LOG(("RGB16ResizeBOF64 - 16 bpp shrink in X\r\n"));
  DD_LOG(("dst=%08lX dstext=%08lX src=%08lX srcext=%08lX\r\n",
          MAKELONG(xDst,yDst),MAKELONG(cxDst,cyDst),
          MAKELONG(xSrc,ySrc),MAKELONG(cxSrc,cySrc)));

#ifndef WINNT_VER40
  // Verify this is a 16bpp shrink!
  ASSERT(cxSrc > cxDst);
  ASSERT(nBytesPixel == 2);

  DBG_WARNING((" RGB16ShrinkBOF64 - Dst %08lXh,%08lXh  %08lX,%08lX",xDst,yDst,cxDst,cyDst));
  DBG_WARNING(("                    Src %08lXh,%08lXh  %08lX,%08lX",xSrc,ySrc,cxSrc,cySrc));
#endif

  xScratch = LOWORD(lpDDHALData->ScratchBufferOrg);
  yScratch = HIWORD(lpDDHALData->ScratchBufferOrg);
  cyScratch = cyDst;

  // initialize auto blt struct for src to scratch buffer
  SrcToScratch.DRAWBLTDEF.DW  = MAKELONG(ROP_OP1_copy, (BD_RES+BD_OP1)*IS_VRAM);

  SrcToScratch.OP0_opRDRAM.DW = MAKELONG(LOWORD(xScratch),LOWORD(yScratch));
  SrcToScratch.OP1_opRDRAM.DW = MAKELONG(LOWORD(xSrc),LOWORD(ySrc));

  SrcToScratch.LNCNTL.W       = lncntl[nBytesPixel-1] << LN_YUV_SHIFT;

  SrcToScratch.SRCX           = cxSrc * nBytesPixel;

#if ENABLE_INTERPOLATED_BLTS
  // Enable interpolation unless we have a palette (8bpp)
  if (1 < nBytesPixel)
    SrcToScratch.LNCNTL.W |= (LN_XINTP_EN | LN_YINTP_EN);
#endif

  SrcToScratch.SHRINKINC.W = 0x0000;

  // THIS IS A SHRINK IN X!
  cxScratch = cxSrc & ~1;
  nSRAMext = 0x38;
  while (cxScratch > cxDst)
  {
    cxScratch >>= 1;
    nSRAMext >>= 1;
  }
  /* Check for zero extent blt */
  if (nSRAMext == 0)
    return;

  SrcToScratch.BLTEXT.DW      = MAKELONG(LOWORD(cxScratch),1);
  // Yes, the following line doesn't make any sense but using
  // half the dest x ext on a 16bpp rgb shrink to compute the
  // minor, major and initial accumulator terms appears to get
  // the hw to work correctly
  cxScratch /= 2;

  SrcToScratch.LNCNTL.W |= LN_XSHRINK;
#if ENABLE_INTERPOLATED_BLTS
  SrcToScratch.LNCNTL.W &= ~LN_XINTP_EN;
#endif
  SrcToScratch.SHRINKINC.pt.X = (cxSrc / cxScratch);

  if ( cyDst < cySrc )
  {
    SrcToScratch.LNCNTL.W |= LN_YSHRINK;
#if ENABLE_INTERPOLATED_BLTS
    SrcToScratch.LNCNTL.W &= ~LN_YINTP_EN;
#endif
    SrcToScratch.SHRINKINC.pt.Y = (cySrc / cyScratch);
  }

  // Compute DDA terms

  nDst[0] = cxScratch;
  nDst[1] = cyScratch;
  nSrc[0] = cxSrc;
  nSrc[1] = cySrc;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

#if ENABLE_INTERPOLATED_BLTS
    if (SrcToScratch.LNCNTL.W & ((i==0) ? LN_XINTP_EN : LN_YINTP_EN))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }
#endif

    if (SrcToScratch.LNCNTL.W & ((i==0) ? LN_XSHRINK : LN_YSHRINK))
    { /* Shrink Terms */
      axis[i].maj   =  (short)nDst[i];
      axis[i].min   = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj   =  kDst * nDst[i];
      axis[i].min   = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }

  SrcToScratch.MAJ_X   = axis[0].maj;
  SrcToScratch.MIN_X   = axis[0].min;
  SrcToScratch.ACCUM_X = axis[0].accum;

  SrcToScratch.MAJ_Y   = axis[1].maj;
  SrcToScratch.MIN_Y   = axis[1].min;
  SrcToScratch.ACCUM_Y = axis[1].accum;

  // Now that we have the major, minor and initial accumulator terms
  // computed, adjust dest x ext back to full width so we do the full
  // width of the blt below
  cxScratch *= 2;



  // initialize auto blt struct for scratch buffer to dst
  ScratchToDst.DRAWBLTDEF.DW  = MAKELONG(ROP_OP1_copy, (BD_RES+BD_OP1)*IS_VRAM);

  ScratchToDst.OP0_opRDRAM.DW = MAKELONG(LOWORD(xDst),LOWORD(yDst));
  ScratchToDst.OP1_opRDRAM.DW = MAKELONG(LOWORD(xScratch),LOWORD(yScratch));
  ScratchToDst.BLTEXT.DW      = MAKELONG(LOWORD(cxDst),1);

  ScratchToDst.LNCNTL.W       = lncntl[nBytesPixel-1] << LN_YUV_SHIFT;

  ScratchToDst.SRCX           = cxScratch * nBytesPixel;

#if ENABLE_INTERPOLATED_BLTS
  // Enable interpolation unless we have a palette (8bpp)
  if (1 < nBytesPixel)
    ScratchToDst.LNCNTL.W |= (LN_XINTP_EN | LN_YINTP_EN);
#endif

  ScratchToDst.SHRINKINC.W = 0x0000;

  // THIS IS A STRETCH IN X!

  // THIS IS 1:1 IN Y

  // Compute DDA terms

  nDst[0] = cxDst;
  nDst[1] = cyDst;
  nSrc[0] = cxScratch;
  nSrc[1] = cyScratch;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

#if ENABLE_INTERPOLATED_BLTS
    if (ScratchToDst.LNCNTL.W & ((i==0) ? LN_XINTP_EN : LN_YINTP_EN))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }
#endif

    if (ScratchToDst.LNCNTL.W & ((i==0) ? LN_XSHRINK : LN_YSHRINK))
    { /* Shrink Terms */
      axis[i].maj   =  (short)nDst[i];
      axis[i].min   = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj   =  kDst * nDst[i];
      axis[i].min   = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }

  ScratchToDst.MAJ_X   = axis[0].maj;
  ScratchToDst.MIN_X   = axis[0].min;
  ScratchToDst.ACCUM_X = axis[0].accum;

  ScratchToDst.MAJ_Y   = axis[1].maj;
  ScratchToDst.MIN_Y   = axis[1].min;
  ScratchToDst.ACCUM_Y = axis[1].accum;


  // loop over scanlines in dst
  // do two blts for each, one from src to scratch buffer
  //   then one from scratch buffer to dst
  while (0 < cyDst)
  {
    // blt one scanline high from src to scratch buffer

    // set values for initial stripe
    xext = nSRAMext;
    accx = SrcToScratch.ACCUM_X;
    srcx = xSrc;

    // write settings that don't vary over stripes to the chip
    CALL_DRV_STR_BLTY(&SrcToScratch);

    cxTemp = cxScratch;
    xTemp = xScratch;

    while (cxTemp > xext)
    {
      // update auto blt struct settings
      SrcToScratch.OP0_opRDRAM.pt.X = (USHORT)xTemp;
      SrcToScratch.OP1_opRDRAM.pt.X = (USHORT)srcx;
      SrcToScratch.BLTEXT.pt.X      = (USHORT)xext;

      // blt current stripe
      CALL_DRV_STR_BLTX(&SrcToScratch);

      // increment xDst and decrement remaining dst extent
      xTemp  += xext;
      cxTemp -= xext;

      // walk DDA to compute error term (accx) and xSrc for next stripe
      for (i = 0; i < xext; i++)
      {
        SrcToScratch.ACCUM_X += SrcToScratch.MIN_X;
        // Even though the following line should be correct
        // the hw doesn't work correctly so we'll skip it
        // here and adjust srcx after the for loop
        //srcx += SrcToScratch.SHRINKINC.pt.X;
        if (0 > (short)SrcToScratch.ACCUM_X)
        {
          SrcToScratch.ACCUM_X += SrcToScratch.MAJ_X;
          srcx++;
        }
      }
      // now adjust srcx with a bizarre equation that appears to get
      // the hw to work correctly
      srcx += ((nSRAMext / 2) * SrcToScratch.SHRINKINC.pt.X);
    }
    // if there's some area left to blt, then do it
    if (0 < cxTemp)
    {
      // update auto blt struct settings
      SrcToScratch.OP0_opRDRAM.pt.X = (USHORT)xTemp;
      SrcToScratch.OP1_opRDRAM.pt.X = (USHORT)srcx;
      SrcToScratch.BLTEXT.pt.X      = (USHORT)cxTemp;

      // blt final stripe
      CALL_DRV_STR_BLTX(&SrcToScratch);
    }
    // reset ACCUM_X for beginning of next scanline
    SrcToScratch.ACCUM_X = accx;

    // walk Y DDA for src to scratch buffer blt
    SrcToScratch.ACCUM_Y += SrcToScratch.MIN_Y;
    SrcToScratch.OP1_opRDRAM.pt.Y += SrcToScratch.SHRINKINC.pt.Y;
    if (0 > (short)SrcToScratch.ACCUM_Y)
    {
      SrcToScratch.ACCUM_Y += SrcToScratch.MAJ_Y;
      SrcToScratch.OP1_opRDRAM.pt.Y++;
    }


    // blt from scratch buffer to dst
    // stretch in X, 1:1 in Y

    // set values for initial stripe
    xext = ((xDst + nSRAMPixels) & (~nSRAMMask)) - xDst;
    accx = ScratchToDst.ACCUM_X;
    srcx = xScratch;

    // write settings that don't vary over stripes to the chip
    CALL_DRV_STR_BLTY(&ScratchToDst);

    xTemp  = xDst;
    cxTemp = cxDst;

    while (cxTemp > xext)
    {
      // update auto blt struct settings
      ScratchToDst.OP0_opRDRAM.pt.X = (USHORT)xTemp;
      ScratchToDst.OP1_opRDRAM.pt.X = (USHORT)srcx;
      ScratchToDst.BLTEXT.pt.X      = (USHORT)xext;

      // blt current stripe
      CALL_DRV_STR_BLTX(&ScratchToDst);

      // increment xDst and decrement remaining dst extent
      xTemp  += xext;
      cxTemp -= xext;

      // walk DDA to compute error term (accx) and xSrc for next stripe
      for (i = 0; i < xext; i++)
      {
        ScratchToDst.ACCUM_X += ScratchToDst.MIN_X;
        if (0 > (short)ScratchToDst.ACCUM_X)
        {
          ScratchToDst.ACCUM_X += ScratchToDst.MAJ_X;
          srcx++;
        }
      }
      // set dst ext of current stripe
      xext = nSRAMPixels;
    }

    // if there's some area left to blt, then do it
    if (0 < cxTemp)
    {
      // update auto blt struct settings
      ScratchToDst.OP0_opRDRAM.pt.X = (USHORT)xTemp;
      ScratchToDst.OP1_opRDRAM.pt.X = (USHORT)srcx;
      ScratchToDst.BLTEXT.pt.X      = (USHORT)cxTemp;

      // blt final stripe
      CALL_DRV_STR_BLTX(&ScratchToDst);
    }
    // reset ACCUM_X for beginning of next scanline
    ScratchToDst.ACCUM_X = accx;

    // adjust dst ptr and dst extent
    ScratchToDst.OP0_opRDRAM.pt.Y++;
    cyDst--;
  }
}

/****************************************************************************
* FUNCTION NAME: DdGetBltStatus (NT)
*                GetBltStatus32 (Win95)
*
* DESCRIPTION:   Doesn't currently really care what surface is specified,
*                just checks and goes.
****************************************************************************/
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

DWORD DdGetBltStatus(PDD_GETBLTSTATUSDATA lpGetBltStatus)
{
  DRIVERDATA* lpDDHALData;
  PDEV*   ppdev;
  HRESULT ddRVal;

  DISPDBG((DBGLVL, "DDraw - DdGetBltStatus\n"));

  ppdev = (PDEV*) lpGetBltStatus->lpDD->dhpdev;
  lpDDHALData = (DRIVERDATA*) &ppdev->DriverData;

#else   // ----- #elseif WINNT_VER40 -----

DWORD __stdcall GetBltStatus32( LPDDHAL_GETBLTSTATUSDATA lpGetBltStatus)
{
  LPGLOBALDATA lpDDHALData = GetDDHALContext( lpGetBltStatus->lpDD);
  HRESULT ddRVal;
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>


  DD_LOG(("GetBltStatus32 Entry\r\n"));

#ifndef WINNT_VER40
  SyncWithQueueManager(lpDDHALData);
#endif

#ifdef WINNT_VER40
  SYNC_W_3D(ppdev);   // if 3D context(s) active, make sure 3D engine idle before continuing...
#endif

  // DDGBS_CANBLT: can we add a blt?
  ddRVal = DD_OK;
  if (lpGetBltStatus->dwFlags == DDGBS_CANBLT)
  {
    // is a flip in progress?
#ifdef WINNT_VER40
    ddRVal = vUpdateFlipStatus(
        &ppdev->flipRecord,
        lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem);
#else
#if defined(DDRAW_COMPAT_10)
    ddRVal = pfnUpdateFlipStatus(
        lpGetBltStatus->lpDDSurface->lpData->fpVidMem,
        lpDDHALData);
#else
    ddRVal = pfnUpdateFlipStatus(
        lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem,
        lpDDHALData);
#endif
#endif

     if (ddRVal == DD_OK)
     {
        // so there was no flip going on, is there room in the fifo
        // to add a blt?
        if (!CALL_ENOUGH_FIFO_FOR_BLT)
           ddRVal = DDERR_WASSTILLDRAWING;
        else
           ddRVal = DD_OK;
     };
  }
  else
  {
     // DDGBS_ISBLTDONE case: is a blt in progress?
    if (DRAW_ENGINE_BUSY)

       ddRVal = DDERR_WASSTILLDRAWING;
    else
       ddRVal = DD_OK;
  };

  lpGetBltStatus->ddRVal = ddRVal;

  DD_LOG(("GetBltStatus32 Exit\r\n"));

  return(DDHAL_DRIVER_HANDLED);

} // DDGetBltStatus or GetBltStatus32

/***************************************************************************
*
* FUNCTION:     DrvStretch64
*
* DESCRIPTION:
*
****************************************************************************/

void DRVSTRETCH64
#ifndef WINNT_VER40
       LPGLOBALDATA lpDDHALData,
#endif
       int xDst, int yDst, int cxDst, int cyDst,
       int xSrc, int ySrc, int cxSrc, int cySrc,
       int nBytesPixel, int SrcType, int BaseOffset,
       int OnScreen)
{
  int   cxClip = cxDst;
  int   cyClip = cyDst;
  int   cxFill = 0;
  int   cyFill = cyDst;
  int   xFill  = xDst;
  int   yFill  = yDst;
  int   cxTrim = 0;
  int   iratio, i;

#ifdef RDRAM_8BIT
  PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;
#endif

  autoblt_regs bltr;

  AXIS axis[2];
  int  nDst[2];
  int  nSrc[2];

#ifdef RDRAM_8BIT
  RECTL   SrcRectl;
  int     nFound = FALSE;
#endif

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

  DISPDBG((DBGLVL3, "DDraw - DrvStretch64 xD=%x, yD=%x, cxD=%x, cyD=%x, xS=%x, yS=%x, cxS=%x, cyS=%x, bpp=%x, t=%x, bo=%x, scn=%x\n",
           xDst, yDst, cxDst, cyDst,
           xSrc, ySrc, cxSrc, cySrc,
           nBytesPixel, SrcType, BaseOffset, OnScreen));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

  DD_LOG(("DrvStretch64 - dst=%08lX dstext=%08lX src=%08lX srcext=%08lX\r\n",
          MAKELONG(xDst,yDst),MAKELONG(cxDst,cyDst),
          MAKELONG(xSrc,ySrc),MAKELONG(cxSrc,cySrc)));

#ifdef RDRAM_8BIT
  if (!lpDDHALData->fNineBitRDRAMS)
  {
     if (SrcType == LN_YUV422)
     {
        SrcRectl.left   = xSrc;
        SrcRectl.top    = ySrc;
        SrcRectl.right  = xSrc+cxSrc;
        SrcRectl.bottom = ySrc+cySrc;
        if (MEMCMP(&SrcRectl, sizeof(SrcRectl)) == 0)
           nFound = TRUE;

        if (nFound)
        {
#if 0
        DBG_MESSAGE(("Stretch: Found Offscreen Area P1(%x,%x) P2(%x,%x) Dst(%x, %x) Dst(%x %x)\n",
                     SrcRectl.left,
                     SrcRectl.top,
                     SrcRectl.right,
                     SrcRectl.bottom,
                     xDst,
                     yDst,
                     xDst+cxDst,
                     yDst+cyDst));
#endif

           LL16(grX_Start_2, xDst + ((4 - (xDst & 3)) & 3));
           LL16(grY_Start_2, yDst);
           LL16(grX_End_2, xDst+(cxDst>>3<<3));
           LL16(grY_End_2, yDst+cyDst);
        }
        else
        {
#if 0
        DBG_MESSAGE(("Stretch: Not Found Offscreen Area P1(%x,%x) P2(%x,%x)\n",
                     SrcRectl.left,
                     SrcRectl.top,
                     SrcRectl.right,
                     SrcRectl.bottom));
#endif

           LL16(grX_Start_2, 0);
           LL16(grY_Start_2, 0);
           LL16(grX_End_2, 0);
           LL16(grY_End_2, 0);

           // Black Blit Here
           CALL_DRV_DST_BLT(0x107000CC,MAKELONG(xDst,yDst),0,MAKELONG(cxDst,cyDst));
           return ;
        }
     }  // endif (SrcType == LN_YUV422)
  }  // endif (!lpDDHALData->fNineBitRDRAMS)
#endif

#ifdef TRACE_STRETCH
  DBG_MESSAGE(("DrvStretch64: %4d,%4d %4dx%4d -> %4d,%4d %4dx%4d (%d %d) %d",
               xSrc, ySrc, cxSrc, cySrc,
               xDst, yDst, cxDst, cyDst,
               nBytesPixel, SrcType, BaseOffset));
#endif

  if ((SrcType == LN_YUV422) ||
     ((SrcType == LN_RGB565) && (nBytesPixel == 1)))
  { // Force alignment of output to QWORD ( it is documented as DWORD but broken)

    if (nBytesPixel == 2)
    {  // 16 bit frame buffer ( Note all ptrs/extents in terms of 16 bpp )
       // The X portions will be mutiplied by 2 by chip on being written )

       if (cxDst > cxSrc)
          iratio = cxDst / cxSrc; // integer ratio of stretch
       else
          iratio = cxSrc / cxDst; // integer ratio of shrink

       if (xDst & 3)   // This should be for LN_YUV422 only
       {
          cxFill = 4 - (xDst & 3);
          cxTrim = cxFill;   // save trim count for source clipping if required

          if ( cxFill > cxClip )
             cxFill = cxClip;  // check for no stretch left

           cxClip -= cxFill;  // reduce size
           cxDst  -= cxFill;  // reduce size
           xDst   += cxFill;  // force alignment to next even DWORD boundary

           CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                              MAKELONG(BOGUS_YUV, BOGUS_YUV),
                              FALSE);
       }  // endif (xDst & 3)

       cxFill  = cxClip & 3;
       if (OnScreen && cxFill )
       {
          cxClip -= cxFill;   // force size to next smaller even DWORD count
          xFill   = xDst + cxClip;
          if ( cxClip >= cxSrc)
          {  // If shrink defer edge fill to later as there may be more
             CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
          }
       }  // endif ( cxFill )

       if ( (cxClip < cxSrc) )
       {  // Edge Clip on shrinks only ( add config flag check here )

          // extra pixels to discard above integer ratio
          int excess = (cxSrc / iratio) - cxClip;

#ifdef TRACE_STRETCH
         DBG_MESSAGE((" Edge Clip iratio = %d excess = %d Trim %% = %d", iratio, excess, lpDDHALData->EdgeTrim));
#endif

          if ( excess && cxTrim )
          {  // These excess pixels are caused by our Dest alignment
             // problems on the Left edge
             if ( excess < (cxTrim * iratio) )
             {
                cxSrc  -= excess;
                xSrc   += excess;
                excess  = 0;
             }
             else
             {
                cxSrc  -= cxTrim * iratio;
                xSrc   += cxTrim * iratio;
                excess -= cxTrim * iratio;
             }
          }  // endif ( (cxClip < cxSrc) )

         if ( excess && cxFill)
         {  // These excess pixels are caused by our Dest alignment
            // problems on the Right edge

            if ( excess < (cxFill * iratio) )
            {
               cxSrc  -= excess;
               excess  = 0;
            }
            else
            {
               cxSrc  -= cxFill * iratio;
               excess -= cxFill * iratio;
            }
         }  // endif ( excess && cxFill)

         if ( excess && (excess <= (lpDDHALData->EdgeTrim * cxSrc)/100 ))
         {  // if excess is less than % of frame trim edges
            int trim  = excess / 2; // half the excess of pixels
            xSrc     +=  trim;      // offset pixel pointer
            cxSrc    -= excess;     // all the excess in pixels

#ifdef TRACE_STRETCH
            DBG_MESSAGE((" Edge Clip Left = %d, xSrc = %d, cxSrc = %d", trim, xSrc, cxSrc));
#endif
         }

         if ( iratio == 1 )
         {  // we may have just changed a shrink to a 1 : 1
            // if excess is zero do edge fill now

            // extra pixels to discard above integer ratio
            excess = ( cxSrc / iratio ) - cxClip;

            if ( !excess && cxFill )
            {
               xFill = xDst + cxClip;
               CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                  MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
            }
         }  // endif ( iratio == 1 )
       }
       else
       { // Stretch adjustments
         if ( xSrc - BaseOffset )
         {  // if we are not starting from left edge of source image

            if ( cxTrim )
            {  // And we were forced to offset for left edge alignment

#ifdef TRACE_STRETCH
          DBG_MESSAGE((" Edge Trim for stretch iratio = %d , cxTrim = %d xSrc %d", iratio, cxTrim, xSrc));
#endif
               cxSrc -= cxTrim / iratio;
               xSrc  += cxTrim / iratio;
            }
         }
       }  // endif ( (cxClip < cxSrc) )

       // Global adjustments
       if ( xSrc & 1 )   // HW bug workaound for clipping
       {
          xSrc  += 1;    // Align to SRC DWORD Boundary
          cxSrc -= 1;    // Account for smaller size
       }
    }
    else
    {  // 8 Bit frame buffer.
       // Force alignment of output to QWORD ( it is documented as DWORD but broken)

       if ( cxDst >= (cxSrc*2) )
          iratio = cxDst / (2 * cxSrc); // integer ratio of stretch
       else
          iratio = (2 * cxSrc ) / cxDst;  // integer ratio of shrink

       if ( xDst & 7 )   /* This should be for LN_YUV422 only */
       {
          cxFill = 8 - (xDst & 7);

          if ( cxFill > cxClip )
             cxFill   = cxClip;  // check for no stretch left

          cxClip -= cxFill;  // reduce size
          cxDst  -= cxFill;  // reduce size
          xDst   += cxFill;  // force alignment to next even WORD boundary

          CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                             0x00000000, FALSE);
       }  // endif ( xDst & 7 )

      cxFill  = cxClip & 7;

      if (OnScreen && cxFill )
      {
         cxClip -= cxFill;    /* force size to next smaller even DWORD count */

         if ( cxClip >= (cxSrc * 2))
         {  // If shrink defer edge fill to later as there may be more
            xFill = xDst + cxClip;
            CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                               0x00000000, FALSE);
         }
      }  // endif ( cxFill )

      // change pixel pointer to byte pointer
      // taking account of X origin of buffer
      xSrc = BaseOffset + (xSrc - BaseOffset) * 2;

      cxSrc *= 2;  // change pixel count to byte count

#ifdef EDGE_CLIP
      if ( (cxClip < cxSrc) && lpDDHALData->EdgeTrim)
      {  // Edge Clip on shrinks only ( add config flag check here )
         int excess;
         excess = ( cxSrc / iratio ) - cxClip; // extra pixels to discard
                                              // above integer ratio
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

         DISPDBG((DBGLVL1,
                 "DDraw - Edge Clip iratio = %d excess = %d Trim %% = %d",
                 iratio, excess, lpDDHALData->EdgeTrim));

#else   // ----- #elseif WINNT_VER40 -----

         DBG_MESSAGE((" Edge Clip iratio = %d excess = %d Trim %% = %d",
                     iratio, excess, lpDDHALData->EdgeTrim));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

         if ( excess && cxTrim )
         {  // These excess pixels are caused by our Dest alignment
            // problems on the Left edge
            if ( excess < (cxTrim * iratio) )
            {
               cxSrc  -= excess;
               xSrc   += excess;
               excess  = 0;
            }
            else
            {
                cxSrc  -= cxTrim * iratio;
                xSrc   += cxTrim * iratio;
                excess -= cxTrim * iratio;
             }
         }  // endif ( excess && cxTrim )

         if ( excess && cxFill)
         {  // These excess pixels are caused by our Dest alignment
            //  problems on the Right edge

            if ( excess < (cxFill * iratio) )
            {
               cxSrc -= excess;
               excess = 0;
            }
            else
            {
               cxSrc -= cxFill * iratio;
               excess -= cxFill * iratio;
            }
         }  // endif ( excess && cxFill)

         if ( excess && ( excess <= (lpDDHALData->EdgeTrim * cxSrc)/100 ) )
         {  // if excess is less than specific % of frame trim edges
            int trim = excess / 2;  // half the excess as pixels
            xSrc +=  trim;          // offset pixel pointer
            cxSrc -= excess;        // all the excess in bytes

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

            DISPDBG((DBGLVL1,
                     "DDraw - Edge Clip Left = %d, xSrc = %d, cxSrc = %d",
                     trim, xSrc, cxSrc));

#else   // ----- #elseif WINNT_VER40 -----

          DBG_MESSAGE((" Edge Clip Left = %d, xSrc = %d, cxSrc = %d",
                       trim, xSrc, cxSrc));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

         } // endif (excess && ( excess <= (lpDDHALData->EdgeTrim * cxSrc)/100))

         if ( iratio == 1 )
         {  // we may have just changed a shrink to a 1 : 1
            // if excess is no zero do edge fill now

            // extra pixels to discard above integer ratio
            excess = ( cxSrc / iratio ) - cxClip;

            if ( !excess && cxFill )
            {
               xFill = xDst + cxClip;
               CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                  0x00000000, FALSE);
            }
         }  // endif ( iratio == 1 )
      }  // endif ( (cxClip < cxSrc) && lpDDHALData->EdgeTrim)
#endif

      if ( xSrc & 3 )   /* HW bug workaound for clipping */
      {
         cxSrc -= 4 - (xSrc & 3);  /* reduce size */
         xSrc = (xSrc + 3) & ~ 3;    /* Align to SRC DWORD Boundary */
      }
    }  // endif (nBytesPixel == 2)
  }

  if ( cxClip == 0 )
     return;     // discard zero extent stretchs

  if (nBytesPixel == 1 && ((SrcType == LN_YUV422) || (SrcType == LN_RGB565))
     || ((nBytesPixel == 2) && (SrcType == LN_YUV422)))
  {
     CALL_DELAY_9BIT_BLT(FALSE);

     bltr.DRAWBLTDEF.DW   = MAKELONG(0x04CC, BD_RES | BD_OP1);
     lpDDHALData->YUVLeft = (USHORT)xDst;  // Save 9th bit rect coords for main
     lpDDHALData->YUVTop = (USHORT)yDst;   // driver for exclusion purposes.
     lpDDHALData->YUVXExt = (USHORT)cxClip;
     lpDDHALData->YUVYExt = (USHORT)cyClip;

     // tell main driver the rectangle is valid
     lpDDHALData->DrvSemaphore |= DRVSEM_YUV_RECT_VALID;
  }
  else
    bltr.DRAWBLTDEF.DW = MAKELONG(0x00CC, BD_RES | BD_OP1);

  bltr.OP0_opRDRAM.DW  = MAKELONG(xDst, yDst);
  bltr.OP1_opRDRAM.DW  = MAKELONG(xSrc, ySrc);

  bltr.BLTEXT.DW = MAKELONG(cxClip, cyClip);

  bltr.LNCNTL.W  = SrcType << LN_YUV_SHIFT;

  // Enable interpolation unless we have a palette (8bpp).
  if (SrcType != LN_8BIT )
     bltr.LNCNTL.W  |= LN_XINTP_EN | LN_YINTP_EN;

  bltr.SHRINKINC.w = 0x0000;

  if ( cxClip < cxSrc )
  {
     bltr.LNCNTL.W  |= LN_XSHRINK;
     bltr.LNCNTL.W  &= ~LN_XINTP_EN;   // Clear Average bit for ALL shrinks
     bltr.SHRINKINC.pt.X = (cxSrc / cxClip);
  }

  if ( cyDst < cySrc )
  {
     bltr.LNCNTL.W |= LN_YSHRINK;
     bltr.LNCNTL.W &= ~LN_YINTP_EN;
     bltr.SHRINKINC.pt.Y = (cySrc / cyDst);
  }

  if ( SrcType == LN_YUV422 || SrcType == LN_RGB565 )
  {
     if ( nBytesPixel == 1 )
        bltr.SRCX       = (USHORT)cxSrc;  // If mixed mode is *2 already
     else
        bltr.SRCX       = cxSrc * 2;
  }
  else
     bltr.SRCX       = cxSrc * nBytesPixel;

#ifdef TRACE_STRETCH
  DBG_MESSAGE((" cSrc = %d , %d : cDst = %d , %d : cClip = %d , %d",
               cxSrc, cySrc, cxDst, cyDst, cxClip, cyClip));
#endif

  // Compute DDA terms.
  nDst[0] = cxClip; nDst[1] = cyDst;
  nSrc[0] = cxSrc; nSrc[1] = cySrc;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

    if (bltr.LNCNTL.W & ((i==0) ? LN_XINTP_EN : LN_YINTP_EN))
    {
       nDst[i] *= 4;
       nSrc[i] *= 4;
       nSrc[i] -= 3;

       kDst = 0x8000 / nDst[i];
    }

    if (bltr.LNCNTL.W & ((i==0) ? LN_XSHRINK : LN_YSHRINK))
    {  /* Shrink Terms */
       axis[i].maj =  (short)nDst[i];
       axis[i].min = - (nSrc[i] % nDst[i]);
       axis[i].accum = axis[i].maj - 1
                     - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    {  /* Stretch Terms */
       axis[i].maj =  kDst * nDst[i];
       axis[i].min = -kDst * nSrc[i];
       axis[i].accum = axis[i].maj - 1
                     - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  } // endfor

  bltr.MAJ_X   = axis[0].maj;
  bltr.MIN_X   = axis[0].min;
  bltr.ACCUM_X = axis[0].accum;

  bltr.MAJ_Y   = axis[1].maj;
  bltr.MIN_Y   = axis[1].min;
  bltr.ACCUM_Y = axis[1].accum;

  if ( ((SrcType == LN_8BIT) || (SrcType == LN_YUV422))
        && !(bltr.LNCNTL.W & LN_XSHRINK) )
  {
    // Put DDA parameter check/adjust (Optional for 5462/required for 5464)

    const  short maj_x = bltr.MAJ_X;
    const  short min_x = bltr.MIN_X;
    short  xaccum      = bltr.ACCUM_X;
    short  copy_xDst   = bltr.BLTEXT.pt.X;
    short  src_ext;
    short  inc_dx      = 1;
    short  inc_sx      = 0;
    short  SrcDstSz;

    SrcDstSz = ( SrcType == LN_8BIT ) ? 1 : 2 ;

    if ( (bltr.LNCNTL.W & LN_XSHRINK) )
       inc_sx = bltr.SHRINKINC.pt.X;

    inc_sx    *= SrcDstSz;
    inc_dx    *= SrcDstSz;
    copy_xDst *= (short)nBytesPixel;
    src_ext    = SrcDstSz;    // Source size starts with a pixel !!

    do
    { // Step through the X DDA accounting for src pixels consumed
      copy_xDst  -= inc_dx;
      src_ext    += inc_sx;
      xaccum     += min_x;
      if ( xaccum < 0 )
      {
        xaccum   += maj_x;
        src_ext  += SrcDstSz;
      }
    } while ( copy_xDst > 0 );

    bltr.SRCX  = src_ext;

    // End DDA parameter check / adjust.

    CALL_DRV_STR_BLT(&bltr);   // Single stretch

    if ( (SrcType == LN_YUV422) )
       CALL_DELAY_9BIT_BLT(TRUE);
  }
//  else if (SrcType == LN_RGB565 && !(bltr.LNCNTL.W & LN_XSHRINK))
  else if (SrcType == LN_RGB565)
  {
    // HWBUG !!! -- Break into sram-aligned vertical tiles
    // based on destination alignment
    // dword and tile masks

    const int mdwrd =   4 ;
    const int mtile_s = 128 - 1; // sram is 128 bytes
    int mtile_d = 128 - 1 ;      // 5464 Dest Workaround half tile size mask

    int endx  = xDst + cxClip;    // last x, exclusive
    int dstxe = endx & ~mtile_d;  // start of last tile

    int  accx = axis[0].accum;
    int  dstx = xDst;
    int  srcx = xSrc;
    int  src_ext = 0;
    int  sav_accx;
    int  sav_dstx;
    int  sav_srcx;
    int  sav_src_ext;
    int  copy_srcx;
    int  xext;
    int  inc_sx;

#ifndef WINNT_VER40
    ASSERT( BITSPERPIXEL != 24 ); // HWBUG !!!
#endif
    if (bltr.LNCNTL.W & LN_XSHRINK)
    {
       mtile_d = 128 - 1;
       dstxe   = endx & ~mtile_d;
    }

    if ( nBytesPixel == 2 )
    {
       cxSrc *= 2;   /* convert size to Bytes from pixels */
       cxDst *= 2;
       srcx = (xSrc *= 2);
       dstx = (xDst *= 2);
       bltr.OP0_opRDRAM.pt.X *= 2;
       bltr.OP1_opRDRAM.pt.X *= 2;
       endx *= 2;
       dstxe = endx & ~mtile_d;
    }

    if (LGDEVID == CL_GD5464)
    {
       bltr.SHRINKINC.pt.X *= 2;
       CALL_DRV_STR_MBLTY(&bltr);   // Load the invariant registers
       bltr.SHRINKINC.pt.X /= 2;
    }
    else
       CALL_DRV_STR_MBLTY(&bltr);   // Load the invariant registers

    copy_srcx  = bltr.SRCX;

    while (dstx < dstxe)
    {
      bltr.OP0_opRDRAM.PT.X   = (USHORT)dstx;
      bltr.OP1_opRDRAM.PT.X   = (USHORT)srcx;
      bltr.ACCUM_X            = (USHORT)accx;
      xext                    = 0;
      src_ext                 = 0;
      inc_sx                  = bltr.SHRINKINC.pt.X * 2;

      if ( bltr.LNCNTL.W & LN_XSHRINK )
      {  // We have to treat the stretch / shrink cases differently
         // because of the need to handle both SRC & DST aligned cases.
         do
         {
           dstx     += 2;
           xext     += 2;
           accx     += axis[0].min;
           srcx     += inc_sx;
           src_ext  += inc_sx;

           if ( !(srcx & mtile_s) )
              break;    // Try double striping !!

           if (accx < 0)
           {
              accx    += axis[0].maj;
              srcx    += 2;
              src_ext += 2;

              if ( !(srcx & mtile_s) )
                 break;    // Try double striping !!
           }
         } while ((dstx + 4 ) & mtile_d);

         sav_dstx = dstx;
         sav_accx = accx;
         sav_srcx = srcx;
         sav_src_ext = src_ext;

         do
         {
           dstx    += 2;
           xext    += 2;
           accx    += axis[0].min;
           srcx    += inc_sx;
           src_ext += inc_sx;

           if ( !(srcx & mtile_s) )
              break;    // Try double striping !!

           if (accx < 0)
           {
              accx    += axis[0].maj;
              srcx    += 2;
              src_ext += 2;

              if ( !(srcx & mtile_s) )
                 break;    // Try double striping !!
           }
         } while ((dstx) & mtile_d);

         bltr.SRCX  = (USHORT)src_ext;
      }
      else
      {
         do
         {
            dstx += 2;
            xext += 2;
            accx += axis[0].min;

            if (accx < 0)
            {
               accx     += axis[0].maj;
               srcx     += 2;
               src_ext  += 2;

               if ( !(srcx & mtile_s) )
                  break;    // Try double striping !!

            }
         } while (dstx & mtile_d);

         bltr.SRCX = src_ext + 2;
         sav_dstx = dstx;
         sav_accx = accx;
         sav_srcx = srcx;
         sav_src_ext = src_ext;
      }

      bltr.BLTEXT.PT.X = (USHORT)xext;

      CALL_DRV_STR_MBLTX(&bltr);

      dstx = sav_dstx;
      accx = sav_accx;
      srcx = sav_srcx;
      src_ext = sav_src_ext;
      copy_srcx -= src_ext;
    } // end while (dstx < dstxe)

    // do the last tile
    if (dstx < endx)
    {
       bltr.OP0_opRDRAM.PT.X  = (USHORT)dstx;
       bltr.OP1_opRDRAM.PT.X  = (USHORT)srcx;
       bltr.ACCUM_X            = (USHORT)accx;
       bltr.SRCX               = (USHORT)copy_srcx;
       bltr.BLTEXT.PT.X        = endx - dstx;

       CALL_DRV_STR_MBLTX(&bltr);
    }

    if ((SrcType == LN_YUV422) || (SrcType == LN_RGB565 && nBytesPixel == 1))
       CALL_DELAY_9BIT_BLT(TRUE);
  }
  else
  {
    // HWBUG !!! -- Break into sram-aligned vertical tiles
    // based on source alignment
    // tile mask
    const int mtile = 128; /* sram is 128 bytes */
    const int mtile_mask = mtile - 1;
    const short maj_x = bltr.MAJ_X;
    const short min_x = bltr.MIN_X;
    int endx  = xDst + cxClip;  // last x, exclusive, in pixels

    short  xaccum;
    int  dstx = xDst;
    int  srcx = xSrc;
    int  dst_ext;
    int  src_ext;
    int  copy_src_ext;

#ifndef WINNT_VER40
    ASSERT( BITSPERPIXEL != 24 ); // HWBUG !!!
#endif

    if ( nBytesPixel == 2 )
    {
       cxSrc *= 2;   /* convert size to Bytes from pixels */
       cxDst *= 2;
       srcx = (xSrc *= 2);
       dstx = (xDst *= 2);
       bltr.OP0_opRDRAM.pt.X *= 2;
       bltr.OP1_opRDRAM.pt.X *= 2;
       endx *= 2;    /* convert end marker to bytes */
    }

#ifdef TRACE_STRETCH
#ifdef TRACE_ALL
    DBG_MESSAGE((" mtile = %d  maj = %d min = %d accum = %d shrinkinc = %04x",
                 mtile, maj_x, min_x, bltr.ACCUM_X, bltr.SHRINKINC));
#endif
#endif

    if (LGDEVID == CL_GD5464 && SrcType != LN_8BIT)
    {
       bltr.SHRINKINC.pt.X *= 2;
       CALL_DRV_STR_MBLTY(&bltr);   // Load the invariant registers
       bltr.SHRINKINC.pt.X /= 2;
    }
    else
       CALL_DRV_STR_MBLTY(&bltr);   // Load the invariant registers

    do
    {
      // get alignment to first src tile / sram break;
      if ( srcx & mtile_mask ) // initial alignment
      {
        src_ext = mtile  - (srcx & mtile_mask);
        if ( src_ext > cxSrc )
          src_ext = cxSrc;
      }
      else
      {
        if ( cxSrc < mtile )
           src_ext = cxSrc; // last partial tile
        else
           src_ext = mtile; // complete tile
      }

      srcx += src_ext;    // account for amount of src consumed
      cxSrc -= src_ext;

      // calculate how many destination pixels == src_ext
      xaccum  = bltr.ACCUM_X;
      dst_ext = 0;
      copy_src_ext = src_ext;

      do
      {
        dst_ext += 2;
        copy_src_ext -= 2 * bltr.SHRINKINC.pt.X;
        xaccum += min_x;

        if ( xaccum < 0 )
        {
           xaccum += maj_x;
           copy_src_ext -= 2;
        }
      } while ( copy_src_ext > 0 && (dstx + dst_ext <= endx) );

      dst_ext &= ~3;    /* force destination extent to DWORDs */

      dstx += dst_ext;

#ifdef TRACE_STRETCH
#ifdef TRACE_ALL
      DBG_MESSAGE((" srcx = %d src_ext = %d cxSrc = %d dstx = %d dst_ext = %d end = %d",
                   srcx, src_ext, cxSrc, dstx, dst_ext, endx ));
#endif
#endif

      if ( SrcType == LN_RGB565 )
         bltr.SRCX           = src_ext + 2;
      else
         bltr.SRCX           = (USHORT)src_ext;

      bltr.BLTEXT.pt.X      = (USHORT)dst_ext;

      if ( dst_ext > 0 )
         CALL_DRV_STR_MBLTX(&bltr);

      bltr.ACCUM_X        = xaccum;
      bltr.OP0_opRDRAM.pt.X += (USHORT)dst_ext;
      bltr.OP1_opRDRAM.pt.X += (USHORT)src_ext;
    } while ( (dstx < endx) && ( cxSrc > 0));

    xFill = bltr.OP0_opRDRAM.pt.X;

    cxFill  = (xDst + cxDst) - xFill;

#ifdef TRACE_STRETCH
    DBG_MESSAGE((" srcx=%d src_ext=%d cxSrc=%d  dstx=%d dst_ext=%d end=%d xFill=%d cxFill=%d",
                 srcx, src_ext, cxSrc, dstx, dst_ext, endx, xFill, cxFill ));
#endif

    // Edge Fill for trailing edge was deferred. Calculate correct amount
    // Taking into account pixels skipped above for alignment.
    //
    if ((cxFill > 0) && (cxClip = (xFill & 7)) &&
       ((SrcType == LN_YUV422)||((nBytesPixel == 1) && (SrcType == LN_RGB565))))
    {  // these must be extra pixels.  They must be filled using
       //  the same 9th bit and in the same format as the stretch
       if ( SrcType == LN_YUV422  )
          CALL_MEDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                              MAKELONG(BOGUS_YUV, BOGUS_YUV), TRUE);
       else
          CALL_MEDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                              0x00000000, TRUE);

       xFill = bltr.OP0_opRDRAM.pt.X + cxClip;
       cxFill -= cxClip;
    }

    if ((SrcType == LN_YUV422) || (SrcType == LN_RGB565 && nBytesPixel == 1))
        CALL_DELAY_9BIT_BLT(TRUE);

    if ( cxFill > 0 )
    {
      /* perform edge fill Blt */
      if ( nBytesPixel == 2 )
         CALL_MEDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                             MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
     else
         CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                            0x00000000, FALSE);
    }
  }
} // DrvStretch64

/***************************************************************************
*
* FUNCTION:     DrvStretch62
*
* DESCRIPTION:  The 5462 doesn't do display list programming, so
*               all blts must be direct (call the DIR_XXX functions)
*
****************************************************************************/

void DRVSTRETCH62
#ifndef WINNT_VER40
       LPGLOBALDATA lpDDHALData,
#endif
       int xDst, int yDst, int cxDst, int cyDst,
       int xSrc, int ySrc, int cxSrc, int cySrc,
       int nBytesPixel, int SrcType, int BaseOffset,
       int OnScreen)
{
  int   cxClip = cxDst;
  int   cyClip = cyDst;
  int   cxFill = 0;
  int   cyFill = cyDst;
  int   xFill  = xDst;
  int   yFill  = yDst;
  int   cxTrim = 0;
  int   iratio, i;
#ifdef RDRAM_8BIT
  PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;
#endif

  autoblt_regs bltr;

  AXIS axis[2];
  int  nDst[2];
  int  nSrc[2];

#ifdef RDRAM_8BIT
  RECTL   SrcRectl;
  int     nFound = FALSE;
#endif

  DD_LOG(("DrvStretch62 - dst=%08lX dstext=%08lX src=%08lX srcext=%08lX\r\n",
          MAKELONG(xDst,yDst),MAKELONG(cxDst,cyDst),
          MAKELONG(xSrc,ySrc),MAKELONG(cxSrc,cySrc)));

#ifdef RDRAM_8BIT
  if (!lpDDHALData->fNineBitRDRAMS)
  {
     if (SrcType == LN_YUV422)
     {
        SrcRectl.left   = xSrc;
        SrcRectl.top    = ySrc;
        SrcRectl.right  = xSrc+cxSrc;
        SrcRectl.bottom = ySrc+cySrc;

        if (MEMCMP(&SrcRectl, sizeof(SrcRectl)) == 0)
           nFound = TRUE;

        if (nFound)
        {
#if 0
        DBG_MESSAGE(("Stretch: Found Offscreen Area P1(%x,%x) P2(%x,%x) Dst(%x, %x) Dst(%x %x)\n",
                     SrcRectl.left,
                     SrcRectl.top,
                     SrcRectl.right,
                     SrcRectl.bottom,
                     xDst,
                     yDst,
                     xDst+cxDst,
                     yDst+cyDst));
#endif

           LL16(grX_Start_2, xDst + ((4 - (xDst & 3)) & 3));
           LL16(grY_Start_2, yDst);
           LL16(grX_End_2, xDst+(cxDst>>3<<3));
           LL16(grY_End_2, yDst+cyDst);
        }
        else
        {
#if 0
        DBG_MESSAGE(("Stretch: Not Found Offscreen Area P1(%x,%x) P2(%x,%x)\n",
                     SrcRectl.left,
                     SrcRectl.top,
                     SrcRectl.right,
                     SrcRectl.bottom));
#endif

           LL16(grX_Start_2, 0);
           LL16(grY_Start_2, 0);
           LL16(grX_End_2, 0);
           LL16(grY_End_2, 0);

           // Black Blit Here
           CALL_DIR_DRV_DST_BLT(0x107000CC,MAKELONG(xDst,yDst),0,MAKELONG(cxDst,cyDst));
           return ;
        }
     }  // endif (SrcType == LN_YUV422)
  }  // endif (!lpDDHALData->fNineBitRDRAMS)
#endif

#ifdef TRACE_STRETCH
  DBG_MESSAGE(("DrvStretch62: %4d,%4d %4dx%4d -> %4d,%4d %4dx%4d (%d %d) %d",
               xSrc, ySrc, cxSrc, cySrc,
               xDst, yDst, cxDst, cyDst,
               nBytesPixel, SrcType, BaseOffset));
#endif

  if ((SrcType == LN_YUV422) ||
      ((SrcType == LN_RGB565) && (nBytesPixel == 1)))
  { // Force alignment of output to QWORD ( it is documented as DWORD but broken)

    if ( nBytesPixel == 2 )
    {  // 16 bit frame buffer ( Note all ptrs/extents in terms of 16 bpp )
       // The X portions will be mutiplied by 2 by chip on being written )

       if ( cxDst > cxSrc )
          iratio = cxDst / cxSrc; // integer ratio of stretch
       else
          iratio = cxSrc / cxDst; // integer ratio of shrink

       if ( xDst & 3 )   /* This should be for LN_YUV422 only */
       {
          cxFill = 4 - (xDst & 3);
          cxTrim = cxFill;    // save trim count for source clipping if required

          if ( cxFill > cxClip )
            cxFill = cxClip;  // check for no stretch left

          cxClip -= cxFill;  /* reduce size */
          cxDst  -= cxFill;  /* reduce size */
          xDst   += cxFill;  /* force alignment to next even DWORD boundary */

          CALL_DIR_DRV_DST_BLT(MAKELONG(0x0000,BD_RES),MAKELONG(xFill,yFill),
                               0,MAKELONG(cxFill,cyFill));

#ifdef TRACE_STRETCH
        DBG_MESSAGE((" Edge Fill(1) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
      }  //endif ( xDst & 3 )

      cxFill  = cxClip & 3;

      if ( cxFill )
      {
         cxClip -= cxFill;    /* force size to next smaller even DWORD count */
         xFill   = xDst + cxClip;

        if ( cxClip >= cxSrc)
        {  // If shrink defer edge fill to later as there may be more
          CALL_DIR_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                 MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
#ifdef TRACE_STRETCH
          DBG_MESSAGE((" Edge Fill(2) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
        }  // endif ( cxClip >= cxSrc)
      } // endif ( cxFill )

      if ( (cxClip < cxSrc) )
      {  // Edge Clip on shrinks only ( add config flag check here )
         int excess;

         // extra pixels to discard above integer ratio
         excess = ( cxSrc / iratio ) - cxClip;

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

         DISPDBG((DBGLVL1,
                  "DDraw - Edge Clip iratio = %d excess = %d Trim %% = %d",
                  iratio, excess, 2));

#else   // ----- #elseif WINNT_VER40 -----

        DBG_MESSAGE((" Edge Clip iratio = %d excess = %d Trim %% = %d", iratio, excess, 2));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

         if ( excess && cxTrim )
         {  // These excess pixels are caused by our Dest alignment
            // problems on the Left edge
            if ( excess < (cxTrim * iratio) )
            {
               cxSrc  -= excess;
               xSrc   += excess;
               excess  = 0;
            }
            else
            {
               cxSrc  -= cxTrim * iratio;
               xSrc   += cxTrim * iratio;
               excess -= cxTrim * iratio;
            }
         }  // endif ( excess && cxTrim )

         if ( excess && cxFill)
         {  // These excess pixels are caused by our Dest alignment
            //  problems on the Right edge
            if ( excess < (cxFill * iratio) )
            {
               cxSrc -= excess;
               excess = 0;
            }
            else
            {
               cxSrc -= cxFill * iratio;
               excess -= cxFill * iratio;
            }
         }  // endif ( excess < (cxFill * iratio) )

         if ( excess && (excess < (2 * cxClip)/100 ))
         {  // if excess is less than 2% of frame trim edges
            int trim = excess / 2; // half the excess of pixels
            xSrc +=  trim;         // offset pixel pointer
            cxSrc -= excess;       // all the excess in pixels

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

            DISPDBG((DBGLVL1,
                     "DDraw - Edge Clip Left = %d, xSrc = %d, cxSrc = %d",
                     trim, xSrc, cxSrc));

#else   // ----- #elseif WINNT_VER40 -----

          DBG_MESSAGE((" Edge Clip Left = %d, xSrc = %d, cxSrc = %d", trim, xSrc, cxSrc));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>
         }

         if ( iratio == 1 )
         {  // we may have just changed a shrink to a 1 : 1
            // if excess is zero do edge fill now

            // extra pixels to discard above integer ratio
            excess = ( cxSrc / iratio ) - cxClip;

            if ( !excess && cxFill )
            {
               xFill = xDst + cxClip;

               CALL_DIR_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                      MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
#ifdef TRACE_STRETCH
            DBG_MESSAGE((" Edge Fill(7) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
            }
         }  // endif ( iratio == 1 )
      }
      else
      { // Stretch adjustments
        if ( xSrc - BaseOffset )
        { // if we are not starting from left edge of source image

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

          DISPDBG((DBGLVL1,
                   "DDraw - Edge Trim for stretch iratio = %d , cxTrim = %d xSrc %d",
                   iratio, cxTrim, xSrc));

#else   // ----- #elseif WINNT_VER40 -----

          DBG_MESSAGE((" Edge Trim for stretch iratio = %d , cxTrim = %d xSrc %d", iratio, cxTrim, xSrc));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

          if ( cxTrim )
          {  // And we were forced to offset for left edge alignment
             cxSrc  -= cxTrim / iratio;
             xSrc += cxTrim / iratio;
          }
        }
      }  // endif ( (cxClip < cxSrc) )

      // Global adjustments
      if ( xSrc & 1 )   /* HW bug workaound for clipping */
      {
         xSrc += 1;    /* Align to SRC DWORD Boundary */
         cxSrc -= 1;   /* Account for smaller size */
      }
    }
    else
    { // 8 Bit frame buffer.
      // Force alignment of output to QWORD ( it is documented as DWORD but broken)

      if ( cxDst >= (cxSrc*2) )
         iratio = cxDst / (2 * cxSrc); // integer ratio of stretch
      else
         iratio = (2 * cxSrc ) / cxDst;  // integer ratio of shrink

      if ( xDst & 7 )   /* This should be for LN_YUV422 only */
      {
         cxFill = 8 - (xDst & 7);

         if ( cxFill > cxClip )
            cxFill = cxClip;  // check for no stretch left

         cxClip -= cxFill;  /* reduce size */
         cxDst  -= cxFill;  /* reduce size */
         xDst   += cxFill;  /* force alignment to next even WORD boundary */

         CALL_DIR_DRV_DST_BLT(MAKELONG(0x0000,BD_RES),MAKELONG(xFill,yFill),
                              0,MAKELONG(cxFill,cyFill));
#ifdef TRACE_STRETCH
        DBG_MESSAGE((" Edge Fill(3) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
      }  // endif ( xDst & 7 )

      cxFill  = cxClip & 7;

      if ( cxFill )
      {
         cxClip -= cxFill;    /* force size to next smaller even DWORD count */
         if ( cxClip >= (cxSrc * 2))
         { // If shrink defer edge fill to later as there may be more

           xFill  = xDst + cxClip;

#ifdef BOGUS_8BIT
           CALL_DIR_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                  MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
#else
           CALL_DIR_DRV_DST_BLT(MAKELONG(0x0000,BD_RES),MAKELONG(xFill,yFill),
                                0,MAKELONG(cxFill,cyFill));
#endif

#ifdef TRACE_STRETCH
          DBG_MESSAGE((" Edge Fill(4) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
         }
      } // endif ( cxFill )

      // change pixel pointer to byte pointer
      // taking account of X origin of buffer
      xSrc = BaseOffset + (xSrc - BaseOffset) * 2;

      cxSrc *= 2;     /* change pixel count to byte count */

#ifdef EDGE_CLIP
      if ( (cxClip < cxSrc) && lpDDHALData->EdgeTrim)
      {  // Edge Clip on shrinks only ( add config flag check here )
         int excess;

         // extra pixels to discard above integer ratio
         excess = ( cxSrc / iratio ) - cxClip;

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

         DISPDBG((DBGLVL1,
                  "DDraw - Edge Clip iratio = %d excess = %d Trim %% = %d",
                  iratio, excess, lpDDHALData->EdgeTrim));

#else   // ----- #elseif WINNT_VER40 -----

        DBG_MESSAGE((" Edge Clip iratio = %d excess = %d Trim %% = %d",
                     iratio, excess, lpDDHALData->EdgeTrim));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

         if ( excess && cxTrim )
         {  // These excess pixels are caused by our Dest alignment
            // problems on the Left edge
            if ( excess < (cxTrim * iratio) )
            {
               cxSrc  -= excess;
               xSrc   += excess;
               excess  = 0;
            }
            else
            {
               cxSrc  -= cxTrim * iratio;
               xSrc   += cxTrim * iratio;
               excess -= cxTrim * iratio;
            }
         }  // endif ( excess && cxTrim )

         if ( excess && cxFill)
         {  // These excess pixels are caused by our Dest alignment
            //  problems on the Right edge

            if ( excess < (cxFill * iratio) )
            {
               cxSrc -= excess;
               excess = 0;
            }
            else
            {
               cxSrc -= cxFill * iratio;
               excess -= cxFill * iratio;
            }
         }  // endif ( excess && cxFill)

        if ( excess && ( excess < (lpDDHALData->EdgeTrim * cxClip)/100 ) )
        {  // if excess is less than specific % of frame trim edges
           int trim = excess / 2;  // half the excess as pixels
           xSrc  +=  trim;      // offset pixel pointer
           cxSrc -= excess;    // all the excess in bytes

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

           DISPDBG((DBGLVL1,
                    "DDraw - Edge Clip Left = %d, xSrc = %d, cxSrc = %d",
                    trim, xSrc, cxSrc));

#else   // ----- #elseif WINNT_VER40 -----

          DBG_MESSAGE((" Edge Clip Left = %d, xSrc = %d, cxSrc = %d",
                       trim, xSrc, cxSrc));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>
        }

        if ( iratio == 1 )
        { // we may have just changed a shrink to a 1 : 1
          // if excess is no zero do edge fill now

          // extra pixels to discard above integer ratio
          excess = ( cxSrc / iratio ) - cxClip;

          if ( !excess && cxFill )
          {
             xFill = xDst + cxClip;

#ifdef BOGUS_8BIT
             CALL_DIR_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                    MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
#else
             CALL_DIR_DRV_DST_BLT(MAKELONG(0x0000,BD_RES),MAKELONG(xFill,yFill),
                                  0,MAKELONG(cxFill,cyFill));
#endif
#ifdef TRACE_STRETCH
            DBG_MESSAGE((" Edge Fill(6) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
          }  // endif ( !excess && cxFill )
        }  // endif ( iratio == 1 )
      } // endif ( (cxClip < cxSrc) && lpDDHALData->EdgeTrim)
#endif

      if ( xSrc & 3 )   /* HW bug workaound for clipping */
      {
         cxSrc -= 4 - (xSrc & 3);      // reduce size
         xSrc   = (xSrc + 3) & ~ 3;    // Align to SRC DWORD Boundary
      }
    }  // endif ( nBytesPixel == 2 )
  }

  if ( cxClip == 0 )
     return;     // discard zero extent stretchs

  if ( nBytesPixel == 1 &&
       ((SrcType == LN_YUV422) || (SrcType == LN_RGB565 )) ||
       ((nBytesPixel == 2) && (SrcType == LN_YUV422) ) )
  {
     /* This is to ensure that the last packet of any previous blt */
     /* does no go out with 9th bit set */

     CALL_DIR_DELAY_9BIT_BLT(FALSE);

     bltr.DRAWBLTDEF.DW   = MAKELONG(0x04CC, BD_RES | BD_OP1);
     lpDDHALData->YUVLeft = (USHORT)xDst;  // Save 9th bit rect coords for main
     lpDDHALData->YUVTop  = (USHORT)yDst;   // driver for exclusion purposes.
     lpDDHALData->YUVXExt = (USHORT)cxClip;
     lpDDHALData->YUVYExt = (USHORT)cyClip;

     // tell main driver the rectangle is valid
     lpDDHALData->DrvSemaphore |= DRVSEM_YUV_RECT_VALID;
  }
  else
     bltr.DRAWBLTDEF.DW  = MAKELONG(0x00CC, BD_RES | BD_OP1);

  bltr.OP0_opRDRAM.DW  = MAKELONG(xDst, yDst);
  bltr.OP1_opRDRAM.DW  = MAKELONG(xSrc, ySrc);

  bltr.BLTEXT.DW = MAKELONG(cxClip, cyClip);

  bltr.LNCNTL.W  = SrcType << LN_YUV_SHIFT;

  // Enable interpolation unless we have a palette (8bpp).
  if (SrcType != LN_8BIT )
     bltr.LNCNTL.W    |= LN_XINTP_EN | LN_YINTP_EN;

  bltr.SHRINKINC.w = 0x0000;

  if ( cxClip < cxSrc )
  {
     bltr.LNCNTL.W   |= LN_XSHRINK;
     bltr.LNCNTL.W   &= ~LN_XINTP_EN;
     bltr.SHRINKINC.pt.X = (cxSrc / cxClip);
  }

  if ( cyDst < cySrc )
  {
     bltr.LNCNTL.W   |= LN_YSHRINK;
     bltr.LNCNTL.W   &= ~LN_YINTP_EN;
     bltr.SHRINKINC.pt.Y = (cySrc / cyDst);
  }

  if ( SrcType == LN_YUV422 || SrcType == LN_RGB565 )
  {
    if ( nBytesPixel == 1 )
      bltr.SRCX  = (USHORT)cxSrc;  // If mixed mode is *2 already
    else
      bltr.SRCX = cxSrc * 2;
  }
  else
    bltr.SRCX   = cxSrc * nBytesPixel;

#ifdef TRACE_STRETCH
  DBG_MESSAGE((" cSrc = %d , %d : cDst = %d , %d : cClip = %d , %d",
               cxSrc, cySrc, cxDst, cyDst, cxClip, cyClip));
#endif

  // Compute DDA terms.
  nDst[0] = cxClip; nDst[1] = cyDst;
  nSrc[0] = cxSrc; nSrc[1] = cySrc;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

    if (bltr.LNCNTL.W & ((i==0) ? LN_XINTP_EN : LN_YINTP_EN))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }

    if (bltr.LNCNTL.W & ((i==0) ? LN_XSHRINK : LN_YSHRINK))
    { /* Shrink Terms */
      axis[i].maj =  (short)nDst[i];
      axis[i].min = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj =  kDst * nDst[i];
      axis[i].min = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }  // endfor (i = 0; i < 2; i++)

  bltr.MAJ_X   = axis[0].maj;
  bltr.MIN_X   = axis[0].min;
  bltr.ACCUM_X = axis[0].accum;

  bltr.MAJ_Y   = axis[1].maj;
  bltr.MIN_Y   = axis[1].min;
  bltr.ACCUM_Y = axis[1].accum;

  if ((SrcType == LN_8BIT) ||
      ((SrcType == LN_YUV422) && !(bltr.LNCNTL.W & LN_XSHRINK)) )
  {
     CALL_DIR_DRV_STR_BLT(&bltr);   // Single stretch

     if ( (SrcType == LN_YUV422) )
     {
        // This is to ensure that the last packet of blt does no go out with
        // 9th bit clear  It is cheaper than waiting, especially on single
        // stripe BLTs

        CALL_DIR_DELAY_9BIT_BLT(TRUE);
     }
  }
  else if (SrcType == LN_RGB565 && !(bltr.LNCNTL.W & LN_XSHRINK))
#if 1
  {
    // HWBUG !!! -- Break into sram-aligned vertical tiles
    // based on destination alignment
    // dword and tile masks

    const int mdwrd =   4 ;
    const int tile = 128 ; /* sram is 128 bytes */
    const int mtile = 128 - 1 ; /* sram is 128 bytes */

    int endx  = xDst + cxClip;  // last x, exclusive
    int dstxe = endx & ~mtile;  // start of last tile

    DDAX accx = axis[0].accum;
    int  dstx = xDst;
    int  srcx = xSrc;
    int  src_ext = 0;
    int  xext;

#ifndef WINNT_VER40
    ASSERT( BITSPERPIXEL != 24 ); // HWBUG !!!
#endif

    if ( nBytesPixel == 2 )
    {
       cxSrc *= 2;   /* convert size to Bytes from pixels */
       cxDst *= 2;
       srcx = (xSrc *= 2);
       dstx = (xDst *= 2);
       bltr.OP0_opRDRAM.pt.X *= 2;
       bltr.OP1_opRDRAM.pt.X *= 2;