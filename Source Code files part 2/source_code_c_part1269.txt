default:
                hr = LDAP_LOCAL_ERROR;
            }

        } else {

            buffer = (PWCHAR) ldapMalloc( (required + 1) * sizeof(WCHAR), LDAP_VALUE_SIGNATURE );

            if (buffer == NULL) {

                hr = LDAP_NO_MEMORY;

            } else {

                if (m_CodePage == CP_UTF8) {

                    err = LdapUTF8ToUnicode( (const char *) (m_pbData + m_iCurrPos),
                                         cb,
                                         buffer,
                                         (required + 1) * sizeof(WCHAR) );
                } else {

                    err = MultiByteToWideChar( m_CodePage,
                                               0,
                                               (const char *) (m_pbData + m_iCurrPos),
                                               cb,
                                               buffer,
                                               (required + 1) * sizeof(WCHAR) );
                }
                
                if ((err == 0) && (GetLastError())){

                    IF_DEBUG(BER) {
                        LdapPrint1( "HrGetValue received error of 0x%x from MultiByteToWideChar.\n",
                                        err );
                    }

                    switch (err) {
                    case ERROR_INSUFFICIENT_BUFFER:
                        hr = E_INVALIDARG;
                        break;
                    case ERROR_NO_UNICODE_TRANSLATION:
                        hr = LDAP_DECODING_ERROR;
                        break;
                    default:
                        hr = LDAP_LOCAL_ERROR;
                    }
                }

                *(buffer+required) = L'\0';
                *szValue = buffer;
                m_iCurrPos += cb;
            }
        }
    }

    if (hr != NOERROR) {
        m_iCurrPos = currentOffset;
    }
    return hr;
}


ULONG CLdapBer::HrGetValueWithAlloc(struct berval **pValue, BOOLEAN IgnoreTag/*=FALSE*/) 
{
    ULONG hr;
    ULONG   cb;
    PCHAR   buffer;
    struct berval *bval;
    ULONG currentOffset = m_iCurrPos;

    *pValue = NULL;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValueWithAlloc ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    if ( !IgnoreTag ) {
        
        if (m_pbData[m_iCurrPos] != BER_OCTETSTRING) {

            IF_DEBUG(BER) {
                LdapPrint1( "HrGetValueWithAlloc got tag of 0x%x.\n",
                            m_pbData[m_iCurrPos] );
            }
            return LDAP_DECODING_ERROR;
        }

    }
        
    m_iCurrPos++;          // skip tag

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValueWithAlloc ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        m_iCurrPos = currentOffset;
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength(&cb);

    if ((hr == NOERROR) && (m_iCurrPos < m_cbData)) {

        bval = (struct berval *) ldapMalloc( sizeof(struct berval) + cb + 1,
                                             LDAP_VALUE_SIGNATURE );

        if (bval == NULL) {

            hr = LDAP_NO_MEMORY;

        } else {

            buffer = ((PCHAR) bval) + sizeof(struct berval);
            bval->bv_len = cb;
            bval->bv_val = buffer;

            // Get the string.
            CopyMemory(buffer, m_pbData + m_iCurrPos, cb);
            *(buffer+cb) = '\0';
            *pValue = bval;
            m_iCurrPos += cb;
        }
    }

    if (hr != NOERROR) {
        m_iCurrPos = currentOffset;
    }
    return hr;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrGetValue
        This routine gets a string value from the current BER entry.  If
        the current BER entry isn't an integer type, then E_INVALIDARG is
        returned.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrGetValue(CHAR *szValue, ULONG cbValue, ULONG ulTag/*=BER_OCTETSTRING*/, BOOLEAN IgnoreTag/*=FALSE*/) 
{
    ULONG hr;
    ULONG   cb, ul;
    ULONG currentOffset = m_iCurrPos;

    szValue[0] = '\0';

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValue ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    ul = (ULONG)m_pbData[m_iCurrPos]; // TAG

    if (!IgnoreTag && (ul != ulTag)) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValue expected tag of 0x%x, received 0x%x.\n",
                        ulTag, ul );
        }
        return E_INVALIDARG;
    }

    m_iCurrPos++;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValue ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        m_iCurrPos = currentOffset;
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength(&cb);

    if ((hr == NOERROR) && (m_iCurrPos < m_cbData)) {

        if (m_CodePage == CP_UTF8) {

            PWCHAR uniString = NULL;

            hr = ToUnicodeWithAlloc( (PCHAR)(m_pbData + m_iCurrPos),
                                     cb,
                                     &uniString,
                                     LDAP_UNICODE_SIGNATURE,
                                     LANG_UTF8 );

            if (hr == NOERROR) {

                ULONG chars = LdapUnicodeToUTF8( uniString,
                                                 -1,
                                                 szValue,
                                                 cbValue
                                                 );

                hr = ((chars > 0) ? NOERROR : LDAP_NO_MEMORY);
            }
            ldapFree( uniString, LDAP_UNICODE_SIGNATURE );

        } else {

            if (cb >= cbValue) {

                ASSERT(cb < cbValue);
                hr = E_INVALIDARG;

            } else {

                // Get the string.
                CopyMemory(szValue, m_pbData + m_iCurrPos, cb);
                szValue[cb] = '\0';
                m_iCurrPos += cb;
            }
        }
    }

    if (hr != NOERROR) {
        m_iCurrPos = currentOffset;
    }

    return hr;
}

/*!-------------------------------------------------------------------------
    CLdapBer::HrGetValue
        This routine gets a string value from the current BER entry.  If
        the current BER entry isn't an integer type, then E_INVALIDARG is
        returned.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrGetValue(WCHAR *szValue, ULONG cbValue, ULONG ulTag/*=BER_OCTETSTRING*/, BOOLEAN IgnoreTag/*=FALSE*/)
{
    ULONG hr;
    ULONG   cb, ul;
    ULONG currentOffset = m_iCurrPos;

    szValue[0] = '\0';

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValue ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    ul = (ULONG)m_pbData[m_iCurrPos]; // TAG

    if (!IgnoreTag && (ul != ulTag)) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValue expected tag of 0x%x, received 0x%x.\n",
                        ulTag, ul );
        }
        return E_INVALIDARG;
    }

    m_iCurrPos++;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetValue ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        m_iCurrPos = currentOffset;
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength(&cb);

    if ((hr == NOERROR) && (m_iCurrPos < m_cbData)) {

        if (cb >= cbValue) {

            hr = E_INVALIDARG;

        } else {

            int required;

            if (m_CodePage == CP_UTF8) {

                required = LdapUTF8ToUnicode( (const char *) (m_pbData + m_iCurrPos),
                                          cb,
                                          NULL,
                                          0 );

            } else {

                required = MultiByteToWideChar( m_CodePage,
                                                0,
                                                (const char *) (m_pbData + m_iCurrPos),
                                                cb,
                                                NULL,
                                                0 );
            }

            if (required * sizeof(WCHAR) > cbValue) {

                hr = E_INVALIDARG;

            } else {

                ULONG wChars = cbValue / sizeof(WCHAR);
                int err;

                if (m_CodePage == CP_UTF8) {

                    err = LdapUTF8ToUnicode( (const char *) (m_pbData + m_iCurrPos),
                                         cb,
                                         szValue,
                                         wChars );
                } else {

                    err = MultiByteToWideChar( m_CodePage,
                                               0,
                                               (const char *) (m_pbData + m_iCurrPos),
                                               cb,
                                               szValue,
                                               wChars );
                }
                if (err == 0) {

                    err = GetLastError();

                    IF_DEBUG(BER) {
                        LdapPrint1( "HrGetValue received error of 0x%x from MultiByteToWideChar.\n",
                                        err );
                    }

                    switch (err) {
                    case ERROR_INSUFFICIENT_BUFFER:
                        hr = E_INVALIDARG;
                        break;
                    case ERROR_NO_UNICODE_TRANSLATION:
                        hr = LDAP_DECODING_ERROR;
                        break;
                    default:
                        hr = LDAP_LOCAL_ERROR;
                    }
                } else {

                    szValue[err] = L'\0';
                }

                szValue[wChars-1] = L'\0';
                m_iCurrPos += cb;
            }
        }
    }

    if (hr != NOERROR) {

        m_iCurrPos = currentOffset;
    }

    return hr;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrGetBinaryValue
        This routine gets a binary value from the current BER entry.  If
        the current BER entry isn't the right type, then E_INVALIDARG is
        returned.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrGetBinaryValue(BYTE *pbBuf, ULONG cbBuf,
                                   ULONG ulTag/*=BER_OCTETSTRING*/, PULONG pcbLength)
{
    ULONG hr;
    ULONG   cb, ul;
    ULONG currentOffset = m_iCurrPos;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetBinaryValue ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    ul = (ULONG)m_pbData[m_iCurrPos]; // TAG

    if (ul != ulTag)
    {
        IF_DEBUG(BER) {
            LdapPrint2( "HrGetBinaryValue expected tag of 0x%x, received 0x%x.\n",
                        ulTag, ul );
        }
        return E_INVALIDARG;
    }

    m_iCurrPos++;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetBinaryValue ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        m_iCurrPos = currentOffset;
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength(&cb);

    if ((hr == NOERROR) && (m_iCurrPos < m_cbData)) {

        if (cb >= cbBuf)
        {
            ASSERT(cb < cbBuf);
            hr = E_INVALIDARG;
        }
        else
        {
            // Get the string.
            CopyMemory(pbBuf, m_pbData + m_iCurrPos, cb);
            m_iCurrPos += cb;
            if ( pcbLength ) {
                *pcbLength = cb;
            }
        }
    }

    if (hr != NOERROR) {
        m_iCurrPos = currentOffset;
    }

    return hr;
}

/*!-------------------------------------------------------------------------
    CLdapBer::HrGetBinaryValuePointer
        This routine gets a pointer to a binary value from the current BER entry.
        If the current BER entry isn't the right type, then E_INVALIDARG is
        returned.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrGetBinaryValuePointer(PBYTE *ppbBuf, PULONG pcbBuf, ULONG ulTag/*=BER_OCTETSTRING*/, BOOLEAN IgnoreTag/*=FALSE*/)
{
    ULONG hr;
    ULONG   cb, ul;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetBinaryValuePointer ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    ul = (ULONG)m_pbData[m_iCurrPos]; // TAG

    if (!IgnoreTag && (ul != ulTag)) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetBinaryValue expected tag of 0x%x, received 0x%x.\n",
                        ulTag, ul );
        }
        return E_INVALIDARG;
    }

    m_iCurrPos++;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetBinaryValuePointer ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength(&cb);

    if ((hr == NOERROR) && (m_iCurrPos < m_cbData))
    {
        // Set the pointer.
        *ppbBuf = m_pbData + m_iCurrPos;
        *pcbBuf = cb;
        m_iCurrPos += cb;
    }

    return hr;
}

/*!-------------------------------------------------------------------------
    CLdapBer::HrGetEnumValue
        This routine gets an enumerated value from the current BER entry.  If
        the current BER entry isn't an enumerated type, then E_INVALIDARG is
        returned.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrGetEnumValue(LONG *pi)
{
    ULONG   hr;
    ULONG   cb;
    ULONG   ul;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetEnumValue ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    ul = (ULONG)m_pbData[m_iCurrPos]; // TAG

    if (ul != BER_ENUMERATED) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetEnumValue expected tag of 0x%x, received 0x%x.\n",
                        BER_ENUMERATED, ul );
        }
        return E_INVALIDARG;
    }

    m_iCurrPos++;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetEnumValue ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength(&cb);

    if ((hr == NOERROR) && (m_iCurrPos < m_cbData))
    {
        hr = GetInt(m_pbData + m_iCurrPos, cb, pi);
        m_iCurrPos += cb;
    }

    return hr;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrGetStringLength
        This routine gets the length of the current BER entry, which is
        assumed to be a string.  If the current BER entry's tag doesn't
        match ulTag, E_INVALIDARG is returned
  ------------------------------------------------------------------------*/
ULONG
CLdapBer::HrGetStringLength(int *pcbValue, ULONG ulTag)
{
    ULONG   ul;
    int     iCurrPosSave = m_iCurrPos;
    ULONG   hr;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetStringLength ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    ul = (ULONG)m_pbData[m_iCurrPos]; // TAG

    if (ul != ulTag) {
        IF_DEBUG(BER) {
            LdapPrint2( "HrGetStringLength expected tag of 0x%x, received 0x%x.\n",
                        ulTag, ul );
        }
        return E_INVALIDARG;
    }

    m_iCurrPos++;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetStringLength ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength((ULONG *)pcbValue);
    m_iCurrPos = iCurrPosSave;
    return hr;
}

/*!-------------------------------------------------------------------------
    CLdapBer::HrAddValue
        This routine puts an integer value in the BER buffer.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrAddValue(LONG i, ULONG ulTag/*=BER_INTEGER*/)
{
    ULONG hr;
    ULONG   cbInt;
    DWORD   dwMask = 0xff000000;
    DWORD   dwHiBitMask = 0x80000000;


    if (m_OverridingTag) {

       ulTag = m_OverridingTag;
       m_OverridingTag = 0;
    }

    if (i == 0)
    {
        cbInt = 1;
    }
    else
    {
        cbInt = sizeof(LONG);
        while (dwMask && !(i & dwMask))
        {
            dwHiBitMask >>= 8;
            dwMask >>= 8;
            cbInt--;
        }
        if (!(i & 0x80000000)) {

            //
            //  the value to insert was a positive number, make sure we allow
            //  for it by sending an extra bytes since it's not negative.
            //

            if (i & dwHiBitMask) {
                cbInt++;
            }

        }
    }

    hr = HrEnsureBuffer(1 + 5 + cbInt); // 1 for tag, 5 for length
    if (hr != 0) {
        return hr;
    }

    m_pbData[m_iCurrPos++] = (BYTE)ulTag;

    hr = HrSetLength(cbInt);
    if (hr == NOERROR) {

        AddInt(m_pbData + m_iCurrPos, cbInt, i);

        m_iCurrPos += cbInt;

        m_cbData = m_iCurrPos;
    }

    return hr;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrAddValue
        Puts a string into the BER buffer.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrAddValue(const CHAR *szValue, ULONG ulTag)
{
    ULONG   hr;
    ULONG   cbValue;
    CHAR   nullStr = '\0';
    PWCHAR uniString = NULL;
    ULONG wLength = 0;

    if (m_OverridingTag) {

       ulTag = m_OverridingTag;
       m_OverridingTag = 0;
    }

    if (szValue == NULL) {

        szValue = &nullStr;
    }

    cbValue = (ULONG) strlen(szValue);

    if ((m_CodePage == CP_UTF8) && (cbValue > 0)) {

        hr = ToUnicodeWithAlloc( (PCHAR) szValue,
                                 cbValue,
                                 &uniString,
                                 LDAP_UNICODE_SIGNATURE,
                                 LANG_ACP );

        if (hr != NOERROR) {

            return hr;
        }

        wLength = strlenW( uniString );

        cbValue = LdapUnicodeToUTF8( uniString,
                                     wLength,
                                     NULL,
                                     0 );

        if (cbValue == 0) {

            ldapFree( uniString, LDAP_UNICODE_SIGNATURE );
            return LDAP_NO_MEMORY;
        }
    }

    hr = HrEnsureBuffer(1 + 5 + cbValue); // 1 for tag, 5 for len

    if (hr != 0) {
        ldapFree( uniString, LDAP_UNICODE_SIGNATURE );
        return hr;
    }

    m_pbData[m_iCurrPos++] = (BYTE)ulTag;

    hr = HrSetLength(cbValue);

    if (hr == NOERROR) {

        //
        //  convert from ANSI to UTF-8 if required...  unfortunately there's
        //  no real quick way.
        //

        if ((m_CodePage == CP_UTF8) && (cbValue > 0)) {

            cbValue = LdapUnicodeToUTF8( uniString,
                                         wLength,
                                         (PCHAR) (m_pbData + m_iCurrPos),
                                         cbValue
                                         );

            hr = ((cbValue > 0) ? NOERROR : LDAP_NO_MEMORY);
            ldapFree( uniString, LDAP_UNICODE_SIGNATURE );

        } else {

            CopyMemory(m_pbData + m_iCurrPos, szValue, cbValue);
        }

        m_iCurrPos += cbValue;
        m_cbData = m_iCurrPos;
    }

    return hr;
}

/*!-------------------------------------------------------------------------
    CLdapBer::HrAddValue
        Puts a string into the BER buffer.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrAddValue(const WCHAR *szValue, ULONG ulTag)
{
    ULONG hr;
    ULONG   cbValue;
    WCHAR   nullStr = L'\0';

    if (m_OverridingTag) {

       ulTag = m_OverridingTag;
       m_OverridingTag = 0;
    }
    
    if (szValue == NULL) {

        szValue = &nullStr;
    }

    ULONG wStrLen = strlenW( (PWCHAR) szValue );

    if (m_CodePage == CP_UTF8) {

        cbValue  = LdapUnicodeToUTF8( szValue,
                                  wStrLen,
                                  NULL,
                                  0 );

    } else {

        cbValue  = WideCharToMultiByte( m_CodePage,
                                        0,
                                        szValue,
                                        wStrLen,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL );
    }

    if ((cbValue == 0) && (wStrLen > 0)) {

        int err = GetLastError();

        IF_DEBUG(BER) {
            LdapPrint1( "HrAddValue received error of 0x%x from WideCharToMultiByte.\n",
                            err );
        }

        switch (err) {
        case ERROR_INSUFFICIENT_BUFFER:
            hr = E_INVALIDARG;
            break;
        default:
            hr = LDAP_LOCAL_ERROR;
        }

    } else {

        hr = HrEnsureBuffer(1 + 5 + cbValue); // 1 for tag, 5 for len
        if (hr != 0) {
            return hr;
        }

        m_pbData[m_iCurrPos++] = (BYTE)ulTag;

        hr = HrSetLength(cbValue);
        if (hr == NOERROR) {

            if (wStrLen > 0) {

                if (m_CodePage == CP_UTF8) {

                    cbValue  = LdapUnicodeToUTF8( szValue,
                                              wStrLen,
                                              (char *) (m_pbData + m_iCurrPos),
                                              cbValue );
                } else {

                    cbValue  = WideCharToMultiByte( m_CodePage,
                                                    0,
                                                    szValue,
                                                    wStrLen,
                                                    (char *) (m_pbData + m_iCurrPos),
                                                    cbValue,
                                                    NULL,
                                                    NULL );
                }
            }

            m_iCurrPos += cbValue;
            m_cbData = m_iCurrPos;
        }
    }
    return hr;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrAddBinaryValue
        Puts a binary value into the BER buffer.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrAddBinaryValue(BYTE *pbValue, ULONG cbValue, ULONG ulTag)
{
    ULONG hr;

    if (m_OverridingTag) {

       ulTag = m_OverridingTag;
       m_OverridingTag = 0;
    }

    hr = HrEnsureBuffer(1 + 5 + cbValue); // 1 for tag, 5 for len

    if (hr != 0) {
        return hr;
    }

    m_pbData[m_iCurrPos++] = (BYTE)ulTag;

    hr = HrSetLength(cbValue);
    if (hr == NOERROR)
    {
        CopyMemory(m_pbData + m_iCurrPos, pbValue, cbValue);

        m_iCurrPos += cbValue;

        m_cbData = m_iCurrPos;
    }

    return hr;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrAddBinaryValue
        Puts a binary value into the BER buffer.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrAddBinaryValue(WCHAR *pbValue, ULONG cChars, ULONG ulTag)
{
    ULONG hr;
    ULONG cbValue;
    WCHAR   nullStr = L'\0';

    if (m_OverridingTag) {

       ulTag = m_OverridingTag;
       m_OverridingTag = 0;
    }


    if (pbValue == NULL) {

        pbValue = &nullStr;
    }

    if (m_CodePage == CP_UTF8) {

        cbValue = LdapUnicodeToUTF8( pbValue,
                                 cChars,
                                 NULL,
                                 0 );
    } else {

        cbValue  = WideCharToMultiByte( m_CodePage,
                                        0,
                                        pbValue,
                                        cChars,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL );
    }

    if ((cbValue == 0) && (cChars > 0)) {

        int err = GetLastError();

        IF_DEBUG(BER) {
            LdapPrint1( "HrAddValue received error of 0x%x from WideCharToMultiByte.\n",
                            err );
        }

        switch (err) {
        case ERROR_INSUFFICIENT_BUFFER:
            hr = E_INVALIDARG;
            break;
        default:
            hr = LDAP_LOCAL_ERROR;
        }

    } else {

        hr = HrEnsureBuffer(1 + 5 + cbValue); // 1 for tag, 5 for len
        if (hr != 0) {
            return hr;
        }

        m_pbData[m_iCurrPos++] = (BYTE)ulTag;

        hr = HrSetLength(cbValue);
        if (hr == NOERROR) {

            if (cChars > 0) {

                if (m_CodePage == CP_UTF8) {

                    cbValue = LdapUnicodeToUTF8( pbValue,
                                             cChars,
                                             (char *) (m_pbData + m_iCurrPos),
                                             cbValue );
                } else {

                    cbValue  = WideCharToMultiByte( m_CodePage,
                                                    0,
                                                    pbValue,
                                                    cChars,
                                                    (char *) (m_pbData + m_iCurrPos),
                                                    cbValue,
                                                    NULL,
                                                    NULL );
                }
            }

            m_iCurrPos += cbValue;
            m_cbData = m_iCurrPos;
        }
    }
    return hr;
}

/*!-------------------------------------------------------------------------
    CLdapBer::HrAddEscapedValue
        Puts a value into the BER buffer that may have escape chars in it.
        We convert the chars after we've converted to UTF-8 or ANSI.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrAddEscapedValue(WCHAR *pbValue, ULONG ulTag)
{
    ULONG hr;
    ULONG cbValue;
    WCHAR nullStr = L'\0';
    ULONG cChars;
    PCHAR allocatedBuffer = NULL;

    if (pbValue == NULL) {

        pbValue = &nullStr;
    }

    cChars = strlenW( pbValue );

    if (cChars == 0) {

        return HrAddValue( (const WCHAR *) pbValue, ulTag );
    }

    if (m_CodePage == CP_UTF8) {

        cbValue = LdapUnicodeToUTF8( pbValue,
                                     cChars,
                                     NULL,
                                     0 );
    } else {

        cbValue  = WideCharToMultiByte( m_CodePage,
                                        0,
                                        pbValue,
                                        cChars,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL );
    }

    if (cbValue == 0) {

        int err = GetLastError();

        IF_DEBUG(BER) {
            LdapPrint1( "HrAddValue received error of 0x%x from WideCharToMultiByte.\n",
                            err );
        }

        switch (err) {
        case ERROR_INSUFFICIENT_BUFFER:
            hr = E_INVALIDARG;
            break;
        default:
            hr = LDAP_LOCAL_ERROR;
        }

        return hr;
    }

    allocatedBuffer = (PCHAR) ldapMalloc( cbValue + 1, LDAP_ESCAPE_FILTER_SIGNATURE );

    if (allocatedBuffer == NULL) {

        return LDAP_NO_MEMORY;
    }

    if (m_CodePage == CP_UTF8) {

        cbValue = LdapUnicodeToUTF8( pbValue,
                                     cChars,
                                     allocatedBuffer,
                                     cbValue );
    } else {

        cbValue  = WideCharToMultiByte( m_CodePage,
                                        0,
                                        pbValue,
                                        cChars,
                                        allocatedBuffer,
                                        cbValue,
                                        NULL,
                                        NULL );
    }

    *(allocatedBuffer+cbValue) = '\0';

    PCHAR source;
    PCHAR dest;
    CHAR ch;

    source = dest = allocatedBuffer;

    while (*source != '\0') {

        ch = *(source++);

        if (ch == '\\') {

            UCHAR upNibble, loNibble;

            ch = *(source++);

            if (ISHEX(ch) == TRUE) {

                //
                //  if we have a backslash followed by some hex chars, then
                //  and only then do we translate it to the bin equivalent
                //

                upNibble = ch;

                ch = *(source++);
                cbValue--;

                if (ch == '\0') {
                    break;
                }

                if (ISHEX(ch) == TRUE) {

                    loNibble = ch;
                    cbValue--;

                } else {

                    //
                    //  if they only specified "\n" rather than "\nn", assume
                    //  a leading 0.
                    //

                    source--;       // obviously back up one since not using it.
                    loNibble = upNibble;
                    upNibble = 0;
                }

                ch = (MAPHEXTODIGIT( upNibble ) * 16) +
                      MAPHEXTODIGIT( loNibble );

            } else {

                source--;       // back up one since not translating the '\'
                ch = '\\';
            }
        }
        *(dest++) = ch;
    }

    *dest = L'\0';

    hr = HrAddBinaryValue( (BYTE *) allocatedBuffer,
                                    cbValue,
                                    ulTag );

    ldapFree( allocatedBuffer, LDAP_ESCAPE_FILTER_SIGNATURE );

    return hr;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrSetLength
        Sets the length of cb to the current position in the BER buffer.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrSetLength(ULONG cb, ULONG cbLength/*=0xffffffff*/)
{
    // Short or long version of length ?
    if (((cb <= 0x7f) && (cbLength == 0xffffffff)) || (cbLength == 1))
    {
        m_pbData[m_iCurrPos++] = (BYTE)cb;
    }
    else if (((cb <= 0x7fff) && (cbLength == 0xffffffff)) || (cbLength == 3))
    {
        // Two byte length
        m_pbData[m_iCurrPos++] = 0x82;
        m_pbData[m_iCurrPos++] = (BYTE)((cb>>8) & 0x00ff);
        m_pbData[m_iCurrPos++] = (BYTE)(cb & 0x00ff);
    }
    else if (((cb < 0x7fffffff) && (cbLength == 0xffffffff)) || (cbLength == 5))
    {
        // Don't bother with 3 byte length, go directly to 4 byte.
        m_pbData[m_iCurrPos++] = 0x84;
        m_pbData[m_iCurrPos++] = (BYTE)((cb>>24) & 0x00ff);
        m_pbData[m_iCurrPos++] = (BYTE)((cb>>16) & 0x00ff);
        m_pbData[m_iCurrPos++] = (BYTE)((cb>>8) & 0x00ff);
        m_pbData[m_iCurrPos++] = (BYTE)(cb & 0x00ff);
    }
    else
    {
        ASSERT(cb < 0x7fffffff);
        return E_INVALIDARG;
    }

    return NOERROR;
}


/*!-------------------------------------------------------------------------
    CLdapBer::GetCbLength
        Gets the # of bytes required for the length field in the current
        position in the BER buffer.
  ------------------------------------------------------------------------*/
void CLdapBer::GetCbLength(ULONG *pcbLength)
{
    // Short or long version of the length ?
    if (m_pbData[m_iCurrPos] & 0x80)
    {
        *pcbLength = 1;
        *pcbLength += m_pbData[m_iCurrPos] & 0x7f;
    }
    else
    {
        // Short version of the length.
        *pcbLength = 1;
    }
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrGetLength
        Gets the length from the current position in the BER buffer.  Only
        definite lengths are supported.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrGetLength(ULONG *pcb)
{
    ULONG   cbLength;
    ULONG   i, cb;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrGetLength ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    GetCbLength(&cbLength);

    // Short or long version of the length ?
    if (cbLength == 1)
    {
        cb = m_pbData[m_iCurrPos++] & 0x7f;
    }
    else if (cbLength <= 5)
    {
        // Account for the overhead byte.cbLength field.
        cbLength--;
        m_iCurrPos++;

        if ((m_iCurrPos + (cbLength-1)) >= m_cbData) {
            IF_DEBUG(BER) {
                LdapPrint2( "HrGetLength ran out of data, length 0x%x, offset 0x%x.\n",
                            m_cbData, m_iCurrPos );
            }
            return LDAP_DECODING_ERROR;
        }

        cb = m_pbData[m_iCurrPos++];
        for (i=1; i < cbLength; i++)
        {
            cb <<= 8;
            cb |= m_pbData[m_iCurrPos++] & 0xffffffff;
        }
    }
    else
    {
        // We don't support lengths 2^32.
        LdapPrint2("HrGetLength got a bad length, cbLength=0x%x, offset=0x%x.\n", cbLength, m_iCurrPos);
        return E_INVALIDARG;
    }

    if (( cb >= m_cbData ) ||
        ((cb + m_iCurrPos) > m_cbData )) {
        
        // Bogus length.
        IF_DEBUG(BER) {
            LdapPrint2( "HrGetLength discovered bogus length 0x%x, buffer length 0x%x\n",
                        cb, m_cbData );
        }

        return LDAP_DECODING_ERROR;
    }

    *pcb = cb;

    return NOERROR;
}



/*!-------------------------------------------------------------------------
    CLdapBer::GetInt
        Gets an integer from a BER buffer.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::GetInt(BYTE *pbData, ULONG cbValue, LONG *plValue)
{
    ULONG   ulVal=0;
    ULONG   cbDiff;
    BOOL    fSign = FALSE;

    // We assume the tag & length have already been taken off and we're
    // at the value part.

    if (cbValue > sizeof(LONG)) {

        *plValue = 0x7FFFFFFF;
        return LDAP_DECODING_ERROR;
    }

    cbDiff = sizeof(LONG) - cbValue;

    // See if we need to sign extend;

    if ((cbDiff > 0) && (*pbData & 0x80)) {

        fSign = TRUE;
    }

    while (cbValue > 0)
    {
        ulVal <<= 8;
        ulVal |= (ULONG)*pbData++;
        cbValue--;
    }

    // Sign extend if necessary.
    if (fSign) {

        *plValue = 0x80000000;
        *plValue >>= cbDiff * 8;
        *plValue |= ulVal;

    } else {

        *plValue = (LONG) ulVal;
    }

    return NOERROR;
}


/*!-------------------------------------------------------------------------
    CLdapBer::AddInt
        Adds an integer to the input pbData buffer.
  ------------------------------------------------------------------------*/
void CLdapBer::AddInt(BYTE *pbData, ULONG cbValue, LONG lValue)
{
    ULONG i;

    for (i=cbValue; i > 0; i--)
    {
        *pbData++ = (BYTE)(lValue >> ((i - 1) * 8)) & 0xff;
    }
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrEnsureBuffer
        Ensures that we've got room to put cbNeeded more bytes into the buffer.
  ------------------------------------------------------------------------*/
ULONG
CLdapBer::HrEnsureBuffer(ULONG cbNeeded, BOOL fExact)
{
    ULONG cbNew;
    BYTE *pbT;

    if (( cbNeeded + m_cbData <= m_cbDataMax) &&
        (m_cbDataMax > 0)) {

        return NOERROR;
    }

    if (fExact) {

        cbNew = cbNeeded + m_cbData;

    } else {

        if (cbNeeded > CB_DATA_GROW) {

            cbNew = m_cbDataMax + cbNeeded;

        } else {

            cbNew = m_cbDataMax + CB_DATA_GROW;
        }
    }
    pbT = (BYTE *)ldapMalloc(cbNew,LDAP_LBER_SIGNATURE);
    if (!pbT) {
        return LDAP_NO_MEMORY;
    }
    if (m_pbData) {

        CopyMemory(pbT, m_pbData, m_cbDataMax);
        ldapFree(m_pbData, LDAP_LBER_SIGNATURE );
    }

    m_pbData = pbT;
    m_cbDataMax = cbNew;
    return NOERROR;
}

ULONG
CLdapBer::HrSetDNLocation()
//
//  Record the position of the distinguished name
//
//  We have to parse out the message here
//
{
    ULONG tag;
    ULONG hr;
    ULONG cb = 0;

    m_dnOffset = m_iCurrPos;

    //
    //  ensure that it is a octet string for the DN.  if not, then we don't
    //  know how to interpret the rest
    //

    hr = HrPeekTag( &tag );

    if (hr != NOERROR) {
        return hr;
    }

    if (tag != BER_OCTETSTRING) {

        return E_INVALIDARG;
    }

    m_iCurrPos++;           // skip tag

    hr = HrGetLength(&cb);

    if (hr != NOERROR) {

        return hr;
    }

    //
    //  if it has a zero length DN and nothing after it, toss it.
    //

    if (cb == 0) {

        //
        //  check that it a sequence starts here for PartialAttributeList
        //

        hr = HrPeekTag( &tag );

        if (hr != NOERROR) {
            return hr;
        }

        if (tag != BER_SEQUENCE) {
            return E_INVALIDARG;
        }

        m_iCurrPos++;           // skip tag

        hr = HrGetLength(&cb);

        if (hr != NOERROR) {

            return hr;
        }
    }

    m_iCurrPos = m_dnOffset;
    return NOERROR;
}

//
//  CLdapBer::HrGetDN
//      This routine gets the DN string value from the current BER entry.
//
ULONG CLdapBer::HrGetDN(PWCHAR *szDN)
{
    ULONG hr;
    ULONG   savedCurrentPosition = m_iCurrPos;

    *szDN = NULL;

    if ((m_dnOffset == 0) ||
        (m_pbData == NULL) ||
        (m_dnOffset > m_cbDataMax)) {

        return E_INVALIDARG;
    }

    if (m_pbData[m_dnOffset] != BER_OCTETSTRING) {

        return LDAP_DECODING_ERROR;
    }

    m_iCurrPos = m_dnOffset;

    hr = HrGetValueWithAlloc( szDN );

    //
    //  we need to change the memory type for a DN.
    //

    ldapSwapTags( *szDN, LDAP_VALUE_SIGNATURE, LDAP_BUFFER_SIGNATURE );

    m_iCurrPos = savedCurrentPosition;

    return hr;
}



void
Asn1GetCbLength (
    PUCHAR Buffer,
    ULONG *pcbLength
    )
{
    // Short or long version of the length ?
    if (*Buffer & 0x80)
    {
        *pcbLength = 1;
        *pcbLength += (*Buffer) & 0x7f;
    }
    else
    {
        // Short version of the length.
        *pcbLength = 1;
    }
}


ULONG
Asn1GetPacketLength (
    PUCHAR Buffer,
    ULONG *plValue
    )
{
    ULONG   cb;
    ULONG   ul;
    ULONG   totalLength = 0;
    ULONG   cbLength;
    ULONG   i;

    ul = (ULONG) (*Buffer); // TAG

    if ( ul != BER_SEQUENCE ) {

        IF_DEBUG(BER) {
            LdapPrint2( "Asn1GetPacketLength expected tag of 0x%x, received 0x%x.\n",
                        BER_SEQUENCE, ul );
        }
        return E_INVALIDARG;
    }

    Buffer++;       // skip tag
    totalLength = 1;

    Asn1GetCbLength(Buffer, &cbLength);

    // Short or long version of the length ?

    if (cbLength == 1) {

        cb = (*Buffer) & 0x7f;
        totalLength += 1;

    } else if (cbLength <= 5) {

        // Account for the overhead byte.cbLength field.
        cbLength--;
        Buffer++;
        totalLength += 1;

        cb = *Buffer;
        Buffer++;
        totalLength += 1;
        for (i=1; i < cbLength; i++) {

            cb <<= 8;
            cb |= (*(Buffer++)) & 0xffffffff;
            totalLength += 1;
        }
    } else {

        // We don't support lengths 2^32.
        ASSERT(cbLength <= 5);
        return E_INVALIDARG;
    }

    *plValue = totalLength + cb;

    return NOERROR;
}


/*!-------------------------------------------------------------------------
    CLdapBer::HrSkipTag2
        Skips over the current tag.
        
  On Success: Returns NO_ERROR; sets tag and length arguments
  On Failure: Returns LDAP_NO_SUCH_ATTRIBUTE; sets nothing
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrSkipTag2(ULONG *tag, ULONG *len)
{
   ULONG SavedOffset = m_iCurrPos;
   ULONG hr;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrSkipTag2 ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    *tag = (ULONG)m_pbData[m_iCurrPos]; // Got the TAG

    m_iCurrPos++;

    if (m_cbData <= m_iCurrPos) {

        IF_DEBUG(BER) {
            LdapPrint2( "HrSkipTag2 ran out of data, length 0x%x, offset 0x%x.\n",
                        m_cbData, m_iCurrPos );
        }
        m_iCurrPos = SavedOffset;
        return LDAP_NO_SUCH_ATTRIBUTE;
    }

    hr = HrGetLength( len );

    if ((hr != NOERROR) || (m_cbData < m_iCurrPos)) {

       m_iCurrPos = SavedOffset;
       return hr;
    }


    return NOERROR;
}



ULONG CLdapBer::HrOverrideTag(ULONG ulTag)
{
   if (ulTag != 0) {

      //
      // Reject any invalid tags
      //

      m_OverridingTag = ulTag;
      return NOERROR;
   }

   return E_INVALIDARG;

}



/*!-------------------------------------------------------------------------
    CLdapBer::HrAddValue
        This routine puts a Boolean value in the BER buffer.
  ------------------------------------------------------------------------*/
ULONG CLdapBer::HrAddValue(BOOLEAN i, ULONG ulTag/*=BER_BOOLEAN*/)
{
    ULONG hr;
    ULONG   cbInt;


    if (m_OverridingTag) {

       ulTag = m_OverridingTag;
       m_OverridingTag = 0;
    }

    cbInt = 0x1; // Sizeof boolean value

    hr = HrEnsureBuffer(1 + 1 + cbInt); // 1 for tag, 1 for length
    if (hr != 0) {
        return hr;
    }

    m_pbData[m_iCurrPos++] = (BYTE)ulTag;

    hr = HrSetLength(cbInt);

    if (hr == NOERROR) {

//      AddInt(m_pbData + m_iCurrPos, cbInt, i);

       *(m_pbData + m_iCurrPos) = ((i == TRUE) ? 0xFF:0x0);

        m_iCurrPos += cbInt;

        m_cbData = m_iCurrPos;
    }

    return hr;
}


// ldapber.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\initterm.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    initterm.c    global data for LDAP client DLL

Abstract:

   This module contains data definitions necessary for LDAP client DLL.

   Also contains code that initializes/frees global data.

Author:

    Andy Herron    (andyhe)        15-May-1996
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "dststlog.h"

#ifdef __cplusplus
extern "C" {
#endif

#define _DECL_DLLMAIN
#include <process.h>

BOOL WINAPI
LdapDllInit (
    HINSTANCE hinstDLL,
    DWORD     Reason,
    LPVOID    Reserved
    );

#ifdef __cplusplus
}
#endif

//
//  global data goes here...
//

HINSTANCE  GlobalLdapDllInstance = NULL;
LIST_ENTRY GlobalListActiveConnections;
LIST_ENTRY GlobalListWaiters;
LIST_ENTRY GlobalListRequests;
CRITICAL_SECTION ConnectionListLock;
CRITICAL_SECTION RequestListLock;
CRITICAL_SECTION LoadLibLock;
CRITICAL_SECTION CacheLock;
CRITICAL_SECTION SelectLock1;
CRITICAL_SECTION SelectLock2;
HANDLE     LdapHeap;
LONG      GlobalConnectionCount;
LONG      GlobalRequestCount;
LONG      GlobalWaiterCount;
LONG      GlobalMessageNumber;
LONG      GlobalCountOfOpenRequests;
WSADATA   GlobalLdapWSAData;
BOOLEAN   MessageNumberHasWrapped = FALSE;
BOOLEAN   GlobalCloseWinsock;
BOOLEAN   GlobalWinsock11;
BOOLEAN   GlobalWinNT = TRUE;
BOOLEAN   PopupRegKeyFound = FALSE;
HINSTANCE WinsockLibraryHandle = NULL;
HINSTANCE SecurityLibraryHandle;
HINSTANCE SslLibraryHandle;
HINSTANCE AdvApi32LibraryHandle = NULL;
HINSTANCE NTDSLibraryHandle = NULL;
HINSTANCE ScramblingLibraryHandle = NULL;
BOOLEAN GlobalLdapShuttingDown;
BOOLEAN DisableRootDSECache = FALSE;
UCHAR   GlobalSeed = 0;      // Let RtlRunEncodeUnicodeString choose the seed
BOOLEAN GlobalUseScrambling = FALSE; // should we scramble passwords?
LIST_ENTRY GlobalPerThreadList;
CRITICAL_SECTION PerThreadListLock;
DWORD GlobalIntegrityDefault = DEFAULT_INTEGRITY_PREFERRED; // what minimum level of signing is required?


ULONG GlobalWaitSecondsForSelect = LDAP_PING_KEEP_ALIVE_DEF;
ULONG GlobalLdapPingLimit = LDAP_PING_LIMIT_DEF;
ULONG GlobalPingWaitTime = LDAP_PING_WAIT_TIME_DEF;
ULONG GlobalRequestResendLimit = LDAP_REQUEST_RESEND_LIMIT_DEF;

#if DBG
DBGPRINT  GlobalLdapDbgPrint = DbgPrint;
#else
DBGPRINT  GlobalLdapDbgPrint = NULL;
#endif

BOOLEAN   GlobalWin9x;
DWORD     GlobalReceiveHandlerThread;
DWORD     GlobalDrainWinsockThread;
HINSTANCE NetApi32LibraryHandle;
LONG     GlobalLoadUnloadRefCount = 0;

//
//  Security support
//

ULONG   NumberSecurityPackagesInstalled;
ULONG   NumberSslPackagesInstalled;
PSecurityFunctionTableW SspiFunctionTableW;
PSecurityFunctionTableW SslFunctionTableW;
PSecurityFunctionTableA SspiFunctionTableA;     // For use in Win9x
PSecurityFunctionTableA SslFunctionTableA;      //    - do -
PSecPkgInfoW SslPackagesInstalled;
PSecPkgInfoW SecurityPackagesInstalled;
PSecPkgInfoW SspiPackageNegotiate;
PSecPkgInfoW SspiPackageKerberos;
PSecPkgInfoW SspiPackageSslPct;
PSecPkgInfoW SspiPackageSicily;
PSecPkgInfoW SspiPackageNtlm;
PSecPkgInfoW SspiPackageDpa;
PSecPkgInfoW SspiPackageDigest;
ULONG SspiMaxTokenSize = 0;

//
//  This socket is used to wake up our thread in select to come and reread
//  the list of handles to wait on.
//

SOCKET LdapGlobalWakeupSelectHandle = INVALID_SOCKET;
BOOLEAN InsideSelect = FALSE;

//
//
//  pointers to functions we import from winsock (1.1 or 2.0)
//

LPFN_WSASTARTUP pWSAStartup = NULL;
LPFN_WSACLEANUP pWSACleanup = NULL;
LPFN_WSAGETLASTERROR pWSAGetLastError = NULL;
LPFN_RECV precv = NULL;
LPFN_SELECT pselect = NULL;
LPFN_WSARECV pWSARecv = NULL;
LPFN_SOCKET psocket = NULL;
LPFN_CONNECT pconnect = NULL;
LPFN_GETHOSTBYNAME pgethostbyname = NULL;
LPFN_GETHOSTBYADDR pgethostbyaddr = NULL;
LPFN_INET_ADDR pinet_addr = NULL;
LPFN_INET_NTOA pinet_ntoa = NULL;
LPFN_HTONS phtons = NULL;
LPFN_HTONL phtonl = NULL;
LPFN_NTOHL pntohl = NULL;
LPFN_CLOSESOCKET pclosesocket = NULL;
LPFN_SEND psend = NULL;
LPFN_IOCTLSOCKET pioctlsocket = NULL;
LPFN_SETSOCKOPT psetsockopt = NULL;
FNWSAFDISSET pwsafdisset = NULL;
LPFN_BIND pbind = NULL;
LPFN_GETSOCKNAME pgetsockname = NULL;
LPFN_WSALOOKUPSERVICEBEGINW pWSALookupServiceBeginW = NULL;
LPFN_WSALOOKUPSERVICENEXTW pWSALookupServiceNextW = NULL;
LPFN_WSALOOKUPSERVICEEND pWSALookupServiceEnd = NULL;

FNDSMAKESPNW pDsMakeSpnW = NULL;

FNRTLINITUNICODESTRING pRtlInitUnicodeString = NULL;
FRTLRUNENCODEUNICODESTRING pRtlRunEncodeUnicodeString = NULL;
FRTLRUNDECODEUNICODESTRING pRtlRunDecodeUnicodeString = NULL;
FRTLENCRYPTMEMORY pRtlEncryptMemory = NULL;
FRTLDECRYPTMEMORY pRtlDecryptMemory = NULL;


CHAR LdapErrorStrings[LDAP_MAX_ERROR_STRINGS][LDAP_ERROR_STR_LENGTH];
WCHAR LdapErrorStringsW[LDAP_MAX_ERROR_STRINGS][LDAP_ERROR_STR_LENGTH];
HANDLE GlobalLdapShutdownEvent = NULL;
DWORD GlobalTlsLastErrorIndex = (DWORD) -1;

CHAR LdapHexToCharTable[17] = "0123456789ABCDEF";

#if DBG
ULONG LdapDebug = DEBUG_ERRORS;
#else
ULONG LdapDebug = 0;
#endif


//
// Once GlobalHasInitialized is TRUE, initialization
// has reached the commit point and LdapClientTerminate
// needs to free any resources that were allocated
//
static BOOLEAN GlobalHasInitialized = FALSE;

//
//  local declarations follow...
//

BOOL
LdapClientInitialize (
    HINSTANCE hinstDLL
    );

BOOL
LdapClientTerminate (
    BOOL AllClean
    );

VOID
LdapCleanupPerThreadData(
    VOID
    );

BOOL
LdapUsePrivateHeap(
    VOID
    );


//
//  This routine handles initializing/releasing global data.  It is called
//  when we're attached/detached from a process.
//

BOOL WINAPI
LdapDllInit (
    HINSTANCE hinstDLL,
    DWORD     Reason,
    LPVOID    Reserved
    )
{
    //
    //  we don't call the _CRT_INIT etc routines because Athena group doesn't
    //  want us to load MSVCRT.DLL.
    //

    if (Reason == DLL_PROCESS_ATTACH) {

        //
        // Start up logging
        //
        
        GlobalLdapDllInstance = hinstDLL;
        return LdapClientInitialize( hinstDLL );

    } else if (Reason == DLL_PROCESS_DETACH) {

        // if Reserved is null, someone called FreeLibrary... we only cleanup
        // on FreeLibrary, not on process terminate.

        if (Reserved == NULL) {

            return LdapClientTerminate( TRUE );
        }

    } else if (Reason == DLL_THREAD_ATTACH) {
            return AddPerThreadEntry(GetCurrentThreadId());

    } else if (Reason == DLL_THREAD_DETACH) {

        if (GlobalTlsLastErrorIndex != (DWORD) -1) {

            TlsSetValue( GlobalTlsLastErrorIndex, NULL );
        }
        RemovePerThreadEntry(GetCurrentThreadId());
    }

    return TRUE;        // we always return sucess
}

BOOL
LdapClientInitialize (
    HINSTANCE hinstDLL
    )
{
    //
    //  If we've already initialized, return TRUE because someone's called
    //  ldap_startup either twice or we handled it at DLL load time.
    //

    UNREFERENCED_PARAMETER( hinstDLL );

    DWORD dwCritSectInitStage = 0;

    if (LdapHeap != NULL) {
        
        InterlockedIncrement( &GlobalLoadUnloadRefCount );
        return TRUE;
    }


    //
    //  handle initializing all data at attach time
    //

    InitializeListHead(&GlobalListActiveConnections);
    InitializeListHead(&GlobalListWaiters);
    InitializeListHead(&GlobalListRequests);
    InitializeListHead(&GlobalPerThreadList);


    __try {
        INITIALIZE_LOCK( &ConnectionListLock );
        dwCritSectInitStage = 1;
        
        INITIALIZE_LOCK( &RequestListLock );
        dwCritSectInitStage = 2;
        
        INITIALIZE_LOCK( &LoadLibLock );
        dwCritSectInitStage = 3;
        
        INITIALIZE_LOCK( &CacheLock );
        dwCritSectInitStage = 4;
        
        INITIALIZE_LOCK( &SelectLock1 );
        dwCritSectInitStage = 5;
        
        INITIALIZE_LOCK( &SelectLock2 );
        dwCritSectInitStage = 6;
        
        INITIALIZE_LOCK( &PerThreadListLock );
        dwCritSectInitStage = 7;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // Something went wrong with the crit section initialization
        //

        switch (dwCritSectInitStage) {
            // fall-through is deliberate

        case 7:
            DELETE_LOCK( &PerThreadListLock );
        case 6:
            DELETE_LOCK( &SelectLock2 );
        case 5:
            DELETE_LOCK( &SelectLock1 );
        case 4:
            DELETE_LOCK( &CacheLock );
        case 3:
            DELETE_LOCK( &LoadLibLock );
        case 2:
            DELETE_LOCK( &RequestListLock );
        case 1:
            DELETE_LOCK( &ConnectionListLock );
        case 0:
        default:
            break;
        }
        
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        IF_DEBUG(ERRORS) {
            LdapPrint0( "LDAP client failed to initialize critical sections.\n");
        }
        
        return FALSE;
    }


    //
    // We use a private heap in the server configuration for the Exchange
    // folks who claim that wldap32 increases process heap contention.
    //

    if (LdapUsePrivateHeap()) {
    
        LdapHeap = HeapCreate( 0, INITIAL_HEAP, 0 );
    }
    else {
        LdapHeap = NULL;
    }


    if (LdapHeap == NULL) {

        LdapHeap = GetProcessHeap();

        if (LdapHeap == NULL) {

            IF_DEBUG(ERRORS) {
                LdapPrint1( "LDAP client failed to create heap, err = 0x%x.\n", GetLastError());
            }

            //
            // Clean up the critical sections we earlier initialized
            //
            DELETE_LOCK( &ConnectionListLock );
            DELETE_LOCK( &RequestListLock );
            DELETE_LOCK( &LoadLibLock );
            DELETE_LOCK( &CacheLock );
            DELETE_LOCK( &SelectLock1 );
            DELETE_LOCK( &SelectLock2 );
            DELETE_LOCK( &PerThreadListLock );

            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
    }

    IF_DEBUG(INIT_TERM) {
        LdapPrint0( "LDAP Client API 32 initializing.\n" );
    }
    

    //
    // Add an entry to GlobalPerThreadList for this thread
    //
    if (!AddPerThreadEntry(GetCurrentThreadId())) {
        //
        // Cleanup and abort
        //
        if (LdapHeap != NULL &&
            LdapHeap != GetProcessHeap()) {

            HeapDestroy( LdapHeap );
            LdapHeap = NULL;
        }
        
        DELETE_LOCK( &ConnectionListLock );
        DELETE_LOCK( &RequestListLock );
        DELETE_LOCK( &LoadLibLock );
        DELETE_LOCK( &CacheLock );
        DELETE_LOCK( &SelectLock1 );
        DELETE_LOCK( &SelectLock2 );
        DELETE_LOCK( &PerThreadListLock );

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    GlobalHasInitialized = TRUE;

    NumberSecurityPackagesInstalled = 0;
    GlobalCountOfOpenRequests = 0;
    NumberSslPackagesInstalled = 0;
    SecurityPackagesInstalled = NULL;
    SslPackagesInstalled = NULL;
    SspiFunctionTableW = NULL;
    SslFunctionTableW = NULL;
    SspiFunctionTableA = NULL;
    SslFunctionTableA = NULL;

    SspiPackageKerberos = NULL;
    SspiPackageSslPct = NULL;
    SspiPackageSicily = NULL;
    SspiPackageNegotiate = NULL;
    SspiPackageNtlm = NULL;
    SspiPackageDpa = NULL;
    SspiPackageDigest = NULL;

    GlobalMessageNumber = 0;
    GlobalConnectionCount = 0;
    GlobalRequestCount = 0;
    GlobalWaiterCount = 0;
    GlobalCloseWinsock = FALSE;
    GlobalWinsock11 = TRUE;
    WinsockLibraryHandle = NULL;
    SecurityLibraryHandle = NULL;
    SslLibraryHandle = NULL;
    NetApi32LibraryHandle = NULL;
    AdvApi32LibraryHandle = NULL;
    GlobalLdapShuttingDown = FALSE;
    GlobalLdapShutdownEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    GlobalReceiveHandlerThread = NULL;
    GlobalDrainWinsockThread = NULL;

    InitializeLdapCache();

    if (ReadRegIntegrityDefault(&GlobalIntegrityDefault) != ERROR_SUCCESS) {
        // if we couldn't read a default integrity (signing) setting from
        // the registry, set our default to "preferred-but-not-required"
        GlobalIntegrityDefault = DEFAULT_INTEGRITY_PREFERRED;
    }

    GlobalTlsLastErrorIndex = TlsAlloc();

    InterlockedIncrement( &GlobalLoadUnloadRefCount );

    IF_DEBUG(INIT_TERM) {
        LdapPrint0( "LDAP Client API 32 initialization complete.\n" );
    }
    
    return TRUE;
}

BOOL
AddPerThreadEntry(
                DWORD ThreadID
                )
{
    //
    // Create a per-thread entry for ThreadID and link it onto the GlobalPerThreadList
    //
    PTHREAD_ENTRY threadEntry = (PTHREAD_ENTRY) ldapMalloc( sizeof( THREAD_ENTRY ), LDAP_PER_THREAD_SIGNATURE);

    if (threadEntry != NULL) {

        threadEntry->dwThreadID = ThreadID;
        threadEntry->pErrorList = NULL;
        threadEntry->pCurrentAttrList = NULL;

        ACQUIRE_LOCK( &PerThreadListLock );
        InsertHeadList ( &GlobalPerThreadList, &threadEntry->ThreadEntry);
        RELEASE_LOCK( &PerThreadListLock );
        
        return TRUE;
    }

    return FALSE;
}

BOOL
RemovePerThreadEntry(
                DWORD ThreadID
                )
{
    PLIST_ENTRY pThreadListEntry = NULL;
    PTHREAD_ENTRY pThreadEntry = NULL;

    PERROR_ENTRY pErrorEntry, pErrorEntryNext;
    PLDAP_ATTR_NAME_THREAD_STORAGE pAttrEntry,pAttrEntryNext;

    ACQUIRE_LOCK( &PerThreadListLock );

    //
    // Locate the per-thread entry for ThreadID
    //
    pThreadListEntry = GlobalPerThreadList.Flink;

    while (pThreadListEntry != &GlobalPerThreadList) {

        pThreadEntry = CONTAINING_RECORD( pThreadListEntry, THREAD_ENTRY, ThreadEntry );
        pThreadListEntry = pThreadListEntry->Flink;

        if (pThreadEntry->dwThreadID == ThreadID) {

            //
            // Found the per-thread entry for ThreadID
            // Remove and free it and it's child lists
            //
            RemoveEntryList(&pThreadEntry->ThreadEntry);

            // walk & free the error list
            pErrorEntry = pThreadEntry->pErrorList;

            while (pErrorEntry != NULL) {

                pErrorEntryNext = pErrorEntry->pNext;

                if (pErrorEntry->ErrorMessage != NULL) {

                   ldap_memfreeW( pErrorEntry->ErrorMessage );
                }

                ldapFree( pErrorEntry, LDAP_ERROR_SIGNATURE );
                
                pErrorEntry = pErrorEntryNext;
            }
            
            // walk & free the attribute list
            pAttrEntry = pThreadEntry->pCurrentAttrList;
            
            while (pAttrEntry != NULL) {

                pAttrEntryNext = pAttrEntry->pNext;

                ldapFree( pAttrEntry, LDAP_ATTR_THREAD_SIGNATURE );
                
                pAttrEntry = pAttrEntryNext;
            }

            // free the per-thread entry itself
            ldapFree(pThreadEntry, LDAP_PER_THREAD_SIGNATURE);
            RELEASE_LOCK ( &PerThreadListLock );
            return TRUE;
        }
    }

    RELEASE_LOCK( &PerThreadListLock );
    return FALSE;
}




//
// Determine whether to use a private heap or the process heap for all
// allocations.
//
// Using a private heap isolates us from other modules in the process
// (good for debugging) and reduces contention on the process heap
// (good for servers).  However, it also increases overhead (bad for
// clients/low memory machines).
//
// Algorithm for deciding whether to use a private heap or the process
// heap:
//
//   CHK bits always use a private heap
//
//   Win9x uses the process heap.
//   NT3.5 -- NT4 use a private heap (since they don't support VERSIONINFOEX)
//   Windows 2000+: if running Personal or Pro, use the process heap
//                  otherwise, use a private heap
//
//
BOOL
LdapUsePrivateHeap (
    VOID
    )
{
#if LDAPDBG

    // CHK bits --> private heap
    return TRUE;

#else

    DWORD sysVersion;
    DWORD winMajorVersion;

    sysVersion = GetVersion();
    winMajorVersion = (DWORD) (LOBYTE(LOWORD(sysVersion)));

    //
    // Check for pre-Windows 2000 operating systems
    //

    if (sysVersion >= 0x80000000) {
        // Win9x --> process heap
        IF_DEBUG(INIT_TERM) {
            LdapPrint0("Platform is windows 95/98\n");
        }
        return FALSE;
    }

    if (winMajorVersion < 5) {
        // a version of NT prior to Windows 2000 ---> private heap
        IF_DEBUG(INIT_TERM) {
            LdapPrint0("Platform is windows NT prior to Windows 2000\n");
        }        
        return TRUE;
    }

    //
    // Windows 2000 or higher: use GetVersionEx with VERSIONINFOEX
    // to determine the configuration
    //

    OSVERSIONINFOEX verInfo;
    verInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (!GetVersionEx(reinterpret_cast<OSVERSIONINFO*>(&verInfo))) {
        // failed --- just use a private heap
        IF_DEBUG(INIT_TERM) {
            LdapPrint1("Could not get any version information from GetVersionEx 0x%x\n", GetLastError());
        }

        return TRUE;
    }

    if (verInfo.wSuiteMask & VER_SUITE_PERSONAL) {
        // Windows Personal --> process heap
        IF_DEBUG(INIT_TERM) {
            LdapPrint0("Platform is Windows Personal\n");
        }        
        return FALSE;
    }
    else if (verInfo.wProductType == VER_NT_WORKSTATION) {
        // Windows Professional --> process heap
        IF_DEBUG(INIT_TERM) {
            LdapPrint0("Platform is Windows Professional\n");
        }        
        return FALSE;        
    }
    else {
        // some sort of Server --> private heap
        IF_DEBUG(INIT_TERM) {
            LdapPrint0("Platform is Windows Server\n");
        }        
        return TRUE;       
    }
    
#endif
}


BOOL
LdapInitializeWinsock (
    VOID
    )
//
//  When we call into winsock at dll load time, the c-runtime libraries may
//  not have initialized the heap and winsock could trap.  To work around this
//  problem, we'll call winsock startup routine on the first connect request.
//
{
    WORD wVersion;
    DWORD sysVersion;
    DWORD winMajorVersion;
    int i, err;
    ULONG nonblockingMode = 1;
    SOCKADDR_IN sa = {0};
    int buffersize = sizeof(sa);
    CHAR DllName[] = "RADMIN32.DLL";
    ULONG offset = 0;
    ULONG retval = 0;


    if (GlobalCloseWinsock) {
        return(TRUE);
    }

    ACQUIRE_LOCK( &LoadLibLock );

    if (GlobalCloseWinsock) {
        RELEASE_LOCK( &LoadLibLock );
        return(TRUE);
    }

    DSINITLOG();
    
    //
    //  Load either winsock 2.0 or 1.1 DLL, depending on if we're on 3.51 or
    //  4.0.
    //

    GlobalWin9x = FALSE;
    sysVersion = GetVersion();
    winMajorVersion = (DWORD) (LOBYTE(LOWORD(sysVersion)));

    if ((winMajorVersion == 3) &&
        (sysVersion < 0x80000000)) {  // Windows NT 3.5x

        WinsockLibraryHandle = LoadLibraryA( "WSOCK32.DLL" );

        GlobalWinsock11 = TRUE;     // we're using Winsock 1.1 on NT 3.5/3.51

        LdapPrint0("Using wsock32 on NT 3.5x\n");

    } else {

        if (sysVersion >= 0x80000000) {

            GlobalWin9x = TRUE;
        }

        //
        // We prefer to use the Winsock2 library if available.
        //

        WinsockLibraryHandle = LoadLibraryA( "WS2_32.DLL" );

        if (WinsockLibraryHandle != NULL) {

            GlobalWinsock11 = FALSE;

        } else {

            //
            // we have no choice but to load Winsock1.1
            //

            WinsockLibraryHandle = LoadLibraryA( "WSOCK32.DLL" );
            LdapPrint0("Using wsock32 due to lack of winsock2.\n");

            if (WinsockLibraryHandle != NULL) {
                GlobalWinsock11 = TRUE;
            }
        }
    }

    if (WinsockLibraryHandle == NULL) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LDAP client failed to load Winsock, err = 0x%x.\n", GetLastError());
        }

        goto error;
    }

    //
    //  Grab the addresses of all functions we'll call
    //

    pWSAStartup = (LPFN_WSASTARTUP) GetProcAddress( WinsockLibraryHandle, "WSAStartup" );
    pWSACleanup = (LPFN_WSACLEANUP) GetProcAddress( WinsockLibraryHandle, "WSACleanup" );
    pWSAGetLastError = (LPFN_WSAGETLASTERROR) GetProcAddress( WinsockLibraryHandle, "WSAGetLastError" );
    psocket = (LPFN_SOCKET) GetProcAddress( WinsockLibraryHandle, "socket");
    pconnect = (LPFN_CONNECT) GetProcAddress( WinsockLibraryHandle, "connect");
    pgethostbyname = (LPFN_GETHOSTBYNAME) GetProcAddress( WinsockLibraryHandle, "gethostbyname");
    pgethostbyaddr = (LPFN_GETHOSTBYADDR) GetProcAddress( WinsockLibraryHandle, "gethostbyaddr");
    pinet_addr = (LPFN_INET_ADDR) GetProcAddress( WinsockLibraryHandle, "inet_addr");
    pinet_ntoa = (LPFN_INET_NTOA) GetProcAddress( WinsockLibraryHandle, "inet_ntoa");
    phtons = (LPFN_HTONS) GetProcAddress( WinsockLibraryHandle, "htons");
    phtonl = (LPFN_HTONL) GetProcAddress( WinsockLibraryHandle, "htonl");
    pntohl = (LPFN_NTOHL) GetProcAddress( WinsockLibraryHandle, "ntohl");
    pclosesocket = (LPFN_CLOSESOCKET) GetProcAddress( WinsockLibraryHandle, "closesocket");
    precv = (LPFN_RECV) GetProcAddress( WinsockLibraryHandle, "recv");
    psend = (LPFN_SEND) GetProcAddress( WinsockLibraryHandle, "send");
    pselect = (LPFN_SELECT) GetProcAddress( WinsockLibraryHandle, "select" );
    pwsafdisset = (FNWSAFDISSET) GetProcAddress( WinsockLibraryHandle, "__WSAFDIsSet");
    pioctlsocket = (LPFN_IOCTLSOCKET) GetProcAddress( WinsockLibraryHandle, "ioctlsocket");
    psetsockopt = (LPFN_SETSOCKOPT) GetProcAddress( WinsockLibraryHandle, "setsockopt");
    pbind = (LPFN_BIND) GetProcAddress( WinsockLibraryHandle, "bind");
    pgetsockname = (LPFN_GETSOCKNAME) GetProcAddress( WinsockLibraryHandle, "getsockname");
    pWSALookupServiceBeginW = (LPFN_WSALOOKUPSERVICEBEGINW) GetProcAddress( WinsockLibraryHandle, "WSALookupServiceBeginW");
    pWSALookupServiceNextW = (LPFN_WSALOOKUPSERVICENEXTW) GetProcAddress( WinsockLibraryHandle, "WSALookupServiceNextW");
    pWSALookupServiceEnd = (LPFN_WSALOOKUPSERVICEEND) GetProcAddress( WinsockLibraryHandle, "WSALookupServiceEnd");

    if (pWSAStartup == NULL ||
        pWSACleanup == NULL ||
        pWSAGetLastError == NULL ||
        precv == NULL ||
        psocket == NULL ||
        pconnect == NULL ||
        pgethostbyname == NULL ||
        pgethostbyaddr == NULL ||
        pinet_addr == NULL ||
        phtons == NULL ||
        phtonl == NULL ||
        pntohl == NULL ||
        psend  == NULL ||
        pclosesocket == NULL ||
        pwsafdisset == NULL ||
        pselect == NULL ) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LDAP client failed GetProcAddress, err = 0x%x.\n", GetLastError());
        }

        FreeLibrary( WinsockLibraryHandle );
        WinsockLibraryHandle = NULL;

        goto error;
    }

    //
    // Try to load up either radmin32.dll, advapi32.dll or ntdll.dll to get access to the
    // scrambling routines.
    //
    // First, check to see if we are on NT. If yes, load NTDLL.DLL and ADVAPI32.DLL.
    // We'll preferably use the encryption routines of advapi32.dll, if they're
    // available (Whistler and up), otherwise we'll use ntdll.dll's Unicode scrambling
    // routines.
    // If not on NT, load RADMIN32.DLL only from the system directory of the Win9x
    // machine.
    //

    OSVERSIONINFO OsVersionInfo;
    CHAR SystemPath[MAX_PATH + 15]; // we will append "RADMIN32.DLL" to the path returned

    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (!GetVersionEx( &OsVersionInfo )) {

        IF_DEBUG(INIT_TERM) {
            LdapPrint1("Could not get any version information from GetVersionEx 0x%x\n", GetLastError());
        }
        goto LoadDone;
    }

    if (OsVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {

        IF_DEBUG(INIT_TERM) {
            LdapPrint0("Platform is windows NT\n");
        }
        GlobalWinNT = TRUE;
    } else {

        IF_DEBUG(INIT_TERM) {
            LdapPrint0("Platform is windows 9x\n");
        }
        GlobalWinNT = FALSE;
    }

    if (GlobalWinNT) {

        ScramblingLibraryHandle = LoadLibraryA( "NTDLL.DLL" );

        if (!AdvApi32LibraryHandle) {
            AdvApi32LibraryHandle = LoadLibraryA( "ADVAPI32.DLL" );
        }

        if (ScramblingLibraryHandle || AdvApi32LibraryHandle) {

            goto GetFnPtrs;

        } else {

            goto LoadDone;
        }
    }

    //
    // We are on Win9x. We have to look for RADMIN32.DLL only in the
    // system directory
    //

    retval = GetSystemDirectoryA( (PCHAR) &SystemPath, MAX_PATH);

    if ((retval != 0) && !(retval > MAX_PATH)) {

        //
        // succeeded in getting the system path.
        //

        for (i=0; i<MAX_PATH; i++ ) {

            if (SystemPath[i] == '\0') {

                SystemPath[i] = '\\';     // append a '\' to the end
                SystemPath[i+1] = '\0';
                i++;
                break;
            }
        }

        for (offset=0; offset <= sizeof("RADMIN32.DLL"); offset++ ) {
            SystemPath[i+offset] = DllName[offset];
        }

        IF_DEBUG(INIT_TERM) {
            LdapPrint1("Looking to load %s\n", SystemPath);
        }

        ScramblingLibraryHandle = LoadLibraryA( SystemPath );

        if (ScramblingLibraryHandle == NULL) {

            IF_DEBUG(INIT_TERM) {
                LdapPrint1("LDAP: Failed to load %s\n", SystemPath);
            }

        } else {
            IF_DEBUG(INIT_TERM) {
                LdapPrint1("Succeeded in loading %s\n", SystemPath);
            }
        }
    }

GetFnPtrs:

    GlobalUseScrambling = FALSE;

    if ((AdvApi32LibraryHandle) && (ScramblingLibraryHandle) && (GlobalWinNT)) {
        //
        // Try to get the advapi32.dll RtlEncryptMemory/RtlDecryptMemory functions,
        // along with ntdll's RtlInitUnicodeString.  Note that RtlEncryptMemory
        // and RtlDecryptMemory are really named SystemFunction040/041, hence
        // the macros.
        //

        pRtlEncryptMemory = (FRTLENCRYPTMEMORY) GetProcAddress( AdvApi32LibraryHandle, STRINGIZE(RtlEncryptMemory) );
        pRtlDecryptMemory = (FRTLDECRYPTMEMORY) GetProcAddress( AdvApi32LibraryHandle, STRINGIZE(RtlDecryptMemory) );
        pRtlInitUnicodeString = (FNRTLINITUNICODESTRING) GetProcAddress( ScramblingLibraryHandle, "RtlInitUnicodeString" );

        if (pRtlEncryptMemory && pRtlDecryptMemory && pRtlInitUnicodeString) {
            //
            // We want to use scrambling
            //
        
            GlobalUseScrambling =  TRUE;

            IF_DEBUG(INIT_TERM) {
                LdapPrint0("Using Strong Scrambling APIs\n");
            }

            goto LoadDone;
        }
        else {
            //
            // Clean up so we can try falling back to the run-encode scrambling functions
            // (we keep the AdvApi32LibraryHandle around since we'll probably need it
            // later anyway)
            //
            pRtlEncryptMemory = NULL;
            pRtlDecryptMemory = NULL;
            pRtlInitUnicodeString = NULL;
        }
    }

    if (ScramblingLibraryHandle) {

        pRtlInitUnicodeString = (FNRTLINITUNICODESTRING) GetProcAddress( ScramblingLibraryHandle, "RtlInitUnicodeString" );
        pRtlRunEncodeUnicodeString = (FRTLRUNENCODEUNICODESTRING) GetProcAddress( ScramblingLibraryHandle, "RtlRunEncodeUnicodeString" );
        pRtlRunDecodeUnicodeString = (FRTLRUNDECODEUNICODESTRING) GetProcAddress( ScramblingLibraryHandle, "RtlRunDecodeUnicodeString" );
    }

    if (!ScramblingLibraryHandle ||
        !pRtlInitUnicodeString ||
        !pRtlRunEncodeUnicodeString ||
         !pRtlRunDecodeUnicodeString) {

        //
        // If we failed to get even one of these functions, we shouldn't try scrambling
        //

        IF_DEBUG(INIT_TERM) {
            LdapPrint0("LDAP: Failed to load scrambling APIs\n");
        }

        if (ScramblingLibraryHandle) {

            FreeLibrary( ScramblingLibraryHandle );
            ScramblingLibraryHandle = NULL;
        }

        ScramblingLibraryHandle = NULL;
        pRtlInitUnicodeString = NULL;
        pRtlRunEncodeUnicodeString = NULL;
        pRtlRunDecodeUnicodeString = NULL;

    } else {
        GlobalUseScrambling = TRUE;
    
        IF_DEBUG(INIT_TERM) {
            LdapPrint0("Using Scrambling APIs\n");
        }
    }

LoadDone:
    
    if ( GlobalWinsock11 ) {

        wVersion = MAKEWORD( 1, 1 );

    } else {

        wVersion = MAKEWORD( 2, 0 );
    }

    IF_DEBUG(INIT_TERM) {
        LdapPrint0( "LDAP Client initializing Winsock.\n" );
    }

    err = (*pWSAStartup)( wVersion, &GlobalLdapWSAData );

    if (err != 0) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LDAP client failed to init Winsock, err = 0x%x.\n", (*pWSAGetLastError)());
        }
        goto error;
    }

    IF_DEBUG(INIT_TERM) {
        LdapPrint0( "LDAP Client initialized winsock.\n" );
    }

    //
    // We create the select wakeup socket.
    //

    LdapGlobalWakeupSelectHandle = (*psocket)(PF_INET, SOCK_DGRAM, 0);

    if (LdapGlobalWakeupSelectHandle == INVALID_SOCKET) {
       LdapPrint1("Failed to create socket in LdapClientInitialize: %d\n", (*pWSAGetLastError)());
       goto error;
    }

    //
    // Bind the socket to a local port
    //

    sa.sin_family = AF_INET;

    retval = (*pbind) ( LdapGlobalWakeupSelectHandle,
                       (SOCKADDR*) &sa,
                       sizeof(sa)
                       );

    if (retval != 0) {
       LdapPrint1("Failed to bind socket in LdapClientInitialize: %d\n", (*pWSAGetLastError)() );
       goto error;
    }

    //
    // Find out which port the system bound the socket to
    //

    retval = (*pgetsockname) ( LdapGlobalWakeupSelectHandle,
                              (SOCKADDR*) &sa,
                              &buffersize
                              );

    if (retval != 0) {
       LdapPrint1("Failed in getsockname in LdapClientInitialize: %d\n", (*pWSAGetLastError)() );
       goto error;
    }

    //
    // Connect the socket to itself
    //

    sa.sin_family = AF_INET;
    sa.sin_addr.s_addr = (*pinet_addr)("127.0.0.1");
    retval = (*pconnect)( LdapGlobalWakeupSelectHandle,
                         (SOCKADDR*) &sa,
                         sizeof( sa )
                         );

    if (retval != 0) {
       LdapPrint1("Failed to connect socket to itself in LdapClientInitialize: %d\n", (*pWSAGetLastError)() );
       goto error;
    }

    //
    // Mark it non-blocking so that sends and receives don't block
    //

    retval = (*pioctlsocket)( LdapGlobalWakeupSelectHandle,
                              FIONBIO,
                              &nonblockingMode
                              );

    if (retval != 0) {
       LdapPrint1("Failed to set socket to nonblocking in LdapClientInitialize: %d\n", (*pWSAGetLastError)() );
       goto error;
    }

    GlobalCloseWinsock = TRUE;

    RELEASE_LOCK( &LoadLibLock );
    return TRUE;

error:
    
    if ( WinsockLibraryHandle ) {

        FreeLibrary( WinsockLibraryHandle );
        WinsockLibraryHandle = NULL;
    }

    if ( ScramblingLibraryHandle ) {

        FreeLibrary( ScramblingLibraryHandle );
        ScramblingLibraryHandle = NULL;
    }
    
    RELEASE_LOCK( &LoadLibLock );
    return FALSE;

}


BOOL
LdapClientTerminate (
    BOOL AllClean
    )
//
//  The DLL is being unloaded from memory.  Cleanup all resources allocated.
//
{
    PLDAP_CONN connection;
    PLIST_ENTRY listEntry;
    PLDAP_REQUEST request;
    PLDAP_MESSAGEWAIT waitStructure;
    PTHREAD_ENTRY pEntry;


    IF_DEBUG(INIT_TERM) {
        LdapPrint0( "LDAP Client API 32 terminating.\n" );
    }

    //
    //  close (immediately) all active connections
    //

    if ( GlobalLdapShutdownEvent != NULL ) {

       ResetEvent( GlobalLdapShutdownEvent );
    }

    GlobalLdapShuttingDown = TRUE;

    if (GlobalHasInitialized == FALSE) {

        // We didn't (completely) initialize, so nothing to clean up.
        // Partial initialization prior to GlobalHasInitialized being set
        // to TRUE would have cleaned up after itself when it failed.

        IF_DEBUG(INIT_TERM) {
            LdapPrint0( "LDAP Client API 32 termination after incomplete initialization.\n" );
        }

        return TRUE;
    }

    //
    //  close all requests
    //

    if (AllClean) {

        ACQUIRE_LOCK( &RequestListLock );

        listEntry = GlobalListRequests.Flink;

        while (listEntry != &GlobalListRequests) {

            request = CONTAINING_RECORD( listEntry, LDAP_REQUEST, RequestListEntry );
            request = ReferenceLdapRequest(request);

            if (! request) {

                listEntry = listEntry->Flink;
                continue;
            }

            RELEASE_LOCK( &RequestListLock );

            CloseLdapRequest( request );

            DereferenceLdapRequest( request );

            ACQUIRE_LOCK( &RequestListLock );

            listEntry = GlobalListRequests.Flink;
        }

        RELEASE_LOCK( &RequestListLock );
    }

    //
    //  shutdown all connections
    //

    ACQUIRE_LOCK( &ConnectionListLock );

    listEntry = GlobalListActiveConnections.Flink;

    while (listEntry != &GlobalListActiveConnections) {

        connection = CONTAINING_RECORD( listEntry, LDAP_CONN, ConnectionListEntry );

        connection = ReferenceLdapConnection( connection );

        if (!connection) {

            listEntry = listEntry->Flink;
            continue;
        }

        RELEASE_LOCK( &ConnectionListLock );

        //
        //  CloseLdapConnection MUST set the state to closing or we loop here.
        //

        CloseLdapConnection( connection);

        DereferenceLdapConnection( connection );

        ACQUIRE_LOCK( &ConnectionListLock );

        listEntry = GlobalListActiveConnections.Flink;
    }

    //
    //  Let all waiters go.
    //

    listEntry = GlobalListWaiters.Flink;

    while (listEntry != &GlobalListWaiters) {

        waitStructure = CONTAINING_RECORD( listEntry,
                                           LDAP_MESSAGEWAIT,
                                           WaitListEntry );
        listEntry = listEntry->Flink;

        waitStructure->Satisfied = TRUE;
        SetEvent( waitStructure->Event );
    }

    RELEASE_LOCK( &ConnectionListLock );

    if (GlobalWaiterCount > 0 &&
        GlobalLdapShutdownEvent != NULL ) {

        IF_DEBUG(INIT_TERM) {
            LdapPrint1( "LdapClientTerminate waiting for 0x%x threads.\n",
                        GlobalWaiterCount );
        }

        WaitForSingleObjectEx( GlobalLdapShutdownEvent,
                               INFINITE,
                               TRUE );         // alertable
    }

    if ( GlobalLdapShutdownEvent != NULL ) {

        CloseHandle( GlobalLdapShutdownEvent );
        GlobalLdapShutdownEvent = NULL;
    }

    //
    // Destroy the per-thread list.
    // This requires destroying the per-thread entry for each
    // thread in the list.
    //
    ACQUIRE_LOCK( &PerThreadListLock );

    while (!IsListEmpty(&GlobalPerThreadList)) {

        // Get the first entry and free it (RemovePerThreadEntry will take
        // care of removing it from the list & deallocating the memory)
        pEntry = CONTAINING_RECORD(GlobalPerThreadList.Flink, THREAD_ENTRY, ThreadEntry);
        RemovePerThreadEntry(pEntry->dwThreadID);
    }
    
    RELEASE_LOCK( &PerThreadListLock );

    //
    // Clean up our cache pages.
    //

    ACQUIRE_LOCK( &CacheLock );
    FreeEntireLdapCache();
    RELEASE_LOCK( &CacheLock );

    DELETE_LOCK( &CacheLock );
    DELETE_LOCK( &ConnectionListLock );
    DELETE_LOCK( &RequestListLock );

    if (LdapHeap != NULL &&
        LdapHeap != GetProcessHeap()) {

        HeapDestroy( LdapHeap );
        LdapHeap = NULL;
    }

    if (GlobalCloseWinsock) {

        GlobalCloseWinsock = FALSE;
        (*pWSACleanup)();
    }

    if (SslPackagesInstalled != NULL) {

        SslFunctionTableW->FreeContextBuffer( SslPackagesInstalled );
        SslPackagesInstalled = NULL;
    }

    if (SslLibraryHandle != NULL) {

        FreeLibrary( SslLibraryHandle );
        SslLibraryHandle = NULL;
    }

    if (ScramblingLibraryHandle != NULL) {

        FreeLibrary( ScramblingLibraryHandle );
        ScramblingLibraryHandle = NULL;
    }

    if (SecurityPackagesInstalled != NULL) {

        SspiFunctionTableW->FreeContextBuffer( SecurityPackagesInstalled );
        SecurityPackagesInstalled = NULL;
    }

    if (SecurityLibraryHandle != NULL) {

        FreeLibrary( SecurityLibraryHandle );
        SecurityLibraryHandle = NULL;
    }

    if ( LdapGlobalWakeupSelectHandle != INVALID_SOCKET ) {

        int sockerr = (*pclosesocket)(LdapGlobalWakeupSelectHandle);
        ASSERT(sockerr == 0); 
        LdapGlobalWakeupSelectHandle = INVALID_SOCKET;
    }

    if (WinsockLibraryHandle != NULL) {

        FreeLibrary( WinsockLibraryHandle );
        WinsockLibraryHandle = NULL;
    }

    if (NetApi32LibraryHandle != NULL) {

        FreeLibrary( NetApi32LibraryHandle );
        NetApi32LibraryHandle = NULL;
    }

    if (AdvApi32LibraryHandle != NULL) {

        FreeLibrary( AdvApi32LibraryHandle );
        AdvApi32LibraryHandle = NULL;
    }

    UnloadPingLibrary();

    if (GlobalTlsLastErrorIndex != (DWORD) -1) {

        TlsFree( GlobalTlsLastErrorIndex );
        GlobalTlsLastErrorIndex = (DWORD) -1;
    }

    DELETE_LOCK( &LoadLibLock );
    DELETE_LOCK( &SelectLock1 );
    DELETE_LOCK( &SelectLock2 );
    DELETE_LOCK( &PerThreadListLock );
    
    IF_DEBUG(INIT_TERM) {
        LdapPrint0( "LDAP Client API 32 termination complete.\n" );
    }

    return TRUE;
}

ULONG __cdecl ldap_startup (
    PLDAP_VERSION_INFO version,
    HANDLE *hInstance
    )
{
    BOOL rc;

    DBG_UNREFERENCED_PARAMETER( hInstance );

    //
    //  we may make this more complicated in future versions.
    //

    if ((version->lv_size != sizeof(LDAP_VERSION)) ||
        (version->lv_major != LAPI_MAJOR_VER1) ||
        (version->lv_minor != LAPI_MINOR_VER1)) {

        return LDAP_OPERATIONS_ERROR;
    }

    //
    //  Set to highest level we support.
    //

    version->lv_major = LAPI_MAJOR_VER1;
    version->lv_minor = LAPI_MINOR_VER1;

    rc = LdapClientInitialize( GlobalLdapDllInstance );

    return( (rc == TRUE) ? LDAP_SUCCESS : LDAP_OPERATIONS_ERROR );
}


ULONG __cdecl ldap_cleanup (
    HANDLE hInstance
    )
//
//  Cleanup all resources owned by library.
//
{
    ULONG prevRefCount;
    BOOL rc;

    DBG_UNREFERENCED_PARAMETER( hInstance );
    
    prevRefCount = InterlockedDecrement( &GlobalLoadUnloadRefCount );

    if (prevRefCount > 0) {

        return LDAP_SUCCESS;
    }

    rc = LdapClientTerminate( TRUE );

    return( (rc == TRUE) ? LDAP_SUCCESS : LDAP_OPERATIONS_ERROR );
}

// initterm.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\ldapp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ldapp.h   LDAP client 32 API header file... internal structures

Abstract:

   This module is the header file for the 32 bit LDAP client API code...
   it contains all interal data structures.

Author:

    Andy Herron    (andyhe)        08-May-1996
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/


#ifndef LDAP_CLIENT_INTERNAL_DEFINED
#define LDAP_CLIENT_INTERNAL_DEFINED

#define LDAP_DEFAULT_LOCALE LOCALE_USER_DEFAULT

#define PLDAPDN PWCHAR

typedef struct ldap_memory_descriptor {

    ULONG Tag;
    DWORD Length;

} LDAP_MEMORY_DESCRIPTOR, *PLDAP_MEMORY_DESCRIPTOR;


// the following signature is "Lsec"

#define LDAP_SECURITY_SIGNATURE 0x6365734c

#define GENERIC_SECURITY_SIZE 1024

//
// State of the connection object
// Closed objects are kept alive till their ref count drops to zero.
// Ref count of a non-active object should never be incremented - it
// should be treated as dead as far as new users are concerned.
//

#define ConnObjectActive          1
#define ConnObjectClosing         2
#define ConnObjectClosed          3

//
// State of the connection inside the connection object
// These are valid only if the connection object is active
//

#define HostConnectStateUnconnected     0x01
#define HostConnectStateConnecting      0x02
#define HostConnectStateReconnecting    0x04
#define HostConnectStateConnected       0x08
#define HostConnectStateError           0x10

#define DEFAULT_NEGOTIATE_FLAGS (ISC_REQ_MUTUAL_AUTH | ISC_RET_EXTENDED_ERROR)

//
//  The LDAP_CONNECTION block is one of the principal data structure for
//  this library.  It tracks the following :
//
//   - destination server info (name, address, credentials, etc)
//   - outstanding receives from this server
//   - completed receives from this server
//   - stats and other per connection info
//
//  It contains within it the non-opaque structure exposed through the API
//  that is compatible with the reference implementation not only at the
//  source level but also at the obj level.  ( That is, the fields such as
//  sb_naddr that are exposed in the reference implementation correspond in
//  offset to the friendlier names in this structure at the same offset.  In
//  the case of sb_naddr, it corresponds to UdpHandle. )
//
//  All important fields that we don't want theoritically trashed by the client
//  (since it's not clear what fields apps will use in the reference
//  implementation) are in front of the external structure in the larger
//  overall structure.  That is, we only pass back a pointer to TcpHandle and
//  below and everything above should never be touched by the client).
//
//
//  This MUST match the ldap structure in WINLDAP.H!  We just have it here
//  so that we can use friendly names and hide opaque fields.
//

#if !defined(_WIN64)
#pragma pack(push, 4)
#endif

typedef struct ldap_connection {

    LONG    ReferenceCount;         // for lifetime management

    LIST_ENTRY ConnectionListEntry;
    LIST_ENTRY PendingCryptoList;
    LIST_ENTRY CompletedReceiveList;

    PLDAPMessage PendingMessage;    // pointer to LDAP message structure
                                    // that we're currently receiving.  This
                                    // is used for receiving a message that
                                    // spans multiple packets.

    ULONG   MaxReceivePacket;
    ULONG   HandlesGivenToCaller;   // number of times we've given handle
                                    // to caller
    ULONG   HandlesGivenAsReferrals; // protected by ConnectionListLock.

    PLDAPDN DNOnBind;               // user name specified in bind
    LDAP_LOCK ScramblingLock;       // protects access to the credentials.
    PWCHAR  CurrentCredentials;     // user credentials specified on bind
    UNICODE_STRING ScrambledCredentials; // contains the password part of CurrentCredentials
    BOOLEAN Scrambled;              // are the credentials scrambled ?
    ULONG   BindMethod;             // method specified on bind
    HANDLE  ConnectEvent;           // handle to wait on for during connect

    LUID    CurrentLogonId;
    CredHandle hCredentials;        // credential handle from SSPI
    BOOLEAN UserSignDataChoice;     // user's choice of whether to sign data
    BOOLEAN UserSealDataChoice;     // user's choice of whether to seal data
    BOOLEAN CurrentSignStatus;      // whether signing or sealing are CURRENTLY
    BOOLEAN CurrentSealStatus;      //   being used on this connection
    BOOLEAN WhistlerServer;          // is server at least Whister?
    BOOLEAN SupportsGSSAPI;         // server advertises that it supports GSSAPI
    BOOLEAN SupportsGSS_SPNEGO;     // server advertises that it supports GSS-SPNEGO
    BOOLEAN SupportsDIGEST;          // server advertises that it supports DIGEST-MD5
    ULONG   HighestSupportedLdapVersion;  // server advertised LDAP version.
    TimeStamp  CredentialExpiry;    // local time credential expires.
    CtxtHandle SecurityContext;

    struct sockaddr_in SocketAddress;

    PWCHAR   ListOfHosts;            // pointer to list of hosts.
    BOOLEAN  ProcessedListOfHosts;   // whether ListOfHosts has been processed into NULL-sep list
    BOOLEAN  DefaultServer;          // whether user requested we find default server/domain (passed in NULL init/open)
    BOOLEAN  AREC_Exclusive;         // the given host string is not a domain name.
    BOOLEAN  ForceHostBasedSPN;      // force use of LdapMakeServiceNameFromHostName to generate SPN
    PWCHAR   ServiceNameForBind;     // service name for kerberos bind
    PWCHAR   ExplicitHostName;       // host name given to us by caller
    PWCHAR   DnsSuppliedName;        // host name supplied by DNS
    PWCHAR   DomainName;             // Domain name returned from DsGetDcName
    PWCHAR   HostNameW;              // Unicode version of LDAP_CONN.HostName
    PCHAR    OptHostNameA;           // Placeholder for the ANSI value returned from LDAP_OPT_HOSTNAME
                                     // which we need to free during ldap_unbind

    PLDAP    ExternalInfo;           // points to lower portion of this structure
    ULONG    GetDCFlags;             // flags ORed in on DsGetDCName
    ULONG    NegotiateFlags;         // Flags for Negotiate SSPI provider.

    //
    //  fields required for keep alive logic
    //

    LONG        ResponsesExpected;      // number of responses that are pending
    ULONGLONG   TimeOfLastReceive;      // tick count that we last received a response.
    ULONG       KeepAliveSecondCount;
    ULONG       PingWaitTimeInMilliseconds;
    USHORT      PingLimit;
    USHORT      NumberOfPingsSent;      // number of unanswered pings we've sent before closing
    USHORT      GoodConsecutivePings;   // number of consecutive answered pings we've sent before closing
    BOOLEAN     UseTCPKeepAlives;       // whether to turn on TCP's keep-alive functionality

    USHORT  NumberOfHosts;
    USHORT  PortNumber;             // port number used on connect

    LDAP_LOCK StateLock;            // protect updates to states below
    UCHAR     ConnObjectState;      // state of connection object
    UCHAR     HostConnectState;     // have we connected to the server?
    BOOLEAN   ServerDown;           // State of server
    BOOLEAN   AutoReconnect;        // whether autoreconnect is desired
    BOOLEAN   UserAutoRecChoice;    // User's choice for Autoreconnect.
    BOOLEAN   Reconnecting;
    LDAP_LOCK ReconnectLock;        // to single thread autoreconnect requests
    LONG      WaiterCount;          // Number of threads waiting on this connection
    ULONGLONG LastReconnectAttempt; // Timestamp of last Autoreconnect attempt

    //
    // Bind data for this connection.
    //
    BOOLEAN BindInProgress;         // Are we currently exchanging bind packets?
    BOOLEAN SspiNeedsResponse;      // Does SSPI need the server response?
    BOOLEAN SspiNeedsMoreData;      // Is the SSPI token incomplete?
    BOOLEAN TokenNeedsCompletion;   // Does SSPI need to complete the token before we
                                    //     send it to the server?
    BOOLEAN BindPerformed;          // Is the bind complete?
    BOOLEAN SentPacket;             // have we sent a packet to this connection?
    BOOLEAN SslPort;                // Is this a connection to a well known SSL port 636/3269?
    BOOLEAN SslSetupInProgress;     // Are we currently setting up an SSL session?

    ULONG   PreTLSOptions;          // Referral chasing options prior to Starting TLS.

    BOOLEAN PromptForCredentials;   // do we prompt for credentials?

    PSecPkgInfoW PreferredSecurityPackage; // User wants to use this package if possible
    PWCHAR  SaslMethod;             // The preferred SASL method for this connection

    //
    //  when this flag is set to true, we reference connections for each
    //  message we get in for all the requests with this connection as primary.
    //

    BOOLEAN ReferenceConnectionsPerMessage;

    PLDAPMessage BindResponse;      // The response that holds the inbound token.

    //
    // The sicily server authentication requires a different bind method
    // number depending on which packet of the authentication sequence
    // we are currently in (YUCK), so we have to keep track.
    //

    ULONG   CurrentAuthLeg;

    //
    // Important SSL Notes:
    //
    // When we have to do an SSL send, we may have to break the message up
    // into multiple crypto blocks.  We MUST send these blocks in order and
    // back to back without any intervening sends.  The SocketLock protects
    // sends and socket closures on the connection in this manner; any thread
    // wishing to do a send on an SSL connection MUST acquire this lock.
    //

    PVOID   SecureStream;              // Crypto stream object (handles all SSPI details).
    CRITICAL_SECTION SocketLock;

    //
    //  Callback routines to allow caching of connections by ADSI etc.
    //

    QUERYFORCONNECTION *ReferralQueryRoutine;
    NOTIFYOFNEWCONNECTION *ReferralNotifyRoutine;
    DEREFERENCECONNECTION *DereferenceNotifyRoutine;

    //
    //  Callback routines to allow specifying client certificates and validating
    //  server certificates.
    //

    QUERYCLIENTCERT *ClientCertRoutine;
    VERIFYSERVERCERT *ServerCertRoutine;

    //
    //  this is considered the top of the struct LDAP structure that we pass
    //  back to the application.
    //

    LDAP publicLdapStruct;

} LDAP_CONN, * PLDAP_CONN;

#if !defined(_WIN64)
#pragma pack(pop)
#endif

#define TcpHandle    publicLdapStruct.ld_sb.sb_sd
#define UdpHandle    publicLdapStruct.ld_sb.sb_naddr

//  the following signature is "LCon"

#define LDAP_CONN_SIGNATURE 0x6e6f434c

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise.  It is followed by two macros for setting and clearing
//  flags
//

#define BooleanFlagOn(Flags,SingleFlag) \
    ((BOOLEAN)((((Flags) & (SingleFlag)) !=0)))

#define SetFlag(Flags,SingleFlag) { \
    (Flags) |= (SingleFlag);        \
}

#define ClearFlag(Flags,SingleFlag) { \
    (Flags) &= ~(SingleFlag);         \
}


//
// Entry that we keep off the THREAD_ENTRY block per connection that is being
// used on this thread.
//

typedef struct error_entry {

   struct error_entry * pNext;
   
   PLDAP_CONN Connection;        // primary connection
   ULONG      ThreadId;          // Thread for which this error applies
   PWCHAR     ErrorMessage;      // Error message

} ERROR_ENTRY, *PERROR_ENTRY;

//
//  Per thread current attribute for ldap_first_attribute.  This structure is
//  stored as a linked list in the THREAD_ENTRY, one for each connection being
//  used on that thread.
//

typedef struct ldap_attr_name_per_thread {

    struct ldap_attr_name_per_thread *pNext;
    DWORD  Thread;
    PLDAP_CONN PrimaryConn;
    LDAP_MEMORY_DESCRIPTOR AttrTag;
    UCHAR  AttributeName[ MAX_ATTRIBUTE_NAME_LENGTH ];
    LDAP_MEMORY_DESCRIPTOR AttrTagW;
    WCHAR  AttributeNameW[ MAX_ATTRIBUTE_NAME_LENGTH ];

} LDAP_ATTR_NAME_THREAD_STORAGE, *PLDAP_ATTR_NAME_THREAD_STORAGE;

//  the following signature is "LAtr"

#define LDAP_ATTR_THREAD_SIGNATURE 0x7274414c


//
// THREAD_ENTRY: A global linked list of these is maintained
// with one per thread.  This is used to hold the linked lists
// of per-connection error and attribute entries for that thread.
//
typedef struct thread_entry {

    LIST_ENTRY ThreadEntry;

    DWORD dwThreadID;
    PERROR_ENTRY pErrorList;
    PLDAP_ATTR_NAME_THREAD_STORAGE pCurrentAttrList;

} THREAD_ENTRY, *PTHREAD_ENTRY;

//
//  Entry that we keep off the LDAP_REQUEST block per referral we've chased
//  for this request.
//

typedef struct referral_table_entry {

    PLDAP_CONN ReferralServer;      // referenced pointer
    PWCHAR     ReferralDN;          // DN for referral
    ULONG      ScopeOfSearch;       // Scope of search
    PWCHAR     SearchFilter;        // Search Filter
    PWCHAR     *AttributeList;      // List of attributes

    PVOID      BerMessageSent;      // Message sent in BER format
    ULONG      RequestsPending;
    USHORT     ReferralInstance;    // unique ID for this referral
    BOOLEAN    SingleLevelSearch;   // is this a single level search where
                                    // subordinate referrals would be base srch
    BOOLEAN    CallDerefCallback;   // do we call caching deref callback?
    ULONG      ResentAttempts;      // how many times has this referral been resent?

} REFERRAL_TABLE_ENTRY, *PREFERRAL_TABLE_ENTRY;

//  the following signature is "LRTa"

#define LDAP_REFTABLE_SIGNATURE 0x6154524c

//  the following signature is "LRDN"

#define LDAP_REFDN_SIGNATURE 0x4e44524c

//
//  The LDAP_REQUEST block is another of the principal data structure for
//  this library.  Most other structures are linked off of it.
//  It tracks the following :
//
//   - list of responses received for this request, including referred
//   - list of connections that this Request has used.
//   - resource lock to protect lists and other important fields
//
typedef struct ldap_request {

    LIST_ENTRY RequestListEntry;
    LONG    ReferenceCount;

    PLDAPMessage MessageLinkedList; // pointer to head... pulled from here
    PLDAP_CONN PrimaryConnection;   // referenced pointer

    //
    // SecondayConnection points to an external referred server (if one exists)
    // We redirect all of our paged searches to this searver
    //

    PLDAP_CONN SecondaryConnection;

    LDAP_LOCK   Lock;
    ULONGLONG   RequestTime;
    ULONG   TimeLimit;          // 0 implies no limit
    ULONG   SizeLimit;          // 0 implies no limit

    ULONG   ReturnCode;         // error returned by server
    LONG    MessageId;          // unique across all connections

    //
    //  Per Request per Connection, we maintain a count of how many requests we
    //  have outstanding.  This allows us to not hang when we call into
    //  DrainWinsock when we really don't have anything to wait on.
    //
    //  This is stored off of the request block, where it's traversed at abandon
    //  time.  It's cross referenced with the connection where it's searched
    //  when the connection goes down.
    //

    ULONG      RequestsPending;

    PVOID      BerMessageSent;      // Message sent in BER format
    PREFERRAL_TABLE_ENTRY ReferralConnections;  // pointer to table

    USHORT  ReferralTableSize;
    USHORT  ReferralHopLimit;
    USHORT  ReferralCount;      // incremented every time we chase a new one

    //
    //  Track the number of requests to different servers we have open such
    //  that we don't stop returning data prematurely.
    //

    USHORT  ResponsesOutstanding;   // sum of requests pending for all referrals

    BOOLEAN Abandoned;

    UCHAR ChaseReferrals;
    UCHAR Operation;

    //
    //  If the call is synchronous, then the pointers that we have below for
    //  the different parameters are not allocated, they simply point back to
    //  the original caller's parameters.
    //

    BOOLEAN Synchronous;

    //
    //  When this has been closed, this will be true.
    //

    BOOLEAN Closed;

    //
    //  when this flag is set to true, we reference connections for each
    //  message we get in so that the app can call ldap_conn_from_msg.
    //

    BOOLEAN ReferenceConnectionsPerMessage;

    //
    // When a notification control is detected, we set this to TRUE to
    // avoid deleting the BER request buffer upon returning notifications.
    //

    BOOLEAN NotificationSearch;

    //
    //  These store the original parameters for each operation. We have to
    //  store these since chasing a referral may mean we need to regenerate
    //  the ASN1 since the DN can change.
    //

    PWCHAR OriginalDN;

    PLDAPControlW *ServerControls;      // array of controls
    PLDAPControlW *ClientControls;      // array of controls

    struct ldap_request *PageRequest;   // Original Page request
    LDAP_BERVAL  *PagedSearchServerCookie;

    union {

        struct {
            LDAPModW **AttributeList;
            BOOLEAN Unicode;
        } add;

        struct {
            PWCHAR Attribute;
            PWCHAR Value;
            struct berval   Data;
        } compare;

        struct {
            LDAPModW **AttributeList;
            BOOLEAN Unicode;
        } modify;

        struct {
            PWCHAR   NewDistinguishedName;
            PWCHAR   NewParent;
            INT      DeleteOldRdn;
        } rename;

        struct {
            ULONG   ScopeOfSearch;
            PWCHAR  SearchFilter;
            PWCHAR  *AttributeList;
            ULONG   AttributesOnly;
            BOOLEAN Unicode;
        } search;

        struct {
            struct berval Data;
        } extended;
    };

    LONG    PendingPagedMessageId;

    BOOLEAN GotExternalReferral;    // we have to send requests to an alternate
                                    // server (PrimaryConnection->ExternalReferredServer)

    BOOLEAN AllocatedParms;

    BOOLEAN AllocatedControls;

    BOOLEAN PagedSearchBlock;       // is this a block controlling a paged
                                    // search?  if FALSE, then normal request

    BOOLEAN ReceivedData;           // have we received data on this paged
                                    // search request?  also used on non-paged.

    BOOLEAN CopyResultToCache;      // Before closing the request, copy result
                                    // contents to cache

    BOOLEAN ResultsAreCached;       // Don't go to the wire to get results. They
                                    // are already queued to your recv buffers

    ULONG ResentAttempts;           // Number of times this request has been
                                    // resent during autoreconnects

} LDAP_REQUEST, * PLDAP_REQUEST;

//  the following signature is "LReq"

#define LDAP_REQUEST_SIGNATURE 0x7165524c

//
//  The LDAP_RECVBUFFER structure is used to receive a server's response.
//  It contains the necessary fields to passdown to the transport through
//  winsock to receive data.
//
//  These are linked into the LDAP_CONN structure via the CompletedReceiveList
//  for messages that have already been received.
//
//  The CompletedReceiveList is ordered... newly received LDAP_RECVBUFFER
//  structures are put on the end.  This is so that if a server sends
//  responses ordered, we maintain the order when we pass the results up to
//  the calling program.
//

typedef struct ldap_recvbuffer {

    PLDAP_CONN Connection;

    LIST_ENTRY ReceiveListEntry;

    DWORD   NumberOfBytesReceived;
    DWORD   NumberOfBytesTaken; // number of bytes already copied off to msgs

    DWORD   BufferSize;

    UCHAR   DataBuffer[1];

} LDAP_RECVBUFFER, * PLDAP_RECVBUFFER;

//  the following signature is "LRec"

#define LDAP_RECV_SIGNATURE 0x6365524c

//
//  this structure is used to track the messages we have to check for waiters.
//  we store them off rather than calling directly so as not to muck with the
//  locking order.
//

typedef struct message_id_list_entry {

    struct message_id_list_entry *Next;
    ULONG MessageId;

} MESSAGE_ID_LIST_ENTRY, *PMESSAGE_ID_LIST_ENTRY;

#define LDAP_MSGID_SIGNATURE 0x64494d4c

//
//  The LDAP_MESSAGEWAIT structure is used by a thread that wants to wait for
//  a message from a server.
//  It allocates one by calling LdapGetMessageWaitStructure
//  This initializes an event the thread can wait on and puts the block on
//  a global list of waiting threads.
//
//  When a message comes in, the receive thread will satisfy a wait for a thread
//  on the waiters list.  This thread will then process the message and satisfy
//  any other waiters that should be.
//
//  These structures are freed by the calling thread using
//  LdapFreeMessageWaitStructure.
//
//  The structure has a few fields of interest :
//    - event for thread to wait on that is triggered when message comes in
//    - message number that waiting thread is interested in (0 if interested
//      in all messages from server)
//    - list entry for list of outstanding wait structures
//    - connection that client is interested in, null is ok.  Just means the
//      thread is waiting for any message
//

typedef struct ldap_messagewait {

    LIST_ENTRY WaitListEntry;
    PLDAP_CONN Connection;          // referenced pointer

    HANDLE Event;
    ULONG  MessageNumber;           // may be zero
    ULONG   AllOfMessage;       // for search results, trigger at last response?
    BOOLEAN Satisfied;
    BOOLEAN PendingSendOnly;    // is this wait only a pending send?

} LDAP_MESSAGEWAIT, * PLDAP_MESSAGEWAIT;


typedef struct _SOCKHOLDER {

   SOCKET sock;                    // socket used in the connection
   LPSOCKET_ADDRESS psocketaddr;   // corresponding  pointer to connecting address
   PWCHAR DnsSuppliedName;         // Name returned from DNS

} SOCKHOLDER, *PSOCKHOLDER;

typedef struct _SOCKHOLDER2 {

   LPSOCKET_ADDRESS psocketaddr;   // address to connect to
   PWCHAR DnsSuppliedName;         // Name returned from DNS

} SOCKHOLDER2, *PSOCKHOLDER2;


typedef struct _LDAPReferralDN
{
    PWCHAR   ReferralDN;     // DN present in the referral
    PWCHAR * AttributeList;  // Attributes requested
    ULONG    AttribCount;    // Number of attributes requested
    ULONG    ScopeOfSearch;  // Search scope
    PWCHAR   SearchFilter;   // search filter
    PWCHAR   Extension;      // Extension part of the URL
    PWCHAR   BindName;       // A bindname extension for the URL

} LDAPReferralDN, * PLDAPReferralDN;


typedef struct _EncryptHeader_v1
{
   ULONG EncryptMessageSize;

} EncryptHeader_v1, *PEncryptHeader_v1;

//
// On the wire, the following signature appears as "ENCRYPTD"
//

#define LDAP_ENCRYPT_SIGNATURE 0x4454505952434e45

//
// hd.exe which is found in the idw directory was used to create these tags.
//


//  the following signature is "LWai"

#define LDAP_WAIT_SIGNATURE 0x6961574c

//  the following signature is "LBer"

#define LDAP_LBER_SIGNATURE 0x7265424c

//  the following signature is "LMsg"

#define LDAP_MESG_SIGNATURE 0x67734d4c

//  the following signature is "LStr"

#define LDAP_STRING_SIGNATURE 0x7274534c

//  the following signature is "LVal"

#define LDAP_VALUE_SIGNATURE 0x6C61564c

//  the following signature is "LVll"

#define LDAP_VALUE_LIST_SIGNATURE 0x6C6C564c

//  the following signature is "LBuf"

#define LDAP_BUFFER_SIGNATURE 0x6675424c

//  the following signature is "LUDn"

#define LDAP_USER_DN_SIGNATURE 0x6e44554c

//  the following signature is "LGDn"

#define LDAP_GENERATED_DN_SIGNATURE 0x6e44474c

//  the following signature is "LCre"

#define LDAP_CREDENTIALS_SIGNATURE 0x6572434c

//  the following signature is "LBCl"

#define LDAP_LDAP_CLASS_SIGNATURE 0x6c43424c

//  the following signature is "LAns"

#define LDAP_ANSI_SIGNATURE 0x736e414c

//  the following signature is "LUni"

#define LDAP_UNICODE_SIGNATURE 0x696e554c

//  the following signature is "LSsl"

#define LDAP_SSL_CLASS_SIGNATURE 0x6c73534c

//  the following signature is "LAtM"

#define LDAP_ATTRIBUTE_MODIFY_SIGNATURE 0x4d74414c

//  the following signature is "LMVa"

#define LDAP_MOD_VALUE_SIGNATURE 0x61564d4c

//  the following signature is "LMVb"

#define LDAP_MOD_VALUE_BERVAL_SIGNATURE 0x62564d4c

//  the following signature is "LSel"

#define LDAP_SELECT_READ_SIGNATURE 0x6c65534c

//  the following signature is "LCnt"

#define LDAP_CONTROL_SIGNATURE 0x746e434c

//  the following signature is "LCrl"

#define LDAP_CONTROL_LIST_SIGNATURE 0x6c72434c

//  the following signature is "LBad"

#define LDAP_DONT_FREE_SIGNATURE 0x6461424c

//  the following signature is "LFre"

#define LDAP_FREED_SIGNATURE 0x6572464c

//  the following signature is "LExO"

#define LDAP_EXTENDED_OP_SIGNATURE 0x4f78454c

//  the following signature is "LCda"

#define LDAP_COMPARE_DATA_SIGNATURE 0x6164434c

//  the following signature is "LEsc"

#define LDAP_ESCAPE_FILTER_SIGNATURE 0x6373454c

//  the following signature is "LHst"

#define LDAP_HOST_NAME_SIGNATURE 0x7473484c

//  the following signature is "LBvl"

#define LDAP_BERVAL_SIGNATURE 0x6c76424c

//  the following signature is "LSrv"

#define LDAP_SERVICE_NAME_SIGNATURE 0x7672534c

//  the following signature is "LSdr"

#define LDAP_SOCKADDRL_SIGNATURE 0x7264534c

//  the following signature is "LErr"

#define LDAP_ERROR_SIGNATURE 0x7272454c

//  the following signature is "LUrl"

#define LDAP_URL_SIGNATURE 0x6c72554c

//  the following signature is "LSal"

#define LDAP_SASL_SIGNATURE 0x6c61534c

// the following signature is "LThd"

#define LDAP_PER_THREAD_SIGNATURE 0x6c546864

//
//  function declarations
//

PLDAP_CONN
GetConnectionPointer(
    LDAP *ExternalHandle
    );

PLDAP_CONN
GetConnectionPointer2(
    LDAP *ExternalHandle
    );

PLDAP_CONN
ReferenceLdapConnection(
    PLDAP_CONN Connection
    );

PLDAP_REQUEST
ReferenceLdapRequest(
    PLDAP_REQUEST request
    );

BOOL
LdapInitializeWinsock (
    VOID
    );

VOID
CloseLdapConnection (
    PLDAP_CONN Connection
    );

PLDAP_CONN
LdapAllocateConnection (
    PWCHAR HostName,
    ULONG PortNumber,
    ULONG Secure,
    BOOLEAN Udp
    );

VOID
DereferenceLdapConnection2 (
    PLDAP_CONN connection
    );

LPVOID
ldapMalloc (
    DWORD Bytes,
    ULONG Tag
    );

VOID
ldapFree (
    LPVOID Block,
    ULONG  Tag
    );

BOOLEAN
ldapSwapTags (
    LPVOID Block,
    ULONG  OldTag,
    ULONG  NewTag
    );

VOID
ldap_MoveMemory (
    PCHAR dest,
    PCHAR source,
    ULONG length
    );

PLDAP_REQUEST LdapCreateRequest (
    PLDAP_CONN Connection,
    UCHAR Operation
    );

VOID
DereferenceLdapRequest2 (
    PLDAP_REQUEST Request
    );

PLDAP_RECVBUFFER
LdapGetReceiveStructure (
    DWORD cbBuffer
    );

VOID
LdapFreeReceiveStructure (
    IN PLDAP_RECVBUFFER ReceiveBuffer,
    IN BOOLEAN HaveLock
    );

PLDAP_MESSAGEWAIT
LdapGetMessageWaitStructure (
    IN PLDAP_CONN Connection,
    IN ULONG CompleteMessages,
    IN ULONG MessageNumber,
    IN BOOLEAN PendingSendOnly
    );

VOID
LdapFreeMessageWaitStructure (
    PLDAP_MESSAGEWAIT Message
    );

VOID
CloseLdapRequest (
    PLDAP_REQUEST Request
    );

PLDAP_REQUEST
FindLdapRequest(
    LONG MessageId
    );

PCHAR
ldap_dup_string (
    PCHAR String,
    ULONG Extra,
    ULONG Tag
    );

PWCHAR
ldap_dup_stringW (
    PWCHAR String,
    ULONG Extra,
    ULONG Tag
    );

ULONG
add_string_to_list (
    PWCHAR **ArrayToReturn,
    ULONG *ArraySize,
    PWCHAR StringToAdd,
    BOOLEAN CreateCopy
    );

VOID
SetConnectionError (
    PLDAP_CONN Connection,
    ULONG   LdapError,
    PCHAR   DNNameInError
    );

ULONG
HandleReferrals (
    PLDAP_CONN Connection,
    PLDAPMessage *FirstSearchEntry,
    PLDAP_REQUEST Request
    );

ULONG
LdapSendCommand (
    PLDAP_CONN Connection,
    PLDAP_REQUEST Request,
    USHORT ReferralNumber
    );

ULONG
LdapBind (
    PLDAP_CONN connection,
    PWCHAR BindDistName,
    ULONG Method,
    PWCHAR BindCred,
    BOOLEAN Synchronous
    );

BOOLEAN
LdapInitSecurity (
    VOID
    );

BOOLEAN
LdapInitSsl (
    VOID
    );

BOOLEAN
CheckForNullCredentials (
    PLDAP_CONN Connection
    );

VOID
CloseCredentials (
    PLDAP_CONN Connection
    );

VOID
SetNullCredentials (
    PLDAP_CONN Connection
    );

ULONG
LdapConvertSecurityError (
    PLDAP_CONN Connection,
    SECURITY_STATUS sErr
    );

ULONG
LdapSspiBind (
    PLDAP_CONN Connection,
    PSecPkgInfoW Package,
    ULONG UserMethod,
    ULONG SspiFlags,
    PWCHAR UserName,
    PWCHAR TargetName,
    PWCHAR Credentials
    );

ULONG
LdapGetSicilyPackageList(
    PLDAP_CONN Connection,
    PBYTE PackageList,
    ULONG Length,
    PULONG pResponseLen
    );

VOID
LdapClearSspiState(
    PLDAP_CONN Connection
);

ULONG
LdapSetSspiContinueState(
    PLDAP_CONN Connection,
    SECURITY_STATUS sErr
    );

ULONG
LdapExchangeOpaqueToken(
    PLDAP_CONN Connection,
    ULONG UserMethod,
    PWCHAR MethodOID,
    PWCHAR UserName,
    PVOID pOutboundToken,
    ULONG cbTokenLength,
    SecBufferDesc *pInboundToken,
    BERVAL **ServerCred,
    PLDAPControlW  *ServerControls,
    PLDAPControlW  *ClientControls,
    PULONG  MessageNumber,
    BOOLEAN SendOnly,
    BOOLEAN Unicode,
    BOOLEAN * pSentMessage
    );

ULONG
LdapTryAllMsnAuthentication(
    PLDAP_CONN Connection,
    PWCHAR BindCred
    );

ULONG
LdapSetupSslSession (
    PLDAP_CONN Connection
    );

DWORD
LdapSendRaw (
    IN PLDAP_CONN Connection,
    PCHAR Data,
    ULONG DataCount
    );

DWORD
GetDefaultLdapServer(
    PWCHAR DomainName,
    LPWSTR Addresses[],
    LPWSTR DnsHostNames[],
    LPWSTR MemberDomains[],
    LPDWORD Count,
    ULONG DsFlags,
    BOOLEAN *SameSite,
    USHORT PortNumber
    );

DWORD
InitLdapServerFromDomain(
    LPCWSTR DomainName,
    ULONG Flags,
    OUT HANDLE *Handle,
    LPWSTR *Site
    );

DWORD
NextLdapServerFromDomain(
    HANDLE Handle,
    LPSOCKET_ADDRESS *lpSockAddresses,
    PWCHAR *DnsHostName,
    PULONG SocketCount
    );

DWORD
CloseLdapServerFromDomain(
    HANDLE Handle,
    LPWSTR Site
    );

ULONG
ParseLdapToken (
    PWCHAR CurrentPosition,
    PWCHAR *StartOfToken,
    PWCHAR *EqualSign,
    PWCHAR *EndOfToken
);

ULONG
FromUnicodeWithAlloc (
    PWCHAR Source,
    PCHAR *Output,
    ULONG Tag,
    ULONG CodePage
    );

ULONG
ToUnicodeWithAlloc (
    PCHAR Source,
    LONG SourceLength,
    PWCHAR *Output,
    ULONG Tag,
    ULONG CodePage
    );

ULONG
strlenW(
    PWCHAR string
    );

BOOLEAN
ldapWStringsIdentical (
    PWCHAR string1,
    LONG length1,
    PWCHAR string2,
    LONG length2
    );

ULONG
DrainPendingCryptoStream (
    PLDAP_CONN Connection
    );

ULONG
LdapDupLDAPModStructure (
    LDAPModW *AttributeList[],
    BOOLEAN Unicode,
    LDAPModW **OutputList[]
);

VOID
LdapFreeLDAPModStructure (
    PLDAPModW *AttrList,
    BOOLEAN Unicode
    );

ULONG
AddToPendingList (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection
    );

VOID
DecrementPendingList (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection
    );

VOID
ClearPendingListForRequest (
    PLDAP_REQUEST Request
    );

VOID
ClearPendingListForConnection (
    PLDAP_CONN Connection
    );

ULONG
LdapCheckControls (
    PLDAP_REQUEST Request,
    PLDAPControlW *ServerControls,
    PLDAPControlW *ClientControls,
    BOOLEAN Unicode,
    ULONG   ExtraSlots
    );

VOID
FreeLdapControl(
    PLDAPControlW *Controls
    );

BOOLEAN
LdapCheckForMandatoryControl (
    PLDAPControlW *Controls
    );

ULONG
ldap_result_with_error (
    PLDAP_CONN      Connection,
    ULONG           msgid,
    ULONG           AllOfMessage,
    struct l_timeval  *TimeOut,
    LDAPMessage     **res,
    LDAPMessage     **LastResult
    );

ULONG
FreeCurrentCredentials (
    PLDAP_CONN Connection
    );

ULONG
LdapSaveSearchParameters (
    PLDAP_REQUEST Request,
    PWCHAR  DistinguishedName,
    PWCHAR  SearchFilter,
    PWCHAR  AttributeList[],
    BOOLEAN Unicode
    );

ULONG
LdapSearch (
        PLDAP_CONN connection,
        PWCHAR  DistinguishedName,
        ULONG   ScopeOfSearch,
        PWCHAR  SearchFilter,
        PWCHAR  AttributeList[],
        ULONG   AttributesOnly,
        BOOLEAN Unicode,
        BOOLEAN Synchronous,
        PLDAPControlW *ServerControls,
        PLDAPControlW *ClientControls,
        ULONG   TimeLimit,
        ULONG   SizeLimit,
        ULONG  *MessageNumber
    );

ULONG
LdapAbandon (
    PLDAP_CONN connection,
    ULONG msgid,
    BOOLEAN SendAbandon
    );

PLDAPMessage
ldap_first_record (
    PLDAP_CONN connection,
    LDAPMessage *Results,
    ULONG MessageType
    );

PLDAPMessage
ldap_next_record (
    PLDAP_CONN connection,
    LDAPMessage *Results,
    ULONG MessageType
    );

ULONG
ldap_count_records (
    PLDAP_CONN connection,
    LDAPMessage *Results,
    ULONG MessageType
    );

VOID
GetCurrentLuid (
    PLUID Luid
    );

ULONG
LdapMakeCredsWide(
    PCHAR pAnsiAuthIdent,
    PCHAR *ppWideAuthIdent,
    BOOLEAN FromWide
    );

ULONG
LdapMakeCredsThin(
    PCHAR pAnsiAuthIdent,
    PCHAR *ppWideAuthIdent,
    BOOLEAN FromWide
    );

ULONG
LdapMakeEXCredsWide(
    PCHAR pAnsiAuthIdentEX,
    PCHAR *ppWideAuthIdentEX,
    BOOLEAN FromWide
    );

ULONG
LdapMakeEXCredsThin(
    PCHAR pAnsiAuthIdentEX,
    PCHAR *ppWideAuthIdentEX,
    BOOLEAN FromWide
    );

BOOLEAN
LdapAuthError(
   ULONG err
   );

ULONG
LdapPingServer(
    PLDAP_CONN      Connection
    );

VOID
UnloadPingLibrary(
    VOID
    );

VOID
LdapWakeupSelect (
    VOID
    );

VOID
CheckForWaiters (
    ULONG MessageNumber,
    BOOLEAN AnyWaiter,
    PLDAP_CONN Connection
    );

ULONG
LdapEncodeSortControl (
        PLDAP_CONN connection,
        PLDAPSortKeyW  *SortKeys,
        PLDAPControlW  Control,
        BOOLEAN Criticality,
        ULONG codePage
        );

ULONG
LdapParseResult (
        PLDAP_CONN connection,
        LDAPMessage *ResultMessage,
        ULONG *ReturnCode OPTIONAL,          // returned by server
        PWCHAR *MatchedDNs OPTIONAL,         // free with ldap_value_freeW
        PWCHAR *ErrorMessage OPTIONAL,       // free with ldap_value_freeW
        PWCHAR **Referrals OPTIONAL,         // free with ldap_value_freeW
        PLDAPControlW **ServerControls OPTIONAL,
        BOOLEAN Freeit,
        ULONG codePage
        );

ULONG LdapParseExtendedResult (
        PLDAP_CONN      connection,
        LDAPMessage    *ResultMessage,
        PWCHAR         *ResultOID,
        struct berval **ResultData,
        BOOLEAN         Freeit,
        ULONG           codePage
        );

ULONG
LdapAutoReconnect (
    PLDAP_CONN Connection
    );

ULONG
SimulateErrorMessage (
    PLDAP_CONN Connection,
    PLDAP_REQUEST Request,
    ULONG Error
    );

ULONG
LdapConnect (
    PLDAP_CONN connection,
    struct l_timeval  *timeout,
    BOOLEAN DontWait
    );

ULONG
ProcessAlternateCreds (
      PLDAP_CONN Connection,
      PSecPkgInfoW Package,
      PWCHAR Credentials,
      PWCHAR *newcreds
      );

BOOLEAN
LdapIsAddressNumeric (
    PWCHAR HostName
    );

ULONG
LdapDetermineServerVersion (
    PLDAP_CONN Connection,
    struct l_timeval  *Timeout,
    BOOLEAN *pfIsServerWhistler     // OUT
    );

BOOLEAN LoadUser32Now(
    VOID
    );

ULONG
ConnectToSRVrecs(
    PLDAP_CONN Connection,
    PWCHAR HostName,
    BOOLEAN SuggestedHost,
    USHORT port,
    struct l_timeval  *timeout
    );

ULONG
ConnectToArecs(
    PLDAP_CONN  Connection,
    struct hostent  *hostEntry,
    BOOLEAN SuggestedHost,
    USHORT port,
    struct l_timeval  *timeout
    );

ULONG
LdapParallelConnect(
       PLDAP_CONN   Connection,
       PSOCKHOLDER2 *sockAddressArr,
       USHORT port,
       UINT totalCount,
       struct l_timeval  *timeout
       );

VOID
InsertErrorMessage(
     PLDAP_CONN Connection,
     PWCHAR     ErrorMessage
      );

PVOID
GetErrorMessage(
     PLDAP_CONN Connection,
     BOOLEAN Unicode
      );

BOOL
AddPerThreadEntry(
                DWORD ThreadID
                );

BOOL
RemovePerThreadEntry(
                DWORD ThreadID
                );

VOID
RoundUnicodeStringMaxLength(
    UNICODE_STRING *pString,
    USHORT dwMultiple
    );

VOID
EncodeUnicodeString(
    UNICODE_STRING *pString
    );

VOID
DecodeUnicodeString(
    UNICODE_STRING *pString
    );

BOOLEAN
IsMessageIdValid(
     LONG MessageId
     );

PLDAPReferralDN
LdapParseReferralDN(
    PWCHAR newDN
    );

VOID
DebugReferralOutput(
    PLDAP_REQUEST Request,
    PWCHAR HostAddr,
    PWCHAR NewUrlDN
    );

VOID
DiscoverDebugRegKey(
    VOID
    );

DWORD
ReadRegIntegrityDefault(
    DWORD *pdwIntegrity
    );
    
#define DEFAULT_INTEGRITY_NONE      0
#define DEFAULT_INTEGRITY_PREFERRED 1
#define DEFAULT_INTEGRITY_REQUIRED  2

VOID
FreeEntireLdapCache(
   VOID
   );

VOID
InitializeLdapCache (
   VOID
   );

PWCHAR
LdapFirstAttribute (
    PLDAP_CONN      connection,
    LDAPMessage     *Message,
    BerElement      **OpaqueResults,
    BOOLEAN         Unicode
    );

PWCHAR
LdapNextAttribute (
    PLDAP_CONN      connection,
    LDAPMessage     *Message,
    BerElement      *OpaqueResults,
    BOOLEAN         Unicode
    );

ULONG
LdapGetValues (
    PLDAP_CONN      connection,
    LDAPMessage     *Message,
    PWCHAR          attr,
    BOOLEAN         BerVal,
    BOOLEAN         Unicode,
    PVOID           *Output
    );


ULONG LdapGetConnectionOption (
    PLDAP_CONN connection,
    int option,
    void *outvalue,
    BOOLEAN Unicode
    );

ULONG LdapSetConnectionOption (
    PLDAP_CONN connection,
    int option,
    const void *invalue,
    BOOLEAN Unicode
    );

ULONG LDAPAPI LdapGetPagedCount(
        PLDAP_CONN      connection,
        PLDAP_REQUEST   request,
        ULONG          *TotalCount,
        PLDAPMessage    Results
    );

ULONGLONG
LdapGetTickCount(
    VOID
    );

ULONG
LdapGetModuleBuildNum(
    VOID
    );


//
//  Here's the function declarations for dynamically loading winsock
//
//  We dynamically load winsock so that we can either load winsock 1.1 or 2.0,
//  and the functions we pull in depend on what version we're going to use.
//

typedef int (PASCAL FAR *FNWSAFDISSET)(SOCKET, fd_set FAR *);

extern LPFN_WSASTARTUP pWSAStartup;
extern LPFN_WSACLEANUP pWSACleanup;
extern LPFN_WSAGETLASTERROR pWSAGetLastError;
extern LPFN_RECV precv;
extern LPFN_SELECT pselect;
extern LPFN_WSARECV pWSARecv;
extern LPFN_SOCKET psocket;
extern LPFN_CONNECT pconnect;
extern LPFN_GETHOSTBYNAME pgethostbyname;
extern LPFN_GETHOSTBYADDR pgethostbyaddr;
extern LPFN_INET_ADDR pinet_addr;
extern LPFN_INET_NTOA pinet_ntoa;
extern LPFN_HTONS phtons;
extern LPFN_HTONL phtonl;
extern LPFN_NTOHL pntohl;
extern LPFN_CLOSESOCKET pclosesocket;
extern LPFN_SEND psend;
extern LPFN_IOCTLSOCKET pioctlsocket;
extern LPFN_SETSOCKOPT psetsockopt;
extern FNWSAFDISSET pwsafdisset;
extern LPFN_WSALOOKUPSERVICEBEGINW pWSALookupServiceBeginW;
extern LPFN_WSALOOKUPSERVICENEXTW pWSALookupServiceNextW;
extern LPFN_WSALOOKUPSERVICEEND pWSALookupServiceEnd;


//
// Function declarations for loading NTDS APIs
//

typedef DWORD (*FNDSMAKESPNW) (
                   LPWSTR ServiceClass,
                   LPWSTR ServiceName,
                   LPWSTR InstanceName,
                   USHORT InstancePort,
                   LPWSTR Referrer,
                   DWORD *pcSpnLength,
                   LPWSTR pszSpn
                   );

extern FNDSMAKESPNW pDsMakeSpnW;

//
// Function declarations for loading Rtl APIs
//

typedef VOID (*FNRTLINITUNICODESTRING) (
           PUNICODE_STRING DestinationString,
           PCWSTR SourceString
           );

extern FNRTLINITUNICODESTRING pRtlInitUnicodeString;

typedef VOID (*FRTLRUNENCODEUNICODESTRING) (
           PUCHAR          Seed,
           PUNICODE_STRING String
           );

extern FRTLRUNENCODEUNICODESTRING pRtlRunEncodeUnicodeString;

typedef VOID (*FRTLRUNDECODEUNICODESTRING) (
           UCHAR           Seed,
           PUNICODE_STRING String
           );

extern FRTLRUNDECODEUNICODESTRING pRtlRunDecodeUnicodeString;


typedef NTSTATUS (*FRTLENCRYPTMEMORY) (
           PVOID Memory,
           ULONG MemoryLength,
           ULONG OptionFlags
           );

extern FRTLENCRYPTMEMORY pRtlEncryptMemory;

typedef NTSTATUS (*FRTLDECRYPTMEMORY) (
           PVOID Memory,
           ULONG MemoryLength,
           ULONG OptionFlags
           );

extern FRTLDECRYPTMEMORY pRtlDecryptMemory;


//
// Function declarations for loading USER32 APIs
//

typedef int (*FNLOADSTRINGA) (
    IN HINSTANCE hInstance,
    IN UINT uID,
    OUT LPSTR lpBuffer,
    IN int nBufferMax
    );

extern FNLOADSTRINGA pfLoadStringA;

typedef int (*FNWSPRINTFW) (
   OUT LPWSTR,
   IN LPCWSTR,
   ...);

extern FNWSPRINTFW pfwsprintfW;

typedef int (*FNMESAGEBOXW) (
    IN HWND hWnd,
    IN LPCWSTR lpText,
    IN LPCWSTR lpCaption,
    IN UINT uType
    );

extern FNMESAGEBOXW pfMessageBoxW;

//
// Function declarations for loading SECUR32 APIs
//

typedef BOOL (WINAPI *FGETTOKENINFORMATION) (
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    LPVOID TokenInformation,
    DWORD TokenInformationLength,
    PDWORD ReturnLength
    );

typedef BOOL (WINAPI *FOPENPROCESSTOKEN) (
    HANDLE ProcessHandle,
    DWORD DesiredAccess,
    PHANDLE TokenHandle
    );

typedef BOOL (WINAPI *FOPENTHREADTOKEN) (
    HANDLE ThreadHandle,
    DWORD DesiredAccess,
    BOOL OpenAsSelf,
    PHANDLE TokenHandle
    );

typedef SECURITY_STATUS (SEC_ENTRY *FSASLGETPROFILEPACKAGEW) (
    IN  LPWSTR ProfileName,
    OUT PSecPkgInfoW * PackageInfo
    );

extern FSASLGETPROFILEPACKAGEW pSaslGetProfilePackageW;

typedef SECURITY_STATUS (SEC_ENTRY *FSASLINITIALIZESECURITYCONTEXTW) (
    PCredHandle                 phCredential,
    PCtxtHandle                 phContext,
    LPWSTR                      pszTargetName,
    unsigned long               fContextReq,
    unsigned long               Reserved1,
    unsigned long               TargetDataRep,
    PSecBufferDesc              pInput,
    unsigned long               Reserved2,
    PCtxtHandle                 phNewContext,
    PSecBufferDesc              pOutput,
    unsigned long SEC_FAR *     pfContextAttr,
    PTimeStamp                  ptsExpiry
    );

extern FSASLINITIALIZESECURITYCONTEXTW pSaslInitializeSecurityContextW;

typedef SECURITY_STATUS (SEC_ENTRY *FQUERYCONTEXTATTRIBUTESW) (
   PCtxtHandle phContext,              // Context to query
   unsigned long ulAttribute,          // Attribute to query
   void SEC_FAR * pBuffer              // Buffer for attributes
   );

extern FQUERYCONTEXTATTRIBUTESW pQueryContextAttributesW;

typedef PSecurityFunctionTableW (*FSECINITSECURITYINTERFACEW)( VOID );
typedef PSecurityFunctionTableA (*FSECINITSECURITYINTERFACEA)( VOID );

extern FSECINITSECURITYINTERFACEW pSspiInitialize;
extern FSECINITSECURITYINTERFACEW pSslInitialize;

PSecurityFunctionTableW Win9xSspiInitialize();
PSecurityFunctionTableW Win9xSslInitialize();

//
// Macros that let us call Unicode version in NT and Ansi version in Win9x
//
#define LdapSspiInitialize()      (GlobalWin9x ? Win9xSspiInitialize() : (*pSspiInitialize)())
#define LdapSslInitialize()       (GlobalWin9x ? Win9xSslInitialize()  : (*pSslInitialize)())

#endif  // LDAP_CLIENT_INTERNAL_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\lmacros.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    lmacro.h   LDAP client 32 API macros

Abstract:

   This module contains macros for the 32 bit LDAP client API code.

Author:

    Andy Herron (andyhe)        08-May-1996

Revision History:

--*/


#ifndef LDAP_CLIENT_MACROS_DEFINED
#define LDAP_CLIENT_MACROS_DEFINED

#define LDAP_LOCK           CRITICAL_SECTION
#define INITIALIZE_LOCK(x)  InitializeCriticalSection(x);
#define DELETE_LOCK(x)      DeleteCriticalSection(x);
#define ACQUIRE_LOCK(x)     EnterCriticalSection(x);
#define RELEASE_LOCK(x)     LeaveCriticalSection(x);

//
// The following stringizing macro will expand the value of a
// #define passed as a parameter.  For example, if SOMEDEF is
// #define'd to be 123, then STRINGIZE(SOMEDEF) will produce
// "123", not "SOMEDEF"
//
#define STRINGIZE(y)          _STRINGIZE_helper(y)
#define _STRINGIZE_helper(z)  #z

#define DereferenceLdapConnection( _conn ) {                            \
        ACQUIRE_LOCK( &(_conn)->StateLock );                            \
        ASSERT((_conn)->ReferenceCount > 0);                            \
        (_conn)->ReferenceCount--;                                      \
        IF_DEBUG(REFCNT) {                                              \
            LdapPrint2("LDAP deref conn 0x%x, new count = 0x%x\n",      \
                    _conn,(_conn)->ReferenceCount );                    \
        }                                                               \
        if ((_conn)->ReferenceCount == 0) {                             \
            RELEASE_LOCK( &(_conn)->StateLock );                        \
            DereferenceLdapConnection2( _conn );                        \
        }                                                               \
        else {                                                          \
            RELEASE_LOCK( &(_conn)->StateLock );                        \
        }                                                               \
    }

#define is_cldap( _conn ) (( (_conn)->UdpHandle != INVALID_SOCKET ) ? TRUE : FALSE )

#define get_socket( _conn ) (( (_conn)->UdpHandle != INVALID_SOCKET ) ? \
                               (_conn)->UdpHandle : (_conn)->TcpHandle )


#define DereferenceLdapRequest( _req ) {                                \
        ACQUIRE_LOCK( &(_req)->Lock );                                  \
        ASSERT((_req)->ReferenceCount > 0);                             \
        (_req)->ReferenceCount--;                                       \
        IF_DEBUG(REFCNT) {                                              \
            LdapPrint2("LDAP deref req 0x%x, new count = 0x%x\n",       \
                    _req,(_req)->ReferenceCount );                      \
        }                                                               \
        if ((_req)->ReferenceCount == 0) {                              \
            RELEASE_LOCK( &(_req)->Lock );                              \
            DereferenceLdapRequest2( _req );                            \
        }                                                               \
        else {                                                          \
            RELEASE_LOCK( &(_req)->Lock );                              \
        }                                                               \
    }


//
// Warning! Do not hold any global locks before calling BeginSocketProtection
//

#define BeginSocketProtection( _conn ) {                                \
        ACQUIRE_LOCK( &SelectLock2 );                                   \
        LdapWakeupSelect();                                             \
        ACQUIRE_LOCK( &SelectLock1 );                                   \
        ACQUIRE_LOCK( &((_conn)->SocketLock) );                         \
}

#define EndSocketProtection( _conn ) {                                  \
        RELEASE_LOCK( &((_conn)->SocketLock) );                         \
        RELEASE_LOCK( &SelectLock1 );                                   \
        RELEASE_LOCK( &SelectLock2 );                                   \
}

//
// used in LdapParallelConnect to clean up useless sockets
//

#define LdapCleanupSockets( _numsockets ) {                             \
ULONG _i;                                                               \
for (_i = 0; _i < _numsockets; _i++) {                                  \
   if (sockarray[_i].sock == INVALID_SOCKET) {                          \
      continue;                                                         \
   }                                                                    \
   sockErr = (*pclosesocket)( sockarray[_i].sock );                     \
   ASSERT(sockErr == 0);                                                \
   sockarray[_i].sock = INVALID_SOCKET;                                 \
}                                                                       \
}

//
//  define ListEntry macros here since we're also compiling for Win9x.
//

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.  We pick them up here because
//  the build breaks when we include ntrtl.h.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
// We will leave the upper 7 bits for the referral instance number. That
// leaves 2^25 == 33 million message numbers.
//

#define GET_NEXT_MESSAGE_NUMBER( _msg ) {                               \
    _msg = 0;                                                           \
    if ((GlobalMessageNumber + 1) & 0xFE000000) {                       \
        GlobalMessageNumber = 0;                                        \
        MessageNumberHasWrapped = TRUE;                                 \
    }                                                                   \
    if (GlobalWin9x) {                                                  \
        while ((_msg == 0) || (_msg == (ULONG) -1)) {                   \
            LONG _prev = GlobalMessageNumber;                           \
            _msg = ++GlobalMessageNumber;                               \
            if (_prev + 1 != _msg ) {                                   \
                _msg = 0;                                               \
            }                                                           \
        }                                                               \
    } else {                                                            \
        while ((_msg == 0) || (_msg == (ULONG) -1)) {                   \
            if ( MessageNumberHasWrapped ) {                            \
                do {                                                    \
                    _msg = InterlockedIncrement( &GlobalMessageNumber );\
                        if ((_msg)&(0xFE000000)) {                      \
                            GlobalMessageNumber = 0;                    \
                        }                                               \
                } while (!IsMessageIdValid ((_msg)));                   \
            } else {                                                    \
                _msg = InterlockedIncrement( &GlobalMessageNumber );    \
            }                                                           \
        }                                                               \
    }                                                                   \
}

#define GET_BASE_MESSAGE_NUMBER( _msgNo ) ((ULONG) ( (_msgNo) & 0x01FFFFFF ) )
#define GET_REFERRAL_NUMBER( _msgNo ) ((ULONG) ( (_msgNo) & 0xFE000000 ) >> 25)

#define MAKE_MESSAGE_NUMBER( _base, _referral ) ((ULONG)(_base+((_referral) << 25)))

extern CHAR LdapHexToCharTable[17];

#define MAPHEXTODIGIT(x) ( x >= '0' && x <= '9' ? (x-'0') :        \
                           x >= 'A' && x <= 'F' ? (x-'A'+10) :     \
                           x >= 'a' && x <= 'f' ? (x-'a'+10) : 0 )

#define ISHEX(x)         ( x >= '0' && x <= '9' ? (TRUE) :     \
                           x >= 'A' && x <= 'F' ? (TRUE) :     \
                           x >= 'a' && x <= 'f' ? (TRUE) : FALSE )

#define RealValue( x )   ( PtrToUlong(x) > 1024 ? *((ULONG *) x) : PtrToUlong(x) )


#define IsLdapInteger( x ) ( (x >= 0 ) && (x <= 2147483647) ? TRUE : FALSE )

#endif  // LDAP_CLIENT_MACROS_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\modify.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    modify.cxx handle modify requests to an LDAP server

Abstract:

   This module implements the LDAP modify APIs.

Author:

    Andy Herron (andyhe)        02-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG
EncodeModifyList (
    CLdapBer *Lber,
    LDAPModW *ModificationList[],
    BOOLEAN Unicode
    );

ULONG
LdapModify (
    PLDAP_CONN connection,
    PWCHAR DistinguishedName,
    LDAPModW *ModificationList[],
    BOOLEAN Unicode,
    BOOLEAN Synchronous,
    PLDAPControlW *ServerControls,
    PLDAPControlW *ClientControls,
    ULONG  *MessageNumber
    )
//
//  This allows a client to modify an entry in the tree.  Note that if Unicode
//  is FALSE, then the AttributeList does not point to a list of Unicode
//  attributes, but rather a list of single byte attributes.
//
{
    ULONG err = LDAP_SUCCESS;
    ULONG messageNumber;
    PLDAP_REQUEST request = NULL;

    if (MessageNumber == NULL) {

        return LDAP_PARAM_ERROR;
    }

    *MessageNumber = (ULONG) -1;

    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {
       return err;
    }

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    request = LdapCreateRequest( connection, LDAP_MODIFY_CMD );

    if (request == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap_modify connection 0x%x couldn't allocate request.\n", connection);
        }
        err = LDAP_NO_MEMORY;
        SetConnectionError( connection, err, NULL );
        return err;
    }

    messageNumber = request->MessageId;

    request->Synchronous = Synchronous;

    request->modify.Unicode = Unicode;

    err = LDAP_SUCCESS;

    if ((ServerControls != NULL) || (ClientControls != NULL)) {

        err = LdapCheckControls( request,
                                 ServerControls,
                                 ClientControls,
                                 Unicode,
                                 0 );

        if (err != LDAP_SUCCESS) {

            IF_DEBUG(CONTROLS) {
                LdapPrint2( "ldap_modify connection 0x%x trouble with SControl, err 0x%x.\n",
                            connection, err );
            }
        }
    }

    if (err == LDAP_SUCCESS) {

        if (Synchronous || (request->ChaseReferrals == 0)) {

            request->AllocatedParms = FALSE;
            request->OriginalDN = DistinguishedName;
            request->modify.AttributeList = ModificationList;

        } else {

            request->AllocatedParms = TRUE;

            if (DistinguishedName != NULL) {

                request->OriginalDN = ldap_dup_stringW( DistinguishedName, 0, LDAP_UNICODE_SIGNATURE );

                if (request->OriginalDN == NULL) {

                    err = LDAP_NO_MEMORY;
                }
            }
            if ( err == LDAP_SUCCESS ) {

                err = LdapDupLDAPModStructure(  ModificationList,
                                                Unicode,
                                                &request->modify.AttributeList );
            }
        }
    }

    if (err == LDAP_SUCCESS) {

        START_LOGGING;
        DSLOG((DSLOG_FLAG_TAG_CNPN,"[+]"));
        DSLOG((0,"[ID=%d][OP=ldap_modify][DN=%ws][ST=%I64d]\n",
               request->MessageId,DistinguishedName,request->RequestTime));
        LogAttributesAndControls(NULL, ModificationList, ServerControls, Unicode);
        DSLOG((DSLOG_FLAG_NOTIME,"[-]\n"));
        END_LOGGING;

        err = SendLdapModify( request,
                              connection,
                              request->OriginalDN,
                              (CLdapBer **)&request->BerMessageSent,
                              request->modify.AttributeList,
                              request->modify.Unicode,
                              0 );
    }

    if (err != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_modify connection 0x%x send with error of 0x%x.\n",
                        connection, err );
        }

        DSLOG((0,"[+][ID=%d][ET=%I64d][ER=%d][-]\n",request->MessageId,LdapGetTickCount(), err));
        messageNumber = (ULONG) -1;
        SetConnectionError( connection, err, NULL );

        CloseLdapRequest( request );
    }

    DereferenceLdapRequest( request );
    *MessageNumber = messageNumber;
    return err;
}


ULONG __cdecl
ldap_modifyW (
    LDAP *ExternalHandle,
    PWCHAR DistinguishedName,
    LDAPModW *AttributeList[]
    )
//
//  This is the client API to allow modifying objects in the directory.
//
{
    ULONG err;
    ULONG msgId;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {

        return LDAP_PARAM_ERROR;
    }

    err =  LdapModify( connection,
                       DistinguishedName,
                       AttributeList,
                       TRUE,
                       FALSE,
                       NULL,
                       NULL,
                       &msgId
                       );

    DereferenceLdapConnection( connection );

    return msgId;
}

ULONG __cdecl
ldap_modify (
    LDAP *ExternalHandle,
    PCHAR DistinguishedName,
    LDAPModA *AttributeList[]
    )
{
    ULONG err;
    ULONG msgId = (ULONG) -1;

    err = ldap_modify_extA( ExternalHandle,
                            DistinguishedName,
                            AttributeList,
                            NULL,
                            NULL,
                            &msgId
                            );
    return msgId;
}

ULONG __cdecl
ldap_modify_sW (
    LDAP *ExternalHandle,
    PWCHAR DistinguishedName,
    LDAPModW *AttributeList[]
    )
{
    return ldap_modify_ext_sW(  ExternalHandle,
                                DistinguishedName,
                                AttributeList,
                                NULL,
                                NULL
                                );
}

ULONG __cdecl
ldap_modify_s (
    LDAP *ExternalHandle,
    PCHAR DistinguishedName,
    LDAPModA *AttributeList[]
    )
//
//  This is the client API to allow modifying objects to the directory.
//
{
    return ldap_modify_ext_sA(  ExternalHandle,
                                DistinguishedName,
                                AttributeList,
                                NULL,
                                NULL
                                );
}

WINLDAPAPI ULONG LDAPAPI ldap_modify_extW(
        LDAP *ExternalHandle,
        PWCHAR DistinguishedName,
        LDAPModW *AttributeList[],
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG          *MessageNumber
        )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {

        return LDAP_PARAM_ERROR;
    }

    err = LdapModify(  connection,
                       DistinguishedName,
                       AttributeList,
                       TRUE,
                       FALSE,
                       ServerControls,
                       ClientControls,
                       MessageNumber
                       );

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_modify_extA(
        LDAP *ExternalHandle,
        PCHAR DistinguishedName,
        LDAPModA *AttributeList[],
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        ULONG          *MessageNumber
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (MessageNumber == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *MessageNumber = (ULONG) -1;

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        goto error;
    }

    err = LdapModify( connection,
                      wName,
                      (LDAPModW **)AttributeList,
                      FALSE,
                      FALSE,
                      (PLDAPControlW *) ServerControls,
                      (PLDAPControlW *) ClientControls,
                      MessageNumber
                      );

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (connection)
        DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_modify_ext_sW(
        LDAP *ExternalHandle,
        PWCHAR DistinguishedName,
        LDAPModW *AttributeList[],
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls
        )
{
    ULONG msgId;
    ULONG err;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapModify(   connection,
                        DistinguishedName,
                        AttributeList,
                        TRUE,
                        TRUE,
                        ServerControls,
                        ClientControls,
                        &msgId
                        );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                      );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( ExternalHandle,
                                     results,
                                     TRUE
                                     );
        }
    }

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_modify_ext_sA(
        LDAP *ExternalHandle,
        PCHAR DistinguishedName,
        LDAPModA *AttributeList[],
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    ULONG msgId;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    err = LdapModify(   connection,
                        wName,
                        (LDAPModW **)AttributeList,
                        FALSE,
                        TRUE,
                        (PLDAPControlW *) ServerControls,
                        (PLDAPControlW *) ClientControls,
                        &msgId
                        );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                      );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( ExternalHandle,
                                     results,
                                     TRUE
                                     );
        }
    }

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    DereferenceLdapConnection( connection );

    return err;
}


ULONG
SendLdapModify (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection,
    PWCHAR DistinguishedName,
    CLdapBer **Lber,
    LDAPModW *AttributeList[],
    BOOLEAN Unicode,
    LONG AltMsgId
    )
//
//  This allows a client to modify an entry in the tree.  Note that if Unicode
//  is FALSE, then the AttributeList does not point to a list of Unicode
//  attributes, but rather a list of single byte attributes.
//
{
    ULONG hr;

    if ( (Connection->publicLdapStruct.ld_version == LDAP_VERSION2) &&
         ( LdapCheckForMandatoryControl( Request->ServerControls ) == TRUE )) {

        IF_DEBUG(CONTROLS) {
            LdapPrint1( "SendLdapModify Connection 0x%x has mandatory controls.\n", Connection);
        }
        SetConnectionError( Connection, LDAP_UNAVAILABLE_CRIT_EXTENSION, NULL );
        return LDAP_UNAVAILABLE_CRIT_EXTENSION;
    }

    CLdapBer *lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

    if (lber == NULL) {
        SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
        return LDAP_NO_MEMORY;
    }

    //
    //  The request looks like the following :
    //
    //  ModifyRequest ::=
    //    [APPLICATION 6] SEQUENCE {
    //         object         LDAPDN,
    //         modification   SEQUENCE OF SEQUENCE {
    //                             operation      ENUMERATED {
    //                                                 add       (0),
    //                                                 delete    (1),
    //                                                 replace   (2)
    //                                            },
    //                             modification   SEQUENCE {
    //                                               type    AttributeType,
    //                                               values  SET OF
    //                                                         AttributeValue
    //                                            }
    //                        }
    //    }
    //
    //              attrs          SEQUENCE OF SEQUENCE {
    //                                  type          AttributeType,
    //                                  values        SET OF AttributeValue
    //                             }
    //         }
    //

    hr = lber->HrStartWriteSequence();
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldap_modify startWrite conn 0x%x encoding error of 0x%x.\n",
                        Connection, hr );
        }
encodingError:
        if (lber != NULL) {

           delete lber;
        }
        return LDAP_ENCODING_ERROR;

    } else {            // we can't forget EndWriteSequence

       if (AltMsgId != 0) {

          hr = lber->HrAddValue((LONG) AltMsgId );

       } else {

          hr = lber->HrAddValue((LONG) Request->MessageId );
       }

       if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_modify MsgNo conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            goto encodingError;
        }

        hr = lber->HrStartWriteSequence(LDAP_MODIFY_CMD);
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_modify cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            goto encodingError;

        } else {        // we can't forget EndWriteSequence

            hr = lber->HrAddValue((const WCHAR *) DistinguishedName );
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_modify DN conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                goto encodingError;
            }

            //
            //  add the modification list and we're done.
            //

            hr = lber->HrStartWriteSequence();
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_modify attrlist conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                goto encodingError;

            } else {        // we can't forget EndWriteSequence

                hr = EncodeModifyList( lber,
                                       AttributeList,
                                       Unicode );

                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "ldap_modify attrlist conn 0x%x encoding error of 0x%x.\n",
                                    Connection, hr );
                    }
                    if (lber != NULL) {

                       delete lber;
                    }
                    return hr;
                }

                hr = lber->HrEndWriteSequence();
                ASSERT( hr == NOERROR );
            }

            hr = lber->HrEndWriteSequence();
            ASSERT( hr == NOERROR );
        }

        //
        //  put in the server controls here if required
        //

        if ( (Connection->publicLdapStruct.ld_version != LDAP_VERSION2) &&
             ( Request->ServerControls != NULL )) {

            hr = InsertServerControls( Request, Connection, lber );

            if (hr != LDAP_SUCCESS) {

                if (lber != NULL) {

                   delete lber;
                }
                return hr;
            }
        }

        hr = lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );
    }

    //
    //  send the modify request.
    //

    ACQUIRE_LOCK( &Connection->ReconnectLock );

    AddToPendingList( Request, Connection );

    hr = LdapSend( Connection, lber );

    if (hr != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_modify connection 0x%x send with error of 0x%x.\n",
                        Connection, hr );
        }
        DecrementPendingList( Request, Connection );

    } else {

        //
        //  Save off the lber value, free any lber message that is already
        //  present.
        //

        lber = (CLdapBer *) InterlockedExchangePointer((PVOID *) Lber,
                                                       (PVOID) lber );
    }

    RELEASE_LOCK( &Connection->ReconnectLock );

    if (lber != NULL) {

       delete lber;
    }

    return hr;
}


ULONG
EncodeModifyList (
    CLdapBer *Lber,
    LDAPModW *ModificationList[],
    BOOLEAN Unicode
    )
//
//  This routine is used by LdapModify to copy a list of LDAPMOD records
//  to an outgoing message.
//
//         modification   SEQUENCE OF SEQUENCE {
//                             operation      ENUMERATED {
//                                                 add       (0),
//                                                 delete    (1),
//                                                 replace   (2)
//                                            },
//                             modification   SEQUENCE {
//                                               type    AttributeType,
//                                               values  SET OF
//                                                         AttributeValue
//                                            }
//                        }
//    }
//
//              attrs          SEQUENCE OF SEQUENCE {
//                                  type          AttributeType,
//                                  values        SET OF AttributeValue
//                             }
//         }
{
    ULONG count = 0;
    ULONG hr;

    if (ModificationList == NULL) {

        return LDAP_SUCCESS;
    }

    while (ModificationList[count] != NULL) {

        PLDAPModW attr = ModificationList[count];
        ULONG operation = attr->mod_op & ~LDAP_MOD_BVALUES;

        hr = Lber->HrStartWriteSequence();
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint1( "EncodeModifyList attrlist 2 encoding error of 0x%x.\n", hr );
            }
            return LDAP_ENCODING_ERROR;

        } else {    // we can't forget EndWriteSequence

            //
            //  write out the modification operation
            //

            if ((operation != LDAP_MOD_ADD) &&
                (operation != LDAP_MOD_DELETE) &&
                (operation != LDAP_MOD_REPLACE)) {

                IF_DEBUG(PARSE) {
                    LdapPrint1( "EncodeModifyList invalid operation of 0x%x.\n", operation );
                }
                return LDAP_PARAM_ERROR;
            }

            hr = Lber->HrAddValue((LONG) operation, BER_ENUMERATED);
            if (hr != NOERROR) {
                IF_DEBUG(PARSE) {
                    LdapPrint1( "EncodeModifyList attrlist 3 encoding error of 0x%x.\n", hr );
                }
                return LDAP_ENCODING_ERROR;
            }

            hr = Lber->HrStartWriteSequence();
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint1( "EncodeModifyList attrlist 4 encoding error of 0x%x.\n", hr );
                }
                return LDAP_ENCODING_ERROR;

            } else {    // we can't forget EndWriteSequence

                //
                //  write out the attribute type to modify
                //
                //  We don't have to worry when adding the attribute
                //  types if we need to convert them to unicode to
                //  preserve any DBCS codes as they should be IA5
                //  attribute names only.
                //

                if (Unicode) {

                    hr = Lber->HrAddValue((const WCHAR *) attr->mod_type );

                } else {

                    hr = Lber->HrAddValue((const CHAR *) attr->mod_type );
                }
                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint1( "EncodeModifyList attrlist 3 encoding error of 0x%x.\n", hr );
                    }
                    return LDAP_ENCODING_ERROR;
                }

                hr = Lber->HrStartWriteSequence(BER_SET);
                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint1( "EncodeModifyList attrlist 4 encoding error of 0x%x.\n", hr );
                    }
                    return LDAP_ENCODING_ERROR;

                } else {    // we can't forget EndWriteSequence

                    //
                    //  the attribute value is either a string or a ptr to
                    //  a berval structure.  Handle appropriately.
                    //

                    if (attr->mod_op & LDAP_MOD_BVALUES) {

                        //
                        //  array of berval structures, put each one into request
                        //

                        if (attr->mod_vals.modv_bvals == NULL) {

                            if (operation != LDAP_MOD_DELETE) {

                                IF_DEBUG(PARSE) {
                                    LdapPrint0( "EncodeModifyList attrlist is empty\n" );
                                }
                                return LDAP_PARAM_ERROR;
                            }

                        } else {

                            //
                            //  the values exist, encode them.
                            //

                            ULONG valCount = 0;

                            while (attr->mod_vals.modv_bvals[valCount]) {

                                PLDAP_BERVAL berValue = attr->mod_vals.modv_bvals[valCount++];

                                hr = Lber->HrAddBinaryValue((BYTE *) berValue->bv_val,
                                                                    berValue->bv_len );
                                if (hr != NOERROR) {

                                    IF_DEBUG(PARSE) {
                                        LdapPrint1( "EncodeModifyList attrlist 5 encoding error of 0x%x.\n", hr );
                                    }
                                    return LDAP_ENCODING_ERROR;
                                }
                            }
                        }

                    } else {

                        //
                        //  array of strings, put each one into request
                        //

                        if (attr->mod_vals.modv_strvals == NULL) {

                            if ((operation != LDAP_MOD_DELETE) &&
                                (operation != LDAP_MOD_REPLACE)) {

                                IF_DEBUG(PARSE) {
                                    LdapPrint0( "EncodeModifyList attrlist is empty\n" );
                                }
                                return LDAP_PARAM_ERROR;
                            }

                        } else {

                            //
                            //  the values exist, encode them.
                            //

                            ULONG valCount = 0;

                            while (attr->mod_vals.modv_strvals[valCount]) {

                                if (Unicode) {

                                    PWCHAR strValue = attr->mod_vals.modv_strvals[valCount++];

                                    hr = Lber->HrAddValue((const WCHAR *) strValue );

                                } else {

                                    PWCHAR wValue = NULL;
                                    PCHAR strValue = ((PLDAPModA)attr)->mod_vals.modv_strvals[valCount++];

                                    //
                                    //  We need to convert from single byte
                                    //  to unicode.  Otherwise we may be
                                    //  putting DBCS codes into the UTF8
                                    //  stream, which would not be good.
                                    //

                                    hr = ToUnicodeWithAlloc( strValue,
                                                             -1,
                                                             &wValue,
                                                             LDAP_UNICODE_SIGNATURE,
                                                             LANG_ACP );

                                    if (hr == LDAP_SUCCESS) {

                                        hr = Lber->HrAddValue((const WCHAR *) wValue );
                                    }

                                    ldapFree( wValue, LDAP_UNICODE_SIGNATURE );
                                }
                                if (hr != NOERROR) {

                                    IF_DEBUG(PARSE) {
                                        LdapPrint1( "EncodeModifyList attrlist 6 encoding error of 0x%x.\n", hr );
                                    }
                                    return LDAP_ENCODING_ERROR;
                                }
                            }
                        }
                    }
                }
                hr = Lber->HrEndWriteSequence();     // BER_SET
                ASSERT( hr == NOERROR );
            }
            hr = Lber->HrEndWriteSequence();
            ASSERT( hr == NOERROR );
        }
        hr = Lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );

        count++;
    }           // while modificationList != NULL

    return LDAP_SUCCESS;
}

// modify.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\newber.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation
   
Module Name:
      
   newber.cxx  
     
Abstract:

   This file contains utility functions required for BER 
   manipulation.
   
   
Author: 
   
   Anoop Anantha (AnoopA)    1-Dec-1997

Revision History:
   
--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"



BerElement * __cdecl ber_init (
     BERVAL  *pBerVal
     )
//
// This constructs a new BerElement structure containing a copy of the
// data in the supplied berval structure.
//
// Returns a pointer to a BerElement structure on success and NULL on failure.
//
{
   LBER *lber;
   ULONG err;
   ULONG bytestaken;

   if ((pBerVal != NULL) &&
        (pBerVal->bv_val != NULL) &&
        (pBerVal->bv_len != 0)) {

      lber = new CLdapBer( LDAP_VERSION2 );

      if (lber == NULL) {
         
         IF_DEBUG (OUTMEMORY) {
            LdapPrint0( "ber_alloc_t could not allocate BerElement structure ");
         }
         return NULL;
      }
      
      err = lber->HrLoadBer( (const BYTE *) pBerVal->bv_val,
                             pBerVal->bv_len,
                             &bytestaken,
                             TRUE,        // This is the whole message
                             TRUE         // Ignore the tag
                             );
      
      if (err == NOERROR) {

          return (BerElement*)lber;
      }

      delete lber;
   }

   return NULL;
}

VOID __cdecl ber_free (
     BerElement *pBerElement,
     INT fbuf
     )
//
// This frees a BerElement which is returned from ber_alloc_t() 
// or ber_init(). The second argument - fbuf should always be set
// to 1. I don't know why - the spec says so.
//
//
{
   CLdapBer *lber;

   if ( (pBerElement == NULL )||(fbuf != 1) ) {
      
      return;
   }

   lber = (CLdapBer *) pBerElement;

   delete lber;

}


VOID  __cdecl
ber_bvfree (
    struct berval *bv
    )
{
   PLDAP_MEMORY_DESCRIPTOR allocBlock;

   //
   // In some places, we allocate the entire berval structure in one piece
   // using the LDAP_VALUE_SIGNATURE. One example of this is in HrGetValueWithAlloc
   //

    if (bv != NULL) {

       allocBlock = (PLDAP_MEMORY_DESCRIPTOR) bv;
       allocBlock--;  // point to header


       if (allocBlock->Tag == LDAP_VALUE_SIGNATURE) {
           
          ldapFree( bv, LDAP_VALUE_SIGNATURE );
       
       } else { 

          ASSERT(allocBlock->Tag == LDAP_BERVAL_SIGNATURE);

        if (bv->bv_val != NULL) {
            ldapFree( bv->bv_val , LDAP_CONTROL_SIGNATURE );
        }
        ldapFree( bv, LDAP_BERVAL_SIGNATURE );
       }
    }
    return;
}


VOID __cdecl ber_bvecfree (
     PBERVAL *pBerVal
     )
//
// Frees an array of BERVAL structures.
//
//
{
   int i;

   if (pBerVal != NULL) {

      for ( i=0; pBerVal[i] != NULL; i++) {
         
         ber_bvfree( pBerVal[i] );
      }

      ldapFree( pBerVal, LDAP_BERVAL_SIGNATURE );
   }
   
   return;

}


PBERVAL __cdecl ber_bvdup (
     PBERVAL pBerVal
     )
//
// Returns a copy of a the supplied berval structure
//
{
   PBERVAL dup = NULL;

   if (pBerVal != NULL) {

      dup = (PBERVAL) ldapMalloc( sizeof( BERVAL ),
                                    LDAP_BERVAL_SIGNATURE );

      if (dup == NULL) {

         IF_DEBUG (OUTMEMORY) {
            LdapPrint0( "ber_bvdup could not allocate memory for berval structure ");
         }
         
         return NULL;
      }
      
      dup->bv_len = pBerVal->bv_len;

      if ((pBerVal->bv_len !=0 ) &&
          (pBerVal->bv_val != NULL ) ) {
      
         dup->bv_val = (PCHAR) ldapMalloc( pBerVal->bv_len ,
                                           LDAP_CONTROL_SIGNATURE );

         if (dup->bv_val == NULL) {
              IF_DEBUG (OUTMEMORY) {
                 LdapPrint0( "ber_bvdup could not allocate berval structure ");
              }
              ldapFree( dup, LDAP_BERVAL_SIGNATURE );
              return NULL;
         }

         CopyMemory( dup->bv_val, pBerVal->bv_val, pBerVal->bv_len);
      }
   }
   return dup;
}



BerElement* __cdecl ber_alloc_t (
     INT options
     )
//
// Constructs and returns a BerElement structure. The options field
// contains a bitwise-or of options which are to be used when generating
// the encoding of the BerElement
//
// The LBER_USE_DER options should always be specified.
//
{
   LBER  *lber;

   if (options & LBER_USE_DER) {
      
         lber = new CLdapBer( LDAP_VERSION2 );
         
         if (lber == NULL) {
            IF_DEBUG (OUTMEMORY) {
               LdapPrint0( "ber_alloc_t could not allocate BerElement structure ");
            }
            return NULL;
      }
         
         return (BerElement *) lber;
   }

   return NULL;
}



ULONG __cdecl ber_skip_tag (
     BerElement *pBerElement,
     PULONG pLen
     )
//
// This skips over the current tag and returns the tag of the next
// element in the supplied BerElement. The lenght of this element is
// stored in the pLen argument.
//
// LBER_DEFAULT is returned if there is no further data to be read
// else the tag of the next element is returned.
//
// The difference between ber_skip_tag() and ber_peek_tag() is that the
// state pointer is advanced past the first tag+lenght and is pointed to
// the value part of the next element
//
//
{
   LBER *lber;
   ULONG hr;
   ULONG tag;
 
    if ((pBerElement != NULL)&&(pLen != NULL )) {
 
       lber = (LBER *) pBerElement;
       hr = lber->HrSkipTag2( &tag, pLen );
 
       return ((hr == NO_ERROR) ? tag : LBER_DEFAULT );
    }
 
    return LDAP_PARAM_ERROR;
  
}

ULONG __cdecl ber_peek_tag (
     BerElement *pBerElement,
     PULONG pLen
     )
//
// This returns the tag of the next element to be parsed in the 
// supplied BerElement. The length of this element is stored in the
// pLen argument.
//
// LBER_DEFAULT is returned if there is no further data to be read
// else the tag of the next element is returned.
//
{
   LBER *lber;
   ULONG tag, oldpos;

   if ((pBerElement != NULL)&&(pLen != NULL )) {

      lber = (LBER *) pBerElement;
      //
      // Save the current position
      //
      oldpos = lber->GetCurrPos();
      tag = ber_skip_tag( pBerElement, pLen );
      //
      // Restore the previous position
      //
      lber->SetCurrPos( oldpos );
      return tag;
   }

   return LDAP_PARAM_ERROR;

}


ULONG __cdecl ber_first_element (
     BerElement *pBerElement,
     PULONG pLen,
     PCHAR *pOpaque
     )
//
// This returns the tag and length of the first element in a SET, SET OF
// or SEQUENCE OF data value. 
//
// LBER_DEFAULT is returned if the constructed value is empty else, the tag
// is returned. It also returns an opaque cookie which has to be passed to
// subsequent invocations of ber_next_element().
//
{
   ULONG hr;
   LBER *lber;


   if ((pBerElement != NULL) && (pLen !=NULL) && (pOpaque != NULL) ) {
      
      lber = (LBER *) pBerElement;
   //
   // First, skip the SET, SET OF or SEQUENCE tag
   //
   
      hr = ber_skip_tag( pBerElement, pLen );
      if (hr == LBER_DEFAULT) {
         return LBER_DEFAULT;
      }

      *pOpaque = (PCHAR) (lber->PbData() + lber->GetCurrPos() + *pLen);
      if ( *pLen == 0 ) {
          return LBER_DEFAULT;
      } else {
          return ( ber_peek_tag( pBerElement, pLen ) );
      }

   }
   return LDAP_PARAM_ERROR;
}



ULONG __cdecl ber_next_element (
     BerElement *pBerElement,
     PULONG pLen,
     PCHAR opaque
     )
//
// This positions the state at the start of the next element in the
// constructed type.
//
// LBER_DEFAULT is returned if the constructed value is empty else, the tag
// is returned.
//
{
   LBER *lber = (LBER *) pBerElement;

   if ((pBerElement != NULL) && (pLen !=NULL) && (opaque != NULL)) {

      if ( (PCHAR) (lber->PbData() + lber-> GetCurrPos()) == opaque) {

         return LBER_DEFAULT;
      }

      return ( ber_peek_tag( pBerElement, pLen ) );
   }
   return LDAP_PARAM_ERROR;
}


INT __cdecl ber_flatten (
     BerElement *pBerElement,
     PBERVAL *pBerVal
     )
//
// This allocates a BerVal structure whose contents are taken from the
// supplied BerElement structure.
//
// The return values are 0 on success and -1 on error.
//
{
   if ((pBerElement == NULL)||
      (pBerVal == NULL)) {
         
      return -1;
   }

      *pBerVal = (PBERVAL) ldapMalloc( sizeof( BERVAL ),
                                    LDAP_BERVAL_SIGNATURE );

      if (*pBerVal == NULL) {

         IF_DEBUG (OUTMEMORY) {
            LdapPrint0( "ber_flatten could'nt allocate berval structure ");
         }
         return -1;
         
      }

      LBER* plber = (LBER *) pBerElement;

      (*pBerVal)->bv_len = plber->CbData();

      (*pBerVal)->bv_val = (PCHAR) ldapMalloc( plber->CbData(),
                                           LDAP_CONTROL_SIGNATURE );

         if ((*pBerVal)->bv_val == NULL) {
              IF_DEBUG (OUTMEMORY) {
                 LdapPrint0( "ber_flatten could'nt allocate val structure ");
              }
              ldapFree( *pBerVal, LDAP_BERVAL_SIGNATURE );
              return -1;
         }

         //
         // Copy the value field over
         //
         CopyMemory( (*pBerVal)->bv_val, plber->PbData(), plber->CbData() );
         
         return 0;

}


INT __cdecl ber_printf (
     BerElement *pBerElement,
     PCHAR fmt,
     ...
     )
//
// This is similar to sprintf(). One important difference
// is that state information is maintained in the BerElement so that multiple
// calls can be made to ber_printf() to append to the end of the BerElement.
//
// The function returns -1 if there is an error during encoding.
//
//
{
   va_list argPtr;
   CHAR *pchar, *strval, **vstrval;
   int retval = NO_ERROR, intval;
   BERVAL **ppberval;
   LBER *lber = (LBER*) pBerElement;
   
   if ((pBerElement==NULL) || (fmt == NULL)) {

      return LBER_ERROR;
   }

   //
   // Make the argument pointer point to the first unnamed argument
   //

   va_start( argPtr, fmt );

   for (pchar = fmt; (*pchar != '\0')&&(retval==NO_ERROR) ; pchar++) {

      switch (*pchar) {
      case 't': //  overriding tag (int) follows
         {
               intval = va_arg( argPtr, INT );
               lber->HrOverrideTag( intval );
               break;
         }
      case 'b': // Boolean (int) follows
         {
            intval = va_arg( argPtr, INT );
            retval = lber->HrAddValue((BOOLEAN) intval, BER_BOOLEAN );
            break;
         }
      case 'i': // integer (int) follows
         {
            intval = va_arg( argPtr, INT );
            retval = lber->HrAddValue( (LONG) intval, BER_INTEGER );
            break;
         }
      case 'e': // enumerated type (int) follows
         {
            intval = va_arg( argPtr, INT );
            retval = lber->HrAddValue( (LONG) intval, BER_ENUMERATED );
            break;
         }
      case 'X': // Bitstring, args are char* ptr followed by
                // an int containing the number of bits in the bitstring
         {
            strval = va_arg( argPtr, PCHAR );
            intval = va_arg( argPtr, INT );
            retval = lber->HrAddBinaryValue( (PBYTE) strval, intval, BER_BITSTRING );
            break;
         }
      case 'n': // Null. No argument is required
         {
//          retval = lber->HrAddTag( BER_NULL ); 
            retval = lber->HrAddValue( (const CHAR *) NULL, BER_NULL );
            break;
         }
      case 'o': // octet string (not null terminated). Args are char* ptr,
                // followed by an int containing the length of the string
         {
            strval = va_arg( argPtr, PCHAR );
            intval = va_arg( argPtr, INT );
            retval = lber->HrAddBinaryValue( (PBYTE) strval, intval, BER_OCTETSTRING );
            break;
         }
      case 's': // octet string (null terminated). Next arg is a char* pointing
                // to a null terminated string.
         {
            strval = va_arg( argPtr, PCHAR );
            retval = lber->HrAddValue( strval, BER_OCTETSTRING );
            break;
         }
      case 'v': // several octet strings.
         {
            vstrval = va_arg( argPtr, PCHAR *);
            if (vstrval == NULL) {
               break;
            }
            for (intval = 0; vstrval[intval] != NULL; intval++) {
               retval = lber->HrAddValue( vstrval[intval], BER_OCTETSTRING );
               if (retval != NO_ERROR) {
                  break;
               }
            }
            break;
         }
      case 'V': // several octet strings
         {
            ppberval = va_arg( argPtr, BERVAL ** );
            if (ppberval == NULL) {
               break;
            }
            for (intval = 0; ppberval[intval] != NULL; intval++) {
               retval = lber->HrAddBinaryValue( (PBYTE) ppberval[intval]->bv_val,
                                                ppberval[intval]->bv_len,
                                                BER_OCTETSTRING );
               if (retval != NO_ERROR) {
                  break;
               }
            }
            break;
         }
      case '{': // Begin sequence, no argument is required
         {
            retval = lber->HrStartWriteSequence( BER_SEQUENCE );
            break;
         }
      case '}': // End sequence, no argument is required
         {
            retval = lber->HrEndWriteSequence();
            break;
         }
      case '[': // Begin set
         {
            retval = lber->HrStartWriteSequence( BER_SET );
            break;
         }
      case ']': // End set
         {
            retval = lber->HrEndWriteSequence();
            break;
         }
      default:
         {
            IF_DEBUG (BER) {  
               LdapPrint1( "ber_printf Unidentified format character %c ", *pchar);
            }
            
            retval = LBER_ERROR;

         }
      }
   }
   va_end( argPtr );
   return (retval == NO_ERROR) ? NO_ERROR : LBER_ERROR;
}


ULONG __cdecl ber_scanf (
     BerElement *pBerElement,
     PCHAR fmt,
     ...
     )
{
   va_list argPtr;
   CHAR *pchar, **pstrval, **pstrvalNew, ***ppstrval;
   int *pintval, retval = NO_ERROR;
   BERVAL **ppberval, **ppbervalNew, ***pppberval;
   ULONG *pUlong, uLong, tag;
   LBER *lber = (LBER*) pBerElement;
   ULONG  nextTag, tagLength;
   ULONG oldPos;
   #define CHUNK_SIZE  10    // minimum is 2.
   
   if ((pBerElement==NULL) || (fmt == NULL)) {

      return (ULONG) -1;
   }

   //
   // Make the argument pointer point to the first unnamed argument
   //

   va_start( argPtr, fmt );

   for (pchar = fmt; (*pchar != '\0')&&(retval==NO_ERROR) ; pchar++) {

      switch (*pchar) {
      case 'a':  // Octet string (null terminated)
         {
            pstrval = va_arg(argPtr, PCHAR*);
            nextTag = ber_peek_tag(pBerElement, &tagLength);
            if (nextTag == LBER_DEFAULT) {
                retval = LDAP_DECODING_ERROR;
                break;
            }
            if (GetBerForm(nextTag) == BER_FORM_CONSTRUCTED) {
                retval = LDAP_DECODING_ERROR;
            } else {
                retval = lber->HrGetValueWithAlloc(pstrval, TRUE);
            }
            break;
         }
      case 'O':  // Octet string (non-null terminated)
         {
            ppberval = va_arg( argPtr, PBERVAL* );
            nextTag = ber_peek_tag(pBerElement, &tagLength);
            if (nextTag == LBER_DEFAULT) {
                retval = LDAP_DECODING_ERROR;
                break;
            }
            if (GetBerForm(nextTag) == BER_FORM_CONSTRUCTED) {
                retval = LDAP_DECODING_ERROR;
            } else {
                retval = lber->HrGetValueWithAlloc(ppberval, TRUE);
            }
            break;
         }
      case 'b':  // Boolean
         {
            pintval = va_arg( argPtr, int* );
            nextTag = ber_peek_tag(pBerElement, &tagLength);
            if (nextTag == LBER_DEFAULT) {
                retval = LDAP_DECODING_ERROR;
                break;
            }
            if (GetBerForm(nextTag) == BER_FORM_CONSTRUCTED) {
                retval = LDAP_DECODING_ERROR;
            } else {
                retval = lber->HrGetValue((long*)pintval, BER_BOOLEAN, TRUE);
            }
            break;
         }
      case 'i':  // Integer
         {
            pintval = va_arg( argPtr, int* );
            nextTag = ber_peek_tag(pBerElement, &tagLength);
            if (nextTag == LBER_DEFAULT) {
                retval = LDAP_DECODING_ERROR;
                break;
            }
            if (GetBerForm(nextTag) == BER_FORM_CONSTRUCTED) {
                retval = LDAP_DECODING_ERROR;
            } else {
                retval = lber->HrGetValue((long*)pintval, BER_INTEGER, TRUE);
            }
            break;
         }
      case 'e':  // Enumerated
         {
            pintval = va_arg( argPtr, int* );
            nextTag = ber_peek_tag(pBerElement, &tagLength);
            if (nextTag == LBER_DEFAULT) {
                retval = LDAP_DECODING_ERROR;
                break;
            }
            if (GetBerForm(nextTag) == BER_FORM_CONSTRUCTED) {
                retval = LDAP_DECODING_ERROR;
            } else {
                retval = lber->HrGetValue((long*)pintval, BER_ENUMERATED, TRUE);
            }
            break;
         }
      case 'B':   // Bitstring
         {
            pstrval = va_arg( argPtr, PCHAR* );
            pUlong = va_arg( argPtr, PULONG );
            nextTag = ber_peek_tag(pBerElement, &tagLength);
            if (nextTag == LBER_DEFAULT) {
                retval = LDAP_DECODING_ERROR;
                break;
            }
            if (GetBerForm(nextTag) == BER_FORM_CONSTRUCTED) {
                retval = LDAP_DECODING_ERROR;
            } else {
                retval = lber->HrGetBinaryValuePointer( (PBYTE*) pstrval, pUlong, BER_BITSTRING, TRUE );
            }
            if (retval != NO_ERROR) {
               //
               // Duplicate the data and pass it back
               //
            }
            break;
         }
      case 'n':  // null
         {
            oldPos = lber->GetCurrPos();
            retval = lber->HrSkipTag();
            if (retval != NO_ERROR) {
                lber->SetCurrPos(oldPos);
                break;
            }
            retval = lber->HrGetLength( &uLong );
            if (retval != NO_ERROR) {
                lber->SetCurrPos(oldPos);
                break;
            }
            if (uLong != 0) {
                retval = LBER_ERROR;
                lber->SetCurrPos(oldPos);
                break;
            }
            break;
         }
      case 'v':   // several null terminated octet strings
         {
            ppstrval = va_arg( argPtr, PCHAR**);
            *ppstrval = NULL;
            PCHAR cookie;
            ULONG numofstrings=0, len, currentArraySize = 0 ;
            
            //
            // We have to allocate a null-terminated array of PCHARs and make
            // ppstrval point to it. To do this, we need to know how many 
            // octet strings are present. Note that we can't simply count
            // the number of strings first, build the array, and then fill it 
            // because ber_next_element will alter the internal state of the
            // BerElement.
            //

            for (tag=ber_first_element(pBerElement, &len, &cookie); 
                 (( tag != LBER_DEFAULT ) && ( retval != LBER_DEFAULT ));
                 tag = ber_next_element(pBerElement,&len, cookie)) {

                 if ( *ppstrval == NULL ) {
                     
                     //
                     // first time around, alloc a sufficiently large array 
                     //
                     
                     *ppstrval = (PCHAR *) ldapMalloc( CHUNK_SIZE * sizeof(PCHAR),
                                                       LDAP_BUFFER_SIGNATURE );
                     if ( *ppstrval == NULL ) {
                         return LBER_ERROR;
                     }

                     currentArraySize = CHUNK_SIZE;

                    } else if ( numofstrings > (currentArraySize-2) ) {
                            
                        //
                        // sort of realloc and free the old memory
                        //
                        
                        pstrvalNew = NULL;
                        pstrvalNew = (PCHAR *) ldapMalloc( (currentArraySize + CHUNK_SIZE) * sizeof(PCHAR),
                                                            LDAP_BUFFER_SIGNATURE );
                        if ( pstrvalNew == NULL ){
                            return LBER_ERROR;
                        }
                        ldap_MoveMemory( (PCHAR) pstrvalNew,
                                         (PCHAR) *ppstrval,
                                         (currentArraySize * sizeof(PCHAR)));
                        ldapFree( *ppstrval, LDAP_BUFFER_SIGNATURE );
                        *ppstrval = pstrvalNew;
                        currentArraySize += CHUNK_SIZE;
                    }


                    retval = lber->HrGetValueWithAlloc( (&(*ppstrval)[numofstrings]), TRUE);
                    numofstrings++;
            }
            
            break;
         }
      case 'V':   // several non-null terminated octet strings
         {
            pppberval = va_arg( argPtr, PBERVAL**);
            *pppberval = NULL;
            PCHAR cookie;
            ULONG numofbervals=0, len, currentArraySize = 0 ;

            //
            // We have to allocate a null-terminated array of PBERVALs and make
            // pppberval point to it. To do this, we need to know how many 
            // bervals are present. Note that we can't simply count
            // the number of bervals first, build the array, and then fill it 
            // because ber_next_element will alter the internal state of the
            // BerElement.
            //

            for (tag=ber_first_element(pBerElement, &len, &cookie); 
                 (( tag != LBER_DEFAULT ) && ( retval != LBER_DEFAULT ));
                 tag = ber_next_element(pBerElement,&len, cookie)) {

                 if ( *pppberval == NULL ) {
                     
                     //
                     // first time around, alloc a sufficiently large array 
                     //
                     
                     *pppberval = (PBERVAL *) ldapMalloc( CHUNK_SIZE * sizeof(PBERVAL),
                                                       LDAP_BUFFER_SIGNATURE );
                     if ( *pppberval == NULL ) {
                         return LBER_ERROR;
                     }

                    } else if ( numofbervals > (currentArraySize-2) ) {
                        
                        //
                        // sort of realloc and free the old memory
                        //
                        
                        ppbervalNew = NULL;
                        ppbervalNew = (PBERVAL *) ldapMalloc( (currentArraySize + CHUNK_SIZE) * sizeof(PBERVAL),
                                                              LDAP_BUFFER_SIGNATURE );
                        if ( ppbervalNew == NULL ){
                                return LBER_ERROR;
                        }
                        ldap_MoveMemory( (PCHAR) ppbervalNew,
                                         (PCHAR) *pppberval,
                                         (currentArraySize * sizeof(PBERVAL)));
                        ldapFree( *pppberval, LDAP_BUFFER_SIGNATURE );
                        *pppberval = ppbervalNew;
                        currentArraySize += CHUNK_SIZE;
                    }

                    retval = lber->HrGetValueWithAlloc( (&(*pppberval)[numofbervals]), TRUE);
                    numofbervals++;
            }
            
            break;
         }
      case 'x':   // Skip element.
         {
            retval = lber->HrSkipElement();
            break;
         }
      case '{':   // Begin sequence
         {
             retval = lber->HrStartReadSequence(BER_SEQUENCE, TRUE);
             break;
         }
      case '}':   // End sequence
         {
             retval = lber->HrEndReadSequence();
             break;
         }
      case '[':   // Begin Set
         {
             retval = lber->HrStartReadSequence(BER_SET, TRUE);
             break;
         }
      case ']':   // End set
         {
             retval = lber->HrEndReadSequence();
             break;
         }

         }
      }
   va_end( argPtr );

   return (retval == NO_ERROR) ? NO_ERROR : LBER_ERROR;

}

// newber.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\names.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    names.cxx handle LDAP names

Abstract:

   This module implements the APIs to break apart LDAP names

Author:

    Andy Herron   (andyhe)        02-Jul-1996
    Anoop Anantha (anoopa)        09-Aug-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

WCHAR
ia5_toupper( WCHAR ch );

PWCHAR * __cdecl
ldap_explode_dnW (
    PWCHAR dn,
    ULONG notypes
    )
//
//  explode the name "cn=andyhe, o=microsoft, c=US"
//  into ->  cn=andyhe
//           o=microsoft
//           c=US
//
{
    PWCHAR currentPosition = dn;
    WCHAR savedChar;
    ULONG numberEntries = 0;
    PWCHAR nextSeparator;        // pointer to separator
    PWCHAR *arrayToReturn = NULL;
    PWCHAR  endOfValue;          // end of current value, no spaces or quotes

    if (currentPosition == NULL) {

        return NULL;
    }

    __try {

        while ((*currentPosition != L'=') && (*currentPosition != L'\0')) {
            currentPosition++;
        }
    
        if (*currentPosition != L'=') {
    
            //
            //  This does not contain = signs, therefore must be DNS name only.
            //  These contain either '@' or '.', so we separate them out based
            //  on these.
            //
    
            currentPosition = dn;
    
            //
            //  we don't use strtok here because the WAB guys don't want us to
            //  load MSVCRT dll.
            //
    
            while (*currentPosition != L'\0') {
    
                nextSeparator = currentPosition;
    
                while ((*nextSeparator != L'\0') &&
                       (*nextSeparator != L'@')  &&
                       (*nextSeparator != L'.') ) {
                    nextSeparator++;
                }
    
                savedChar = *nextSeparator;
                *nextSeparator = L'\0';
    
                add_string_to_list( &arrayToReturn,
                                    &numberEntries,
                                    currentPosition,
                                    TRUE );
    
                *nextSeparator = savedChar;
                currentPosition = nextSeparator;
    
                if (*currentPosition != L'\0') {
                    currentPosition++;
                }
            }
    
            return arrayToReturn;
        }
    
        //
        //  These contain either '@' or '.', so we separate them out based
        //  on these.
        //
    
        currentPosition = dn;
    
        //
        //  we don't use strtok here because the WAB guys don't want us to
        //  load MSVCRT dll.
        //
    
        while (*currentPosition != L'\0') {
    
           nextSeparator = currentPosition;
    
            //
            //  pick up the next full ava "cn = bob" or "cn = bob\" robert"
            //
    
            do {
    
                if (*nextSeparator == L'"') {
    
                    //
                    //  look for either non-escaped endquote or nul
                    //
    
                    do {
                        
                        if ((*nextSeparator ==  L'\\') &&
                            (*(nextSeparator+1) != L'\0')) {
    
                            nextSeparator++;
                        }
                        
                        nextSeparator++;
    
                      } while ((*nextSeparator != L'\0') && (*nextSeparator != L'"'));
    
                
                } else if ( *nextSeparator == L'\\' ) {
    
                    nextSeparator++;
    
                    if ((*nextSeparator) == L'\0') {
    
                        //
                        //  the string ends in a \, this is invalid.  end it here
                        //
    
                        currentPosition = nextSeparator;
    
                    } else {
    
                        nextSeparator++;      // skip the escaped character
                        continue;
                    }
                }
    
                nextSeparator++;
    
            } while (( *nextSeparator != L'\0') &&
                     ( *nextSeparator != L';') &&
                     ( *nextSeparator != L','));
    
            while (*currentPosition == L' ') {
                currentPosition++;
            }
    
            if (*currentPosition == L'\0') {
                break;
            }
    
            //
            //  end of current string is separator, back up one to point to
            //  end of value
            //
    
            endOfValue = nextSeparator - 1;
    
            while ((*endOfValue == L' ') &&      // strip trailing blanks
                   (endOfValue > currentPosition) ) {
    
               if ((*(endOfValue-1) == '\\')&&
                    (*(endOfValue-2) != '\\')) {
                  //
                  // Don't strip off blank if it is escaped.
                  //
                  break;
               }
    
                endOfValue--;
            }
    
            //
            //  coming out of the above loop, currentPosition points to beginning
            //  of AVA, nextSeparator points to separator or null, and
            //  endOfValue points to last char in value (or '"').
            //
    
            if (notypes) {
    
                PWCHAR startingPosition = currentPosition;
    
                //
                //  skip past the attribute name and equals to the value
                //
    
                while ((*currentPosition != L'=') &&
                       (currentPosition < endOfValue)) {
    
                    currentPosition++;
                }
    
                //
                //  if we didn't find an equal, just copy the whole bloomin thing
                //
    
                if (*currentPosition != L'=') {
                    currentPosition = startingPosition;
                } else {
                    currentPosition++;
                }
    
                while (*currentPosition == L' ') {
                    currentPosition++;
                }
    
                if (*currentPosition == L'"') {
                    currentPosition++;
    
                    if (*endOfValue == L'"') {
                        endOfValue--;
                    }
                }
            }
    
            //
            //  make sure we didn't get some funky string like a=""
            //
    
            if (currentPosition <= endOfValue) {
    
                endOfValue++;
    
                savedChar = *endOfValue;
                *endOfValue = L'\0';
    
                add_string_to_list( &arrayToReturn,
                                    &numberEntries,
                                    currentPosition,
                                    TRUE );
    
                *endOfValue = savedChar;
            }
    
            currentPosition = nextSeparator;
    
            if (*currentPosition != L'\0') {
                currentPosition++;
            }
        }
    
        return arrayToReturn;
    
    }__except (EXCEPTION_EXECUTE_HANDLER) {

         //
         // Free any partial array allocations.
         //
         
         ldap_value_freeW( arrayToReturn );
         return NULL;
    }
}

PCHAR * __cdecl
ldap_explode_dn (
    PCHAR dn,
    ULONG notypes
    )
//
//  This calls the unicode form of explodeDn and then converts the output from
//  Unicode to ansi before we give back the result.
//
{
    PWCHAR wName = NULL;
    PWCHAR *Names = NULL;
    PCHAR *ansiNames;
    PCHAR explodedName;
    ULONG err;

    err = ToUnicodeWithAlloc( dn, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        return NULL;
    }

    Names = ldap_explode_dnW( wName, notypes );

    ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    ansiNames = (PCHAR *) Names;

    if (ansiNames != NULL) {

        while (*Names != NULL) {
            explodedName = NULL;

            err = FromUnicodeWithAlloc( *Names, &explodedName, LDAP_VALUE_SIGNATURE, LANG_ACP );

            if (err != LDAP_SUCCESS) {

                //
                //  so close... we just couldn't convert from Unicode.  No way
                //  to return a meaningful error here.
                //

                ldap_value_free( ansiNames );
                return NULL;
            }

            ldapFree( *Names, LDAP_VALUE_SIGNATURE );
            *((PCHAR *) Names) = explodedName;
            Names++;        // on to next entry in array
        }
    }
    return ansiNames;
}

PWCHAR __cdecl
ldap_dn2ufnW (
    PWCHAR dn
    )
//
//  From RFC 1781...
//
// To take a distinguished name, and generate a name of this format with
// attribute types omitted, the following steps are followed.
//
//  1.  If the first attribute is of type CommonName, the type may be
//      omitted.
//
//  2.  If the last attribute is of type Country, the type may be
//      omitted.
//
//  3.  If the last attribute is of type Country, the last
//      Organisation attribute may have the type omitted.
//
//  4.  All attributes of type OrganisationalUnit may have the type
//      omitted, unless they are after an Organisation attribute or
//      the first attribute is of type OrganisationalUnit.
//
{
    PWCHAR currentPosition = dn;
    PWCHAR bufferToReturn;
    BOOLEAN inQuotes = FALSE;
    PWCHAR marker;
    BOOLEAN foundOrganization = FALSE;
    BOOLEAN foundCountry = FALSE;
    PWCHAR outputPosition;

    if (currentPosition == NULL) {

        return NULL;
    }

    //
    //  since we may in fact expand the string past what is currently
    //  allocated, grab a bit more than we need.  This is a rare case, and
    //  we don't overrun much.
    //

    bufferToReturn = ldap_dup_stringW(  dn,
                                        16,
                                        LDAP_BUFFER_SIGNATURE );

    if (bufferToReturn == NULL) {

        return NULL;
    }

    while ((*currentPosition != L'=') && (*currentPosition != L'\0')) {
        currentPosition++;
    }

    //
    //  if it isn't an AVA type of name, just return whole string
    //

    if (*currentPosition != L'=') {

        return bufferToReturn;
    }

    currentPosition = dn;
    outputPosition = bufferToReturn;

    while (*currentPosition == L' ') {
        currentPosition++;
    }

    marker = currentPosition;

    //
    //  if the first attribute type is 'cn', move past it
    //

    if ((*currentPosition == L'c') &&
        (*(currentPosition+1) == L'n')) {

        currentPosition += 2;

        while (*currentPosition == L' ') {
            currentPosition++;
        }

        if (*currentPosition != L'=') {
            currentPosition = marker;
        } else {
            currentPosition++;
        }
    }

    while (*currentPosition != L'\0') {

        switch (*currentPosition) {
        case L'"':
            inQuotes = (BOOLEAN) ( inQuotes ? FALSE : TRUE );
            break;

        case L';':
        case L',':
            if (! inQuotes) {

                *outputPosition++ = L',';
                *outputPosition++ = L' ';
                currentPosition++;

                //
                //  find beginning of next attribute
                //

                while (*currentPosition == L' ') {
                    currentPosition++;
                }

                //
                //  check for 'c='
                //

                if (foundCountry == FALSE) {

                    if ((*currentPosition == L'c') &&
                        ((*(currentPosition+1) == L' ') ||
                         (*(currentPosition+1) == L'='))) {

                        foundCountry = TRUE;
                        currentPosition++;

                        while ((*currentPosition == L' ') ||
                               (*currentPosition == L'=')) {
                            currentPosition++;
                        }
                        continue;
                    }

                    if (foundOrganization == FALSE) {

                        //
                        //  look for o=
                        //

                        if ((*currentPosition == L'o') &&
                            ((*(currentPosition+1) == L' ') ||
                             (*(currentPosition+1) == L'='))) {

                            foundOrganization = TRUE;
                            currentPosition++;

                            while ((*currentPosition == L' ') ||
                                   (*currentPosition == L'=')) {
                                currentPosition++;
                            }
                            continue;
                        }

                        //
                        //  look for ou=
                        //

                        if ((*currentPosition == L'o') &&
                            (*(currentPosition+1) == L'u') &&
                            ((*(currentPosition+2) == L' ') ||
                             (*(currentPosition+2) == L'='))) {

                            currentPosition += 2;

                            while ((*currentPosition == L' ') ||
                                   (*currentPosition == L'=')) {
                                currentPosition++;
                            }
                            continue;
                        }

                    } else {        // have we found o=

                        //
                        //  look for st=
                        //

                        if ((*currentPosition == L's') &&
                            (*(currentPosition+1) == L't') &&
                            ((*(currentPosition+2) == L' ') ||
                             (*(currentPosition+2) == L'='))) {

                            currentPosition += 2;

                            while ((*currentPosition == L' ') ||
                                   (*currentPosition == L'=')) {
                                currentPosition++;
                            }
                            continue;
                        }

                        //
                        //  look for l=
                        //

                        if ((*currentPosition == L'l') &&
                            ((*(currentPosition+1) == L' ') ||
                             (*(currentPosition+1) == L'='))) {

                            currentPosition++;

                            while ((*currentPosition == L' ') ||
                                   (*currentPosition == L'=')) {
                                currentPosition++;
                            }
                            continue;
                        }
                    }
                }
            }
            break;

        case L' ':           // don't copy spaces unless within quotes
            if (! inQuotes) {
                currentPosition++;
                continue;
            }
            break;

        default:        // do nothing but fall through, we copy the char below
            break;
        }

        *outputPosition++ = *currentPosition;
        currentPosition++;
    }

    *outputPosition = L'\0';
    return bufferToReturn;
}

PCHAR __cdecl
ldap_dn2ufn (
    PCHAR dn
    )
{
    ULONG err;
    PWCHAR wName = NULL;
    PWCHAR wNewUfn = NULL;
    PCHAR pUfn = NULL;

    err = ToUnicodeWithAlloc( dn, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP);

    if (err != LDAP_SUCCESS) {

        return NULL;
    }

    wNewUfn = ldap_dn2ufnW( wName );

    ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wNewUfn != NULL) {

        err = FromUnicodeWithAlloc( wNewUfn, &pUfn, LDAP_BUFFER_SIGNATURE, LANG_ACP );
        ldapFree( wNewUfn, LDAP_BUFFER_SIGNATURE );
    }

    return pUfn;
}

ULONG __cdecl
ldap_ufn2dnW (
    PWCHAR ufn,
    PWCHAR *pDn
    )
//
//  From RFC 1781...
//
// Take a user friendly name and generate a valid DN format.
// The following steps are followed :
//
//  1.  If the first attribute type is not specified, it is
//      CommonName.
//
//  2.  If the last attribute type is not specified, it is Country.
//
//  3.  If there is no organisation explicitly specified, the last
//      attribute with type not specified is of type Organisation.
//
//  4.  Any remaining attribute with type unspecified must be before
//      an Organisation or OrganisationalUnit attribute, and is of
//      type OrganisationalUnit.
//
//  5.  We uppercase all attribute types.
//
//  6.  All whitespace between attribute type, '=', and attribute values
//      are eliminated.
//
{
    PWCHAR currentPosition = ufn;
    PWCHAR equalPointer;
    ULONG numberOfElements = 1;
    ULONG err;
    PWCHAR marker;
    BOOLEAN foundOrganization = FALSE;
    BOOLEAN foundCountry = FALSE;
    PWCHAR outputPosition;
    ULONG tokenLength;
    ULONG numberElementsParsed = 0;
    PWCHAR secondToLastOU = NULL;
    PWCHAR lastOU = NULL;
    BOOLEAN interveningAttributeFound = FALSE;

    if (pDn == NULL) {
        return LDAP_PARAM_ERROR;
    }

    *pDn = NULL;

    if (ufn == NULL) {
        return LDAP_SUCCESS;
    }

    //
    //  count the number of distinct elements, we don't worry about
    //  quotes or escape characters.. just calculate a worst case.
    //

    while (*currentPosition != L'\0') {

        if (*(currentPosition++) == L',') {

            numberOfElements++;
        }
    }

    //
    //  We'll expand it by adding at most the following :
    //   initial "cn="
    //   last "c="
    //   numberOfElements * "ou="
    //
    //   This gives us an upper limit on the size.
    //

    *pDn = ldap_dup_stringW( ufn,
                             5 + (numberOfElements * 3),
                             LDAP_GENERATED_DN_SIGNATURE );

    if (*pDn == NULL) {

        return LDAP_NO_MEMORY;
    }

    outputPosition = *pDn;
    currentPosition = ufn;

    while (*currentPosition != L'\0') {

        //
        //  toss in a comma separator before the next token
        //

        if (numberElementsParsed > 0) {

            *(outputPosition++) = L',';
        }

        err = ParseLdapToken(   currentPosition,
                                &marker,
                                &equalPointer,
                                &currentPosition );

        if (err != LDAP_SUCCESS) {

            ldapFree( *pDn, LDAP_GENERATED_DN_SIGNATURE );
            *pDn = NULL;
            return err;
        }

        if (*marker == L'\0') {

            //
            //  hmmm... the DN ended on a comma.  we'll allow it.
            //

            break;
        }

        if ((marker == currentPosition) ||
            (marker == equalPointer)) {

            //
            //  hmmm.... they specified ", stuff" or "= stuff" to start with
            //  and this is invalid
            //
NamingViolation:

            //
            //  if they specified what we think is an invalid DN,  we
            //  may very well be wrong.  We try our best but we've seen
            //  some really funky DNs returned by servers... so let's
            //  just return the DN as it was passed in to us.
            //

            CopyMemory( *pDn, ufn, (strlenW( ufn ) + 1 ) * sizeof(WCHAR));
            return LDAP_SUCCESS;
        }

        if (equalPointer == NULL) {

            if (numberElementsParsed == 0) {

                *(outputPosition++) = L'C';
                *(outputPosition++) = L'N';
                *(outputPosition++) = L'=';

            } else if (foundCountry == FALSE) {

                interveningAttributeFound = FALSE;

                //
                //  remember where we copied this in because we may have to
                //  go back in later and change it to a O= or C=
                //

                secondToLastOU = lastOU;
                lastOU = outputPosition;

                if (foundOrganization == FALSE) {

                    *(outputPosition++) = L'O';
                    *(outputPosition++) = L'U';
                    *(outputPosition++) = L'=';
                }
            }

            equalPointer = marker;

        } else {

            BOOLEAN isCountry = FALSE;
            BOOLEAN isOrg = FALSE;

            //
            //  an attribute type has been specified.
            //  copy the attribute name as uppercased with no embedded spaces.
            //

            if (*marker == L'C' || *marker == L'c') {
                isCountry = TRUE;
            }

            if (*marker == L'O' || *marker == L'o') {
                isOrg = TRUE;
            }

            *(outputPosition++) = ia5_toupper( *marker );

            marker++;

            while (marker < equalPointer) {

                if (*marker != L' ') {

                    isCountry = FALSE;
                    isOrg = FALSE;

                    *(outputPosition++) = ia5_toupper( *marker );
                }
                marker++;
            }

            if (isCountry) {

                foundCountry = TRUE;

            } else {

                interveningAttributeFound = TRUE;

            }
            if (isOrg) {

                foundOrganization = TRUE;
            }

            *(outputPosition++) = L'=';
            equalPointer++;             // point to next char past '='
        }

        //
        //  getting to here, equalPointer should point to the first position
        //  past the equal sign to the value that we'll copy to the output buffer
        //

        while (*equalPointer == L' ') {

            equalPointer++;
        }

        if ((*equalPointer == L'\0') || (*equalPointer == L',')) {

            goto NamingViolation;
        }

        ASSERT( currentPosition > equalPointer );

        tokenLength = (ULONG)(((PCHAR) currentPosition) - ((PCHAR) equalPointer));

        numberElementsParsed++;

        CopyMemory( outputPosition, equalPointer, tokenLength );
        outputPosition += ( tokenLength / sizeof(WCHAR) );

        //
        //  skip forward to point to next AVA
        //

        if (*currentPosition != L'\0') {

            currentPosition++;
        }
    }

    *outputPosition = L'\0';

    //
    //  if we added a couple of "OU=" at the end, let's go back and change them
    //  to "O=" and "C="
    //

    if ((foundCountry == TRUE) &&
        (foundOrganization == TRUE)) {

        //
        //  Both a O= and a C= were specified by the client, nothing to do or
        //  undo here.
        //

    } else if ( foundCountry == TRUE ) {

        //
        //  Only a C= was found.  Need to go back to last OU= we put in and
        //  change it to O=.
        //

        if (lastOU != NULL) {

            //  change it from OU= to O= by moving everything up.

            ldap_MoveMemory( (PCHAR) (lastOU+1),
                             (PCHAR) (lastOU+2),
                             (strlenW(lastOU+2) + 1) * sizeof(WCHAR));
        }

    } else if ( foundOrganization == TRUE ) {

        //
        //  Only a O= was specified.  Need to go to last one and modify it to
        //  C=.  We only do this if the very last element didn't have a
        //  attribute identifier.
        //

        if ((lastOU != NULL) && (interveningAttributeFound == FALSE)) {

            //  toss in C= by moving everything down.

            ldap_MoveMemory( (PCHAR) (lastOU+2),
                             (PCHAR) lastOU,
                             (strlenW(lastOU) + 1) * sizeof(WCHAR));
            *lastOU = L'C';
            *(lastOU+1) = L'=';
        }

    } else {

        //
        //  Neither a C= or O= was specified.  If the last token didn't have
        //  an attribute identifier, change it to C= from OU=
        //

        if (lastOU != NULL) {

            if (interveningAttributeFound == FALSE) {

                //  change it from OU= to C= by moving everything up.

                ASSERT( *lastOU == L'O' );
                *lastOU = L'C';
                ldap_MoveMemory(    (PCHAR) (lastOU+1),
                                    (PCHAR) (lastOU+2),
                                    (strlenW(lastOU+2) + 1) * sizeof(WCHAR));

                if (secondToLastOU != NULL) {

                    //
                    //  They really didn't have any types... not only do
                    //  we convert the last OU= to C= (which we just did
                    //  above) but here we change the second to last OU=
                    //  to O=
                    //

                    ASSERT( *secondToLastOU == L'O' );
                    ldap_MoveMemory( (PCHAR) (secondToLastOU+1),
                                     (PCHAR) (secondToLastOU+2),
                                     (strlenW(secondToLastOU+2) + 1) * sizeof(WCHAR));
                }
            } else {

                // there was an intervening named attribute between the
                // last unnamed one and the end, so we assume that the last
                // unnamed one is O=, since none was specified.

                ASSERT( *lastOU == L'O' );
                ldap_MoveMemory(    (PCHAR) (lastOU+1),
                                    (PCHAR) (lastOU+2),
                                    (strlenW(lastOU+2) + 1)*sizeof(WCHAR));
            }
        }
    }

    return LDAP_SUCCESS;
}

ULONG __cdecl
ldap_ufn2dn (
    PCHAR ufn,
    PCHAR *pDn
    )
{
    ULONG err;
    PWCHAR wName = NULL;
    PWCHAR wNewDn = NULL;

    if (pDn == NULL) {
        return LDAP_PARAM_ERROR;
    }

    *pDn = NULL;

    err = ToUnicodeWithAlloc( ufn, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        return err;
    }

    err = ldap_ufn2dnW( wName, &wNewDn );

    ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wNewDn != NULL) {

        err = FromUnicodeWithAlloc( wNewDn, pDn, LDAP_GENERATED_DN_SIGNATURE, LANG_ACP );
        ldapFree( wNewDn, LDAP_GENERATED_DN_SIGNATURE );
    }

    return err;
}

ULONG
ParseLdapToken (
    PWCHAR CurrentPosition,
    PWCHAR *StartOfToken,
    PWCHAR *EqualSign,
    PWCHAR *EndOfToken
    )
//
//  Find end of token such as ',' or L'\0'.  Also save off position of '='
//  and of start of attribute name.
//
{
    BOOLEAN inQuotes = FALSE;
    BOOLEAN foundEquals = FALSE;

    while (*CurrentPosition == L' ') {
        CurrentPosition++;
    }

    *StartOfToken = CurrentPosition;
    *EqualSign = NULL;

    while (*CurrentPosition != L'\0') {

        if (*CurrentPosition == L'\\') {

            //
            //  allow characters to be escaped, but include the escape
            //

            if (*(CurrentPosition+1) != L'\0') {

                CurrentPosition++;
            }
        } else if (*CurrentPosition == L'"') {

            inQuotes = (BOOLEAN) ( inQuotes ? FALSE : TRUE );

        } else if (inQuotes == FALSE) {

            if (*CurrentPosition == L'=') {

                if (foundEquals == FALSE) {

                    foundEquals = TRUE;
                    *EqualSign = CurrentPosition;
                }
            }

            if (*CurrentPosition == L',') {

                break;
            }
        }
        CurrentPosition++;
    }

    *EndOfToken = CurrentPosition;
    return LDAP_SUCCESS;
}

//
//  can't use toupper because that would pull in msvcrt.dll
//

WCHAR
ia5_toupper (
    WCHAR ch
    )
{
    if (ch >= L'a' && ch <= L'z') {

        ch -= L'a';
        ch += L'A';
    }
    return ch;
}

// results.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\open.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    open.cxx  open a connection to an LDAP server

Abstract:

   This module implements the LDAP ldap_open API.

Author:

    Andy Herron    (andyhe)        08-May-1996
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"
#include <dststlog.h>

#define LDAP_CONNECT_TIMEOUT     45    // seconds
#define MAX_PARALLEL_CONNECTS    20    // Limited to 64 because select can't handle more
#define CONNECT_INTERVAL         100   // milliseconds
#define MAX_SOCK_ADDRS           100   // max number of records we will retrieve
#define SAMESITE_CONNECT_TIMEOUT 10    // seconds for intra site connections
#define LDAP_QUICK_TIMEOUT       2     // in seconds to accomodate high latency links.

DEFINE_DSLOG;

LDAP *LdapConnectionOpen (
    PWCHAR HostName,
    ULONG PortNumber,
    BOOLEAN Udp
    );

INT
OpenLdapServer (
    PLDAP_CONN Connection,
    struct l_timeval  *timeout
    );

ULONG
LdapWinsockConnect (
    PLDAP_CONN Connection,
    USHORT PortNumber,
    PWCHAR HostName,
    struct l_timeval  *timeout,
    BOOLEAN samesite
    );

BOOLEAN
LdapIsAddressNumeric (
    PWCHAR HostName
    );

struct hostent *
GetHostByNameW(
    PWCHAR  hostName
 );

ULONG
Inet_addrW(
   PWCHAR  IpAddressW
 );

ULONG
GetCurrentMachineParams(
    PWCHAR* Address,
    PWCHAR* DnsHostName
    );

//
//  This routine is one of the main entry points for clients calling into the
//  ldap API.  The Hostname is a list of 0 to n hosts, separated by spaces.
//  The host name can be either a name or a TCP address of the form
//  nnn.nnn.nnn.nnn.
//

LDAP * __cdecl ldap_openW (
    PWCHAR HostName,
    ULONG PortNumber
    )
{
    return LdapConnectionOpen( HostName, PortNumber, FALSE );
}

//
//  This routine is one of the main entry points for clients calling into the
//  ldap API.  The Hostname is a list of 0 to n hosts, separated by spaces.
//  The host name can be either a name or a TCP address of the form
//  nnn.nnn.nnn.nnn.
//

LDAP * __cdecl ldap_open (
    PCHAR HostName,
    ULONG PortNumber
    )
{

    LDAP* ExternalHandle = NULL;
    ULONG err;
    PWCHAR wHostName = NULL;

    err = ToUnicodeWithAlloc( HostName,
                              -1,
                              &wHostName,
                              LDAP_UNICODE_SIGNATURE,
                              LANG_ACP );

    if (err == LDAP_SUCCESS) {

        ExternalHandle = LdapConnectionOpen( wHostName, PortNumber, FALSE );
    }

    ldapFree(wHostName, LDAP_UNICODE_SIGNATURE);

    return ExternalHandle;
}

LDAP * __cdecl cldap_open (
    PCHAR HostName,
    ULONG PortNumber
    )
{
    LDAP* ExternalHandle = NULL;
    ULONG err;
    PWCHAR wHostName = NULL;

    err = ToUnicodeWithAlloc( HostName,
                              -1,
                              &wHostName,
                              LDAP_UNICODE_SIGNATURE,
                              LANG_ACP );

    if (err == LDAP_SUCCESS) {

        ExternalHandle = LdapConnectionOpen( wHostName, PortNumber, TRUE );
    }

    ldapFree(wHostName, LDAP_UNICODE_SIGNATURE);

    return ExternalHandle;
}

LDAP * __cdecl cldap_openW (
    PWCHAR HostName,
    ULONG PortNumber
    )
{
    return LdapConnectionOpen( HostName, PortNumber, TRUE );
}

LDAP * __cdecl ldap_sslinit (
    PCHAR HostName,
    ULONG PortNumber,
    int Secure
    )
{
    LDAP* connection = NULL;
    ULONG err;
    PWCHAR wHostName = NULL;

    err = ToUnicodeWithAlloc( HostName,
                              -1,
                              &wHostName,
                              LDAP_UNICODE_SIGNATURE,
                              LANG_ACP );

    if (err == LDAP_SUCCESS) {

        connection = ldap_sslinitW( wHostName, PortNumber,(ULONG) Secure );
    }

    ldapFree(wHostName, LDAP_UNICODE_SIGNATURE);

    return connection;

}


LDAP * __cdecl ldap_init (
    PCHAR HostName,
    ULONG PortNumber
    )
{
    return ldap_sslinit( HostName, PortNumber, 0 );
}


LDAP * __cdecl ldap_initW (
    PWCHAR HostName,
    ULONG PortNumber
    )
{
    return ldap_sslinitW( HostName, PortNumber, 0 );
}


LDAP * __cdecl ldap_sslinitW (
    PWCHAR HostName,
    ULONG PortNumber,
    int Secure
    )
{
    PLDAP_CONN connection;

    connection = LdapAllocateConnection( HostName, PortNumber, (ULONG) Secure, FALSE );

    if (connection == NULL) {

        return NULL;
    }

    //
    // No locks needed - not yet added to connection list
    //

    connection->HandlesGivenToCaller++;

    //
    // Add it to global list of connections
    //

    ACQUIRE_LOCK( &ConnectionListLock );

    InsertTailList( &GlobalListActiveConnections, &connection->ConnectionListEntry );

    RELEASE_LOCK( &ConnectionListLock );

    DereferenceLdapConnection( connection );

    return connection->ExternalInfo;

}


LDAP_CONN * LdapAllocateConnection (
    PWCHAR HostName,
    ULONG PortNumber,
    ULONG Secure,
    BOOLEAN Udp
    )
//
//  This routine creates a data block containing instance data for a connection.
//
//  Must return a Win32 error code.
//
{
    PLDAP_CONN connection = NULL;
    ULONG err;
    HANDLE hConnectEvent = NULL;

    DWORD dwCritSectInitStage = 0;

    if (LdapInitializeWinsock() == FALSE) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LdapAllocateConnection could not initialize winsock, 0x%x.\n", GetLastError());
        }
        SetLastError( ERROR_NETWORK_UNREACHABLE );
        SetConnectionError(NULL, LDAP_CONNECT_ERROR, NULL);
        return NULL;
    }

    (VOID) LdapInitSecurity();

    hConnectEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

    if (hConnectEvent == NULL) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LdapAllocateConnection could not alloc event, 0x%x.\n", GetLastError());
        }
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        SetConnectionError(NULL, LDAP_NO_MEMORY, NULL);
        return NULL;
    }

    //
    //  allocate the connection block and setup all the initial values
    //

    connection = (PLDAP_CONN) ldapMalloc( sizeof( LDAP_CONN ), LDAP_CONN_SIGNATURE );

    if (connection == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap_open could not allocate 0x%x bytes.\n", sizeof( LDAP_CONN ) );
        }

        CloseHandle( hConnectEvent );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        SetConnectionError(NULL, LDAP_NO_MEMORY, NULL);        
        return NULL;
    }

    if (HostName != NULL) {

        connection->ListOfHosts = ldap_dup_stringW( HostName, 0, LDAP_HOST_NAME_SIGNATURE );

        if (connection->ListOfHosts == NULL) {

            IF_DEBUG(OUTMEMORY) {
                LdapPrint1( "ldap_open could not allocate mem for %s\n", HostName );
            }

            ldapFree( connection, LDAP_CONN_SIGNATURE );

            CloseHandle( hConnectEvent );
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            SetConnectionError(NULL, LDAP_NO_MEMORY, NULL);        
            return NULL;
        }
    }

    InterlockedIncrement( &GlobalConnectionCount );

    //
    //  keep in mind the memory is already zero initialized
    //

    connection->ReferenceCount = 2;
    connection->ConnectEvent = hConnectEvent;

    connection->ConnObjectState = ConnObjectActive;

    connection->publicLdapStruct.ld_options = LDAP_OPT_DNS |
                                    LDAP_OPT_CHASE_REFERRALS |
                                    LDAP_CHASE_SUBORDINATE_REFERRALS |
                                    LDAP_CHASE_EXTERNAL_REFERRALS;

    connection->PortNumber = LOWORD( PortNumber );
    connection->AREC_Exclusive = FALSE;
    connection->ExternalInfo = &connection->publicLdapStruct;
    connection->publicLdapStruct.ld_version = ( Udp ? LDAP_VERSION3 : LDAP_VERSION2 );
    connection->HighestSupportedLdapVersion = LDAP_VERSION2;
    connection->TcpHandle = INVALID_SOCKET;
    connection->UdpHandle = INVALID_SOCKET;
    connection->MaxReceivePacket = INITIAL_MAX_RECEIVE_BUFFER;
    connection->NegotiateFlags = DEFAULT_NEGOTIATE_FLAGS;

    //  setup fields for keep alive processing

    connection->TimeOfLastReceive = LdapGetTickCount();
    connection->PingLimit = LOWORD( GlobalLdapPingLimit );
    connection->KeepAliveSecondCount = GlobalWaitSecondsForSelect;
    connection->PingWaitTimeInMilliseconds = GlobalPingWaitTime;
    connection->HostConnectState = HostConnectStateUnconnected;

    InitializeListHead( &connection->CompletedReceiveList );
    InitializeListHead( &connection->PendingCryptoList );
    SetNullCredentials( connection );

    connection->ConnectionListEntry.Flink = NULL;

    __try {

        INITIALIZE_LOCK( &(connection->ReconnectLock) );
        dwCritSectInitStage = 1;
        
        INITIALIZE_LOCK( &(connection->StateLock) );
        dwCritSectInitStage = 2;
        
        INITIALIZE_LOCK( &(connection->SocketLock) );
        dwCritSectInitStage = 3;
        
        INITIALIZE_LOCK( &(connection->ScramblingLock) );
        dwCritSectInitStage = 4;

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // Something went wrong
        //
        IF_DEBUG(ERRORS) {
            LdapPrint0( "LdapAllocateConnection could not initialize critical sections.\n");
        }

        switch (dwCritSectInitStage) {
            // fall-through is deliberate

        case 4:
            DELETE_LOCK(&(connection->ScramblingLock));
        case 3:
            DELETE_LOCK(&(connection->SocketLock));
        case 2:
            DELETE_LOCK(&(connection->StateLock));
        case 1:
            DELETE_LOCK(&(connection->ReconnectLock));
        case 0:
        default:
            break;
        }
        
        InterlockedDecrement( &GlobalConnectionCount );    
        ldapFree( connection->ListOfHosts, LDAP_HOST_NAME_SIGNATURE );
        ldapFree( connection, LDAP_CONN_SIGNATURE );
        CloseHandle( hConnectEvent );
        
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        SetConnectionError(NULL, LDAP_NO_MEMORY, NULL);        

        return NULL;
    }


    connection->publicLdapStruct.ld_deref = LDAP_DEREF_NEVER;
    connection->publicLdapStruct.ld_timelimit = LDAP_TIME_LIMIT_DEFAULT;
    connection->publicLdapStruct.ld_errno = LDAP_SUCCESS;
    connection->publicLdapStruct.ld_cldaptries = CLDAP_DEFAULT_RETRY_COUNT;
    connection->publicLdapStruct.ld_cldaptimeout = CLDAP_DEFAULT_TIMEOUT_COUNT;
    connection->publicLdapStruct.ld_refhoplimit = LDAP_REF_DEFAULT_HOP_LIMIT;
    connection->publicLdapStruct.ld_lberoptions = LBER_USE_DER;
    connection->PromptForCredentials = TRUE;
    connection->AutoReconnect = TRUE;
    connection->UserAutoRecChoice = TRUE;
    connection->ClientCertRoutine = NULL;
    connection->ServerCertRoutine = NULL;
    connection->SentPacket = FALSE;
    connection->ProcessedListOfHosts = FALSE;
    connection->ForceHostBasedSPN = FALSE;
    connection->DefaultServer = FALSE;

    if (Udp) {

        connection->UdpHandle = (*psocket)(PF_INET, SOCK_DGRAM, 0);

        err = ( connection->UdpHandle == INVALID_SOCKET ) ? ERROR_BAD_NET_NAME : 0;

    } else {

        connection->TcpHandle = (*psocket)(PF_INET, SOCK_STREAM, 0);

        err = ( connection->TcpHandle == INVALID_SOCKET ) ? ERROR_BAD_NET_NAME : 0;
    }

    if (err != 0) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint1( "ldap_create failed to open socket, err = 0x%x.\n", (*pWSAGetLastError)());
        }

exitWithError:
        CloseLdapConnection( connection );
        DereferenceLdapConnection( connection );
        SetLastError(err);
        SetConnectionError(NULL, (err == ERROR_SUCCESS ? LDAP_SUCCESS : LDAP_OPERATIONS_ERROR), NULL);
        return NULL;
    }

    ULONG secure = PtrToUlong(((Secure == 0) ? LDAP_OPT_OFF : LDAP_OPT_ON ));

    err = LdapSetConnectionOption( connection, LDAP_OPT_SSL, &secure, FALSE );

    if (err != LDAP_SUCCESS) {

        err = ERROR_OPEN_FAILED;
        goto exitWithError;
    }

    return connection;
}

//
//  After all of the above plethora of ways to get to this routine, we
//  have some code that actually allocates a connection block and sets it up.
//

LDAP *LdapConnectionOpen (
    PWCHAR HostName,
    ULONG PortNumber,
    BOOLEAN Udp
    )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = LdapAllocateConnection( HostName, PortNumber, 0, Udp );

    if (connection == NULL) {

        IF_DEBUG(CONNECTION) {
            LdapPrint1( "ldap_open failed to create connection, err = 0x%x.\n", GetLastError());
        }

        return NULL;
    }

    //
    //  open a connection to any of the servers specified
    //

    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {

        CloseLdapConnection( connection );
        DereferenceLdapConnection( connection );
        connection = NULL;
        SetConnectionError(NULL, err, NULL);
        SetLastError( LdapMapErrorToWin32( err ));

        IF_DEBUG(CONNECTION) {
            LdapPrint1( "ldap_open failed to open connection, err = 0x%x.\n", err);
        }
        return NULL;
    }

    //
    // We haven't given the connection to anyone - so object must be active
    //

    ASSERT(connection->ConnObjectState == ConnObjectActive);

    connection->HandlesGivenToCaller++;

    //
    // Add it to global list of connections
    //

    ACQUIRE_LOCK( &ConnectionListLock );

    InsertTailList( &GlobalListActiveConnections, &connection->ConnectionListEntry );

    RELEASE_LOCK( &ConnectionListLock );

    //
    // Wake up select so that it picks up the new connection handle.
    //
    
    LdapWakeupSelect();

    DereferenceLdapConnection( connection );

    return connection->ExternalInfo;
}

INT
OpenLdapServer (
    PLDAP_CONN Connection,
    struct l_timeval  *timeout
    )
//
//  The Connection->ListOfHosts parameter is a list of hosts of the form :
//      hostname
//      hostaddr
//      hostname:port
//      hostaddr:port
//
//  We should, for each one, do the following :
//
//      If name, call DsGetDcOpen to get DCs
//      If name and DsGetDcOpen fails, call gethostbyname, get list of addrs
//         for every addr we have, try connect()
//
//  Each of them is null terminated, the number is specified by
//  Connection->NumberOfHosts
//
//  This returns a Win32 error code.
{
    USHORT  PortNumber;
    USHORT  hostsTried;
    PWCHAR  hostName;
    INT     rc = ERROR_HOST_UNREACHABLE;
    INT     wsErr;
    USHORT  port;
    PWCHAR  endOfHost;
    PWCHAR  hostPtr;
    BOOLEAN haveTriedExplicitHost = FALSE;
    BOOLEAN tryingExplicitHost = FALSE;
    BOOLEAN samesite = FALSE;
    ULONGLONG   startTime;
    BOOLEAN fIsValidDnsSuppliedName = FALSE;
    DWORD DCFlags = 0;

#if DBG
    startTime = LdapGetTickCount();
#endif

    if ((Connection->ProcessedListOfHosts) && (Connection->DefaultServer == TRUE)) {

        //
        // If we're reconnecting, and the user originally asked us to find the default
        // server (by passing in NULL), we reset the internal state and go through the
        // DsGetDcName process again to retrieve a fresh DC.  This way, we have all the
        // data we need in order to generate a valid DNS-based SPN for Kerberos.
        //

        //
        // We need to free ListOfHosts.  ExplicitHostName and HostNameW may be aliased
        // to ListOfHosts.  So if they are, we need to take appropriate action.  We'll
        // just reset HostNameW later, so we free it if it didn't point to the same
        // memory as ListOfHosts, and reset it to NULL.  This prevents a leak.
        // For ExplicitHostName, we want to preserve it, so we copy it off if it is
        // currently an alias for ListOfHosts (in practice, I don't think this will
        // ever happen)
        //
        if (Connection->ExplicitHostName == Connection->ListOfHosts) {
            // Copy this off before freeing ListOfHosts if it's an alias to
            // ListOfHosts (see unbind.cxx)
            Connection->ExplicitHostName = ldap_dup_stringW(Connection->ExplicitHostName,
                                                            0,
                                                            LDAP_HOST_NAME_SIGNATURE);

            if ((Connection->ExplicitHostName) == NULL) {
                return LDAP_NO_MEMORY;
            }
        }

        if (( Connection->HostNameW != Connection->ExplicitHostName ) &&
           ( Connection->HostNameW != Connection->ListOfHosts )) {
            // Reset HostNameW --- this may point to a allocated block of memory,
            // or it may be a alias for ListOfHosts, hence the check above
            // (see unbind.cxx)
            ldapFree( Connection->HostNameW, LDAP_HOST_NAME_SIGNATURE );
        }
        Connection->HostNameW = NULL;

        // Free everything we'll set in the code to find a DC below
        ldapFree( Connection->ListOfHosts, LDAP_HOST_NAME_SIGNATURE );
        Connection->ListOfHosts = NULL;

        ldapFree( Connection->DnsSuppliedName, LDAP_HOST_NAME_SIGNATURE );
        Connection->DnsSuppliedName = NULL;

        ldapFree( Connection->DomainName, LDAP_HOST_NAME_SIGNATURE);
        Connection->DomainName = NULL;

        DCFlags = DS_FORCE_REDISCOVERY; // since our old DC may have gone down
        Connection->ProcessedListOfHosts = FALSE;  // we're resetting ListOfHosts
    }


    if (Connection->ListOfHosts == NULL) {

        PWCHAR Address, DnsName, DomainName;
        DWORD numAddrs = 1;
        ULONG strLen0, strLen1;

        Address = DnsName = DomainName = NULL;

        if ((!GlobalWin9x) &&
            ((Connection->PortNumber == LDAP_PORT) ||
             (Connection->PortNumber == LDAP_SSL_PORT))) {

            rc = GetCurrentMachineParams( &Address, &DnsName );
        }

         if (rc != LDAP_SUCCESS) {

            //
            //  Either the current machine is not a DC or we failed trying to
            //  find out.Get the domain name for the currently logged in user.
            //  alas, for now we just get the server name of a NTDS DC in the domain.
            //


            rc = GetDefaultLdapServer(    NULL,
                                          &Address,
                                          &DnsName,
                                          &DomainName,
                                          &numAddrs,
                                          Connection->GetDCFlags | DCFlags,
                                          &samesite,
                                          Connection->PortNumber
                                          );
         }

        if (rc != NO_ERROR) {

            return rc;
        }

        strLen0 = (Address == NULL) ? 0 : (strlenW( Address ) + 1);
        strLen1 = (DomainName == NULL) ? 0 : (strlenW( DomainName ) + 1);

        if (strLen0 > 1) {

            Connection->ListOfHosts = ldap_dup_stringW(  Address,
                                                         strLen1, // Allocate extra for the domain name
                                                         LDAP_HOST_NAME_SIGNATURE );

            if (Connection->ListOfHosts && (strLen1 > 1)) {

                PWCHAR nextHost = Connection->ListOfHosts + strLen0;

                // make this a space separated list of names

                    if (strLen0 > 0) {
                        *(nextHost-1) = L' ';
                    }
                ldap_MoveMemory( (PCHAR) nextHost, (PCHAR) DomainName, sizeof(WCHAR)*strLen1 );
            }

            ldapFree( Address, LDAP_HOST_NAME_SIGNATURE );
            Address = NULL;
            Connection->DnsSuppliedName = DnsName;
            fIsValidDnsSuppliedName = TRUE;
            Connection->DomainName = DomainName;
        }

        if (Connection->ListOfHosts == NULL) {

            ldapFree( Address, LDAP_HOST_NAME_SIGNATURE );
            SetLastError( ERROR_INCORRECT_ADDRESS );
            return ERROR_INCORRECT_ADDRESS;
        }

        Connection->DefaultServer = TRUE;
    } 

    //
    //  if we haven't already processed the list of hosts (i.e., this isn't
    //  a autoreconnect), go through the list of hosts and replace all spaces
    //  with nulls and count up number of hosts
    //
    //  If this is a autoreconnect, the NULLs were already inserted during the
    //  initial connect, and trying to do it a second time will cause us to
    //  lost all but the first host on the list (since we'll stop at the first
    //  NULL)
    //

    if (!Connection->ProcessedListOfHosts)
    {
        Connection->NumberOfHosts = 1;

        hostPtr = Connection->ListOfHosts;

        while (*hostPtr != L'\0') {

            if (*hostPtr == L' ') {

                Connection->NumberOfHosts++;
                *hostPtr = L'\0';
                hostPtr++;

                while (*hostPtr == L' ') {
                    hostPtr++;
                }
            } else {

                hostPtr++;
            }
        }

        Connection->ProcessedListOfHosts = TRUE;
    }
    
    //
    //  Try to connect to the server(s) specified by hostName
    //

RetryWithoutExplicitHost:

    PortNumber = Connection->PortNumber;
    hostsTried = 0;

    hostName = Connection->ListOfHosts;

    //
    //  if the app suggested a server to try by calling ldap_set_option with
    //  LDAP_OPT_HOSTNAME before we got in here, then we try that name first
    //

    if ((haveTriedExplicitHost == FALSE) &&
        (Connection->ExplicitHostName != NULL)) {

        hostName = Connection->ExplicitHostName;
        haveTriedExplicitHost = TRUE;
        tryingExplicitHost = TRUE;
    }

    Connection->SocketAddress.sin_family = AF_INET;

    if (PortNumber == 0) {
        PortNumber = LDAP_SERVER_PORT;
    }
    Connection->SocketAddress.sin_port = (*phtons)( LOWORD( PortNumber ));

    rc = ERROR_HOST_UNREACHABLE;

    while (( hostsTried < Connection->NumberOfHosts ) &&
           ( rc != 0 )) {

        port = LOWORD( PortNumber );

        IF_DEBUG(CONNECTION) {
            LdapPrint2( "LDAP conn 0x%x trying host %S\n", Connection, hostName );
        }

        //
        //  pick up :nnn for port number
        //

        endOfHost = hostName;

        while ((*endOfHost != L':') &&
               (*endOfHost != L'\0')) {

            endOfHost++;
        }

        if (*endOfHost != L'\0') {

            PWCHAR portPtr = endOfHost + 1;

            //
            //  pick up port number
            //

            port = 0;

            while (*portPtr != L'\0') {

                if (*portPtr < L'0' ||
                    *portPtr > L'9') {

                    IF_DEBUG(CONNECTION) {
                        LdapPrint2( "LDAP conn 0x%x invalid port number for %S\n", Connection, hostName );
                    }
                    rc = ERROR_INVALID_NETNAME;
                    goto tryNextServer;
                }

                port = (port * 10) + (*portPtr++ - L'0');
            }
            if (port == 0) {
                port = LOWORD( PortNumber );
            }
            *endOfHost = L'\0';
        } else {
            endOfHost = NULL;
        }

        Connection->SocketAddress.sin_port = (*phtons)( port );

        if ( LdapIsAddressNumeric(hostName) ) {

            Connection->SocketAddress.sin_addr.s_addr = Inet_addrW( hostName );

            if (Connection->SocketAddress.sin_addr.s_addr != INADDR_NONE) {

                rc = LdapWinsockConnect( Connection, port, hostName, timeout, samesite );

                if (!fIsValidDnsSuppliedName) {
                    if (Connection->DnsSuppliedName) {
                        ldapFree( Connection->DnsSuppliedName, LDAP_HOST_NAME_SIGNATURE );
                        Connection->DnsSuppliedName = NULL;
                    }
                }

                //
                // If the user explicitly connects via a numeric IP address, we want to
                // make sure that the resulting SPN contains that IP address, not a
                // retrieved DNS name corresponding to that IP address, for security
                // reasons (DNS can be spoofed).
                //
                // If we're here, the user must have explicitly passed in a IP address,
                // unless we just retrieved the IP address from the locator because the
                // user passed in NULL (fIsValidDnsSuppliedName).
                //
                if (!fIsValidDnsSuppliedName)
                {
                    Connection->ForceHostBasedSPN = TRUE;
                }

            } else {

                IF_DEBUG(CONNECTION) {
                    LdapPrint1( "LDAP inet_addr failed to get address from %S\n", hostName );
                }
            }

        } else {

           struct hostent *hostEntry = NULL;
           BOOLEAN connected = FALSE;
           ULONG dnsSrvRecordCount = 0;
           BOOLEAN LoopBack = FALSE;

           if (ldapWStringsIdentical( 
                        Connection->ListOfHosts,
                        -1,
                        L"localhost",
                        -1)) {
               
               LoopBack = TRUE;
           }

           if ( (Connection->AREC_Exclusive == FALSE) && 
                (tryingExplicitHost == FALSE) &&
                (LoopBack == FALSE)) {
               
               rc = ConnectToSRVrecs( Connection,
                                      hostName,
                                      tryingExplicitHost,
                                      port,
                                      timeout );
               if (rc == LDAP_SUCCESS) {
                   connected = TRUE;
               }
           
           }

            if (connected == FALSE) {

                PWCHAR HostAddress = NULL;
                PWCHAR DnsName = NULL;
                PWCHAR DomainName = NULL;
                PWCHAR hostNameUsedByGetHostByName = hostName;

                //
                //  The hostname is of the form HOSTNAME.  Do a gethostbyname
                //  and try to connect to it.
                //


                hostEntry = GetHostByNameW( hostName );

                if ((hostEntry == NULL) &&
                    (Connection->AREC_Exclusive == FALSE) &&
                    (tryingExplicitHost == FALSE) &&
                    (LoopBack == FALSE)) {

                    wsErr = (*pWSAGetLastError)();

                    IF_DEBUG(CONNECTION) {
                       LdapPrint2( "LDAP gethostbyname failed for %S, 0x%x\n", hostName, wsErr );
                    }

                    rc = ERROR_INCORRECT_ADDRESS;

                    // now we try to connect to the name as if it were a
                    // domain name.  We've already checked SRV records, so
                    // try to make it work simply for a flat name like "ntdev".

                    if ((dnsSrvRecordCount == 0) &&
                        (tryingExplicitHost == FALSE)) {

                            DWORD numAddrs = 1;
                            samesite= FALSE;

                            rc = GetDefaultLdapServer(    hostName,
                                                          &HostAddress,
                                                          &DnsName,
                                                          &DomainName,
                                                          &numAddrs,
                                                          Connection->GetDCFlags | DS_IS_FLAT_NAME,
                                                          &samesite,
                                                          port
                                                          );

                            if (HostAddress != NULL) {

                                if ( LdapIsAddressNumeric(HostAddress) ) {

                                    Connection->SocketAddress.sin_addr.s_addr = Inet_addrW( HostAddress );

                                    if (Connection->SocketAddress.sin_addr.s_addr != INADDR_NONE) {

                                        rc = LdapWinsockConnect( Connection, port, HostAddress, timeout, samesite );

                                        //
                                        //  if we succeeded here, we have to
                                        //  move the HostName pointer in the
                                        //  connection record to point to the
                                        //  domain name since the server name
                                        //  may go away
                                        //
                                        // Also, store the real machine name in
                                        // the DnsSuppliedName field to be
                                        // used later for making up the SPN
                                        // during bind.
                                        //

                                        if (rc == 0) {

                                            Connection->HostNameW = hostName;
                                            Connection->DnsSuppliedName = DnsName;
                                            Connection->DomainName = DomainName;
                                        }

                                    } else {

                                        IF_DEBUG(CONNECTION) {
                                            LdapPrint1( "LDAP inet_addr failed to get address from %S\n", hostName );
                                        }
                                        rc = ERROR_INCORRECT_ADDRESS;
                                    }
                                } else {

                                    hostEntry = GetHostByNameW( HostAddress );
                                    hostNameUsedByGetHostByName = HostAddress;
                                    rc = ERROR_INCORRECT_ADDRESS;
                                }

                            } else {

                                rc = ERROR_INCORRECT_ADDRESS;
                            }
                    }

                }

                if (hostEntry != NULL) {

                   //
                   // gethostbyname has returned us a list of addresses which we
                   // can use to do a parallel connect.
                   //
                   rc = ConnectToArecs( Connection,
                                        hostEntry,
                                        tryingExplicitHost,
                                        port,
                                        timeout );

                   if (rc == LDAP_SUCCESS) {
                      
                       connected = TRUE;

#if LDAPDBG
                      if ( (Connection->AREC_Exclusive == FALSE) && (tryingExplicitHost == FALSE) ) {

                          char tempBuff[1000]; 
                          DWORD tempErr = GetModuleFileName( NULL, tempBuff, 1000);

                          if (tempErr == 0) {
                              LdapPrint1("Process 0x%x is calling LDAP without setting the LDAP_OPT_AREC_EXCLUSIVE flag\n", GetCurrentProcessId());
                              LdapPrint0("Using this flag when passing in a fully-qualified server DNS name can\n");
                              LdapPrint0("improve the performance of this application when connecting.\n");
                              LdapPrint0("You can use tlist.exe to get the process name of the application.\n");
                          } else {
                              LdapPrint2("%s [PID 0x%x] is calling LDAP without setting the LDAP_OPT_AREC_EXCLUSIVE flag\n", tempBuff, GetCurrentProcessId());
                              LdapPrint0("Using this flag when passing in a fully-qualified server DNS name can\n");
                              LdapPrint0("improve the performance of this application when connecting.\n");                              
                          }
                      }
#endif
                   }
                }

                if (HostAddress != NULL) {

                    if (rc == 0) {

                        ldapFree( Connection->ExplicitHostName, LDAP_HOST_NAME_SIGNATURE );
                        Connection->ExplicitHostName = HostAddress;

                    } else {

                        ldapFree( HostAddress, LDAP_HOST_NAME_SIGNATURE );
                    }
                }
            }

            //
            // Free the hostent structure if we have allocated it
            //

            if (hostEntry &&
                pWSALookupServiceBeginW &&
                pWSALookupServiceNextW &&
                pWSALookupServiceEnd) {

                PCHAR* temp = hostEntry->h_addr_list;
                int i=0;

                while (temp[i]) {
                    ldapFree(temp[i], LDAP_ANSI_SIGNATURE);
                    i++;
                }

                ldapFree(temp, LDAP_ANSI_SIGNATURE);
                ldapFree(hostEntry->h_name, LDAP_HOST_NAME_SIGNATURE);
                ldapFree(hostEntry->h_aliases, LDAP_HOST_NAME_SIGNATURE);
                ldapFree(hostEntry, LDAP_ANSI_SIGNATURE);
            }

        }

        if (endOfHost != NULL) {
            *endOfHost = L':';
        }

tryNextServer:
        if (rc != 0) {

            hostsTried++;

            //
            // go to next host
            //

            while (*hostName != L'\0') {
                hostName++;
            }
            hostName++;
        }
    }

    if ((rc != 0) && (tryingExplicitHost == TRUE)) {

        tryingExplicitHost = FALSE;
        goto RetryWithoutExplicitHost;
    }

    if ((rc == 0) && (tryingExplicitHost == TRUE)) {

        //
        //  if we succeeded here, we have to move the HostName pointer in the
        //  connection record to point to the domain name since the server name
        //  may go away.
        //

       if ((Connection->HostNameW != NULL) &&
            (Connection->HostNameW != Connection->ListOfHosts) &&
           (Connection->HostNameW != Connection->ExplicitHostName)) {

          ldapFree( Connection->HostNameW, LDAP_HOST_NAME_SIGNATURE );
       }
        Connection->HostNameW = Connection->ListOfHosts;
    }

    if ((rc==0) && (hostsTried)) {
        //
        // The Hostname ptr will be pointing somewhere inbetween the ListOfHost
        // we have to reset it.
        //

        Connection->HostNameW = Connection->ListOfHosts;
    }

    //
    // We finally need an ANSI version of the hostname on the connection
    // block to be compliant with the UMICH implementation.
    //

    ldapFree( Connection->publicLdapStruct.ld_host, LDAP_HOST_NAME_SIGNATURE );

    FromUnicodeWithAlloc( Connection->HostNameW,
                          &Connection->publicLdapStruct.ld_host,
                          LDAP_HOST_NAME_SIGNATURE,
                          LANG_ACP
                          );


    if ( ( rc == 0 ) && ( Connection->SslPort ) ) {

        rc = LdapSetupSslSession( Connection );
    }

    START_LOGGING;
    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0]"));
    DSLOG((0,"[OP=ldap_open][SV=%s][ST=%I64d][ET=%I64d][ER=%d][-]\n",
           Connection->publicLdapStruct.ld_host, startTime, LdapGetTickCount(), rc));
    END_LOGGING;

    return rc;
}

ULONG
LdapWinsockConnect (
    PLDAP_CONN Connection,
    USHORT PortNumber,
    PWCHAR  HostName,
    struct l_timeval  *timeout,
    BOOLEAN samesite
    )
{
    ULONG wsErr;
    BOOLEAN isAsync = FALSE;
    ULONG nonblockingMode;
    BOOLEAN tcpSocket = (Connection->TcpHandle != INVALID_SOCKET) ? TRUE : FALSE;

    //
    //  we call connect both for UDP and TCP.  With UDP, it just
    //  associates the address with the socket.
    //  With TCP, we leave the socket in nonblocking mode.
    //

    if (tcpSocket && pioctlsocket) {

        nonblockingMode = 1;
        isAsync = TRUE;

        //
        //  We set the socket to nonblocking, do the connect, call select
        //  with the timeout value, and fail the whole thing if it doesn't
        //  work.
        //

        wsErr = (*pioctlsocket)( Connection->TcpHandle,
                                 FIONBIO,
                                 &nonblockingMode
                                );

        if (wsErr != 0) {

            //
            //  if it fails, we just do a synchronous connect... we tried.
            //

            wsErr = (*pWSAGetLastError)();

            IF_DEBUG(NETWORK_ERRORS) {
                LdapPrint2( "LDAP conn %u ioclsocket returned 0x%x\n", Connection, wsErr );
            }

            isAsync = FALSE;
        }
    }

    if (tcpSocket && psetsockopt && Connection->UseTCPKeepAlives) {

        // turn on TCP keep-alives if requested
        
        int t = TRUE;

        wsErr = (*psetsockopt)( Connection->TcpHandle,
                                SOL_SOCKET,
                                SO_KEEPALIVE,
                                reinterpret_cast<char*>(&t),
                                sizeof(t)
                              );

        if (wsErr != 0) {
        
            // we'll treat failure to turn on keep-alives as non-fatal
            wsErr = (*pWSAGetLastError)();

            IF_DEBUG(NETWORK_ERRORS) {
                LdapPrint2( "LDAP conn %u setsockopt for keepalive returned 0x%x\n", Connection, wsErr );
            }
        }

    }

TryConnectAgain:

    wsErr = (*pconnect)(get_socket( Connection ),
                        (struct sockaddr *)&Connection->SocketAddress,
                        sizeof(Connection->SocketAddress) );

    if (wsErr != 0) {

        wsErr = (*pWSAGetLastError)();

        //
        //  if someone in our process set OVERLAPPED to TRUE for all sockets,
        //  then the connect will fail here if we've set it to nonblocking
        //  mode, so we'll pick up this error code and revert to blocking.
        //

        if (wsErr == WSAEINVAL && isAsync == TRUE) {

            IF_DEBUG(CONNECT) {
                LdapPrint2( "LDAP connect switching back to sync for host %S, port %u\n",
                        HostName, PortNumber );
            }

            SOCKET newSocket = (*psocket)(PF_INET,
                                          tcpSocket ? SOCK_STREAM : SOCK_DGRAM,
                                          0);

            if (newSocket != INVALID_SOCKET) {

                BeginSocketProtection( Connection );

                int sockerr = (*pclosesocket)( tcpSocket ? Connection->TcpHandle : Connection->UdpHandle);
                ASSERT(sockerr == 0); 

                if (tcpSocket) {
                    Connection->TcpHandle = newSocket;
                } else {
                    Connection->UdpHandle = newSocket;
                }

                EndSocketProtection( Connection );

                isAsync = FALSE;
                goto TryConnectAgain;
            }
        }

        if (wsErr == 0) {

            wsErr = WSA_WAIT_TIMEOUT;
        }
        IF_DEBUG(CONNECTION) {
            LdapPrint3( "LDAP connect returned err %u for addr %S, port %u\n",
                    wsErr, HostName, PortNumber );
        }
    }

    if (isAsync) {

        BOOLEAN failedSelect = FALSE;

        if (wsErr == WSAEWOULDBLOCK) {

            fd_set writeSelectSet;
            fd_set excSelectSet;
            timeval selectTimeout;

            FD_ZERO( &writeSelectSet );
            FD_SET( Connection->TcpHandle, &writeSelectSet );
            FD_ZERO( &excSelectSet );
            FD_SET( Connection->TcpHandle, &excSelectSet );

                  if (timeout == NULL) {

                     if (samesite == TRUE) {

                        //
                        // We are connecting to servers in the same site. We can afford
                        // to have a small timeout.
                        //

                        selectTimeout.tv_sec = SAMESITE_CONNECT_TIMEOUT;
                        selectTimeout.tv_usec = 0;

                     } else {

                        selectTimeout.tv_sec = LDAP_CONNECT_TIMEOUT;
                        selectTimeout.tv_usec = 0;

                     }
                  } else {

                     //
                     // honor the user specified timeout
                     //

                     selectTimeout.tv_sec = timeout->tv_sec;
                     selectTimeout.tv_usec = timeout->tv_usec;
                  }

            wsErr = (*pselect)(   0,
                                  NULL,
                                  &writeSelectSet,
                                  &excSelectSet,
                                  &selectTimeout );

            if ((wsErr == SOCKET_ERROR) || (wsErr == 0)) {

failedSelect:
                if (wsErr == SOCKET_ERROR) {

                    wsErr = (*pWSAGetLastError)();
                }

                if (wsErr == 0) {

                    wsErr = WSA_WAIT_TIMEOUT;
                }

                IF_DEBUG(NETWORK_ERRORS) {
                    LdapPrint2( "LDAP conn 0x%x connect/select returned %u\n", Connection, wsErr );
                }

                failedSelect = TRUE;

                ASSERT( wsErr != 0 );

            } else {

                if ((*pwsafdisset)(Connection->TcpHandle, &writeSelectSet )) {

                    wsErr = 0;

                } else {

                    IF_DEBUG(CONNECTION) {
                        LdapPrint3( "LDAP connect returned err 0x%x for addr %S, port %u\n",
                                wsErr, HostName, PortNumber );
                    }
                    wsErr = (ULONG) SOCKET_ERROR;
                    goto failedSelect;
                }
            }
        }
    }

    if (wsErr == 0) {

        Connection->PortNumber = PortNumber;

        IF_DEBUG(CONNECTION) {
            LdapPrint2( "LDAP conn 0x%x connected to addr %S\n", Connection, HostName );
        }

        if (( PortNumber == LDAP_SERVER_PORT_SSL ) ||
            ( PortNumber == LDAP_SSL_GC_PORT)) {

            Connection->SslPort = TRUE;
        }

        Connection->HostNameW = HostName;

    } else {

        IF_DEBUG(CONNECTION) {
            LdapPrint4( "LDAP conn 0x%x connecting to addr %S, port %u err = 0x%x\n",
                    Connection, HostName, PortNumber, wsErr );
        }

        SOCKET newSocket = (*psocket)(PF_INET,
                                      tcpSocket ? SOCK_STREAM : SOCK_DGRAM,
                                      0);

        if (newSocket != INVALID_SOCKET) {

            BeginSocketProtection( Connection );

            int sockerr = (*pclosesocket)( tcpSocket ? Connection->TcpHandle : Connection->UdpHandle);
            ASSERT(sockerr == 0); 

            if (tcpSocket) {
                Connection->TcpHandle = newSocket;
            } else {
                Connection->UdpHandle = newSocket;
            }

            EndSocketProtection( Connection );

        }
    }

    return wsErr;
}


//
//   This is the function which takes in an LDAP handle returned
//   from ldap_init( ) and connects to the server for you
//

ULONG __cdecl ldap_connect (
    LDAP *ExternalHandle,
    struct l_timeval  *timeout
    )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapConnect( connection, timeout, FALSE );

    DereferenceLdapConnection( connection );

    return err;
}

ULONG
LdapConnect (
    PLDAP_CONN connection,
    struct l_timeval  *timeout,
    BOOLEAN DontWait
    )
{
    ULONG err;
    BOOLEAN haveLock = FALSE;

    //
    // Check if the connection has already been established
    // if yes, simply return. If not, establish it
    //

    if ( connection->HostConnectState == HostConnectStateConnected ) {

        return LDAP_SUCCESS;
    }

waitAgain:

    if (haveLock == FALSE) {
        ACQUIRE_LOCK( &connection->StateLock );
        haveLock = TRUE;
    }

    //
    //  single thread the call to OpenLdapServer
    //

    if ( connection->HostConnectState == HostConnectStateConnected ) {

        IF_DEBUG(CONNECT) {
            LdapPrint1( "ldap_connect reports connection 0x%x already connected\n",
                            connection );
        }
        err = LDAP_SUCCESS;
        goto connectDone;
    }

    if (( connection->ServerDown == TRUE) && (connection->AutoReconnect == FALSE) ) {

       err = LDAP_SERVER_DOWN;
       goto connectDone;
    }

    if (connection->ConnObjectState != ConnObjectActive) {

        IF_DEBUG(CONNECT) {
            LdapPrint3( "ldap_connect connection 0x%x is in state 0x%x for thread 0x%x\n",
                            connection,
                            connection->ConnObjectState,
                            GetCurrentThreadId() );
        }
        err = LDAP_USER_CANCELLED;
        goto connectDone;
    }

    //
    //  if no thread is currently handling the reconnect, volunteer... but then
    //  don't go into a wait state waiting for someone else to do it.
    //

    if (DontWait == FALSE) {

        if ((connection->HostConnectState == HostConnectStateError) &&
            (connection->AutoReconnect == TRUE)) {

            //
            // Let go of the StateLock while waiting for the ReconnectLock
            //

            RELEASE_LOCK( &connection->StateLock );
            haveLock = FALSE;
            ACQUIRE_LOCK( &connection->ReconnectLock );

            //
            // Grab the StateLock again before checking the state which
            // could have changed while we were waiting for the ReconnectLock
            //

            ACQUIRE_LOCK( &connection->StateLock );
            haveLock = TRUE;

            if ((connection->HostConnectState == HostConnectStateError) &&
                (connection->AutoReconnect == TRUE)) {

                    IF_DEBUG(CONNECT) {
                        LdapPrint2( "ldap_connect connection 0x%x is in error state for thread 0x%x, reconnecting...\n",
                                        connection,
                                        GetCurrentThreadId() );
                    }

                    //
                    //  we'll call off to autoreconnect and then recursively come back in
                    //  here.  kind of ugly, but auto-reconnect involves a lot of
                    //  processing, so we keep it in one place.
                    //

                    connection->HostConnectState = HostConnectStateReconnecting;
                    RELEASE_LOCK( &connection->StateLock );
                    haveLock = FALSE;

                    err = LdapAutoReconnect( connection );

                    RELEASE_LOCK( &connection->ReconnectLock );

                    goto connectDone;

            }

            RELEASE_LOCK( &connection->ReconnectLock );
            goto waitAgain;

        }

        if (haveLock == FALSE) {
            ACQUIRE_LOCK( &connection->StateLock );
            haveLock = TRUE;
        }

        //
        //  if some other thread is doing the reconnect, wait for it to finish
        //

        if ((( connection->HostConnectState == HostConnectStateConnecting ) ||
             ( connection->HostConnectState == HostConnectStateReconnecting ))) {

            IF_DEBUG(CONNECT) {
                LdapPrint2( "ldap_connect thread 0x%x is waiting on connection 0x%x\n",
                                GetCurrentThreadId(),
                                connection );
            }
            RELEASE_LOCK( &connection->StateLock );
            haveLock = FALSE;

            WaitForSingleObjectEx( connection->ConnectEvent,
                                   INFINITE,
                                   TRUE );         // alertable
            goto waitAgain;
        }
    }

    ResetEvent( connection->ConnectEvent );
    connection->HostConnectState = HostConnectStateConnecting;

    IF_DEBUG(CONNECT) {
        LdapPrint2( "ldap_connect thread 0x%x is opening connection 0x%x\n",
                        GetCurrentThreadId(),
                        connection );
    }

    RELEASE_LOCK( &connection->StateLock );
    haveLock = FALSE;

    //
    //  open a connection to any of the servers specified
    //

    err = OpenLdapServer( connection, timeout );

    //
    //  If we couldn't open the LDAP server, then the address that
    //  DsGetDCName passed us isn't valid (or the value in the
    //  registry isn't valid).  Either way, we mark to force rediscovery
    //  and then try this whole thing again.
    //

    ACQUIRE_LOCK( &connection->StateLock );
    haveLock = TRUE;

    if (err != 0) {

        connection->HostConnectState = HostConnectStateError;
        if (DontWait == FALSE) {
            SetEvent( connection->ConnectEvent );
        }

        IF_DEBUG(CONNECT) {
            LdapPrint2( "LdapConnect failed to open connection 0x%x, err = 0x%x.\n",
                connection, err);
        }

        IF_DEBUG(SERVERDOWN) {
            LdapPrint2( "LdapConnect thread 0x%x has connection 0x%x as down.\n",
                            GetCurrentThreadId(),
                            connection );
        }
        err = LDAP_SERVER_DOWN;
        goto connectDone;
    }

    IF_DEBUG(CONNECT) {
        LdapPrint2( "ldap_connect thread 0x%x has opened connection 0x%x\n",
                        GetCurrentThreadId(),
                        connection );
    }

    connection->HostConnectState = HostConnectStateConnected;
    if (DontWait == FALSE) {
        SetEvent( connection->ConnectEvent );
    }

    if (connection->ConnObjectState != ConnObjectActive) {

        IF_DEBUG(CONNECT) {
            LdapPrint1( "LdapConnect connection 0x%x is closing.\n", connection);
        }

        err = LDAP_USER_CANCELLED;
        goto connectDone;
    }

    IF_DEBUG(CONNECTION) {
        LdapPrint2( "ldap_connect marking 0x%x as open, host is %S.\n",
                       connection, connection->HostNameW );
    }

    LdapWakeupSelect();

connectDone:

    IF_DEBUG(CONNECT) {
        LdapPrint3( "ldap_connect thread 0x%x is leaving for conn 0x%x with 0x%x\n",
                        GetCurrentThreadId(),
                        connection,
                        err );
    }

    if (haveLock) {
        RELEASE_LOCK( &connection->StateLock );
    }

    SetConnectionError(connection, err, NULL);
    return(err);
}

BOOLEAN
LdapIsAddressNumeric (
    PWCHAR HostName
    )
{
    BOOLEAN rc = FALSE;

    //
    //  to check to see if it's a TCP address, we check for it to only
    //  contain only numerals and periods.
    //

    while (((*HostName >= L'0') && (*HostName <= L'9')) ||
            (*HostName == L'.')) {
        HostName++;
    }

    //
    //  if we hit the end of the hostname, then it's an address.
    //

    if (*HostName == L'\0' || *HostName == L':') {

        rc = TRUE;
    }
    return rc;
}



ULONG
ConnectToSRVrecs(
    PLDAP_CONN Connection,
    PWCHAR HostName,
    BOOLEAN SuggestedHost,
    USHORT port,
    struct l_timeval  *timeout
    )
//
// HostName can be of the form "ntdsdc1.ntdev.microsoft.com" or simply
// "ntdev.microsoft.com". If this is a SuggestedHost, we try to connect to
// that host first (1 second preference) before the rest of the address records.
//
//
{
    HANDLE enumHandle = NULL;
    PWCHAR hostname = NULL;
    ULONG hostCount;
    LPWSTR site = NULL;
    ULONG rc = LDAP_SUCCESS;
    BOOLEAN GetDcSucceeded = FALSE;
    BOOLEAN StartedEnumeration = FALSE;
    ULONG totalCount = 0;
    struct l_timeval localtimeout = {0};
    PWCHAR Address = NULL;
    PWCHAR DnsHostName = NULL;
    PWCHAR DomainName = NULL;
    PSOCKHOLDER2  sockAddressArr[MAX_SOCK_ADDRS];

    //
    // Initialize all elements of our SOCKHOLDER2 array.
    //

    for (int j=0; j<MAX_SOCK_ADDRS; j++ ) {

        sockAddressArr[j] = NULL;
    }

    hostname = ( HostName==NULL ) ? Connection->ListOfHosts : HostName;

    //
    // If a hostname wasn't suggested, we try DsGetDcName
    // because it will return to us a "sticky" address to connect to. This will
    // ensure that we always hit the same DC everytime someone comes in with a
    // domain name like "ntdev.microsoft.com". This will also ensure that if we
    // are on a DC, we connect to the same machine without going on the wire. Note
    // that if the "sticky" DC goes down, the user has to repeat the process
    // with the ForceVerify flag set.
    //
    // Note that we assume the hostname is of a DNS style name. This is to prevent
    // DsGetDcName from performing a lengthy NetBT broadcast.
    //
    //


    if ( SuggestedHost == FALSE ) {

        sockaddr_in *ptemp;
        BOOLEAN samesite = FALSE;
        DWORD numAddrs = 1;
        ULONG tempAddr = 0;
        ULONG Flags = 0;
        BOOLEAN ForcedRetry = FALSE;

TryAgain:

        if (ForcedRetry) {
            Flags = DS_FORCE_REDISCOVERY;
        }

        rc = GetDefaultLdapServer( hostname,
                                   &Address,
                                   &DnsHostName,
                                   &DomainName,
                                   &numAddrs,
                                   Connection->GetDCFlags | Flags | DS_IS_DNS_NAME,
                                   &samesite,
                                   Connection->PortNumber
                                   );


        if ((rc == NO_ERROR) && (Address != NULL)) {

            sockAddressArr[totalCount] = (PSOCKHOLDER2)ldapMalloc(sizeof(SOCKHOLDER2), LDAP_SOCKADDRL_SIGNATURE);

            if (sockAddressArr[totalCount] == NULL) {
                rc = LDAP_NO_MEMORY;
                goto ExitWithCleanup;
            }

            sockAddressArr[totalCount]->psocketaddr = (LPSOCKET_ADDRESS)ldapMalloc(sizeof(SOCKET_ADDRESS), LDAP_SOCKADDRL_SIGNATURE);

            if (sockAddressArr[totalCount]->psocketaddr == NULL) {

                ldapFree(sockAddressArr[totalCount],LDAP_SOCKADDRL_SIGNATURE );
                sockAddressArr[totalCount] = NULL;
                rc = LDAP_NO_MEMORY;
                goto ExitWithCleanup;
            }

            sockAddressArr[totalCount]->psocketaddr->lpSockaddr = (LPSOCKADDR)ldapMalloc(sizeof(SOCKADDR), LDAP_SOCKADDRL_SIGNATURE);

            if (sockAddressArr[totalCount]->psocketaddr->lpSockaddr == NULL) {

                ldapFree(sockAddressArr[totalCount]->psocketaddr,LDAP_SOCKADDRL_SIGNATURE );
                ldapFree(sockAddressArr[totalCount],LDAP_SOCKADDRL_SIGNATURE );
                sockAddressArr[totalCount] = NULL;
                rc = LDAP_NO_MEMORY;
                goto ExitWithCleanup;
            }

            ptemp = (sockaddr_in *) sockAddressArr[totalCount]->psocketaddr->lpSockaddr;
            sockAddressArr[totalCount]->psocketaddr->iSockaddrLength = sizeof(sockaddr_in);

            tempAddr = Inet_addrW( Address );

            if (tempAddr != INADDR_NONE) {

               CopyMemory( &(ptemp->sin_addr.s_addr), &tempAddr, sizeof(tempAddr) );
               ptemp->sin_family = AF_INET;
               ptemp->sin_port = (*phtons)( port );
               GetDcSucceeded = TRUE;

            } else {

               ldapFree(sockAddressArr[totalCount]->psocketaddr->lpSockaddr,LDAP_SOCKADDRL_SIGNATURE );
               ldapFree(sockAddressArr[totalCount]->psocketaddr,LDAP_SOCKADDRL_SIGNATURE );
               ldapFree(sockAddressArr[totalCount],LDAP_SOCKADDRL_SIGNATURE );
               sockAddressArr[totalCount] = NULL;
               rc = LDAP_LOCAL_ERROR;
            }

        }

        if ((rc == LDAP_SUCCESS) && (GetDcSucceeded)) {

            //
            // We give the address returned by DsGetDcName preference. Keep in mind
            // that this server may not respond in 1 second in which case we move
            // on to enumerate DNS records.
            //

            sockAddressArr[totalCount]->DnsSuppliedName = DnsHostName;
            DnsHostName = NULL;

            IF_DEBUG(CONNECTION) {
                LdapPrint1("Dns supplied hostname from DsGetDcName is %s\n", sockAddressArr[totalCount]->DnsSuppliedName);
            }
            totalCount++;
            sockAddressArr[totalCount] = NULL;   // Null terminate the array.
            localtimeout.tv_sec = LDAP_QUICK_TIMEOUT;

            if (ForcedRetry) {
             
                //
                // This must be a reachable DC we are connecting to. Wait twice
                // as long if necessary.
                //

                localtimeout.tv_sec = localtimeout.tv_sec * 2;
            }

            localtimeout.tv_usec = 0;

            rc = LdapParallelConnect( Connection,
                                   &sockAddressArr[0],
                                   port,
                                   totalCount,
                                   &localtimeout
                                   );

            if (rc == LDAP_SUCCESS) {

                Connection->HostNameW = ldap_dup_stringW( hostname,
                                                         0,
                                                         LDAP_HOST_NAME_SIGNATURE );
                Connection->DomainName = DomainName;
                DomainName = NULL;

                goto ExitWithCleanup;

            }

            //
            // We failed to connect to the DC returned from DsGetDcName. Maybe
            // it was a cached DC and has gone down since. Let's force the
            // locator to find a fresh DC.
            //

            ldapFree( DomainName, LDAP_HOST_NAME_SIGNATURE );
            DomainName = NULL;
            ldapFree( Address, LDAP_HOST_NAME_SIGNATURE);
            Address = NULL;

            if (!ForcedRetry) {
             
                ForcedRetry = TRUE;
                goto TryAgain;
            }

        }
    }

    //
    // This could be a third party SRV record registration. DsGetDcName will
    // not find such a name by default.
    //
    // Note that if this is not a third party SRV record domain but an A record
    // instead, it will result in unnecessary delay and traffic. For this reason,
    // applications MUST specify the LDAP_OPT_AREC_EXCLUSIVE flag when specifying
    // SRV records.
    //

    rc = InitLdapServerFromDomain( hostname,
                                   Connection->GetDCFlags | DS_ONLY_LDAP_NEEDED,
                                   &enumHandle,
                                   &site
                                   );

    if (rc != LDAP_SUCCESS) {

        goto ExitWithCleanup;
    }

    StartedEnumeration = TRUE;

    while (totalCount < MAX_SOCK_ADDRS) {

        LPSOCKET_ADDRESS  sockAddresses;

        //
        // Try to collect all the addresses into the array of addresses
        //

        hostCount = 0;

        rc = NextLdapServerFromDomain( enumHandle,
                                       &sockAddresses,
                                       &DnsHostName,
                                       &hostCount
                                       );

        if (rc != NO_ERROR) {

            break;
        }

        ULONG count = 0;


        while ((count < hostCount) && (totalCount < MAX_SOCK_ADDRS)) {

            sockAddressArr[totalCount] = (PSOCKHOLDER2)ldapMalloc(sizeof(SOCKHOLDER2), LDAP_SOCKADDRL_SIGNATURE);

            if (sockAddressArr[totalCount] == NULL) {
                rc = LDAP_NO_MEMORY;
                goto ExitWithCleanup;
            }

            sockAddressArr[totalCount]->psocketaddr = (LPSOCKET_ADDRESS)ldapMalloc(sizeof(SOCKET_ADDRESS), LDAP_SOCKADDRL_SIGNATURE);

            if (sockAddressArr[totalCount]->psocketaddr == NULL) {
                ldapFree(sockAddressArr[totalCount],LDAP_SOCKADDRL_SIGNATURE );
                sockAddressArr[totalCount] = NULL;
                rc = LDAP_NO_MEMORY;
                goto ExitWithCleanup;
            }

            sockAddressArr[totalCount]->psocketaddr->lpSockaddr = (LPSOCKADDR)ldapMalloc(sizeof(SOCKADDR), LDAP_SOCKADDRL_SIGNATURE);

            if (sockAddressArr[totalCount]->psocketaddr->lpSockaddr == NULL) {
                ldapFree(sockAddressArr[totalCount]->psocketaddr,LDAP_SOCKADDRL_SIGNATURE );
                ldapFree(sockAddressArr[totalCount],LDAP_SOCKADDRL_SIGNATURE );
                sockAddressArr[totalCount] = NULL;
                rc = LDAP_NO_MEMORY;
                goto ExitWithCleanup;
            }

            sockAddressArr[totalCount]->psocketaddr->iSockaddrLength = (&sockAddresses[count])->iSockaddrLength;

            CopyMemory(sockAddressArr[totalCount]->psocketaddr->lpSockaddr,
                       (&sockAddresses[count])->lpSockaddr,
                       (&sockAddresses[count])->iSockaddrLength);

            sockAddressArr[totalCount]->DnsSuppliedName = ldap_dup_stringW( DnsHostName,
                                                                            0,
                                                                            LDAP_HOST_NAME_SIGNATURE
                                                                            );

            IF_DEBUG(CONNECTION) {
                LdapPrint3("Dns supplied hostname from DsGetDcNext is %s totalcount %d intermediatecount %d\n", sockAddressArr[totalCount]->DnsSuppliedName, totalCount, count );
            }

            totalCount++;
            count++;

        }

        ldapFree( DnsHostName, LDAP_HOST_NAME_SIGNATURE );
        DnsHostName = NULL;

        LocalFree( sockAddresses );
    }

    sockAddressArr[totalCount] = NULL;

    IF_DEBUG(CONNECTION) {
        LdapPrint2("Collected a total of %d address records for host %S\n",totalCount, hostname);
    }

    if (totalCount == 0) {

        CloseLdapServerFromDomain( enumHandle, site );
        return rc;
    }

    //
    // We can now connect to any address in this null terminated array.
    //

    if (timeout == NULL) {

        if (site != NULL) {

            //
            // We are connecting to servers in the same site. We can afford
            // to have a small timeout.
            //


            localtimeout.tv_sec = (SuggestedHost) ? LDAP_QUICK_TIMEOUT : SAMESITE_CONNECT_TIMEOUT;
            localtimeout.tv_usec = 0;

        } else {

            localtimeout.tv_sec = (SuggestedHost) ? LDAP_QUICK_TIMEOUT : LDAP_CONNECT_TIMEOUT;
            localtimeout.tv_usec = 0;

        }
    } else {

        //
        // honor the user specified timeout
        //

        localtimeout.tv_sec = (SuggestedHost) ? 1:timeout->tv_sec;
        localtimeout.tv_usec = timeout->tv_usec;
    }

    rc = LdapParallelConnect( Connection,
                              &sockAddressArr[0],
                              port,
                              totalCount,
                              &localtimeout
                              );

    if (rc == LDAP_SUCCESS) {
        Connection->HostNameW = ldap_dup_stringW( hostname,
                                                  0,
                                                  LDAP_HOST_NAME_SIGNATURE );

    }


ExitWithCleanup:

    //
    // Cleanup allocated socket addresses.
    //

    ULONG i =0;

    while (sockAddressArr[i] != NULL) {
        ldapFree(sockAddressArr[i]->psocketaddr->lpSockaddr, LDAP_SOCKADDRL_SIGNATURE);
        ldapFree(sockAddressArr[i]->psocketaddr, LDAP_SOCKADDRL_SIGNATURE);
        ldapFree(sockAddressArr[i]->DnsSuppliedName, LDAP_HOST_NAME_SIGNATURE);
        ldapFree(sockAddressArr[i], LDAP_SOCKADDRL_SIGNATURE);
        sockAddressArr[i] = NULL;
        i++;
    }

    if ( Address != NULL) {
        ldapFree( Address, LDAP_HOST_NAME_SIGNATURE );
    }

    if ( DnsHostName != NULL ) {
        ldapFree( DnsHostName, LDAP_HOST_NAME_SIGNATURE );
    }

    if ( DomainName != NULL) {
        ldapFree( DomainName, LDAP_HOST_NAME_SIGNATURE );
    }


    if ( StartedEnumeration ) {
        CloseLdapServerFromDomain( enumHandle, site );
    }

    return rc;

}


ULONG
ConnectToArecs(
    PLDAP_CONN  Connection,
    struct hostent  *hostEntry,
    BOOLEAN SuggestedHost,
    USHORT port,
    struct l_timeval  *timeout
    )
{

   PSOCKHOLDER2  sockAddressArr[MAX_SOCK_ADDRS];
   sockaddr_in *ptemp;
   ULONG rc, hostCount = 0;
   PCHAR hostAddr = hostEntry->h_addr_list[0];

   while ((hostAddr != NULL) && (hostCount < MAX_SOCK_ADDRS-1)) {

      //
      // Allocate both the SOCKET_ADDRESS & sockaddr structures
      //
      sockAddressArr[hostCount] = (PSOCKHOLDER2)ldapMalloc(sizeof(SOCKHOLDER2), LDAP_SOCKADDRL_SIGNATURE);

      if (sockAddressArr[hostCount] == NULL) {

         rc = LDAP_NO_MEMORY;
         goto ExitWithCleanup;

      }

      sockAddressArr[hostCount]->psocketaddr = (LPSOCKET_ADDRESS)ldapMalloc(sizeof(SOCKET_ADDRESS), LDAP_SOCKADDRL_SIGNATURE);

      if (sockAddressArr[hostCount]->psocketaddr == NULL) {

         rc = LDAP_NO_MEMORY;
         goto ExitWithCleanup;
      }

      sockAddressArr[hostCount]->psocketaddr->lpSockaddr = (LPSOCKADDR)ldapMalloc(sizeof(SOCKADDR), LDAP_SOCKADDRL_SIGNATURE);

      if (sockAddressArr[hostCount]->psocketaddr->lpSockaddr == NULL) {

         rc = LDAP_LOCAL_ERROR;
         goto ExitWithCleanup;
      }

      ptemp = (sockaddr_in *) sockAddressArr[hostCount]->psocketaddr->lpSockaddr;
      sockAddressArr[hostCount]->psocketaddr->iSockaddrLength = sizeof(sockaddr_in);

      ASSERT( sizeof(ptemp->sin_addr.s_addr) == hostEntry->h_length );
      CopyMemory( &(ptemp->sin_addr.s_addr), hostAddr, hostEntry->h_length );

      ptemp->sin_family = AF_INET;
      ptemp->sin_port = (*phtons)( port );

      //
      // All address records will have the same name. So, we will not bother
      // to hook up the DNS supplied hostname. We will do it later if the
      // connect is successful.
      //
      sockAddressArr[hostCount]->DnsSuppliedName = NULL;

      hostAddr = hostEntry->h_addr_list[++hostCount];
   }

   sockAddressArr[hostCount] = NULL;

   if (Connection->PortNumber == 0) {
      Connection->PortNumber = LDAP_SERVER_PORT;
   }

   IF_DEBUG(CONNECTION) {
      LdapPrint2("gethostbyname collected %d records for %S\n", hostCount, hostEntry->h_name );
   }


   struct l_timeval localtimeout;


   if (timeout == NULL) {
      //
      // gethostbyname does not give us any site information, so we use a long
      // timeout.
      //

      localtimeout.tv_sec = (SuggestedHost) ? 1:LDAP_CONNECT_TIMEOUT;
      localtimeout.tv_usec = 0;
   } else {

      //
      // honor the user specified timeout
      //

      localtimeout.tv_sec = (SuggestedHost) ? 1:timeout->tv_sec;
      localtimeout.tv_usec = timeout->tv_usec;
   }


   rc = LdapParallelConnect( Connection,
                             &sockAddressArr[0],
                             port,
                             hostCount,
                             &localtimeout
                             );

   if (rc == LDAP_SUCCESS) {

       //
       // Convert from ANSI to Unicode before storing off the hostnames internally
       // We do this only if we called gethostbyname() in winsock 1.1.
       //

       if (pWSALookupServiceBeginW &&
           pWSALookupServiceNextW &&
           pWSALookupServiceEnd) {

           Connection->DnsSuppliedName = ldap_dup_stringW( hostEntry->h_aliases ?
                                                           (PWCHAR)hostEntry->h_aliases : (PWCHAR) hostEntry->h_name,
                                                           0,
                                                           LDAP_HOST_NAME_SIGNATURE
                                                          );
           FromUnicodeWithAlloc( hostEntry->h_aliases ?
                                 (PWCHAR)hostEntry->h_aliases : (PWCHAR) hostEntry->h_name,
                                 &Connection->publicLdapStruct.ld_host,
                                 LDAP_HOST_NAME_SIGNATURE,
                                 LANG_ACP
                                 );

       } else {

           //
           // Probably Win95 without Unicode RNR APIs. We are dealing with a TRUE hostEnt
           // structure.
           //

           ToUnicodeWithAlloc( hostEntry->h_aliases ?
                               hostEntry->h_aliases[0] : hostEntry->h_name,
                               -1,
                               &Connection->DnsSuppliedName,
                               LDAP_HOST_NAME_SIGNATURE,
                               LANG_ACP
                               );

          Connection->publicLdapStruct.ld_host = ldap_dup_string( hostEntry->h_aliases ?
                                                                  hostEntry->h_aliases[0] : hostEntry->h_name,
                                                                  0,
                                                                  LDAP_HOST_NAME_SIGNATURE );

       }

       Connection->HostNameW = ldap_dup_stringW( Connection->DnsSuppliedName,
                                                 0,
                                                 LDAP_HOST_NAME_SIGNATURE
                                                 );


      IF_DEBUG(CONNECTION) {
         LdapPrint1("Successfully connected to host %S\n", Connection->DnsSuppliedName);
      }
   }


ExitWithCleanup:

   for (ULONG i = 0; i < hostCount; i++) {

      if ( sockAddressArr[i]->psocketaddr->lpSockaddr ) {

         ldapFree(sockAddressArr[i]->psocketaddr->lpSockaddr, LDAP_SOCKADDRL_SIGNATURE);

         if ( sockAddressArr[i]->psocketaddr ) {

            ldapFree(sockAddressArr[i]->psocketaddr, LDAP_SOCKADDRL_SIGNATURE);

            if ( sockAddressArr[i] ) {

               ldapFree(sockAddressArr[i], LDAP_SOCKADDRL_SIGNATURE);

            }
         }
      }
   }

   return rc;

}

ULONG
LdapParallelConnect(
       PLDAP_CONN   Connection,
       PSOCKHOLDER2 *sockAddressArr,
       USHORT port,
       UINT totalCount,
       struct l_timeval  *timeout
       )
{
   //
   // we take in an array of pointers to SOCKET_ADDRESS structures. The goal is to try to issue connect
   // to any one of those addresses. To do this, we issues async connects to each address in intervals of
   // 1/10 sec (default).
   //

   SOCKHOLDER sockarray [MAX_PARALLEL_CONNECTS];
   ULONG remainingcount = totalCount;
   ULONG currentset = 0;
   ULONG startingpos = 0;
   ULONG index, k;
   ULONG sockpos = 0;
   ULONG wsErr = 0;
   ULONG nonblockingMode = 1;
   ULONG hoststried = 0;
   ULONG currentsock = 0;
   fd_set writeSelectSet;
   fd_set excSelectSet;
   timeval selectTimeout;
   ULONGLONG starttime;
   BOOLEAN connected = FALSE;
   BOOLEAN LastTimeout = FALSE;
   BOOLEAN StreamSocket = TRUE;
   ULONG sockErr = 0;

   if ((Connection == NULL)||
       (sockAddressArr == NULL)||
       (totalCount == 0)||
       (timeout == NULL))  {

      return LDAP_PARAM_ERROR;
   }


   port = (port == 0) ? LDAP_SERVER_PORT : port;

   if (( port == LDAP_SERVER_PORT_SSL ) ||
        ( port == LDAP_SSL_GC_PORT ) ) {

      Connection->SslPort = TRUE;
   }

   FD_ZERO( &writeSelectSet );
   FD_ZERO( &excSelectSet );
   selectTimeout.tv_sec = 0;
   selectTimeout.tv_usec = CONNECT_INTERVAL*1000;
   starttime = LdapGetTickCount();


   while ((connected == FALSE) &&
          (remainingcount > 0) &&
          ((LdapGetTickCount() - starttime)/1000 < (DWORD) timeout->tv_sec)) {

      if (remainingcount <= MAX_PARALLEL_CONNECTS) {
   
         currentset = remainingcount;
         remainingcount = 0;
      
      } else {

         currentset = MAX_PARALLEL_CONNECTS;
         remainingcount -= currentset;
      }

      for (index=startingpos, sockpos=0;
            index < (currentset+hoststried);
            index++, startingpos++, sockpos++) {

         ASSERT (sockAddressArr[index] != NULL);
         
         LastTimeout = FALSE;

         //
         // Create an appropriate socket and issue a connect
         //

         if (Connection->TcpHandle != INVALID_SOCKET) {

             sockarray[sockpos].sock = (*psocket)(PF_INET, SOCK_STREAM, 0);

             StreamSocket = TRUE;

         } else {

             sockarray[sockpos].sock = (*psocket)(PF_INET, SOCK_DGRAM, 0);
             StreamSocket = FALSE;
         }

         if (sockarray[sockpos].sock == INVALID_SOCKET) {
             goto ExitWithCleanup;
         }
   
         sockarray[sockpos].psocketaddr = sockAddressArr[index]->psocketaddr;
         sockarray[sockpos].DnsSuppliedName = sockAddressArr[index]->DnsSuppliedName;
   
         wsErr = (*pioctlsocket)( sockarray[sockpos].sock,
                                  FIONBIO,
                                  &nonblockingMode
                                  );
         if (wsErr != 0) {
             LdapPrint1("ioctlsocket failed with 0x%x . .\n", GetLastError());
             LdapCleanupSockets( sockpos+1 );
             goto ExitWithCleanup;
         }


         if (StreamSocket && psetsockopt && Connection->UseTCPKeepAlives) {

            // turn on TCP keep-alives if requested
            
            int t = TRUE;

            wsErr = (*psetsockopt)( sockarray[sockpos].sock,
                                    SOL_SOCKET,
                                    SO_KEEPALIVE,
                                    reinterpret_cast<char*>(&t),
                                    sizeof(t)
                                  );

            if (wsErr != 0) {
            
                // we'll treat failure to turn on keep-alives as non-fatal
                wsErr = (*pWSAGetLastError)();

                IF_DEBUG(NETWORK_ERRORS) {
                    LdapPrint2( "LDAP conn %u setsockopt for keepalive returned 0x%x\n", Connection, wsErr );
                }
            }

         }

        
         sockaddr_in *inetSocket = (sockaddr_in *) sockAddressArr[index]->psocketaddr->lpSockaddr;

         inetSocket->sin_port = (*phtons)( port );

         wsErr = (*pconnect)(sockarray[sockpos].sock,
                             (struct sockaddr *) inetSocket,
                             sizeof(struct sockaddr_in) );

        
         if ((wsErr != SOCKET_ERROR) ||
             (wsErr == SOCKET_ERROR)&&
             ((*pWSAGetLastError)() == WSAEWOULDBLOCK)) {

             FD_SET( sockarray[sockpos].sock, &writeSelectSet );
             FD_SET( sockarray[sockpos].sock, &excSelectSet );
      
             if (index >= (currentset + hoststried - 1)) {
                 
                 //
                 // We will not be issuing any more connects for this set
                 // So, we should wait for the entire timeout period.
                 //
                 // We should actually wait for the remainder of the
                 // timeout period but this method is accurate to within 1%
                 //
                        
                 LastTimeout = TRUE;
                 selectTimeout.tv_sec = timeout->tv_sec;
                 selectTimeout.tv_usec = timeout->tv_usec;
             }
                  
             wsErr = (*pselect)(   0,
                                   NULL,
                                   &writeSelectSet,
                                   &excSelectSet,
                                   &selectTimeout );
             
             if (wsErr == SOCKET_ERROR) {
      
                 LdapPrint1("select failed with 0x%x . .\n", GetLastError());
                 LdapCleanupSockets( sockpos+1 );
                 goto ExitWithCleanup;
      
             } else  if (wsErr == 0) {

                 //
                 // We timed out without receiving a response.
                 // Go ahead and issue another connect.
                 //
                     
                 wsErr = WSA_WAIT_TIMEOUT;
                 connected = FALSE;
                 IF_DEBUG(CONNECTION) {
                     LdapPrint0("No response yet. . .\n");
                 }
                 
             } else {
      
                 for (k=0; k<=sockpos; k++) {
                     
                     if ((*pwsafdisset)(sockarray[k].sock, &writeSelectSet )) {
                         
                         //
                         // Yes! This connect was successful 
                         //
                         
                         connected = TRUE;
                       
                         BeginSocketProtection( Connection );

                         if (StreamSocket) {
                       
                             if (Connection->TcpHandle != INVALID_SOCKET) {
                                 sockErr = (*pclosesocket)( Connection->TcpHandle );
                                 ASSERT(sockErr == 0);

                             }
                             Connection->TcpHandle = sockarray[k].sock;

                         } else {

                             if (Connection->UdpHandle != INVALID_SOCKET) {
                                 sockErr = (*pclosesocket)( Connection->UdpHandle );
                                 ASSERT(sockErr == 0);
                             }
                             Connection->UdpHandle = sockarray[k].sock;
                         }
                       
                         EndSocketProtection( Connection );
                                   
                         sockarray[k].sock = INVALID_SOCKET;
  
                         inetSocket = (sockaddr_in *) sockarray[k].psocketaddr->lpSockaddr;
                       
                         ASSERT( sizeof(Connection->SocketAddress.sin_addr.s_addr) ==
                                 sizeof( inetSocket->sin_addr.s_addr ) );
          
                         CopyMemory( &Connection->SocketAddress.sin_addr.s_addr,
                                     &inetSocket->sin_addr.s_addr,
                                     sizeof(Connection->SocketAddress.sin_addr.s_addr) );

                         Connection->DnsSuppliedName = ldap_dup_stringW(sockarray[k].DnsSuppliedName,
                                                                        0,
                                                                        LDAP_HOST_NAME_SIGNATURE);

                         Connection->PortNumber = port;

                         IF_DEBUG(CONNECTION) {
                             LdapPrint1("Successfully connected to host %S\n", Connection->DnsSuppliedName);
                         }
                         
                         LdapCleanupSockets( sockpos+1 );
                         goto ExitWithCleanup;
                        
                     } else if ((*pwsafdisset)(sockarray[k].sock, &excSelectSet )) {
      
                         //
                         // If there was an exception, we have no other choice
                         // Remove the socket from the select sets and close it.
                         
                         FD_CLR( sockarray[k].sock, &writeSelectSet);
                         FD_CLR( sockarray[k].sock, &excSelectSet);

                         sockErr = (*pclosesocket)(sockarray[k].sock);
                         ASSERT(sockErr == 0);
                         
                         sockarray[k].sock = INVALID_SOCKET;

                     }
                 }

             }

              //
              // If this is the last timeout for the current set, close 
              // all the sockets we created and clear the fd_sets because
              // they can't hold more than 64 sockets.
              //

              if (LastTimeout == TRUE) {
                 
                LdapCleanupSockets( sockpos+1 );
                FD_ZERO( &writeSelectSet );
                FD_ZERO( &excSelectSet );
              }

            } else {
               
                wsErr = (*pWSAGetLastError)();

                IF_DEBUG(CONNECTION) {
                    LdapPrint1("Connect failed with 0x%x\n",wsErr );
                }
                
                sockErr = (*pclosesocket)( sockarray[sockpos].sock );
                ASSERT(sockErr == 0);

                goto ExitWithCleanup;
            }
      }
      
      hoststried += currentset;
   }

ExitWithCleanup:

      //
      // We need to close all the sockets we created
      //

      LdapCleanupSockets( sockpos );
      
      if ((connected == FALSE) && (wsErr != WSA_WAIT_TIMEOUT)) {
      
         wsErr = (*pWSAGetLastError)();
         SetConnectionError( Connection, wsErr, NULL );

         IF_DEBUG(NETWORK_ERRORS) {
             LdapPrint2( "LDAP conn %u returned 0x%x\n", Connection, wsErr );
         }
         return LDAP_CONNECT_ERROR;
      }
      
      if (connected == TRUE) {

         return LDAP_SUCCESS;
      
      } else if (wsErr == 0) {

         return LDAP_SERVER_DOWN;
      }

      return wsErr;

}

struct hostent *
GetHostByNameW(
    PWCHAR  hostName
 )
{
    //
    // We try to make use of Winsock2 functionality if available. This is
    // because gethostbyname in Winsock 1.1 supports only ANSI.
    //

    if (pWSALookupServiceBeginW &&
        pWSALookupServiceNextW &&
        pWSALookupServiceEnd) {

        //
        //  We will fabricate a hostent structure of our own. It will look
        //  like the following. The only fields of interest are h_name, h_aliases[0],
        //  h_length and h_addr_list. Note that we will fill in a UNICODE
        //  h_name and h_aliases[0] field instead of the standard ANSI name.
        //
        //
        //      struct  hostent {
        //      WCHAR   * h_name;               /* official name of host */
        //      WCHAR   * h_aliases;            /* first alias */
        //      short   h_addrtype;             /* host address type */
        //      short   h_length;               /* length of address */
        //      char    FAR * FAR * h_addr_list; /* list of addresses */
        //      };
        //
        //

        #define INITIAL_COUNT   20
         
        WSAQUERYSETW  qsQuery;
        PWSAQUERYSETW pBuffer = NULL;
        HANDLE hRnr = NULL;
        ULONG totalCount = 0;
        DWORD dwQuerySize = 0;
        GUID  ServiceGuid = SVCID_INET_HOSTADDRBYNAME;
        struct hostent  *phostent = NULL;
        int retval = 0;
        PCHAR *IPArray = NULL;
        ULONG arraySize = INITIAL_COUNT;
        BOOLEAN bCapturedOfficialName = FALSE;
        ULONG dnsFlags = LUP_RETURN_ADDR | LUP_RETURN_NAME | LUP_RETURN_BLOB | LUP_RETURN_ALIASES;

        //
        // Allocate a hostent structure which the callee will free later
        //

        phostent = (struct hostent*) ldapMalloc(sizeof(struct hostent), LDAP_ANSI_SIGNATURE );

        if (!phostent) {
            goto Cleanup;
        }

        //
        // Fill in the size of an IP address.
        // This will change when we move to IPv6.
        //

        phostent->h_length = 4;
         
        //
        // Initialize the query structure
        //

        memset(&qsQuery, 0, sizeof(WSAQUERYSETW));
        qsQuery.dwSize = sizeof(WSAQUERYSETW);   // the dwSize field has to be initialised like this
        qsQuery.dwNameSpace = NS_ALL;
        qsQuery.lpServiceClassId = &ServiceGuid;  // this is the GUID to perform forward name resolution (name to IP)
        qsQuery.lpszServiceInstanceName = hostName;

        if( pWSALookupServiceBeginW( &qsQuery,
                                     dnsFlags,
                                     &hRnr ) == SOCKET_ERROR ) {

            IF_DEBUG(CONNECTION) {
                LdapPrint1( "WSALookupServiceBegin failed  %d\n", GetLastError() );
            }
            goto Cleanup;
        }


         //
         // Determine the size of the buffer required to store the results.
         //

         retval = pWSALookupServiceNextW( hRnr,
                                          dnsFlags,
                                          &dwQuerySize,
                                          NULL          // No buffer supplied
                                          );
         
         if (GetLastError() != WSAEFAULT) {
             IF_DEBUG(CONNECTION) {
                 LdapPrint1( "WSALookupServiceNext failed with %d\n", GetLastError() );
             }
             goto Cleanup;
         }
             
         IF_DEBUG(CONNECTION) {
             LdapPrint1( "WSALookupServiceNext requires a buffer of %d\n", dwQuerySize );
         }

         pBuffer = (PWSAQUERYSETW) ldapMalloc(dwQuerySize, LDAP_BUFFER_SIGNATURE);

         if (!pBuffer) {
             goto Cleanup;
         }

         //
         // Allocate an initial array capable of holding upto INITIAL_COUNT addresses.
         //

         IPArray = (PCHAR*) ldapMalloc( (INITIAL_COUNT+1)*sizeof(PCHAR),
                                        LDAP_ANSI_SIGNATURE
                                        );

         if (!IPArray) {
             goto Cleanup;
         }


         //
         // Marshall the returned data into a hostent structure. Note that
         // we use a Unicode hostname instead of the ANSI name.
         //

         while (( pWSALookupServiceNextW( hRnr,
                                          dnsFlags,
                                          &dwQuerySize,
                                          pBuffer ) == NO_ERROR )) {


             if ((bCapturedOfficialName) && (pBuffer->lpszServiceInstanceName)) {

                 //
                 // We pick up the first alias -- verified with JamesG.
                 // Note that we shoe horn a Unicode string instead of a ptr to
                 // null-terminated array of ANSI strings.
                 //

                 phostent->h_aliases = (PCHAR*) ldap_dup_stringW(pBuffer->lpszServiceInstanceName,
                                                                 0,
                                                                 LDAP_HOST_NAME_SIGNATURE
                                                                 );
                 if (!phostent->h_aliases) {
                     goto Cleanup;
                 }
                 IF_DEBUG(CONNECTION) {
                     LdapPrint1("First host alias is %S\n", phostent->h_aliases);
                 }
             }

             //
             // We pick off the official name first; Clarified with JamesG.
             //
             
             if ((!phostent->h_name) &&
                 (pBuffer->dwNumberOfCsAddrs > 0)) {

                 phostent->h_name = (PCHAR) ldap_dup_stringW(pBuffer->lpszServiceInstanceName,
                                                             0,
                                                             LDAP_HOST_NAME_SIGNATURE
                                                             );
                 if (!phostent->h_name) {
                     goto Cleanup;
                 }
                 IF_DEBUG(CONNECTION) {
                     LdapPrint1("Official host %S\n", phostent->h_name);
                 }

                 bCapturedOfficialName = TRUE;
             }

             struct sockaddr_in *ptemp;

             ptemp = (sockaddr_in *) pBuffer->lpcsaBuffer->RemoteAddr.lpSockaddr;

             ASSERT(sizeof(ptemp->sin_addr) == phostent->h_length);

             IF_DEBUG(CONNECTION) {
                 LdapPrint1("Number of addresses collected 0x%x\n", pBuffer->dwNumberOfCsAddrs );
             }

             UINT i;

             for (i=0 ;( i < pBuffer->dwNumberOfCsAddrs ); i++,totalCount++) {

                    ptemp = (struct sockaddr_in *) pBuffer->lpcsaBuffer[i].RemoteAddr.lpSockaddr;

                    if ( totalCount == arraySize ) {

                        PCHAR *newArray;
                        int j=0;

                        //
                        // It is time to realloc our IPArray since it is too small.
                        //

                        arraySize *=2;

                        newArray = (PCHAR*) ldapMalloc( (arraySize+1)*sizeof(PCHAR),
                                                        LDAP_ANSI_SIGNATURE
                                                        );
                        if (!newArray) {
                            goto Cleanup;
                        }

                        //
                        // Copy all the old entries to the new one.
                        //

                        while (IPArray[j]) {
                            newArray[j] = IPArray[j];
                            j++;
                        }
                        //
                        // Free the old array.
                        //
                        ldapFree( IPArray, LDAP_ANSI_SIGNATURE );
                        
                        IPArray = newArray;
                    }

                    IPArray[totalCount] = (PCHAR) ldapMalloc(phostent->h_length,
                                                                 LDAP_ANSI_SIGNATURE);

                    if (IPArray[totalCount] == NULL) {
                        goto Cleanup;
                    }

                    CopyMemory( IPArray[totalCount], &ptemp->sin_addr, phostent->h_length );

                    IF_DEBUG(CONNECTION) {
                        if (pinet_ntoa) {
                            LdapPrint1("Copied address %s\n", pinet_ntoa(ptemp->sin_addr));
                        }
                    }
             }

             //
             // We need to determine the required buffer size before each call to 
             // WSALookupServiceBegin. Keep in mind that the buffer length can change
             // for each call.
             //

             DWORD dwNewQuerySize = 0;

             retval = pWSALookupServiceNextW( hRnr,
                                              dnsFlags,
                                              &dwNewQuerySize,
                                              NULL          // No buffer supplied on purpose
                                              );

             if (GetLastError() != WSAEFAULT) {
                 IF_DEBUG(CONNECTION) {
                     LdapPrint1( "WSALookupServiceNext failed with %d\n", GetLastError() );
                 }
                 break;
             
             } else {

                 if (dwNewQuerySize > dwQuerySize) {

                     IF_DEBUG(CONNECTION) {
                         LdapPrint1( "WSALookupServiceNext requires a bigger buffer of %d\n", dwNewQuerySize );
                     }
                     ldapFree( pBuffer, LDAP_BUFFER_SIGNATURE);
                     pBuffer = (PWSAQUERYSETW) ldapMalloc(dwNewQuerySize, LDAP_BUFFER_SIGNATURE);

                     if (!pBuffer) {
                         break; 
                     }

                     dwQuerySize = dwNewQuerySize;
                 }
             }

         }

         phostent->h_addr_list = IPArray;

Cleanup:
         ldapFree( pBuffer, LDAP_BUFFER_SIGNATURE );

         if ( hRnr ) {
             pWSALookupServiceEnd( hRnr );
         }

         if ( totalCount == 0 ) {

             if (phostent) {

                 ldapFree(phostent->h_name, LDAP_HOST_NAME_SIGNATURE);
                 ldapFree(phostent->h_aliases, LDAP_HOST_NAME_SIGNATURE);
                 ldapFree(phostent, LDAP_ANSI_SIGNATURE);
                 phostent = NULL;
             }

             ldapFree(IPArray, LDAP_ANSI_SIGNATURE);
         }

         return phostent;

    } else {

        //
        // We don't have winsock2 functionality, do our best by calling gethostbyname
        //

        PCHAR ansiHostname = NULL;
        struct hostent * retval = NULL;
        ULONG err = 0;

        LdapPrint0("No Winsock2 functionality found.\n");

        err = FromUnicodeWithAlloc( hostName,
                                    &ansiHostname,
                                    LDAP_HOST_NAME_SIGNATURE,
                                    LANG_ACP);

        if (err != LDAP_SUCCESS) {
            return NULL;
        }

        retval = ((*pgethostbyname)( ansiHostname ));

        ldapFree( ansiHostname, LDAP_HOST_NAME_SIGNATURE );

        return retval;
    }

}

ULONG
Inet_addrW(
   PWCHAR  IpAddressW
 )
{
    //
    // Convert from Unicode to ANSI because inet_addr does not handle
    // Unicode.
    //

    PCHAR IpAddressA = NULL;
    ULONG err, retval;

    err = FromUnicodeWithAlloc( IpAddressW,
                                &IpAddressA,
                                LDAP_BUFFER_SIGNATURE,
                                LANG_ACP);

    if (err != LDAP_SUCCESS) {

        return INADDR_NONE;
    }

    retval = (*pinet_addr)( IpAddressA );

    ldapFree( IpAddressA, LDAP_BUFFER_SIGNATURE );

    return retval;

}

// open.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\paged.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    paged.cxx  paged results support routines for the LDAP api

Abstract:

   This module implements routines that handle paging through results

Author:

    Andy Herron (andyhe)        02-Apr-1997

Revision History:

    Anoop Anantha (anoopa)      25-Dec-1999
            
            Added support for Virtual List View (VLV)

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG LdapGetNextPage(
        PLDAP_CONN      connection,
        PLDAP_REQUEST   request,
        ULONG           PageSize,
        ULONG          *MessageNumber,
        BOOLEAN         Synchronous
        );

ULONG
LdapCreatePageControl (
        PLDAP_CONN      connection,
        ULONG           PageSize,
        struct berval  *Cookie,
        UCHAR           IsCritical,
        PLDAPControlW  *Control,
        ULONG           CodePage
        );

ULONG
LdapParsePageControl (
        PLDAP_CONN      connection,
        PLDAPControlW  *ServerControls,
        ULONG          *TotalCount,
        struct berval  **Cookie,
        ULONG           CodePage
        );

PLDAPSearch
LdapSearchInitPage (
        PLDAP_CONN      connection,
        PWCHAR          DistinguishedName,
        ULONG           ScopeOfSearch,
        PWCHAR          SearchFilter,
        PWCHAR          AttributeList[],
        ULONG           AttributesOnly,
        ULONG           CodePage,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           PageTimeLimit,
        ULONG           TotalSizeLimit,
        PLDAPSortKeyW  *SortKeys
    )
//
//  We setup a request buffer to hold the info for this search since it will
//  span multiple requests.
//
{
    ULONG err;
    PLDAP_REQUEST request = NULL;
    UCHAR chaseReferrals;
    PLDAPControlW *controls;
    PLDAPControlW currentControl = NULL;
    ULONG extraSlots;
    BOOLEAN Unicode = (( CodePage == LANG_UNICODE ) ? TRUE : FALSE );

    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {

       SetConnectionError( connection, err, NULL );

       return NULL;
    }

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    request = LdapCreateRequest( connection, LDAP_SEARCH_CMD );

    if (request == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap_search connection 0x%x couldn't allocate request.\n", connection);
        }
        err = LDAP_NO_MEMORY;
        goto exitSetupPagedResults;
    }

    request->Synchronous = FALSE;
    request->AllocatedParms = FALSE;
    request->search.Unicode = Unicode;
    request->search.ScopeOfSearch = ScopeOfSearch;
    request->search.AttributesOnly = AttributesOnly;
    request->TimeLimit = PageTimeLimit;
    request->SizeLimit = TotalSizeLimit;
    request->ReceivedData = FALSE;
    request->PendingPagedMessageId = 0;

    //
    //  we have to save off here whether or not we chase referrals because
    //  LdapCheckControls will not save off the controls if we don't chase
    //  referrals.
    //

    chaseReferrals = request->ChaseReferrals;
    request->ChaseReferrals = TRUE;

    if ((SortKeys != NULL) && (*SortKeys != NULL)) {

        extraSlots = 2;

    } else {

        extraSlots = 1;
    }

    err = LdapCheckControls( request,
                             ServerControls,
                             ClientControls,
                             Unicode,
                             extraSlots );  // extra for sorting, extra for paged

    if (err != LDAP_SUCCESS) {

        IF_DEBUG(CONTROLS) {
            LdapPrint2( "ldap_search connection 0x%x trouble with SControl, err 0x%x.\n",
                        connection, err );
        }
        goto exitSetupPagedResults;
    }

    request->ChaseReferrals = chaseReferrals;
    request->PagedSearchBlock = TRUE;

    err = LdapSaveSearchParameters( request,
                                    DistinguishedName,
                                    SearchFilter,
                                    AttributeList,
                                    Unicode
                                    );
    if (err != LDAP_SUCCESS) {

        IF_DEBUG(CONTROLS) {
            LdapPrint2( "ldap_search connection 0x%x trouble saving parms, err 0x%x.\n",
                        connection, err );
        }
        goto exitSetupPagedResults;
    }

    //
    //  add in sorting control to the list of server controls
    //

    if ((SortKeys != NULL) && (*SortKeys != NULL)) {

        controls = request->ServerControls;

        while (*controls != NULL) {

            currentControl = *controls;

            if (currentControl->ldctl_oid == NULL) {
                break;
            }
            currentControl = NULL;
            controls++;
        }

        if (currentControl == NULL) {

            err = LDAP_NO_MEMORY;
            IF_DEBUG(CONTROLS) {
                LdapPrint2( "ldap_search connection 0x%x trouble saving parms, err 0x%x.\n",
                            connection, err );
            }
            goto exitSetupPagedResults;
        }

        err = LdapEncodeSortControl( connection,
                                     SortKeys,
                                     currentControl,
                                     TRUE,               // criticality
                                     CodePage
                                     );
    }

exitSetupPagedResults:

    if (err != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_init_page connection 0x%x had error of 0x%x.\n",
                        connection, err );
        }

        if (request != NULL) {

            CloseLdapRequest( request );
            DereferenceLdapRequest( request );
        }
        request = NULL;
    }

    SetConnectionError( connection, err, NULL );

    //
    // In this case, the refcount of the search handle (which is actually
    // a request) is 2.
    //

    return (PLDAPSearch) request;
}

WINLDAPAPI PLDAPSearch LDAPAPI ldap_search_init_pageW(
        PLDAP           ExternalHandle,
        PWCHAR          DistinguishedName,
        ULONG           ScopeOfSearch,
        PWCHAR          SearchFilter,
        PWCHAR          AttributeList[],
        ULONG           AttributesOnly,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           PageTimeLimit,
        ULONG           TotalSizeLimit,
        PLDAPSortKeyW  *SortKeys
    )
{
    PLDAP_CONN connection = NULL;
    PLDAPSearch search;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {

        return NULL;
    }

    search = LdapSearchInitPage(connection,
                                DistinguishedName,
                                ScopeOfSearch,
                                SearchFilter,
                                AttributeList,
                                AttributesOnly,
                                LANG_UNICODE,
                                ServerControls,
                                ClientControls,
                                PageTimeLimit,
                                TotalSizeLimit,
                                SortKeys
                                );

    DereferenceLdapConnection( connection );

    return search;
}

WINLDAPAPI PLDAPSearch LDAPAPI ldap_search_init_pageA(
        PLDAP           ExternalHandle,
        PCHAR           DistinguishedName,
        ULONG           ScopeOfSearch,
        PCHAR           SearchFilter,
        PCHAR           AttributeList[],
        ULONG           AttributesOnly,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        ULONG           PageTimeLimit,
        ULONG           TotalSizeLimit,
        PLDAPSortKeyA  *SortKeys
    )
{
    ULONG err;
    PWCHAR wName = NULL;
    PWCHAR wFilter = NULL;
    PLDAP_CONN connection = NULL;
    PLDAPSearch search = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        goto error;
    }

    err = ToUnicodeWithAlloc( SearchFilter, -1, &wFilter, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        goto error;
    }

    search = LdapSearchInitPage(connection,
                                wName,
                                ScopeOfSearch,
                                wFilter,
                                (PWCHAR *) AttributeList,
                                AttributesOnly,
                                LANG_ACP,
                                (PLDAPControlW *) ServerControls,
                                (PLDAPControlW *) ClientControls,
                                PageTimeLimit,
                                TotalSizeLimit,
                                (PLDAPSortKeyW *) SortKeys
                                );

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wFilter)
        ldapFree( wFilter, LDAP_UNICODE_SIGNATURE );

    DereferenceLdapConnection( connection );

    return search;
}


ULONG LdapGetNextPage(
        PLDAP_CONN      connection,
        PLDAP_REQUEST   request,
        ULONG           PageSize,
        ULONG          *MessageNumber,
        BOOLEAN         Synchronous
    )
{
    ULONG err;
    PLDAPControlW *controls;
    PLDAPControlW replacedControl = NULL;
    PLDAPControlW allocatedControl = NULL;
    ULONG msgId = (ULONG) -1;

    PLDAP_CONN tempConn = connection;

    if (MessageNumber != NULL) {

        *MessageNumber = msgId;
    }

    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {

       return err;
    }

    if (request->PagedSearchBlock != TRUE) {

        return LDAP_PARAM_ERROR;
    }

    //
    //  if we've received all of the data and have an empty cookie, nothing
    //  more to do.
    //

    if ((request->ReceivedData == TRUE) &&
        (request->PagedSearchServerCookie == NULL)) {

        return LDAP_NO_RESULTS_RETURNED;
    }

    if (request->PendingPagedMessageId != 0) {

        //
        //  if we've already sent the cookie, don't do it again.
        //

        return LDAP_LOCAL_ERROR;
    }

    controls = request->ServerControls;

    while (*controls != NULL) {

        replacedControl = *controls;

        if (replacedControl->ldctl_oid == NULL) {

            break;
        }

        replacedControl = NULL;
        controls++;
    }

    if (replacedControl == NULL) {

        err = LDAP_LOCAL_ERROR;
        IF_DEBUG(CONTROLS) {
            LdapPrint2( "ldap_get_next_page connection 0x%x trouble setting controls, err 0x%x.\n",
                        connection, err );
        }
        goto exitGetNextPage;
    }

    err = LdapCreatePageControl(    connection,
                                    PageSize,
                                    request->PagedSearchServerCookie,
                                    0x01,       // IsCritical
                                    &allocatedControl,
                                    request->search.Unicode ?
                                            LANG_UNICODE :
                                            LANG_ACP );

    *controls = allocatedControl;

    request->ReceivedData = TRUE;

    //
    // for now, if the app passed in clientControls, then we hope that they
    // disabled referrals
    //

    PLDAPControlW   *ClientControls;

    ClientControls = request->ClientControls;

    LDAPControlW referralControl;
    PLDAPControlW controlArray[2];
    ULONG referralControlValue;

    if (ClientControls == NULL) {

        //
        //  we're not setup to handle subordinate referrals on paged results
        //  so just handle external referrals if client so desires
        //

        referralControlValue = ( connection->publicLdapStruct.ld_options &
                                LDAP_CHASE_EXTERNAL_REFERRALS );

        controlArray[0] = &referralControl;
        controlArray[1] = NULL;

        referralControl.ldctl_iscritical = TRUE;
        referralControl.ldctl_value.bv_len = sizeof(referralControlValue);
        referralControl.ldctl_value.bv_val = (PCHAR) &referralControlValue;

        if (request->search.Unicode) {

            referralControl.ldctl_oid = LDAP_CONTROL_REFERRALS_W;

        } else {

            referralControl.ldctl_oid = (PWCHAR) LDAP_CONTROL_REFERRALS;
        }

        ClientControls = &controlArray[0];
    }

    //
    // Before we fire off the search, we have to make sure that we are
    // sending the search to the correct server. In the case of us following
    // external referrals, we have to walk a chain of connections until we
    // find the last server.
    //

    if (request->SecondaryConnection) {

        IF_DEBUG(CONTROLS) {
            LdapPrint0("Sending paged search to external referred server\n");
        }
        tempConn = request->SecondaryConnection;
    }

    err = LdapSearch(   tempConn,
                        request->OriginalDN,
                        request->search.ScopeOfSearch,
                        request->search.SearchFilter,
                        request->search.AttributeList,
                        request->search.AttributesOnly,
                        request->search.Unicode,
                        Synchronous,
                        request->ServerControls,
                        ClientControls,
                        request->TimeLimit,
                        request->SizeLimit,
                        &msgId
                        );

    if (err == LDAP_SUCCESS) {

        request->PendingPagedMessageId = msgId;

        //
        // Find the request associated with this msgid and hookup
        // the search block. This will be useful later during external
        // referral chasing.
        //

        PLDAP_REQUEST LatestRequest = FindLdapRequest( msgId );

        if (LatestRequest) {

            //
            // Reference the search block so that it doesn't go away.
            //

            request = ReferenceLdapRequest( request );
            ASSERT( request );
            LatestRequest->PageRequest = request;
            DereferenceLdapRequest( LatestRequest );
        }
    }

exitGetNextPage:

    if (replacedControl != NULL) {

        if (allocatedControl != NULL) {

            ldap_control_freeW( allocatedControl );
        }

        *controls = replacedControl;
    }

    if (MessageNumber != NULL) {

        *MessageNumber = msgId;
    }

    return err;
}


WINLDAPAPI ULONG LDAPAPI ldap_get_next_page(
        PLDAP           ExternalHandle,
        PLDAPSearch     SearchBlock,
        ULONG           PageSize,
        ULONG          *MessageNumber
    )
{
    ULONG err;
    PLDAP_CONN connection = NULL;
    PLDAP_REQUEST request = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    request = ReferenceLdapRequest( (PLDAP_REQUEST) SearchBlock );

    if (request == NULL) {
        DereferenceLdapConnection( connection );
        return LDAP_PARAM_ERROR;
    }
    
    err = LdapGetNextPage(  connection,
                            request,
                            PageSize,
                            MessageNumber,
                            FALSE );

    DereferenceLdapRequest( request );
    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_get_next_page_s(
        PLDAP           ExternalHandle,
        PLDAPSearch     SearchHandle,
        struct l_timeval  *timeout,
        ULONG           PageSize,
        ULONG          *TotalCount,
        LDAPMessage     **Results
    )
{
    ULONG msgId;
    ULONG err = LDAP_SUCCESS;
    ULONG RetCode = LDAP_SUCCESS;
    PLDAP_CONN connection = NULL;
    PLDAP_REQUEST request = NULL;
    ULONG timeLimit;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (Results == NULL) || (SearchHandle == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *Results = NULL;

    if (TotalCount != NULL) {

        *TotalCount = 0;
    }

    if (timeout != NULL) {

        timeLimit = (ULONG) timeout->tv_sec + ( timeout->tv_usec / ( 1000 * 1000 ));

    } else {

        timeLimit = connection->publicLdapStruct.ld_timelimit;
    }

    request = ReferenceLdapRequest( (PLDAP_REQUEST) SearchHandle );

    if (request == NULL) {
        DereferenceLdapConnection( connection );
        return LDAP_PARAM_ERROR;
    }
    
    err = LdapGetNextPage(  connection,
                            request,
                            PageSize,
                            &msgId,
                            TRUE );

    
    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        PLDAPMessage lastMessage = NULL;

        //
        //  otherwise we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error(  connection,
                                       msgId,
                                       LDAP_MSG_ALL,
                                       timeout,
                                       Results,
                                       &lastMessage
                                       );

        if (*Results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            ASSERT( lastMessage != NULL );

            RetCode = LdapGetPagedCount(    connection,
                                            request,
                                            TotalCount,
                                            lastMessage );
        }
    }

error:

    if (request)
        DereferenceLdapRequest( request );

    if (connection)
        DereferenceLdapConnection( connection );

    if (RetCode != LDAP_SUCCESS) {

       return RetCode;

    }

    return err;

}


WINLDAPAPI
ULONG LDAPAPI ldap_get_paged_count(
        PLDAP           ExternalHandle,
        PLDAPSearch     SearchBlock,
        ULONG          *TotalCount,
        PLDAPMessage    Results
    )
{
    ULONG err;
    PLDAP_CONN connection = NULL;
    PLDAP_REQUEST request = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {

        return LDAP_PARAM_ERROR;
    }

    request = (PLDAP_REQUEST) SearchBlock;

    request = ReferenceLdapRequest( request );

    if (request == NULL) {
        
        return LDAP_PARAM_ERROR;
    }
    
    err = LdapGetPagedCount( connection,
                             request,
                             TotalCount,
                             Results );

    DereferenceLdapRequest( request );
    DereferenceLdapConnection( connection );

    return err;
}



ULONG LDAPAPI LdapGetPagedCount(
        PLDAP_CONN      connection,
        PLDAP_REQUEST   request,
        ULONG          *TotalCount,
        PLDAPMessage    Results
    )
{
    PLDAPControlW *serverControls = NULL;
    ULONG err = LDAP_SUCCESS;
    ULONG RetCode = LDAP_SUCCESS;

    if (Results == NULL) {

        return LDAP_PARAM_ERROR;
    }

    if (request->PagedSearchBlock != TRUE) {

        return LDAP_PARAM_ERROR;
    }

    if ( request->SecondaryConnection ) {

        IF_DEBUG(CONTROLS) {
            LdapPrint2("Getting data for conn 0x%x instead of 0x%x\n",request->SecondaryConnection, connection );
        }
        connection = request->SecondaryConnection;
    }

    if (TotalCount != NULL) {

        *TotalCount = 0;
    }

    err = LdapParseResult(  connection,
                            Results,
                            &RetCode,  // return code
                            NULL,     // matchedDNs
                            NULL,     // error message
                            NULL,     // referrals
                            &serverControls,
                            FALSE,    // don't free messages
                            request->search.Unicode ?
                                        LANG_UNICODE :
                                        LANG_ACP );

    //
    //  grab the server cookie from the response and store in the paged request
    //  buffer.
    //

    if (serverControls != NULL) {

        ULONG  totalCount;

        ber_bvfree( request->PagedSearchServerCookie );
        request->PagedSearchServerCookie = NULL;

        err = LdapParsePageControl( connection,
                                    serverControls,
                                    &totalCount,
                                    &request->PagedSearchServerCookie,
                                    request->search.Unicode ?
                                            LANG_UNICODE :
                                            LANG_ACP );

        if (request->PagedSearchServerCookie != NULL &&
            request->PagedSearchServerCookie->bv_len == 0) {

            ber_bvfree( request->PagedSearchServerCookie );
            request->PagedSearchServerCookie = NULL;
        }

        if (err == LDAP_SUCCESS) {

            if (TotalCount != NULL) {

                *TotalCount = totalCount;
            }

            request->PendingPagedMessageId = 0;
        }

        ldap_controls_freeW( serverControls );

    } else if (request->PagedSearchServerCookie != NULL) {

        //
        //  check to see if the server sent a searchResultDone.  If it did,
        //  then we simply free the cookie.
        //

        LDAPMessage *checkResult = Results;

        while ((checkResult != NULL) &&
               ((checkResult->lm_msgtype == LDAP_RES_REFERRAL) ||
                (checkResult->lm_msgtype == LDAP_RES_SEARCH_ENTRY))) {

            checkResult = checkResult->lm_chain;
        }

        if (checkResult != NULL) {

            request->PendingPagedMessageId = 0;

            ber_bvfree( request->PagedSearchServerCookie );
            request->PagedSearchServerCookie = NULL;
        }
    }

    if (RetCode != LDAP_SUCCESS) {

       //
       // If the server returned an error code, let the user know.
       //

       return RetCode;
    }

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_search_abandon_page(
        PLDAP           ExternalHandle,
        PLDAPSearch     SearchBlock
    )
{
    ULONG err = LDAP_SUCCESS;
    PLDAP_CONN connection = NULL;
    PLDAP_CONN refConnection = NULL;
    PLDAP_REQUEST request = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (SearchBlock == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    refConnection = connection;     // For dereferencing later

    request = (PLDAP_REQUEST) SearchBlock;

    request = ReferenceLdapRequest( request );

    if (request == NULL) {
        err = LDAP_PARAM_ERROR;
        goto error;
    }

    if (request->PagedSearchBlock != TRUE) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    if (request->SecondaryConnection) {

        IF_DEBUG(CONTROLS) {
            LdapPrint2("Getting data for conn 0x%x instead of 0x%x\n",request->SecondaryConnection, connection );
        }
        connection = request->SecondaryConnection;
    }

    //
    //  if we have a cookie from the server, then send a search request closing
    //  it out.
    //

    if ((request->ReceivedData == TRUE) &&
        (request->PagedSearchServerCookie != NULL)) {

        PLDAPMessage results = NULL;

        err = ldap_get_next_page_s( connection->ExternalInfo,
                                    SearchBlock,
                                    NULL,       // timeout
                                    0,
                                    NULL,       // total count
                                    &results );

        ldap_msgfree( results );
    }

    if (request->PendingPagedMessageId != 0) {

        LdapAbandon( connection, request->PendingPagedMessageId, TRUE );
        request->PendingPagedMessageId = 0;
    }

    if (request->SecondaryConnection != NULL) {

        //
        // We have to decrement refcnt
        //

        ACQUIRE_LOCK( &request->SecondaryConnection->StateLock);
        request->SecondaryConnection->HandlesGivenAsReferrals--;
        RELEASE_LOCK( &request->SecondaryConnection->StateLock);

        IF_DEBUG(CONTROLS) {
            LdapPrint1("Penultimate refcnt for sec conn is %d\n", request->SecondaryConnection->ReferenceCount);
        }
    }

    CloseLdapRequest( request );

    DereferenceLdapRequest( request );

error:
    if (request)
        DereferenceLdapRequest( request );
    
    if (refConnection)
        DereferenceLdapConnection( refConnection );
    
    return err;
}


WINLDAPAPI
ULONG LDAPAPI
ldap_create_page_controlW (
        PLDAP           ExternalHandle,
        ULONG           PageSize,
        struct berval  *Cookie,
        UCHAR           IsCritical,
        PLDAPControlW  *Control
        )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {

        return LDAP_PARAM_ERROR;
    }

    err = LdapCreatePageControl(    connection,
                                    PageSize,
                                    Cookie,
                                    IsCritical,
                                    Control,
                                    LANG_UNICODE );

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI
ULONG LDAPAPI
ldap_create_page_controlA (
        PLDAP           ExternalHandle,
        ULONG           PageSize,
        struct berval  *Cookie,
        UCHAR           IsCritical,
        PLDAPControlA  *Control
        )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        if (Control) {

            *Control = NULL;
        }

        return LDAP_PARAM_ERROR;
    }

    err = LdapCreatePageControl(    connection,
                                    PageSize,
                                    Cookie,
                                    IsCritical,
                                    (PLDAPControlW *) Control,
                                    LANG_ACP );

    DereferenceLdapConnection( connection );

    return err;
}

ULONG
LdapCreatePageControl (
        PLDAP_CONN      connection,
        ULONG           PageSize,
        struct berval  *Cookie,
        UCHAR           IsCritical,
        PLDAPControlW  *Control,
        ULONG           CodePage
        )
{

    ULONG err;
    BOOLEAN criticality = ( (IsCritical > 0) ? TRUE : FALSE );
    PLDAPControlW  control = NULL;
    CLdapBer *lber = NULL;

    if (Control == NULL) {

        return LDAP_PARAM_ERROR;
    }

    control = (PLDAPControlW) ldapMalloc( sizeof( LDAPControlW ), LDAP_CONTROL_SIGNATURE );

    if (control == NULL) {

        *Control = NULL;
        return LDAP_NO_MEMORY;
    }

    control->ldctl_iscritical = criticality;

    if (CodePage == LANG_UNICODE) {

        control->ldctl_oid = ldap_dup_stringW( LDAP_PAGED_RESULT_OID_STRING_W,
                                               0,
                                               LDAP_VALUE_SIGNATURE );
    } else {

        control->ldctl_oid = (PWCHAR) ldap_dup_string(  LDAP_PAGED_RESULT_OID_STRING,
                                                        0,
                                                        LDAP_VALUE_SIGNATURE );
    }

    if (control->ldctl_oid == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodePagedControl;
    }

    lber = new CLdapBer( connection->publicLdapStruct.ld_version );

    if (lber == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodePagedControl;
    }

    err = lber->HrStartWriteSequence();

    if (err != LDAP_SUCCESS) {

        goto exitEncodePagedControl;
    }

    err = lber->HrAddValue( (LONG) PageSize );

    if ((Cookie != NULL) &&
        (Cookie->bv_len > 0) &&
        (Cookie->bv_val != NULL)) {

        err = lber->HrAddBinaryValue((BYTE *) Cookie->bv_val,
                                              Cookie->bv_len
                                              );
    } else {

        err = lber->HrAddValue( (const CHAR *) NULL );
    }

    if (err != LDAP_SUCCESS) {

        goto exitEncodePagedControl;
    }

    err = lber->HrEndWriteSequence();
    ASSERT( err == NOERROR );

    control->ldctl_value.bv_len = lber->CbData();

    if (control->ldctl_value.bv_len == 0) {

        err = LDAP_LOCAL_ERROR;
        goto exitEncodePagedControl;
    }

    control->ldctl_value.bv_val = (PCHAR) ldapMalloc(
                                                control->ldctl_value.bv_len,
                                                LDAP_CONTROL_SIGNATURE );

    if (control->ldctl_value.bv_val == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodePagedControl;
    }

    CopyMemory( control->ldctl_value.bv_val,
                lber->PbData(),
                control->ldctl_value.bv_len );

    err = LDAP_SUCCESS;

exitEncodePagedControl:

    if (err != LDAP_SUCCESS) {

        ldap_control_freeW( control );
        control = NULL;
    }

    if (lber != NULL) {
        delete lber;
    }

    *Control = control;
    return err;
}

WINLDAPAPI
ULONG LDAPAPI
ldap_parse_page_controlW (
        PLDAP           ExternalHandle,
        PLDAPControlW  *ServerControls,
        ULONG          *TotalCount,
        struct berval  **Cookie
        )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {

        return LDAP_PARAM_ERROR;
    }

    err = LdapParsePageControl(     connection,
                                    ServerControls,
                                    TotalCount,
                                    Cookie,
                                    LANG_UNICODE );

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI
ULONG LDAPAPI
ldap_parse_page_controlA (
        PLDAP           ExternalHandle,
        PLDAPControlA  *ServerControls,
        ULONG          *TotalCount,
        struct berval  **Cookie
        )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {

        return LDAP_PARAM_ERROR;
    }

    err = LdapParsePageControl(     connection,
                                    (PLDAPControlW *) ServerControls,
                                    TotalCount,
                                    Cookie,
                                    LANG_ACP );

    DereferenceLdapConnection( connection );

    return err;
}

ULONG
LdapParsePageControl (
        PLDAP_CONN      connection,
        PLDAPControlW  *ServerControls,
        ULONG          *TotalCount,
        struct berval  **Cookie,
        ULONG           CodePage
        )
{
    ULONG err = LDAP_CONTROL_NOT_FOUND;
    CLdapBer *lber = NULL;

    //
    //  First thing is to zero out the parms passed in.
    //

    if (TotalCount != NULL) {

        *TotalCount = 0;
    }

    if (Cookie != NULL) {

        *Cookie = NULL;
    }

    if (ServerControls != NULL) {

        PLDAPControlW *controls = ServerControls;
        PLDAPControlW currentControl;
        ULONG bytesTaken;
        LONG totalCount;

        while (*controls != NULL) {

            currentControl = *controls;

            //
            //  check to see if the current control is the SIMPLE PAGING control
            //

            if ( ((CodePage == LANG_UNICODE) &&
                  ( ldapWStringsIdentical( currentControl->ldctl_oid,
                                           -1,
                                           LDAP_PAGED_RESULT_OID_STRING_W,
                                           -1 ) == TRUE )) ||
                 ((CodePage == LANG_ACP) &&
                  ( CompareStringA( LDAP_DEFAULT_LOCALE,
                                    NORM_IGNORECASE,
                                    (PCHAR) currentControl->ldctl_oid,
                                    -1,
                                    LDAP_PAGED_RESULT_OID_STRING,
                                    sizeof(LDAP_PAGED_RESULT_OID_STRING) ) == 2)) ) {

                lber = new CLdapBer( connection->publicLdapStruct.ld_version );

                if (lber == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint1( "LdapParsePageControl: unable to alloc msg for 0x%x.\n",
                                    connection );
                    }

                    err = LDAP_NO_MEMORY;
                    break;
                }

                err = lber->HrLoadBer(   (const BYTE *) currentControl->ldctl_value.bv_val,
                                         currentControl->ldctl_value.bv_len,
                                         &bytesTaken,
                                         TRUE );    // we have the whole message guarenteed

                if (err != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParsePageControl: loadBer error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    break;
                }

                err = lber->HrStartReadSequence();
                if (err != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParsePageControl: loadBer error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    break;
                }

                err = lber->HrGetValue( &totalCount );
                if (err != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParsePageControl: loadBer error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    break;
                }

                if (TotalCount != NULL) {

                    *TotalCount = totalCount;
                }

                if (Cookie != NULL) {

                    struct berval *cookie;
                    PBYTE *ppbBuf = NULL;

                    cookie = (struct berval *) ldapMalloc(
                                sizeof( struct berval ),
                                LDAP_BERVAL_SIGNATURE );

                    if (cookie == NULL) {

                        err = LDAP_NO_MEMORY;
                        IF_DEBUG(PARSE) {
                            LdapPrint1( "LdapParsePageControl: couldn't alloc berval for 0x%x.\n",
                                        connection );
                        }
                        break;
                    }

                    err = lber->HrGetBinaryValuePointer( (PBYTE *) &ppbBuf,
                                                         &cookie->bv_len );

                    if (ppbBuf != NULL) {

                        cookie->bv_val = (PCHAR)
                                ldapMalloc( cookie->bv_len,
                                            LDAP_CONTROL_SIGNATURE );

                        if (cookie->bv_val == NULL) {

                            err = LDAP_NO_MEMORY;
                            ber_bvfree( cookie );
                            break;
                        }

                        CopyMemory( cookie->bv_val,
                                    ppbBuf,
                                    cookie->bv_len );
                    } else {

                        cookie->bv_len = 0;
                        cookie->bv_val = NULL;
                    }

                    *Cookie = cookie;
                }

                err = LDAP_SUCCESS;
                break;                  // done with loop... look no more
            }
            controls++;
        }
    }

    if (lber != NULL) {

        delete lber;
    }

    SetConnectionError( connection, err, NULL );
    return err;
}



ULONG
LdapEncodeVlvControl (
    PLDAP_CONN      connection,
    PLDAPControlW   OutputControl,
    PLDAPVLVInfo    VlvInfo,
    BOOLEAN         Criticality,
    ULONG           CodePage
    )
{
    ULONG err = LDAP_PARAM_ERROR;
    CLdapBer *lber = NULL;
    ULONG hr = NOERROR;

    if ((connection == NULL) ||
        (OutputControl == NULL) ||
        (VlvInfo->ldvlv_version != LDAP_VLVINFO_VERSION) ||
        (!IsLdapInteger( (int) VlvInfo->ldvlv_before_count)) ||
        (!IsLdapInteger( (int) VlvInfo->ldvlv_after_count))  ||
        ((VlvInfo->ldvlv_attrvalue == NULL) &&
         (!IsLdapInteger( (int) VlvInfo->ldvlv_offset) ||
          !IsLdapInteger( (int) VlvInfo->ldvlv_count)))) {

        return LDAP_PARAM_ERROR;
    }

    OutputControl->ldctl_oid = NULL;
    OutputControl->ldctl_iscritical = Criticality;

    if (CodePage == LANG_UNICODE) {

        OutputControl->ldctl_oid = ldap_dup_stringW( LDAP_CONTROL_VLVREQUEST_W,
                                                     0,
                                                     LDAP_VALUE_SIGNATURE );
    } else {

        OutputControl->ldctl_oid = (PWCHAR) ldap_dup_string(  LDAP_CONTROL_VLVREQUEST,
                                                              0,
                                                              LDAP_VALUE_SIGNATURE );
    }

    if (OutputControl->ldctl_oid == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodeVlvControl;
    }

    lber = new CLdapBer( connection->publicLdapStruct.ld_version );

    if (lber == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodeVlvControl;
    }

    //
    // VirtualListViewRequest ::= SEQUENCE {
    //    beforeCount    INTEGER (0 .. maxInt),
    //    afterCount     INTEGER (0 .. maxInt),
    //    CHOICE {
    //            byoffset [0] SEQUENCE, {
    //                           offset           INTEGER (0 .. maxInt),
    //                           contentCount    INTEGER (0 .. maxInt)  
    //                          }
    //                     [1] greaterThanOrEqual assertionValue
    //            }
    //
    //    contextID     OCTET STRING OPTIONAL
    //
    //    }
    //

    hr = lber->HrStartWriteSequence();

    if (hr != NOERROR) {
        goto exitEncodeVlvControl;
    }

    hr = lber->HrAddValue( (LONG) VlvInfo->ldvlv_before_count );

    if (hr != NOERROR) {
        goto exitEncodeVlvControl;
    }
    
    hr = lber->HrAddValue( (LONG) VlvInfo->ldvlv_after_count );
    
    if (hr != NOERROR) {
        goto exitEncodeVlvControl;
    }


    if ( VlvInfo->ldvlv_attrvalue != NULL ) {

        //
        // We have an assertion value to encode. For some strange reason
        // Netscape seems to expect 0x81 instead of 0xA1. Is this a bug
        // in Netscape?
        //

        hr = lber->HrAddBinaryValue((BYTE *) VlvInfo->ldvlv_attrvalue->bv_val,
                                     VlvInfo->ldvlv_attrvalue->bv_len,
                                     0x80 | 0x1  );

    } else {

        //
        // We will use the offset & content count.
        // Constructed/context specific/tag is 0
        //

        hr = lber->HrStartWriteSequence( 0xA0 | 0x0 );

        if (hr != NOERROR) {
            goto exitEncodeVlvControl;
        }

        hr = lber->HrAddValue( (LONG) VlvInfo->ldvlv_offset );
        
        if (hr != NOERROR) {
            goto exitEncodeVlvControl;
        }

        hr = lber->HrAddValue( (LONG) VlvInfo->ldvlv_count );

        if (hr != NOERROR) {
            goto exitEncodeVlvControl;
        }
    
        hr = lber->HrEndWriteSequence();
    }

    if (hr != NOERROR) {
        goto exitEncodeVlvControl;
    }
    
    //
    // Finally, encode the context cookie if it exists.
    //

    if ( VlvInfo->ldvlv_context && VlvInfo->ldvlv_context->bv_len ) {

        hr = lber->HrAddBinaryValue((PBYTE) VlvInfo->ldvlv_context->bv_val,
                                    VlvInfo->ldvlv_context->bv_len
                                    );
    }
    
    if (hr != NOERROR) {
        goto exitEncodeVlvControl;
    }
    
    hr = lber->HrEndWriteSequence();
    ASSERT( hr == NOERROR );

    OutputControl->ldctl_value.bv_len = lber->CbData();

    if (OutputControl->ldctl_value.bv_len == 0) {

        err = LDAP_LOCAL_ERROR;
        goto exitEncodeVlvControl;
    }

    OutputControl->ldctl_value.bv_val = (PCHAR) ldapMalloc(
                            OutputControl->ldctl_value.bv_len,
                            LDAP_CONTROL_SIGNATURE );

    if (OutputControl->ldctl_value.bv_val == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodeVlvControl;
    }

    CopyMemory( OutputControl->ldctl_value.bv_val,
                lber->PbData(),
                OutputControl->ldctl_value.bv_len );

    err = LDAP_SUCCESS;

exitEncodeVlvControl:

    if (hr != NOERROR) {
        err = LDAP_DECODING_ERROR;
    }

    if (err != LDAP_SUCCESS) {

        if (OutputControl->ldctl_oid != NULL) {

            ldapFree( OutputControl->ldctl_oid, LDAP_VALUE_SIGNATURE );
            OutputControl->ldctl_oid = NULL;
        }

        OutputControl->ldctl_value.bv_len = 0;
    }

    if (lber != NULL) {
        delete lber;
    }
    
    return err;

}


ULONG
LdapCreateVlvControlWithAlloc (
        PLDAP            ExternalHandle,
        PLDAPVLVInfo     VlvInfo,
        PLDAPControlW   *Control,
        UCHAR            IsCritical,
        ULONG            CodePage
    )
{

    ULONG err;
    PLDAPControlW  control = NULL;
    PLDAP_CONN connection = NULL;
    BOOLEAN criticality = ( (IsCritical > 0) ? TRUE : FALSE );

    connection = GetConnectionPointer( ExternalHandle );

    if ((connection == NULL) || (Control == NULL) || (VlvInfo == NULL)) {
        err = LDAP_PARAM_ERROR;
        goto error;
    }

    control = (PLDAPControlW) ldapMalloc( sizeof( LDAPControlW ), LDAP_CONTROL_SIGNATURE );

    if (control == NULL) {

        *Control = NULL;
        err = LDAP_NO_MEMORY;
        goto error;
    }

    err = LdapEncodeVlvControl( connection,
                                control,
                                VlvInfo,
                                criticality,
                                CodePage
                                );

    if (err != LDAP_SUCCESS) {

        ldap_control_freeW( control );
        control = NULL;
    }

    *Control = control;

error:

    if (connection) {
        DereferenceLdapConnection( connection );
    }

    return err;

}


WINLDAPAPI
INT LDAPAPI
ldap_create_vlv_controlW (
    PLDAP            ExternalHandle,
    PLDAPVLVInfo     VlvInfo,
    UCHAR            IsCritical,
    PLDAPControlW    *Control
    )
{

    return LdapCreateVlvControlWithAlloc( ExternalHandle,
                                          VlvInfo,
                                          Control,
                                          IsCritical,
                                          LANG_UNICODE
                                          );

}

WINLDAPAPI
INT LDAPAPI
ldap_create_vlv_controlA (
    PLDAP            ExternalHandle,
    PLDAPVLVInfo     VlvInfo,
    UCHAR            IsCritical,
    PLDAPControlA    *Control
    )
{

    return LdapCreateVlvControlWithAlloc( ExternalHandle,
                                          VlvInfo,
                                          (PLDAPControlW  *)Control,
                                          IsCritical,
                                          LANG_ACP
                                          );

}


ULONG
LdapParseVlvControl (
        PLDAP_CONN      connection,
        PLDAPControlW  *ServerControls,
        ULONG          *TargetPos,
        ULONG          *ListCount,
        PBERVAL        *Context,
        INT            *Error,
        ULONG           CodePage
        )
{
    ULONG err = LDAP_CONTROL_NOT_FOUND;
    CLdapBer *lber = NULL;
    ULONG hr = NOERROR;

    //
    //  First thing is to zero out the parms passed in.
    //

    if (TargetPos != NULL) {

        *TargetPos = 0;
    }

    if (ListCount != NULL) {

        *ListCount = 0;
    }

    if (Error != NULL) {

        *Error = LDAP_SUCCESS;
    }

    if (Context != NULL) {

        *Context = NULL;
    }
    
    if (ServerControls != NULL) {

        PLDAPControlW *controls = ServerControls;
        PLDAPControlW currentControl;
        ULONG bytesTaken;
        LONG  vlvError = 0;
        ULONG targetPosition = 0;
        ULONG ContentCount = 0;

        while (*controls != NULL) {

            currentControl = *controls;

            //
            //  check to see if the current control is the VLV control
            //

            if ( ((CodePage == LANG_UNICODE) &&
                  ( ldapWStringsIdentical( currentControl->ldctl_oid,
                                           -1,
                                           LDAP_CONTROL_VLVRESPONSE_W,
                                           -1 ) == TRUE )) ||
                 ((CodePage == LANG_ACP) &&
                  ( CompareStringA( LDAP_DEFAULT_LOCALE,
                                    NORM_IGNORECASE,
                                    (PCHAR) currentControl->ldctl_oid,
                                    -1,
                                    LDAP_CONTROL_VLVRESPONSE,
                                    sizeof(LDAP_CONTROL_VLVRESPONSE) ) == 2)) ) {

                lber = new CLdapBer( connection->publicLdapStruct.ld_version );

                if (lber == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint1( "LdapParseVlvControl: unable to alloc msg for 0x%x.\n",
                                    connection );
                    }

                    err = LDAP_NO_MEMORY;
                    break;
                }

                hr = lber->HrLoadBer(   (const BYTE *) currentControl->ldctl_value.bv_val,
                                         currentControl->ldctl_value.bv_len,
                                         &bytesTaken,
                                         TRUE );    // we have the whole message guarenteed

                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseVlvControl: loadBer error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    err = LDAP_DECODING_ERROR;
                    break;
                }

                hr = lber->HrStartReadSequence();
                
                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseVlvControl: loadBer error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    err = LDAP_DECODING_ERROR;
                    break;
                }

                hr = lber->HrGetValue( (PLONG) &targetPosition );

                if ((hr != NOERROR) || !IsLdapInteger( (int) targetPosition )) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseVlvControl: TargetPos read error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    err = LDAP_DECODING_ERROR;
                    break;
                }
                
                hr = lber->HrGetValue( (PLONG) &ContentCount );

                if ((hr != NOERROR) || !IsLdapInteger( (int) ContentCount )) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseVlvControl: ListCount read error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    err = LDAP_DECODING_ERROR;
                    break;
                }
                
                hr = lber->HrGetEnumValue( &vlvError );
                
                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseVlvControl: getEnumValue error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    err = LDAP_DECODING_ERROR;
                    break;
                }

                if (TargetPos != NULL) {

                    *TargetPos = targetPosition;
                }

                if (ListCount != NULL) {

                    *ListCount = ContentCount;
                }

                if (Error != NULL) {

                    *Error = vlvError;
                }

                if (Context != NULL) {

                    struct berval *cookie;
                    PBYTE *ppbBuf = NULL;

                    cookie = (struct berval *) ldapMalloc(
                                sizeof( struct berval ),
                                LDAP_BERVAL_SIGNATURE );

                    if (cookie == NULL) {

                        err = LDAP_NO_MEMORY;
                        IF_DEBUG(PARSE) {
                            LdapPrint1( "LdapParseVlvControl: couldn't alloc berval for 0x%x.\n",
                                        connection );
                        }
                        break;
                    }

                    err = lber->HrGetBinaryValuePointer( (PBYTE *) &ppbBuf,
                                                         &cookie->bv_len );

                    if (ppbBuf != NULL) {

                        cookie->bv_val = (PCHAR)
                                ldapMalloc( cookie->bv_len,
                                            LDAP_CONTROL_SIGNATURE );

                        if (cookie->bv_val == NULL) {

                            err = LDAP_NO_MEMORY;
                            ber_bvfree( cookie );
                            break;
                        }

                        CopyMemory( cookie->bv_val,
                                    ppbBuf,
                                    cookie->bv_len );
                    } else {

                        ber_bvfree( cookie );
                        cookie = NULL;
                    }

                    *Context = cookie;
                }

                err = LDAP_SUCCESS;
                break;                  // done with loop... look no more
            }
            controls++;
        }
    }

    if (lber != NULL) {

        delete lber;
    }

    SetConnectionError( connection, err, NULL );
    return err;
}

WINLDAPAPI
INT LDAPAPI
ldap_parse_vlv_controlW (
        PLDAP             ExternalHandle,
        PLDAPControlW    *Control,
        ULONG            *TargetPos,
        ULONG            *ListCount,
        PBERVAL          *Context,
        PINT              ErrCode
    )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err  = LdapParseVlvControl(    connection,
                                   Control,
                                   TargetPos,
                                   ListCount,
                                   Context,
                                   ErrCode,
                                   LANG_UNICODE );

    DereferenceLdapConnection( connection );

    return err;

}


WINLDAPAPI
INT LDAPAPI
ldap_parse_vlv_controlA (
        PLDAP             ExternalHandle,
        PLDAPControlA    *Control,
        ULONG            *TargetPos,
        ULONG            *ListCount,
        PBERVAL          *Context,
        PINT              ErrCode
    )
{

    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err  = LdapParseVlvControl(    connection,
                                   (PLDAPControlW *)Control,
                                   TargetPos,
                                   ListCount,
                                   Context,
                                   ErrCode,
                                   LANG_ACP );

    DereferenceLdapConnection( connection );

    return err;

}



// paged.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\parse.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    parse.cxx extended parse of results from LDAP servers

Abstract:

   This module implements the APIs to break up LDAP responses into components

Author:

    Andy Herron (andyhe)        16-Apr-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG LdapParseResult (
        PLDAP_CONN connection,
        LDAPMessage *ResultMessage,
        ULONG *ReturnCode OPTIONAL,          // returned by server
        PWCHAR *MatchedDNs OPTIONAL,         // free with ldap_value_freeW
        PWCHAR *ErrorMessage OPTIONAL,       // free with ldap_value_freeW
        PWCHAR **Referrals OPTIONAL,         // free with ldap_value_freeW
        PLDAPControlW **ServerControls OPTIONAL,
        BOOLEAN Freeit,
        ULONG codePage
        )
//
//  This is one of the main entry points of the LDAP API... it returns the
//  error code that the server returned to a requesting client.  We've already
//  parsed out the return code so there's not much work.
//
{
    ULONG err;
    CLdapBer *lber;
    ULONG hr;
    ULONG tag;

    //
    //  since we return -1 on calls such as ldap_search as a message id, we'll
    //  explicitely check for it here.
    //

    if (ReturnCode != NULL) {

        *ReturnCode = 0;
    }
    if (MatchedDNs != NULL) {

        *MatchedDNs = NULL;
    }
    if (ErrorMessage != NULL) {

        *ErrorMessage = NULL;
    }
    if (Referrals != NULL) {

        *Referrals = NULL;
    }
    if (ServerControls != NULL) {

        *ServerControls = NULL;
    }

    if ( ResultMessage == (LDAPMessage *) -1 ) {

        ResultMessage = NULL;
    }

    LDAPMessage *checkResult = ResultMessage;

    while ((checkResult != NULL) &&
           ((checkResult->lm_msgtype == LDAP_RES_REFERRAL) ||
            (checkResult->lm_msgtype == LDAP_RES_SEARCH_ENTRY))) {

        checkResult = checkResult->lm_chain;
    }

    //
    //  return the result from the first non-search entry record.
    //

    if (checkResult == NULL) {

        IF_DEBUG(PARSE) {
            LdapPrint1( "LdapParseResult couldn't find result message for conn 0x%x\n",
                            connection);
        }
        return LDAP_NO_RESULTS_RETURNED;
    }

    lber = (CLdapBer *)checkResult->lm_ber;

    if (lber == NULL) {

        return LDAP_LOCAL_ERROR;
    }

    lber->Reset(FALSE);

    err = LdapInitialDecodeMessage( connection, checkResult );

    if (err != LDAP_SUCCESS) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "LdapParseResult couldn't decode message for conn 0x%x, result 0x%x.\n",
                            connection, err);
        }
        return err;
    }

    //
    //  LdapInitialDecodeMessage leaves the message parsed up to the error
    //  code.  we'll pick up the rest from there.
    //
    //      LDAPMessage ::= SEQUENCE {
    //              messageID       MessageID,
    //              protocolOp      CHOICE {  }
    //              controls       [0] Controls OPTIONAL }
    //
    //      LDAPResult ::= SEQUENCE {
    //              resultCode      ENUMERATED { };
    //              matchedDN       LDAPDN,
    //              errorMessage    LDAPString,
    //              referral        [3] Referral OPTIONAL }
    //
    //      Controls ::= SEQUENCE OF Control
    //
    //      Control ::= SEQUENCE {
    //              controlType             LDAPOID,
    //              criticality             BOOLEAN DEFAULT FALSE,
    //              controlValue            OCTET STRING OPTIONAL }
    //
    //      Referral ::= SEQUENCE OF LDAPURL
    //
    //      LDAPURL ::= LDAPString  -- limited to characters permitted in URLs
    //
    //      BindResponse ::= [APPLICATION 1] SEQUENCE {
    //           COMPONENTS OF LDAPResult,
    //           serverCreds        [7] SaslCredentials OPTIONAL }
    //
    //      For search, modify, add, rename, delete and compare... the
    //          response is just an LDAPResult
    //
    //      ExtendedResponse ::= [APPLICATION 24] SEQUENCE {
    //              COMPONENTS OF LDAPResult,
    //              responseName     [10] LDAPOID OPTIONAL,
    //              response         [11] OCTET STRING OPTIONAL }
    //

    if (ReturnCode != NULL) {
        *ReturnCode = checkResult->lm_returncode;
    }

    if (MatchedDNs != NULL) {

        if (codePage == LANG_UNICODE) {

            hr = lber->HrGetValueWithAlloc(MatchedDNs);

        } else {

            hr = lber->HrGetValueWithAlloc((PCHAR *) MatchedDNs);
        }

        if (*MatchedDNs != NULL) {

            ldapSwapTags( *MatchedDNs, LDAP_VALUE_SIGNATURE, LDAP_BUFFER_SIGNATURE );
        }

    } else {

        hr = lber->HrSkipElement();
    }

    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "LdapParseResult couldn't decode matchedDN for conn 0x%x, result 0x%x.\n",
                            connection, hr);
        }
        return hr;
    }

    if (ErrorMessage != NULL) {

        if (codePage == LANG_UNICODE) {

            hr = lber->HrGetValueWithAlloc(ErrorMessage);

        } else {

            hr = lber->HrGetValueWithAlloc((PCHAR *) ErrorMessage);
        }

        if (*ErrorMessage != NULL) {

            ldapSwapTags( *ErrorMessage, LDAP_VALUE_SIGNATURE, LDAP_BUFFER_SIGNATURE );
        }
    } else {

        hr = lber->HrSkipElement();
    }

    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "LdapParseResult couldn't decode errorMsg for conn 0x%x, result 0x%x.\n",
                            connection, hr);
        }
        return hr;
    }

    hr = lber->HrPeekTag( &tag );

    if (tag == (BER_CLASS_CONTEXT_SPECIFIC | BER_FORM_CONSTRUCTED | 0x03)) {

        if (Referrals != NULL) {

            ULONG resultCount = 0;      // current offset in table
            ULONG sizeResultTable = 2;  // current size of result table

            hr = lber->HrStartReadSequence( tag );

            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "LdapParseResult couldn't decode referrals for conn 0x%x, result 0x%x.\n",
                                    connection, hr);
                }
                return hr;
            }

            if (codePage == LANG_UNICODE) {

                PWCHAR *resultWStr = NULL;

                while (hr == NOERROR) {

                    PWCHAR attrWValue = NULL;

                    if ((resultWStr == NULL) ||
                        (resultCount >= (sizeResultTable-1))) {      // leave room for null

                        if (sizeResultTable < 256) {    // only increase table size slowly
                            sizeResultTable *= 2;
                        } else {
                            sizeResultTable += 256;
                        }

                        PWCHAR *newResultTable = (PWCHAR *) ldapMalloc( sizeof(PWCHAR) * sizeResultTable,
                                                            LDAP_VALUE_LIST_SIGNATURE );

                        if (newResultTable == NULL) {

                            IF_DEBUG(OUTMEMORY) {
                                LdapPrint2( "LdapParseResult conn 0x%x could not allocate mem of 0x%x .\n",
                                                connection, sizeof(PWCHAR) * sizeResultTable);
                            }
                            hr = LDAP_NO_MEMORY;
                            continue;
                        }

                        if (resultWStr != NULL) {

                            CopyMemory( newResultTable, resultWStr, sizeof(PWCHAR) * resultCount );
                            ldapFree( resultWStr, LDAP_VALUE_LIST_SIGNATURE );
                        }
                        resultWStr = newResultTable;
                    }

                    hr = lber->HrGetValueWithAlloc( &attrWValue );
                    if (hr != NOERROR) {

                        //
                        //  This will fail when we hit the end of the attribute list
                        //

                        IF_DEBUG(TRACE1) {
                            LdapPrint2( "LdapParseResult conn 0x%x received error 0x%x .\n",
                                            connection, hr);
                        }
                        continue;       // rest of results may be valid
                    }

                    *(resultWStr+resultCount) = attrWValue;
                    resultCount++;
                }
                *(resultWStr+resultCount) = NULL;

                *Referrals = resultWStr;

            } else {

                PCHAR *resultStr = NULL;

                //
                //  get the list of attribute values in form of single byte strings
                //

                while (hr == NOERROR) {

                    PCHAR attrValue = NULL;

                    if ((resultStr == NULL) ||
                        (resultCount >= (sizeResultTable-1))) {      // leave room for null

                        if (sizeResultTable < 256) {    // only increase table size slowly
                            sizeResultTable *= 2;
                        } else {
                            sizeResultTable += 256;
                        }

                        PCHAR *newResultTable = (PCHAR *) ldapMalloc( sizeof(PCHAR) * sizeResultTable,
                                                            LDAP_VALUE_LIST_SIGNATURE );

                        if (newResultTable == NULL) {

                            IF_DEBUG(OUTMEMORY) {
                                LdapPrint2( "LdapParseResult conn 0x%x could not allocate mem of 0x%x .\n",
                                                connection, sizeof(PCHAR) * sizeResultTable);
                            }
                            hr = LDAP_NO_MEMORY;
                            continue;
                        }

                        if (resultStr != NULL) {

                            CopyMemory( newResultTable, resultStr, sizeof(PCHAR) * resultCount );
                            ldapFree( resultStr, LDAP_VALUE_LIST_SIGNATURE );
                        }
                        resultStr = newResultTable;
                    }

                    hr = lber->HrGetValueWithAlloc( &attrValue );
                    if (hr != NOERROR) {

                        //
                        //  This will fail when we hit the end of the attribute list
                        //

                        IF_DEBUG(TRACE1) {
                            LdapPrint2( "LdapParseResult conn 0x%x received error 0x%x .\n",
                                            connection, hr);
                        }
                        continue;       // rest of results may be valid
                    }

                    *(resultStr+resultCount) = attrValue;
                    resultCount++;
                }
                *(resultStr+resultCount) = NULL;

                *Referrals = (PWCHAR *)resultStr;
            }

            hr = lber->HrEndReadSequence();
            ASSERT( hr == NOERROR );

        } else {

            hr = lber->HrSkipElement();
        }

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "LdapParseResult couldn't decode referrals for conn 0x%x, result 0x%x.\n",
                                connection, hr);
            }
            return hr;
        }

    }

    if (ServerControls != NULL) {

        hr = lber->HrEndReadSequence();
        ASSERT( hr == NOERROR );

        hr = lber->HrPeekTag( &tag );

        if (tag == (BER_CLASS_CONTEXT_SPECIFIC | BER_FORM_CONSTRUCTED | 0x00)) {

            hr = lber->HrStartReadSequence(tag);
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "LdapParseResult couldn't decode controls for conn 0x%x, result 0x%x.\n",
                                    connection, hr);
                }
                return hr;
            }

            hr = LdapRetrieveControlsFromMessage( ServerControls, codePage, lber );

            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "LdapParseResult couldn't parse controls for conn 0x%x, result 0x%x.\n",
                                    connection, hr);
                }
                return hr;
            }
        }
    }

    if ( Freeit ) {

        //
        //  if there are more searchResultDone messages, don't free the
        //  list of messages.
        //

        checkResult = checkResult->lm_chain;

        while ((checkResult != NULL) &&
               ((checkResult->lm_msgtype == LDAP_RES_REFERRAL) ||
                (checkResult->lm_msgtype == LDAP_RES_SEARCH_ENTRY))) {

            checkResult = checkResult->lm_chain;
        }

        if (checkResult != NULL) {

            return LDAP_MORE_RESULTS_TO_RETURN;
        }

        ldap_msgfree( ResultMessage );
    }

    return LDAP_SUCCESS;
}

ULONG LdapParseExtendedResult (
        PLDAP_CONN      connection,
        LDAPMessage    *ResultMessage,
        PWCHAR         *ResultOID,
        struct berval **ResultData,
        BOOLEAN         Freeit,
        ULONG           codePage
        )
{
    ULONG      err;
    CLdapBer  *lber;
    ULONG    hr;
    ULONG      tag;

    if ( ResultOID != NULL ) {
      *ResultOID = NULL;
    }

    if ( ResultData != NULL ) {
      *ResultData = NULL;
    }

    if ( ResultMessage == (LDAPMessage *) -1 ) {
      ResultMessage = NULL;
    }

    LDAPMessage *checkResult = ResultMessage;

    if (checkResult == NULL) {

        IF_DEBUG(PARSE) {
            LdapPrint1( "LdapParseExtendedResult couldn't find result message for conn 0x%x\n",
                            connection);
        }
        return LDAP_NO_RESULTS_RETURNED;
    }

    lber = (CLdapBer *)checkResult->lm_ber;

    if (lber == NULL) {

        return LDAP_LOCAL_ERROR;
    }

    lber->Reset( FALSE );

    err = LdapInitialDecodeMessage( connection, checkResult );

    if (err != LDAP_SUCCESS) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "LdapParseResult couldn't decode message for conn 0x%x, result 0x%x.\n",
                            connection, err);
        }
        return err;
    }

    //
    //  LdapInitialDecodeMessage leaves the message parsed up to the error
    //  code.  we'll pick up the rest from there.
    //
    //      LDAPMessage ::= SEQUENCE {
    //              messageID       MessageID,
    //              protocolOp      CHOICE {...,ExtendedResponse,..  }
    //              controls       [0] Controls OPTIONAL }
    //
    //      ExtendedResponse ::= [APPLICATION 24] SEQUENCE {
    //              COMPONENTS OF LDAPResult,
    //              responseName     [10] LDAPOID OPTIONAL,
    //              response         [11] OCTET STRING OPTIONAL }
    //
    //      LDAPResult ::= SEQUENCE {
    //              resultCode      ENUMERATED { };
    //              matchedDN       LDAPDN,
    //              errorMessage    LDAPString,
    //              referral        [3] Referral OPTIONAL }

    // errorCode is consumed by LdapDecodeInitialMessage


    // skip MatchedDN
    hr = lber->HrSkipElement();
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "LdapParseExtendedResult couldn't decode matchedDN for conn 0x%x, result 0x%x.\n",
                            connection, hr);
        }
        return hr;
    }

    // skip ErrorMessage
    hr = lber->HrSkipElement();
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "LdapParseExtendedResult couldn't decode errorMsg for conn 0x%x, result 0x%x.\n",
                            connection, hr);
        }
        return hr;
    }

    // referrals are OPTIONAL
    hr = lber->HrPeekTag( &tag );

    if (tag == (BER_CLASS_CONTEXT_SPECIFIC | BER_FORM_CONSTRUCTED | 0x03)) {
       
        //
        // Referrals are present
        //

       hr = lber->HrSkipElement();
       if (hr != NOERROR) {

           IF_DEBUG(PARSE) {
               LdapPrint2( "LdapParseExtendedResult couldn't decode referrals for conn 0x%x, result 0x%x.\n",
                               connection, hr);
           }
           return hr;
       }
    } else if (tag == (BER_CLASS_CONTEXT_SPECIFIC | 0xA) ) {
        
        //
        // tag = 0x8A, this is the response name..
        // responseName [10] LDAPOID OPTIONAL found
        //

        if ( ResultOID ) {

           if (codePage == LANG_UNICODE) {

               hr = lber->HrGetValueWithAlloc( ResultOID, TRUE );

           } else {

               hr = lber->HrGetValueWithAlloc( ( PCHAR * )ResultOID, TRUE );
           }

        } else {
            
            hr = lber->HrSkipElement();
        }

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "LdapParseExtendedResult couldn't decode ResultOID for conn 0x%x, result 0x%x.\n",
                               connection, hr);
            }
            return hr;
        }


        //
        // look for response [11] OCTETSTRING OPTIONAL
        //

        hr = lber->HrPeekTag( &tag );

        if (tag == (BER_CLASS_CONTEXT_SPECIFIC | 0x0B)) {
            //
            // tag = 0x8B, we found the optional response [11[
            //
    
            if ( ResultData ) {
                hr = lber->HrGetValueWithAlloc( ResultData, TRUE );
            } else {
                hr = lber->HrSkipElement();
            }
               
            if (hr != NOERROR) {
                IF_DEBUG(PARSE) {
                    LdapPrint2( "LdapParseExtendedResult couldn't decode response data  for conn 0x%x, result 0x%x.\n",
                                connection, hr);
                }
                return hr;
            }
        }

    }

    if ( Freeit ) {
       ldap_msgfree( ResultMessage );
    }

    return LDAP_SUCCESS;
}

WINLDAPAPI ULONG LDAPAPI ldap_parse_resultW (
        LDAP *ExternalHandle,
        LDAPMessage *ResultMessage,
        ULONG *ReturnCode OPTIONAL,          // returned by server
        PWCHAR *MatchedDNs OPTIONAL,         // free with ldap_value_freeW
        PWCHAR *ErrorMessage OPTIONAL,       // free with ldap_memfreeW
        PWCHAR **Referrals OPTIONAL,         // free with ldap_memfreeW
        PLDAPControlW **ServerControls OPTIONAL,
        BOOLEAN Freeit
        )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapParseResult(      connection,
                                ResultMessage,
                                ReturnCode,
                                MatchedDNs,
                                ErrorMessage,
                                Referrals,
                                ServerControls,
                                Freeit,
                                LANG_UNICODE
                            );

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_parse_resultA (
        LDAP *ExternalHandle,
        LDAPMessage *ResultMessage,
        ULONG *ReturnCode OPTIONAL,         // returned by server
        PCHAR *MatchedDNs OPTIONAL,         // free with ldap_value_freeA
        PCHAR *ErrorMessage OPTIONAL,       // free with ldap_value_freeA
        PCHAR **Referrals OPTIONAL,         // free with ldap_value_freeA
        PLDAPControlA **ServerControls OPTIONAL,
        BOOLEAN Freeit
        )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapParseResult(      connection,
                                ResultMessage,
                                ReturnCode,
                                (PWCHAR *) MatchedDNs,
                                (PWCHAR *) ErrorMessage,
                                (PWCHAR **) Referrals,
                                (PLDAPControlW **) ServerControls,
                                Freeit,
                                LANG_ACP
                            );

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_parse_extended_resultW (
        LDAP           *ExternalHandle,
        LDAPMessage    *ResultMessage,
        PWCHAR         *ResultOID,
        struct berval **ResultData,
        BOOLEAN         Freeit
        )

{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapParseExtendedResult( connection,
                                   ResultMessage,
                                   ResultOID,
                                   ResultData,
                                   Freeit,
                                   LANG_UNICODE
                                 );

    DereferenceLdapConnection( connection );

    return err;
}


WINLDAPAPI ULONG LDAPAPI ldap_parse_extended_resultA (
        LDAP           *ExternalHandle,
        LDAPMessage    *ResultMessage,
        PCHAR          *ResultOID,
        struct berval **ResultData,
        BOOLEAN         Freeit
        )

{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapParseExtendedResult( connection,
                                   ResultMessage,
                                   (PWCHAR *)ResultOID,
                                   ResultData,
                                   Freeit,
                                   LANG_ACP
                                 );

    DereferenceLdapConnection( connection );

    return err;
}

// parse.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\receive.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    receive.c    receive data from an LDAP server

Abstract:

   This module handles incoming data from an LDAP server

Author:

    Andy Herron (andyhe)        01-Jun-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

//
//  Not exactly thrilled with this, but users want an arbitrary number of
//  connections, and not limited by FD_SETSIZE.  We'll play with it here so
//  that all the macros still 'just work'.
//

fd_set *WinsockSelectReadSet = NULL;
ULONG Real_FD_SETSIZE = FD_SETSIZE;

#define CONSECUTIVE_PING_LIMIT   8

#if DBG
    #define INTJECTSERVERDOWNS  120
//  ULONG InjectServerDowns = INTJECTSERVERDOWNS;
    ULONG InjectServerDowns = 0;

VOID
LdapSpewSearchResults (
    PLDAP_REQUEST request,
    PLDAP_CONN resultConn,
    ULONG msgid,
    LDAPMessage * result
    );

#endif

#undef FD_SETSIZE

ULONG FD_SETSIZE = 0;

PLDAP_CONN
LdapAllBuffersToMessages (
    PLDAP_CONN Connection,
    ULONG AllOfMessage
    );

ULONG
LdapBuffersToMessages (
    PLDAP_CONN Connection,
    ULONG AllOfMessage
    );

ULONG
DrainWinsock (
    ULONG milliseconds
    );

ULONG __cdecl
ldap_result (
    LDAP            *ExternalHandle,
    ULONG           msgid,
    ULONG           AllOfMessage,
    struct l_timeval  *TimeOut,
    LDAPMessage     **res
    )
{
    PLDAP_CONN connection = NULL;
    ULONG err;
    PLDAPMessage lastMessage = NULL;

    if (res == NULL) {

        return (ULONG) -1;
    }

    *res = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL && ExternalHandle != NULL) {

        return (ULONG) -1;
    }

    err = ldap_result_with_error( connection,
                                  msgid,
                                  AllOfMessage,
                                  TimeOut,
                                  res,
                                  &lastMessage );

    if (err == LDAP_SUCCESS) {

        if (lastMessage == NULL) {

            lastMessage = *res;
        }

        //
        //  return the result from a non-search entry record, rather than just
        //  the first entry in the list.  This is because the server's
        //  return code is stored in the last entry.
        //

        if (lastMessage != NULL) {

            err = lastMessage->lm_msgtype;

        } else {

            err = (ULONG) -1;
            SetConnectionError( connection, LDAP_TIMEOUT, NULL );
        }
    } else {

        SetConnectionError( connection, err, NULL );

        if (err == LDAP_TIMEOUT) {

            err = 0;

        } else {

            err = (ULONG) -1;
        }
    }

    if (connection != NULL) {

       DereferenceLdapConnection( connection );
    }

    return err;
}

ULONG
ldap_result_with_error (
    PLDAP_CONN      Connection,
    ULONG           msgid,
    ULONG           AllOfMessage,
    struct l_timeval  *TimeOut,
    LDAPMessage     **res,
    LDAPMessage     **LastMessage
    )
//
//  This is the same as ldap_result except that we don't return the message
//  type... we return the result code of the wait.  This will be very useful.
//
{
    ULONG err;
    PLDAP_CONN dereferenceConnection = NULL;
    ULONG timeout;
    LDAPMessage *result = NULL;
    PLDAP_REQUEST request = NULL;
    ULONG all = LDAP_MSG_ALL;

    if (res == NULL) {

        return LDAP_PARAM_ERROR;
    }

    *res = NULL;

    if (LastMessage != NULL) {

        *LastMessage = NULL;
    }

    if ((AllOfMessage == LDAP_MSG_ONE) ||
        (AllOfMessage == LDAP_MSG_ALL) ||
        (AllOfMessage == LDAP_MSG_RECEIVED)) {

        all = AllOfMessage;
    }

    if ((Connection != NULL) && (msgid != (ULONG)LDAP_RES_ANY)) {

        PLDAP_REQUEST MatchingRequest = FindLdapRequest( msgid );

        if (MatchingRequest &&
            MatchingRequest->PageRequest &&
            MatchingRequest->SecondaryConnection) {

            IF_DEBUG(CONTROLS) {
                LdapPrint2("Getting data for conn 0x%x instead of 0x%x\n",MatchingRequest->SecondaryConnection, Connection );
            }
            Connection = MatchingRequest->SecondaryConnection;
        }

        if (MatchingRequest) {

            //
            // We don't really need this request. So, deref it
            //

            DereferenceLdapRequest( MatchingRequest );
        }
    }

    if (TimeOut == NULL) {

        timeout = WSA_INFINITE;

    } else {

        if ((TimeOut->tv_sec == 0) &&
            (TimeOut->tv_usec == 0)) {

            timeout = 0;

        } else {

            //
            //  convert to milliseconds.
            //

            timeout = (TimeOut->tv_sec * 1000) + (TimeOut->tv_usec / 1000);
        }
    }

    if (msgid == (ULONG) -1) {

        msgid = 0;
    }

    request = FindLdapRequest( (LONG) msgid );

    if ((msgid != 0) &&
        (request == NULL)) {

        SetConnectionError( Connection, LDAP_PARAM_ERROR, NULL );

        IF_DEBUG(RECEIVEDATA) {
            LdapPrint1( "ldap_result couldn't find request for msgid 0x%x\n", msgid );
        }
        return LDAP_PARAM_ERROR;
    }

GotReferral:

    err = LdapWaitForResponseFromServer(    Connection,
                                            request,
                                            timeout,
                                            all,
                                            &result,
                                            FALSE    // reconnect if necessary.
                                            );

    if (result != NULL) {

        LDAPMessage *lastResult = NULL;
        LDAPMessage *checkResult = NULL;
        PLDAP_CONN resultConn = Connection;

        if (resultConn == NULL) {

            resultConn = GetConnectionPointer(result->Connection);
            dereferenceConnection = resultConn;
        }

        //
        // Note that resultConn could be NULL at this point if we couldn't
        // reference it
        //
        if (resultConn == NULL) {

            LdapPrint1( "resultConn NULL because connection handle 0x%x was unbound\n",
                        result->Connection);
        }

        if (request == NULL) {

            request = FindLdapRequest( result->lm_msgid );
        }

        IF_DEBUG(RECEIVEDATA) {
            LdapPrint3( "ldap_result found results at 0x%x for request 0x%x msgid 0x%x\n",
                        result, request, msgid );
        }

        //
        //  check if we need to chase any referrals
        //

        if ((request != NULL) && (request->ChaseReferrals != 0) && (resultConn != NULL)) {

            ULONG referralError;

            referralError = HandleReferrals( resultConn,
                                             &result,
                                             request );

            if ((referralError == LDAP_SUCCESS) ||
                ( result == NULL )) {

                IF_DEBUG(REFERRALS) {
                    LdapPrint1( "ldap_result chasing referral for msg 0x%x\n", request );
                }

                if (msgid == 0) {

                    DereferenceLdapRequest( request );
                    request = NULL;
                }
                ASSERT( result == NULL );
                goto GotReferral;
            }
        }

        //
        //  find the last message in the list if required.  There's two reasons
        //  why it might be required : if the caller needs to handle it (so we
        //  only traverse the list once) and to check to see if we need to
        //  close the request.
        //

        if ((LastMessage != NULL) || (request != NULL)) {

            checkResult = result;
            LDAPMessage *lastMessage = NULL;

            while (checkResult != NULL) {

                if ((checkResult->lm_msgtype != LDAP_RES_SEARCH_ENTRY) &&
                    (checkResult->lm_msgtype != LDAP_RES_REFERRAL)){

                    lastResult = checkResult;

                    if (lastResult->lm_eom) {

                        IF_DEBUG(EOM) {
                            LdapPrint2( "ldap_result found EOM marker for req 0x%x, msg 0x%x\n",
                                        request, lastResult );
                        }
                        break;
                    }
                }
                lastMessage = checkResult;
                checkResult = checkResult->lm_chain;
            }

            if (lastResult == NULL) {

                lastResult = lastMessage;
            }

            if (LastMessage != NULL) {

                *LastMessage = lastResult;
            }
        }

        ASSERT( lastResult != NULL );

#if DBG
        IF_DEBUG(SPEWSEARCH) {
            LdapSpewSearchResults( request, resultConn, msgid, result );
        }
#endif

        //
        //  since we're returning results, free the ber structure from the
        //  request so that we don't duplicate results during reconnect.
        //
        //  If this is a notifications result, don't free the BER buffer
        //  because we will need it during autoresends.
        //

        if ((request != NULL) &&
            (request->NotificationSearch == FALSE) ) {

            CLdapBer *lber;

            lber = (CLdapBer *) InterlockedExchangePointer(  &request->BerMessageSent,
                                                             NULL );
            if (lber != NULL) {
                delete lber;
            }
        }

        //
        //  if the request needs to be closed, do so now.
        //

        if ((lastResult != NULL) &&
             (lastResult->lm_eom == TRUE) &&
             (request != NULL)) {

            IF_DEBUG(EOM) {
                LdapPrint2( "ldap_result checking to close req 0x%x, msg 0x%x\n",
                            request, lastResult );
            }

            ACQUIRE_LOCK( &request->Lock );

            if ((request->ResponsesOutstanding == 0) &&
                (request->MessageLinkedList == NULL)) {

                IF_DEBUG(REQUEST) {
                     LdapPrint2( "ldap_result closing request 0x%x for msg 0x%x\n",
                                 request, request->MessageId );
                } else {

                    IF_DEBUG(EOM) {
                         LdapPrint2( "ldap_result closing request 0x%x for msg 0x%x\n",
                                     request, request->MessageId );
                    }
                }

                RELEASE_LOCK( &request->Lock );

                CloseLdapRequest( request );

            } else {

                IF_DEBUG(EOM) {
                    LdapPrint1( "ldap_result responses outstanding for req 0x%x\n",
                                request );
                }

                RELEASE_LOCK( &request->Lock );
            }

            START_LOGGING;
            DSLOG((DSLOG_FLAG_TAG_CNPN,"[+]"));
            DSLOG((0,"[ID=%d][ET=%I64d][RC=%d][ER=%d][-]\n",
                   request->MessageId,LdapGetTickCount(),request->ReferralCount,
                   ldap_result2error(Connection->ExternalInfo,result,FALSE)));
            END_LOGGING;
        }

        SetConnectionError( resultConn, LDAP_SUCCESS, NULL );

        err = LDAP_SUCCESS;

        *res = result;

    } else {

        ASSERT(err != NOERROR);

        *res = NULL;

        IF_DEBUG(CONNECTION) {
            LdapPrint2( "ldap_result conn 0x%x failed with 0x%x.\n", Connection, err);
        }

        if (err == LDAP_SERVER_DOWN) {

            //
            //  if we chased a referral and the server went down, return
            //  an error of 'unavailable'... why not?
            //

            if ((Connection != NULL) &&
                (Connection->ServerDown == FALSE)) {

                err = LDAP_UNAVAILABLE;
            }

            SetConnectionError( Connection, err, NULL );
        }
    }

    if (request != NULL) {

        DereferenceLdapRequest( request );
    }

    if ((*res != NULL) && (Connection != NULL)) {

      //
      // We need to get the error string returned by the server and
      // store it.
      //

      PWCHAR ErrorMessage = NULL;

      LdapParseResult(Connection,
                      *res,
                      0,                   // return code
                      NULL,                // Matched DNs
                      &ErrorMessage,       // Server returned err msg
                      NULL,                // No need for referrals
                      NULL,                // or controls
                      FALSE,               // and don't free the message
                      LANG_UNICODE
                      );


      InsertErrorMessage( Connection, ErrorMessage );
    }

    if (dereferenceConnection != NULL) {

        DereferenceLdapConnection( dereferenceConnection );
    }

   return err;
}

#if DBG
VOID
LdapSpewSearchResults (
    PLDAP_REQUEST request,
    PLDAP_CONN resultConn,
    ULONG msgid,
    LDAPMessage *result
    )
{
    ACQUIRE_LOCK( &ConnectionListLock );
    if (request == NULL) {

        LdapPrint1( "\nLDAPSPEW no request for message %u\n", msgid );

    } else {

        LdapPrint3( "\nLDAPSPEW request %u is an %x operation for %S\n",
                request->MessageId,
                request->Operation,
                request->OriginalDN );

        LdapPrint3( "\nLDAPSPEW from server %s, explicit %s, port %u\n",
                resultConn->ListOfHosts,
                resultConn->ExplicitHostName,
                resultConn->PortNumber );

        if (request->Operation == LDAP_SEARCH_CMD) {

            LdapPrint2( "\tLDAPSPEW scope is %u, filter is %S\n",
                request->search.ScopeOfSearch, request->search.SearchFilter );
#if 1
            PWCHAR *attrList = request->search.AttributeList;
            if (attrList == NULL) {

                LdapPrint0( "\tLDAPSPEW requesting all attributes.\n" );

            } else {

                LdapPrint0( "\tLDAPSPEW requesting attributes :\n" );

                while (*attrList != NULL) {

                    LdapPrint1( "\t\t%S\n", *attrList );
                    attrList++;
                }
            }
#endif
        }
    }

    PLDAPMessage    temp = result;

    LdapPrint1( "\nLDAPSPEW results for %u are : \n", msgid );

    while (temp != NULL) {

        if (temp->lm_msgtype != LDAP_RES_SEARCH_ENTRY) {

            LdapPrint1( "\tMessage type received is 0x%x\n", temp->lm_msgtype );

        } else {

            PWCHAR dn = NULL;
            PWCHAR attribute;
            BerElement *opaque;

            dn = ldap_get_dnW( resultConn->ExternalInfo, temp );

            LdapPrint1( "\tDN is : %S\n", dn );

            ldap_memfree( (PCHAR) dn );
#if 1
            attribute = ldap_first_attributeW( resultConn->ExternalInfo,
                                              temp,
                                              &opaque
                                              );
            while (attribute != NULL) {

                PWCHAR *value = NULL;
                ULONG total;

                value = ldap_get_valuesW(   resultConn->ExternalInfo,
                                            temp,
                                            attribute
                                            );

                total = ldap_count_valuesW(value);
                if (total > 1) {

                    ULONG count;

                    LdapPrint1( "\tAttribute %S is :\n", attribute );

                    for (count = 0; count < total; count++ ) {
                        LdapPrint1( "\t\t%S\n", value[count] );
                    }

                } else if (total == 1) {

                    LdapPrint2( "\tAttribute %S is %S\n", attribute, *value );

                } else {

                    LdapPrint1( "\tAttribute %S has no value\n", attribute );
                }

                ldap_value_freeW( value );

                attribute = ldap_next_attributeW( resultConn->ExternalInfo,
                                                  temp,
                                                  opaque
                                                  );
            }
#endif
        }
        temp = temp->lm_chain;
    }

    RELEASE_LOCK( &ConnectionListLock );
    return;
}
#endif

LONG GlobalWaitersCount = 0;

ULONG
LdapWaitForResponseFromServer (
    IN PLDAP_CONN Connection,
    IN PLDAP_REQUEST Request,
    IN ULONG Timeout,
    IN ULONG AllOfMessage,
    OUT PLDAPMessage *Result,
    IN BOOLEAN DisableReconnect
    )
//
//  Wait for a response from the server for a given messageid and return the
//  message.
//
//  Timeout value is in milliseconds.
//
{
    PLDAP_MESSAGEWAIT msgWait = NULL;
    ULONG err = LDAP_SUCCESS;
    ULONG messageNumber;
    BOOLEAN haveLock = FALSE;
    ULONG waitErr;
    ULONGLONG startingTime = LdapGetTickCount();
    ULONGLONG currentTime;
    ULONG waitTime;
    BOOLEAN cldap = FALSE;
    ULONG cldapRetries = 0;
    PLDAP_CONN reconnectConnection = NULL;

    if (Result != NULL) {
        *Result = NULL;
    }

    ULONG checkMessage =  (AllOfMessage == LDAP_MSG_RECEIVED) ?
                            LDAP_MSG_ALL : AllOfMessage;

    messageNumber = (Request != NULL) ? Request->MessageId : 0;

    //
    //  Check to see if we already have a message waiting
    //

TryAgain:

    if (Result != NULL) {

        if ((Request != NULL) && (Request->ResultsAreCached)) {

            ACQUIRE_LOCK( &ConnectionListLock );

            err = LdapBuffersToMessages( Connection, AllOfMessage );

            RELEASE_LOCK( &ConnectionListLock );

            if (err != LDAP_SUCCESS) {

                IF_DEBUG(CACHE) {
                    LdapPrint1("LdapBuffersToMessages returned err 0x%x\n", err);
                }
                return err;
            }
        }

        err = LdapGetResponseFromServer( Connection,
                                         Request,
                                         checkMessage,
                                         Result );

        if (*Result != NULL) {

            //
            //  we have a message from the server waiting for us.
            //

            ASSERT( err == LDAP_SUCCESS );
            goto exitWaitForMessage;
        }

        if ((Request != NULL) &&
            (Connection != NULL) &&
            (Connection->UdpHandle != INVALID_SOCKET)) {

            cldap = TRUE;

            if (( Timeout == WSA_INFINITE ) ||
                ( Timeout == 0 )) {

                //
                //  convert seconds to milliseconds.
                //

                Timeout = Connection->publicLdapStruct.ld_cldaptimeout * 1000;
            }
        }
    }

    //
    //  allocate a wait structure to wait for the reply
    //

    msgWait = LdapGetMessageWaitStructure(  Connection,
                                            AllOfMessage,
                                            messageNumber,
                                            ((Result == NULL) ? TRUE : FALSE) );

    //
    //  We may have gotten a message after we last checked but before we
    //  allocated the structure.  We'll check one more time.
    //

    if (Result != NULL) {
        err = LdapGetResponseFromServer( Connection,
                                         Request,
                                         checkMessage,
                                         Result );

        if (*Result != NULL) {

            //
            //  we have a message from the server waiting for us.
            //

            ASSERT( err == LDAP_SUCCESS );
            goto exitWaitForMessage;
        }
    }

    //
    // Make sure we indeed have outstanding requests before we try to pull data
    // or go off to sleep waiting for someone else to do the job for us.
    //

    if (GlobalCountOfOpenRequests == 0) {
        if (Result != NULL) {

            // check one more time --- another thread may have come by and processed
            // our request (dropping GlobalCountOfOpenRequests to 0), so we need
            // to check for the data now being available

            
            err = LdapGetResponseFromServer( Connection,
                                             Request,
                                             checkMessage,
                                             Result );

            if (*Result != NULL) {

                //
                //  we have a message from the server waiting for us.
                //
                ASSERT( err == LDAP_SUCCESS );
                goto exitWaitForMessage;
            }
        }

        err = LDAP_PARAM_ERROR;
        SetConnectionError( Connection, err, NULL );
        goto exitWaitForMessage;
    }

    //
    //  otherwise, check to make sure we have a structure to wait on.
    //

    if (msgWait == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldapGetMsg connection 0x%x failed wait allocation.\n", Connection);
        }

        err = LDAP_NO_MEMORY;
        SetConnectionError( Connection, err, NULL );
        goto exitWaitForMessage;
    }

TryReceiveAgain:

    //
    //  The messageWaitStructure starts out reset, we only reset it and set
    //  it to not satisfied right before we go check to see if there's a message.
    //  We then check it again before we exit to see if we should wake up
    //  another waiter since we're happily exiting.
    //

    if (haveLock == FALSE) {
        ACQUIRE_LOCK( &ConnectionListLock );
        haveLock = TRUE;
    }

    if ((Connection != NULL) &&
        (Connection->ConnObjectState != ConnObjectActive)) {

        err = LDAP_PARAM_ERROR;
        SetConnectionError( Connection, err, NULL );
        goto exitWaitForMessage;
    }

    if ((Request != NULL) &&
        ((Request->Closed == TRUE) ||
         (Request->Abandoned == TRUE ))) {

        err = (Request->Closed ? LDAP_PARAM_ERROR : LDAP_USER_CANCELLED);
        SetConnectionError( Connection, err, NULL );
        goto exitWaitForMessage;
    }

    if (GlobalReceiveHandlerThread != NULL) {

        //
        //  Some other thread is handling receives... we just sit and wait.
        //

        // NOTE: This code also appears below. Please maintain them
        // in unison.

        InterlockedIncrement( &GlobalWaitersCount );

        //
        // We want to be visible only if this thread is allowed to reconnect
        //

        if ( Connection  && !DisableReconnect ) {

            InterlockedIncrement( &Connection->WaiterCount );
        }

        RELEASE_LOCK( &ConnectionListLock );
        haveLock = FALSE;

        if ((Timeout != 0) && (Timeout != (ULONG) -1)) {

            waitTime = Timeout - (DWORD)(LdapGetTickCount() - startingTime);

        } else {

            waitTime = Timeout;
        }

        IF_DEBUG(RECEIVEDATA) {
            LdapPrint1( "LdapWaitForResponseFromServer waiting for request 0x%x.\n",
                        Request );
        }

        waitErr = WaitForSingleObjectEx( msgWait->Event,
                                         waitTime,
                                         FALSE );


        InterlockedDecrement( &GlobalWaitersCount );

        if ( Connection  && !DisableReconnect ) {

            InterlockedDecrement( &Connection->WaiterCount );
        }

        if (waitErr == (ULONG) -1) {

            waitErr = GetLastError();
        }

    } else {

        //
        // There is a small timing window where another thread might have
        // collected results for us. So, we should check for messages before
        // we go any further. Otherwise, there is a possibility that we might
        // block for 2 mins inside DrainWinsock().
        //


        if (Result != NULL) {

            haveLock = FALSE;
            RELEASE_LOCK( &ConnectionListLock );
            err = LdapGetResponseFromServer( Connection,
                                             Request,
                                             checkMessage,
                                             Result );
            haveLock = TRUE;
            ACQUIRE_LOCK( &ConnectionListLock );
            if (*Result != NULL) {

                //
                //  we have a message from the server waiting for us.
                //

                ASSERT( err == LDAP_SUCCESS );
                goto exitWaitForMessage;
            }
        }

        //
        //  We're now probably the thread that will process data.  Be careful here,
        //  as we can't leave this routine without ensuring that either
        //  another thread has taken over OR no threads are waiting.
        //
        //  Note that since we released and reacquired ConnectionListLock around the
        //  previous LdapGetResponseFromServer call, there is a small window during which
        //  another thread could have become the GlobalReceiveHandlerThread.  So now
        //  that we're back inside ConnectionListLock, we need to recheck
        //  GlobalReceiveHandlerThread and if some other thread is the receive handler,
        //  just wait on it to receive the data.

        if ( !Connection ||
             (Connection  &&
              Connection->HostConnectState == HostConnectStateConnected) ) {

                if (GlobalReceiveHandlerThread == NULL) {
                    GlobalReceiveHandlerThread = GetCurrentThreadId();
                }
                else {
                    //
                    //  Some other thread is handling receives... we just sit and wait.
                    //

                    // NOTE: This code also appears above. Please maintain them
                    // in unison.

                    InterlockedIncrement( &GlobalWaitersCount );

                    //
                    // We want to be visible only if this thread is allowed to reconnect
                    //

                    if ( Connection  && !DisableReconnect ) {

                        InterlockedIncrement( &Connection->WaiterCount );
                    }

                    RELEASE_LOCK( &ConnectionListLock );
                    haveLock = FALSE;

                    if ((Timeout != 0) && (Timeout != (ULONG) -1)) {

                        waitTime = Timeout - (DWORD)(LdapGetTickCount() - startingTime);

                    } else {

                        waitTime = Timeout;
                    }

                    IF_DEBUG(RECEIVEDATA) {
                        LdapPrint1( "LdapWaitForResponseFromServer waiting for request 0x%x.\n",
                                    Request );
                    }

                    waitErr = WaitForSingleObjectEx( msgWait->Event,
                                                     waitTime,
                                                     FALSE );


                    InterlockedDecrement( &GlobalWaitersCount );

                    if ( Connection  && !DisableReconnect ) {

                        InterlockedDecrement( &Connection->WaiterCount );
                    }

                    if (waitErr == (ULONG) -1) {

                        waitErr = GetLastError();
                    }

                    goto doneReceive;
                }
        
                haveLock = FALSE;
                RELEASE_LOCK( &ConnectionListLock );
        
                //
                //  wait for the response to come back from the server
                //
        
                if ((Timeout != 0) && (Timeout != (ULONG) -1)) {
        
                    waitTime = Timeout - (DWORD)(LdapGetTickCount() - startingTime);
        
                } else {
        
                    waitTime = Timeout;
                }
        
                //
                //  when we drain winsock, if it returns with no error, we keep draining
                //  so that we get all data before returning entries.
                //
        
                waitErr = 0;
        
                if (waitTime == (ULONG) -1) {
        
                    //
                    //  They specified an infinite amount of time, let's not
                    //  wait that long.
                    //
        
                    waitErr = DrainWinsock( waitTime );
        
                    while (waitErr == 0) {
        
                        waitErr = DrainWinsock( 0 );
                    }
        
                    if (waitErr == WSAENOBUFS) {
        
                        //
                        // Catastrophic error in DrainWinsock()
                        //
        
                        LdapPrint1("Drainwinsock failed with error 0x%x\n", waitErr);
                        SetConnectionError( Connection, waitErr, NULL );
                        err = LDAP_NO_MEMORY;
                        
                        //
                        // Reset GlobalReceiveHandlerThread before exiting.
                        //

                        ACQUIRE_LOCK(&ConnectionListLock);
                        GlobalReceiveHandlerThread = NULL;
                        RELEASE_LOCK(&ConnectionListLock);
                        
                        goto exitWaitForMessage;
                    }
        
                } else {
        
                    ULONG successfulReceives = 0;
        
                    //
                    //  We drain winsock at least once (for small timeout values) but
                    //  if we're getting completely hosed with data from the server,
                    //  we don't ignore the timeout value passed in from the app.
                    //
        
                    while (waitErr == 0) {
        
                        waitErr = DrainWinsock( 0 );
        
                        if (waitErr == 0) {
                            successfulReceives++;
                        }
        
                        if ((Timeout != 0) &&
                            (Timeout <= (LdapGetTickCount() - startingTime))) {
        
                            break;
                        }
                    }
        
                    if ((waitErr == WSA_WAIT_TIMEOUT) &&
                        (waitTime != 0) &&
                        (successfulReceives == 0)) {
        
                        waitErr = DrainWinsock( waitTime );
        
                        while (waitErr == 0) {
        
                            waitErr = DrainWinsock( 0 );
                        }
                    }
        
                    if (waitErr == WSAENOBUFS) {
        
                        //
                        // Catastrophic error in DrainWinsock()
                        //
        
                        LdapPrint1("Drainwinsock failed with error 0x%x\n", waitErr);
                        SetConnectionError( Connection, waitErr, NULL );
                        err = LDAP_NO_MEMORY;
                        
                        //
                        // Reset GlobalReceiveHandlerThread before exiting.
                        //

                        ACQUIRE_LOCK(&ConnectionListLock);
                        GlobalReceiveHandlerThread = NULL;
                        RELEASE_LOCK(&ConnectionListLock);
                        goto exitWaitForMessage;
                    }
                }
        
                IF_DEBUG(TRACE1) {
                    LdapPrint1( "LdapWaitForResponseFromServer DrainWinsock returned 0x%x.\n",
                                waitErr );
                }
        
                //
                //  We just tried to receive data... convert the buffers to messages.
                //
                //  This function references the connection
                //
                reconnectConnection = LdapAllBuffersToMessages( Connection, AllOfMessage );

            
        } else if (!DisableReconnect) {
            
            haveLock = FALSE;
            RELEASE_LOCK( &ConnectionListLock );
    
            //
            // the connection is not properly connected. Try to reconnect.
            //
    
            err = LdapConnect( Connection, NULL, FALSE );
            
            if (err == LDAP_SUCCESS) {
    
                goto TryReceiveAgain;
    
            } else {
    
                goto exitWaitForMessage;
            }
        
        } else {

            //
            // We must not attempt to reconnect as we might actually be blocked
            // on a send or waiting for a bind response.
            //

            err = LDAP_SERVER_DOWN;
            ASSERT( GlobalReceiveHandlerThread == NULL );
            goto exitWaitForMessage;
        }

        //
        //  now we allow other threads to handle the message pump... then we
        //  try to auto-reconnect only if our connection needs it or if there
        //  are threads currently waiting on this connection.
        //

        ACQUIRE_LOCK(&ConnectionListLock);
        GlobalReceiveHandlerThread = NULL;
        RELEASE_LOCK(&ConnectionListLock);        

        if (( !DisableReconnect ) &&
            ( reconnectConnection != NULL ) &&
            (( reconnectConnection == Connection ) ||
             ( reconnectConnection->WaiterCount > 0 ))) {

            ACQUIRE_LOCK( &reconnectConnection->ReconnectLock );

            if ((reconnectConnection->HostConnectState == HostConnectStateError) &&
                (reconnectConnection->AutoReconnect == TRUE)) {

                ACQUIRE_LOCK( &reconnectConnection->StateLock );

                reconnectConnection->HostConnectState = HostConnectStateReconnecting;

                RELEASE_LOCK( &reconnectConnection->StateLock );

                err = LdapAutoReconnect( reconnectConnection );

                IF_DEBUG(NETWORK_ERRORS) {
                    LdapPrint2( "LdapWaitForResponseFromServer: reconnect returned 0x%x for 0x%x\n",
                                err, reconnectConnection );
                }
            }

            RELEASE_LOCK( &reconnectConnection->ReconnectLock );
        }

        if ( reconnectConnection != NULL ) {
            DereferenceLdapConnection( reconnectConnection );
        }
    }

doneReceive:

    //
    //  Now that we've either processed all the packets or we've been woken
    //  up, check to see if we have any messages.
    //

    if ((Result != NULL) && (msgWait->Satisfied == TRUE)) {

        //
        //  We reset the event BEFORE we call off to get the response,
        //  otherwise we could not wakeup if the response comes in between
        //  the time we check and the time we reset the event.
        //

        ResetEvent( msgWait->Event );
        msgWait->Satisfied = FALSE;     // mark that we're not active

        err = LdapGetResponseFromServer(    Connection,
                                            Request,
                                            AllOfMessage,
                                            Result );
    }

    if ((Result != NULL) && (*Result == NULL)) {

        //
        //  hmmm... what did we wake up for if there was no message for us.
        //  let's go try again.
        //

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint1( "LdapWaitForResponseFromServer: no message found for 0x%x. retrying!\n",
                                Connection );
        }

        if ((Connection != NULL) &&
            (Connection->ServerDown == TRUE)) {

            if (Connection->AutoReconnect == FALSE) {

                IF_DEBUG(SERVERDOWN) {
                    LdapPrint2( "ldapWaitForResponse thread 0x%x has connection 0x%x as down.\n",
                                    GetCurrentThreadId(),
                                    Connection );
                }
                err = LDAP_SERVER_DOWN;

            } else {

                err = LDAP_UNAVAILABLE;
            }

        } else if ((GlobalLdapShuttingDown == TRUE) ||
                   ((Connection != NULL) &&
                    (Connection->ConnObjectState != ConnObjectActive))) {

            err = LDAP_USER_CANCELLED;

        } else if ( GlobalCountOfOpenRequests == 0 ) {

            //
            //  now this is interesting... we've run out of things to wait
            //  for.  Either the request was abandoned or all the servers
            //  have gone down.
            //

            //
            //  since we were off chasing referrals or something, return
            //  what we have so far maybe.
            //

            if (AllOfMessage != LDAP_MSG_RECEIVED) {
                err = LdapGetResponseFromServer( Connection,
                                                 Request,
                                                 checkMessage,
                                                 Result );

                if (*Result != NULL) {

                    //
                    //  we have a message from the server waiting for us.
                    //
                    ASSERT( err == LDAP_SUCCESS );
                    goto exitWaitForMessage;
                }
            }

            if (AllOfMessage == LDAP_MSG_RECEIVED) {

                (VOID)LdapGetResponseFromServer(    Connection,
                                                    Request,
                                                    AllOfMessage,
                                                    Result );
            }

            if (Request != NULL && Request->Abandoned) {

                err = LDAP_USER_CANCELLED;

            } else {

                //
                //  we should return timeout, nothing else.
                //

                err = LDAP_TIMEOUT;
            }

        } else {

            //
            //  check to see if we've exceeded the time limit
            //

            currentTime = LdapGetTickCount();

            if ((Timeout != 0) &&
                ((Timeout == (ULONG) -1) ||
                 (currentTime - startingTime < Timeout))) {

                goto TryReceiveAgain;
            }

            //
            //  If this is a CLDAP request, send the request again, as the
            //  server may have not received it or we may have missed it.
            //

            if ((cldap == TRUE) &&
                (cldapRetries++ <= Connection->publicLdapStruct.ld_cldaptries)) {

                if (haveLock) {
                    RELEASE_LOCK( &ConnectionListLock );
                    haveLock = FALSE;
                }

                ACQUIRE_LOCK( &Request->Lock );

                if (Request->Abandoned == FALSE ) {

                   RELEASE_LOCK( &Request->Lock );

                   ULONG hr = LdapSendCommand(  Connection,
                                                   Request,
                                                   0 );

                    //
                    //  If we successfully sent the packet off, let's go back
                    //  up to the top to wait for the packet again.
                    //

                    if (hr == LDAP_SUCCESS) {

                        IF_DEBUG(CLDAP) {
                            LdapPrint1( "LdapWaitForResponseFromServer rewaiting for connection 0x%x\n",
                                        Connection );
                        }

                        //
                        //  Reset timer
                        //

                        startingTime = LdapGetTickCount();
                        goto TryReceiveAgain;
                    }

                    IF_DEBUG(NETWORK_ERRORS) {
                        LdapPrint2( "LdapWaitForResponseFromServer connection 0x%x send with error of 0x%x.\n",
                                    Connection, hr );
                    }
                } else {

                    RELEASE_LOCK( &Request->Lock );
                }

            }

            //
            //  go check one more time for responses.  It could be that we
            //  haven't received the end of message yet, in which case we
            //  wouldn't have had our wait satisfied.
            //

            if (AllOfMessage != LDAP_MSG_ALL) {

                err = LdapGetResponseFromServer(    Connection,
                                                    Request,
                                                    AllOfMessage,
                                                    Result );

                if (*Result == NULL) {

                    err = LDAP_TIMEOUT;
                }
            } else {

                err = LDAP_TIMEOUT;
            }
        }

        SetConnectionError( Connection, err, NULL );

    } else {

        //
        // We can't assume that (err==LDAP_SUCCESS) here because
        // LdapAutoReconnect can fail with LDAP_SERVER_DOWN when the caller
        // doesn't want a LdapMessage (Result == NULL). Since this is mainly
        // called internally (in LdapSendRaw, etc.), we  should reset the
        // error to success so that the error is picked up in the receive
        // path.
        //

        err = LDAP_SUCCESS;
    }

exitWaitForMessage:

    if (msgWait != NULL) {

        if (haveLock == FALSE) {

            ACQUIRE_LOCK( &ConnectionListLock );    // need it within next call
            haveLock = TRUE;
        }

        //
        //  if our wait should be satified, then we need to wake somebody else
        //  up because we're exiting and maybe haven't pulled off the message.
        //

        if (msgWait->Satisfied) {

            CheckForWaiters( msgWait->MessageNumber, FALSE, NULL );
        }

        LdapFreeMessageWaitStructure( msgWait );
        msgWait = NULL;
    }

    //
    //  If we're running in Win9x with Winsock1.1, and there's no thread
    //  currently calling select and there are threads waiting on wait events,
    //  then we satisfy one of the waits so that they will pick up waiting
    //  with select rather than a wait structure.  This is so packets will
    //  actually get received rather than every thread just waiting for hell
    //  to freeze over.
    //

    if ((GlobalReceiveHandlerThread == NULL) &&
        (GlobalWaitersCount > 0)) {

        if (haveLock == FALSE) {

            ACQUIRE_LOCK( &ConnectionListLock );
            haveLock = TRUE;
        }

        //
        //  recheck since GlobalReceiveHandlerThread is protected by the lock.
        //

        if ((GlobalReceiveHandlerThread == NULL) &&
            (GlobalWaitersCount > 0)) {

            //
            //  there are other threads waiting and there's no one handling
            //  the receive thread.  Succeed a wait.
            //

            CheckForWaiters( 0, TRUE, NULL );
        }
    }

    if (haveLock) {
        haveLock = FALSE;
        RELEASE_LOCK( &ConnectionListLock );
    }

    if ((err == LDAP_SUCCESS) &&
        (Result != NULL) &&
        (Request != NULL) &&
        (Request->CopyResultToCache == TRUE)) {

        if (CopyResultToCache( Connection, *Result ) == TRUE) {

            Request->CopyResultToCache = FALSE;
            Request->ResultsAreCached = TRUE;

            err = FabricateLdapResult(Request,
                                      Connection,
                                      Request->OriginalDN,
                                      Request->search.AttributeList,
                                      Request->search.Unicode
                                      );


        } else {

            //
            // We were not able to cache the data, resend the original request
            // to the server.
            //

            Request->CopyResultToCache = FALSE;
            Request->ResultsAreCached = FALSE;

            err = SendLdapSearch(Request,
                                 Connection,
                                 Request->OriginalDN,
                                 Request->search.ScopeOfSearch,
                                 Request->search.SearchFilter,
                                 Request->search.AttributeList,
                                 Request->search.AttributesOnly,
                                 Request->search.Unicode,
                                 (CLdapBer **)&Request->BerMessageSent,
                                 0 );

        }


        if (err == LDAP_SUCCESS) {

            //
            // Free the old result message and get a new result message
            // from the cache. This message will consist of only the attributes
            // requested in the original search.
            //

            ldap_msgfree( *Result );
            *Result = NULL;
            goto TryAgain;
        }
    }

    return err;
}

PLDAP_CONN
LdapAllBuffersToMessages (
    PLDAP_CONN PreferredConnection,
    ULONG AllOfMessage
    )
//
//  This routine processes all received buffers into LDAP messages.  It
//  bounces out if we hit a connection that needs to be reconnected.
//
//  We give first preference to the specified connection.
//
//  No locks must be held coming in here!!
//
{
    PLIST_ENTRY listEntry;
    PLDAP_CONN connection = NULL;
    ULONG err;
    PLDAP_CONN reconnectConnection = NULL;

    ACQUIRE_LOCK( &ConnectionListLock );
    
    if ( PreferredConnection != NULL ) {
        
        PreferredConnection = ReferenceLdapConnection( PreferredConnection );
        
        if ( PreferredConnection &&
             (PreferredConnection->HostConnectState == HostConnectStateConnected ) ) {

            err = LdapBuffersToMessages( PreferredConnection, AllOfMessage );
            
            if (PreferredConnection->HostConnectState == HostConnectStateError) {

                //
                // Possible candidate for auto-reconnect
                //

                if (PreferredConnection->AutoReconnect == TRUE) {

                    reconnectConnection = PreferredConnection;
                
                } else {

                    RELEASE_LOCK( &ConnectionListLock );

                    ClearPendingListForConnection( PreferredConnection );

                    ACQUIRE_LOCK( &ConnectionListLock );
                }

            }
        }

        //
        // Keep the connection referenced if it is a candidate for reconnect.
        //

        if ( PreferredConnection && !reconnectConnection ) {
            DereferenceLdapConnection( PreferredConnection );
        }
    }

    if (reconnectConnection) {

        RELEASE_LOCK( &ConnectionListLock );
        return reconnectConnection;
    }

    //
    // Walk the rest of the connectionList, converting buffers to messages
    // and looking for potential autoreconnect candidates.
    //

    listEntry = GlobalListActiveConnections.Flink;

    while (listEntry != &GlobalListActiveConnections) {

        connection = CONTAINING_RECORD( listEntry, LDAP_CONN, ConnectionListEntry );

        if (connection == PreferredConnection) {
            
            //
            // We have already processed this one, skip to the next one.
            //

            listEntry = listEntry->Flink;
            continue;
        }

        connection = ReferenceLdapConnection( connection );

        if (connection &&
            (connection->HostConnectState == HostConnectStateConnected )) {

            err = LdapBuffersToMessages( connection, AllOfMessage );

            if (connection->HostConnectState == HostConnectStateError) {

                //
                //   here we go trying auto-reconnect
                //

                if (connection->AutoReconnect == TRUE) {

                    reconnectConnection = connection;
                    break;
                }

                RELEASE_LOCK( &ConnectionListLock );

                ClearPendingListForConnection( connection );

                ACQUIRE_LOCK( &ConnectionListLock );
            }

            listEntry = listEntry->Flink;
            DereferenceLdapConnection( connection );

        } else {

            listEntry = listEntry->Flink;
            
            if (connection) {
                DereferenceLdapConnection( connection );
            }
        }
    }

    RELEASE_LOCK( &ConnectionListLock );
    return reconnectConnection;
}

ULONG
LdapBuffersToMessages (
    PLDAP_CONN Connection,
    ULONG AllOfMessage
    )
//
//  This routine processes all received buffers into LDAP messages.
//
//  !! The ConnectionListLock must be held coming in here.
//
{
    PLDAP_RECVBUFFER buffer = NULL;
    ULONG err;
    PLIST_ENTRY listEntry;
    ULONG hr;
    ULONG messagesGenerated = 0;

    //
    //  drain the crypto stream into the Received list.  If this fails, there
    //  was a problem and the user must close the connection.
    //

    err = DrainPendingCryptoStream( Connection );

    if (err != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "LdapBuffersToMessages : drain crypto returned 0x%x on conn 0x%x\n",
                            err, Connection );
        }

        //
        // We can't call CloseLdapConnection() because the user can't unbind the connection
        // due to the connection state being set to closed, thus leaking the connection.
        // Our only option is to set the state to HostConnectState to Error and set
        // autoreconnect to OFF. This will prevent autoreconnects yet convey an 
        // error (LDAP_SERVER_DOWN) to the user upon decryption failure.
        // This is the best we can do.
        //

        Connection->ServerDown = TRUE;
        Connection->HostConnectState = HostConnectStateError;
        Connection->AutoReconnect = FALSE;
        
        return err;
    }
    
    listEntry = Connection->CompletedReceiveList.Flink;

    if (listEntry == &Connection->CompletedReceiveList) {

        //
        // No plaintext buffers for us to convert into messages. We have nothing
        // to do.
        //
        
        return err;
    }

    IF_DEBUG(TRACE1) {
        LdapPrint1( "LdapBuffersToMessages : searching for messages on conn 0x%x\n", Connection );
    }

    err = LDAP_SUCCESS;

    while (( listEntry != &Connection->CompletedReceiveList ) &&
           ( err == LDAP_SUCCESS )) {

        //
        //  loop through the receive buffers converting them to LDAP messages
        //

        buffer = CONTAINING_RECORD(   listEntry,
                                      LDAP_RECVBUFFER,
                                      ReceiveListEntry );

        ASSERT( buffer->Connection == Connection );

        if (buffer->NumberOfBytesReceived == 0) {

            IF_DEBUG(TRACE1) {
                LdapPrint1( "BufferToMessages : connection 0x%x is marked down.\n",
                             Connection );
            }

            IF_DEBUG(SERVERDOWN) {
                LdapPrint2( "ldapBuffersToMsgs thread 0x%x has connection 0x%x as down.\n",
                                GetCurrentThreadId(),
                                Connection );
            }
            err = LDAP_SERVER_DOWN;
            Connection->ServerDown = TRUE;
            Connection->HostConnectState = HostConnectStateError;
            LdapFreeReceiveStructure( buffer, TRUE );
            continue;
        }

        IF_DEBUG(TRACE1) {
            LdapPrint2( "  checking out buffer 0x%x for Connection 0x%x\n",
                                buffer, Connection );
        }

        while ((err == NOERROR) &&
               (buffer->NumberOfBytesReceived > buffer->NumberOfBytesTaken)) {

            ULONG bytesTaken;
            ULONG bytesAvailable;
            PLDAPMessage result;
            CLdapBer *lber;

            bytesAvailable = buffer->NumberOfBytesReceived - buffer->NumberOfBytesTaken;
            bytesTaken = 0;

            if (Connection->PendingMessage == NULL) {

                //
                //  There is no portion of a message waiting so this must be
                //  the start of a new message.
                //

                result = (PLDAPMessage) ldapMalloc( sizeof(LDAPMessage),
                                                    LDAP_MESG_SIGNATURE );

                if (result == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint1( "BufferToMessages: unable to alloc msg for 0x%x.\n",
                                    Connection );
                    }

                    err = LDAP_NO_MEMORY;
                    break;
                }

                lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

                if (lber == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint1( "BufferToMessages: unable to alloc msg for 0x%x.\n",
                                    Connection );
                    }

                    ldapFree( result, LDAP_MESG_SIGNATURE );
                    err = LDAP_NO_MEMORY;
                    break;
                }

                result->Connection = Connection->ExternalInfo;
                result->lm_ber = (PVOID) lber;

                hr = lber->HrLoadBer(
                         (const BYTE *) &buffer->DataBuffer[buffer->NumberOfBytesTaken],
                          bytesAvailable,
                          &bytesTaken);

                if (hr != NOERROR) {

                    err = hr;

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "BufferToMessages: loadBer1 error of 0x%x for 0x%x.\n",
                                    err, Connection );
                    }

                    ldapFree( result, LDAP_MESG_SIGNATURE );
                    delete lber;
                    break;
                }

            } else {

                //
                //  We've already received a portion of a message, this must
                //  be the continuation of it.
                //

                result = Connection->PendingMessage;

                lber = (CLdapBer *) (result->lm_ber);

                ASSERT( lber != NULL );

                hr = lber->HrLoadMoreBer(
                         (const BYTE *) &buffer->DataBuffer[buffer->NumberOfBytesTaken],
                         bytesAvailable,
                         &bytesTaken);

                if (hr != NOERROR) {

                    err = hr;

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "BufferToMessages: loadBer2 error of 0x%x for 0x%x.\n",
                                    err, Connection );
                    }

                    if (hr != LDAP_NO_MEMORY) {

                        ASSERT( hr == LDAP_DECODING_ERROR );

                        ldapFree( result, LDAP_MESG_SIGNATURE );
                        delete lber;
                        Connection->PendingMessage = NULL;
                    }

                    break;
                }
            }

            //
            //  check to see if we've received the whole message
            //

            if ((lber->CbData() > lber->BytesReceived()) ||
                (lber->CbData() == 0)) {

                // if CbData is 0, means that we don't have enough of the
                // message to determine the length.

                Connection->PendingMessage = result;

            } else {

                Connection->PendingMessage = NULL;

                //
                //  this message is now complete.  Find the request block for
                //  it and put it on the list.
                //

                err = LdapInitialDecodeMessage( Connection, result );

                if (err != NOERROR) {

                    IF_DEBUG(NETWORK_ERRORS) {
                        LdapPrint2( "LdapBuffersToMessages Connection 0x%x, decoding error of 0x%x\n",
                                    Connection, err );
                    }

                    ldapFree( result, LDAP_MESG_SIGNATURE );
                    delete lber;

                } else {

                    //
                    //  find the request block for this message id
                    //

                    PLDAP_REQUEST request = FindLdapRequest( result->lm_msgid );

                    if (request == NULL) {

                        IF_DEBUG(NETWORK_ERRORS) {
                            LdapPrint2( "LdapBuffersToMessages Connection 0x%x, request for msgid 0x%x not found.\n",
                                        Connection, result->lm_msgid );
                        }

                        if ( result->lm_msgid == 0 ) {

                           Connection->HostConnectState = HostConnectStateError;
                           Connection->ServerDown = TRUE;

                           IF_DEBUG(NETWORK_ERRORS) {
                               LdapPrint2( "LdapBuffersToMessages Connection 0x%x, msgid 0x%x found.\n",
                                           Connection, result->lm_msgid );
                           }
                        }
                        
                        IF_DEBUG(NETWORK_ERRORS) {
                           LdapPrint2("LdapBuffersToMessages discarding result msgid 0X%X at 0x%X for lack of request\n", result->lm_msgid,result );
                        }

                        ldapFree( result, LDAP_MESG_SIGNATURE );
                        delete lber;

                    } else {

                        ACQUIRE_LOCK( &request->Lock );

                        if (request->Abandoned) {

                            RELEASE_LOCK( &request->Lock );

                            IF_DEBUG(NETWORK_ERRORS) {
                                LdapPrint2( "LdapBuffersToMessages Connection 0x%x, request 0x%x abandoned.\n",
                                            Connection, result->lm_msgid );
                            }

                            DereferenceLdapRequest( request );
                            ldapFree( result, LDAP_MESG_SIGNATURE );
                            delete lber;

                        } else {

                            PLDAPMessage msgList = request->MessageLinkedList;

                            //
                            //  if the caller wanted us to ref/deref connections
                            //  for each message, we ref the connection here.
                            //

                            if (request->ReferenceConnectionsPerMessage) {

                                result->ConnectionReferenced = TRUE;
                                Connection = ReferenceLdapConnection( Connection );
                                ASSERT(Connection);
                            }

                            if ((result->lm_msgtype != LDAP_RES_SEARCH_ENTRY) &&
                                (result->lm_msgtype != LDAP_RES_REFERRAL)) {

                                DecrementPendingList( request, Connection );

                                IF_DEBUG(REQUEST) {
                                    LdapPrint2( "LdapBuffersToMessages received message type 0x%x for msgid 0x%X\n", result->lm_msgtype, result->lm_msgid );
                                    LdapPrint1( "LdapBuffersToMessages handling completion for 0x%x.\n", request );
                                }

                            } else if (result->lm_msgtype == LDAP_RES_SEARCH_ENTRY) {

                                request->ReceivedData = TRUE;

                                IF_DEBUG(REQUEST) {
                                    LdapPrint1( "LdapBuffersToMessages handling searchEntry for 0x%x.\n", request );
                                }

                            } else {
                                IF_DEBUG(REQUEST) {
                                    LdapPrint1( "LdapBuffersToMessages handling referral for 0x%x.\n", request );
                                }
                            }

                            //
                            //  put the message on the end of the message's
                            //  chain list
                            //

                            while ((msgList != NULL) &&
                                   (msgList->lm_chain != NULL)) {

                                msgList = msgList->lm_chain;
                            }

                            result->lm_chain = NULL;
                            result->lm_next = NULL;

                            if (msgList != NULL) {

                                msgList->lm_chain = result;

                            } else {

                                request->MessageLinkedList = result;
                            }

                            result->lm_time = GetTickCount();
                            result->Request = request;

                            //
                            //  figure out if we need to wake somebody up.
                            //
                            //  if it wasn't a searchEntry or subordinateRef
                            //  (or we're chasing referrals), then
                            //  wake somebody.
                            //

                            if (((result->lm_msgtype == LDAP_RES_SEARCH_ENTRY)&&(AllOfMessage == LDAP_MSG_ALL)) ||
                                ((result->lm_msgtype == LDAP_RES_REFERRAL) &&
                                 (request->ChaseReferrals == 0))) {

                                RELEASE_LOCK( &request->Lock );

                            } else {

                                //
                                //  if we're about to wake someone up, only
                                //  do it if we don't have outstanding responses.
                                //

                               if ((result->lm_msgtype == LDAP_RES_SEARCH_ENTRY)&&
                                   (AllOfMessage != LDAP_MSG_ALL)) {
                                  goto wakeSomeoneUp;
                               }
                                if (result->lm_msgtype != LDAP_RES_REFERRAL) {

                                    if (request->ResponsesOutstanding > 0) {

                                        IF_DEBUG(SCRATCH) {
                                             LdapPrint2( "LdapBuffersToMessages request 0x%x has 0x%x outstanding\n",
                                                         request, request->ResponsesOutstanding );
                                        }
                                        RELEASE_LOCK( &request->Lock );

                                    } else {

                                          //
                                          // This is the last message
                                          //

                                        IF_DEBUG(EOM) {
                                             LdapPrint3( "LdapBuffersToMessages marking eom for request 0x%x, msg 0x%x, msgid 0x%x\n",request, result, result->lm_msgid );
                                        }
                                        result->lm_eom = TRUE;
                                        goto wakeSomeoneUp;
                                    }
                                } else {
wakeSomeoneUp:
                                    LONG msgId = result->lm_msgid;

                                    RELEASE_LOCK( &request->Lock );

                                    //
                                    //  check for waiters for this message
                                    //

                                    CheckForWaiters( msgId, FALSE, Connection );
                                }
                            }
                            DereferenceLdapRequest( request );

                            messagesGenerated++;
                        }
                    }
                }
            }

            buffer->NumberOfBytesTaken += bytesTaken;
        }

        //
        //  we've converted the single buffer to some messages... let's
        //  continue on.
        //

        listEntry = listEntry->Flink;

        //
        //  the only time we leave the buffer on the received list is when
        //  we're in an out of memory condition and we haven't processed the
        //  entire packet.
        //

        if ((buffer->NumberOfBytesReceived == buffer->NumberOfBytesTaken) ||
            (err != LDAP_NO_MEMORY) ) {

            LdapFreeReceiveStructure( buffer, TRUE );
        }
    }

    if (messagesGenerated > 0) {

        SetConnectionError( Connection, err, NULL );
    }
    return err;
}

VOID
CheckForWaiters (
    ULONG MessageNumber,
    BOOLEAN AnyWaiter,
    PLDAP_CONN Connection
    )
//
//  This searches down through the list of waiting threads and signals one
//  that is waiting for the specific message number.  If none are found for
//  the specific message number, a thread waiting for any (messageNumber = 0)
//  is signalled.
//
//  The AnyWaiter parameter specifies that we should just succeed any old
//  waiter, doesn't matter what it's waiting for.
//
//  !! The lock protecting the list of waiters must be held coming in here.
//
{
    PLIST_ENTRY waitList = &GlobalListWaiters;
    PLIST_ENTRY listEntry;
    PLDAP_MESSAGEWAIT generalWait = NULL;
    PLDAP_MESSAGEWAIT specificWait = NULL;

    listEntry = waitList->Flink;

    //
    //  ensure there aren't any wait structures for this particular
    //  message
    //

    while (listEntry != waitList) {

        specificWait = CONTAINING_RECORD( listEntry,
                                         LDAP_MESSAGEWAIT,
                                         WaitListEntry );

        if (specificWait->Satisfied == FALSE) {

            if (specificWait->PendingSendOnly) {

                if ((Connection == NULL) ||
                    (Connection == specificWait->Connection)) {

                    IF_DEBUG(RECEIVEDATA) {
                        LdapPrint2( "CheckForWaiter setting connection 0x%x, wait 0x%x\n",
                                    specificWait->Connection, specificWait );
                    }

                    specificWait->Satisfied = TRUE;
                    SetEvent( specificWait->Event );
                }

            } else {

                if (AnyWaiter == TRUE) {
                    break;
                }

                if (specificWait->MessageNumber == MessageNumber) {
                    break;
                }

                if ((specificWait->MessageNumber == 0) &&
                   (Connection == specificWait->Connection) ) {
                   break;
                }
                //
                //  Consider also looking at the connection that this response
                //  came from as criteria to who should be woken up.
                //

                if (generalWait == NULL) {
                    generalWait = specificWait;
                }
            }
        }

        specificWait = NULL;
        listEntry = listEntry->Flink;
    }

    if (specificWait != NULL) {

        generalWait = specificWait;
    }

    if (generalWait != NULL) {

        IF_DEBUG(RECEIVEDATA) {
            LdapPrint2( "CheckForWaiter setting MsgNo 0x%x, wait 0x%x\n",
                        generalWait->MessageNumber, generalWait );
        }

        generalWait->Satisfied = TRUE;
        SetEvent( generalWait->Event );

    } else {

        IF_DEBUG(SCRATCH) {
            LdapPrint1( "CheckForWaiter didn't find any waiters for MsgNo 0x%x\n",
                        MessageNumber );
        }
    }
    return;
}

ULONG
LdapGetResponseFromServer (
    IN PLDAP_CONN Connection,
    IN PLDAP_REQUEST Request,
    IN ULONG AllOfMessage,
    OUT PLDAPMessage *Result
    )
//
//  Get a response from the server for a given messageid
//  and return the message.
//
{
    PLIST_ENTRY requestListEntry;
    PLDAP_REQUEST request = Request;
    PLDAPMessage message;

    ASSERT( *Result == NULL );
    ASSERT( ( AllOfMessage == LDAP_MSG_ALL ) ||
            ( AllOfMessage == LDAP_MSG_ONE ) ||
            ( AllOfMessage == LDAP_MSG_RECEIVED ));

    if (request != NULL) {

        //
        //  we know exactly which request to look at...
        //

        ACQUIRE_LOCK( &request->Lock );

        IF_DEBUG(RECEIVEDATA) {
            LdapPrint1( "LdapGetResponseFromServer : searching for msgs for message 0x%x\n",
                        Request->MessageId );
        }

        //
        //  if the client wanted only a complete message, ensure that this is it.
        //

        message = request->MessageLinkedList;

        if ((message != NULL) &&
            (AllOfMessage == LDAP_MSG_ALL)) {

            if (request->ResponsesOutstanding > 0) {

                message = NULL;

                IF_DEBUG(REQUEST) {
                    LdapPrint2( "LdapGetRespFromSrv still 0x%x pending responses for 0x%x.\n",
                                request->ResponsesOutstanding, request );
                }

            } else if (message->lm_msgtype == LDAP_RES_SEARCH_ENTRY) {

                PLDAPMessage chainedMsg;

                //
                //  search down chain for LDAP_RES_SEARCH_RESULT message
                //

                for (chainedMsg = message;
                    ((chainedMsg != NULL) &&
                     (chainedMsg->lm_msgtype != LDAP_RES_SEARCH_RESULT));
                    chainedMsg = chainedMsg->lm_chain );

                if (chainedMsg == NULL) {

                    //
                    //  Haven't received the whole message.  we're done
                    //  and haven't found it.
                    //

                    IF_DEBUG(RECEIVEDATA) {
                        LdapPrint1( "LdapGetResponseFromServer : haven't found whole msg 0x%x\n",
                                    Request->MessageId );
                    }
                    message = NULL;
                }
            }
        }

        if (message != NULL) {

            //
            //  remove message from list of incoming messages for request
            //

            IF_DEBUG(RECEIVEDATA) {
                LdapPrint2( "LdapGetResponseFromServer Msg 0x%x marked received for conn 0x%x\n",
                                    message->lm_msgid, message->Connection );
            }

            if ((AllOfMessage == LDAP_MSG_ONE) &&
                (message->lm_chain != NULL)) {

                message->lm_chain->lm_next = message->lm_next;
                message->lm_next = message->lm_chain;
                message->lm_chain = NULL;
            }

            request->MessageLinkedList = message->lm_next;
            message->lm_next = NULL;

            *Result = message;

        } else {

            IF_DEBUG(RECEIVEDATA) {
                LdapPrint1( "LdapGetResponseFromServer: no message found for 0x%x.\n",
                                    request->MessageId );
            }
        }

        RELEASE_LOCK( &request->Lock );

        return LDAP_SUCCESS;
    }

    //
    //  search through the list of pending requests for the messages we're
    //  looking for
    //

    ACQUIRE_LOCK( &RequestListLock );

    requestListEntry = GlobalListRequests.Flink;

    while (requestListEntry != &GlobalListRequests) {

        request = CONTAINING_RECORD( requestListEntry,
                                     LDAP_REQUEST,
                                     RequestListEntry );

        request = ReferenceLdapRequest(request);

        requestListEntry = requestListEntry->Flink;

        IF_DEBUG(RECEIVEDATA) {
            LdapPrint1( "LdapGetResponseFromServer : searching for any msg for conn 0x%x\n", Connection );
        }

        if ( !request ) {
            continue;
        }

        if ( request->Closed ) {
            DereferenceLdapRequest(request);
            continue;
        }

        //
        //  Check if the message meets the requirements... is it for the
        //  correct connection, if they specified one.
        //

        if ( (request->Synchronous == FALSE ) &&
             ( (Connection == NULL) ||
               ((Connection != NULL) &&
                (request->PrimaryConnection == Connection)) ) ) {

            ACQUIRE_LOCK( &request->Lock );

            message = request->MessageLinkedList;

            if ((message != NULL) &&
                (AllOfMessage == LDAP_MSG_ALL)) {

                if (request->ResponsesOutstanding > 0) {

                    message = NULL;

                } else if (message->lm_msgtype == LDAP_RES_SEARCH_ENTRY) {

                    PLDAPMessage chainedMsg;

                    //
                    //  search down chain for LDAP_RES_SEARCH_RESULT message
                    //

                    for (chainedMsg = message;
                        ((chainedMsg != NULL) &&
                         (chainedMsg->lm_msgtype != LDAP_RES_SEARCH_RESULT));
                        chainedMsg = chainedMsg->lm_chain );

                    if (chainedMsg == NULL) {

                        //
                        //  Haven't received the whole message.  we're done
                        //  and haven't found it.
                        //

                        IF_DEBUG(RECEIVEDATA) {
                            LdapPrint1( "LdapGetResponseFromServer : haven't found whole msg 0x%x\n",
                                        Request->MessageId );
                        }
                        message = NULL;
                    }
                }
            }

            if (message != NULL) {

                //
                //  remove message from list of incoming messages for request
                //

                IF_DEBUG(RECEIVEDATA) {
                    LdapPrint2( "LdapGetResponseFromServer Msg 0x%x marked received for conn 0x%x\n",
                                        message->lm_msgid, message->Connection );
                }

                if ((AllOfMessage == LDAP_MSG_ONE) &&
                    (message->lm_chain != NULL)) {

                    message->lm_chain->lm_next = message->lm_next;
                    message->lm_next = message->lm_chain;
                    message->lm_chain = NULL;
                }

                request->MessageLinkedList = message->lm_next;
                message->lm_next = NULL;

                *Result = message;

                RELEASE_LOCK( &request->Lock );
                DereferenceLdapRequest(request);

                RELEASE_LOCK( &RequestListLock );
                return LDAP_SUCCESS;
            }

            IF_DEBUG(RECEIVEDATA) {
                LdapPrint1( "LdapGetResponseFromServer: no message found for 0x%x.\n",
                                    request->MessageId );
            }

            RELEASE_LOCK( &request->Lock );
        }

        DereferenceLdapRequest(request);
    }

    RELEASE_LOCK( &RequestListLock );

    //
    //  none found.
    //

    return LDAP_SUCCESS;
}


ULONG
DrainWinsock (
    ULONG milliseconds
    )
//
//  This uses "select" to drain all data from winsock into message structures.
//
//  This should not be called with any locks held.
//
//  It returns a Winsock error, 0 if success.
//
{
    PLDAP_RECVBUFFER buffer = NULL;

    USHORT waitHandles = 1;
    PLIST_ENTRY connListEntry;
    PLDAP_CONN recvConn = NULL;
    SOCKET socket;
    ULONG successfulReceives = 0;
    ULONG waitErr = WSA_WAIT_TIMEOUT;
    ULONG minKeepAliveCount = 0;
    ULONG err = 0;

    ACQUIRE_LOCK( &SelectLock2 );
    InsideSelect = TRUE;
    RELEASE_LOCK( &SelectLock2 );

    ASSERT( GlobalDrainWinsockThread == NULL );

    InterlockedExchange( (PLONG) &GlobalDrainWinsockThread, GetCurrentThreadId());
    
    //
    //  setup array to wait on
    //

    ACQUIRE_LOCK( &SelectLock1 );
    ACQUIRE_LOCK( &ConnectionListLock );

    //
    //  Well, clients don't want a maximum number of connections, so we'll
    //  have to take a peek into the select() control macros and manipulate
    //  the structures rather than use FD_SET, FD_SETSIZE, etc
    //

    if ((WinsockSelectReadSet == NULL) ||
        (GlobalConnectionCount >= (LONG) FD_SETSIZE)) {

        if (FD_SETSIZE == 0) {

            FD_SETSIZE = Real_FD_SETSIZE;
        }

        ULONG temp_FD_SETSIZE = FD_SETSIZE;

        if (WinsockSelectReadSet != NULL) {

            ASSERT( FD_SETSIZE > 0 );

            temp_FD_SETSIZE *= 2;      // double size of array.
        }

        fd_set *newSelectSet;

        newSelectSet = (fd_set *) ldapMalloc( sizeof( fd_set ) +
             ( ( temp_FD_SETSIZE - Real_FD_SETSIZE ) * sizeof( SOCKET )),
               LDAP_SELECT_READ_SIGNATURE );

        if (newSelectSet == NULL) {

            IF_DEBUG(ERRORS) {
                LdapPrint1( "wldap32: DrainWinsock couldn't allocate 0x%x select buffer.\n", temp_FD_SETSIZE );
            }

            if (WinsockSelectReadSet == NULL) {

                InsideSelect = FALSE;
                RELEASE_LOCK( &ConnectionListLock );
                err = ERROR_NOT_ENOUGH_MEMORY;
                goto error;
            }

            //
            //  if we fail, we just fall through here.  We just won't wait
            //  on all the connections.  Hopefully this won't deadlock us.
            //

        } else {

            FD_SETSIZE = temp_FD_SETSIZE;       // we've made it a variable

            ldapFree( WinsockSelectReadSet, LDAP_SELECT_READ_SIGNATURE );

            WinsockSelectReadSet = newSelectSet;
        }
    }

    FD_ZERO( WinsockSelectReadSet );

    ASSERT( LdapGlobalWakeupSelectHandle != INVALID_SOCKET);

    if ( LdapGlobalWakeupSelectHandle != INVALID_SOCKET ) {

        FD_SET( LdapGlobalWakeupSelectHandle, WinsockSelectReadSet );
    }

    connListEntry = GlobalListActiveConnections.Flink;

    while (connListEntry != &GlobalListActiveConnections) {

        recvConn = CONTAINING_RECORD( connListEntry, LDAP_CONN, ConnectionListEntry );
        recvConn = ReferenceLdapConnection(recvConn);

        if ( !recvConn ||
             recvConn->ServerDown ||
             ( recvConn->ConnObjectState == ConnObjectClosing ) ||
             ( recvConn->HostConnectState != HostConnectStateConnected ) ||
             ( recvConn->SslSetupInProgress )) {

           //
           // If this connection is in SSL setup, we do NOT want to
           // include it in the select or we will interfere with the
           // raw sspi token receive.
           //

           connListEntry = connListEntry->Flink;
           
           if (recvConn)
               DereferenceLdapConnection(recvConn);

           continue;
        }

        if (recvConn->UdpHandle != INVALID_SOCKET) {

            socket = recvConn->UdpHandle;

        } else if (recvConn->TcpHandle != INVALID_SOCKET) {

            socket = recvConn->TcpHandle;

        } else {

            connListEntry = connListEntry->Flink;
            DereferenceLdapConnection(recvConn);
            continue;
        }

        FD_SET( socket, WinsockSelectReadSet );

        if ((recvConn->ResponsesExpected > 0) &&
            (recvConn->KeepAliveSecondCount > 0)) {

            if (minKeepAliveCount == 0) {

                minKeepAliveCount = recvConn->KeepAliveSecondCount;

            } else {

                minKeepAliveCount = min( minKeepAliveCount, recvConn->KeepAliveSecondCount );
            }
        }

        if (++waitHandles == FD_SETSIZE) {
            break;
        }

        connListEntry = connListEntry->Flink;
        DereferenceLdapConnection(recvConn);
    }

    RELEASE_LOCK( &ConnectionListLock );


    //
    //  we have a set to wait on, let's call select to see which ones
    //  we need to put recv's on.
    //

    struct timeval winSock11Time;
    struct timeval *pWinSock11Time;
    int entries;

    entries = 0;

    pWinSock11Time = &winSock11Time;

    //
    //  if they specified infinite timeout, then we use the timeout value
    //  from the connection that has the min timeout value that has a response
    //  pending on it.
    //

    if (milliseconds == (ULONG) -1) {

        if (minKeepAliveCount == 0) {

            minKeepAliveCount = GlobalWaitSecondsForSelect;
        }

        if (minKeepAliveCount > 0) {

            winSock11Time.tv_sec = minKeepAliveCount;
            winSock11Time.tv_usec = 0;

        } else {

            pWinSock11Time = NULL;
        }

    } else if (milliseconds == 0) {

        winSock11Time.tv_sec = 0;
        winSock11Time.tv_usec = 0;

    } else {

        ULONG seconds = 0;
        ULONG msecs = max( milliseconds, 1 );

        if (milliseconds >= 1000) {

            seconds = milliseconds / 1000;
            msecs = milliseconds % 1000;
        }

        winSock11Time.tv_sec = seconds;
        winSock11Time.tv_usec = msecs * 1000;
    }

    entries = (*pselect)(   0,
                            WinsockSelectReadSet,
                            NULL,
                            NULL,
                            pWinSock11Time );

    InsideSelect = FALSE;

    if (entries == SOCKET_ERROR) {

        err = (*pWSAGetLastError)();
        goto error;
    }

    waitErr = WSA_WAIT_TIMEOUT;

    //
    //  check which connections had messages come in on them... or, if we timed
    //  out, then we check to see if the servers are up.
    //

    ACQUIRE_LOCK( &ConnectionListLock );

    connListEntry = GlobalListActiveConnections.Flink;

    while (connListEntry != &GlobalListActiveConnections) {

        recvConn = CONTAINING_RECORD( connListEntry, LDAP_CONN, ConnectionListEntry );
        recvConn = ReferenceLdapConnection( recvConn );

        if ( !recvConn ||
             recvConn->ServerDown ||
             ( recvConn->ConnObjectState == ConnObjectClosing ) ||
             ( recvConn->HostConnectState != HostConnectStateConnected ) ||
             ( recvConn->SslSetupInProgress )) {

            //
            // If this connection is in SSL setup, we do NOT want to
            // include it in the select or we will interfere with the
            // raw sspi token receive.
            //

            connListEntry = connListEntry->Flink;
            
            if (recvConn)
                DereferenceLdapConnection(recvConn);

            continue;
        }

        if (recvConn->UdpHandle != INVALID_SOCKET) {

            socket = recvConn->UdpHandle;

        } else if (recvConn->TcpHandle != INVALID_SOCKET) {

            socket = recvConn->TcpHandle;

        } else {

            connListEntry = connListEntry->Flink;
            DereferenceLdapConnection(recvConn);
            continue;
        }

        if ((entries != 0) &&
            (*pwsafdisset)( socket, WinsockSelectReadSet ) > 0) {

            recvConn->TimeOfLastReceive = LdapGetTickCount();
            recvConn->NumberOfPingsSent = 0;

            buffer = LdapGetReceiveStructure(INITIAL_MAX_RECEIVE_BUFFER);

            if (buffer == NULL) {

                IF_DEBUG(OUTMEMORY) {
                    LdapPrint0( "LdapDrainWinsock failed to get receive buffer\n");
                }

                RELEASE_LOCK( &ConnectionListLock );
                DereferenceLdapConnection(recvConn);
                err = WSA_NOT_ENOUGH_MEMORY;
                goto error;
            }

            waitErr = (*precv)( socket,
                                (PCHAR) &buffer->DataBuffer[0],
                                buffer->BufferSize,
                                0 );        // recv flags

            if (waitErr == SOCKET_ERROR) {

                waitErr = (*pWSAGetLastError)();

                IF_DEBUG(NETWORK_ERRORS) {
                    LdapPrint2( "LdapDrainWinsock failed recv, err = 0x%x for conn 0x%x.\n",
                                waitErr, recvConn);
                }

                ASSERT( waitErr != WSAEWOULDBLOCK );
                ASSERT( waitErr != WSA_IO_PENDING );

                if ((waitErr == WSAECONNRESET) ||
                    (waitErr == WSAECONNABORTED) ||
                    (waitErr == WSAENETDOWN) ||
                    (waitErr == WSAENETUNREACH) ||
                    (waitErr == WSAESHUTDOWN) ||
                    (waitErr == WSAEHOSTDOWN) ||
                    (waitErr == WSAEHOSTUNREACH) ||
                    (waitErr == WSAENETRESET) ||
                    (waitErr == WSAENOTCONN) ) {

                    IF_DEBUG(NETWORK_ERRORS) {
                        LdapPrint2( "LdapDrainWinsock marking connection 0x%x as down, rc = 0x%x\n",
                                    recvConn, waitErr);
                    }

                    buffer->NumberOfBytesReceived = 0;
                    recvConn->ServerDown = TRUE;

                    goto postReceive;

                } else if (waitErr != WSA_IO_PENDING) {

                    LdapFreeReceiveStructure( buffer, TRUE );
                }

            } else {

                //
                //  we received data here... call the callback routine.
                //

#if DBG
                if (InjectServerDowns > 0 && recvConn->BindInProgress == FALSE) {
                    if (--InjectServerDowns == 1) {
                        InjectServerDowns = INTJECTSERVERDOWNS;
                        waitErr = 0;
                    }
                }
#endif
                buffer->NumberOfBytesReceived = waitErr;

                if (waitErr == 0) {

                    IF_DEBUG(NETWORK_ERRORS) {
                        LdapPrint1( "LdapDrainWinsock marking connection 0x%x as gracefully down\n",
                                    recvConn);
                    }

                    recvConn->ServerDown = TRUE;
                    waitErr = LDAP_SERVER_DOWN;
                }
postReceive:
                buffer->Connection = recvConn;

                if ( recvConn->SecureStream ) {

                    InsertTailList( &recvConn->PendingCryptoList,
                                    &buffer->ReceiveListEntry );
                } else {

                    InsertTailList( &recvConn->CompletedReceiveList,
                                    &buffer->ReceiveListEntry );
                }

                if ( recvConn->ServerDown == FALSE ) {
                   successfulReceives++;
                }
            }

        } else if ((recvConn->TcpHandle != INVALID_SOCKET) &&
                   (recvConn->ResponsesExpected > 0) &&
                   (recvConn->PingLimit > 0) &&
                   (recvConn->KeepAliveSecondCount > 0)) {
            //
            //  if we're expecting a message from this server, then we check
            //  to see if it's time to send it a ping.
            //
            //  We do this only for a TCP connection; not for netlogon's UDP
            //  connections.
            //

            ULONGLONG tickCount = LdapGetTickCount();

            if (tickCount > recvConn->TimeOfLastReceive) {

                tickCount -= recvConn->TimeOfLastReceive;

                if (tickCount >= recvConn->KeepAliveSecondCount * 1000) {

                    RELEASE_LOCK( &ConnectionListLock );

                    //
                    //  send the server a ping.  if it returns ok, then we
                    //  know it's alive and we can reset the timer.  If it fails,
                    //  then we keep pinging until we exceed the ping limit,
                    //  in which case we mark the server as down.
                    //

                    ULONG err = LdapPingServer( recvConn );

                    ACQUIRE_LOCK( &ConnectionListLock );

                    if (err != LDAP_SUCCESS) {

                        recvConn->NumberOfPingsSent++;

                        if (recvConn->NumberOfPingsSent >= recvConn->PingLimit) {

                            buffer = LdapGetReceiveStructure(INITIAL_MAX_RECEIVE_BUFFER);

                            if (buffer != NULL) {

                                IF_DEBUG(NETWORK_ERRORS) {
                                    LdapPrint2( "LdapDrainWinsock marking connection 0x%x as down from 0x%x pings\n",
                                                recvConn,
                                                recvConn->NumberOfPingsSent);
                                }

                                buffer->NumberOfBytesReceived = 0;
                                recvConn->ServerDown = TRUE;

                                waitErr = WSAECONNRESET;
                                goto postReceive;
                            }

                            IF_DEBUG(OUTMEMORY) {
                                LdapPrint0( "LdapDrainWinsock failed to get receive buffer for ping limit\n");
                            }
                        }

                    } else {

                        recvConn->NumberOfPingsSent = 0;
                        recvConn->TimeOfLastReceive = LdapGetTickCount();
                    }
                }
            }
        }

        connListEntry = connListEntry->Flink;
        DereferenceLdapConnection( recvConn );
    }

    //
    // We got out of select because someone woke us up by sending
    // data on the wakeup socket. We will now free that data.
    //


    if ((entries != 0) &&
        (waitErr == WSA_WAIT_TIMEOUT) &&
        (successfulReceives == 0)) {

             char dummy;
             int lastError;

             //
             // pull data from the wakeup socket until there is no more.
             //

             while ((waitErr != 0) && (waitErr != SOCKET_ERROR)) {

                waitErr = (*precv)( LdapGlobalWakeupSelectHandle,
                                    &dummy,
                                    sizeof(dummy),
                                    0 );
             }

           if (waitErr == SOCKET_ERROR) {

               lastError = (*pWSAGetLastError)();

               if (lastError == WSAEWOULDBLOCK) {

                  //
                  // All is well, reset the error back to the true cause
                  //

                  waitErr = WSA_WAIT_TIMEOUT;

               } else {

                  waitErr = lastError;

                  IF_DEBUG(NETWORK_ERRORS) {
                      LdapPrint2( "LdapDrainWinsock recving wakup data, err = 0x%x for conn 0x%x.\n",
                                  waitErr, recvConn);
                  }
               }
            }
    }

    RELEASE_LOCK( &ConnectionListLock );
    InterlockedExchange( (PLONG) &GlobalDrainWinsockThread, NULL);
    RELEASE_LOCK( &SelectLock1 );
    return ((successfulReceives == 0) ? waitErr : 0);

error:
    InterlockedExchange( (PLONG) &GlobalDrainWinsockThread, NULL);
    RELEASE_LOCK( &SelectLock1 );
    return err;
}

ULONG
DrainPendingCryptoStream (
    PLDAP_CONN Connection
    )
//
//  This routine takes any received buffers from the connection block that
//  have not yet been decrypted and tries to decrypt them.
//
//  Note that the connectionlistlock must be held coming in here.
//
{
    ULONG LdapError = LDAP_SUCCESS;
    PLIST_ENTRY pendingCrypto = Connection->PendingCryptoList.Flink;
    PSECURESTREAM pSecureStream = (PSECURESTREAM) Connection->SecureStream;
    PLDAP_RECVBUFFER buffer;

    if ( pSecureStream == NULL ) {

        return LDAP_SUCCESS;
    }

    //
    //  Loop through all crypto buffers that have not yet been processed and
    //  try to process them.  Note that we take into account that buffers may
    //  remain on the pending list multiple times by pulling from the head
    //  of the list each time.
    //

    while (pendingCrypto != &Connection->PendingCryptoList) {

        //
        // DecryptLdapReceive will put the data on the
        // CompletedReceiveList as is appropriate.
        //

        buffer = CONTAINING_RECORD( pendingCrypto,
                                    LDAP_RECVBUFFER,
                                    ReceiveListEntry );

        if (buffer->NumberOfBytesReceived == 0) {
            //
            // The server disconnected the connection. Set the
            // connection state to Error process the rest of the buffers.
            //
        
            RemoveEntryList( &buffer->ReceiveListEntry );
            LdapFreeReceiveStructure( buffer, TRUE );
            buffer = NULL;
            pendingCrypto = Connection->PendingCryptoList.Flink;
            Connection->HostConnectState = HostConnectStateError;
            continue;
        }

        LdapError = pSecureStream->DecryptLdapReceive( buffer );

        //
        //  DecryptLdapReceive handles moving the receive to the appropriate
        //  list.  If it returns failure, then we are probably out of memory
        //  and we must not try to process any more for now.
        //

        if ( LdapError != LDAP_SUCCESS ) {

            IF_DEBUG(NETWORK_ERRORS) {
                LdapPrint2( "DrainPendingCrypt failed decrypt, err = 0x%x for conn 0x%x.\n",
                            LdapError, Connection);
            }

            return LdapError;
        }

        //
        //  If the buffer hasn't been pulled from the pending list, we've got
        //  a loop.  Can't have that.
        //

        pendingCrypto = Connection->PendingCryptoList.Flink;
    }

    return LdapError;
}

VOID
LdapWakeupSelect (
    VOID
    )
//
//  This sends a short message to a socket that select() is waiting on to
//  bring it back up. We wakeup select whenever we are trying to create a
//  new connection or close a socket. SelectLock2 MUST be held before coming
//  into this function.
//
{
    //
    //  there's minimum locking around LdapGlobalWakeupSelectHandle so
    //  we're careful in how we use it.
    //

   char DummyData = 'd';

   if (InsideSelect == TRUE) {

        ASSERT( LdapGlobalWakeupSelectHandle != INVALID_SOCKET);

        IF_DEBUG(RECEIVEDATA) {
            LdapPrint1( "ldap_connect : waking up select on handle 0x%x\n",
                        LdapGlobalWakeupSelectHandle );
        }

        //
        // Simply send some dummy data to the wakeup socket. This is
        // guaranteed not to block
        //

        (*psend)( LdapGlobalWakeupSelectHandle,
                  &DummyData,
                  sizeof(DummyData),
                  0 );
    }

    return;
}

// receive.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\ping.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ping.cxx  check to see if an LDAP server is still around

Abstract:

   This module handles incoming data from an LDAP server

Author:

    Andy Herron (andyhe)        17-Jun-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ipexport.h>
#include <icmpapi.h>

typedef HANDLE (WINAPI *FICMPCREATEFILE) (
    VOID
    );

typedef BOOL (WINAPI *FICMPCLOSEHANDLE) (
    HANDLE IcmpHandle
    );

typedef DWORD (WINAPI *FICMPSENDECHO) (
    HANDLE                   IcmpHandle,
    IPAddr                   DestinationAddress,
    LPVOID                   RequestData,
    WORD                     RequestSize,
    PIP_OPTION_INFORMATION   RequestOptions,
    LPVOID                   ReplyBuffer,
    DWORD                    ReplySize,
    DWORD                    Timeout
    );

FICMPCREATEFILE pIcmpCreateFile = 0;
FICMPCLOSEHANDLE pIcmpCloseHandle = 0;
FICMPSENDECHO  pIcmpSendEcho = 0;

#define ICMP_REPLY_BUFFER_SIZE (sizeof(ICMP_ECHO_REPLY) + 128)

HINSTANCE IcmpLibraryHandle = NULL;

BOOLEAN
LoadPingLibrary(
    VOID
    );

ULONG
LdapPingServer(
    PLDAP_CONN      Connection
    )
{
    ULONG err = LDAP_SUCCESS;
    HANDLE icmpHandle = NULL;
    UCHAR request;
    ULONG waitTime = Connection->PingWaitTimeInMilliseconds;
    UCHAR replyBuffer[ICMP_REPLY_BUFFER_SIZE];

    if ((waitTime > 0) &&
        (LoadPingLibrary() == TRUE)) {

        icmpHandle = (*pIcmpCreateFile)();

        if (icmpHandle != NULL) {

            request = '?';

            err = (*pIcmpSendEcho)( icmpHandle,
                                    Connection->SocketAddress.sin_addr.s_addr,
                                    &request,
                                    1,              // request size
                                    NULL,
                                    &replyBuffer[0],
                                    ICMP_REPLY_BUFFER_SIZE,
                                    waitTime
                                  );

            if (err > 0) {

                err = LDAP_SUCCESS;

            } else {

                err = LDAP_TIMEOUT;
            }

            (*pIcmpCloseHandle)( icmpHandle );
        }
    }

    return err;
}

BOOLEAN
LoadPingLibrary(
    VOID
    )
{
    if (IcmpLibraryHandle != NULL) {

        return TRUE;
    }

    IcmpLibraryHandle = LoadLibraryA( "ICMP.DLL" );

    if (IcmpLibraryHandle != NULL) {

        pIcmpCreateFile = (FICMPCREATEFILE) GetProcAddress( IcmpLibraryHandle,
                                                            "IcmpCreateFile" );
        pIcmpCloseHandle = (FICMPCLOSEHANDLE) GetProcAddress(   IcmpLibraryHandle,
                                                            "IcmpCloseHandle" );
        pIcmpSendEcho = (FICMPSENDECHO) GetProcAddress(     IcmpLibraryHandle,
                                                            "IcmpSendEcho" );
        if ((pIcmpCreateFile == NULL) ||
            (pIcmpCloseHandle == NULL) ||
            (pIcmpSendEcho == NULL)) {

            UnloadPingLibrary();
        }
    }
    return ((IcmpLibraryHandle != NULL) ? TRUE : FALSE);
}

VOID
UnloadPingLibrary(
    VOID
    )
{
    if (IcmpLibraryHandle != NULL) {

        FreeLibrary( IcmpLibraryHandle );
        IcmpLibraryHandle = NULL;
    }
    return;
}

// ping.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\rename.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rename.cxx handle rename requests to an LDAP server

Abstract:

   This module implements the LDAP rename APIs.

Author:

    Andy Herron (andyhe)        02-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG
LdapRename (
    PLDAP_CONN connection,
    PWCHAR   DistinguishedName,
    PWCHAR   NewDistinguishedName,
    PWCHAR   NewParent,
    INT      DeleteOldRdn,
    BOOLEAN  Unicode,
    BOOLEAN  Synchronous,
    PLDAPControlW   *ServerControls,
    PLDAPControlW   *ClientControls,
    ULONG           *MessageNumber
    )
{
    ULONG hr;
    PLDAP_REQUEST request = NULL;
    ULONG messageNumber;
    ULONG err;

    if (MessageNumber == NULL) {

        return LDAP_PARAM_ERROR;
    }

    *MessageNumber = (ULONG) -1;


    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {
       return err;
    }

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    request = LdapCreateRequest( connection, LDAP_MODRDN_CMD );

    if (request == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap_rename connection 0x%x couldn't allocate request.\n", connection);
        }
        hr = LDAP_NO_MEMORY;
        SetConnectionError( connection, hr, NULL );
        return hr;
    }

    messageNumber = request->MessageId;

    request->Synchronous = Synchronous;

    hr = LDAP_SUCCESS;

    if ((ServerControls != NULL) || (ClientControls != NULL)) {

        hr = LdapCheckControls( request,
                                ServerControls,
                                ClientControls,
                                Unicode,
                                0 );

        if (hr != LDAP_SUCCESS) {

            IF_DEBUG(CONTROLS) {
                LdapPrint2( "ldap_comp connection 0x%x trouble with SControl, err 0x%x.\n",
                            connection, hr );
            }
        }
    }

    if (hr == LDAP_SUCCESS) {

        request->rename.DeleteOldRdn         = DeleteOldRdn;

        if (Synchronous || (request->ChaseReferrals == 0)) {

            request->AllocatedParms = FALSE;
            request->OriginalDN = DistinguishedName;
            request->rename.NewDistinguishedName = NewDistinguishedName;
            request->rename.NewParent            = NewParent;

        } else {

            request->AllocatedParms = TRUE;

            if (DistinguishedName != NULL) {

                request->OriginalDN = ldap_dup_stringW( DistinguishedName, 0, LDAP_UNICODE_SIGNATURE );

                if (request->OriginalDN == NULL) {

                    hr = LDAP_NO_MEMORY;
                }
            }

            if ((hr == LDAP_SUCCESS) && (NewDistinguishedName != NULL)) {

                request->rename.NewDistinguishedName = ldap_dup_stringW( NewDistinguishedName, 0, LDAP_UNICODE_SIGNATURE );

                if (request->rename.NewDistinguishedName == NULL) {

                    hr = LDAP_NO_MEMORY;
                }
            }

            if ((hr == LDAP_SUCCESS) && (NewParent != NULL)) {

                request->rename.NewParent = ldap_dup_stringW( NewParent, 0, LDAP_UNICODE_SIGNATURE );

                if (request->rename.NewParent == NULL) {

                    hr = LDAP_NO_MEMORY;
                }
            }
        }
    }

    if (hr == LDAP_SUCCESS) {

        hr = SendLdapRename( request,
                             connection,
                             request->OriginalDN,
                             (CLdapBer **)&request->BerMessageSent,
                             0 );
    }

    if (hr != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_rename connection 0x%x errored with 0x%x.\n",
                        connection, hr );
        }

        messageNumber = (ULONG) -1;
        SetConnectionError( connection, hr, NULL );

        CloseLdapRequest( request );
    }

    *MessageNumber = messageNumber;

    DereferenceLdapRequest( request );
    return hr;
}


ULONG
SendLdapRename (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection,
    PWCHAR DistinguishedName,
    CLdapBer **Lber,
    LONG AltMsgId
    )
//
//  A modifyRdn (rename) looks like this :
//
//     ModifyRDNRequest ::=
//         [APPLICATION 12] SEQUENCE {
//              entry          LDAPDN,
//              newrdn         RelativeLDAPDN,
//              deleteoldrdn   BOOLEAN
//         }
//
//
{
    PWCHAR  NewDistinguishedName = Request->rename.NewDistinguishedName;
    PWCHAR  NewParent = Request->rename.NewParent;
    INT     DeleteOldRdn = Request->rename.DeleteOldRdn;

    ULONG err;

    CLdapBer *lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

    if (lber == NULL) {
        SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
        return LDAP_NO_MEMORY;
    }

    err = lber->HrStartWriteSequence();
    if (err != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldap_modrdn startWrite conn 0x%x encoding error of 0x%x.\n",
                        Connection, err );
        }

        err = LDAP_ENCODING_ERROR;
        goto returnError;

    } else {            // we can't forget EndWriteSequence

       if (AltMsgId != 0) {

          err = lber->HrAddValue((LONG) AltMsgId );

       } else {

          err = lber->HrAddValue((LONG) Request->MessageId );
       }

       if (err != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_modrdn MsgNo conn 0x%x encoding error of 0x%x.\n",
                            Connection, err );
            }
            err = LDAP_ENCODING_ERROR;
            goto returnError;
        }

        err = lber->HrStartWriteSequence(LDAP_MODRDN_CMD);
        if (err != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_modrdn cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, err );
            }
            err = LDAP_ENCODING_ERROR;
            goto returnError;

        } else {        // we can't forget EndWriteSequence

            err = lber->HrAddValue((const WCHAR *) DistinguishedName );
            if (err != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_modrdn DN conn 0x%x encoding error of 0x%x.\n",
                                Connection, err );
                }
                err = LDAP_ENCODING_ERROR;
                goto returnError;
            }

            err = lber->HrAddValue((const WCHAR *)NewDistinguishedName );
            if (err != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_modrdn newDN conn 0x%x encoding error of 0x%x.\n",
                                Connection, err );
                }
                err = LDAP_ENCODING_ERROR;
                goto returnError;
            }

            err = lber->HrAddValue((BOOLEAN) DeleteOldRdn, BER_BOOLEAN );
            if (err != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_modrdn delOldRdn conn 0x%x encoding error of 0x%x.\n",
                                Connection, err );
                }
                err = LDAP_ENCODING_ERROR;
                goto returnError;
            }

            if ((Connection->publicLdapStruct.ld_version != LDAP_VERSION2) &&
                (NewParent != NULL)) {

                // 0x80 comes from context specific, primitive, optional tag 0

                err = lber->HrAddValue((const WCHAR *) NewParent, 0x80 );
                if (err != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "ldap_modrdn newDN conn 0x%x encoding error of 0x%x.\n",
                                    Connection, err );
                    }
                    err = LDAP_ENCODING_ERROR;
                    goto returnError;
                }
            }

            err = lber->HrEndWriteSequence();
            ASSERT( err == NOERROR );
        }

        //
        //  put in the server controls here if required
        //

        if ( (Connection->publicLdapStruct.ld_version != LDAP_VERSION2) &&
             ( Request->ServerControls != NULL )) {

            err = InsertServerControls( Request, Connection, lber );

            if (err != LDAP_SUCCESS) {

                if (lber != NULL) {

                   delete lber;
                }
                return err;
            }
        }

        err = lber->HrEndWriteSequence();
        ASSERT( err == NOERROR );
    }

    //
    //  send the modrdn request.
    //

    ACQUIRE_LOCK( &Connection->ReconnectLock );
    
    AddToPendingList( Request, Connection );

    err = LdapSend( Connection, lber );

    if (err != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "SendLdapRename connection 0x%x send with error of 0x%x.\n",
                        Connection, err );
        }
        DecrementPendingList( Request, Connection );

    } else {

        //
        //  Save off the lber value, free any lber message that is already
        //  present.
        //

        lber = (CLdapBer *) InterlockedExchangePointer((PVOID *) Lber,
                                                       (PVOID) lber );
    }

    RELEASE_LOCK( &Connection->ReconnectLock );


returnError:

    if (lber != NULL) {

       delete lber;
    }
    return err;
}

ULONG __cdecl
ldap_modrdn2W (
    LDAP    *ExternalHandle,
    PWCHAR   DistinguishedName,
    PWCHAR   NewDistinguishedName,
    INT     DeleteOldRdn
    )
{
    ULONG err;
    ULONG msgId = (ULONG) -1;
    PLDAP_CONN connection = NULL;
    PWCHAR generatedNewDN = NULL;
    PWCHAR startOfRDN = NULL;
    PWCHAR equalPointer = NULL;
    PWCHAR startOfParent = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (NewDistinguishedName == NULL)) {

        SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
        err = (ULONG) -1;
        goto error;
    }

    //
    //  We have to normalize the newDN as we need to determine the RDN and the
    //  parent.
    //

    err = ldap_ufn2dnW( NewDistinguishedName, &generatedNewDN );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        err = (ULONG) -1;
        goto error;
    }

    //
    //  we have to break up the new DN into two pieces... one is the new RDN,
    //  the other is the new parent, if present.  Two cases to cover:
    //
    //  1)  cn=bob                result is simply cn=bob with null parent
    //  2)  cn=bob,ou=foo,o=bar   result is cn=bob, parent is ou=foo,o=bar
    //

    err = ParseLdapToken(   generatedNewDN,
                            &startOfRDN,
                            &equalPointer,
                            &startOfParent );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        err = (ULONG) -1;
        goto error;
    }

    if (startOfParent != NULL) {

        if (*startOfParent == L',') {

            //
            //  slam a null in at end of first token.  We effectively
            //  turn CN=BOB,OU=NT,O=MS,C=US into two parts...
            //       CN=BOB  and OU=NT,O=MS,C=US
            //

            *startOfParent = L'\0';
            startOfParent++;
        }
        if (*startOfParent == L'\0') {
            startOfParent = NULL;
        }
    }

    err = LdapRename(    connection,
                         DistinguishedName,
                         startOfRDN,
                         startOfParent,
                         DeleteOldRdn,
                         TRUE,
                         FALSE,
                         NULL,
                         NULL,
                         &msgId
                         );

    SetConnectionError( connection, err, NULL );

error:
    if (generatedNewDN)
        ldapFree( generatedNewDN, LDAP_GENERATED_DN_SIGNATURE );

    if (connection)
        DereferenceLdapConnection( connection );

    return msgId;
}

ULONG __cdecl
ldap_modrdn2 (
    LDAP    *ExternalHandle,
    PCHAR   DistinguishedName,
    PCHAR   NewDistinguishedName,
    INT     DeleteOldRdn
    )
{
    ULONG err;
    PWCHAR wName = NULL;
    PWCHAR wNewName = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);
    if (connection == NULL) {

        return (ULONG) -1;
    }

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        err = (ULONG) -1;
        goto error;
    }

    err = ToUnicodeWithAlloc( NewDistinguishedName, -1, &wNewName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        err = (ULONG) -1;
        goto error;
    }

    err = ldap_modrdn2W( connection->ExternalInfo, wName, wNewName, DeleteOldRdn );

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wNewName)
        ldapFree( wNewName, LDAP_UNICODE_SIGNATURE );

    DereferenceLdapConnection( connection );

    return err;
}


ULONG __cdecl
ldap_modrdn2_sW (
    LDAP    *ExternalHandle,
    PWCHAR   DistinguishedName,
    PWCHAR   NewDistinguishedName,
    INT     DeleteOldRdn
    )
{
    ULONG err;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;
    ULONG msgId;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    msgId = ldap_modrdn2W(  connection->ExternalInfo,
                            DistinguishedName,
                            NewDistinguishedName,
                            DeleteOldRdn
                            );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  otherwise we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                    );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( connection->ExternalInfo,
                                     results,
                                     TRUE
                                     );
        }
    } else {

        err = connection->publicLdapStruct.ld_errno;
    }

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_modrdn2_s (
    LDAP    *ExternalHandle,
    PCHAR   DistinguishedName,
    PCHAR   NewDistinguishedName,
    INT     DeleteOldRdn
    )
{
    ULONG err;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;
    ULONG msgId;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    msgId = ldap_modrdn2(   connection->ExternalInfo,
                            DistinguishedName,
                            NewDistinguishedName,
                            DeleteOldRdn
                            );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  otherwise we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                    );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( connection->ExternalInfo,
                                     results,
                                     TRUE
                                     );
        }
    } else {

        err = connection->publicLdapStruct.ld_errno;
    }

    DereferenceLdapConnection( connection );

    return err;
}

//
//  The old style call modrdn is still supported.
//

ULONG __cdecl
ldap_modrdnW (
    LDAP    *ExternalHandle,
    PWCHAR   DistinguishedName,
    PWCHAR   NewDistinguishedName
    )
{
    return( ldap_modrdn2W( ExternalHandle,
                           DistinguishedName,
                           NewDistinguishedName,
                           1
                           ) );
}

ULONG __cdecl
ldap_modrdn (
    LDAP    *ExternalHandle,
    PCHAR   DistinguishedName,
    PCHAR   NewDistinguishedName
    )
{
    return( ldap_modrdn2( ExternalHandle,
                          DistinguishedName,
                          NewDistinguishedName,
                          1
                          ) );
}

ULONG __cdecl
ldap_modrdn_sW (
    LDAP    *ExternalHandle,
    PWCHAR   DistinguishedName,
    PWCHAR   NewDistinguishedName
    )
{
  return( ldap_modrdn2_sW( ExternalHandle,
                           DistinguishedName,
                           NewDistinguishedName,
                           1
                           ) );
}

ULONG __cdecl
ldap_modrdn_s (
    LDAP    *ExternalHandle,
    PCHAR   DistinguishedName,
    PCHAR   NewDistinguishedName
    )
{
    return( ldap_modrdn2_s( ExternalHandle,
                            DistinguishedName,
                            NewDistinguishedName,
                            1
                            ) );
}

ULONG __cdecl
ldap_rename_extW(
        LDAP *ExternalHandle,
        PWCHAR DistinguishedName,
        PWCHAR NewRDN,
        PWCHAR NewParent,
        INT DeleteOldRdn,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           *MessageNumber
        )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }


    err = LdapRename(   connection,
                        DistinguishedName,
                        NewRDN,
                        NewParent,
                        DeleteOldRdn,
                        TRUE,
                        FALSE,
                        ServerControls,
                        ClientControls,
                        MessageNumber
                        );

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_rename_extA(
        LDAP *ExternalHandle,
        PCHAR DistinguishedName,
        PCHAR NewRDN,
        PCHAR NewParent,
        INT DeleteOldRdn,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        ULONG           *MessageNumber
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    ULONG msgId = (ULONG) -1;
    PLDAP_CONN connection = NULL;
    PWCHAR wNewRDN = NULL;
    PWCHAR wNewParent = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (MessageNumber == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *MessageNumber = (ULONG) -1;

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
        goto error;
    }

    err = ToUnicodeWithAlloc( NewRDN, -1, &wNewRDN, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
        goto error;
    }

    if (NewParent != NULL) {

        err = ToUnicodeWithAlloc( NewParent, -1, &wNewParent, LDAP_UNICODE_SIGNATURE, LANG_ACP );

        if (err != LDAP_SUCCESS) {

            SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
            goto error;
        }
    }

    err = LdapRename(    connection,
                         wName,
                         wNewRDN,
                         wNewParent,
                         DeleteOldRdn,
                         FALSE,
                         FALSE,
                         (PLDAPControlW *) ServerControls,
                         (PLDAPControlW *) ClientControls,
                         &msgId
                         );

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wNewRDN)
        ldapFree( wNewRDN, LDAP_UNICODE_SIGNATURE );

    if (wNewParent)
        ldapFree( wNewParent, LDAP_UNICODE_SIGNATURE );

    if (connection)
        DereferenceLdapConnection( connection );

    if (MessageNumber) {
        *MessageNumber = msgId;
    }

    return err;
}

ULONG __cdecl
ldap_rename_ext_sW(
        LDAP *ExternalHandle,
        PWCHAR DistinguishedName,
        PWCHAR NewRDN,
        PWCHAR NewParent,
        INT DeleteOldRdn,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls
        )
{
    ULONG msgId;
    ULONG err;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapRename(  connection,
                       DistinguishedName,
                       NewRDN,
                       NewParent,
                       DeleteOldRdn,
                       TRUE,
                       TRUE,
                       ServerControls,
                       ClientControls,
                       &msgId
                       );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                      );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( connection->ExternalInfo,
                                     results,
                                     TRUE
                                     );
        }
    }

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_rename_ext_sA(
        LDAP *ExternalHandle,
        PCHAR DistinguishedName,
        PCHAR NewRDN,
        PCHAR NewParent,
        INT DeleteOldRdn,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    ULONG msgId;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;
    PWCHAR wNewRDN = NULL;
    PWCHAR wNewParent = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    err = ToUnicodeWithAlloc( NewRDN, -1, &wNewRDN, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    if (NewParent != NULL) {

        err = ToUnicodeWithAlloc( NewParent, -1, &wNewParent, LDAP_UNICODE_SIGNATURE, LANG_ACP );

        if (err != LDAP_SUCCESS) {

            goto error;
        }
    }

    err = LdapRename(    connection,
                         wName,
                         wNewRDN,
                         wNewParent,
                         DeleteOldRdn,
                         FALSE,
                         TRUE,
                         (PLDAPControlW *) ServerControls,
                         (PLDAPControlW *) ClientControls,
                         &msgId
                         );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  otherwise we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                    );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( connection->ExternalInfo,
                                     results,
                                     TRUE
                                     );
        }
    }

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wNewRDN)
        ldapFree( wNewRDN, LDAP_UNICODE_SIGNATURE );

    if (wNewParent)
        ldapFree( wNewParent, LDAP_UNICODE_SIGNATURE );

    DereferenceLdapConnection( connection );

    return err;
}

// rename.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\precomp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ldap32.h   LDAP client 32 API header file

Abstract:

   This module is the header file for the 32 bit LDAP client API.

Author:

    Andy Herron (andyhe)        08-May-1996

Revision History:

--*/

#ifndef LDAP_CLIENT_PRECOMP_DEFINED
#define LDAP_CLIENT_PRECOMP_DEFINED

#ifdef __cplusplus
extern "C" {
#endif

#define INCL_WINSOCK_API_TYPEDEFS 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windef.h>
#include <windows.h>
#include <winsock2.h>
#include <svcguid.h>
#include <wtypes.h>
#include <stdlib.h>     // for malloc and free
#include <mmsystem.h>

#define SECURITY_WIN32 1

#include <security.h>
#include <kerberos.h>
#include <dsgetdc.h>
#include <ntdsapi.h>
#include <dsrole.h>

#include <crypt.h>
#include <des.h>

#define LDAP_UNICODE 0
#define _WINLDAP_ 1
#include <winldap.h>
#define _WINBER_ 1
#include <winber.h>

#include "lmacros.h"
#include "globals.h"
#include "ldapp.h"
#include "debug.h"
#include "ldapstr.h"
//
//  This is in schnlsp.h, but since this isn't in the 4.0 QFE tree, we'll plop
//  it here.
//

#ifndef SEC_I_INCOMPLETE_CREDENTIALS

#define SEC_I_INCOMPLETE_CREDENTIALS      ((HRESULT)0x00090320L)

#endif

#ifdef __cplusplus
}
#endif

#endif  // LDAP_CLIENT_PRECOMP_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\referral.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    referral.c    handle referrerals from an LDAP server

Abstract:

   This module handles referrals

Author:

    Andy Herron    (andyhe)        19-Aug-1996
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

#define LDAP_SCOPE_UNDEFINED  0x03

ULONG
LdapChaseReferral (
    PLDAP_REQUEST Request,
    PLDAPMessage ResultMessage,
    PWCHAR HostAddr,
    PWCHAR NewDN,
    USHORT PortNumber,
    BOOLEAN FromSubordinateReferral,
    BOOLEAN Ssl
    );

ULONG
HandleReferral (
    PLDAP_CONN Connection,
    PLDAPMessage  SearchEntry,
    PLDAP_REQUEST Request
    );

ULONG
CheckForExistingReferral (
    PLDAP_REQUEST Request,
    PWCHAR HostAddr,
    USHORT PortNumber,
    PWCHAR NewDN
    );

BOOLEAN
DoSigningOptionsMatch(
    PLDAP_CONN pPrimary,
    PLDAP_CONN pReferral
    );

BOOLEAN
DoCredentialsMatch(
    PLDAP_CONN pReferral,
    DWORD BindMethod,
    CredHandle * pcomparisonHandle,
    PWCHAR comparisonBindName,
    PWCHAR comparisonBindPwd    
    );


#define LDAP_V2_URL_SEPARATOR ((USHORT) 0x0A)


ULONG
HandleReferrals (
    PLDAP_CONN Connection,
    PLDAPMessage *FirstSearchEntry,
    PLDAP_REQUEST Request
    )
//
//  The request and connection are both refererenced coming in here,
//  we don't have to worry about them going away.
//
//  This routine does the following :
//
//  Strip out all referrals from the current set of results
//  For each referral, try to chase it.
//
{
    ULONG hr = LDAP_LOCAL_ERROR;
    PLDAPMessage msg;
    ULONG referralsChased = 0;

    PLDAPMessage referralListHead = NULL;
    PLDAPMessage nonReferralListHead = NULL;
    PLDAPMessage referralListLast = NULL;
    PLDAPMessage nonReferralListLast = NULL;

    PLDAPMessage searchResultDoneList = NULL;
    PLDAPMessage searchResultDoneLast = NULL;

    PLDAPMessage EomMessage = NULL;

    IF_DEBUG(REFERRALS) {
        LdapPrint2( "HandleReferrels looking at request 0x%x, number 0x%x\n",
                        Request, Request->MessageId );
    }

    if (Request->ChaseReferrals == 0) {

        goto exitReferral;
    }

    //
    //  traverse the list of results and pull out all those that have
    //  referrals but have not yet been chased.  We do this by separating it
    //  out into two different lists... one of referrals, the other not.
    //

    msg = *FirstSearchEntry;

    while (msg != NULL) {

        PLDAPMessage nextOne = msg->lm_chain;
        msg->lm_chain = NULL;

        if (msg->lm_eom == TRUE) {

            EomMessage = msg;
        }

        //
        //  if we've already chased it OR it's a search result entry OR
        //  the return code is not referral, stick it on the non-referral list
        //

        if ((msg->lm_chased == TRUE ) ||
            (msg->lm_msgtype == LDAP_RES_SEARCH_ENTRY) ||
            ((msg->lm_msgtype != LDAP_RES_REFERRAL) &&
             (msg->lm_returncode != LDAP_REFERRAL) &&
             (msg->lm_returncode != LDAP_REFERRAL_V2))) {

            if (msg->lm_msgtype == LDAP_RES_SEARCH_RESULT) {

                if (searchResultDoneList == NULL) {

                    searchResultDoneList= msg;

                } else {

                    searchResultDoneLast->lm_chain = msg;
                }
                searchResultDoneLast = msg;

            } else {

                if (nonReferralListHead == NULL) {

                    nonReferralListHead = msg;

                } else {

                    nonReferralListLast->lm_chain = msg;
                }
                nonReferralListLast = msg;
            }

        } else {



            //
            //  otherwise, we stick it on the referral list
            //

            if (referralListHead == NULL) {

                referralListHead = msg;

            } else {

                referralListLast->lm_chain = msg;
            }
            referralListLast = msg;
        }
        msg = nextOne;
    }

    if (referralListHead == NULL) {

        //
        //  there are no referrals or we've chased them all, just return.
        //  note that all though we've redone the list, it should be in the
        //  exact same order it started in.
        //

        IF_DEBUG(REFERRALS) {
            LdapPrint2( "HandleReferrels no referrals for request 0x%x, number 0x%x\n",
                            Request, Request->MessageId );
        }
        goto exitReferral;
    }

    while (referralListHead != NULL) {

        PLDAPMessage nextReferral = referralListHead->lm_chain;
        referralListHead->lm_chain = NULL;

        referralListHead->lm_chased = TRUE;

        hr = HandleReferral( Connection, referralListHead, Request );

        if (hr == LDAP_SUCCESS) {

            referralsChased++;

            IF_DEBUG(REFERRALS) {
                LdapPrint2( "HandleReferrels successfully chased referral for 0x%x, number 0x%x\n",
                                Request, Request->MessageId );
            }

            if (EomMessage == referralListHead) {

                //
                //  Since we handled a referral, unmark the EOM marker on the
                //  last record, if there was one marked.
                //

                IF_DEBUG(REFERRALS) {
                    LdapPrint1( "HandleReferrals unmarking EOM for request 0x%x\n",
                                 Request );
                } else {
                    IF_DEBUG(EOM) {
                        LdapPrint2( "HandleReferrals unmarking EOM for request 0x%x, msg 0x%x\n",
                                     Request, EomMessage );
                    }
                }

                EomMessage->lm_eom = FALSE;
                EomMessage = NULL;
            }

            ldap_msgfree( referralListHead );

        } else {

            //
            //  put it on list of non referral messages since it failed.
            //

            IF_DEBUG(REFERRALS) {
                LdapPrint3( "HandleReferrels chasing referral for 0x%x, number 0x%x returned 0x%x\n",
                                Request, Request->MessageId, hr );
            }

            if (nonReferralListHead == NULL) {

                nonReferralListHead = referralListHead;

            } else {

                nonReferralListLast->lm_chain = referralListHead;
            }
            nonReferralListLast = referralListHead;
        }

        referralListHead = nextReferral;
    }

exitReferral:

    //
    //  Put the nonreferral results back on the pending list for the request
    //  iff we successfully chased a referral.
    //

    if (referralsChased > 0) {

        hr = LDAP_SUCCESS;

        if (nonReferralListLast != NULL) {

            ACQUIRE_LOCK( &Request->Lock );

            IF_DEBUG(REFERRALS) {
                LdapPrint1( "HandleReferrals putting msgs back on request 0x%x\n",
                             Request );
            }

            nonReferralListLast->lm_chain = Request->MessageLinkedList;
            Request->MessageLinkedList = nonReferralListHead;

            RELEASE_LOCK( &Request->Lock );
        }

        if (EomMessage != NULL) {

            //
            //  Since we handled a referral, unmark the EOM marker on the
            //  last record, if there was one marked.
            //

            IF_DEBUG(REFERRALS) {
                LdapPrint1( "HandleReferrals unmarking EOM for request 0x%x\n",
                             Request );
            } else {
                IF_DEBUG(EOM) {
                    LdapPrint2( "HandleReferrals unmarking EOM for request 0x%x, msg 0x%x\n",
                                 Request, EomMessage );
                }
            }

            EomMessage->lm_eom = FALSE;
        }

        //
        //  if the request has been marked closed, reopen it.  This is because
        //  a thread could have come along while we were processing the
        //  referral and marked it as closed because it thought it was the
        //  end of the responses.
        //

        if (Request->Closed == TRUE) {

            ACQUIRE_LOCK( &Request->Lock );

            if ((Request->Closed == TRUE) &&
                (Request->ResponsesOutstanding > 0)) {

                Request = ReferenceLdapRequest( Request );
                
                ASSERT ( Request );
                
                Request->Closed = FALSE;
                
                IF_DEBUG(REQUEST) {
                    LdapPrint1( "HandleReferrals reopening request 0x%x.\n", Request );
                }
            }
            
            RELEASE_LOCK( &Request->Lock );
        }

        ldap_msgfree( searchResultDoneList );

        //
        //  since we put the responses back on the request block, tell the caller
        //  that it no longer has results.
        //

        *FirstSearchEntry = NULL;

    } else {

        hr = LDAP_LOCAL_ERROR;

        //
        //  we give the responses back to the caller
        //

        if (nonReferralListLast != NULL) {

            nonReferralListLast->lm_chain = searchResultDoneList;

        } else {

            nonReferralListHead = searchResultDoneList;
        }

        *FirstSearchEntry = nonReferralListHead;
    }

    return hr;
}

ULONG
HandleReferral (
    PLDAP_CONN Connection,
    PLDAPMessage ResultMessage,
    PLDAP_REQUEST Request
    )
//
//  The request and connection are both refererenced coming in here,
//  we don't have to worry about them going away.
//
//  This routine does the following :
//
//  - check for a valid ldapv2 or set of ldapv3 referrals
//  - look for a connection to the referred server
//  - if none exist, create a connection to the referred server
//  - update the request block to reference the referred server
//  - send the request to the referred server
//  - return success
//
//
{
    ULONG hr = LDAP_LOCAL_ERROR;
    PWCHAR referralString = NULL;
    CLdapBer *lber = NULL;
    ULONG referralsChased = 0;
    PWCHAR referral;        // points to current location in referral
    USHORT  port;

    ASSERT( ResultMessage->lm_next == NULL );
    ASSERT( ResultMessage->lm_chain == NULL );

    //
    //  check for a referral included in the response.
    //

    lber = (CLdapBer *) (ResultMessage->lm_ber);

    if (lber == NULL) {

        IF_DEBUG(REFERRALS) {
            LdapPrint1( "HandleReferral no ber to decode for 0x%x\n",
                         Request );
        }
        goto exitReferral;
    }

    if ((ResultMessage->lm_msgtype != LDAP_RES_REFERRAL) &&
        (ResultMessage->lm_returncode == LDAP_REFERRAL_V2)) {

        if (Request->ReceivedData) {

            if ((Request->ChaseReferrals & LDAP_CHASE_SUBORDINATE_REFERRALS) == 0) {

                IF_DEBUG(REFERRALS) {
                    LdapPrint1( "HandleReferral not handling subordinate for 0x%x\n",
                                 Request );
                }
                goto exitReferral;
            }
        } else {

            if ((Request->ChaseReferrals & LDAP_CHASE_EXTERNAL_REFERRALS) == 0) {

                IF_DEBUG(REFERRALS) {
                    LdapPrint1( "HandleReferral not handling external for 0x%x\n",
                                 Request );
                }
                goto exitReferral;
            }
        }

        lber->Reset(FALSE);

        hr = LdapInitialDecodeMessage( Connection, ResultMessage );

        if (hr != NOERROR) {

            IF_DEBUG(REFERRALS) {
                LdapPrint2( "HandleReferral error 0x%x while decoding referral for 0x%x\n",
                             hr, Request );
            }
            goto exitReferral;
        }

        //
        //  LdapInitialDecodeMessage left the message half
        //  decoded...  we're sitting right at the matchedDN
        //
        //  matchedDN     LDAPDN,
        //  errorMessage  LDAPString... this is
        //                  "Referral0x0AText"
        //

        hr = lber->HrSkipElement();

        if (hr != NOERROR) {

            IF_DEBUG(REFERRALS) {
                LdapPrint2( "HandleReferral error 0x%x while skipping matchedDN for 0x%x\n",
                             hr, Request );
            }
            goto exitReferral;
        }

        hr = lber->HrGetValueWithAlloc( &referralString );

        if (hr != NOERROR || referralString == NULL) {

            IF_DEBUG(REFERRALS) {
                LdapPrint2( "HandleReferral error 0x%x while getting referral for 0x%x\n",
                             hr, Request );
            }
            goto exitReferral;
        }

        //
        //  If we didn't get a string back or if the string is different than
        //  "Referral"+0x0a, then we bail.
        //

        if ((referralString == NULL) ||
            (ldapWStringsIdentical( referralString,
                                    sizeof("Referral:")-1,
                                    L"Referral:",
                                    sizeof("Referral:")-1 ) == FALSE) ||
             (*(referralString+sizeof("Referral:")-1) == L'\0')) {

            IF_DEBUG(REFERRALS) {
                LdapPrint1( "HandleReferral not proper v2 referral for 0x%x\n",
                             Request );
            }
            hr = LDAP_LOCAL_ERROR;
            goto exitReferral;
        }

        referral = referralString + sizeof("Referral:")-1 + 1; // skip "Referral:/0x0A"

        IF_DEBUG(REFERRALS) {
            LdapPrint2( "HandleReferral chasing %S for request 0x%x\n",
                         referral, Request );
        }

        //
        //  we've got a referral here or maybe even a set of referrals.
        //  it is null terminated but could be multiple URLs separated
        //  by 0x0A (new line).
        //

        while ((referral != NULL) && (*referral != L'\0')) {

            BOOLEAN ssl = FALSE;

            if (ldapWStringsIdentical( referral,
                                       sizeof("ldap://")-1,
                                       L"ldap://",
                                       sizeof("ldap://")-1 ) == FALSE) {

                if (ldapWStringsIdentical( referral,
                                           sizeof("ldaps://")-1,
                                           L"ldaps://",
                                           sizeof("ldaps://")-1 ) == FALSE) {

                    //
                    // we've got a referral here that is not an LDAP referral.
                    // just skip it to see if there perhaps an LDAP URL following it.
                    //

                    while (*referral != LDAP_V2_URL_SEPARATOR &&
                           *referral != L'\0') {
                        referral++;
                    }

                    if (*referral == LDAP_V2_URL_SEPARATOR) {
                        referral++;
                    }

                    IF_DEBUG(REFERRALS) {
                        LdapPrint1( "HandleReferral non ldap referral skipped for 0x%x\n",
                                     Request );
                    }
                    continue;           // go check the next referral
                }

                ssl = TRUE;
                referral += sizeof("ldaps://")-1;      // skip "ldaps://"

            } else {

                referral += sizeof("ldap://")-1;      // skip "ldap://"
            }

            PWCHAR hostAddr = referral;
            PWCHAR newDN = NULL;

            //
            //  the URL is of the following forms :
            //    "hostaddr/DN"
            //    "hostaddr:port/DN"
            //    "hostaddr:port"
            //    "hostaddr"
            //
            //  find the end of the hostname and replace with a 0x00 to
            //  end it and begin DN.
            //

            while (*referral != L'/' &&
                   *referral != L'\\' &&
                   *referral != L':' &&
                   *referral != LDAP_V2_URL_SEPARATOR &&
                   *referral != L'\0') {
                referral++;
            }

            port = 0;

            if (*referral == L':') {

                *referral = L'\0';
                referral++;

                while (*referral != L'\0' &&
                       *referral != L'/' &&
                       *referral != L'\\' &&
                       *referral != LDAP_V2_URL_SEPARATOR) {

                    if (*referral >= L'0' &&
                        *referral <= L'9') {

                        port = (port * 10) + (*referral - L'0');
                    }
                    referral++;
                }
            }
            if (port == 0) {

                if (ssl || Request->PrimaryConnection->SslPort) {

                    port = LDAP_SERVER_PORT_SSL;

                } else {

                    port = LDAP_SERVER_PORT;
                }
            }

            if (*referral == L'/' || *referral == L'\\') {

                *referral = L'\0';
                referral++;

                if (*referral != L'\0' &&
                    *referral != LDAP_V2_URL_SEPARATOR) {

                    newDN = referral;

                    //
                    //  go to the end of the referral and replace 0x0A with
                    //  a 0x00 if it exists
                    //

                    while (*referral != LDAP_V2_URL_SEPARATOR &&
                           *referral != L'\0') {

                        referral++;
                    }

                    if (*referral != L'\0') {

                        *referral = L'\0';
                        referral++;
                    }
                }
            }

            //
            //  now that we have the new host name and possibly DN, chase
            //  the referral
            //
            //  note that if we've received any responses for this v2 request,
            //  then we should consider this a subordinate referral rather
            //  than external referral.  There is no subordinate referral in
            //  ldapv2, but if we've received search results, we can assume it.
            //

            hr = LdapChaseReferral( Request,
                                    ResultMessage,
                                    hostAddr,
                                    newDN,
                                    port,
                                    Request->ReceivedData,
                                    ssl );

            if (hr == LDAP_SUCCESS) {

                //
                //  if we succeeded in chasing one of these referrals, then
                //  we break out of the loop as we've followed one of them.
                //

                referralsChased++;
                break;
            }

            // on to next one
        }

    } else if ((ResultMessage->lm_msgtype == LDAP_RES_REFERRAL) ||
               (ResultMessage->lm_returncode == LDAP_REFERRAL)) {

        BOOLEAN fromSubordinateReferral;

        if (ResultMessage->lm_msgtype == LDAP_RES_REFERRAL) {

            if ((Request->ChaseReferrals & LDAP_CHASE_SUBORDINATE_REFERRALS) == 0) {

                IF_DEBUG(REFERRALS) {
                    LdapPrint1( "HandleReferral not handling subordinate for 0x%x\n",
                                 Request );
                }
                goto exitReferral;
            }

            fromSubordinateReferral = TRUE;

        } else {

            if ((Request->ChaseReferrals & LDAP_CHASE_EXTERNAL_REFERRALS) == 0) {

                IF_DEBUG(REFERRALS) {
                    LdapPrint1( "HandleReferral not handling external for 0x%x\n",
                                 Request );
                }
                goto exitReferral;
            }

            fromSubordinateReferral = FALSE;
        }

        lber->Reset(FALSE);

        hr = LdapInitialDecodeMessage( Connection, ResultMessage );

        if (hr != NOERROR) {

            IF_DEBUG(REFERRALS) {
                LdapPrint2( "HandleReferral error 0x%x while decoding referral for 0x%x\n",
                             hr, Request );
            }
            goto exitReferral;
        }

        //
        //  Two cases to consider here... a search result entry that is a
        //  referral type response or a general result from the server that
        //  contains a referral and a referral return code.  There's not much
        //  to handle in the former case, since the initial decode left us
        //  at the start of the referrals.
        //

        if (ResultMessage->lm_msgtype != LDAP_RES_REFERRAL) {

            //
            //  LdapInitialDecodeMessage left the message half
            //  decoded...  we're sitting right at the matchedDN
            //
            //  matchedDN     LDAPDN,
            //  errorMessage  LDAPString
            //  referral      [3] SEQUENCE OF LDAPURL
            //

            hr = lber->HrSkipElement();     // skip matched DN

            if (hr != NOERROR) {

                IF_DEBUG(REFERRALS) {
                    LdapPrint2( "HandleReferral error 0x%x while skipping matchedDN for 0x%x\n",
                                 hr, Request );
                }
                goto exitReferral;
            }

            hr = lber->HrSkipElement();     // skip error message

            if (hr != NOERROR) {

                IF_DEBUG(REFERRALS) {
                    LdapPrint2( "HandleReferral error 0x%x while skipping errmsg for 0x%x\n",
                                 hr, Request );
                }
                goto exitReferral;
            }

            hr = lber->HrStartReadSequence( 0xA3L ); // context specific + constructed : Referral
            if (hr != NOERROR) {

                IF_DEBUG(REFERRALS) {
                    LdapPrint2( "HandleReferral error 0x%x while parsing referral 0x%x\n",
                                 hr, Request );
                }
                goto exitReferral;
            }
        }

        while (1) {

            BOOLEAN ssl = FALSE;
            ULONG hrTemp;

            if (referralString != NULL) {

                ldapFree( referralString, LDAP_VALUE_SIGNATURE );
                referralString = NULL;
            }

            hrTemp = lber->HrGetValueWithAlloc( &referralString );

            if (hrTemp != NOERROR || referralString == NULL) {

                IF_DEBUG(REFERRALS) {
                    LdapPrint2( "HandleReferral error 0x%x while reading referral 0x%x\n",
                                 hrTemp, Request );
                }
                break;
            }

            referral = referralString;

            IF_DEBUG(REFERRALS) {
                LdapPrint2( "HandleReferral chasing %S for request 0x%x\n",
                             referral, Request );
            }

            if (ldapWStringsIdentical( referral,
                                       sizeof("ldap://")-1,
                                       L"ldap://",
                                       sizeof("ldap://")-1 ) == FALSE) {

                if (ldapWStringsIdentical( referral,
                                           sizeof("ldaps://")-1,
                                           L"ldaps://",
                                           sizeof("ldaps://")-1 ) == FALSE) {

                    continue;           // go check the next referral

                }

                ssl = TRUE;
                referral += sizeof("ldaps://")-1;      // skip "ldaps://"

            } else {

                referral += sizeof("ldap://")-1;      // skip "ldap://"
            }

            PWCHAR hostAddr = referral;
            PWCHAR newDN = NULL;

            //
            //  the URL is of the following forms :
            //    "hostaddr/DN"
            //    "hostaddr:port/DN"
            //    "hostaddr:port"
            //    "hostaddr"
            //
            //  find the end of the hostname and replace with a 0x00 to
            //  end it and begin DN.
            //
            // AnoopA: The new LDAP URL is of the type
            //
            //  ldap://[<servername>:<port>][/<dn>[?[<attrib>[?[<scope>[?[<filter>[?[<extension>]]]]]]]]]
            //

            while (*referral != L'/' &&
                   *referral != L':' &&
                   *referral != L'\0') {
                referral++;
            }

            port = 0;

            if (*referral == L':') {

                *referral = L'\0';
                referral++;

                while (*referral != L'\0' &&
                       *referral != L'\\' &&
                       *referral != L'/') {

                    if (*referral >= L'0' &&
                        *referral <= L'9') {

                        port = (port * 10) + (*referral - L'0');
                    }
                    referral++;
                }
            }
            if (port == 0) {

                if (ssl || Request->PrimaryConnection->SslPort) {

                    port = LDAP_SERVER_PORT_SSL;

                } else {

                    port = LDAP_SERVER_PORT;
                }
            }

            if (*referral == L'/' || *referral == L'\\') {

                *referral = L'\0';
                referral++;

                if (*referral != L'\0') {

                    newDN = referral;
                }
            }

            hr = LdapChaseReferral( Request,
                                    ResultMessage,
                                    hostAddr,
                                    newDN,
                                    port,
                                    fromSubordinateReferral,
                                    ssl );

            if (hr == LDAP_SUCCESS) {
                //
                //  if we succeeded in chasing one of these referrals, then
                //  we break out of the loop as we've followed one of them.
                //

                referralsChased++;
                break;
            }
        }
    }

exitReferral:
    //
    //  Coming down to here, referralsChased is the number of successful
    //  referrals we've chased and hr is the error code if they all failed.
    //

    if (referralsChased > 0) {

        hr = LDAP_SUCCESS;

    } else {

        if ( hr == LDAP_SUCCESS ) {

            hr = LDAP_LOCAL_ERROR;
        }
    }

    if (referralString != NULL) {

        IF_DEBUG(REFERRALS) {
            LdapPrint3( "HandleReferral result 0x%x for request 0x%x while handling %S\n",
                         hr, Request, referralString );
        }

        ldapFree( referralString, LDAP_VALUE_SIGNATURE );

    } else {

        IF_DEBUG(REFERRALS) {
            LdapPrint2( "HandleReferral returning error of 0x%x for request 0x%x\n",
                         hr, Request );
        }
    }

    return hr;
}


ULONG
LdapChaseReferral (
    PLDAP_REQUEST Request,
    PLDAPMessage ResultMessage,
    PWCHAR HostAddr,
    PWCHAR NewUrlDN,
    USHORT PortNumber,
    BOOLEAN FromSubordinateReferral,
    BOOLEAN Ssl
    )
{
    ULONG hr;
    PREFERRAL_TABLE_ENTRY refTable;
    PLDAP_CONN newConnection = NULL;
    PLDAP_CONN originatingConnection = NULL;
    ULONG err;
    PWCHAR mappedHostAddrW = NULL;
    PCHAR  mappedHostAddrA = NULL;
    PWCHAR newDN = NewUrlDN;
    PREFERRAL_TABLE_ENTRY originalEntry;
    PWCHAR newReferralDN;
    PLIST_ENTRY listEntry;
    PLDAP_CONN searchConn;
    PLDAP_CONN primaryConn = NULL;
    USHORT referralNumber;

    BOOLEAN haveLock = FALSE;
    BOOLEAN searchWasSingleLevel = FALSE;
    BOOLEAN updatedReferralHandleCount = FALSE;
    BOOLEAN fNeedToRescramble = FALSE;    
    QUERYFORCONNECTION *queryRoutine = NULL;
    NOTIFYOFNEWCONNECTION *notifyRoutine = NULL;
    DEREFERENCECONNECTION *dereferenceRoutine = NULL;
    LDAPReferralDN *pldapRefDN = NULL;
    PLDAP_CONN tempConn;

    BOOLEAN callDerefCallback = FALSE;

    PCHAR copyOfPrimaryCreds = NULL;

    USHORT i;
    PREFERRAL_TABLE_ENTRY workingEntry;

    //
    // If the referral is of the form LDAP://gc._msdcs.<DnsForest>, we have to 
    // special case it and strip off the "gc._msdcs." prefix.
    //

    #define GC_PREFIX      "gc._msdcs."
    #define GC_PREFIXW    L"gc._msdcs."
    
    if (ldapWStringsIdentical( HostAddr,
                               (LONG)min( sizeof(GC_PREFIX)-1, strlenW( HostAddr ) ),
                               GC_PREFIXW,
                               -1)) {
        //
        // Slide the hostname to the left thus, stripping off the prefix.
        //

        IF_DEBUG(REFERRALS) {
            LdapPrint1("Preprocessing GC referral to %S\n", HostAddr);
        }

        ldap_MoveMemory( (PCHAR)HostAddr,
                         (PCHAR)HostAddr + ((sizeof(GC_PREFIX)-1) * sizeof(WCHAR)),
                         (strlenW(HostAddr) - sizeof(GC_PREFIX) + 2) * sizeof(WCHAR) // len of str after prefix including \0
                         );
        
        IF_DEBUG(REFERRALS) {
            LdapPrint1("Chasing GC referral to %S instead\n", HostAddr);
        }
    }

    hr = FromUnicodeWithAlloc( HostAddr,
                               &mappedHostAddrA,
                               LDAP_ANSI_SIGNATURE,
                               LANG_ACP );

    mappedHostAddrW = ldap_dup_stringW(HostAddr, 0, LDAP_UNICODE_SIGNATURE);

    if (( mappedHostAddrW == NULL ) || (hr != NO_ERROR)) {

        goto exitReferral;
    }

    #if 0
    DebugReferralOutput( Request,
                         HostAddr,
                         NewUrlDN
                         );
    #endif

    //
    //  Go through the DN that came in on the URL and convert from the
    //  URL encoded form back to the DN by removing all %nn to 0xnn char
    //  Also, parse out the new style parameters.
    //

    if (NewUrlDN != NULL) {

        PWCHAR source = NewUrlDN;
        PWCHAR dest = NewUrlDN;

        while (*source != L'\0') {

            WCHAR ch = *(source++);

            if (ch == L'%') {

                //
                //  we convert %nn to the 0xnn character, despite the fact that
                //  we have a unicode string here
                //

                WCHAR upperNibble;
                WCHAR lowerNibble;

                upperNibble = *source;

                if (upperNibble == L'\0') {
                    break;
                }
                lowerNibble = *(source+1);

                if (lowerNibble == L'\0') {
                    break;
                }

                if ((HIBYTE(upperNibble) == 0) && (HIBYTE(lowerNibble) == 0)) {

                    UCHAR upNibble = LOBYTE( upperNibble );
                    UCHAR loNibble = LOBYTE( lowerNibble );

                    if ((ISHEX(upNibble) == TRUE) &&
                        (ISHEX(loNibble) == TRUE)) {

                        UCHAR c = (MAPHEXTODIGIT( upNibble ) << 4 ) |
                                   MAPHEXTODIGIT( loNibble );

                        source += 2;
                        ch = MAKEWORD( c, 0 );

                        if (ch == L'?') {

                            //
                            // Escape the ? in the DN/Filter as per RFC 2253 (sec 2.4)
                            // so that our DN parsing routine doesn't get confused.
                            // We know for sure that a ? cannot appear inside an
                            // AttributeDescription (RFC 2251 sec 4.1.4). It is ok to
                            // send these escaped characters on the wire as is.
                            //

                            *(dest++) = L'\\';
                            *(dest++) = L'3';
                            *(dest++) = L'F';
                            continue;
                        }
                    }
                }
            }

            *(dest++) = ch;
        }

        *dest = L'\0';

        if (*(newDN) == L'\0') {

            newDN = NULL;
        }
    }

    //
    // We will attempt to parse the entire DN, complete with the options
    //

    if (newDN) {

        pldapRefDN = LdapParseReferralDN( newDN );

        if (!pldapRefDN) {

            goto exitReferral;
        }
    }

    ACQUIRE_LOCK( &Request->Lock );
    haveLock = TRUE;

    primaryConn = Request->PrimaryConnection;

    if (Request->ReferralHopLimit <= Request->ReferralCount) {

        IF_DEBUG(REFERRALS) {
            LdapPrint2( "HandleReferral hit hop count limit of 0x%x while handling 0x%x\n",
                         hr, Request );
        }
        hr = LDAP_RESULTS_TOO_LARGE;
        goto exitReferral;
    }

    //
    //  determine the referral record that this particular response came from
    //

    referralNumber = ResultMessage->lm_referral;

    if (referralNumber == 0) {

        originatingConnection = Request->PrimaryConnection;

        if (newDN == NULL) {

            newDN = Request->OriginalDN;

        } else {

            newDN = pldapRefDN->ReferralDN;
        }

        if ((Request->Operation == LDAP_SEARCH_CMD) &&
            (Request->search.ScopeOfSearch == LDAP_SCOPE_ONELEVEL) ) {

            searchWasSingleLevel = TRUE;
        }

    } else {

        //
        //  We go to the nth-1 element in the array of referrals.. this is the
        //  one that originated this message.
        //

        originalEntry = Request->ReferralConnections;
        originalEntry += (referralNumber - 1);

        if (newDN == NULL) {

            newDN = originalEntry->ReferralDN;

        } else {

            newDN = pldapRefDN->ReferralDN;
        }

        originatingConnection = originalEntry->ReferralServer;

        if ((Request->Operation == LDAP_SEARCH_CMD) &&
            (originalEntry->SingleLevelSearch == TRUE ) &&
            (Request->search.ScopeOfSearch == LDAP_SCOPE_ONELEVEL)) {

            searchWasSingleLevel = TRUE;

        }
    }

    //
    //  first thing to do is to check the request to see if this one already
    //  has been chased.
    //

    hr = CheckForExistingReferral( Request, mappedHostAddrW, PortNumber, newDN );

    if (hr != LDAP_SUCCESS) {

        //
        //  we've already chased this one... don't chase our tail on it.
        //

        goto exitReferral;
    }

    RELEASE_LOCK( &Request->Lock );
    haveLock = FALSE;

    queryRoutine = primaryConn->ReferralQueryRoutine;
    dereferenceRoutine = primaryConn->DereferenceNotifyRoutine;

    //
    // If we are chasing a referral for a paged request, we must create a new
    // connection
    //

    if ((queryRoutine != NULL) &&
        (Request->PageRequest == NULL)) {

        LUID luid;

        ACQUIRE_LOCK( &primaryConn->StateLock );

        luid.LowPart = primaryConn->CurrentLogonId.LowPart;
        luid.HighPart = primaryConn->CurrentLogonId.HighPart;

        //
        //  we make a copy of the credentials so that we don't have to hold
        //  any locks across the callout.
        //

        if ((primaryConn->BindMethod != LDAP_AUTH_SIMPLE) &&
            (primaryConn->CurrentCredentials != NULL)) {

            PSEC_WINNT_AUTH_IDENTITY_A pIncoming =
                    (PSEC_WINNT_AUTH_IDENTITY_A) primaryConn->CurrentCredentials;
            BOOLEAN fromWide = (BOOLEAN) ((pIncoming->Flags &
                    SEC_WINNT_AUTH_IDENTITY_UNICODE) ? TRUE : FALSE);


            ACQUIRE_LOCK( &primaryConn->ScramblingLock );

            if (GlobalUseScrambling && primaryConn->Scrambled) {

                DecodeUnicodeString(&primaryConn->ScrambledCredentials );
                primaryConn->Scrambled = FALSE;
            }
            
            PSEC_WINNT_AUTH_IDENTITY_EXA pIncomingEX = (PSEC_WINNT_AUTH_IDENTITY_EXA) primaryConn->CurrentCredentials;

            if ((pIncomingEX->Version > 0xFFFF)||(pIncomingEX->Version == 0)) {

                //
                // we are using the older style security structure
                //

                err = LdapMakeCredsWide( (PCHAR) primaryConn->CurrentCredentials,
                                         &copyOfPrimaryCreds,
                                         fromWide
                                         );
            } else {

                //
                // We are using the newer style structure
                //

                err = LdapMakeEXCredsWide( (PCHAR) primaryConn->CurrentCredentials,
                                           &copyOfPrimaryCreds,
                                           fromWide
                                           );
            }

            if (GlobalUseScrambling && !primaryConn->Scrambled) {

                EncodeUnicodeString(&primaryConn->ScrambledCredentials );
                primaryConn->Scrambled = TRUE;
            }

            RELEASE_LOCK( &primaryConn->ScramblingLock );

            if (err != LDAP_SUCCESS) {

                RELEASE_LOCK( &primaryConn->StateLock );
                goto exitReferral;
            }
        }

        //
        //  call out to the app to see if they have one for us to use.
        //

        RELEASE_LOCK( &primaryConn->StateLock );

        PLDAP calloutReturnConn = NULL;

        err = (*queryRoutine)(  primaryConn->ExternalInfo,
                                originatingConnection->ExternalInfo,
                                NewUrlDN,
                                mappedHostAddrA,
                                PortNumber,
                                (PVOID) copyOfPrimaryCreds,
                                (PVOID) &luid,
                                &calloutReturnConn
                                );
        if (err != 0) {

            goto exitReferral;
        }

        newConnection = GetConnectionPointer(calloutReturnConn);

        if (newConnection != NULL) {

            IF_DEBUG(REFERRALS) {
                LdapPrint1( "HandleReferral: Given existing connection to %s\n",
                        mappedHostAddrA );
            }

            ACQUIRE_LOCK( &newConnection->StateLock);

            //
            // Check if the connection is in the process of being closed.
            // Anytime all handles given out go to zero, the connection
            // will be closed. There is a small timing window where
            // after the decision to close is made by another thread, we
            // can increment the handle count and have the conection
            // be closed under our feet. This check prevents that because
            // decrementing and checking happens with StateLock being held.
            //
            // Use this connection only if it is already connected. No point
            // in using a cached connection which is long dead. We might as
            // well create a new connection.
            //
            // Also, ensure that the sign/seal/ssl options are identical to that
            // of the primary connection.
            //

            if ((newConnection->HandlesGivenToCaller == 0 &&
                 newConnection->HandlesGivenAsReferrals == 0) ||
                 (newConnection->HostConnectState != HostConnectStateConnected) ||
                 (!DoSigningOptionsMatch(primaryConn, newConnection)) ||
                 (newConnection->UserSealDataChoice != primaryConn->UserSealDataChoice) ||
                 (newConnection->SslPort != primaryConn->SslPort) ||
                 (newConnection->publicLdapStruct.ld_version < primaryConn->publicLdapStruct.ld_version))
            {
                RELEASE_LOCK( &newConnection->StateLock);
                DereferenceLdapConnection( newConnection );
                IF_DEBUG(REFERRALS) {
                    LdapPrint1("Rejecting given cached connection 0x%x\n", newConnection);
                }
                newConnection = NULL;
            }
            else
            {
                newConnection->HandlesGivenAsReferrals++;
                RELEASE_LOCK( &newConnection->StateLock);

                callDerefCallback = TRUE;
                dereferenceRoutine = newConnection->DereferenceNotifyRoutine;
            }
        }

    } else if (Request->PageRequest == NULL) {

        ULONG lenHostAddr = (ULONG) strlen( mappedHostAddrA );
        ULONG socket = (*phtons)( PortNumber );

        DWORD  comparisonBindMethod = 0;
        PWCHAR comparisonBindName = NULL;
        PWCHAR comparisonBindPwd = NULL;
        CredHandle comparisonHandle;

        //
        //  go through list of connections and try to match by name.
        //
        //  we already have an authenticated, decent connection already
        //  to this server.
        //

        // Descramble the credentials so we can compare them inside DoCredentialsMatch,
        // if using simple bind
        err = LDAP_SUCCESS;
        ACQUIRE_LOCK( &primaryConn->StateLock );

        comparisonBindMethod = primaryConn->BindMethod;
        comparisonHandle.dwLower = primaryConn->hCredentials.dwLower;
        comparisonHandle.dwUpper = primaryConn->hCredentials.dwUpper;
        
        if ( comparisonBindMethod == LDAP_AUTH_SIMPLE) {
            ACQUIRE_LOCK( &primaryConn->ScramblingLock ); 
            fNeedToRescramble = FALSE;
            if ( GlobalUseScrambling && primaryConn->Scrambled && primaryConn->CurrentCredentials) {

               DecodeUnicodeString(&primaryConn->ScrambledCredentials);
               primaryConn->Scrambled = FALSE;
               fNeedToRescramble = TRUE;
            } 

            comparisonBindName = ldap_dup_stringW( primaryConn->DNOnBind, 0, LDAP_UNICODE_SIGNATURE);
            comparisonBindPwd  = ldap_dup_stringW( primaryConn->CurrentCredentials, 0, LDAP_UNICODE_SIGNATURE);

            if ( ((comparisonBindName == NULL) && (primaryConn->DNOnBind != NULL)) ||
                 ((comparisonBindPwd == NULL) && (primaryConn->CurrentCredentials != NULL)) ) {

                err = LDAP_NO_MEMORY;
            }

            if (fNeedToRescramble && GlobalUseScrambling && !primaryConn->Scrambled && primaryConn->CurrentCredentials) {

               EncodeUnicodeString(&primaryConn->ScrambledCredentials);
               primaryConn->Scrambled = TRUE;
            }
            RELEASE_LOCK( &primaryConn->ScramblingLock );
        }
        
        RELEASE_LOCK( &primaryConn->StateLock );

        if (err != LDAP_SUCCESS) {

            ldapFree(comparisonBindPwd, LDAP_UNICODE_SIGNATURE);
            ldapFree(comparisonBindName, LDAP_UNICODE_SIGNATURE);

            hr = err;
            goto exitReferral;
        }


        ACQUIRE_LOCK( &ConnectionListLock );

        listEntry = GlobalListActiveConnections.Flink;
        searchConn = NULL;

        while (listEntry != &GlobalListActiveConnections) {

            searchConn = CONTAINING_RECORD( listEntry, LDAP_CONN, ConnectionListEntry );

            //
            //  We check to see if the net addresses are the same, the net sockets
            //  are the same, and that the connection isn't being closed by a call
            //  to DereferenceLdapRequest2 where we've freed the connectionlistlock
            //  but not yet closed the connection.
            //

            if ((searchConn->ConnObjectState != ConnObjectClosing) &&
                (searchConn->HostConnectState == HostConnectStateConnected) &&
                ((searchConn->HandlesGivenToCaller > 0 ) ||
                     (searchConn->HandlesGivenAsReferrals > 0)) &&
                (searchConn->ServerDown == FALSE) &&
                (searchConn->SocketAddress.sin_port == socket) &&
                (DoSigningOptionsMatch(primaryConn, searchConn)) &&
                (searchConn->UserSealDataChoice == primaryConn->UserSealDataChoice) &&
                (searchConn->SslPort == primaryConn->SslPort) &&
                (DoCredentialsMatch(searchConn, comparisonBindMethod, &comparisonHandle, comparisonBindName, comparisonBindPwd)) &&
                (searchConn->publicLdapStruct.ld_version >= primaryConn->publicLdapStruct.ld_version) &&
                (ldapWStringsIdentical(
                                 mappedHostAddrW,
                                 lenHostAddr,
                                 searchConn->HostNameW,
                                 -1 )) ) {
                //
                //  check if the user context is the same.
                //

                if ((primaryConn->CurrentLogonId.LowPart ==
                      searchConn->CurrentLogonId.LowPart) &&
                    (primaryConn->CurrentLogonId.HighPart ==
                      searchConn->CurrentLogonId.HighPart)) {

                    break;
                }
            }
            listEntry = listEntry->Flink;
            searchConn = NULL;
        }

        RELEASE_LOCK( &ConnectionListLock );

        ldapFree(comparisonBindPwd, LDAP_UNICODE_SIGNATURE);
        ldapFree(comparisonBindName, LDAP_UNICODE_SIGNATURE);

        if (searchConn != NULL) {

            newConnection = ReferenceLdapConnection( searchConn );

            if (newConnection)
            {
                ACQUIRE_LOCK( &newConnection->StateLock);

                if (newConnection->HandlesGivenToCaller == 0 &&
                    newConnection->HandlesGivenAsReferrals == 0)
                {
                    RELEASE_LOCK( &newConnection->StateLock);
                    DereferenceLdapConnection( newConnection);
                    newConnection = NULL;
                }
                else
                {
                    newConnection->HandlesGivenAsReferrals++;

                    RELEASE_LOCK( &newConnection->StateLock);

                    IF_DEBUG(REFERRALS) {
                        LdapPrint1( "HandleReferral: Found existing connection to %S\n",
                                mappedHostAddrW );
                    }
                }
            }
        }
    }

    if (newConnection == NULL) {

        DWORD  comparisonBindMethod = 0;
        PWCHAR comparisonBindName = NULL;
        PWCHAR comparisonBindPwd = NULL;
        CredHandle comparisonHandle;

        newConnection = LdapAllocateConnection( mappedHostAddrW,
                                                PortNumber,
                                                Ssl,
                                                0 );

        if (newConnection == NULL) {

            IF_DEBUG(CONNECTION) {
                LdapPrint1( "HandleReferral failed to allocate, err 0x%x.\n", GetLastError());
            }

            hr = LDAP_UNAVAILABLE;
            goto exitReferral;
        }

        //
        //  open a connection to any of the servers specified
        //  No one has this connection yet, so no need to protect
        //

        err = LdapConnect( newConnection, NULL, FALSE );

        if (err != 0) {

            IF_DEBUG(CONNECTION) {
                LdapPrint1( "HandleReferral failed to connect, err 0x%x.\n", err);
            }

            CloseLdapConnection( newConnection );
            DereferenceLdapConnection( newConnection );
            newConnection = NULL;
            hr = LDAP_UNAVAILABLE;
            goto exitReferral;
        }

        ASSERT(newConnection->ConnObjectState == ConnObjectActive);

        // Descramble the credentials so we can compare them inside DoCredentialsMatch,
        // if using simple bind
        err = LDAP_SUCCESS;
        ACQUIRE_LOCK( &primaryConn->StateLock );

        comparisonBindMethod = primaryConn->BindMethod;
        comparisonHandle.dwLower = primaryConn->hCredentials.dwLower;
        comparisonHandle.dwUpper = primaryConn->hCredentials.dwUpper;
        
        if ( comparisonBindMethod == LDAP_AUTH_SIMPLE) {
            ACQUIRE_LOCK( &primaryConn->ScramblingLock );   
            fNeedToRescramble = FALSE;
            if ( GlobalUseScrambling && primaryConn->Scrambled && primaryConn->CurrentCredentials) {

               DecodeUnicodeString(&primaryConn->ScrambledCredentials);
               primaryConn->Scrambled = FALSE;
               fNeedToRescramble = TRUE;
            } 

            comparisonBindName = ldap_dup_stringW( primaryConn->DNOnBind, 0, LDAP_UNICODE_SIGNATURE);
            comparisonBindPwd  = ldap_dup_stringW( primaryConn->CurrentCredentials, 0, LDAP_UNICODE_SIGNATURE);

            if ( ((comparisonBindName == NULL) && (primaryConn->DNOnBind != NULL)) ||
                 ((comparisonBindPwd == NULL) && (primaryConn->CurrentCredentials != NULL)) ) {

                err = LDAP_NO_MEMORY;
            }

            if (fNeedToRescramble && GlobalUseScrambling && !primaryConn->Scrambled && primaryConn->CurrentCredentials) {

               EncodeUnicodeString(&primaryConn->ScrambledCredentials);
               primaryConn->Scrambled = TRUE;
            }
            RELEASE_LOCK( &primaryConn->ScramblingLock );
        }
        
        RELEASE_LOCK( &primaryConn->StateLock );

        if (err != LDAP_SUCCESS) {

            ldapFree(comparisonBindPwd, LDAP_UNICODE_SIGNATURE);
            ldapFree(comparisonBindName, LDAP_UNICODE_SIGNATURE);
        
            CloseLdapConnection( newConnection );
            DereferenceLdapConnection( newConnection );
            newConnection = NULL;
            hr = err;
            goto exitReferral;
        }
        

        ACQUIRE_LOCK( &ConnectionListLock );

        //
        //  go through list of connections we already have and see if
        //  we already have an authenticated, decent connection already
        //  to this server.
        //

        listEntry = GlobalListActiveConnections.Flink;
        searchConn = NULL;

        while (listEntry != &GlobalListActiveConnections) {

            searchConn = CONTAINING_RECORD( listEntry, LDAP_CONN, ConnectionListEntry );

            //
            //  We check to see if the net addresses are the same, the net sockets
            //  are the same, and that the connection isn't being closed by a call
            //  to DereferenceLdapRequest2 where we've freed the connectionlistlock
            //  but not yet closed the connection.
            //

            if ((searchConn != newConnection ) &&
                (searchConn->ConnObjectState != ConnObjectClosing) &&
                (searchConn->BindInProgress == FALSE) &&
                (DoSigningOptionsMatch(primaryConn, searchConn)) &&
                (searchConn->UserSealDataChoice == primaryConn->UserSealDataChoice) &&
                (searchConn->SslPort == primaryConn->SslPort) &&
                (DoCredentialsMatch(searchConn, comparisonBindMethod, &comparisonHandle, comparisonBindName, comparisonBindPwd)) &&
                (searchConn->publicLdapStruct.ld_version >= primaryConn->publicLdapStruct.ld_version) &&                
                (searchConn->HostConnectState == HostConnectStateConnected)) {

                if ((searchConn->ServerDown == FALSE) &&
                    (searchConn->SocketAddress.sin_addr.s_addr ==
                     newConnection->SocketAddress.sin_addr.s_addr) &&
                    (searchConn->SocketAddress.sin_port ==
                     newConnection->SocketAddress.sin_port ) &&
                    ((searchConn->HandlesGivenToCaller > 0 ) ||
                     (searchConn->HandlesGivenAsReferrals > 0))) {

                    //
                    //  check if the user context is the same.
                    //

                    if ((primaryConn->CurrentLogonId.LowPart ==
                          searchConn->CurrentLogonId.LowPart) &&
                        (primaryConn->CurrentLogonId.HighPart ==
                          searchConn->CurrentLogonId.HighPart)) {

                        break;
                    }
                }
            }
            listEntry = listEntry->Flink;
            searchConn = NULL;
        }

        RELEASE_LOCK( &ConnectionListLock );

        ldapFree(comparisonBindPwd, LDAP_UNICODE_SIGNATURE);
        ldapFree(comparisonBindName, LDAP_UNICODE_SIGNATURE);

        if (searchConn != NULL) {

            //
            // We can get rid of newConnection and use this searchConn
            // only if we are able to reference it AND we are able
            // to increment HandlesGivenAsReferrals. So don't
            // do anyting hasty till we are absolutely sure we have
            // got our connection
            //
            // If we are unable to reuse searchConn, we set searchConn
            // to NULL, so we can use the newconnection
            //

            tempConn = ReferenceLdapConnection( searchConn );

            if (tempConn)
            {
                ACQUIRE_LOCK( &tempConn->StateLock);

                if (tempConn->HandlesGivenToCaller == 0 &&
                    tempConn->HandlesGivenAsReferrals == 0)
                {
                    RELEASE_LOCK( &tempConn->StateLock);
                    DereferenceLdapConnection( tempConn);
                    tempConn = NULL;
                }
                else
                {
                    tempConn->HandlesGivenAsReferrals++;
                    RELEASE_LOCK( &tempConn->StateLock);

                    //
                    // Blow awy newly created connection
                    //

                    CloseLdapConnection( newConnection );
                    DereferenceLdapConnection( newConnection );

                    newConnection = tempConn;

                    IF_DEBUG(REFERRALS) {
                        LdapPrint1( "HandleReferral: Found existing connection to %S\n",
                                mappedHostAddrW );
                    }
                }
            }

            searchConn = tempConn;      // Set to NULL if necessary
        }

        if (searchConn == NULL) {

            //
            // For whatever reason, we couldn't reuse an existing conenction
            //
            //
            //  we make a copy of the credentials so that we don't have to hold
            //  any locks across the callout.
            //

            ACQUIRE_LOCK( &primaryConn->StateLock );

            ULONG primaryBindMethod = primaryConn->BindMethod;

            if ((primaryBindMethod != LDAP_AUTH_SIMPLE) &&
                (primaryConn->CurrentCredentials != NULL)) {

                PSEC_WINNT_AUTH_IDENTITY_A pIncoming =
                        (PSEC_WINNT_AUTH_IDENTITY_A) primaryConn->CurrentCredentials;
                BOOLEAN fromWide = (BOOLEAN) ((pIncoming->Flags &
                        SEC_WINNT_AUTH_IDENTITY_UNICODE) ? TRUE : FALSE);


                if (copyOfPrimaryCreds != NULL) {

                   ldapFree( copyOfPrimaryCreds, LDAP_SECURITY_SIGNATURE );
                   copyOfPrimaryCreds = NULL;
                }


                ACQUIRE_LOCK( &primaryConn->ScramblingLock );

                if (GlobalUseScrambling && primaryConn->Scrambled) {

                   DecodeUnicodeString(&primaryConn->ScrambledCredentials );
                   primaryConn->Scrambled = FALSE;
                }
                
                PSEC_WINNT_AUTH_IDENTITY_EXA pIncomingEX = (PSEC_WINNT_AUTH_IDENTITY_EXA) primaryConn->CurrentCredentials;
    
                if ((pIncomingEX->Version > 0xFFFF)||(pIncomingEX->Version == 0)) {
    
                    //
                    // we are using the older style security structure
                    //
    
                    err = LdapMakeCredsWide( (PCHAR) primaryConn->CurrentCredentials,
                                             &copyOfPrimaryCreds,
                                             fromWide
                                             );
                } else {
    
                    //
                    // We are using the newer style structure
                    //
    
                    err = LdapMakeEXCredsWide( (PCHAR) primaryConn->CurrentCredentials,
                                               &copyOfPrimaryCreds,
                                               fromWide
                                               );
                }

                if (GlobalUseScrambling && !primaryConn->Scrambled) {

                   EncodeUnicodeString(&primaryConn->ScrambledCredentials );
                   primaryConn->Scrambled = TRUE;

                }

                RELEASE_LOCK( &primaryConn->ScramblingLock );

                if (err != LDAP_SUCCESS) {

                    RELEASE_LOCK( &primaryConn->StateLock );
                    goto exitReferral;
                }
            }

            //
            // Set up an SSL session if required.
            //

            DWORD opt = PtrToUlong( LDAP_OPT_ON );

            if ( primaryConn->SslPort ) {

                hr = LdapSetConnectionOption( newConnection, LDAP_OPT_SSL, &opt, TRUE );

                if (hr != LDAP_SUCCESS) {
                    IF_DEBUG(REFERRALS) {
                        LdapPrint0("Unable to setup SSL session on referral connection\n");
                    }
                    RELEASE_LOCK( &primaryConn->StateLock );
                    goto exitReferral;
                } else {
                    IF_DEBUG(REFERRALS) {
                        LdapPrint0("Successfully setup SSL session on referral connection\n");
                    }
                }
            }

            //
            // Mimic the sign/seal options of the primary connection.
            //

            // we go by what the user explicitly requested, not what we actually got
            // (which may differ because of global signing policy).  Global signing
            // policy will be enforced when we actually do the LdapBind.
            if (primaryConn->UserSignDataChoice) {

                hr = LdapSetConnectionOption( newConnection, LDAP_OPT_SIGN, &opt, TRUE );

                if (hr != LDAP_SUCCESS) {
                    IF_DEBUG(REFERRALS) {
                        LdapPrint0("Unable to setup Signing on referral connection\n");
                    }
                    RELEASE_LOCK( &primaryConn->StateLock );
                    goto exitReferral;
                } else {
                    IF_DEBUG(REFERRALS) {
                        LdapPrint0("Successfully setup Signing on referral connection\n");
                    }
                }
            }

            if (primaryConn->UserSealDataChoice) {
                
                hr = LdapSetConnectionOption( newConnection, LDAP_OPT_ENCRYPT, &opt, TRUE );
                
                if (hr != LDAP_SUCCESS) {
                    IF_DEBUG(REFERRALS) {
                        LdapPrint0("Unable to setup Sealing on referral connection\n");
                    }
                    RELEASE_LOCK( &primaryConn->StateLock );
                    goto exitReferral;
                } else {
                    IF_DEBUG(REFERRALS) {
                        LdapPrint0("Successfully setup Sealing on referral connection\n");
                    }
                }
            }

            //
            // Mimic the version of the primary connection
            //

            ULONG ver = primaryConn->publicLdapStruct.ld_version;
            hr = LdapSetConnectionOption( newConnection, LDAP_OPT_VERSION, &ver, TRUE);
            if (hr != LDAP_SUCCESS) {
                IF_DEBUG(REFERRALS) {
                    LdapPrint0("Unable to set version on referral connection\n");
                }
                RELEASE_LOCK( &primaryConn->StateLock );
                goto exitReferral;
            } else {
                IF_DEBUG(REFERRALS) {
                    LdapPrint1("Successfully set version=%ul on referral connection\n", ver);
                }
            }
                
            RELEASE_LOCK( &primaryConn->StateLock );

            //
            // Note: From this point onward till updatedReferralHandleCount is
            // set to TRUE, we shouldn't jump out directly to exitReferral.
            // If we do, we will leak a connection
            //
            // No locks or checks needed here as no one else has access
            // connection (it is not yet in the connection list)
            //

            newConnection->HandlesGivenAsReferrals++;

            //
            // Add newConnection to connection list
            //

            ACQUIRE_LOCK( &ConnectionListLock );

            InsertTailList( &GlobalListActiveConnections, &newConnection->ConnectionListEntry );

            RELEASE_LOCK( &ConnectionListLock );

            //
            // Wake up select so that it picks up the new connection handle.
            //
        
            LdapWakeupSelect();

            //
            //  Send a bind request to the referred server.
            //  
            //  Make sure that if we are using clear text credentials, the session
            //  is protected by SSL.
            //
            //  We must *ALWAYS* send a bind request to the referred server because we
            //  don't know beforehand if it is a v2 or v3 server. v2 servers always require
            //  binds but v3 servers don't.
            //
            //  We will send a NULL simple bind (anonymous) bind to the server in the
            //  following cases:
            //
            //      - There was no bind performed initially. (primary server was v3)
            //      - A simple bind was originally performed without SSL protection.
            //        (primary server was v2/v3)
            //


            PWCHAR creds = (PWCHAR) copyOfPrimaryCreds;

            if ((creds == NULL) && (primaryBindMethod != 0)) {


               ACQUIRE_LOCK( &primaryConn->StateLock );
               ACQUIRE_LOCK( &primaryConn->ScramblingLock );

               if (GlobalUseScrambling && primaryConn->Scrambled) {

                     DecodeUnicodeString( &primaryConn->ScrambledCredentials );
                     primaryConn->Scrambled = FALSE;
               }

               RELEASE_LOCK( &primaryConn->ScramblingLock );
               RELEASE_LOCK( &primaryConn->StateLock );
               
               creds = primaryConn->CurrentCredentials;
            }

            BOOLEAN protectedAuth = FALSE;

            if (!((primaryBindMethod == 0) ||
                  (primaryBindMethod == LDAP_AUTH_SIMPLE) && (newConnection->SslPort == FALSE))) {
                
                protectedAuth = TRUE;
            }

            err = LdapBind( newConnection,
                            protectedAuth ? primaryConn->DNOnBind : NULL,
                            (primaryBindMethod == 0) ? LDAP_AUTH_SIMPLE : primaryBindMethod,
                            protectedAuth ? creds : NULL,
                            TRUE           // Synchronous
                            );

            IF_DEBUG(REFERRALS) {
                LdapPrint2( "HandleReferral: Bind to host %S returned 0x%x\n",
                        mappedHostAddrW, err );
            }

            if (err != LDAP_SUCCESS) {
                
                hr = err;
                
                //
                // The cleanup code will make sure this connection is deleted.
                //
                
                updatedReferralHandleCount = TRUE;
                goto exitReferral;
            }

            newConnection->CurrentLogonId.LowPart = primaryConn->CurrentLogonId.LowPart;
            newConnection->CurrentLogonId.HighPart = primaryConn->CurrentLogonId.HighPart;

            notifyRoutine = primaryConn->ReferralNotifyRoutine;

            newConnection->ReferralNotifyRoutine = notifyRoutine;
            newConnection->ReferralQueryRoutine = queryRoutine;
            newConnection->DereferenceNotifyRoutine =
                            primaryConn->DereferenceNotifyRoutine;

            if (notifyRoutine != NULL) {

                if ((*notifyRoutine)(   primaryConn->ExternalInfo,
                                        originatingConnection->ExternalInfo,
                                        NewUrlDN,
                                        mappedHostAddrA,
                                        newConnection->ExternalInfo,
                                        PortNumber,
                                        (PVOID) copyOfPrimaryCreds,
                                        (PVOID) &newConnection->CurrentLogonId,
                                        err )) {

                    //
                    //  the callout routine has agreed to track it, we simply
                    //  need to mark it that it's been handed over.
                    //

                    ACQUIRE_LOCK( &newConnection->StateLock);

                    ASSERT(newConnection->HandlesGivenAsReferrals > 0);
                    newConnection->HandlesGivenToCaller++;

                    RELEASE_LOCK( &newConnection->StateLock);

                    IF_DEBUG(REFERRALS) {
                        LdapPrint2( "HandleReferral: Handle was given to callee for host %s, 0x%x\n",
                                mappedHostAddrA, newConnection );
                    }

                    callDerefCallback = TRUE;

                } else {

                    IF_DEBUG(REFERRALS) {
                        LdapPrint2( "HandleReferral: Handle was not given to callee for host %s, 0x%x\n",
                                mappedHostAddrA, newConnection );
                    }
                }
            }
        }
    }

    //
    //  make note of the fact that we've bumped the connection's
    //  HandlesGivenAsReferrals value... if we back out, we need to handle
    //  decrementing and possibly closing the connection.
    //

    updatedReferralHandleCount = TRUE;

    ACQUIRE_LOCK( &Request->Lock );
    haveLock = TRUE;

    if (Request->ReferralHopLimit <= Request->ReferralCount) {

        IF_DEBUG(REFERRALS) {
            LdapPrint2( "HandleReferral hit hop count limit of 0x%x while handling %0x%x\n",
                         Request->ReferralCount, Request );
        }
        hr = LDAP_RESULTS_TOO_LARGE;
        goto exitReferral;
    }

    //
    //  check the request again to see if this one already has been chased.
    //

    hr = CheckForExistingReferral( Request,
                                   newConnection->HostNameW,
                                   newConnection->PortNumber,
                                   newDN );

    if (hr != LDAP_SUCCESS) {

        //
        //  we've already chased this one... don't chase our tail on it.
        //

        goto exitReferral;
    }

    refTable = Request->ReferralConnections;

    //
    //  find a spot for this in the referral table
    //

    if (refTable == NULL) {

        refTable = (PREFERRAL_TABLE_ENTRY) ldapMalloc(
                        sizeof( REFERRAL_TABLE_ENTRY ) *
                        Request->ReferralHopLimit,
                        LDAP_REFTABLE_SIGNATURE );

        if (refTable == NULL) {

            IF_DEBUG(REFERRALS) {
                LdapPrint1( "HandleReferral could not allocate ref table while handling 0x%x\n",
                             Request );
            }
            hr = LDAP_NO_MEMORY;
            goto exitReferral;
        }
        Request->ReferralConnections = refTable;
        Request->ReferralTableSize = Request->ReferralHopLimit;
    }

    //
    // put the connection into the reference table... note that the index into
    // the referral table starts at 1, because the primary connection is 0.
    //

    i = 1;
    workingEntry = refTable;

    while ((i <= Request->ReferralTableSize) &&
           (workingEntry->ReferralServer != NULL)) {

        i++;
        workingEntry++;
    }

    if (i > Request->ReferralTableSize) {

        IF_DEBUG(REFERRALS) {
            LdapPrint2( "HandleReferral ref table full(0x%x) while handling %0x%x\n",
                         i, Request );
        }
        hr = LDAP_RESULTS_TOO_LARGE;
        goto exitReferral;

    }

    newReferralDN = ldap_dup_stringW( newDN, 0, LDAP_REFDN_SIGNATURE );

    if ((newReferralDN == NULL) && (newDN != NULL)) {

        IF_DEBUG(REFERRALS) {
            LdapPrint1( "HandleReferral could not allocate dn while handling 0x%x\n",
                         Request );
        }
        hr = LDAP_NO_MEMORY;
        goto exitReferral;
    }

    //
    //  put it in the table and reference the connection for the trouble.
    //  It'll be dereferenced when the request is freed.
    //

    workingEntry->ReferralServer = newConnection;
    workingEntry->ReferralInstance = i;
    workingEntry->ReferralDN = newReferralDN;
    workingEntry->ScopeOfSearch = pldapRefDN ? pldapRefDN->ScopeOfSearch : 0;
    workingEntry->SearchFilter = pldapRefDN ? pldapRefDN->SearchFilter : NULL;
    workingEntry->AttributeList = pldapRefDN ? pldapRefDN->AttributeList : NULL;
    workingEntry->CallDerefCallback = callDerefCallback;

    callDerefCallback = FALSE;

    if (searchWasSingleLevel && FromSubordinateReferral) {

        workingEntry->SingleLevelSearch = FALSE;

    } else {

        workingEntry->SingleLevelSearch = TRUE;
    }

    Request->ReferralCount++;

    newConnection = ReferenceLdapConnection( newConnection );
    ASSERT(newConnection);
    
    //
    //  all that remains is to send our request to the referred server.
    //
    
    RELEASE_LOCK( &Request->Lock );
    haveLock = FALSE;

    hr = LdapSendCommand( newConnection, Request, i );

    ACQUIRE_LOCK( &Request->Lock );
    haveLock = TRUE;

    if (hr != LDAP_SUCCESS) {

        workingEntry->ReferralServer = NULL;
        ldapFree( workingEntry->ReferralDN, LDAP_REFDN_SIGNATURE );
        workingEntry->ReferralDN = NULL;

        Request->ReferralCount--;

        RELEASE_LOCK( &Request->Lock );
        haveLock = FALSE;

        DereferenceLdapConnection( newConnection );

   } else {

       //
       // Check to see if this is a paged search request. If it is,
       // we just chased an external referral. This means that we have
       // to keep the connection around by referencing it. We also have
       // to hook up the new connection to the original conn so that all
       // future *paged* requests go to the new connection instead of the
       // old one.
       //

       if (Request->PageRequest != NULL) {

           IF_DEBUG(CONTROLS) {
               LdapPrint0("The parent search was a paged request\n");
           }

           if (newConnection != NULL) {

               IF_DEBUG(CONTROLS) {
                   LdapPrint2("Hooking up new connection 0x%x to req 0x%x\n", newConnection, Request->PageRequest);
               }

               //
               // We do this to counter the fact that this variable will be
               // decremented at the end of this function
               //

               ACQUIRE_LOCK(&newConnection->StateLock);

               ASSERT(newConnection->HandlesGivenAsReferrals > 0);
               newConnection->HandlesGivenAsReferrals++;

               RELEASE_LOCK(&newConnection->StateLock);

               //
               // As we are saving it off as a secondary connection, reference
               // it once more.
               //

               newConnection = ReferenceLdapConnection( newConnection );
               ASSERT(newConnection);

               Request->PageRequest->SecondaryConnection = newConnection;
           }
       }
    }

exitReferral:

    ldapFree( mappedHostAddrA, LDAP_ANSI_SIGNATURE );
    ldapFree( mappedHostAddrW, LDAP_UNICODE_SIGNATURE );

    if (haveLock) {
        RELEASE_LOCK( &Request->Lock );
    }

    if (callDerefCallback && dereferenceRoutine != NULL) {

        ASSERT( newConnection != NULL );

        (*dereferenceRoutine)( primaryConn->ExternalInfo,
                               newConnection->ExternalInfo );
    }

    if (hr != LDAP_SUCCESS) {

        if (updatedReferralHandleCount) {

            ASSERT( newConnection != NULL );

            ACQUIRE_LOCK( &newConnection->StateLock );

            ASSERT(newConnection->HandlesGivenAsReferrals > 0);
            newConnection->HandlesGivenAsReferrals--;

            if ((newConnection->HandlesGivenToCaller == 0 ) &&
                (newConnection->HandlesGivenAsReferrals == 0)) {

                RELEASE_LOCK( &newConnection->StateLock );

                CloseLdapConnection( newConnection );

            }
            else {
                RELEASE_LOCK( &newConnection->StateLock );
            }
        }
    }

    if (newConnection != NULL) {

        DereferenceLdapConnection( newConnection );
    }

    if (copyOfPrimaryCreds != NULL) {

        ldapFree( copyOfPrimaryCreds, LDAP_SECURITY_SIGNATURE );
    }

    if (pldapRefDN != NULL) {

        ldapFree(pldapRefDN->ReferralDN, LDAP_URL_SIGNATURE);
        ldapFree(pldapRefDN->SearchFilter, LDAP_URL_SIGNATURE);
        ldapFree(pldapRefDN->Extension, LDAP_URL_SIGNATURE);
        ldapFree(pldapRefDN->BindName, LDAP_URL_SIGNATURE);

        if (pldapRefDN->AttributeList) {
            for (i=0; i<pldapRefDN->AttribCount; i++) {
                ldapFree(pldapRefDN->AttributeList[i], LDAP_URL_SIGNATURE);
            }
        }

        ldapFree(pldapRefDN->AttributeList, LDAP_URL_SIGNATURE);
        ldapFree(pldapRefDN, LDAP_URL_SIGNATURE);
    }

    return hr;
}

BOOLEAN
DoSigningOptionsMatch(
    PLDAP_CONN pPrimary,
    PLDAP_CONN pReferral
    )
{

    //
    // Signing can be enabled 2 ways: by the user's explicit request, and by a global policy.
    // Global policy is enforced by the LdapBind call, so we don't worry about it here --- whatever
    // signing setting is on the referral connection must be in agreement with the policy.
    // Therefore, we only need to deal with the user's explicit requests here.  If the user
    // requested the primary connection to be signed, the referral connection MUST
    // be signed.  (Note: It's possible that the user requested signing for the primary connection but
    // that the primary connection isn't actually signed, because a bind was never performed.  However,
    // to be safe and avoid opening any unexpected security holes, we require the referral to be signed
    // anyway.  This also duplicates the W2k behavior.)
    //
    if (pPrimary->UserSignDataChoice) {
        return (pReferral->CurrentSignStatus) ? TRUE : FALSE;
    }

    //
    // If the user didn't request signing on the primary, we just accept the referral
    // whether or not it's signed.  This could mean the referral is signed but the primary
    // isn't, but that's okay, we just get some extra security for free.  (We don't have to worry
    // about whether or not the referral meets policy guidelines, because LdapBind would have taken
    // care of that when the referral connection was opened.)
    //
    return TRUE;
}


BOOLEAN
DoCredentialsMatch(
    PLDAP_CONN pReferral,
    DWORD BindMethod,
    CredHandle * pcomparisonHandle,
    PWCHAR comparisonBindName,
    PWCHAR comparisonBindPwd    
    )
{
    BOOLEAN fMatch = FALSE;
    BOOLEAN fNeedToScramble = FALSE;

    //
    // For simplicity, we'll require that they be bound using the same package
    // to count as a match (otherwise, we'd wind up comparing simple binds to
    // Negotiate binds, etc.)
    //

    ACQUIRE_LOCK(&pReferral->StateLock);
    if (pReferral->BindMethod != BindMethod) {

        RELEASE_LOCK(&pReferral->StateLock);
        return FALSE;
    }
    RELEASE_LOCK(&pReferral->StateLock);

    //
    // Perform a match, using a method appropriate to the auth package
    // in question
    //
    switch (BindMethod) {

        case LDAP_AUTH_SIMPLE:
            // For simple bind, either both connections must have no username/password (anonymous),
            // or they must both have the same username/password

            ACQUIRE_LOCK( &pReferral->StateLock );

            if ((comparisonBindName == NULL) &&
                (comparisonBindPwd == NULL) &&
                (pReferral->DNOnBind == NULL) &&
                (pReferral->CurrentCredentials == NULL)) {

                // both anonymous --> they match
                fMatch = TRUE;
            }
            else if ( (comparisonBindName && !(pReferral->DNOnBind)) ||
                      (pReferral->DNOnBind && !(comparisonBindName)) ||
                      (comparisonBindPwd && !(pReferral->CurrentCredentials)) ||
                      (pReferral->CurrentCredentials && !(comparisonBindPwd)) ) {

                // they couldn't possibly match
                fMatch = FALSE;
            }
            else {

                ACQUIRE_LOCK( &pReferral->ScramblingLock );            

                if ( GlobalUseScrambling && pReferral->Scrambled && pReferral->CurrentCredentials) {

                   DecodeUnicodeString(&pReferral->ScrambledCredentials);
                   pReferral->Scrambled = FALSE;
                   fNeedToScramble = TRUE;
                }

                fMatch = FALSE;
                
                if ( (!pReferral->DNOnBind && !comparisonBindName) ||
                     (ldapWStringsIdentical(pReferral->DNOnBind, -1, comparisonBindName, -1)) ) {

                    if ( (!pReferral->CurrentCredentials && !comparisonBindPwd) ||
                         (ldapWStringsIdentical(pReferral->CurrentCredentials, -1, comparisonBindPwd, -1)) ) {

                        fMatch = TRUE;
                    }
                }

                if ( fNeedToScramble && GlobalUseScrambling && !pReferral->Scrambled && pReferral->CurrentCredentials) {

                   EncodeUnicodeString(&pReferral->ScrambledCredentials);
                   pReferral->Scrambled = TRUE;
                }

                RELEASE_LOCK( &pReferral->ScramblingLock );
            }

            RELEASE_LOCK( &pReferral->StateLock );
            
            break;

        case LDAP_AUTH_EXTERNAL:
            // In an External bind, the credentials are dependent on the client certificate
            // that was presented to the server during the SSL negotiations.  Rather than deal
            // with this, we'll just force a new connection.
            fMatch = FALSE;
            break;

        default:
            // All other binds methods, including Negotiate, Digest, etc.
            // We'll check to see if the connections are using the same credentials
            // handle.
            ACQUIRE_LOCK(&pReferral->StateLock);    
            if ( (pcomparisonHandle->dwLower == pReferral->hCredentials.dwLower) &&
                 (pcomparisonHandle->dwUpper == pReferral->hCredentials.dwUpper) ) {

                fMatch = TRUE;
            }
            else {

                fMatch = FALSE;
            }
            RELEASE_LOCK(&pReferral->StateLock);


            break;
    }


    return fMatch;
}



ULONG
CheckForExistingReferral (
    PLDAP_REQUEST Request,
    PWCHAR HostAddr,
    USHORT PortNumber,
    PWCHAR NewDN
    )
//
//  This routine checks if a request already has chased a given referral.
//
//  It returns LDAP_SUCCESS if it doesn't exist, LDAP_LOOP_DETECT if it does.
//
//  The request's lock must be held coming in to here!
//
{
    PREFERRAL_TABLE_ENTRY refTable;
    ULONG lenHostAddr;
    ULONG lenNewDN;
    ULONG socket = (*phtons)( PortNumber );
    USHORT refTableEntries = 0;

    if ((HostAddr == NULL) ||
        ((lenHostAddr = strlenW(HostAddr)) == 0)) {

        return LDAP_LOOP_DETECT;
    }

    ASSERT( Request->PrimaryConnection->publicLdapStruct.ld_host != NULL );

    lenNewDN = strlenW( NewDN );

    //
    //  if the one coming in is equal to the one we started with, bail.
    //

    if ((ldapWStringsIdentical(
                         HostAddr,
                         lenHostAddr,
                         Request->PrimaryConnection->HostNameW,
                         -1 )) &&
        (Request->PrimaryConnection->SocketAddress.sin_port == socket) &&
        (ldapWStringsIdentical( NewDN,
                                lenNewDN,
                                Request->OriginalDN,
                                -1))) {

        return LDAP_LOOP_DETECT;
    }

    refTable = Request->ReferralConnections;

    if (refTable == NULL) {

        return LDAP_SUCCESS;
    }

    while (refTableEntries < Request->ReferralTableSize) {

        if ((refTable->ReferralServer != NULL ) &&
            (ldapWStringsIdentical(
                             HostAddr,
                             lenHostAddr,
                             refTable->ReferralServer->HostNameW,
                             -1 )) &&
            (refTable->ReferralServer->SocketAddress.sin_port == socket) &&
            (ldapWStringsIdentical( NewDN,
                                    lenNewDN,
                                    refTable->ReferralDN,
                                    -1))) {

            return LDAP_LOOP_DETECT;
        }
        refTableEntries++;
        refTable++;
    }

    return LDAP_SUCCESS;
}


ULONG
LdapSendCommand (
    PLDAP_CONN Connection,
    PLDAP_REQUEST Request,
    USHORT ReferralNumber
    )
//
//  The request lock must be held coming in here.  We assume both the request
//  and connection blocks are referenced.
//
{
    ULONG hr;
    PREFERRAL_TABLE_ENTRY refTable;
    PWCHAR workingDN;
    LONG NewMessageId;
    CLdapBer **berMessage;

    if (ReferralNumber == 0) {

        refTable = NULL;
        workingDN = Request->OriginalDN;
        berMessage = (CLdapBer **) &Request->BerMessageSent;

    } else {

        //
        //  We go to the nth-1 element in the array of referrals.. this is the
        //  one that originated this message.
        //

        refTable = Request->ReferralConnections;
        refTable += (ReferralNumber - 1);

        workingDN = refTable->ReferralDN;
        berMessage = (CLdapBer **) &refTable->BerMessageSent;
    }

    NewMessageId = MAKE_MESSAGE_NUMBER( Request->MessageId, ReferralNumber );

    if ((refTable) &&
        (refTable->ScopeOfSearch == LDAP_SCOPE_UNDEFINED) &&
        (Request->Operation == LDAP_SEARCH_CMD)) {

        refTable->ScopeOfSearch = Request->search.ScopeOfSearch;
    }

    switch (Request->Operation) {
    case LDAP_SEARCH_CMD:

        hr  = SendLdapSearch(Request,
                             Connection,
                             workingDN,
                             ((refTable)? refTable->ScopeOfSearch : LDAP_SCOPE_BASE),
                             ((refTable && refTable->SearchFilter)? refTable->SearchFilter:Request->search.SearchFilter),
                             ((refTable && refTable->AttributeList)? refTable->AttributeList:Request->search.AttributeList),
                             Request->search.AttributesOnly,
                             Request->search.Unicode,
                             berMessage,
                             NewMessageId );
        break;

    case LDAP_MODIFY_CMD :

        hr = SendLdapModify( Request,
                             Connection,
                             workingDN,
                             berMessage,
                             Request->modify.AttributeList,
                             Request->modify.Unicode,
                             NewMessageId );
        break;

    case LDAP_ADD_CMD :

        hr = SendLdapAdd(   Request,
                            Connection,
                            workingDN,
                            Request->add.AttributeList,
                            berMessage,
                            Request->add.Unicode,
                            NewMessageId );
        break;

    case LDAP_DELETE_CMD :

        hr = SendLdapDelete( Request,
                             Connection,
                             workingDN,
                             berMessage,
                             NewMessageId );
        break;

    case LDAP_MODRDN_CMD :

        hr = SendLdapRename( Request,
                             Connection,
                             workingDN,
                             berMessage,
                             NewMessageId
                             );
        break;

    case LDAP_COMPARE_CMD :

        hr = SendLdapCompare( Request,
                              Connection,
                              berMessage,
                              workingDN,
                              NewMessageId
                              );
        break;

    case LDAP_EXTENDED_CMD :

        hr = SendLdapExtendedOp( Request,
                                 Connection,
                                 Request->OriginalDN,
                                 berMessage,
                                 NewMessageId );
        break;

    default:

        ASSERT(FALSE);

        hr = LDAP_LOCAL_ERROR;

        IF_DEBUG(REFERRALS) {
            LdapPrint2( "LdapSendCommand asked to send cmd of 0x%x handling %0x%x\n",
                         Request->Operation, Request );
        }

    }


    return hr;
}


PLDAPReferralDN
LdapParseReferralDN(
    PWCHAR newDN
    )
{

    PWCHAR CurrentPos, TempPos;
    PLDAPReferralDN pRefDN = NULL;
    int lengthOfDN = 0;
    ULONG i;
    WCHAR savedChar;

    if ((!newDN) || (*newDN == L'\0')) {

        return NULL;
    }

    CurrentPos = TempPos = newDN;

    pRefDN = (PLDAPReferralDN) ldapMalloc(sizeof(LDAPReferralDN), LDAP_URL_SIGNATURE);

    if (!pRefDN) {
        return NULL;
    }

    IF_DEBUG (REFERRALS) {
        LdapPrint1("LdapParseReferralDN: Given string is %S\n", CurrentPos);
    }

    pRefDN->ScopeOfSearch = LDAP_SCOPE_UNDEFINED;

    //
    // The first item in the string is the <dn>
    // If the next char is a \0 or a '?', then we didnt get a <dn>
    //

    if( *CurrentPos == L'?') {

        pRefDN->ReferralDN = NULL;
        CurrentPos++;
        TempPos++;

    } else {

        //
        // We found a DN. Discover the length and copy it.
        //

        while( *TempPos && (*TempPos != L'?')) {

            TempPos++;
            lengthOfDN++;
        }

        savedChar = *TempPos;
        *TempPos = L'\0';

        pRefDN->ReferralDN = ldap_dup_stringW( CurrentPos, 0, LDAP_URL_SIGNATURE );

        IF_DEBUG (REFERRALS) {
            LdapPrint1("LdapParseReferralDN: Discovered referralDN of %S\n", pRefDN->ReferralDN);
        }

        *TempPos = savedChar;
        CurrentPos = TempPos;

        if (*CurrentPos) {
            //
            // Skip over the next '?'
            //
            CurrentPos++;
            TempPos++;
        }
    }

    //
    // Next on line is the attributes for this search ...
    // There are no attributes if this is the end of the string
    // or the current character is a ?
    //

    if (!*CurrentPos) {

        pRefDN->AttributeList = NULL;
        goto DoneParsing;

    } else if ((*CurrentPos == L'?') && (*(CurrentPos-1) != L'\\' )) {

        pRefDN->AttributeList = NULL;
        CurrentPos++;
        TempPos++;

    } else {

        while( (*TempPos) &&
               (*TempPos != L'?') &&
               (*(TempPos-1) != L'\\')) {
            //
            // Seek the end of the attribute list
            //
            TempPos++;
        }

        if(*TempPos) {
            //
            // and null-terminate it.
            //

            *TempPos = L'\0';
            TempPos++;
        }

            //
            // Count the commas in the attrib string
            //

            PWCHAR lp = CurrentPos;

            while(*lp && *lp != L'\0') {

                if((*lp == L',') && (*(lp-1) != L'\\')) {

                    pRefDN->AttribCount++;
                }
                lp++;
            }

            pRefDN->AttribCount++; // one more attribute than commas

            //
            // allocate an extra location for the null-terminator
            //

            pRefDN->AttributeList = (PWCHAR*) ldapMalloc( sizeof(PWCHAR) * (pRefDN->AttribCount+1),
                                                           LDAP_URL_SIGNATURE);

            if ( pRefDN->AttributeList == NULL ) {

                ldapFree( pRefDN, LDAP_URL_SIGNATURE );
                return NULL;
            }

            PWCHAR lpEnd = CurrentPos; // points to start of attribute list

            for(i=0; i<pRefDN->AttribCount ; i++) {

                PWCHAR lpStart = lpEnd;

                while(*lpEnd && *lpEnd!= L',' && *(lpEnd-1)!= L'\\') {
                    lpEnd++;
                }

                lpStart = lpEnd;
                lpStart++;
                *lpEnd = L'\0';
                pRefDN->AttributeList[i] = ldap_dup_stringW(CurrentPos, 0, LDAP_URL_SIGNATURE);
                CurrentPos = lpStart;
            }

            pRefDN->AttributeList[++i] = NULL;

            //
            // Restore both ptrs to the end of the attribute list.
            //

            CurrentPos = TempPos;

            if (*CurrentPos) {
                //
                // Skip over the next '?'
                //
                CurrentPos++;
                TempPos++;
            }
    }


    //
    // Next is the scope which can be one of 3 values
    //

    if (!*CurrentPos) {

        pRefDN->ScopeOfSearch = LDAP_SCOPE_UNDEFINED;
        goto DoneParsing;

    } else if (*CurrentPos == L'?'){

        pRefDN->ScopeOfSearch = LDAP_SCOPE_UNDEFINED;
        CurrentPos++;
        TempPos++;

    } else {

        ULONG CurrentStrLen = strlenW( CurrentPos );

        if(ldapWStringsIdentical( CurrentPos, (LONG)min( sizeof("one")-1, CurrentStrLen), L"one", -1)) {

            pRefDN->ScopeOfSearch = LDAP_SCOPE_ONELEVEL;
            TempPos += sizeof("one") - 1;

        } else if(ldapWStringsIdentical( CurrentPos, (LONG)min( sizeof("sub")-1, CurrentStrLen), L"sub", -1)) {

            pRefDN->ScopeOfSearch = LDAP_SCOPE_SUBTREE;
            TempPos += sizeof("sub") - 1;

        } else if(ldapWStringsIdentical( CurrentPos, (LONG)min( sizeof("base")-1, CurrentStrLen), L"base", -1)) {

            pRefDN->ScopeOfSearch = LDAP_SCOPE_BASE;
            TempPos += sizeof("base") - 1;

        } else {

            pRefDN->ScopeOfSearch = LDAP_SCOPE_UNDEFINED;
            IF_DEBUG(REFERRALS) {
                LdapPrint0("LdapParseReferralDN: Did not find any scope\n");
            }
        }

        CurrentPos = TempPos;
    }


    //
    // Finally the filter
    //

    if(!*CurrentPos) {

        pRefDN->SearchFilter = NULL;

        IF_DEBUG(REFERRALS) {
            LdapPrint0("LdapParseReferralDN: NO search filter found in referral\n");
        }

    } else {

        if (*CurrentPos != L'?') {
            
            pRefDN->SearchFilter = NULL;
            LdapPrint0("LdapParseReferralDN: Invalid search filter found in referral\n ");
            goto DoneParsing;
        }

        CurrentPos++;
        TempPos++;

        if (*CurrentPos == L'?') {
            
            //
            // This URL has extensions which we will not parse
            //
            goto DoneParsing;
        }
        
        pRefDN->SearchFilter = ldap_dup_stringW(CurrentPos, 0, LDAP_URL_SIGNATURE);

        IF_DEBUG(REFERRALS) {
            LdapPrint1("LdapParseReferralDN: Found search filter %S\n", pRefDN->SearchFilter);
        }
    }

    //
    // For the time being, we will not bother about extensions.
    //

DoneParsing:

    return pRefDN;

}
// referral.c eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\request.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    request.cxx  request block maintencance for the LDAP api

Abstract:

   This module implements routines that maintain request blocks

Author:

    Andy Herron (andyhe)        03-Aug-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

PLDAP_REQUEST LdapCreateRequest (
    PLDAP_CONN Connection,
    UCHAR Operation
    )
//
//  This returns a block that is used to represent a client request.
//
{
    PLDAP_REQUEST request;

    //
    // As we'll be storing a pointer to connection in the request block, we need to
    // reference the connection - this can fail if the connection is being closed.
    // So lets do it up fromt and fail if this fails
    //

    Connection = ReferenceLdapConnection( Connection );
    if (!Connection)
    {
        return NULL;
    }

    //
    //  allocate the request block and setup all the initial values
    //

    request = (PLDAP_REQUEST) ldapMalloc(   sizeof( LDAP_REQUEST),
                                            LDAP_REQUEST_SIGNATURE );

    if (request == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "LdapCreateRequest could not allocate 0x%x bytes.\n", sizeof( LDAP_REQUEST ) );
        }
        DereferenceLdapConnection(Connection);
        return(NULL);
    }

    //
    //  keep in mind the memory is already zero initialized
    //

    request->ReferenceCount = 2;

    __try {
        INITIALIZE_LOCK( &request->Lock );
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // Something went wrong
        //
        IF_DEBUG(REQUEST) {
            LdapPrint2( "LDAP failed to initialize critical sections while creating request at 0x%x, conn is 0x%x.\n",
                           request, Connection );
        }

        ldapFree(request, LDAP_REQUEST_SIGNATURE);
        DereferenceLdapConnection(Connection);

        return NULL;
    }

    request->PrimaryConnection = Connection;

    request->Operation = Operation;
    request->RequestTime = LdapGetTickCount();
    request->TimeLimit = Connection->publicLdapStruct.ld_timelimit;
    request->SizeLimit = Connection->publicLdapStruct.ld_sizelimit;
    request->ReferralHopLimit = LOWORD( Connection->publicLdapStruct.ld_refhoplimit );
    request->ResentAttempts = 0;

    request->ReferenceConnectionsPerMessage = Connection->ReferenceConnectionsPerMessage;

    if (Connection->publicLdapStruct.ld_options & LDAP_OPT_CHASE_REFERRALS) {

        request->ChaseReferrals = (LDAP_CHASE_SUBORDINATE_REFERRALS |
                                   LDAP_CHASE_EXTERNAL_REFERRALS);

    } else if (Connection->publicLdapStruct.ld_options & LDAP_OPT_RETURN_REFS) {

        request->ChaseReferrals = 0;

    } else {

        request->ChaseReferrals = (UCHAR) (Connection->publicLdapStruct.ld_options &
             (LDAP_CHASE_SUBORDINATE_REFERRALS | LDAP_CHASE_EXTERNAL_REFERRALS));
    }
    GET_NEXT_MESSAGE_NUMBER( request->MessageId );
    Connection->publicLdapStruct.ld_msgid = request->MessageId;

    //
    //  put this record into the global list of requests
    //

    ACQUIRE_LOCK( &RequestListLock );

    IF_DEBUG(REQUEST) {
        LdapPrint2( "LDAP creating request at 0x%x, conn is 0x%x.\n",
                       request, Connection );
    }

    InsertTailList( &GlobalListRequests, &request->RequestListEntry );
    GlobalRequestCount++;

    RELEASE_LOCK( &RequestListLock );

    return request;
}


VOID
DereferenceLdapRequest2 (
    PLDAP_REQUEST Request
    )
//
//  This frees all resources for a given request.
//
{
    PLDAP_CONN connection;
    USHORT connCount;
    PREFERRAL_TABLE_ENTRY referral;
    CLdapBer *lber;

    ACQUIRE_LOCK( &RequestListLock );

    IF_DEBUG(REQUEST) {
        LdapPrint2( "LDAP deleting request at 0x%x, conn is 0x%x.\n",
                       Request, Request->PrimaryConnection );
    }

    ACQUIRE_LOCK( &Request->Lock );

    //
    //  we should've come in here by calling at some point CloseLdapRequest
    //

    ASSERT( Request->Closed == TRUE );
    ASSERT( Request->PrimaryConnection );
    ASSERT( Request->ReferenceCount == 0 );

    ClearPendingListForRequest( Request );

    if (Request->RequestListEntry.Flink != NULL) {

        RemoveEntryList( &Request->RequestListEntry );
        Request->RequestListEntry.Flink = NULL;
    }

    GlobalRequestCount--;

    RELEASE_LOCK( &Request->Lock );
    RELEASE_LOCK( &RequestListLock );

    lber = (CLdapBer *) InterlockedExchangePointer(  &Request->BerMessageSent,
                                                     NULL );
    if (lber != NULL) {

        delete lber;
    }

    if (Request->SecondaryConnection != NULL) {

        IF_DEBUG(CONTROLS) {
            LdapPrint1("Last refcnt for sec conn is %d\n", Request->SecondaryConnection->ReferenceCount);
        }

        ACQUIRE_LOCK( &Request->SecondaryConnection->StateLock );

        if ((Request->SecondaryConnection->HandlesGivenToCaller == 0 ) &&
            (Request->SecondaryConnection->HandlesGivenAsReferrals == 0)) {

            RELEASE_LOCK( &Request->SecondaryConnection->StateLock );
            CloseLdapConnection( Request->SecondaryConnection );
        }
        else {
            RELEASE_LOCK( &Request->SecondaryConnection->StateLock );
        }

        DereferenceLdapConnection( Request->SecondaryConnection );

//        IF_DEBUG(CONTROLS) {
//            LdapPrint1("Final refcnt for sec conn is %d\n", Request->SecondaryConnection->ReferenceCount);
//        }

        Request->SecondaryConnection = NULL;
    }

    referral = Request->ReferralConnections;
    if (referral != NULL) {

        for (connCount = 0;
             connCount < Request->ReferralTableSize;
             connCount++ ) {

            connection = referral->ReferralServer;

            if (connection != NULL) {

                DEREFERENCECONNECTION *dereferenceRoutine = connection->DereferenceNotifyRoutine;

                if (referral->CallDerefCallback &&
                    (dereferenceRoutine != NULL)) {

                    (*dereferenceRoutine)( Request->PrimaryConnection->ExternalInfo,
                                           connection->ExternalInfo );
                    referral->CallDerefCallback = FALSE;
                }

                ACQUIRE_LOCK( &connection->StateLock );

                ASSERT(connection->HandlesGivenAsReferrals > 0);
                connection->HandlesGivenAsReferrals--;

                if ((connection->HandlesGivenToCaller == 0 ) &&
                    (connection->HandlesGivenAsReferrals == 0)) {

                    RELEASE_LOCK( &connection->StateLock );
                    CloseLdapConnection( connection );

                } else {

                    RELEASE_LOCK( &connection->StateLock );
                }

                DereferenceLdapConnection( connection );
                referral->ReferralServer = NULL;
            }

            if (referral->ReferralDN != NULL) {

                ldapFree( referral->ReferralDN, LDAP_REFDN_SIGNATURE );
                referral->ReferralDN = NULL;
            }

            lber = (CLdapBer *) InterlockedExchangePointer(  &referral->BerMessageSent,
                                                             NULL );
            if (lber != NULL) {

                delete lber;
            }
            referral++;     // on to next entry
        }

        ldapFree( Request->ReferralConnections, LDAP_REFTABLE_SIGNATURE );
        Request->ReferralConnections = NULL;
    }

    //
    //  Free all messages remaining on this request
    //

    PLDAPMessage nextMessage;
    PLDAPMessage message;

    message = Request->MessageLinkedList;

    while (message != NULL) {

        nextMessage = message->lm_next;
        message->lm_next = NULL;

        ldap_msgfree( message );

        message = nextMessage;
    }

    DELETE_LOCK( &Request->Lock );

    //
    //  Free all saved parameters for this request
    //

    if (Request->AllocatedParms == TRUE) {

        if (Request->OriginalDN != NULL) {

            ldapFree( Request->OriginalDN, LDAP_UNICODE_SIGNATURE );
        }

        switch (Request->Operation) {
        case LDAP_ADD_CMD:

            LdapFreeLDAPModStructure( Request->add.AttributeList,
                                      Request->add.Unicode );
            break;

        case LDAP_COMPARE_CMD:

            if ( Request->compare.Attribute != NULL ) {
                ldapFree( Request->compare.Attribute, LDAP_UNICODE_SIGNATURE );
            }
            if ( Request->compare.Value != NULL ) {
                ldapFree( Request->compare.Value, LDAP_UNICODE_SIGNATURE );
            }
            if ( Request->compare.Data.bv_val != NULL ) {
                ldapFree( Request->compare.Data.bv_val, LDAP_COMPARE_DATA_SIGNATURE );
            }
            break;

        case LDAP_MODRDN_CMD:

            if (Request->rename.NewDistinguishedName != NULL) {
                ldapFree( Request->rename.NewDistinguishedName, LDAP_UNICODE_SIGNATURE );
            }
            if (Request->rename.NewParent != NULL) {
                ldapFree( Request->rename.NewParent, LDAP_UNICODE_SIGNATURE );
            }
            break;

        case LDAP_MODIFY_CMD:

            LdapFreeLDAPModStructure( Request->modify.AttributeList,
                                      Request->modify.Unicode );
            break;

        case LDAP_SEARCH_CMD:

            if ( Request->search.SearchFilter != NULL ) {
                ldapFree( Request->search.SearchFilter, LDAP_UNICODE_SIGNATURE );
            }

            if ( Request->search.AttributeList != NULL ) {

                PWCHAR *attr = Request->search.AttributeList;

                while (*attr != NULL) {

                    if (Request->search.Unicode) {

                        ldapFree( *attr, LDAP_UNICODE_SIGNATURE );

                    } else {

                        ldapFree( *attr, LDAP_ANSI_SIGNATURE );
                    }
                    attr++;
                }

                ldapFree( Request->search.AttributeList, LDAP_MOD_VALUE_SIGNATURE );
            }

            break;

        case LDAP_EXTENDED_CMD:

            ldapFree( Request->extended.Data.bv_val, LDAP_EXTENDED_OP_SIGNATURE );
            break;

        case LDAP_DELETE_CMD :      // none saved other than DN
        case LDAP_BIND_CMD :        // no saved parameters
            break;

        default:

            IF_DEBUG(REQUEST) {
                LdapPrint2( "LDAP unknown request type of 0x%x, conn is 0x%x.\n",
                            Request->Operation, Request->PrimaryConnection);
            }
        }
    }

    if (Request->AllocatedControls) {

        ldap_controls_freeW( Request->ServerControls );
        ldap_controls_freeW( Request->ClientControls );
    }

    if (Request->PagedSearchServerCookie != NULL) {

        ber_bvfree( Request->PagedSearchServerCookie );
    }

    //
    // Dereference the primary connection
    //

    DereferenceLdapConnection( Request->PrimaryConnection );
    Request->PrimaryConnection = NULL;

    //
    // Dereference the associated search block if one exists
    //

    if ( Request->PageRequest ) {
        DereferenceLdapRequest( Request->PageRequest );
        Request->PageRequest = NULL;
    }

    ldapFree( Request, LDAP_REQUEST_SIGNATURE );

    return;
}


VOID
CloseLdapRequest (
    PLDAP_REQUEST Request
    )
{
    ACQUIRE_LOCK( &Request->Lock );

    if (Request->Closed == FALSE) {

        Request->Closed = TRUE;

        IF_DEBUG(REQUEST) {
            LdapPrint1( "CloseLdapRequest closing request 0x%x.\n", Request );
        }

        RELEASE_LOCK( &Request->Lock );

        DereferenceLdapRequest( Request );

    } else {

        IF_DEBUG(REQUEST) {
            LdapPrint1( "CloseLdapRequest couldn't close request 0x%x.\n", Request );
        }
        RELEASE_LOCK( &Request->Lock );
    }

    return;
}

PLDAP_REQUEST
FindLdapRequest(
    LONG MessageId
    )
{
    PLDAP_REQUEST request = NULL;
    PLIST_ENTRY listEntry;

    if (MessageId != 0) {

        ACQUIRE_LOCK( &RequestListLock );

        listEntry = GlobalListRequests.Flink;

        while ((listEntry != &GlobalListRequests) &&
               (request == NULL)) {

            request = CONTAINING_RECORD( listEntry, LDAP_REQUEST, RequestListEntry );
            request = ReferenceLdapRequest( request );

            listEntry = listEntry->Flink;
            
            if (!request) {
                continue;
            }
            
            if (( request->MessageId == MessageId) &&
                ( request->Abandoned == FALSE ) &&
                ( request->Closed == FALSE) ) {

                break;
            }

            DereferenceLdapRequest( request );
            request = NULL;
        }

        if (request == NULL) {

            IF_DEBUG(REQUEST) {
                LdapPrint1( "FindLdapRequest couldn't find request 0x%x.\n", MessageId );
            }
        }
        
        RELEASE_LOCK( &RequestListLock );
    }
    return request;
}

//
// These routines implements tracking the number of outstanding requests we have
// per LDAP connection.  We do this so that we don't hang.... if we go into
// DrainWinsock without actually having any requests pending.
//

ULONG
AddToPendingList (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection
    )
//
//  Add a new element to the list if required.  If it already exists in the
//  list then just bump the request count.
//
//  The Request->Lock will be taken in here.
//
{
    ULONG result = LDAP_SUCCESS;

    ACQUIRE_LOCK( &Request->Lock );

    if (Connection == Request->PrimaryConnection) {

        InterlockedIncrement( &Connection->ResponsesExpected );
        Request->ResponsesOutstanding++;
        Request->RequestsPending++;
        InterlockedIncrement( &GlobalCountOfOpenRequests );

        IF_DEBUG(REQUEST) {
            LdapPrint2( "LdapAddToPendingList bumping outstanding to 0x%x for 0x%x.\n",
                         Request->ResponsesOutstanding, Request );
        }
    } else {

        PREFERRAL_TABLE_ENTRY refTable = Request->ReferralConnections;
        USHORT limit = Request->ReferralTableSize;
        USHORT i = 0;
        BOOLEAN found = FALSE;

        result = LDAP_LOCAL_ERROR;

        if (refTable != NULL) {

            while (i < limit) {

                if (refTable->ReferralServer == Connection) {

                    InterlockedIncrement( &GlobalCountOfOpenRequests );

                    InterlockedIncrement( &Connection->ResponsesExpected );
                    Request->ResponsesOutstanding++;
                    refTable->RequestsPending++;
                    found = TRUE;

                    IF_DEBUG(REQUEST) {
                        LdapPrint2( "LdapAddToPendingList bumping outstanding to 0x%x for 0x%x.\n",
                                     Request->ResponsesOutstanding, Request );
                    }
                    result = LDAP_SUCCESS;
                    break;
                }
                i++;
                refTable++;
            }
        }

        if ( found == FALSE ) {
            IF_DEBUG(REQUEST) {
                LdapPrint1( "LdapAddToPendingList couldn't bump for request 0x%x.\n", Request );
            }
        }
    }

    RELEASE_LOCK( &Request->Lock );

    return result;
}

VOID
DecrementPendingList (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection
    )
//
//  The Request->Lock will be taken in here.
//
{
    CLdapBer *lber;

    ACQUIRE_LOCK( &Request->Lock );
    
    if ((Connection == Request->PrimaryConnection) &&
        (Request->RequestsPending > 0)) {

        InterlockedDecrement( &Connection->ResponsesExpected );
        Request->ResponsesOutstanding--;
        Request->RequestsPending--;
        InterlockedDecrement( &GlobalCountOfOpenRequests );

        lber = (CLdapBer *) InterlockedExchangePointer(  &Request->BerMessageSent,
                                                         NULL );
        if (lber != NULL) {
            delete lber;
        }

        IF_DEBUG(REQUEST) {
            LdapPrint2( "LdapDecrementPendingList bumping outstanding to 0x%x for 0x%x.\n",
                         Request->ResponsesOutstanding, Request );
        }

    } else {

        PREFERRAL_TABLE_ENTRY refTable = Request->ReferralConnections;
        BOOLEAN found = FALSE;

        if (refTable != NULL) {

            USHORT limit = Request->ReferralTableSize;
            USHORT i = 0;

            while (i < limit) {

                if ((refTable->ReferralServer == Connection) &&
                    (refTable->RequestsPending > 0)) {

                    InterlockedDecrement( &Connection->ResponsesExpected );
                    InterlockedDecrement( &GlobalCountOfOpenRequests );
                    Request->ResponsesOutstanding--;
                    refTable->RequestsPending--;
                    found = TRUE;

                    lber = (CLdapBer *) InterlockedExchangePointer(  &refTable->BerMessageSent,
                                                                     NULL );
                    if (lber != NULL) {
                        delete lber;
                    }

//                  IF_DEBUG(REQUEST) {
                    IF_DEBUG(SCRATCH) {
                        LdapPrint2( "LdapDecrementPendingList bumping outstanding to 0x%x for 0x%x.\n",
                                     Request->ResponsesOutstanding, Request );
                    }
                    break;
                }
                i++;
                refTable++;
            }
        }
        if ( found == FALSE ) {
//          IF_DEBUG(REQUEST) {
            IF_DEBUG(SCRATCH) {
                LdapPrint1( "LdapDecrementPendingList couldn't bump for request 0x%x.\n", Request );
            }
        }
    }

    RELEASE_LOCK( &Request->Lock );
    
    return;
}

VOID
ClearPendingListForRequest (
    PLDAP_REQUEST Request
    )
//
//  The Request->Lock must be held coming in here.
//
{
    ULONG i = Request->RequestsPending;
    PLDAP_CONN conn = Request->PrimaryConnection;

    //
    //  yes, I know this is slow, but the only protection we have for
    //  GlobalCountOfOpenRequests is interlockedIncrement/Decrement.
    //

    while ( i-- > 0) {

        InterlockedDecrement( &GlobalCountOfOpenRequests );

        if (conn != NULL) {
            InterlockedDecrement( &conn->ResponsesExpected );
        }
    }

    Request->RequestsPending = 0;
    Request->ResponsesOutstanding = 0;

    IF_DEBUG(REQUEST) {
        LdapPrint1( "LdapClearPendingList cleared request 0x%x.\n", Request );
    }

    PREFERRAL_TABLE_ENTRY refTable = Request->ReferralConnections;

    if (refTable != NULL) {

        USHORT limit = Request->ReferralTableSize;
        USHORT referralCount = 0;

        while (referralCount < limit) {

            i = refTable->RequestsPending;

            conn = refTable->ReferralServer;

            while ( i-- > 0) {

                InterlockedDecrement( &GlobalCountOfOpenRequests );

                if (conn != NULL) {
                    InterlockedDecrement( &conn->ResponsesExpected );
                }
            }
            refTable->RequestsPending = 0;

            referralCount++;
            refTable++;
        }
    }

    return;
}

VOID
ClearPendingListForConnection (
    PLDAP_CONN Connection
    )
//
//  The RequestListLock and Request->Lock will be taken in here.
//
//  Go through all requests and for each one, check to see if this connection
//  is included... if so, decrement the number of outstanding requests by the
//  number of pending requests.
//
{
    PLDAP_REQUEST request;
    PLIST_ENTRY listEntry;
    ULONG i;
    PMESSAGE_ID_LIST_ENTRY messageIdsToFree = NULL;
    PMESSAGE_ID_LIST_ENTRY currentNode = NULL;

    ACQUIRE_LOCK( &RequestListLock );

    IF_DEBUG(REQUEST) {
        LdapPrint1( "LdapClearPendingList cleared for conn 0x%x.\n", Connection );
    }

    listEntry = GlobalListRequests.Flink;

    while (listEntry != &GlobalListRequests) {

        //
        //  we may have to add an entry at the end of the request's message
        //  list since this connection went down.  We do this when this
        //  connection was the last connection we were waiting for and we
        //  have no more search entries to mark as end-of-message.
        //

        BOOLEAN markEom = FALSE;

        request = CONTAINING_RECORD( listEntry, LDAP_REQUEST, RequestListEntry );
        
        request = ReferenceLdapRequest(request);
        listEntry = listEntry->Flink;

        if ( !request ) {
            continue;
        }

        ACQUIRE_LOCK( &request->Lock );

        if (Connection == request->PrimaryConnection) {

            i = request->RequestsPending;

            //
            //  yes, I know this is slow, but the only protection we have for
            //  GlobalCountOfOpenRequests is interlockedIncrement/Decrement.
            //

            while ( i-- > 0) {
                InterlockedDecrement( &GlobalCountOfOpenRequests );
            }

            request->ResponsesOutstanding -= LOWORD( request->RequestsPending );
            request->RequestsPending = 0;

            if (request->ResponsesOutstanding == 0) {

                markEom = TRUE;
            }
        }

        //
        //  now we go through the referral table for this request...
        //

        PREFERRAL_TABLE_ENTRY refTable = request->ReferralConnections;

        if (refTable != NULL) {

            USHORT limit = request->ReferralTableSize;
            USHORT referralCount = 0;

            while (referralCount < limit) {

                if (refTable->ReferralServer == Connection) {

                    i = refTable->RequestsPending;

                    while ( i-- > 0) {
                        InterlockedDecrement( &GlobalCountOfOpenRequests );
                    }

                    request->ResponsesOutstanding -= LOWORD( refTable->RequestsPending );

                    if (request->ResponsesOutstanding == 0) {

                        markEom = TRUE;
                    }
                    refTable->RequestsPending = 0;
                }
                referralCount++;
                refTable++;
            }
        }

        if (markEom) {

            ULONG err = SimulateErrorMessage( Connection,
                                              request,
                                              LDAP_SERVER_DOWN
                                              );

            IF_DEBUG(SERVERDOWN) {
                LdapPrint2( "ldapClearPending thread 0x%x has connection 0x%x simulated as down\n",
                                GetCurrentThreadId(),
                                Connection );
            }
            if (err != LDAP_SUCCESS) {

                request->Abandoned = TRUE;
            }
            currentNode = (PMESSAGE_ID_LIST_ENTRY) ldapMalloc( sizeof( MESSAGE_ID_LIST_ENTRY ),
                                                           LDAP_MSGID_SIGNATURE );

            if (currentNode != NULL) {

                currentNode->Next = messageIdsToFree;
                currentNode->MessageId = request->MessageId;
                messageIdsToFree = currentNode;
            }

        }
        RELEASE_LOCK( &request->Lock );
        DereferenceLdapRequest( request );
    }

    //
    //  since we cleared out all requests for this conn, zero out the number
    //  of responses we're expecting.
    //

    Connection->ResponsesExpected = 0;

    RELEASE_LOCK( &RequestListLock );

    //
    //  Now we go through and wake up any threads that are waiting for these
    //  requests.
    //

    if (messageIdsToFree != NULL) {

        ACQUIRE_LOCK( &ConnectionListLock );

        while (messageIdsToFree != NULL) {

            currentNode = messageIdsToFree;
            messageIdsToFree = messageIdsToFree->Next;

            CheckForWaiters( currentNode->MessageId, FALSE, Connection );
            ldapFree( currentNode, LDAP_MSGID_SIGNATURE );
        }

        RELEASE_LOCK( &ConnectionListLock );

        LdapWakeupSelect();
    }

    return;
}

ULONG
SimulateErrorMessage (
    PLDAP_CONN Connection,
    PLDAP_REQUEST Request,
    ULONG Error
    )
{
    //
    //  we mark the last message received as EndOfMessage.  If there
    //  isn't one, we make up our own.
    //

    PLDAPMessage lastEntry = Request->MessageLinkedList;
    PLDAPMessage newEntry = NULL;

    if (lastEntry != NULL) {

        while (lastEntry->lm_chain != NULL) {
            lastEntry = lastEntry->lm_chain;
        }
    }

    if ((lastEntry == NULL) ||
        (lastEntry->lm_msgtype == LDAP_RES_SEARCH_ENTRY) ||
        (lastEntry->lm_msgtype == LDAP_RES_REFERRAL)) {

        newEntry = (PLDAPMessage) ldapMalloc( sizeof(LDAPMessage),
                                               LDAP_MESG_SIGNATURE );

        if (newEntry == NULL) {

            return LDAP_NO_MEMORY;
        }

        newEntry->Connection = Connection->ExternalInfo;
        newEntry->Request = Request;
        newEntry->lm_returncode = Error;
        newEntry->lm_time = GetTickCount();
        newEntry->lm_msgid = Request->MessageId;

        if (Request->Operation == LDAP_SEARCH_CMD) {

            newEntry->lm_msgtype = LDAP_RES_SEARCH_RESULT;

        } else if (Request->Operation == LDAP_BIND_CMD) {

            newEntry->lm_msgtype = LDAP_RES_BIND;

        } else if (Request->Operation == LDAP_MODIFY_CMD) {

            newEntry->lm_msgtype = LDAP_RES_MODIFY;

        } else if (Request->Operation == LDAP_ADD_CMD) {

            newEntry->lm_msgtype = LDAP_RES_ADD;

        } else if (Request->Operation == LDAP_DELETE_CMD) {

            newEntry->lm_msgtype = LDAP_RES_DELETE;

        } else if (Request->Operation == LDAP_MODRDN_CMD) {

            newEntry->lm_msgtype = LDAP_RES_MODRDN;

        } else if (Request->Operation == LDAP_COMPARE_CMD) {

            newEntry->lm_msgtype = LDAP_RES_COMPARE;

        } else if (Request->Operation == LDAP_EXTENDED_CMD) {

            newEntry->lm_msgtype = LDAP_RES_EXTENDED;

        } else {

            ASSERT( Request->Operation == LDAP_SEARCH_CMD );
            newEntry->lm_msgtype = LDAP_RES_SEARCH_RESULT;
        }

        if (lastEntry == NULL) {

            Request->MessageLinkedList = newEntry;

        } else {

            lastEntry->lm_chain = newEntry;
        }
        lastEntry = newEntry;
    }

    IF_DEBUG(EOM) {
         LdapPrint2( "LdapClearConn faking eom for request 0x%x, msg 0x%x\n",
                     Request, lastEntry );
    }
    lastEntry->lm_eom = TRUE;

    return LDAP_SUCCESS;
}

// request.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\results.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    results.cxx parse out results from LDAP servers

Abstract:

   This module implements the APIs to break apart LDAP results

Author:

    Andy Herron (andyhe)        02-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

PWCHAR * __cdecl
ldap_get_valuesW (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    PWCHAR           Attribute
    )
//
//  This routine gets the attribute value for a given attribute.
//
{
    PWCHAR *Output = NULL;
    ULONG hr;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    hr = LdapGetValues( connection,
                        Message,
                        Attribute,
                        FALSE,
                        TRUE,       // return in Unicode
                        (PVOID *) &Output
                        );

    if (hr != NOERROR) {
        IF_DEBUG(PARSE) {
            LdapPrint1( "ldap_get_values had decoding error of 0x0x%x .\n", hr);
        }
    }

    DereferenceLdapConnection( connection );

    return(Output);
}

PCHAR * __cdecl
ldap_get_values (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    PCHAR           Attribute
    )
//
//  This routine gets the attribute value for a given attribute.
//
{
    PCHAR *Output = NULL;
    ULONG hr = NOERROR;
    ULONG err;
    PWCHAR attr = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    err = ToUnicodeWithAlloc( Attribute, -1, &attr, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    hr = LdapGetValues( connection,
                        Message,
                        attr,
                        FALSE,
                        FALSE,
                        (PVOID *) &Output
                        );

error:
    if (attr)
        ldapFree( attr, LDAP_UNICODE_SIGNATURE );

    if (hr != NOERROR) {
        IF_DEBUG(PARSE) {
            LdapPrint1( "ldap_get_values had decoding error of 0x0x%x .\n", hr);
        }
    }

    DereferenceLdapConnection( connection );

    return(Output);
}

PCHAR * __cdecl
ldap_get_valuesA (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    PCHAR           Attribute
    )
{
    return ldap_get_values( ExternalHandle, Message, Attribute );
}


struct berval **__cdecl
ldap_get_values_lenW (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    PWCHAR          Attribute
    )
//
//  This routine gets the attribute value for a given attribute.  It returns
//  it as a berval structure rather than a string.
//
{
    struct berval **Output = NULL;
    ULONG hr;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    hr = LdapGetValues( connection,
                        Message,
                        Attribute,
                        TRUE,
                        TRUE,              // in unicode form
                        (PVOID *) &Output
                        );

    if (hr != NOERROR) {
        IF_DEBUG(PARSE) {
            LdapPrint1( "ldap_get_values_len had decoding error of 0x0x%x .\n", hr);
        }
    }

    DereferenceLdapConnection( connection );

    return(Output);
}

struct berval **__cdecl
ldap_get_values_len (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    PCHAR           Attribute
    )
//
//  This routine gets the attribute value for a given attribute.  It returns
//  it as a berval structure rather than a string.
//
{
    struct berval **Output = NULL;
    ULONG hr = NOERROR;
    ULONG err;
    PWCHAR attr = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    err = ToUnicodeWithAlloc( Attribute, -1, &attr, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    hr = LdapGetValues( connection,
                        Message,
                        attr,
                        TRUE,
                        FALSE,              // not in unicode form
                        (PVOID *) &Output
                        );

error:
    if (attr)
        ldapFree( attr, LDAP_UNICODE_SIGNATURE );

    if (hr != NOERROR) {
        IF_DEBUG(PARSE) {
            LdapPrint1( "ldap_get_values_len had decoding error of 0x0x%x .\n", hr);
        }
    }

    DereferenceLdapConnection( connection );

    return(Output);
}

ULONG
LdapGetValues (
    PLDAP_CONN      connection,
    LDAPMessage     *Message,
    PWCHAR          attr,
    BOOLEAN         BerVal,     // do we put value out raw in buffer
    BOOLEAN         Unicode,    // do we leave value as unicode or convert to single
    PVOID           *Output
    )
//
//  This routine gets the attribute value for a given attribute.  It returns
//  it as a berval structure rather than a string.
//
{
    CLdapBer *lber = NULL;
    CLdapBer *newLber = NULL;
    ULONG hr;
    PLDAP_ATTR_NAME_THREAD_STORAGE threadAttr;
    DWORD currentThread;
    ULONG tag;
    BOOLEAN startAgain = TRUE;      // do we have to reparse message?
    struct berval **resultBer = NULL;
    WCHAR attributeType[MAX_ATTRIBUTE_NAME_LENGTH];
    BOOLEAN notFound = TRUE;
    ULONG resultCount = 0;      // current offset in table
    ULONG sizeResultTable = 2;  // current size of result table
    PWCHAR *resultWStr = NULL;
    PCHAR *resultStr = NULL;
    PVOID outputArray = NULL;

    PLIST_ENTRY pThreadListEntry = NULL;
    PTHREAD_ENTRY pThreadEntry = NULL;
    BOOLEAN fRetriedFindThread = FALSE;

    *Output = NULL;

    if (Message == NULL) {

        return LDAP_PARAM_ERROR;
    }

    if (Message->lm_msgtype != LDAP_RES_SEARCH_ENTRY) {

        SetConnectionError( connection, LDAP_DECODING_ERROR, NULL );
        return LDAP_DECODING_ERROR;
    }

    currentThread = GetCurrentThreadId();

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    lber = (CLdapBer *) Message->lm_ber;

    //
    //  depending on what the last call was, we're either at the start of a
    //  sequence for the next attribute or the start of a set of attribute
    //  values for the current attribute.  We'll peak at the tag and if
    //  we're at a set, we'll check the current attribute to see if we
    //  can just use these values.
    //

    hr = lber->HrPeekTag( &tag );

    if ((hr != LDAP_NO_SUCH_ATTRIBUTE) &&
        (tag == BER_SET)) {

        //
        // Find the buffer that stored the attribute name off of this connection
        // to check the attribute name of the current location.
        // This requires first finding the THREAD_ENTRY for this thread,
        // then the attribute entry for this connection off of that thread entry.
        //
retryFindThread:

        ACQUIRE_LOCK( &PerThreadListLock );

        pThreadListEntry = GlobalPerThreadList.Flink;

        // find the THREAD_ENTRY for this thread
        while (pThreadListEntry != &GlobalPerThreadList) {

            pThreadEntry = CONTAINING_RECORD( pThreadListEntry, THREAD_ENTRY, ThreadEntry );
            pThreadListEntry = pThreadListEntry->Flink;

            if (pThreadEntry->dwThreadID == currentThread) {
                break;
            }

            pThreadEntry = NULL;
        }


        if (!pThreadEntry && !fRetriedFindThread) {
            // this thread must have been created before this DLL was loaded-
            // create a per-thread entry for it now
            RELEASE_LOCK( &PerThreadListLock );
            IF_DEBUG(PARSE) {
                LdapPrint2( "LdapGetValues could not find ThreadEntry for conn 0x%x, thread 0x%x.  Creating one.\n",
                                connection, currentThread );
            }

            if (!AddPerThreadEntry(currentThread)) {
                IF_DEBUG(PARSE) {
                    LdapPrint2( "LdapGetValues AddPerThreadEntry failed, conn 0x%x, thread 0x%x.\n",
                                    connection, currentThread );
                }
                SetConnectionError( connection, LDAP_NO_MEMORY, NULL );
                return LDAP_NO_MEMORY;
            }

            fRetriedFindThread = TRUE;
            goto retryFindThread;
        }
        else if (!pThreadEntry) {
            // shouldn't happen --- somehow a thread entry wasn't created
            RELEASE_LOCK( &PerThreadListLock );
            IF_DEBUG(PARSE) {
                LdapPrint2( "LdapGetValues no per-thread entry, conn 0x%x, thread 0x%x.\n",
                                connection, currentThread );
            }            
            ASSERT(pThreadEntry);
            SetConnectionError( connection, LDAP_LOCAL_ERROR, NULL );
            return LDAP_LOCAL_ERROR;
        }


        // find the attribute entry for this connection
        threadAttr = pThreadEntry->pCurrentAttrList;

        while (threadAttr != NULL) {

            if (threadAttr->PrimaryConn == connection) {
                ASSERT(threadAttr->Thread == currentThread);
                break;
            }
            
            threadAttr = threadAttr->pNext;
        }

        RELEASE_LOCK( &PerThreadListLock );
        
        if (threadAttr != NULL) {

            if (ldapWStringsIdentical(  &(threadAttr->AttributeNameW[0]),
                                        -1,
                                        attr,
                                        -1) == TRUE) {

                startAgain = FALSE;
            }
        }
        
    }

    if (startAgain) {

        //
        //  Create a temp copy of the lber message and look for the attribute
        //  in the message
        //

        newLber = new CLdapBer( connection->publicLdapStruct.ld_version );

        if (newLber == NULL) {
            IF_DEBUG(OUTMEMORY) {
                LdapPrint1( "LdapGetValues conn 0x%x could not allocate message.\n",
                                connection);
            }
            hr = LDAP_NO_MEMORY;
            goto exitGetValues;
        }

        hr = newLber->CopyExistingBERStructure( lber );
        if (hr != NOERROR) {
            IF_DEBUG(OUTMEMORY) {
                LdapPrint2( "LdapGetValues conn 0x%x could not create message, 0x0x%x .\n",
                                connection, hr);
            }
            SetConnectionError( connection, LDAP_NO_MEMORY, NULL );
            goto exitGetValues;
        }

        lber = newLber;

        hr = LdapGoToFirstAttribute( connection, lber );
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "LdapGetValues 1 conn 0x%x received protocol error 0x%x .\n",
                                connection, hr);
            }

protocolError:
            SetConnectionError( connection, LDAP_DECODING_ERROR, NULL );
            goto exitGetValues;
        }

        while (notFound && (hr == NOERROR)) {

            hr = lber->HrStartReadSequence();

            if (hr != NOERROR) {
                IF_DEBUG(PARSE) {
                    LdapPrint2( "LdapGetValues 8 conn 0x%x received protocol error 0x%x .\n",
                                    connection, hr);
                }
                continue;
            }

            hr = lber->HrGetValue(  (WCHAR *) &(attributeType[0]),
                                    MAX_ATTRIBUTE_NAME_LENGTH - 1,
                                    BER_OCTETSTRING );

            if (hr == NOERROR) {

                if (ldapWStringsIdentical(  &(attributeType[0]),
                                            -1,
                                            attr,
                                            -1) == TRUE) {

                    notFound = FALSE;
                    continue;
                }

                //
                //  not this attribute, skip the value for it.  Note that if
                //  we get a protocol error here, we bail since it really is
                //  an error and not the end of data.
                //

                hr = lber->HrEndReadSequence(); // skip the attribute value

                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapGetValues 2 conn 0x%x received protocol error 0x%x .\n",
                                        connection, hr);
                    }
                    goto protocolError;
                }
            }
        }

        if ((hr != NOERROR) || notFound) {

            //
            //  we didn't find the attribute
            //

            IF_DEBUG(PARSE) {
                LdapPrint2( "LdapGetValues conn 0x%x did not find attribute %s\n",
                                connection, attr );
            }
            SetConnectionError( connection, hr, NULL );
            goto exitGetValues;
        }
    }

    //
    //  Read the set of values from the lber buffer one at a time.  We store
    //  them in a list of PVOID pointers.
    //

    hr = lber->HrStartReadSequence(BER_SET);
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "LdapGetValues 2 conn 0x%x received protocol error 0x%x .\n",
                            connection, hr);
        }
        goto protocolError;
    }

    if (BerVal) {

        //
        //  get the list of attribute values in BER_VAL structures
        //

        while (hr == NOERROR) {

            struct berval *attrValue;

            if ((resultBer == NULL) ||
                (resultCount >= (sizeResultTable-1))) {      // leave room for null

                if (sizeResultTable < 256) {    // only increase table size slowly
                    sizeResultTable *= 2;
                } else {
                    sizeResultTable += 256;
                }

                struct berval **newResultTable = (struct berval **)
                                ldapMalloc( sizeof(struct berval *) * sizeResultTable,
                                            LDAP_VALUE_LIST_SIGNATURE );

                if (newResultTable == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint2( "LdapGetValues 3 conn 0x%x could not allocate mem of 0x%x .\n",
                                        connection, sizeof(PCHAR) * sizeResultTable);
                    }
                    hr = LDAP_NO_MEMORY;
                    goto exitGetValues;
                }

                if (resultBer != NULL) {

                    CopyMemory( newResultTable,
                                resultBer,
                                sizeof(struct berval *) * resultCount );
                    ldapFree( resultBer, LDAP_VALUE_LIST_SIGNATURE );
                }
                resultBer = newResultTable;
            }

            hr = lber->HrGetValueWithAlloc( &attrValue );
            if (hr != NOERROR) {

                if (hr == LDAP_NO_MEMORY) {
                    goto exitGetValues;
                }
                
                //
                //  This will fail when we hit the end of the attribute list
                //

                IF_DEBUG(TRACE1) {
                    LdapPrint2( "LdapGetValues 4 conn 0x%x received error 0x%x .\n",
                                    connection, hr);
                }

                continue;       // rest of results may be valid
            }

            *(resultBer+resultCount) = attrValue;
            resultCount++;
        }

        outputArray = resultBer;

    } else if (Unicode) {

        //
        //  get the list of attribute values in form of unicode strings
        //

        while (hr == NOERROR) {

            PWCHAR attrWValue = NULL;

            if ((resultWStr == NULL) ||
                (resultCount >= (sizeResultTable-1))) {      // leave room for null

                if (sizeResultTable < 256) {    // only increase table size slowly
                    sizeResultTable *= 2;
                } else {
                    sizeResultTable += 256;
                }

                PWCHAR *newResultTable = (PWCHAR *) ldapMalloc( sizeof(PWCHAR) * sizeResultTable,
                                                    LDAP_VALUE_LIST_SIGNATURE );

                if (newResultTable == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint2( "LdapGetValues 3 conn 0x%x could not allocate mem of 0x%x .\n",
                                        connection, sizeof(PWCHAR) * sizeResultTable);
                    }
                    hr = LDAP_NO_MEMORY;
                    goto exitGetValues;
                }

                if (resultWStr != NULL) {

                    CopyMemory( newResultTable, resultWStr, sizeof(PWCHAR) * resultCount );
                    ldapFree( resultWStr, LDAP_VALUE_LIST_SIGNATURE );
                }
                resultWStr = newResultTable;
            }

            hr = lber->HrGetValueWithAlloc( &attrWValue );
            if (hr != NOERROR) {

                if (hr == LDAP_NO_MEMORY) {
                    goto exitGetValues;
                }
                
                //
                //  This will fail when we hit the end of the attribute list
                //

                IF_DEBUG(TRACE1) {
                    LdapPrint2( "LdapGetValues 4 conn 0x%x received error 0x%x .\n",
                                    connection, hr);
                }
                continue;       // rest of results may be valid
            }

            *(resultWStr+resultCount) = attrWValue;
            resultCount++;
        }

        outputArray = resultWStr;

    } else {

        //
        //  get the list of attribute values in form of single byte strings
        //

        while (hr == NOERROR) {

            PCHAR attrValue = NULL;

            if ((resultStr == NULL) ||
                (resultCount >= (sizeResultTable-1))) {      // leave room for null

                if (sizeResultTable < 256) {    // only increase table size slowly
                    sizeResultTable *= 2;
                } else {
                    sizeResultTable += 256;
                }

                PCHAR *newResultTable = (PCHAR *) ldapMalloc( sizeof(PCHAR) * sizeResultTable,
                                                    LDAP_VALUE_LIST_SIGNATURE );

                if (newResultTable == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint2( "LdapGetValues 3 conn 0x%x could not allocate mem of 0x%x .\n",
                                        connection, sizeof(PCHAR) * sizeResultTable);
                    }
                    hr = LDAP_NO_MEMORY;
                    goto exitGetValues;
                }

                if (resultStr != NULL) {

                    CopyMemory( newResultTable, resultStr, sizeof(PCHAR) * resultCount );
                    ldapFree( resultStr, LDAP_VALUE_LIST_SIGNATURE );
                }
                resultStr = newResultTable;
            }

            hr = lber->HrGetValueWithAlloc( &attrValue );
            if (hr != NOERROR) {

                if (hr == LDAP_NO_MEMORY) {
                    goto exitGetValues;
                }
                
                //
                //  This will fail when we hit the end of the attribute list
                //

                IF_DEBUG(TRACE1) {
                    LdapPrint2( "LdapGetValues 4 conn 0x%x received error 0x%x .\n",
                                    connection, hr);
                }
                continue;       // rest of results may be valid
            }

            *(resultStr+resultCount) = attrValue;
            resultCount++;
        }

        outputArray = resultStr;
    }

    if (outputArray != NULL) {

        *(((PCHAR *) outputArray)+resultCount) = NULL;
    }

    hr = lber->HrEndReadSequence(); // for set of values
    ASSERT( hr == NOERROR );

exitGetValues:

    if (newLber != NULL) {
        delete newLber;
    }

    if (hr == LDAP_NO_MEMORY) {
        
        //
        // Cleanup any partial allocations.
        //
        
        ldap_value_free( (PCHAR*) outputArray );
        outputArray = NULL;
    }
    
    SetConnectionError( connection, hr, NULL );
    
    *Output = outputArray;
    return hr;
}



ULONG __cdecl
ldap_count_values (
    PCHAR *vals
    )
//
//  Count the number of values returned in a list of attribute value strings
//
{
    ULONG count;

    if (vals == NULL) {
        return 0;
    }

    for (count = 0; vals[count] != NULL; count++ );

    return count;
}

ULONG __cdecl
ldap_count_valuesW (
    PWCHAR *vals
    )
{
    return ldap_count_values((PCHAR *) vals);
}


ULONG __cdecl
ldap_value_free (
    PCHAR *vals
    )
//
//  Free a list of values returned in a list of attribute value strings
//
{
    ULONG count;

    if (vals == NULL) {
        return LDAP_SUCCESS;
    }

    for (count = 0; vals[count] != NULL; count++ ) {

        ldapFree( vals[count], LDAP_VALUE_SIGNATURE );
        vals[count] = NULL;     // aid debugging
    }
    ldapFree( vals, LDAP_VALUE_LIST_SIGNATURE );

    return LDAP_SUCCESS;
}

ULONG __cdecl
ldap_value_freeW (
    PWCHAR *vals
    )
{
    return ldap_value_free( (PCHAR *) vals );
}


ULONG __cdecl
ldap_count_values_len (
    struct berval **vals
    )
{
    return( ldap_count_values( (PCHAR *) vals ));
}

ULONG __cdecl
ldap_value_free_len (
    struct berval **vals
    )
{
    return( ldap_value_free( (PCHAR *) vals ));
}

PWCHAR __cdecl
ldap_get_dnW (
    LDAP *ExternalHandle,
    LDAPMessage *LdapMsg
    )
//
//  The offset of the DN within the LBER message is saved in the LDAPMessage
//  structure.  We allocate a buffer and copy the DN in.
//
{
    PLDAP_CONN connection = NULL;
    ULONG hr;
    PWCHAR  result = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (LdapMsg == NULL) {

        SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
        return(NULL);
    }

    if (connection == NULL) {
        return NULL;
    }

    CLdapBer *lber = (CLdapBer *) LdapMsg->lm_ber;

    hr = lber->HrGetDN((PWCHAR *) &result);

    SetConnectionError( connection, hr, NULL );

    if (connection)
        DereferenceLdapConnection( connection );

    return result;
}

PCHAR __cdecl
ldap_get_dn (
    LDAP *ExternalHandle,
    LDAPMessage *LdapMsg
    )
{
    PWCHAR wName;
    PCHAR dn = NULL;

    wName = ldap_get_dnW( ExternalHandle, LdapMsg );

    FromUnicodeWithAlloc( wName, &dn, LDAP_BUFFER_SIGNATURE, LANG_ACP );
    ldapFree( wName, LDAP_BUFFER_SIGNATURE );

    return dn;
}

// results.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\search.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    search.cxx handle search requests to an LDAP server

Abstract:

   This module implements the LDAP search APIs.

Author:

    Andy Herron (andyhe)        02-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG
LdapSearch (
        PLDAP_CONN connection,
        PWCHAR  DistinguishedName,
        ULONG   ScopeOfSearch,
        PWCHAR  SearchFilter,
        PWCHAR  AttributeList[],
        ULONG   AttributesOnly,
        BOOLEAN Unicode,
        BOOLEAN Synchronous,
        PLDAPControlW *ServerControls,
        PLDAPControlW *ClientControls,
        ULONG   TimeLimit,
        ULONG   SizeLimit,
        ULONG  *MessageNumber
    )
//
//  Here's where we get to the meat of this protocol.  This is the main client
//  API for performing an LDAP search.  Parameters are rather self explanatory,
//  see the LDAP RFC for detailed descriptions.
//
{
    ULONG err;
    ULONG messageNumber;
    PLDAP_REQUEST request = NULL;

    *MessageNumber = (ULONG) -1;


    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {

       return err;
    }

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    request = LdapCreateRequest( connection, LDAP_SEARCH_CMD );

    if (request == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap_search connection 0x%x couldn't allocate request.\n", connection);
        }
        err = LDAP_NO_MEMORY;
        SetConnectionError( connection, err, NULL );
        return err;
    }

    if (SearchFilter == NULL) {

       //
       // According to the LDAP spec, if the user comes in with a NULL filter,
       // we should convert it to (ObjectClass=*)
       //

       SearchFilter = L"ObjectClass=*";
    }

    messageNumber = request->MessageId;

    request->Synchronous = Synchronous;
    request->search.Unicode = Unicode;
    request->search.ScopeOfSearch = ScopeOfSearch;
    request->search.AttributesOnly = AttributesOnly;
    request->TimeLimit = TimeLimit;
    request->SizeLimit = SizeLimit;

    err = LDAP_SUCCESS;

    if ((ServerControls != NULL) || (ClientControls != NULL)) {

        err = LdapCheckControls( request,
                                 ServerControls,
                                 ClientControls,
                                 Unicode,
                                 0 );

        if (err != LDAP_SUCCESS) {

            IF_DEBUG(CONTROLS) {
                LdapPrint2( "ldap_search connection 0x%x trouble with SControl, err 0x%x.\n",
                            connection, err );
            }
        }
    }

    if (err == LDAP_SUCCESS) {

        if (Synchronous || (request->ChaseReferrals == 0)) {

            request->AllocatedParms = FALSE;
            request->OriginalDN = DistinguishedName;
            request->search.SearchFilter = SearchFilter;
            request->search.AttributeList = AttributeList;

        } else {

            err = LdapSaveSearchParameters( request,
                                            DistinguishedName,
                                            SearchFilter,
                                            AttributeList,
                                            Unicode );
        }
    }

    if (err == LDAP_SUCCESS) {

        if ( DSLOG_ACTIVE ) {

            START_LOGGING;
            DSLOG((DSLOG_FLAG_TAG_CNPN,
                   "[+][ID=%d][OP=ldap_search][ST=%I64d][DN=%ws][LV=%s]",
                   request->MessageId, request->RequestTime,
                   DistinguishedName,
                   (ScopeOfSearch == LDAP_SCOPE_BASE) ? "Base" :
                    (ScopeOfSearch == LDAP_SCOPE_ONELEVEL) ? "OneLevel" : "Subtree"
                ));

            if ( AttributesOnly ) {
                DSLOG((DSLOG_FLAG_NOTIME,"[FL=ATTONLY]"));
            }

            if ( request->ChaseReferrals ) {
                DSLOG((DSLOG_FLAG_NOTIME,"[FL=CHASEREF]"));
            }

            LogAttributesAndControls(AttributeList, NULL, ServerControls,Unicode);
            DSLOG((DSLOG_FLAG_NOTIME,"[FI=%ws][-]\n", SearchFilter));
            END_LOGGING;
        }

        //
        // We access the cache if this is a RootDSE search. We should also
        // mark the request as "cacheable" so that we know to save the search
        // results in our cache. Note that if there are controls associated
        // with the RootDSE search, we do not cache it.
        //

        if (!DisableRootDSECache &&
            ((request->OriginalDN == NULL) ||
            (*(request->OriginalDN) == L'\0')) &&
            (ServerControls == NULL) &&
            (ClientControls == NULL) &&
            (request->search.AttributeList != NULL) &&
            (request->search.ScopeOfSearch == LDAP_SCOPE_BASE) &&
            (connection->CurrentSignStatus == FALSE) &&
            (connection->CurrentSealStatus == FALSE) &&
            (connection->SecureStream == NULL) &&
            (connection->DnsSuppliedName != NULL)) {

            err = AccessLdapCache(request,
                                  connection,
                                  request->OriginalDN,
                                  request->search.ScopeOfSearch,
                                  request->search.SearchFilter,
                                  request->search.AttributeList,
                                  request->search.AttributesOnly,
                                  request->search.Unicode
                                  );

        } else {

            if ((request->OriginalDN == NULL) &&
                (request->search.AttributeList == NULL) &&
                (request->search.ScopeOfSearch == LDAP_SCOPE_BASE)) {

                IF_DEBUG(CACHE) {
                    LdapPrint1("WLDAP32: Process 0x%x is incorrectly making RootDSE searches which bypass the cache. Contact AnoopA with the process name.\n", GetCurrentProcessId());
                }
            }
            //
            // This is an ordinary search which is not cacheable.
            //

            err = SendLdapSearch(request,
                                 connection,
                                 request->OriginalDN,
                                 request->search.ScopeOfSearch,
                                 request->search.SearchFilter,
                                 request->search.AttributeList,
                                 request->search.AttributesOnly,
                                 request->search.Unicode,
                                 (CLdapBer **)&request->BerMessageSent,
                                 0 );
        }
    }

    if (err != LDAP_SUCCESS) {

        START_LOGGING;
        DSLOG((DSLOG_FLAG_TAG_CNPN,"[+]"));
        DSLOG((0,"[ID=%d][OP=ldap_search][ET=%I64d][ER=%d][-]\n",
                   request->MessageId, LdapGetTickCount(), err));
        END_LOGGING;

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_search connection 0x%x send with error of 0x%x.\n",
                        connection, err );
        }

        messageNumber = (ULONG) -1;
        SetConnectionError( connection, err, NULL );
        CloseLdapRequest( request );
    }

    DereferenceLdapRequest( request );
    *MessageNumber = messageNumber;
    return err;
}

ULONG __cdecl
ldap_searchW (
        LDAP    *ExternalHandle,
        PWCHAR  DistinguishedName,
        ULONG   ScopeOfSearch,
        PWCHAR  SearchFilter,
        PWCHAR  AttributeList[],
        ULONG   AttributesOnly
    )
{
    PLDAP_CONN connection = NULL;
    ULONG msgId = (ULONG) -1;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return (ULONG) -1;
    }

    err = LdapSearch(   connection,
                        DistinguishedName,
                        ScopeOfSearch,
                        SearchFilter,
                        AttributeList,
                        AttributesOnly,
                        TRUE,               // attribute list is in Unicode
                        FALSE,               // not synch
                        NULL,
                        NULL,
                        connection->publicLdapStruct.ld_timelimit,
                        connection->publicLdapStruct.ld_sizelimit,
                        &msgId
                        );
    DereferenceLdapConnection( connection );

    return msgId;
}

ULONG __cdecl
ldap_search (
        LDAP    *ExternalHandle,
        PCHAR   DistinguishedName,
        ULONG   ScopeOfSearch,
        PCHAR   SearchFilter,
        PCHAR   AttributeList[],
        ULONG   AttributesOnly
    )
{
    PWCHAR wName = NULL;
    PWCHAR wFilter = NULL;
    PLDAP_CONN connection = NULL;
    ULONG msgId = (ULONG) -1;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return (ULONG) -1;
    }

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP);

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        err = (ULONG) -1;
        goto error;
    }

    err = ToUnicodeWithAlloc( SearchFilter, -1, &wFilter, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        err = (ULONG) -1;
        goto error;
    }

    err = LdapSearch(   connection,
                        wName,
                        ScopeOfSearch,
                        wFilter,
                        (PWCHAR *) AttributeList,
                        AttributesOnly,
                        FALSE,              // attribute list isn't Unicode
                        FALSE,              // not synch
                        NULL,
                        NULL,
                        connection->publicLdapStruct.ld_timelimit,
                        connection->publicLdapStruct.ld_sizelimit,
                        &msgId
                        );

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wFilter)
        ldapFree( wFilter, LDAP_UNICODE_SIGNATURE );

    DereferenceLdapConnection( connection );

    return msgId;
}

ULONG __cdecl
ldap_search_sW (
        LDAP    *ExternalHandle,
        PWCHAR  DistinguishedName,
        ULONG   ScopeOfSearch,
        PWCHAR  SearchFilter,
        PWCHAR  AttributeList[],
        ULONG   AttributesOnly,
        LDAPMessage     **Results
    )
{
    return ldap_search_stW(ExternalHandle,
                           DistinguishedName,
                           ScopeOfSearch,
                           SearchFilter,
                           AttributeList,
                           AttributesOnly,
                           NULL,            // no timeout value specified
                           Results );
}

ULONG __cdecl
ldap_search_s (
        LDAP    *ExternalHandle,
        PCHAR   DistinguishedName,
        ULONG   ScopeOfSearch,
        PCHAR   SearchFilter,
        PCHAR   AttributeList[],
        ULONG   AttributesOnly,
        LDAPMessage     **Results
    )
{
    return ldap_search_st( ExternalHandle,
                           DistinguishedName,
                           ScopeOfSearch,
                           SearchFilter,
                           AttributeList,
                           AttributesOnly,
                           NULL,
                           Results );
}

ULONG __cdecl
ldap_search_stW (
        LDAP    *ExternalHandle,
        PWCHAR   DistinguishedName,
        ULONG    ScopeOfSearch,
        PWCHAR   SearchFilter,
        PWCHAR   AttributeList[],
        ULONG    AttributesOnly,
        struct l_timeval  *TimeOut,
        LDAPMessage     **Results
    )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (Results == NULL)) {
        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *Results = NULL;

    err = ldap_search_ext_sW(  ExternalHandle,
                               DistinguishedName,
                               ScopeOfSearch,
                               SearchFilter,
                               AttributeList,
                               AttributesOnly,
                               NULL,
                               NULL,
                               TimeOut,
                               connection->publicLdapStruct.ld_sizelimit,
                               Results );

#ifdef QFE_BUILD

    //
    // Mask results in the QFE build. Some folks still rely upon
    // LDAP_SUCCESS for retreiving entries
    //

    if ((*Results != NULL) &&
        (err != LDAP_SUCCESS) &&
        (err != LDAP_ADMIN_LIMIT_EXCEEDED) &&
        (ldap_count_records( connection, *Results, LDAP_RES_SEARCH_ENTRY ) > 0)) {

        err = LDAP_SUCCESS;
    }

#endif

error:
    if (connection)
        DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_search_st (
        LDAP    *ExternalHandle,
        PCHAR    DistinguishedName,
        ULONG    ScopeOfSearch,
        PCHAR    SearchFilter,
        PCHAR    AttributeList[],
        ULONG    AttributesOnly,
        struct l_timeval  *TimeOut,
        LDAPMessage     **Results
    )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (Results == NULL)) {
        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *Results = NULL;

    err = ldap_search_ext_sA(  ExternalHandle,
                               DistinguishedName,
                               ScopeOfSearch,
                               SearchFilter,
                               AttributeList,
                               AttributesOnly,
                               NULL,
                               NULL,
                               TimeOut,
                               connection->publicLdapStruct.ld_sizelimit,
                               Results );

#ifdef QFE_BUILD

    //
    // Mask results in the QFE build. Some folks still rely upon
    // LDAP_SUCCESS for retreiving entries
    //

    if ((*Results != NULL) &&
        (err != LDAP_SUCCESS) &&
        (err != LDAP_ADMIN_LIMIT_EXCEEDED) &&
        (ldap_count_records( connection, *Results, LDAP_RES_SEARCH_ENTRY ) > 0)) {

        err = LDAP_SUCCESS;
    }

#endif

error:
    if (connection)
        DereferenceLdapConnection( connection );

    return err;
}


WINLDAPAPI ULONG LDAPAPI ldap_search_extW(
        PLDAP           ExternalHandle,
        PWCHAR          DistinguishedName,
        ULONG           ScopeOfSearch,
        PWCHAR          SearchFilter,
        PWCHAR          AttributeList[],
        ULONG           AttributesOnly,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           TimeLimit,
        ULONG           SizeLimit,
        ULONG          *MessageNumber
    )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return (ULONG) -1;
    }

    err = LdapSearch(   connection,
                        DistinguishedName,
                        ScopeOfSearch,
                        SearchFilter,
                        AttributeList,
                        AttributesOnly,
                        TRUE,               // attribute list is in Unicode
                        FALSE,               // not synch
                        ServerControls,
                        ClientControls,
                        TimeLimit,
                        SizeLimit,
                        MessageNumber
                        );

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_search_extA(
        PLDAP           ExternalHandle,
        PCHAR           DistinguishedName,
        ULONG           ScopeOfSearch,
        PCHAR           SearchFilter,
        PCHAR           AttributeList[],
        ULONG           AttributesOnly,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        ULONG           TimeLimit,
        ULONG           SizeLimit,
        ULONG          *MessageNumber
    )
{
    ULONG err;
    PWCHAR wName = NULL;
    PWCHAR wFilter = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    *MessageNumber = (ULONG) -1;

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        goto error;
    }

    err = ToUnicodeWithAlloc( SearchFilter, -1, &wFilter, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        goto error;
    }

    err = LdapSearch(   connection,
                        wName,
                        ScopeOfSearch,
                        wFilter,
                        (PWCHAR *) AttributeList,
                        AttributesOnly,
                        FALSE,              // attribute list isn't Unicode
                        FALSE,              // not synch
                        (PLDAPControlW *) ServerControls,
                        (PLDAPControlW *) ClientControls,
                        TimeLimit,
                        SizeLimit,
                        MessageNumber
                        );

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wFilter)
        ldapFree( wFilter, LDAP_UNICODE_SIGNATURE );

    DereferenceLdapConnection( connection );

    return err;
}


WINLDAPAPI ULONG LDAPAPI ldap_search_ext_sW(
        PLDAP           ExternalHandle,
        PWCHAR          DistinguishedName,
        ULONG           ScopeOfSearch,
        PWCHAR          SearchFilter,
        PWCHAR          AttributeList[],
        ULONG           AttributesOnly,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        struct l_timeval  *timeout,
        ULONG           SizeLimit,
        LDAPMessage     **Results
    )
{
    ULONG msgId;
    ULONG err;
    PLDAP_CONN connection = NULL;
    ULONG timeLimit;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (Results == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *Results = NULL;

    if (timeout != NULL) {

        timeLimit = (ULONG) timeout->tv_sec + ( timeout->tv_usec / ( 1000 * 1000 ) );

    } else {

        timeLimit = connection->publicLdapStruct.ld_timelimit;
    }

    err = LdapSearch(   connection,
                        DistinguishedName,
                        ScopeOfSearch,
                        SearchFilter,
                        AttributeList,
                        AttributesOnly,
                        TRUE,               // attribute list is in Unicode
                        TRUE,               // synch
                        ServerControls,
                        ClientControls,
                        timeLimit,
                        SizeLimit,
                        &msgId
                        );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  otherwise we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error(  connection,
                                       msgId,
                                       LDAP_MSG_ALL,
                                       timeout,
                                       Results,
                                       NULL
                                       );

        if (*Results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( ExternalHandle,
                                     *Results,
                                     FALSE
                                     );
        }
    }

error:
    if (connection)
        DereferenceLdapConnection( connection );

    return err;
}


WINLDAPAPI ULONG LDAPAPI ldap_search_ext_sA(
        PLDAP           ExternalHandle,
        PCHAR           DistinguishedName,
        ULONG           ScopeOfSearch,
        PCHAR           SearchFilter,
        PCHAR           AttributeList[],
        ULONG           AttributesOnly,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        struct l_timeval  *timeout,
        ULONG           SizeLimit,
        LDAPMessage     **Results
    )
{
    ULONG msgId;
    ULONG err;
    PWCHAR wName = NULL;
    PWCHAR wFilter = NULL;
    PLDAP_CONN connection = NULL;
    ULONG timeLimit;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (Results == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *Results = NULL;

    if (timeout != NULL) {

        timeLimit = (ULONG) timeout->tv_sec + ( timeout->tv_usec / ( 1000 * 1000 ) );

    } else {

        timeLimit = connection->publicLdapStruct.ld_timelimit;
    }

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    err = ToUnicodeWithAlloc( SearchFilter, -1, &wFilter, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    err = LdapSearch(   connection,
                        wName,
                        ScopeOfSearch,
                        wFilter,
                        (PWCHAR *) AttributeList,
                        AttributesOnly,
                        FALSE,              // attribute list isn't Unicode
                        TRUE,               // synch
                        (PLDAPControlW *) ServerControls,
                        (PLDAPControlW *) ClientControls,
                        timeLimit,
                        SizeLimit,
                        &msgId
                        );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  otherwise we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error(  connection,
                                       msgId,
                                       LDAP_MSG_ALL,
                                       timeout,
                                       Results,
                                       NULL
                                      );

        if ((*Results) == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( ExternalHandle,
                                     *Results,
                                     FALSE
                                     );
        }
    }

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wFilter)
        ldapFree( wFilter, LDAP_UNICODE_SIGNATURE );

    if (connection)
        DereferenceLdapConnection( connection );

    return err;
}



LDAPMessage * __cdecl
ldap_first_entry (
    LDAP    *ExternalHandle,
    LDAPMessage *Results
    )
{
    PLDAP_CONN connection = NULL;
    LDAPMessage *message;

    connection = GetConnectionPointer(ExternalHandle);

    message = ldap_first_record( connection, Results, LDAP_RES_SEARCH_ENTRY );

    if (connection)
        DereferenceLdapConnection( connection );

    return message;
}


LDAPMessage * __cdecl
ldap_next_entry (
    LDAP    *ExternalHandle,
    LDAPMessage *entry
    )
{
    PLDAP_CONN connection = NULL;
    LDAPMessage *message;

    connection = GetConnectionPointer(ExternalHandle);

    message = ldap_next_record( connection, entry, LDAP_RES_SEARCH_ENTRY );

    if (connection)
        DereferenceLdapConnection( connection );

    return message;
}


ULONG __cdecl
ldap_count_entries (
    LDAP *ExternalHandle,
    LDAPMessage *res
    )
{
    PLDAP_CONN connection = NULL;
    ULONG cnt;

    connection = GetConnectionPointer(ExternalHandle);

    cnt = ldap_count_records( connection, res, LDAP_RES_SEARCH_ENTRY );

    if (connection)
        DereferenceLdapConnection( connection );

    return cnt;
}


ULONG
LdapSaveSearchParameters (
    PLDAP_REQUEST Request,
    PWCHAR  DistinguishedName,
    PWCHAR  SearchFilter,
    PWCHAR  AttributeList[],
    BOOLEAN Unicode
    )
{
    ULONG err = LDAP_SUCCESS;

    Request->AllocatedParms = TRUE;

    if (DistinguishedName != NULL) {

        Request->OriginalDN = ldap_dup_stringW( DistinguishedName, 0, LDAP_UNICODE_SIGNATURE );

        if (Request->OriginalDN == NULL) {

            err = LDAP_NO_MEMORY;
        }
    }
    if ((SearchFilter != NULL) && (err == LDAP_SUCCESS)) {

        Request->search.SearchFilter = ldap_dup_stringW( SearchFilter, 0, LDAP_UNICODE_SIGNATURE );

        if (Request->search.SearchFilter == NULL) {

            err = LDAP_NO_MEMORY;
        }
    }
    if ( ( err == LDAP_SUCCESS ) && ( AttributeList != NULL )) {

        ULONG valCount = 1;
        PWCHAR *attr = AttributeList;

        while (*(attr++) != NULL) {

            valCount++;
        }

        Request->search.AttributeList = (PWCHAR *) ldapMalloc(
                            valCount * sizeof( PWCHAR ),
                            LDAP_MOD_VALUE_SIGNATURE );

        if (Request->search.AttributeList == NULL) {

            IF_DEBUG(OUTMEMORY) {
                LdapPrint0( "LdapSearch 1 could not allocate memory.\n",  );
            }
            err = LDAP_NO_MEMORY;
        }

        valCount = 0;
        attr = AttributeList;

        while ((*attr != NULL) && (err == LDAP_SUCCESS)) {

            if (Unicode) {

                Request->search.AttributeList[ valCount ] =
                    ldap_dup_stringW(   *attr,
                                        0,
                                        LDAP_UNICODE_SIGNATURE );

            } else {

                Request->search.AttributeList[ valCount ] = (PWCHAR)
                    ldap_dup_string(    (PCHAR) *attr,
                                        0,
                                        LDAP_ANSI_SIGNATURE );
            }


            if ( Request->search.AttributeList[valCount] == NULL ) {

                IF_DEBUG(OUTMEMORY) {
                    LdapPrint0( "LdapSearch 2 could not allocate memory.\n",  );
                }
                err = LDAP_NO_MEMORY;
            }
            valCount++;
            attr++;
        }
    }

    return err;
}

// search.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\send.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    send.cxx  send a message to an LDAP server

Abstract:

   This module implements sending a message to an ldap server.

Author:

    Andy Herron (andyhe)        08-Jun-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

DWORD
LdapSend (
    IN PLDAP_CONN Connection,
    CLdapBer *lber )
{

    DWORD dwResult;
    PSECURESTREAM pSecureStream;

    ACQUIRE_LOCK( &(Connection->SocketLock) );

    if ( Connection->SecureStream || 
         Connection->SslPort ||
         Connection->CurrentSignStatus ||
         Connection->CurrentSealStatus) {

        //
        // You can't send on this connection if it's
        // currently doing SSL negotiation.
        //

        if ( Connection->SslSetupInProgress ) {

            IF_DEBUG(NETWORK_ERRORS) {
                LdapPrint1( "LdapSend denied - connection 0x%x is negotiating SSL.\n",
                            Connection );
            }

            RELEASE_LOCK( &(Connection->SocketLock) );
            return LDAP_LOCAL_ERROR;
        }

        pSecureStream = (PSECURESTREAM) Connection->SecureStream;

        if ( pSecureStream == NULL ) {

            //
            // If the stream object is NULL, then this connection
            // could not be negotiated and is being shut down.
            //

            dwResult = LDAP_LOCAL_ERROR;

        } else {

            dwResult = pSecureStream->LdapSendSsl( (PBYTE) (lber->PbData()),
                                                lber->CbData() );
        }

    } else {

        dwResult = LdapSendRaw( Connection,
                                (PCHAR) (lber->PbData()),
                                lber->CbData() );

    }

    RELEASE_LOCK( &(Connection->SocketLock) );

    return dwResult;
}

DWORD
LdapSendRaw (
    IN PLDAP_CONN Connection,
    PCHAR Data,
    ULONG DataCount
    )
{
    ULONG   bytesSent;
    ULONG   msgLength = DataCount;
    DWORD   rc = LDAP_SUCCESS;
    ULONG   retval = 0;

    fd_set SendSet;
    struct timeval tv= {2,0};
               
    if (Connection->UdpHandle == INVALID_SOCKET) {

        for ( bytesSent = 0 ; bytesSent < msgLength ; bytesSent += retval) {

            //
            // Make sure the socket is ready to send.  If we're feeding large blocks
            // of data to it rapidly, send() may fail with WSAWOULDBLOCK because we're
            // momentarily out of send buffer space.  The select() will momentarily block
            // if that's the case, saving us the lengthy delays of going through the
            // LdapWaitForResponseFromServer path when send() isn't blocked because of the
            // receiving server.
            //
            FD_ZERO(&SendSet);
            FD_SET(Connection->TcpHandle, &SendSet);

            (*pselect)(0,
                       NULL,
                       &SendSet,
                       NULL,
                       &tv);

             Connection->SentPacket = TRUE;

             retval = (*psend)(  Connection->TcpHandle,
                         Data + bytesSent,
                         msgLength - bytesSent,
                         0 );

             if (retval == SOCKET_ERROR) {

                rc = (*pWSAGetLastError)();

                if (rc == WSAEWOULDBLOCK) {

                   //
                   // We have to ensure that we will not go into the autoreconnect
                   // logic here. Downed servers should be picked up in the receive
                   // path.
                   //

                    rc = LdapWaitForResponseFromServer( Connection,
                                                        NULL,
                                                        Connection->KeepAliveSecondCount * 1000,
                                                        LDAP_MSG_ONE,
                                                        NULL,        // no results
                                                        TRUE         // Disable reconnect
                                                        );

                    if (rc == LDAP_SERVER_DOWN) {

                       //
                       // We will pickup the serverdown in the receive path.
                       //

                        return LDAP_SUCCESS;
                    }

                    retval = 0;     // retry the send.

                } else {
                    bytesSent = retval;
                    break;
                }
             }
        }

    } else {

        Connection->SentPacket = TRUE;

        bytesSent = (*psend)(   Connection->UdpHandle,
                                Data,
                                msgLength,
                                0 );
    }

    if (bytesSent != msgLength) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint3( "LDAP error during send. sent= 0x%x, len=0x%x, err = 0x%x\n",
                        bytesSent,
                        msgLength,
                        (*pWSAGetLastError)()  );
        }

        //
        //  we pick up a down server in the receive path.  If the server is
        //  down, we'll retransmit the request when we get a connection to
        //  the server again.
        //

        if (bytesSent == SOCKET_ERROR) {

            rc = (*pWSAGetLastError)();

            switch (rc) {
            case WSAECONNRESET:
            case WSAECONNABORTED:
            case WSAENETDOWN:
            case WSAENETUNREACH:
            case WSAESHUTDOWN:
            case WSAEHOSTDOWN:
            case WSAEHOSTUNREACH:
            case WSAENETRESET:
            case WSAENOTCONN:
//              rc = LDAP_SERVER_DOWN;
                rc = LDAP_SUCCESS;
                break;
            default:
                rc = LDAP_LOCAL_ERROR;
                SetConnectionError( Connection, rc, NULL );
            }
        }
    }

    return rc;
}

// send.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\srchenc.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    srchenc.cxx handle encoding of search requests

Abstract:

   This module helps implements the LDAP search APIs.

Author:

    Andy Herron    (andyhe)        20-Jan-1997
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG
LdapEncodeFilter (
    CLdapBer *Lber,
    PWCHAR SearchFilter
    );

ULONG
LdapEncodeSimpleFilter (
    CLdapBer *Lber,
    PWCHAR SearchFilter
    );

LONG
FindRightParen (
    PWCHAR CurrentLocation
    );

ULONG
SendLdapSearch (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection,
    PWCHAR  DistinguishedName,
    ULONG   ScopeOfSearch,
    PWCHAR  SearchFilter,
    PWCHAR  AttributeList[],
    ULONG   AttributesOnly,
    BOOLEAN Unicode,
    CLdapBer **Lber,
    LONG AltMsgId
    )
//
//  Here's where we get to the meat of this protocol.  This is the main client
//  API for performing an LDAP search.  Parameters are rather self explanatory,
//  see the LDAP RFC for detailed descriptions.
//
{
    CLdapBer *lber = NULL;
    ULONG hr;

    //
    //  If we have not yet bound, we set the Connection version to LDAPv3,
    //  since LDAPv2 doesn't allow operations without binding.
    //

    if ( (Connection->publicLdapStruct.ld_version == LDAP_VERSION2) &&
         (Connection->UdpHandle == INVALID_SOCKET) &&
         (Connection->BindPerformed == FALSE) ) {

        Connection->publicLdapStruct.ld_version = LDAP_VERSION3;
    }

    if ( (Connection->publicLdapStruct.ld_version == LDAP_VERSION2) &&
         ( LdapCheckForMandatoryControl( Request->ServerControls ) == TRUE )) {

        IF_DEBUG(CONTROLS) {
            LdapPrint1( "SendLdapSearch Connection 0x%x has mandatory controls.\n", Connection);
        }
        SetConnectionError( Connection, LDAP_UNAVAILABLE_CRIT_EXTENSION, NULL );
        return LDAP_UNAVAILABLE_CRIT_EXTENSION;
    }

    lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

    if (lber == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap_search Connection 0x%x couldn't allocate lber.\n", Connection);
        }
        SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
        return LDAP_NO_MEMORY;
    }

    //
    //  The request looks like the following :
    //
    //     SearchRequest ::=
    //         [APPLICATION 3] SEQUENCE {
    //             baseObject    LDAPDN,
    //             scope         ENUMERATED {
    //                                baseObject            (0),
    //                                singleLevel           (1),
    //                                wholeSubtree          (2)
    //                           },
    //             derefAliases  ENUMERATED {
    //                                        neverDerefAliases     (0),
    //                                        derefInSearching      (1),
    //                                        derefFindingBaseObj   (2),
    //                                        derefAlways           (3)
    //                                   },
    //             sizeLimit     INTEGER (0 .. maxInt),
    //             timeLimit     INTEGER (0 .. maxInt),
    //             attrsOnly     BOOLEAN,
    //             filter        Filter,
    //             attributes    SEQUENCE OF AttributeType
    //     }
    //
    //     Filter ::=
    //         CHOICE {
    //             and                [0] SET OF Filter,
    //             or                 [1] SET OF Filter,
    //             not                [2] Filter,
    //             equalityMatch      [3] AttributeValueAssertion,
    //             substrings         [4] SubstringFilter,
    //             greaterOrEqual     [5] AttributeValueAssertion,
    //             lessOrEqual        [6] AttributeValueAssertion,
    //             present            [7] AttributeType,
    //             approxMatch        [8] AttributeValueAssertion
    //             extensibleMatch    [9] MatchingRuleAssertion
    //         }
    //
    //     SubstringFilter
    //         SEQUENCE {
    //             type               AttributeType,
    //             SEQUENCE OF CHOICE {
    //                 initial        [0] LDAPString,
    //                 any            [1] LDAPString,
    //                 final          [2] LDAPString
    //             }
    //         }
    //
    //     MatchingRuleAssertion ::= SEQUENCE {
    //           matchingRule    [1] MatchingRuleId OPTIONAL,
    //           type            [2] AttributeDescription OPTIONAL,
    //           matchValue      [3] AssertionValue,
    //           dnAttributes    [4] BOOLEAN DEFAULT FALSE }
    //
    //

    hr = lber->HrStartWriteSequence();
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldap_search startWrite conn 0x%x encoding error of 0x%x.\n",
                        Connection, hr );
        }

        hr = LDAP_ENCODING_ERROR;
        goto returnError;

    } else {            // we can't forget EndWriteSequence

       if (AltMsgId != 0) {

          hr = lber->HrAddValue((LONG) AltMsgId );

       } else {

          hr = lber->HrAddValue((LONG) Request->MessageId );
       }

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_search MsgNo conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;
        }

        if ((Connection->UdpHandle != INVALID_SOCKET) &&
            (Connection->publicLdapStruct.ld_version == LDAP_VERSION2)) {

            hr = lber->HrAddValue((const WCHAR *) Connection->DNOnBind );

            //  if we couldn't put the DN in the packet, don't worry about it
            //  as it wasn't actually used for authentication in CLDAP v2.
        }

        hr = lber->HrStartWriteSequence(LDAP_SEARCH_CMD);
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_search cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;

        } else {        // we can't forget EndWriteSequence

            hr = lber->HrAddValue((const WCHAR *) DistinguishedName );
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_search DN conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                hr = LDAP_ENCODING_ERROR;
                goto returnError;
            }

            if ((ScopeOfSearch != LDAP_SCOPE_BASE) &&
                (ScopeOfSearch != LDAP_SCOPE_ONELEVEL) &&
                (ScopeOfSearch != LDAP_SCOPE_SUBTREE)) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_search conn 0x%x invalid scope of 0x%x.\n",
                                Connection, ScopeOfSearch );
                }

                hr = LDAP_PARAM_ERROR;
                goto returnError;
            }

            hr = lber->HrAddValue((LONG) ScopeOfSearch, BER_ENUMERATED);
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_search scope conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                hr = LDAP_ENCODING_ERROR;
                goto returnError;
            }

            if ((Connection->publicLdapStruct.ld_deref != LDAP_DEREF_NEVER) &&
                (Connection->publicLdapStruct.ld_deref != LDAP_DEREF_SEARCHING) &&
                (Connection->publicLdapStruct.ld_deref != LDAP_DEREF_FINDING) &&
                (Connection->publicLdapStruct.ld_deref != LDAP_DEREF_ALWAYS)) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_search conn 0x%x invalid derefOption of 0x%x.\n",
                                Connection, Connection->publicLdapStruct.ld_deref );
                }

                hr = LDAP_PARAM_ERROR;
                goto returnError;
            }

            hr = lber->HrAddValue((LONG) Connection->publicLdapStruct.ld_deref, BER_ENUMERATED);
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_search derefOption conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                hr = LDAP_ENCODING_ERROR;
                goto returnError;
            }

            hr = lber->HrAddValue((LONG) Request->SizeLimit );
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_search size conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                hr = LDAP_ENCODING_ERROR;
                goto returnError;
            }

            hr = lber->HrAddValue((LONG) Request->TimeLimit );
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_search time conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                hr = LDAP_ENCODING_ERROR;
                goto returnError;
            }

            hr = lber->HrAddValue((BOOLEAN) AttributesOnly, BER_BOOLEAN );
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_search attrOnly conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                hr = LDAP_ENCODING_ERROR;
                goto returnError;
            }

            //
            //  now the fun one... encode the filter
            //

            if (SearchFilter != NULL ) {

                //
                //  we have to make a duplicate of the filter because it may
                //  be that the filter is in a read only piece of memory and
                //  since we're modifying it, it's not a good thing to cause
                //  an access violatation.
                //

                PWCHAR filter;
                ULONG remaining = strlenW( SearchFilter ) + 1;

                if (remaining == 1) {

                    hr = LDAP_FILTER_ERROR;

                } else {

                    filter = (PWCHAR) ldapMalloc( remaining * sizeof(WCHAR),
                                                  LDAP_STRING_SIGNATURE );

                    if (filter == NULL) {

                        hr = LDAP_NO_MEMORY;
                        IF_DEBUG(FILTER) {
                            LdapPrint1( "ldap_search : could not allocate memory 0x%x.\n", remaining );
                        }
                        goto returnError;
                    }

                    CopyMemory( filter, SearchFilter, remaining * sizeof(WCHAR));

                    hr = LdapEncodeFilter(  lber, filter );

                    ldapFree( filter, LDAP_STRING_SIGNATURE );
                }

            } else {

                hr = LDAP_FILTER_ERROR;
            }

            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_search filter conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                goto returnError;
            }

            //
            //  add the attribute list and we're done.
            //

            hr = lber->HrStartWriteSequence();
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_search attrlist conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                hr = LDAP_ENCODING_ERROR;
                goto returnError;

            } else {        // we can't forget EndWriteSequence

                if (AttributeList != NULL) {

                    ULONG count = 0;

                    while (AttributeList[count] != NULL) {

                        if (Unicode) {

                            hr = lber->HrAddValue((const WCHAR *) AttributeList[count]);

                        } else {

                            hr = lber->HrAddValue((const CHAR *) AttributeList[count]);
                        }

                        if (hr != NOERROR) {
                            IF_DEBUG(PARSE) {
                                if (Unicode) {
                                    LdapPrint3( "ldap_search conn 0x%x encoding error of 0x%x, attr = %S.\n",
                                                Connection, hr, AttributeList[count] );
                                } else {
                                    LdapPrint3( "ldap_search conn 0x%x encoding error of 0x%x, attr = %s.\n",
                                                Connection, hr, AttributeList[count] );
                                }
                            }
                            hr = LDAP_ENCODING_ERROR;
                            goto returnError;
                        }
                        count++;
                    }
                }

                hr = lber->HrEndWriteSequence();
                ASSERT( hr == NOERROR );
            }

            hr = lber->HrEndWriteSequence();
            ASSERT( hr == NOERROR );
        }

        //
        //  put in the server controls here if required
        //

        if ( (Connection->publicLdapStruct.ld_version != LDAP_VERSION2) &&
             ( Request->ServerControls != NULL )) {

            hr = InsertServerControls( Request, Connection, lber );

            if (hr != LDAP_SUCCESS) {

                goto returnError;
            }
        }

        hr = lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );
    }

    //
    //  send the search request.
    //

    ACQUIRE_LOCK( &Connection->ReconnectLock );

    AddToPendingList( Request, Connection );

    hr = LdapSend( Connection, lber );

    if (hr != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_search Connection 0x%x send with error of 0x%x.\n",
                        Connection, hr );
        }
        DecrementPendingList( Request, Connection );

    } else {

        //
        //  Save off the lber value, free any lber message that is already
        //  present.
        //

        lber = (CLdapBer *) InterlockedExchangePointer(  (PVOID *) Lber,
                                                         (PVOID) lber );
    }

    RELEASE_LOCK( &Connection->ReconnectLock );

returnError:

    SetConnectionError( Connection, hr, NULL );

    if (lber != NULL) {

       delete lber;
    }

    return hr;
}

WINLDAPAPI ULONG LDAPAPI ldap_check_filterW(
        LDAP    *ExternalHandle,
        PWCHAR  SearchFilter
    )
{
    PLDAP_CONN connection = NULL;
    PWCHAR filter;
    CLdapBer *lber;
    ULONG hr;

    connection = GetConnectionPointer(ExternalHandle);

    if (SearchFilter == NULL || connection == NULL) {

        hr = LDAP_PARAM_ERROR;
        goto error;
    }

    lber = new CLdapBer( connection->publicLdapStruct.ld_version );

    if (lber == NULL) {

        IF_DEBUG(FILTER) {
            LdapPrint0( "ldap_check_filter : could not allocate lber.\n" );
        }
        hr = LDAP_NO_MEMORY;
        goto error;
    }

    filter = ldap_dup_stringW( SearchFilter, 0, LDAP_STRING_SIGNATURE );

    if (filter == NULL) {

        IF_DEBUG(FILTER) {
            LdapPrint0( "ldap_check_filter : could not allocate memory.\n" );
        }
        delete lber;
        hr = LDAP_NO_MEMORY;
        goto error;
    }

    hr = LdapEncodeFilter( lber, filter );

    ldapFree( filter, LDAP_STRING_SIGNATURE );
    delete lber;

error:
    if (connection)
        DereferenceLdapConnection( connection );

    return hr;
}


WINLDAPAPI ULONG LDAPAPI ldap_check_filterA(
        LDAP    *ld,
        PCHAR   SearchFilter
    )
{
    PWCHAR filter;
    ULONG err;

    err = ToUnicodeWithAlloc( SearchFilter,
                              -1,
                              &filter,
                              LDAP_STRING_SIGNATURE,
                              LANG_ACP );
    if (err == LDAP_SUCCESS) {

        err = ldap_check_filterW( ld, filter );
        ldapFree( filter, LDAP_STRING_SIGNATURE );
    }
    return err;
}

ULONG
LdapEncodeFilter (
    CLdapBer *Lber,
    PWCHAR SearchFilter
    )
//
//  Encode a search filter per RFC 2254.  We take the string and encode it into
//  the BER object specified by Lber.
//
//     Filter ::=
//         CHOICE {
//             and                [0] SET OF Filter,
//             or                 [1] SET OF Filter,
//             not                [2] Filter,
//             equalityMatch      [3] AttributeValueAssertion,
//             substrings         [4] SubstringFilter,
//             greaterOrEqual     [5] AttributeValueAssertion,
//             lessOrEqual        [6] AttributeValueAssertion,
//             present            [7] AttributeType,
//             approxMatch        [8] AttributeValueAssertion
//             extensibleMatch    [9] MatchingRuleAssertion
//         }
//
//     SubstringFilter
//         SEQUENCE {
//             type               AttributeType,
//             SEQUENCE OF CHOICE {
//                 initial        [0] LDAPString,
//                 any            [1] LDAPString,
//                 final          [2] LDAPString
//             }
//         }
//
//     MatchingRuleAssertion ::= SEQUENCE {
//           matchingRule    [1] MatchingRuleId OPTIONAL,
//           type            [2] AttributeDescription OPTIONAL,
//           matchValue      [3] AssertionValue,
//           dnAttributes    [4] BOOLEAN DEFAULT FALSE }
//
//

{
    ULONG hr = LDAP_FILTER_ERROR;
    PWCHAR currentPtr = SearchFilter;
    LONG   componentLength;
    WCHAR savedChar;
    ULONG parensCount = 0;
    BOOLEAN atEndOfString = FALSE;
    BOOLEAN definitiveError = TRUE;

    IF_DEBUG(FILTER) {
        LdapPrint1( "LdapEncodeFilter : Filter is %S\n", SearchFilter );
    }

    ASSERT( currentPtr != NULL );

    while (*currentPtr == L' ') {
        currentPtr++;
    }

    //
    //  if the filter was empty or only made up of spaces, error out with
    //  bad filter
    //

    if (*currentPtr != L'\0') {

        while ((atEndOfString == FALSE) && (*currentPtr != L'\0')) {

            switch ( *currentPtr ) {
            case L'(':

                parensCount++;

                currentPtr++;

                while (*currentPtr == L' ') {
                    currentPtr++;
                }

                switch ( *currentPtr ) {
                case L'&':       // handle "(&(cn=bob)(phone=12345))"
                case L'|':       // handle "(|(cn=bob)(cn=mary))"

                    if (*currentPtr == L'&') {

                        hr = Lber->HrStartWriteSequence(LDAP_FILTER_AND);

                    } else {

                        hr = Lber->HrStartWriteSequence(LDAP_FILTER_OR);
                    }

                    if (hr != NOERROR) {
                        IF_DEBUG(FILTER) {
                            LdapPrint2( "LdapEncodeFilter : 1 Filter is %S, err 0x%x\n", SearchFilter, hr );
                        }
                        hr = LDAP_FILTER_ERROR;
                        goto encodingError;
                    }

                    currentPtr++;

                    //
                    //  encode each FILTER separately
                    //

                    componentLength = FindRightParen( currentPtr );

                    if (componentLength == -1) {
                        IF_DEBUG(FILTER) {
                            LdapPrint1( "LdapEncodeFilter : 2 Filter is %S, no right ')'\n", SearchFilter );
                        }
                        hr = LDAP_FILTER_ERROR;
                        goto encodingError;
                    }

                    //
                    //  save off char at end and slam in null to mark end of subfilter
                    //

                    savedChar = *(currentPtr + componentLength );

                    ASSERT( savedChar == L')' );

                    *(currentPtr + componentLength ) = L'\0';

                    //
                    //  recursively call ourselves to process list of filters
                    //

                    hr = LdapEncodeFilter( Lber, currentPtr );
                    if (hr != NOERROR) {
                        IF_DEBUG(FILTER) {
                            LdapPrint2( "LdapEncodeFilter : 3 Filter is %S, err 0x%x\n", SearchFilter, hr );
                        }
                        definitiveError = FALSE;
                        goto encodingError;
                    }

                    *(currentPtr + componentLength ) = savedChar;

                    currentPtr += (componentLength + 1);

                    parensCount--;      // account for ')'

                    hr = Lber->HrEndWriteSequence();
                    if (hr != NOERROR) {
                        IF_DEBUG(FILTER) {
                            LdapPrint2( "LdapEncodeFilter : 4 Filter is %S, err 0x%x\n", SearchFilter, hr );
                        }
                        hr = LDAP_FILTER_ERROR;
                        goto encodingError;
                    }
                    break;

                case L'!':       // handle "(!(ou=foo))"

                    hr = Lber->HrStartWriteSequence(LDAP_FILTER_NOT);

                    if (hr != NOERROR) {
                        IF_DEBUG(FILTER) {
                            LdapPrint2( "LdapEncodeFilter : 5 Filter is %S, err 0x%x\n", SearchFilter, hr );
                        }
                        hr = LDAP_FILTER_ERROR;
                        goto encodingError;
                    }

                    currentPtr++;

                    //
                    //  encode the single FILTER
                    //

                    componentLength = FindRightParen( currentPtr );

                    if (componentLength == -1) {
                        IF_DEBUG(FILTER) {
                            LdapPrint1( "LdapEncodeFilter : 6 Filter is %S, no right ')'\n", SearchFilter  );
                        }
                        hr = LDAP_FILTER_ERROR;
                        goto encodingError;
                    }

                    //
                    //  save off char at end and slam in null to mark end of subfilter
                    //

                    savedChar = *(currentPtr + componentLength );

                    ASSERT( savedChar == L')' );

                    *(currentPtr + componentLength ) = L'\0';

                    //
                    //  recursively call ourselves to process filter
                    //

                    hr = LdapEncodeFilter( Lber, currentPtr );
                    if (hr != NOERROR) {
                        IF_DEBUG(FILTER) {
                            LdapPrint2( "LdapEncodeFilter : 7 Filter is %S, err 0x%x\n", SearchFilter, hr );
                        }
                        definitiveError = FALSE;
                        goto encodingError;
                    }

                    *(currentPtr + componentLength ) = savedChar;

                    currentPtr += (componentLength + 1);

                    parensCount--;      // account for ')'

                    hr = Lber->HrEndWriteSequence();
                    if (hr != NOERROR) {
                        IF_DEBUG(FILTER) {
                            LdapPrint2( "LdapEncodeFilter : 8 Filter is %S, err 0x%x\n", SearchFilter, hr );
                        }
                        hr = LDAP_FILTER_ERROR;
                        goto encodingError;
                    }
                    break;

                case L')':       // handle "()" by reporting error

                    hr = LDAP_FILTER_ERROR;
                    IF_DEBUG(FILTER) {
                        LdapPrint1( "LdapEncodeFilter : Filter is %S, () not allowed\n", SearchFilter);
                    }
                    goto encodingError;

                default:        // handle "(cn=bob)"

                    //
                    //  encode the single FILTER
                    //

                    componentLength = FindRightParen( currentPtr );

                    if (componentLength == -1) {
                        IF_DEBUG(FILTER) {
                            LdapPrint1( "LdapEncodeFilter : 9 Filter is %S, no right ')'\n", SearchFilter  );
                        }
                        hr = LDAP_FILTER_ERROR;
                        goto encodingError;
                    }

                    //
                    //  save off char at end and slam in null to mark end of subfilter
                    //

                    savedChar = *(currentPtr + componentLength );

                    ASSERT( savedChar == L')' );

                    *(currentPtr + componentLength ) = L'\0';

                    //
                    //  recursively call ourselves to process filter
                    //

                    hr = LdapEncodeFilter( Lber, currentPtr );
                    if (hr != NOERROR) {
                        IF_DEBUG(FILTER) {
                            LdapPrint2( "LdapEncodeFilter : 10 Filter is %S, err 0x%x\n", SearchFilter, hr );
                        }
                        definitiveError = FALSE;
                        goto encodingError;
                    }

                    *(currentPtr + componentLength ) = savedChar;

                    currentPtr += (componentLength + 1);

                    parensCount--;      // account for ')'
                }
                break;

            case L')':
                parensCount--;      // intentionally no break

            case L' ':
                currentPtr++;
                break;

            case L'&':
            case L'|':
                hr = LDAP_FILTER_ERROR;
                IF_DEBUG(FILTER) {
                    LdapPrint1( "LdapEncodeFilter : invalid filter is %S\n", SearchFilter);
                }
                goto encodingError;

            default:                // handle "cn=bob"

                //
                //  duplicate the string since we update it and it won't be
                //  cool to change the client's filter.
                //

                PWCHAR duplicate = ldap_dup_stringW( currentPtr,
                                                     0,
                                                     LDAP_STRING_SIGNATURE );

                if (duplicate == NULL) {

                    hr = LDAP_NO_MEMORY;
                    IF_DEBUG(FILTER) {
                        LdapPrint2( "LdapEncodeFilter : 11 Filter is %S, err 0x%x\n", SearchFilter, hr );
                    }
                    goto encodingError;
                }

                hr = LdapEncodeSimpleFilter( Lber, duplicate );

                ldapFree( duplicate, LDAP_STRING_SIGNATURE );

                if (hr != NOERROR) {
                    IF_DEBUG(FILTER) {
                        LdapPrint2( "LdapEncodeFilter : 12 Filter is %S, err 0x%x\n", SearchFilter, hr );
                    }
                    goto encodingError;
                }

                atEndOfString = TRUE;     // we're done with string
            }
        }

        return ((parensCount == 0) ? NOERROR : LDAP_FILTER_ERROR );
    }

encodingError:

    return hr;
}


ULONG
LdapEncodeSimpleFilter (
    CLdapBer *Lber,
    PWCHAR SearchFilter
    )
//
//  Encode a single search filter such as :
//
//      "cn=bob"            straight equality
//      "size >= 2"         greater than
//      "size <= 5"         less than
//      "mail=*"            present
//      "ou = DBSD*"        contains
//      "printer ~= laser"  approximately equal
//
//
//  AnoopA: Added support for Extensible matches (1/29/98)
//
//       "cn:1.2.3.4.5:=Fred Flintstone"
//       "sn:dn:2.4.6.8.10:=Barney Rubble"
//       "o:dn:=Ace Industry"
//       ":dn:2.4.6.8.10:=Dino"
//  Note that all leading escape markers have already been removed.
//
{
    ULONG hr;
    PWCHAR ptrToEqual = SearchFilter;
    PWCHAR ptrToValue;
    LONG operation;

    PWCHAR ptrToOid = SearchFilter;
    WCHAR  savedchar;
    PWCHAR ptrToType = SearchFilter;
    PWCHAR ptrToTypeEnd = ptrToType;
    PWCHAR ptrToDN = SearchFilter;
    BOOLEAN DNdetected = FALSE;
    BOOLEAN bOidPresent = FALSE;
    BOOLEAN bSubstringValuePresent = FALSE;

    IF_DEBUG(FILTER) {
        LdapPrint1( "LdapEncodeSimpleFilter : Filter is %S\n", SearchFilter );
    }

    //
    //  Determine what the desired operation is by skipping to the = sign.
    //

    while ((*ptrToEqual != L'=') && (*ptrToEqual != L'\0')) {

        ptrToEqual++;
    }

    if ((*ptrToEqual == L'\0') || (ptrToEqual == SearchFilter)) {

        return LDAP_FILTER_ERROR;
    }

    ptrToValue = ptrToEqual + 1;

    //
    //  strip off leading blanks from value
    //

    while (*ptrToValue == L' ' && *ptrToValue != L'\0') {

        ptrToValue++;
    }

    if (*ptrToValue == L'\0') {

        return LDAP_FILTER_ERROR;
    }

    //
    //  strip off trailing blanks from value
    //

#if 0
    while (*(ptrToValue+strlenW(ptrToValue)-1) == L' ') {

        *(ptrToValue+strlenW(ptrToValue)-1) = L'\0';
    }
#endif

    switch (*(ptrToEqual-1)) {
    case L'~':
        operation = LDAP_FILTER_APPROX;
        *(ptrToEqual-1) = L'\0';
        break;
    case L'>':
        operation = LDAP_FILTER_GE;
        *(ptrToEqual-1) = L'\0';
        break;
    case L'<':
        operation = LDAP_FILTER_LE;
        *(ptrToEqual-1) = L'\0';
        break;
    case L':':
        operation = LDAP_FILTER_EXTENSIBLE;


        savedchar = *(ptrToEqual-1);
        *(ptrToEqual-1) = L'\0';

        hr = Lber->HrStartWriteSequence(LDAP_FILTER_EXTENSIBLE);
        if (hr != NOERROR) {
           IF_DEBUG(FILTER) {
              LdapPrint2( "LdapEncodeSimpleFilter : 3 Filter is %S, err 0x%x\n", SearchFilter, hr );
           }
           goto encodingError;
        }

        //
        // We have to detect the matching rule ID if one is present
        //

        while ((ptrToOid != ptrToEqual) && (*ptrToOid != L'\0')) {
           if (*ptrToOid == L'.') {
              bOidPresent = TRUE;
              break;
           }
           ptrToOid++;
        }
        ptrToOid = SearchFilter; // Reset to beginning of filter

        if (bOidPresent == TRUE) {

           //
           // We have an OID preceding the colon. Now, start from the
           // beginning and skip over spaces looking for the '.'of the OID
           //

           while ((*ptrToOid != L':') &&
                  (*ptrToOid != L'\0')) {

               ptrToOid++;
           }

           if (*ptrToValue == L'\0') {

               return LDAP_FILTER_ERROR;
           } else {

              ptrToOid++;
           }
        hr = Lber->HrAddValue ((const WCHAR *) ptrToOid, BER_CLASS_CONTEXT_SPECIFIC | 0x01);
        if (hr != NOERROR) {
            IF_DEBUG(FILTER) {
                LdapPrint2( "LdapEncodeSimpleFilter : 2 Filter is %S, err 0x%x\n", SearchFilter, hr );
                }
            goto encodingError;
            }

        }
        *(ptrToEqual-1) = savedchar;  // Restore the colon

        //
        // We detect the type if one is present
        //


        while ((*ptrToType == L' ') && (*ptrToType != L'\0')) {

           ptrToType++;
        }
        if (*ptrToType == L'\0') {

            return LDAP_FILTER_ERROR;

        } else {

           if (*ptrToType != L':') {

              //
              // If we don't start off with a ":" it means we have a type present
              //

              while (*ptrToTypeEnd != L':') {

                 ptrToTypeEnd++;
              }

              savedchar = *ptrToTypeEnd;  // save off the colon
              *ptrToTypeEnd = L'\0';
              hr = Lber->HrAddValue ((const WCHAR *) ptrToType, BER_CLASS_CONTEXT_SPECIFIC | 0x02);
              if (hr != NOERROR) {
                 IF_DEBUG(FILTER) {
                    LdapPrint2( "LdapEncodeSimpleFilter : 2 Filter is %S, err 0x%x\n", SearchFilter, hr );
                 }
                 goto encodingError;
              }
              *ptrToTypeEnd = savedchar;   // restore the colon
           }
        }

        //
        // Deal with the matchValue
        //

           hr = Lber->HrAddValue ((const WCHAR *) ptrToEqual+1, BER_CLASS_CONTEXT_SPECIFIC | 0x03);
           if (hr != NOERROR) {
               IF_DEBUG(FILTER) {
                   LdapPrint2( "LdapEncodeSimpleFilter : 2 Filter is %S, err 0x%x\n", SearchFilter, hr );
                   }
               goto encodingError;
               }

        //
        // Deal with the dnAttributes
        //

        while ((*ptrToDN != L'\0')&&((*(ptrToDN+1)) != L'\0')&&((*(ptrToDN+2)) != L'\0')) {

           if (*ptrToDN == L':') {
              if ((*(ptrToDN+1) == L'd') || (*(ptrToDN+1) == L'D')) {
                 if ((*(ptrToDN+2) == L'n') || (*(ptrToDN+2) == L'N')) {
                    if (*(ptrToDN+3) == L':') {

                       DNdetected = TRUE;
                       break;
                    }
                 }
              }

           }
           ptrToDN++;
        }

           hr = Lber->HrAddValue((BOOLEAN) DNdetected, BER_CLASS_CONTEXT_SPECIFIC | 0x04  );

           if (hr != NOERROR) {
               IF_DEBUG(FILTER) {
                   LdapPrint2( "LdapEncodeSimpleFilter : 2 Filter is %S, err 0x%x\n", SearchFilter, hr );
                   }
               goto encodingError;
               }


        hr = Lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );

        goto encodingError;

        break;

    default:

        PWCHAR checkForAsterisk = ptrToValue;

        *ptrToEqual = L'\0';

        if ((*ptrToValue == L'*') && (*(ptrToValue+1) == L'\0')) {

            //
            //  value is simply "*", therefore we check for presence.
            //

            hr = Lber->HrAddValue((const WCHAR *) SearchFilter, LDAP_FILTER_PRESENT );
            if (hr != NOERROR) {
                IF_DEBUG(FILTER) {
                    LdapPrint2( "LdapEncodeSimpleFilter : 2 Filter is %S, err 0x%x\n", SearchFilter, hr );
                }
                goto encodingError;
            }

            return(hr);
        }

        //
        //  allow that we may have some embedded '*' escaped
        //

        ULONG remaining = strlenW( ptrToValue ) + 1;

        //
        //  note that we also use a length check here "remaining" so that
        //  we don't blow up if we hit something like "abc\\0" where the
        //  null terminator is escaped.
        //

        while ((*checkForAsterisk != L'\0') &&
               (*checkForAsterisk != L'*') &&
                remaining > 0) {

            checkForAsterisk++;
            remaining--;
        }

        if (*checkForAsterisk != L'*') {

            //
            //  value does not contain an '*' therefore we test for equality
            //

            operation = LDAP_FILTER_EQUALITY;

        } else {

            //
            //  value is a substring such as "cn=bob*"
            //
            //         SEQUENCE {
            //             type               AttributeType,
            //             SEQUENCE OF CHOICE {
            //                 initial        [0] LDAPString,
            //                 any            [1] LDAPString,
            //                 final          [2] LDAPString
            //             }
            //

            PWCHAR   NextAsterisk;
            BOOLEAN foundAsterisk = FALSE;

            hr = Lber->HrStartWriteSequence(LDAP_FILTER_SUBSTRINGS);
            if (hr != NOERROR) {
                IF_DEBUG(FILTER) {
                    LdapPrint2( "LdapEncodeSimpleFilter : 3 Filter is %S, err 0x%x\n", SearchFilter, hr );
                }
                goto encodingError;
            }

            hr = Lber->HrAddValue((const WCHAR *) SearchFilter );
            if (hr != NOERROR) {
                IF_DEBUG(FILTER) {
                    LdapPrint2( "LdapEncodeSimpleFilter : 4 Filter is %S, err 0x%x\n", SearchFilter, hr );
                }
                goto encodingError;
            }

            hr = Lber->HrStartWriteSequence();
            if (hr != NOERROR) {
                IF_DEBUG(FILTER) {
                    LdapPrint2( "LdapEncodeSimpleFilter : 5 Filter is %S, err 0x%x\n", SearchFilter, hr );
                }
                goto encodingError;
            }

            while (ptrToValue != NULL) {

                //
                //  find the next asterisk in the substring
                //

                remaining = strlenW( ptrToValue ) + 1;

                NextAsterisk = ptrToValue;

                //
                //  note that we also use a length check here "remaining" so that
                //  we don't blow up if we hit something like "abc\\0" where the
                //  null terminator is escaped.
                //

                while ((*NextAsterisk != L'\0') &&
                       (*NextAsterisk != L'*') &&
                       (remaining > 0)) {

                    NextAsterisk++;
                    remaining--;
                }

                //
                //  if we found another asterisk, set the byte to 0 to mark
                //  end of partial value.
                //

                if (*NextAsterisk == L'*') {

                    *NextAsterisk = L'\0';
                    NextAsterisk++;

                } else {

                    NextAsterisk = NULL;
                }

                if (! foundAsterisk) {

                    operation = LDAP_SUBSTRING_INITIAL;
                    foundAsterisk = TRUE;

                } else if (NextAsterisk != NULL) {

                    operation = LDAP_SUBSTRING_ANY;

                } else {

                    operation = LDAP_SUBSTRING_FINAL;
                }

                if (*ptrToValue != L'\0') {

                    hr = Lber->HrAddEscapedValue( ptrToValue, operation );
                    if (hr != NOERROR) {
                        IF_DEBUG(FILTER) {
                            LdapPrint2( "LdapEncodeSimpleFilter : 6 Filter is %S, err 0x%x\n", SearchFilter, hr );
                        }
                        goto encodingError;
                    }
                    bSubstringValuePresent = TRUE;
                }

                ptrToValue = NextAsterisk;
            }

            //
            // We got a substring filter containing only asterisks, no values.
            // This isn't a valid filter.
            //
            if (!bSubstringValuePresent) {
                hr = LDAP_FILTER_ERROR;
                goto encodingError;
            }

            hr = Lber->HrEndWriteSequence();
            ASSERT( hr == NOERROR );

            hr = Lber->HrEndWriteSequence();
            ASSERT( hr == NOERROR );
            return hr;
        }
    }

    hr = Lber->HrStartWriteSequence(operation);
    if (hr != NOERROR) {
        IF_DEBUG(FILTER) {
            LdapPrint2( "LdapEncodeSimpleFilter : 3 Filter is %S, err 0x%x\n", SearchFilter, hr );
        }
        goto encodingError;
    }

    hr = Lber->HrAddValue((const WCHAR *) SearchFilter );
    if (hr != NOERROR) {
        IF_DEBUG(FILTER) {
            LdapPrint2( "LdapEncodeSimpleFilter : 4 Filter is %S, err 0x%x\n", SearchFilter, hr );
        }
        goto encodingError;
    }

    //
    //  translate escaping characters from filter value
    //

    hr = Lber->HrAddEscapedValue( ptrToValue, BER_OCTETSTRING );

    if (hr != NOERROR) {
        IF_DEBUG(FILTER) {
            LdapPrint2( "LdapEncodeSimpleFilter : 5 Filter is %S, err 0x%x\n", SearchFilter, hr );
        }
        goto encodingError;
    }

    hr = Lber->HrEndWriteSequence();
    ASSERT( hr == NOERROR );

encodingError:
    return(hr);
}


LONG
FindRightParen (
    PWCHAR CurrentLocation
    )
{
    BOOLEAN escaped = FALSE;
    LONG count = 0;
    ULONG parens = 0;
    WCHAR ch;

    //
    //  search the remainder of the string for a closing ')'
    //

    while (*CurrentLocation != L'\0') {

        if (! escaped) {

            ch = *CurrentLocation;

            if (ch == L'(') {

                parens++;

            } else if (ch == L')') {

                if (parens == 0) {
                    return count;
                }
                parens--;

            } else if ( ch == L'\\' ) {

                escaped = TRUE;
            }

        } else {

            escaped = FALSE;

            if (*CurrentLocation == L'\0') {
                break;
            }

        }
        count++;
        CurrentLocation++;
    }
    //
    //  no closing right parens was found.  this is an error
    //

    return(-1);
}

//
//  Extended API to support allowing opaque blobs of data in search filters.
//  This API takes any filter element and adds necessary escape characters
//  such that when the element hits the wire in the search request, it will
//  be equal to the opaque blob past in here as source.
//

ULONG __cdecl
ldap_escape_filter_elementW (
   PCHAR   sourceFilterElement,
   ULONG   sourceLength,            // size in bytes
   PWCHAR  destFilterElement,
   ULONG   destLength               // size in bytes
   )
{
    ULONG err;
    PCHAR dest;
    ULONG lengthRequired;
    ULONG sLength;

    //
    //  figure out how long of a buffer we need.
    //

    lengthRequired = ldap_escape_filter_element( sourceFilterElement,
                                                 sourceLength,
                                                 NULL,
                                                 0 );
    if (destFilterElement == NULL) {

        //
        //  If they didn't specify an output buffer, tell them how big the
        //  output buffer should be.
        //

        return lengthRequired;
    }

    if ((sourceFilterElement == NULL) ||
        (destLength < lengthRequired * sizeof(WCHAR))) {

        return LDAP_PARAM_ERROR;
    }

    dest = (PCHAR) ldapMalloc( lengthRequired, LDAP_ANSI_SIGNATURE );

    if (dest == NULL) {

        return LDAP_NO_MEMORY;
    }

    err = ldap_escape_filter_element( sourceFilterElement,
                                      sourceLength,
                                      dest,
                                      lengthRequired );

    if (err != 0) {

        ldapFree( dest, LDAP_ANSI_SIGNATURE );
        return err;
    }

    //
    //  determine length of required string
    //

    sLength = MultiByteToWideChar(  CP_ACP,
                                    0,
                                    dest,
                                    (int) -1,
                                    NULL,
                                    0 );

    if ((sLength == 0) || ((sLength*sizeof(WCHAR)) > destLength)) {

        ldapFree( dest, LDAP_ANSI_SIGNATURE );
        return LDAP_PARAM_ERROR;
    }

    sLength =  MultiByteToWideChar(  CP_ACP,
                                     0,
                                     dest,
                                     (int) -1,
                                     destFilterElement,
                                     (int) destLength/2 );

    if (dest != NULL) {

       ldapFree( dest, LDAP_ANSI_SIGNATURE );
    }

    return LDAP_SUCCESS;
}

ULONG __cdecl
ldap_escape_filter_element (
   PCHAR   sourceFilterElement,
   ULONG   sourceLength,
   PCHAR   destFilterElement,
   ULONG   destLength
   )
{
    ULONG sourceCount;
    ULONG destCount = 0;
    PCHAR source = sourceFilterElement;
    PCHAR dest = destFilterElement;
    CHAR ch;

    sourceCount = sourceLength;

    if (source != NULL) {

        while ((sourceCount--) > 0) {

            ch = *(source++);

            if (((ch >= 'A') && (ch <= 'Z')) ||
                ((ch >= 'a') && (ch <= 'z')) ||
                ((ch >= '0') && (ch <= '9'))) {

                destCount++;

            } else {

                destCount += 3;             // sizeof '\xx'
            }
        }
    }

    if (destFilterElement == NULL) {

        //
        //  This is a bit of a hack.. if they didn't specify a destination,
        //  then we return the required size of the buffer.
        //

        return (destCount + 1);
    }

    if ((source == NULL) || ((destCount + 1) > destLength)) {

        return LDAP_PARAM_ERROR;
    }

    //
    //  For each char in the source string, copy it to dest string
    //  but if it is not alphanumeric, we first expand it out such that
    //  each nibble is it's own character and each pair has a leading backslash.
    //

    source = sourceFilterElement;
    sourceCount = sourceLength;

    while ((sourceCount--) > 0) {

        ch = *source;

        if (((ch >= 'A') && (ch <= 'Z')) ||
            ((ch >= 'a') && (ch <= 'z')) ||
            ((ch >= '0') && (ch <= '9'))) {

            *(dest++) = ch;

        } else {

            *(dest++) = '\\';

            ch = ( (*source) & 0xF0 ) >> 4;

            *(dest++) = LdapHexToCharTable[ch];

            ch = (*source) & 0x0F;

            *(dest++) = LdapHexToCharTable[ch];
        }

        source++;
    }

    *dest = '\0';

    return LDAP_SUCCESS;
}

// search.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\sort.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sort.cxx  sort control support routines for the LDAP api

Abstract:

   This module implements routines that handle sorting controls

Author:

    Andy Herron (andyhe)        27-Aug-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG
LdapCreateSortControlWithAlloc(
        PLDAP           ExternalHandle,
        PLDAPSortKeyW  *SortKeys,
        UCHAR           IsCritical,
        PLDAPControlW  *Control,
        ULONG           CodePage
        );

ULONG
LdapParseSortControl (
        PLDAP_CONN      connection,
        PLDAPControlW  *Control,
        ULONG          *Result,
        PWCHAR         *Attribute,
        ULONG           CodePage
        );

ULONG
LdapEncodeSortControl (
    PLDAP_CONN      connection,
    PLDAPSortKeyW  *SortKeys,
    PLDAPControlW  OutputControl,
    BOOLEAN Criticality,
    ULONG CodePage
    )
{
    ULONG err;
    CLdapBer *lber = NULL;
    PLDAPSortKeyW sortKey;

    if ((connection == NULL) || (OutputControl == NULL) || (SortKeys == NULL)) {

        return LDAP_PARAM_ERROR;
    }

    OutputControl->ldctl_oid = NULL;
    OutputControl->ldctl_iscritical = Criticality;

    if (CodePage == LANG_UNICODE) {

        OutputControl->ldctl_oid = ldap_dup_stringW( LDAP_SERVER_SORT_OID_W,
                                                     0,
                                                     LDAP_VALUE_SIGNATURE );
    } else {

        OutputControl->ldctl_oid = (PWCHAR) ldap_dup_string(  LDAP_SERVER_SORT_OID,
                                                     0,
                                                     LDAP_VALUE_SIGNATURE );
    }

    if (OutputControl->ldctl_oid == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodeSortControl;
    }

    lber = new CLdapBer( connection->publicLdapStruct.ld_version );

    if (lber == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodeSortControl;
    }

    //
    //  for each sort key, insert it into the control :
    //
    //   SortKeyList ::= SEQUENCE OF SEQUENCE {
    //      attributeType   AttributeType,
    //      orderingRule    [0] MatchingRuleId OPTIONAL,
    //      reverseOrder    [1] BOOLEAN DEFAULT FALSE }
    //


    err = lber->HrStartWriteSequence();

    if (err != LDAP_SUCCESS) {

        goto exitEncodeSortControl;
    }

    while (*SortKeys != NULL) {

        sortKey = *SortKeys;

        err = lber->HrStartWriteSequence();

        if (err != LDAP_SUCCESS) {

            goto exitEncodeSortControl;
        }

        if (CodePage == LANG_UNICODE) {

            err = lber->HrAddValue((const WCHAR *) sortKey->sk_attrtype );

        } else {

            err = lber->HrAddValue((const CHAR *) sortKey->sk_attrtype );
        }

        if (err != LDAP_SUCCESS) {

            goto exitEncodeSortControl;
        }

        if (sortKey->sk_matchruleoid != NULL) {

            if (CodePage == LANG_UNICODE) {

              err = lber->HrAddValue((const WCHAR *) sortKey->sk_matchruleoid,
                   BER_CLASS_CONTEXT_SPECIFIC | 0x00 );

            } else {

              err = lber->HrAddValue((const CHAR *) sortKey->sk_matchruleoid,
                   BER_CLASS_CONTEXT_SPECIFIC | 0x00 );
            }

            if (err != LDAP_SUCCESS) {

                goto exitEncodeSortControl;
            }
        }

        if (sortKey->sk_reverseorder != FALSE) {

            err = lber->HrAddValue((BOOLEAN) 1, BER_CLASS_CONTEXT_SPECIFIC | 0x01 );

            if (err != LDAP_SUCCESS) {

                goto exitEncodeSortControl;
            }
        }

        err = lber->HrEndWriteSequence();
        ASSERT( err == NOERROR );

        SortKeys++;
    }

    err = lber->HrEndWriteSequence();
    ASSERT( err == NOERROR );

    OutputControl->ldctl_value.bv_len = lber->CbData();

    if (OutputControl->ldctl_value.bv_len == 0) {

        err = LDAP_LOCAL_ERROR;
        goto exitEncodeSortControl;
    }

    OutputControl->ldctl_value.bv_val = (PCHAR) ldapMalloc(
                            OutputControl->ldctl_value.bv_len,
                            LDAP_CONTROL_SIGNATURE );

    if (OutputControl->ldctl_value.bv_val == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodeSortControl;
    }

    CopyMemory( OutputControl->ldctl_value.bv_val,
                lber->PbData(),
                OutputControl->ldctl_value.bv_len );

    err = LDAP_SUCCESS;

exitEncodeSortControl:

    if (err != LDAP_SUCCESS) {

        if (OutputControl->ldctl_oid != NULL) {

            ldapFree( OutputControl->ldctl_oid, LDAP_VALUE_SIGNATURE );
            OutputControl->ldctl_oid = NULL;
        }

        OutputControl->ldctl_value.bv_len = 0;
    }

    if (lber != NULL) {
        delete lber;
    }
    return err;
}

WINLDAPAPI
ULONG LDAPAPI
ldap_create_sort_controlA (
        PLDAP           ExternalHandle,
        PLDAPSortKeyA  *SortKeys,
        UCHAR           IsCritical,
        PLDAPControlA  *Control
        )
{
    return LdapCreateSortControlWithAlloc( ExternalHandle,
                                           (PLDAPSortKeyW  *) SortKeys,
                                           IsCritical,
                                           (PLDAPControlW  *) Control,
                                           LANG_ACP );
}

WINLDAPAPI
ULONG LDAPAPI
ldap_create_sort_controlW (
        PLDAP           ExternalHandle,
        PLDAPSortKeyW  *SortKeys,
        UCHAR           IsCritical,
        PLDAPControlW  *Control
        )
{
    return LdapCreateSortControlWithAlloc( ExternalHandle,
                                           SortKeys,
                                           IsCritical,
                                           Control,
                                           LANG_UNICODE );
}

ULONG
LdapCreateSortControlWithAlloc(
        PLDAP           ExternalHandle,
        PLDAPSortKeyW  *SortKeys,
        UCHAR           IsCritical,
        PLDAPControlW  *Control,
        ULONG           CodePage
        )
{
    ULONG err;
    BOOLEAN criticality = ( (IsCritical > 0) ? TRUE : FALSE );
    PLDAPControlW  control = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (Control == NULL)) {
        err = LDAP_PARAM_ERROR;
        goto error;
    }

    control = (PLDAPControlW) ldapMalloc( sizeof( LDAPControlW ), LDAP_CONTROL_SIGNATURE );

    if (control == NULL) {

        *Control = NULL;
        err = LDAP_NO_MEMORY;
        goto error;
    }

    err = LdapEncodeSortControl(  connection,
                                  SortKeys,
                                  control,
                                  criticality,
                                  CodePage );

    if (err != LDAP_SUCCESS) {

        ldap_control_freeW( control );
        control = NULL;
    }

    *Control = control;

error:
    if (connection)
        DereferenceLdapConnection( connection );

    return err;
}


//
//  These routines parse the search control returned by the server
//

WINLDAPAPI
ULONG LDAPAPI
ldap_parse_sort_controlA (
        PLDAP           ExternalHandle,
        PLDAPControlA  *Control,
        ULONG          *Result,
        PCHAR          *Attribute
        )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapParseSortControl(     connection,
                                    (PLDAPControlW  *) Control,
                                    Result,
                                    (PWCHAR *) Attribute,
                                    LANG_ACP );

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI
ULONG LDAPAPI
ldap_parse_sort_controlW (
        PLDAP           ExternalHandle,
        PLDAPControlW  *Control,
        ULONG          *Result,
        PWCHAR         *Attribute
        )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err  = LdapParseSortControl(    connection,
                                    Control,
                                    Result,
                                    Attribute,
                                    LANG_UNICODE );

    DereferenceLdapConnection( connection );

    return err;
}

ULONG
LdapParseSortControl (
        PLDAP_CONN      connection,
        PLDAPControlW  *ServerControls,
        ULONG          *Result,
        PWCHAR         *Attribute,
        ULONG           CodePage
        )
{
    ULONG err = LDAP_CONTROL_NOT_FOUND;
    PCHAR *ansiAttribute = (PCHAR *) Attribute;
    CLdapBer *lber = NULL;

    //
    //  First thing is to zero out the parms passed in.
    //

    if (Result != NULL) {

        *Result = 0;
    }

    if (Attribute != NULL) {

        *Attribute = NULL;
    }

    if (ServerControls != NULL) {

        PLDAPControlW *controls = ServerControls;
        PLDAPControlW currentControl;
        ULONG bytesTaken;
        LONG  sortError;

        while (*controls != NULL) {

            currentControl = *controls;

            //
            //  check to see if the current control is the SORT control
            //

            if ( ((CodePage == LANG_UNICODE) &&
                  ( ldapWStringsIdentical( currentControl->ldctl_oid,
                                           -1,
                                           LDAP_SERVER_RESP_SORT_OID_W,
                                           -1 ) == TRUE )) ||
                 ((CodePage == LANG_ACP) &&
                  ( CompareStringA( LDAP_DEFAULT_LOCALE,
                                    NORM_IGNORECASE,
                                    (PCHAR) currentControl->ldctl_oid,
                                    -1,
                                    LDAP_SERVER_RESP_SORT_OID,
                                    sizeof(LDAP_SERVER_RESP_SORT_OID) ) == 2)) ) {

                lber = new CLdapBer( connection->publicLdapStruct.ld_version );

                if (lber == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint1( "LdapParseSortControl: unable to alloc msg for 0x%x.\n",
                                    connection );
                    }

                    err = LDAP_NO_MEMORY;
                    break;
                }

                err = lber->HrLoadBer(   (const BYTE *) currentControl->ldctl_value.bv_val,
                                         currentControl->ldctl_value.bv_len,
                                         &bytesTaken,
                                         TRUE );    // we have the whole message guarenteed

                if (err != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseSortControl: loadBer error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    break;
                }

                err = lber->HrStartReadSequence();
                if (err != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseSortControl: loadBer error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    break;
                }

                err = lber->HrGetEnumValue( &sortError );
                if (err != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseSortControl: getEnumValue error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    break;
                }

                if (Result != NULL) {

                    *Result = sortError;
                }

                if (Attribute != NULL) {

                    if ( CodePage == LANG_UNICODE) {

                        err = lber->HrGetValueWithAlloc( Attribute );

                    } else {

                        err = lber->HrGetValueWithAlloc( ansiAttribute );
                    }

                    if (err != NOERROR) {

                        //
                        //  Since it's an optional string, only bail out if we
                        //  got a legit error from decoding.
                        //

                        IF_DEBUG(PARSE) {
                            LdapPrint2( "LdapParseSortControl: GetAttribute error of 0x%x for 0x%x.\n",
                                        err, connection );
                        }

                        if ( (err != LDAP_NO_SUCH_ATTRIBUTE ) &&
                             (err != LDAP_DECODING_ERROR) ) {

                            break;
                        }
                    }
                }

                err = LDAP_SUCCESS;
                break;                  // done with loop... look no more
            }
            controls++;
        }
    }

    if (lber != NULL) {

        delete lber;
    }

    SetConnectionError( connection, err, NULL );
    return err;
}

//
//  These two APIs are old and will be eliminated after NT 5.0 beta 1.
//

WINLDAPAPI ULONG LDAPAPI ldap_encode_sort_controlW (
        PLDAP           ExternalHandle,
        PLDAPSortKeyW  *SortKeys,
        PLDAPControlW  Control,
        BOOLEAN Criticality
        )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapEncodeSortControl(   connection,
                                   SortKeys,
                                   Control,
                                   Criticality,
                                   LANG_UNICODE );

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_encode_sort_controlA (
        PLDAP           ExternalHandle,
        PLDAPSortKeyA  *SortKeys,
        PLDAPControlA  Control,
        BOOLEAN Criticality
        )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapEncodeSortControl(   connection,
                                   (PLDAPSortKeyW *)SortKeys,
                                   (PLDAPControlW)Control,
                                   Criticality,
                                   LANG_ACP );

    DereferenceLdapConnection( connection );

    return err;
}

// sort.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\security.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    security.cxx  security handler for LDAP client DLL

Abstract:

   This module implements SSPI security handlers for LDAP client DLL.

Author:

    Andy Herron    (andyhe)        26-Aug-1996
    Cory West      (corywest)      01-Oct-1996
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

#include "precomp.h"
#include "ldapp2.hxx"
#pragma hdrstop

FGETTOKENINFORMATION pGetTokenInformation = 0;
FOPENTHREADTOKEN pOpenThreadToken = 0;
FOPENPROCESSTOKEN pOpenProcessToken = 0;

FSASLINITIALIZESECURITYCONTEXTW pSaslInitializeSecurityContextW = NULL;
FSASLGETPROFILEPACKAGEW pSaslGetProfilePackageW = NULL;
FQUERYCONTEXTATTRIBUTESW pQueryContextAttributesW = NULL;

FSECINITSECURITYINTERFACEW pSspiInitialize = NULL;
FSECINITSECURITYINTERFACEW pSslInitialize = NULL;

ULONG LdapGlobalMsnSecurityFlags = 0;
ULONG LdapGlobalDpaSecurityFlags = 0;

BOOLEAN
LdapLoadSecurityDLL (
    PCHAR DllName
    );

BOOLEAN
LdapInitSecurity (
    VOID
    )
//
//  Returns TRUE if we have an SSPI function table to call through to.
//
{
    if (SecurityLibraryHandle != NULL) {

        return TRUE;      // we have a security DLL loaded, must be right one
    }

    if (pSspiInitialize != NULL) {

        return FALSE;   // dll is not loaded but we have an entry point..
                        // this prevents us from trying to loading
                        // the DLL every time if it failed on first try.
    }

    ACQUIRE_LOCK( &LoadLibLock );

    if (SecurityLibraryHandle != NULL) {

        RELEASE_LOCK( &LoadLibLock );
        return TRUE;      // we have a security DLL loaded, must be right one
    }

    if (pSspiInitialize != NULL) {

        RELEASE_LOCK( &LoadLibLock );
        return FALSE;   // dll is not loaded but we have an entry point..
                        // this prevents us from trying to loading
                        // the DLL every time if it failed on first try.
    }

    NumberSecurityPackagesInstalled = 0;
    SecurityPackagesInstalled = NULL;
    SspiFunctionTableW = NULL;
    SspiFunctionTableA = NULL;

    if ((GlobalWin9x == FALSE) && (AdvApi32LibraryHandle == NULL)) {

        //
        //  if we're on NT, pick up the address of the routine to use to get
        //  the currently logged in user's LUID.
        //

        AdvApi32LibraryHandle = LoadLibraryA( "ADVAPI32.DLL" );

    }
    
    if ((GlobalWin9x == FALSE) && (AdvApi32LibraryHandle != NULL)) {

        pGetTokenInformation = (FGETTOKENINFORMATION) GetProcAddress(
                                        AdvApi32LibraryHandle,
                                        "GetTokenInformation" );
        pOpenThreadToken = (FOPENTHREADTOKEN) GetProcAddress(
                                        AdvApi32LibraryHandle,
                                        "OpenThreadToken" );
        pOpenProcessToken = (FOPENPROCESSTOKEN) GetProcAddress(
                                        AdvApi32LibraryHandle,
                                        "OpenProcessToken" );
    }

    //
    // All exports in security.dll are forwarded to secur32.dll. so, we will try
    // to load it first.
    //

    if ((LdapLoadSecurityDLL("SECUR32.DLL") == FALSE) &&
        (LdapLoadSecurityDLL("SECURITY.DLL")  == FALSE)) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LDAP client failed to load security, err = 0x%x.\n", GetLastError());
        }

        //
        //  remember that we failed so we don't keep retrying
        //

        pSspiInitialize = (FSECINITSECURITYINTERFACEW) -1;

        RELEASE_LOCK( &LoadLibLock );
        return FALSE;
    }

    ASSERT( pSspiInitialize != NULL );

    SspiFunctionTableW = LdapSspiInitialize();

    //
    // There is no Kerberos support in Win9x for now
    //
    if (! GlobalWin9x)
    {
        pSaslInitializeSecurityContextW = (FSASLINITIALIZESECURITYCONTEXTW) GetProcAddress( SecurityLibraryHandle,
                                                        "SaslInitializeSecurityContextW" );

        pSaslGetProfilePackageW = (FSASLGETPROFILEPACKAGEW) GetProcAddress( SecurityLibraryHandle,
                                                        "SaslGetProfilePackageW" );

        pQueryContextAttributesW = (FQUERYCONTEXTATTRIBUTESW) GetProcAddress( SecurityLibraryHandle,
                                                        "QueryContextAttributesW" );

        if (pSaslInitializeSecurityContextW == NULL) {

            LdapPrint0("Failed to load SaslInitializeSecurityContextW\n");
        }

        if ( pSaslGetProfilePackageW == NULL ) {

            LdapPrint0("Failed to load SaslGetProfilePackageW\n");
        }

        if ( pQueryContextAttributesW == NULL ) {

            LdapPrint0("Failed to load QueryContextAttributesW\n");
        }
    }

    if (SspiFunctionTableW == NULL) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LDAP client failed InitSecurityInterface, err = 0x%x.\n", GetLastError());
        }

        //
        //  we definitely failed, so free the library so we don't keep retrying
        //

        FreeLibrary( SecurityLibraryHandle );
        SecurityLibraryHandle = NULL;

        RELEASE_LOCK( &LoadLibLock );
        return FALSE;
    }

    SECURITY_STATUS sErr;

    sErr = SspiFunctionTableW->EnumerateSecurityPackagesW(
                            &NumberSecurityPackagesInstalled,
                            &SecurityPackagesInstalled );
    if (sErr != SEC_E_OK) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LDAP client failed EnumSecurityPackages, err = 0x%x.\n", sErr);
        }

        RELEASE_LOCK( &LoadLibLock );
        return FALSE;
    }

    //
    //  check which security packages are installed.
    //

    ULONG i;
    PSecPkgInfoW packages = SecurityPackagesInstalled;

    if (packages != NULL) {

        for (i = 0; i < NumberSecurityPackagesInstalled; i++) {

            if (ldapWStringsIdentical(
                               packages->Name,
                               -1,
                               L"Kerberos",
                               -1)) {

                SspiPackageKerberos = packages;

            } else if (ldapWStringsIdentical(
                               (const PWCHAR) packages->Name,
                               -1,
                               (const PWCHAR) L"MSN",
                               -1)) {

                SspiPackageSicily = packages;

            } else if (ldapWStringsIdentical(
                               (const PWCHAR) packages->Name,
                               -1,
                               (const PWCHAR) L"NTLM",
                               -1)) {

                SspiPackageNtlm = packages;

            } else if (ldapWStringsIdentical(
                           (const PWCHAR) packages->Name,
                           -1,
                           (const PWCHAR) L"DPA",
                           -1)) {

                SspiPackageDpa = packages;

            } else if (ldapWStringsIdentical(
                           (const PWCHAR) packages->Name,
                           -1,
                           (const PWCHAR) L"wDigest",
                           -1)) {

                SspiPackageDigest = packages;

            } else if (ldapWStringsIdentical(
                           (const PWCHAR) packages->Name,
                           -1,
                           (const PWCHAR) L"Negotiate",
                           -1)) {

                SspiPackageNegotiate = packages;

            }

            //
            // Keep track of the largest token buffer that we'll need.
            //

            if ( packages->cbMaxToken > SspiMaxTokenSize) {
                SspiMaxTokenSize = packages->cbMaxToken;
            }

            packages++;
        }
    }

    RELEASE_LOCK( &LoadLibLock );
    return TRUE;
}

BOOLEAN
LdapInitSsl (
    VOID
    )
//
//  Returns TRUE if we have an SSL SSPI function table to call through to.
//
//  We treat SCHANNEL.DLL separately because on Win9x, it's not accessible
//  through the normal security dll.
//
{
    if (SslLibraryHandle != NULL) {

        return TRUE;      // we have a security DLL loaded, must be right one
    }

    if (pSslInitialize != NULL) {

        return FALSE;   // dll is not loaded but we have an entry point..
                        // this prevents us from trying to loading
                        // the DLL every time if it failed on first try.
    }

    ACQUIRE_LOCK( &LoadLibLock );

    if (SslLibraryHandle != NULL) {

        RELEASE_LOCK( &LoadLibLock );
        return TRUE;      // we have a security DLL loaded, must be right one
    }

    if (pSslInitialize != NULL) {

        RELEASE_LOCK( &LoadLibLock );
        return FALSE;   // dll is not loaded but we have an entry point..
                        // this prevents us from trying to loading
                        // the DLL every time if it failed on first try.
    }

    NumberSslPackagesInstalled = 0;
    SslPackagesInstalled = NULL;
    SslFunctionTableW = NULL;
    SslFunctionTableA = NULL;

    ASSERT( SslLibraryHandle == NULL );

    SslLibraryHandle = LoadLibraryA( "SCHANNEL.DLL" );

    if (SslLibraryHandle == NULL) {

        //
        //  remember that we failed so we don't keep retrying
        //

        pSslInitialize = (FSECINITSECURITYINTERFACEW) -1;

        RELEASE_LOCK( &LoadLibLock );
        return FALSE;
    }

    //
    //  if it's the wrong library for some reason, fail it and free the library.
    //

    if (GlobalWin9x)
    {
        pSslInitialize = (FSECINITSECURITYINTERFACEW) GetProcAddress( SslLibraryHandle,
                                                    "InitSecurityInterfaceA" );
    }
    else
    {
        pSslInitialize = (FSECINITSECURITYINTERFACEW) GetProcAddress( SslLibraryHandle,
                                                        "InitSecurityInterfaceW" );
    }

    if (pSslInitialize == NULL) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LDAP failed GetProcAddress for InitSecurityInterface, err = 0x%x.\n", GetLastError());
        }

        FreeLibrary( SslLibraryHandle );
        SslLibraryHandle = NULL;

        //
        //  remember that we failed so we don't keep retrying
        //

        pSslInitialize = (FSECINITSECURITYINTERFACEW) -1;

        RELEASE_LOCK( &LoadLibLock );
        return FALSE;
    }

    SslFunctionTableW = LdapSslInitialize();

    if (SslFunctionTableW == NULL) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LDAP client failed SSL InitSecurityInterface, err = 0x%x.\n", GetLastError());
        }

        //
        //  we definitely failed, so free the library so we don't keep retrying
        //

        FreeLibrary( SslLibraryHandle );
        pSslInitialize = (FSECINITSECURITYINTERFACEW) -1;
        SslLibraryHandle = NULL;

        RELEASE_LOCK( &LoadLibLock );
        return FALSE;
    }


    SECURITY_STATUS sErr;

    sErr = SslFunctionTableW->EnumerateSecurityPackagesW(
                            &NumberSslPackagesInstalled,
                            &SslPackagesInstalled );
    if (sErr != SEC_E_OK) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LDAP client failed SSL EnumSecurityPackages, err = 0x%x.\n", sErr);
        }
        RELEASE_LOCK( &LoadLibLock );
        return FALSE;
    }

    //
    //  check which security packages are installed.
    //

    ULONG i;
    PSecPkgInfoW packages = SslPackagesInstalled;

    for (i = 0; i < NumberSslPackagesInstalled; i++) {

        if (ldapWStringsIdentical(
                           (const PWCHAR) packages->Name,
                           -1,
                           (const PWCHAR) L"Microsoft Unified Security Protocol Provider",
                           -1)) {

            SspiPackageSslPct = packages;
        }

        //
        // Keep track of the largest token buffer that we'll need.
        //

        if ( packages->cbMaxToken > SspiMaxTokenSize) {
            SspiMaxTokenSize = packages->cbMaxToken;
        }

        packages++;
    }

    RELEASE_LOCK( &LoadLibLock );
    return TRUE;
}


BOOLEAN
LdapLoadSecurityDLL (
    PCHAR DllName
    )
{
    ASSERT( SecurityLibraryHandle == NULL );

    SecurityLibraryHandle = LoadLibraryA( DllName );

    if (SecurityLibraryHandle == NULL) {

        return FALSE;
    }

    //
    //  if it's the wrong library for some reason, fail it and free the library.
    //

    if (GlobalWin9x)
    {
        pSspiInitialize = (FSECINITSECURITYINTERFACEW) GetProcAddress( SecurityLibraryHandle,
                                                    "InitSecurityInterfaceA" );
    }
    else
    {
        pSspiInitialize = (FSECINITSECURITYINTERFACEW) GetProcAddress( SecurityLibraryHandle,
                                                        "InitSecurityInterfaceW" );
    }

    if (pSspiInitialize == NULL) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LDAP failed GetProcAddress for InitSecurityInterface, err = 0x%x.\n", GetLastError());
        }

        FreeLibrary( SecurityLibraryHandle );
        SecurityLibraryHandle = NULL;

        return FALSE;
    }
    return TRUE;
}

BOOLEAN
CheckForNullCredentials (
    PLDAP_CONN Connection
    )
{
    if ((Connection->hCredentials.dwLower == (ULONG_PTR) -1) &&
        (Connection->hCredentials.dwUpper == (ULONG_PTR) -1)) {

        return TRUE;
    }
    return FALSE;
}

VOID
CloseCredentials (
    PLDAP_CONN Connection
    )
{
    SECURITY_STATUS sErr;

    ACQUIRE_LOCK( &Connection->StateLock);

    if ((Connection->SecurityContext.dwLower != (ULONG_PTR) -1) ||
        (Connection->SecurityContext.dwUpper != (ULONG_PTR) -1)) {

        sErr = SspiFunctionTableW->DeleteSecurityContext( &Connection->SecurityContext );
//      ASSERT(sErr == SEC_E_OK);

        Connection->SecurityContext.dwLower = (ULONG_PTR) -1;
        Connection->SecurityContext.dwUpper = (ULONG_PTR) -1;
    }

    if (CheckForNullCredentials(Connection) == FALSE) {

        ASSERT( SspiFunctionTableW != NULL );

        sErr = SspiFunctionTableW->FreeCredentialHandle( &Connection->hCredentials );
//      ASSERT(sErr == SEC_E_OK);

        Connection->hCredentials.dwLower = (ULONG_PTR) -1;
        Connection->hCredentials.dwUpper = (ULONG_PTR) -1;
    }

    Connection->CurrentLogonId.LowPart = 0;
    Connection->CurrentLogonId.HighPart = 0;

    RELEASE_LOCK( &Connection->StateLock);
    
    return;
}


VOID
CloseCredentialsByHandle (
    CredHandle * phCredentials
    )
{
    SECURITY_STATUS sErr;

    if (!((phCredentials->dwLower == (ULONG_PTR) -1) &&
          (phCredentials->dwUpper == (ULONG_PTR) -1))) {

        ASSERT( SspiFunctionTableW != NULL );

        sErr = SspiFunctionTableW->FreeCredentialHandle( phCredentials );

        phCredentials->dwLower = (ULONG_PTR) -1;
        phCredentials->dwUpper = (ULONG_PTR) -1;
    }
   
    return;
}


VOID
SetNullCredentials (
    PLDAP_CONN Connection
    )
{
    Connection->hCredentials.dwLower = (ULONG_PTR) -1;
    Connection->hCredentials.dwUpper = (ULONG_PTR) -1;

    Connection->SecurityContext.dwLower = (ULONG_PTR) -1;
    Connection->SecurityContext.dwUpper = (ULONG_PTR) -1;
    return;
}


VOID
ClearSecurityContext (
    PLDAP_CONN Connection
    )
{

    ACQUIRE_LOCK( &Connection->StateLock);

    if ((Connection->SecurityContext.dwLower != (ULONG_PTR) -1) ||
        (Connection->SecurityContext.dwUpper != (ULONG_PTR) -1)) {

        SspiFunctionTableW->DeleteSecurityContext( &Connection->SecurityContext );

        Connection->SecurityContext.dwLower = (ULONG_PTR) -1;
        Connection->SecurityContext.dwUpper = (ULONG_PTR) -1;
    }

    RELEASE_LOCK( &Connection->StateLock);    
}


VOID
ClearSecurityContextByHandle (
    CtxtHandle * pSecurityContext
    )
{


    if ((pSecurityContext->dwLower != (ULONG_PTR) -1) ||
        (pSecurityContext->dwUpper != (ULONG_PTR) -1)) {

        ASSERT( SspiFunctionTableW != NULL );
        SspiFunctionTableW->DeleteSecurityContext( pSecurityContext );

        pSecurityContext->dwLower = (ULONG_PTR) -1;
        pSecurityContext->dwUpper = (ULONG_PTR) -1;
    }

}


ULONG
LdapConvertSecurityError (
    PLDAP_CONN Connection,
    SECURITY_STATUS sErr
    )
//
//  Map a security return code to an ldap return code.
//
{
    ULONG err;

    switch (sErr) {
    case SEC_E_OK:
        err = LDAP_SUCCESS;
        break;

    case SEC_E_NO_CREDENTIALS:
    case SEC_E_NOT_OWNER:
    case SEC_E_LOGON_DENIED:
        err = LDAP_INVALID_CREDENTIALS;
        break;

    case SEC_E_UNKNOWN_CREDENTIALS:
    case SEC_E_SECPKG_NOT_FOUND:
        err = LDAP_AUTH_UNKNOWN;
        break;

    case SEC_E_INSUFFICIENT_MEMORY:
        err = LDAP_NO_MEMORY;
        break;

    case ERROR_BAD_NET_RESP:
        err = LDAP_SERVER_DOWN;
        break;

    case ERROR_TIMEOUT:
        err = LDAP_TIMEOUT;
        break;
    
    case SEC_E_INTERNAL_ERROR:
    default:

        SetConnectionError (Connection, sErr, NULL);
        err = LDAP_LOCAL_ERROR;
    }

    return err;
}

ULONG
LdapSspiBind (
    PLDAP_CONN Connection,
    PSecPkgInfoW Package,
    ULONG UserMethod,
    ULONG SspiFlags,
    PWCHAR UserName,
    PWCHAR TargetName,
    PWCHAR Credentials
)
/*+++

Description:

    Given an SSPI package, the method that the user request, a user name,
    the package specific data, a password, and a set of security
    requirements, complete the SSPI authentication to the server for the
    current bind request.

    The user supplied authentication method influences how the bind
    packet is formed; othewise, this code is generic for any SSPI package.

---*/
{
    ULONG err;
    SECURITY_STATUS sErr;
    PSecBufferDesc pInboundToken = NULL;
    ULONG          LocalSspiFlags = SspiFlags;
    BOOLEAN        InitFailedOnce = FALSE;
    BOOLEAN        KerberosCapableServer = TRUE;
    BOOLEAN        CheckedForKerberos = FALSE;
    SecBuffer      OutBuffer[1], InBuffer[1];
    PWCHAR newCreds = NULL;
    BOOLEAN fSentMessage = FALSE;
    
    BOOLEAN fRequireSigning = FALSE;
    BOOLEAN fSign = FALSE;
    BOOLEAN fSignableServer = Connection->WhistlerServer;

    // The security context we negotiate using this bind.  This will become
    // the connection's security context once the bind is complete.
    CtxtHandle BindSecurityContext = {-1, -1};     // SSPI security context
    CredHandle hBindCredentials = {-1, -1};        // credential handle from SSPI
    TimeStamp  BindCredentialExpiry;    // local time credential expires.

    //
    // Determine our signing requirements.  Global signing policy only
    // applies if we're not doing SSL.
    //
    if (Connection->UserSignDataChoice) {
        fRequireSigning = TRUE;
        fSign = TRUE;
    }
    else {
        // If user didn't explicitly request signing, it's still possible signing bits
        // are set in NegotiateFlags (& variables derived from NegotiateFlags) from a previous
        // bind that turned on signing by policy.  Make sure those bits are cleared in
        // preparation for this bind --- we'll turn them back on below if policy dictates.
        SspiFlags &= ~(ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT);
        LocalSspiFlags &= ~(ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT);
        Connection->NegotiateFlags &= ~(ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT);
    }

    if (!Connection->SslPort) {
    
        if (GlobalIntegrityDefault == DEFAULT_INTEGRITY_REQUIRED) {

            fRequireSigning = TRUE;
        }

        //
        // If we have integrity (signing) globally turned on,
        // turn it on for this connection.  Note, that if we only
        // "prefer" signing and fail to establish it, we'll later need
        // to reset the connection to its unsigned state.
        //
        if ( ((GlobalIntegrityDefault == DEFAULT_INTEGRITY_PREFERRED) && (fSignableServer)) ||
             (GlobalIntegrityDefault == DEFAULT_INTEGRITY_REQUIRED) ) {

            SspiFlags |= (ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT);
            LocalSspiFlags |= (ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT);
            fSign=TRUE;
        }
    }
    
    //
    // Make sure the security provider has been initialized.
    //

    OutBuffer[0].pvBuffer = NULL;

    ASSERT( SspiFunctionTableW != NULL );

    //
    // The client can perform multiple binds in
    // a single session.  So we set up a new security context and credential
    // handle for this bind, and cleanup the old context/credentials once the
    // bind is complete to avoid leaks.  We need to keep the old context
    // around because the connection may be currently signed/sealed, so we need
    // to use the old context to sign/seal the bind until a new context is
    // established.
    //

    LdapClearSspiState( Connection );

    //
    // If we are currently autoreconnecting, do not recreate the credential
    // handle since we already have it. This will ensure that we use the
    // same credential context used on the primary bind.
    //

    if ( Connection->Reconnecting ) {

        //
        // Use the existing credential handle for the new security context.
        //

        hBindCredentials = Connection->hCredentials;

    } else {

        //
        // It is valid to issue multiple binds on the same connection.
        // Create a new credential handle for the newly passed-in credentials.
        //

    
        //
        //  If alternate credentials were passed in and we have a
        //  SEC_WINNT_AUTH_IDENTITY structure, ensure it's the right format.
        //
    
        if ( Credentials != NULL) {
    
           err = ProcessAlternateCreds( Connection,
                                        Package,
                                        Credentials,
                                        &newCreds
                                         );
           if (err != LDAP_SUCCESS) {
    
              LdapPrint0(" Error in processing alternate credentials\n");
              return err;
    
           }
        }
    
        sErr = SspiFunctionTableW->AcquireCredentialsHandleW(
                   NULL,                          // User name for the credentials (ignored).
                   Package->Name,                 // Security package name.
                   SECPKG_CRED_OUTBOUND,          // These are outbound only credentials.
                   NULL,                          // The user LUID - not used.
                   newCreds,                      // The package specific data.
                   NULL,                          // The specific get key function.
                   NULL,                          // Argument to the get key function.
                   &hBindCredentials,     // OUT: Pointer to the credential.
                   &BindCredentialExpiry  // OUT: Credential expiration time.
        );
    
        err = LdapConvertSecurityError( Connection, sErr );
    
        if ( err != LDAP_SUCCESS ) {
    
            IF_DEBUG( NETWORK_ERRORS ) {
                LdapPrint2( "LdapSspiBind Connection 0x%x received 0x%x on \
                             AcquireCredentialsHandle.\n",
                            Connection, sErr );
            }
            goto ExitWithCleanup;
        }
    }

    //
    // Get the opaque SSPI token for the remote peer.
    //

    SecBufferDesc  OutboundToken, InboundToken;
    DWORD          ContextAttr;
    TimeStamp      tsExpiry;

    ContextAttr = 0;

    OutBuffer[0].pvBuffer = ldapMalloc( SspiMaxTokenSize,
                                        LDAP_SECURITY_SIGNATURE );
    if ( OutBuffer[0].pvBuffer == NULL ) {
        err = LDAP_NO_MEMORY;
        goto ExitWithCleanup;
    }

    OutBuffer[0].cbBuffer = SspiMaxTokenSize,
    OutBuffer[0].BufferType = SECBUFFER_TOKEN;

    OutboundToken.cBuffers = 1;
    OutboundToken.pBuffers = OutBuffer;
    OutboundToken.ulVersion = SECBUFFER_VERSION;

    InBuffer[0].cbBuffer = 0;
    InBuffer[0].BufferType = SECBUFFER_TOKEN;
    InBuffer[0].pvBuffer = NULL;

    InboundToken.cBuffers = 1;
    InboundToken.pBuffers = InBuffer;
    InboundToken.ulVersion = SECBUFFER_VERSION;

ITERATE_BIND:


    if ((pSaslInitializeSecurityContextW) &&
        (UserMethod == LDAP_AUTH_NEGOTIATE) &&
        (Connection->PreferredSecurityPackage)) {

        sErr = (*pSaslInitializeSecurityContextW)(
                   &hBindCredentials,                    // The credential.
                   Connection->CurrentAuthLeg ?
                     &BindSecurityContext : NULL,        // The partially formed context.
                   TargetName,                           // Target name.
                   LocalSspiFlags,                       // Required attributes.
                   0,                                    // Reserved - must be zero.
                   SECURITY_NATIVE_DREP,                 // Data representation on target.
                   pInboundToken,                        // Pointer to the input buffers.
                   0,                                    // Reserved - must be zero.
                   &BindSecurityContext,                 // OUT: New context handle.
                   &OutboundToken,                       // OUT: Opaque token.
                   &ContextAttr,                         // OUT: Context established attributes.
                   &tsExpiry                             // OUT: Expiration time for context.
        );

    } else {


        sErr = SspiFunctionTableW->InitializeSecurityContextW(
                   &hBindCredentials,                    // The credential.
                   Connection->CurrentAuthLeg ?
                     &BindSecurityContext : NULL,        // The partially formed context.
                   TargetName,                           // Target name.
                   LocalSspiFlags,                       // Required attributes.
                   0,                                    // Reserved - must be zero.
                   SECURITY_NATIVE_DREP,                 // Data representation on target.
                   pInboundToken,                        // Pointer to the input buffers.
                   0,                                    // Reserved - must be zero.
                   &BindSecurityContext,                 // OUT: New context handle.
                   &OutboundToken,                       // OUT: Opaque token.
                   &ContextAttr,                         // OUT: Context established attributes.
                   &tsExpiry                             // OUT: Expiration time for context.
        );

    }

    //
    // If the SSPI package is the MSN Sicily package and
    // we failed because of a lack of credentials, then
    // throw up the "Logon to MSN" dialog.
    //

    if (LocalSspiFlags & ISC_REQ_PROMPT_FOR_CREDS) {

        InitFailedOnce = TRUE;
    }

    if ( ( ( UserMethod == LDAP_AUTH_SICILY ) ||
           ( UserMethod == LDAP_AUTH_DPA ) ||
           ( UserMethod == LDAP_AUTH_MSN ) ) &&
         ( sErr == SEC_E_NO_CREDENTIALS ) &&
         ( Connection->PromptForCredentials ) &&
         ( !InitFailedOnce ) ) {

        InitFailedOnce = TRUE;
        SetFlag( LocalSspiFlags, ISC_REQ_PROMPT_FOR_CREDS );
        goto ITERATE_BIND;
    }

    if ( InitFailedOnce ) {
        ClearFlag( LocalSspiFlags, ISC_REQ_PROMPT_FOR_CREDS );
        InitFailedOnce = FALSE;
    }

    //
    // If there was an inbound token, then we're in an intermediate
    // leg of a multi-leg authentication procedure.  We need to free
    // the LDAP response that holds the most recent inbound token.
    //

    if ( ( pInboundToken ) &&
         ( pInboundToken->pBuffers[0].pvBuffer != NULL ) ) {

        pInboundToken->pBuffers[0].pvBuffer = NULL;
        pInboundToken->pBuffers[0].cbBuffer = 0;

        pInboundToken = NULL;

        ldap_msgfree( Connection->BindResponse );
        Connection->BindResponse = NULL;
    }

    //
    // Check the return code and set the proper SSPI
    // continue flags in the connection data structure.
    //

    err = LdapSetSspiContinueState( Connection, sErr );

    if ( err != LDAP_SUCCESS ) {
        goto ExitWithCleanup;
    }

    //
    // If we determine that the server is capable of kerberos but the it
    // does not advertise GSSAPI or GSS_SPENGO in it's RootDSE, we should
    // fail the bind request because this could be a downgrade attack to
    // collect NTLM passwords.
    //

    if (( CheckedForKerberos == FALSE ) &&
        ( UserMethod == LDAP_AUTH_NEGOTIATE ) &&
        ( pQueryContextAttributesW != NULL )) {

        SecPkgContext_NegotiationInfoW NegoInfo;
        
        ULONG status = pQueryContextAttributesW( &BindSecurityContext,
                                           SECPKG_ATTR_NEGOTIATION_INFO,
                                           &NegoInfo );
        
        if (NT_SUCCESS(status)) {

            CheckedForKerberos = TRUE;

            if (ldapWStringsIdentical(
                                      NegoInfo.PackageInfo->Name,
                                      -1,
                                      L"Kerberos",
                                      -1 )) {

                IF_DEBUG(BIND) {
                    LdapPrint0("wldap32:Server is capable of Kerberos\n");
                }
                KerberosCapableServer = TRUE;
    
            } else {

                IF_DEBUG(BIND) {
                    LdapPrint1("wldap32:Server is capable of %S\n", NegoInfo.PackageInfo->Name);
                }
                KerberosCapableServer = FALSE;
            }       
                
            SspiFunctionTableW->FreeContextBuffer( NegoInfo.PackageInfo );
        
            if (KerberosCapableServer &&
                !(Connection->SupportsGSSAPI || Connection->SupportsGSS_SPNEGO)) {

                //
                // This is a rogue server trying to trick us into sending it NTLM
                // creds or an SPN misconfiguration.
                //
    
                err = LDAP_UNWILLING_TO_PERFORM;
                goto ExitWithCleanup;
            
            } else if (!KerberosCapableServer && !Connection->PreferredSecurityPackage) {

                if (!(Connection->SupportsGSS_SPNEGO || Connection->SupportsGSSAPI)) {

                    if (Connection->HighestSupportedLdapVersion == LDAP_VERSION3) {
                        //
                        // This must be an Exchange/SiteServer server which does not support
                        // kerberos. No point in getting LdapExchangeOpaqueToken to label
                        // it as a GSSAPI blob. We will retry with sicily authentication.
                        //

                        err = LDAP_AUTH_METHOD_NOT_SUPPORTED;
                        goto ExitWithCleanup;
                    
                    } else {
                        //
                        // This must be a v2 server. Obviously it will not understand gssapi
                        // we must back off to v2 and try with Sicily auth.
                        //

                        ASSERT(Connection->publicLdapStruct.ld_version == LDAP_VERSION3);
                        err = LDAP_PROTOCOL_ERROR;
                        goto ExitWithCleanup;

                    }
                }
            }

        } else {

            LdapPrint1("QueryContextAttributes failed with 0x%x\n", status)
            err = LDAP_LOCAL_ERROR;
            goto ExitWithCleanup;
        }
    }

    //
    // We can't have a partial response here since the
    // token was part of an LDAP message!!
    //

    ASSERT( Connection->SspiNeedsMoreData == FALSE );

    //
    // Complete the token if the SSPI provider requires.
    //

    if ( Connection->TokenNeedsCompletion ) {

        sErr = SspiFunctionTableW->CompleteAuthToken(
                   &BindSecurityContext,
                   &OutboundToken );

        err = LdapConvertSecurityError( Connection, sErr );

        if ( err != LDAP_SUCCESS ) {

            IF_DEBUG( NETWORK_ERRORS ) {
                LdapPrint1( "LdapSspiBind couldn't complete the \
                             auth token.  sErr = 0x%x\n", sErr );
            }

            goto ExitWithCleanup;
        }

        Connection->TokenNeedsCompletion = FALSE;
    }

    //
    // Send the token if one was provided.  The response
    // will contain the SSPI SecBuffer that we need to
    // continue if this is a multi-leg auth package. The other
    // case is during GSSAPI auth for the server initiation of
    // the roundtrip where we have to send an empty bind request.
    //

    if (( OutBuffer[0].cbBuffer != 0 ) ||
        (( OutBuffer[0].cbBuffer == 0) &&
          (sErr == SEC_I_CONTINUE_NEEDED))) {

        //
        // Ensure that we sign/seal during the bind stage
        // with the options CURRENTLY being used on this connection,
        // not with what we're TRYING to establish with this bind
        //        

        err = LdapExchangeOpaqueToken( Connection,
                                       UserMethod,
                                       Connection->SaslMethod,     // User preferred SASL mechanism
                                       UserName,
                                       OutboundToken.pBuffers[0].pvBuffer,
                                       OutboundToken.pBuffers[0].cbBuffer,
                                       &InboundToken,
                                       NULL,            // server returned cred
                                       NULL,            // server ctrls
                                       NULL,            // Client Ctrls
                                       NULL,            // return msgNumber
                                       FALSE,           // Send only
                                       FALSE,           // Unicode
                                       &fSentMessage);  // did we send bind message


        if (( err != LDAP_SUCCESS ) &&
            ( err != LDAP_SASL_BIND_IN_PROGRESS )) {

            goto ExitWithCleanup;
        }

    }

    //
    // If SSPI expects the response token, send it on up.
    //

    if ( Connection->SspiNeedsResponse ) {

        if ( Package == SspiPackageDpa ) {

            LocalSspiFlags |= LdapGlobalDpaSecurityFlags;
            LdapGlobalDpaSecurityFlags = 0;
        }

        if ( Package == SspiPackageSicily ) {

            LocalSspiFlags |= LdapGlobalMsnSecurityFlags;
            LdapGlobalMsnSecurityFlags = 0;
        }

        pInboundToken = &InboundToken;

        ASSERT( pInboundToken->pBuffers[0].pvBuffer != NULL );
        ASSERT( pInboundToken->pBuffers[0].cbBuffer != 0 );

        //
        // Reset the outbound token size.
        //

        OutBuffer[0].cbBuffer = SspiMaxTokenSize;

        goto ITERATE_BIND;
    }


    //
    // security check: If we asked for a connection that supports
    // signing/sealing, make sure we got one.
    //

    // first check signing.  We have to deal with the possibility
    // that signing may have been preferred but not required.
    if ( ((SspiFlags & ISC_REQ_INTEGRITY) &&
          (!(ContextAttr & ISC_REQ_INTEGRITY))) ||
          
         ((SspiFlags & ISC_REQ_SEQUENCE_DETECT) &&
          (!(ContextAttr & ISC_REQ_SEQUENCE_DETECT))) ) {


        IF_DEBUG(SSL) {
            LdapPrint2("LdapSspiBind: asked for connection supporting SspiFlags = 0x%x, \
                        got connection supporting ContextAttr = 0x%x\n", SspiFlags, ContextAttr);
        }

        if (fRequireSigning) {
            err = LDAP_UNWILLING_TO_PERFORM;
            goto ExitWithCleanup;
        }
        else {
            // must be just signing preferred.  reset the signing status
            // on the connection.
            SspiFlags &= ~(ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT);
            LocalSspiFlags &= ~(ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT);
            fSign = FALSE;
        }
    }

    // check sealing
    if ((SspiFlags & ISC_REQ_CONFIDENTIALITY) &&
          (!(ContextAttr & ISC_REQ_CONFIDENTIALITY))) {


        IF_DEBUG(SSL) {
            LdapPrint2("LdapSspiBind: asked for connection supporting SspiFlags = 0x%x, \
                        got connection supporting ContextAttr = 0x%x\n", SspiFlags, ContextAttr);
        }
 
        err = LDAP_UNWILLING_TO_PERFORM;
        goto ExitWithCleanup;
    }


ExitWithCleanup:

    //
    // Regardless of whether we succeeded or failed, we need to get rid of
    // the old context if we started the bind protocol with the server
    //  * If we failed, the old context is no good anyway
    //  (see RFC 2251, section 4.2.1, about subsequent binds : "Authentication
    //  from earlier binds are subsequently ignored, and so if the bind fails,
    //  the connection will be treated as anonymous.")
    //  * If we succeeded, the new context will replace the old context.
    //

    // We skip only if it failed before we got to the point of sending anything
    // to the server (since in that case the server doesn't know anything is wrong)
    if (! ((!fSentMessage) && (err != LDAP_SUCCESS)) ) {

            
        if ( Connection->Reconnecting ) {

            //
            // This could be a transient security failure.
            // Get rid of the security context but save the credential handle.
            // If we are asked to autorebind in future, we will need it.
            //
            
            ClearSecurityContext( Connection );

        } else {

            CloseCredentials( Connection );
        }

        //
        // Clear the secure stream left over from the previous bind,
        // if it was a SASL (sign/seal) secure stream
        //
        if ((Connection->SecureStream) &&
            (Connection->CurrentSignStatus || Connection->CurrentSealStatus)) {

            PSECURESTREAM pTemp;
            pTemp = (PSECURESTREAM) Connection->SecureStream;
            delete pTemp;
            
            Connection->SecureStream = NULL;
            Connection->CurrentSignStatus = FALSE;
            Connection->CurrentSealStatus = FALSE;
        }

    }

    //
    // If we failed, close the new SSPI credentials.
    //

    if ( err != LDAP_SUCCESS ) {

        if ( Connection->Reconnecting ) {
    
            // we created a new security context but used the old credential handle,
            // so we just need to clean up the new context
    
            IF_DEBUG( RECONNECT ) {
                LdapPrint1("LDAP rebind failed due to security error 0x%x", sErr);
            }
            
            ClearSecurityContextByHandle( &BindSecurityContext );
    
        } else {

            //
            // Get rid of the new context as well as the new credentials. This bind has
            // no chance of recovering.
            //

            ClearSecurityContextByHandle( &BindSecurityContext );
            CloseCredentialsByHandle( &hBindCredentials );
        }

 
        if (( err == LDAP_INVALID_CREDENTIALS ) &&
            ( Connection->PromptForCredentials )) {

            if ( Package == SspiPackageDpa ) {

                //
                //  if we failed due to invalid credentials, prompt for
                //  credentials the next time we come in here.
                //

                LdapGlobalDpaSecurityFlags = ISC_REQ_PROMPT_FOR_CREDS;
            }
            if ( Package == SspiPackageSicily ) {

                //
                //  if we failed due to invalid credentials, prompt for
                //  credentials the next time we come in here.
                //

                LdapGlobalMsnSecurityFlags = ISC_REQ_PROMPT_FOR_CREDS;
            }
        }

        if (!CheckedForKerberos) {
            //
            // We don't know for sure if the server is kerberos capable. We
            // failed before getting to that step. Let's give it the benefit
            // of the doubt.
            //
            
            KerberosCapableServer = FALSE;
        }

        if (KerberosCapableServer &&
            (( err == LDAP_PROTOCOL_ERROR ) ||
             ( err == LDAP_AUTH_METHOD_NOT_SUPPORTED ) )) {
            
            //
            // Make sure that we don't fall back to NTLM/Sicily if a server tries
            // to fool us with a bogus return code.
            //

            err = LDAP_UNWILLING_TO_PERFORM;
        }

        if (newCreds != NULL) {

            ldapFree( newCreds, LDAP_SECURITY_SIGNATURE );
        }

    } else {

        Connection->BindMethod = UserMethod;
        Connection->CurrentCredentials = newCreds;
        // update the current sign/seal status with the signing/sealing
        // we just negotiated
        Connection->CurrentSignStatus = fSign;
        Connection->CurrentSealStatus = Connection->UserSealDataChoice;
        
        // If the bind we negotiated has signing enabled, but our connection's NegotiateFlags
        // don't indicate signing, then we must have turned on signing by integrity policy and
        // need to update NegotiateFlags to reflect this fact
        if ( (SspiFlags & (ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT)) &&
             (!(Connection->NegotiateFlags & (ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT)))) {

            Connection->NegotiateFlags |= (ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT);
        }

        //
        // Copy the new credentials/context into the connection
        // (the old credentials/context have already been freed).
        //
        if ( Connection->Reconnecting ) {

            // reconnects recycle the old credential handle,
            // so we just need to copy the context
            Connection->SecurityContext = BindSecurityContext;
    
        } else {
        
            Connection->SecurityContext = BindSecurityContext;
            Connection->hCredentials = hBindCredentials;
            Connection->CredentialExpiry = BindCredentialExpiry;

        }

        //
        // Scramble stored password if necessary.
        //
        // CurrentCredentials points to an authidentity/_EX struct
        // which inturn, points to plaintext credentials. We will encrypt
        // only the password.
        //

        if ((Connection->CurrentCredentials) && GlobalUseScrambling) {

            PSEC_WINNT_AUTH_IDENTITY_EXW temp = (PSEC_WINNT_AUTH_IDENTITY_EXW) Connection->CurrentCredentials;
    
            ACQUIRE_LOCK( &Connection->ScramblingLock );
    
            if (( temp->Version > 0xFFFF )||( temp->Version == 0 )) {
    
               //
               // we are using the older style authIdentity structure.
               //
    
                PSEC_WINNT_AUTH_IDENTITY_W pAuth = (PSEC_WINNT_AUTH_IDENTITY_W) Connection->CurrentCredentials;
    
                if (pAuth->Password) {
    
                      pRtlInitUnicodeString( &Connection->ScrambledCredentials, pAuth->Password);
                      RoundUnicodeStringMaxLength(&Connection->ScrambledCredentials, DES_BLOCKLEN);
                      EncodeUnicodeString(&Connection->ScrambledCredentials);

                      Connection->Scrambled = TRUE;
                }
    
            } else {
    
                //
                // We are using the newer style _EX structure.
                //
                
                PSEC_WINNT_AUTH_IDENTITY_EXW pAuthEX = (PSEC_WINNT_AUTH_IDENTITY_EXW) Connection->CurrentCredentials;
    
                if (pAuthEX->Password) {
    
                      pRtlInitUnicodeString( &Connection->ScrambledCredentials, pAuthEX->Password);
                      RoundUnicodeStringMaxLength(&Connection->ScrambledCredentials, DES_BLOCKLEN);
                      EncodeUnicodeString(&Connection->ScrambledCredentials);

                      Connection->Scrambled = TRUE;
                }
    
            }
            
            RELEASE_LOCK( &Connection->ScramblingLock );

        }

        //
        // If this is an auto-rebind, we should already have a LUID so,
        // don't overwrite it with a new one.
        //

        if ( Connection->Reconnecting == FALSE ) {

            GetCurrentLuid( &Connection->CurrentLogonId );
        }

        if (Connection->CurrentSignStatus || Connection->CurrentSealStatus) {

            ASSERT( SspiFunctionTableW != NULL );

            PSECURESTREAM pSecureStream;

            IF_DEBUG(SSL) {
                LdapPrint0("Creating Cryptstream object to handle signing/sealing\n");
            }

            pSecureStream = new CryptStream( Connection, SspiFunctionTableW, FALSE );

            if ( pSecureStream == NULL ) {

               err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

               Connection->SecureStream = (PVOID)pSecureStream;
            }
        }
    }

    ldapFree( OutBuffer[0].pvBuffer, LDAP_SECURITY_SIGNATURE );

    return err;

}

VOID
GetCurrentLuid (
    PLUID Luid
    )
{
    HANDLE           TokenHandle = NULL ;
    TOKEN_STATISTICS TokenInformation ;
    DWORD            ReturnLength ;
    BOOLEAN          setIt = FALSE;

    //
    //  Get the logon token for the current user making the bind call
    //
    //  Note that we only do this if we're on WinNT, not Win9x since Win9x
    //  doesn't have the concept of different user contexts.
    //

    if ((pGetTokenInformation != 0) &&
        (pOpenThreadToken != 0)) {

        //
        // Try thread first. If fail, try process.
        //

        if ((*pOpenThreadToken)(    GetCurrentThread(),
                                    TOKEN_QUERY,
                                    TRUE,
                                    &TokenHandle) ||
            ((pOpenProcessToken != 0) &&
             (*pOpenProcessToken)(  GetCurrentProcess(),
                                    TOKEN_QUERY,
                                    &TokenHandle))) {

            //
            // Get the TokenSource info to pull out the luid.
            //

            if ((*pGetTokenInformation)(    TokenHandle,
                                            TokenStatistics,
                                            &TokenInformation,
                                            sizeof(TokenInformation),
                                            &ReturnLength)) {

                *Luid = TokenInformation.AuthenticationId ;
                setIt = TRUE;
            }
            CloseHandle(TokenHandle) ;
        }
    }
    if (!setIt) {

        Luid->LowPart = 0;
        Luid->HighPart = 0;
    }

    return;
}

ULONG
LdapSetSspiContinueState(
    PLDAP_CONN Connection,
    SECURITY_STATUS sErr
)
/*+++

Description:

    Given a response code from InitializeSecurityContext,
    set the appropriate state in the connection structure.

---*/
{

    ULONG err = LDAP_SUCCESS;

    switch ( sErr ) {

        case SEC_E_OK:

            Connection->SspiNeedsResponse = FALSE;
            Connection->SspiNeedsMoreData = FALSE;
            Connection->TokenNeedsCompletion = FALSE;
            break;

        case SEC_I_CONTINUE_NEEDED:

            Connection->SspiNeedsResponse = TRUE;
            Connection->SspiNeedsMoreData = FALSE;
            Connection->TokenNeedsCompletion = FALSE;
            break;

        case SEC_I_COMPLETE_NEEDED:

            Connection->TokenNeedsCompletion = TRUE;
            Connection->SspiNeedsResponse = FALSE;
            Connection->SspiNeedsMoreData = FALSE;
            break;

        case SEC_I_COMPLETE_AND_CONTINUE:

            Connection->SspiNeedsResponse = TRUE;
            Connection->TokenNeedsCompletion = TRUE;
            Connection->SspiNeedsMoreData = FALSE;
            break;

        case SEC_E_INCOMPLETE_MESSAGE:

            //
            // If the error is incomplete message, don't
            // touch any other parts of the state - we still
            // need them.
            //

            Connection->SspiNeedsMoreData = TRUE;
            break;

        default:

            err = LdapConvertSecurityError( Connection, sErr );

            IF_DEBUG(NETWORK_ERRORS) {

                LdapPrint2(
                    "LdapSetSspiContinueState: Conn 0x%x received 0x%x.\n",
                    Connection, sErr
                );
            }

            break;
    }

    return err;

}

VOID
LdapClearSspiState(
    PLDAP_CONN Connection
) {

    Connection->SspiNeedsResponse = FALSE;
    Connection->SspiNeedsMoreData = FALSE;
    Connection->TokenNeedsCompletion = FALSE;
    Connection->CurrentAuthLeg = 0;

}


ULONG
LdapExchangeOpaqueToken(
    PLDAP_CONN Connection,
    ULONG UserMethod,
    PWCHAR MethodOID,
    PWCHAR UserName,
    PVOID pOutboundToken,
    ULONG cbTokenLength,
    SecBufferDesc *pInboundToken,
    BERVAL **ServerCred,
    PLDAPControlW  *ServerControls,
    PLDAPControlW  *ClientControls,
    PULONG  MessageNumber,
    BOOLEAN SendOnly,
    BOOLEAN Unicode,
    BOOLEAN * pSentMessage    
)
/*+++

Description:

    This routine takes the opaque SSPI token and exchanges it with
    the server specified in the connection structure.  The format
    of the token depends on the user method specified.

Arguments:

    Connection     - The connection we are binding.
    UserMethod     - The user specified method for bind (affect packet format).
    UserName       - The user to bind.
    pOutboundToken - The outbound opaque SSPI token for the user.
    cbTokenLength  - The length of the outbound token.
    pInboundToken  - The security buffer descriptor for the inbound token.

 ---*/
{
    ULONG hr;
    CLdapBer lber( Connection->publicLdapStruct.ld_version );
    ULONG LdapErr;
    PLDAP_REQUEST LdapRequest;
    PLDAPMessage LdapMessage = NULL;
    CLdapBer *ReplyBer;
    ULONG WaitTime;
    PWCHAR ErrorMessage = NULL;

    //
    // We have to support these bind methods:
    //
    //     LDAP_AUTH_SICILY
    //     LDAP_AUTH_NEGOTIATE
    //     LDAP_AUTH_DPA
    //     LDAP_AUTH_MSN
    //     LDAP_AUTH_NTLM
    //     LDAP_AUTH_SASL
    //
    // These are not valid on this path:
    //
    //     LDAP_AUTH_SIMPLE
    //

    //
    // Allocate the request.
    //

    ldap_msgfree( Connection->BindResponse );
    Connection->BindResponse = NULL;

    LdapRequest = LdapCreateRequest( Connection, LDAP_BIND_CMD );

    if ( LdapRequest == NULL ) {
        return LDAP_NO_MEMORY;
    }

    LdapRequest->ChaseReferrals = 0;
    
    //
    // Make sure this no other waiting thread steals a response meant
    // for us.
    //

    LdapRequest->Synchronous = TRUE;

    //
    // Figure out how the packet should look.
    //

    switch ( UserMethod ) {

        case LDAP_AUTH_SICILY:
        case LDAP_AUTH_DPA:
        case LDAP_AUTH_MSN:
        case LDAP_AUTH_NTLM:

            LONG SicilyAuthTag;

            LdapErr = LDAP_ENCODING_ERROR;

            hr = lber.HrStartWriteSequence();
            if (hr != NOERROR) {
                goto ExitWithCleanup;
            }

            hr = lber.HrAddValue( (LONG) LdapRequest->MessageId );
            if (hr != NOERROR) {
                goto ExitWithCleanup;
            }

            hr = lber.HrStartWriteSequence( LDAP_BIND_CMD );
            if (hr != NOERROR) {
                goto ExitWithCleanup;
            }

                hr = lber.HrAddValue( (LONG) Connection->publicLdapStruct.ld_version );
                if (hr != NOERROR) {
                    goto ExitWithCleanup;
                }

                //
                // Set the leg specific data.
                //

                if ( Connection->CurrentAuthLeg == 0 ) {

                   SicilyAuthTag = BIND_SSPI_NEGOTIATE;

                   hr = lber.HrAddValue( (const WCHAR *) UserName );
                   if (hr != NOERROR) {
                       goto ExitWithCleanup;
                   }

                } else {

                   SicilyAuthTag = BIND_SSPI_RESPONSE;

                   hr = lber.HrAddValue( (const CHAR *) "" );
                   if (hr != NOERROR) {
                       goto ExitWithCleanup;
                   }

                }

                hr = lber.HrAddBinaryValue( (BYTE *)pOutboundToken,
                                            cbTokenLength,
                                            SicilyAuthTag );
                if (hr != NOERROR) {
                    goto ExitWithCleanup;
                }

            hr = lber.HrEndWriteSequence();
            if (hr != NOERROR) {
                goto ExitWithCleanup;
            }

            hr = lber.HrEndWriteSequence();
            if (hr != NOERROR) {
                goto ExitWithCleanup;
            }

            break;

    case LDAP_AUTH_NEGOTIATE:
    case LDAP_AUTH_SASL:
    case LDAP_AUTH_DIGEST:

            LdapErr = LDAP_ENCODING_ERROR;

            hr = lber.HrStartWriteSequence();
            if (hr != NOERROR) {
                goto ExitWithCleanup;
            }

                hr = lber.HrAddValue( (LONG) LdapRequest->MessageId );
                if (hr != NOERROR) {
                    goto ExitWithCleanup;
                }

                hr = lber.HrStartWriteSequence( LDAP_BIND_CMD );
                if (hr != NOERROR) {
                    goto ExitWithCleanup;
                }

                    hr = lber.HrAddValue( (LONG) Connection->publicLdapStruct.ld_version );
                    if (hr != NOERROR) {
                        goto ExitWithCleanup;
                    }

                    hr = lber.HrAddValue( (const WCHAR *) UserName );
                    if (hr != NOERROR) {
                        goto ExitWithCleanup;
                    }

                    //
                    // Now add the SASL wrapper
                    //

                    hr = lber.HrStartWriteSequence( BER_TAG_CONSTRUCTED );
                    if (hr != NOERROR) {
                        goto ExitWithCleanup;
                    }

                    if ((MethodOID != NULL)) {

                        //
                        // User has explicitly requested a sasl method. Stick to it.
                        //

                        hr = lber.HrAddValue( (const WCHAR *) MethodOID );

                    } else if ((UserMethod == LDAP_AUTH_NEGOTIATE) &&
                               (Connection->SupportsGSS_SPNEGO == TRUE) &&
                               (MethodOID == NULL)) {

                        //
                        // This is a NT5 Beta3 server which expects a negotiate
                        // blob or a third pary server which expects a negotiate
                        // blob. Also, the user has not specified a preferred package
                        // to be used.
                        //

                        hr = lber.HrAddValue( (const CHAR *) "GSS-SPNEGO" );

                    } else if (UserMethod == LDAP_AUTH_DIGEST) {

                        hr = lber.HrAddValue( (const CHAR *) "DIGEST-MD5" );
                        
                    } else {

                        //
                        // Send a GSSAPI request. This could be a Beta2 server
                        // or third party server expecting true Kerberos. A true
                        // kerberos blob will be sent *only* if user sets
                        // LDAP_OPT_SASL_METHOD with "GSSAPI". We should remove
                        // this behavior after Beta3.
                        //

                        hr = lber.HrAddValue( (const CHAR *) "GSSAPI" );
                    }

                        if (hr != NOERROR) {
                            goto ExitWithCleanup;
                        }

                        hr = lber.HrAddBinaryValue( (BYTE *)pOutboundToken,
                                                    cbTokenLength );

                        if (hr != NOERROR) {
                            goto ExitWithCleanup;
                        }

                    hr = lber.HrEndWriteSequence();
                    if (hr != NOERROR) {
                        goto ExitWithCleanup;
                    }

                hr = lber.HrEndWriteSequence();
                if (hr != NOERROR) {
                    goto ExitWithCleanup;
                }

            hr = lber.HrEndWriteSequence();
            if (hr != NOERROR) {
                goto ExitWithCleanup;
            }

            break;

        default:

            //
            // Unsupported authentication type.
            //

            IF_DEBUG(ERRORS) {
                LdapPrint1( "LdapExchangeOpaqueToken: Unsupported authentication type %d.\n",
                            UserMethod );
            }

            LdapErr = LDAP_AUTH_METHOD_NOT_SUPPORTED;
            goto ExitWithCleanup;
    }

    //
    // See if we need to process controls
    //

    if (ServerControls || ClientControls) {

        LdapErr = LdapCheckControls( LdapRequest,
                                     ServerControls,
                                     ClientControls,
                                     Unicode,         // unicode?
                                     0 );

        if ( (Connection->publicLdapStruct.ld_version != LDAP_VERSION2) &&
             ( LdapRequest->ServerControls != NULL )) {

            LdapErr = InsertServerControls( LdapRequest, Connection, &lber );

            if (LdapErr != LDAP_SUCCESS) {

                goto ExitWithCleanup;
            }
        }
    }
    //
    // Send the packet and get the response token.
    //

    ACQUIRE_LOCK( &Connection->ReconnectLock );

    AddToPendingList( LdapRequest, Connection );

    LdapErr = LdapSend( Connection, &lber );

    if ( LdapErr != LDAP_SUCCESS ) {

        DecrementPendingList( LdapRequest, Connection );
        RELEASE_LOCK( &Connection->ReconnectLock );
        goto ExitWithCleanup;
    }

    if (pSentMessage) {
        *pSentMessage = TRUE;
    }

    RELEASE_LOCK( &Connection->ReconnectLock );

    if ( SendOnly ) {

        *MessageNumber = LdapRequest->MessageId;
        goto ExitWithCleanup;
    }

    if ( Connection->publicLdapStruct.ld_timelimit ) {
        WaitTime = Connection->publicLdapStruct.ld_timelimit * 1000;
    } else {
        WaitTime = LDAP_BIND_TIME_LIMIT_DEFAULT;
    }

    LdapErr = LdapWaitForResponseFromServer( Connection,
                                             LdapRequest,
                                             WaitTime,
                                             FALSE,
                                             &LdapMessage,
                                             TRUE     // Disable autorec during bind
                                             );

    Connection->BindResponse = LdapMessage;

    if ( (LdapErr != LDAP_SUCCESS) && (LdapMessage == NULL)) {

        goto ExitWithCleanup;
    }

    if ( LdapMessage == NULL ) {
        IF_DEBUG(SERVERDOWN) {
            LdapPrint2( "ldapExchangeOpaque thread 0x%x has connection 0x%x as down.\n",
                            GetCurrentThreadId(),
                            Connection );
        }
        LdapErr = LDAP_SERVER_DOWN;
        goto ExitWithCleanup;
    }

    LdapErr = LdapMessage->lm_returncode;

    if (( LdapErr != LDAP_SUCCESS ) &&
        ( LdapErr != LDAP_SASL_BIND_IN_PROGRESS ))  {

        LdapPrint1("Bailing out of LdapExchangeOpaqueToken because server returned 0x%x\n", LdapErr);
        goto ExitWithCleanup;
    }

    //
    // Describe the inbound token from the message.
    //

    ReplyBer = (CLdapBer*) LdapMessage->lm_ber;

    if (ReplyBer == NULL) {

        hr = LDAP_LOCAL_ERROR;
        goto ExitWithCleanup;
    }

    if ( ( UserMethod == LDAP_AUTH_SICILY ) ||
         ( UserMethod == LDAP_AUTH_MSN ) ||
         ( UserMethod == LDAP_AUTH_DPA ) ||
         ( UserMethod == LDAP_AUTH_NTLM )) {

        //
        // Neither v2 nor v3 exactly.
        //

        hr = ReplyBer->HrGetBinaryValuePointer(
                 (PBYTE *) &(pInboundToken->pBuffers[0].pvBuffer),
                           &(pInboundToken->pBuffers[0].cbBuffer)
             );
        if ( hr != NOERROR ) {
            goto ExitWithCleanup;
        }

    } else if (( UserMethod == LDAP_AUTH_SASL ) && ( ServerCred )) {

        //
        // Copy the data to a berval signature
        //

        hr = ReplyBer->HrGetValueWithAlloc( ServerCred );
        if ( hr != NOERROR ) {
            goto ExitWithCleanup;
        }

    } else if (( UserMethod == LDAP_AUTH_NEGOTIATE ) || ( UserMethod == LDAP_AUTH_DIGEST )) {

        ULONG Tag;
        LdapErr = LDAP_DECODING_ERROR;

        //
        // Skip the matched DN.
        //

        hr = ReplyBer->HrSkipElement();
        if (hr != NOERROR) {
            goto ExitWithCleanup;
        }

        //
        // Skip the error message.
        //

        hr = ReplyBer->HrSkipElement();
        if (hr != NOERROR) {
            goto ExitWithCleanup;
        }

        //
        // Check for the optional elements.
        //

        hr = ReplyBer->HrPeekTag( &Tag );

        if (hr == NOERROR) {
        
            //
            // Got a optional element
            //

            if ( Tag == 0x83 ) {    /* Referral */

               hr = ReplyBer->HrSkipElement();
               if (hr != NOERROR) {
                   goto ExitWithCleanup;
               }

               hr = ReplyBer->HrPeekTag( &Tag );
               if (hr != NOERROR) {
                   goto ExitWithCleanup;
               }
            }

            if ( Tag == 0x85 ) {    /* SupportedVersion */

               hr = ReplyBer->HrSkipElement();
               if (hr != NOERROR) {
                   goto ExitWithCleanup;
               }

               hr = ReplyBer->HrPeekTag( &Tag );
               if (hr != NOERROR) {
                   goto ExitWithCleanup;
               }
            }

            if ( Tag == 0x86 ) {    /* ServerURL */

               hr = ReplyBer->HrSkipElement();
               if (hr != NOERROR) {
                   goto ExitWithCleanup;
               }

               hr = ReplyBer->HrPeekTag( &Tag );
               if (hr != NOERROR) {
                   goto ExitWithCleanup;
               }
            }


            if ( Tag == 0xa7 ) {

                //
                // This is the old style bind response returned from the
                // server. You never know when you might need this code for 
                // backward compatibility. Better to be safe than sorry.
                //
                // BindResponse ::= [APPLICATION 1] SEQUENCE {
                //      COMPONENTS OF LDAPResult,
                //      serverCreds    [7] SaslCredentials OPTIONAL }
                //
                // SaslCredentials ::= SEQUENCE {
                //      mechanism      LDAPString,
                //      credentials    OCTET STRING }
                //
                // We are at the constructed, context-specific
                // option 7, which is the SaslCredentials.
                //

                hr = ReplyBer->HrStartReadSequence( Tag );
                if (hr != NOERROR) {
                    goto ExitWithCleanup;
                }

                //
                // We should be at the constructed, context-specific
                // option 3, which is the SASL packet.
                //

                hr = ReplyBer->HrPeekTag( &Tag );
                if (hr != NOERROR) {
                    goto ExitWithCleanup;
                }

                if ( Tag != 0xa3 ) {
                    goto ExitWithCleanup;
                }

                hr = ReplyBer->HrStartReadSequence( Tag );
                if (hr != NOERROR) {
                    goto ExitWithCleanup;
                }

                //
                // Skip the name element, which we know
                // to be GSSAPI.
                //

                hr = ReplyBer->HrSkipElement();
                if (hr != NOERROR) {
                    goto ExitWithCleanup;
                }

                hr = ReplyBer->HrGetBinaryValuePointer(
                         (PBYTE *) &(pInboundToken->pBuffers[0].pvBuffer),
                                   &(pInboundToken->pBuffers[0].cbBuffer) );

                if (hr != NOERROR) {
                    goto ExitWithCleanup;

                }

            } else  if ( Tag == 0x87 ) {

                //
                // This is the new RFC 2251 style bind response.
                //
                // BindResponse ::= [APPLICATION 1] SEQUENCE {
                //          COMPONENTS OF LDAPResult,
                //          serverSaslCreds    [7] OCTET STRING OPTIONAL }
                //
                // ServerSaslCreds is a primitive encoding of context-specific option 7.
                //

                hr = ReplyBer->HrGetBinaryValuePointer(
                               (PBYTE *) &(pInboundToken->pBuffers[0].pvBuffer),
                               &(pInboundToken->pBuffers[0].cbBuffer),
                               Tag );

                if (hr != NOERROR) {
                    goto ExitWithCleanup;

                }

            } else {

                //
                // If the server does not return the credential blob, we let SSPI
                // flag an error at a later stage.
                //

                goto ExitWithCleanup;

            }
        }

    }

    //
    // We parsed the response, so all must be ok.
    // Bump the authentication leg counter and return.
    // We don't free the LDAP request here since it contains
    // the response and we have to pass that to SSPI.
    //

    Connection->CurrentAuthLeg++;
    LdapErr = LDAP_SUCCESS;

ExitWithCleanup:

    //
    // Try to get back a server Error string if one was returned.
    //

    if (LdapMessage) {

        LdapParseResult(Connection,
                        LdapMessage,
                        0,                   // return code
                        NULL,                // Matched DNs
                        &ErrorMessage,       // Server returned err msg
                        NULL,                // No need for referrals
                        NULL,                // or controls
                        FALSE,               // and don't free the message
                        LANG_UNICODE
                        );

        InsertErrorMessage( Connection, ErrorMessage );
    }

    CloseLdapRequest( LdapRequest );

    DereferenceLdapRequest( LdapRequest );

    if ((LdapErr != LDAP_SUCCESS) || (ServerCred != NULL)) {

        ldap_msgfree( Connection->BindResponse );
        Connection->BindResponse = NULL;
    }

    return LdapErr;
}

ULONG
LdapGetSicilyPackageList(
    PLDAP_CONN Connection,
    PBYTE PackageList,
    ULONG Length,
    PULONG pResponseLen
)
/*+++

Description:

    This sends the package list request to a sicily server.

    Connection  - The connection to the sicily server.
    PackageList - The buffer to write the package list into.
    Length      - The length of the buffer.

---*/
{

    ULONG hr;
    CLdapBer lber( Connection->publicLdapStruct.ld_version );
    CLdapBer *ReplyBer;
    ULONG LdapErr = LDAP_ENCODING_ERROR;
    PLDAP_REQUEST LdapRequest;
    PLDAPMessage LdapMessage = NULL;

    //
    // Form up the package request.
    //

    LdapRequest = LdapCreateRequest( Connection, LDAP_BIND_CMD );

    if ( LdapRequest == NULL ) {
        return LDAP_NO_MEMORY;
    }

    LdapRequest->ChaseReferrals = FALSE;

    hr = lber.HrStartWriteSequence();
    if ( hr != NOERROR ) {
        goto ExitWithCleanup;
    }

    hr = lber.HrAddValue( (LONG) LdapRequest->MessageId );
    if ( hr != NOERROR ) {
        goto ExitWithCleanup;
    }

    hr = lber.HrStartWriteSequence( LDAP_BIND_CMD );
    if ( hr != NOERROR ) {
        goto ExitWithCleanup;
    }

        hr = lber.HrAddValue( (LONG) Connection->publicLdapStruct.ld_version );
        if ( hr != NOERROR ) {
            goto ExitWithCleanup;
        }

        hr = lber.HrAddValue( (const CHAR *) NULL );
        if ( hr != NOERROR ) {
            goto ExitWithCleanup;
        }

        hr = lber.HrAddBinaryValue( (BYTE *) NULL, 0, BIND_SSPI_PACKAGEREQ );
        if ( hr != NOERROR ) {
            goto ExitWithCleanup;
        }

    hr = lber.HrEndWriteSequence();
    if ( hr != NOERROR ) {
        goto ExitWithCleanup;
    }

    hr = lber.HrEndWriteSequence();
    if ( hr != NOERROR ) {
        goto ExitWithCleanup;
    }

    //
    // Send the packet and get the response.
    //

    AddToPendingList( LdapRequest, Connection );

    LdapErr = LdapSend( Connection, &lber );

    if ( LdapErr != LDAP_SUCCESS ) {

        DecrementPendingList( LdapRequest, Connection );
        goto ExitWithCleanup;
    }

    LdapErr = LdapWaitForResponseFromServer( Connection,
                                             LdapRequest,
                                             LDAP_BIND_TIME_LIMIT_DEFAULT,
                                             FALSE,
                                             &LdapMessage,
                                             TRUE     // Disable autorec during bind
                                             );

    if ( ( LdapErr != LDAP_SUCCESS ) && (LdapMessage == NULL) ) {
        goto ExitWithCleanup;
    }

    if ( LdapMessage == NULL ) {
        IF_DEBUG(SERVERDOWN) {
            LdapPrint2( "ldapGetSicilyList thread 0x%x has connection 0x%x as down.\n",
                            GetCurrentThreadId(),
                            Connection );
        }
        LdapErr = LDAP_SERVER_DOWN;
        goto ExitWithCleanup;
    }

    LdapErr = LdapMessage->lm_returncode;

    if ( LdapErr != LDAP_SUCCESS ) {
        goto ExitWithCleanup;
    }

    //
    // Copy out the package list.
    //

    ReplyBer = (CLdapBer*) LdapMessage->lm_ber;

    if (ReplyBer == NULL) {

        hr = LDAP_LOCAL_ERROR;
        goto ExitWithCleanup;
    }

    hr = ReplyBer->HrGetBinaryValue( PackageList,
                                     Length,
                                     BER_OCTETSTRING,
                                     pResponseLen );

    if ( hr != NOERROR ) {
        LdapErr = LDAP_DECODING_ERROR;
        goto ExitWithCleanup;
    }

    LdapErr = LDAP_SUCCESS;

ExitWithCleanup:

    if ( LdapMessage != NULL ) {
        ldap_msgfree( LdapMessage );
    }

    CloseLdapRequest( LdapRequest );

    DereferenceLdapRequest( LdapRequest );

    return LdapErr;

}

ULONG
LdapTryAllMsnAuthentication(
    PLDAP_CONN Connection,
    PWCHAR BindCred
    )
{

    ULONG LdapErr, ResponseLen, PackageCount = 0, Len = 0;
    PBYTE PackageList = NULL;
    PWCHAR CurrentPackage = NULL, wPackageList = NULL;
    PSecPkgInfoW SecurityPackage;

    //
    // Negotiate the supported sicily packages.
    //


   PackageList = (PBYTE) ldapMalloc( GENERIC_SECURITY_SIZE,
                                     LDAP_SECURITY_SIGNATURE );

   if ( PackageList == NULL ) {
       return LDAP_NO_MEMORY;
   }

   LdapErr = LdapGetSicilyPackageList( Connection,
                                       PackageList,
                                       GENERIC_SECURITY_SIZE,
                                       &ResponseLen );

   if ( LdapErr != LDAP_SUCCESS ) {
       goto ExitWithCleanup;
   }

   //
   // convert the ANSI packagelist into Unicode
   //

   LdapErr = ToUnicodeWithAlloc ( (PCHAR) PackageList,
                                  ResponseLen,
                                  &wPackageList,
                                  LDAP_UNICODE_SIGNATURE,
                                  LANG_ACP
                                  );

   if ( LdapErr != LDAP_SUCCESS ) {
       goto ExitWithCleanup;
   }

   //
   // Convert the semicolon separators to NULLs.
   //

   CurrentPackage = wPackageList;

   while ( Len < ResponseLen ) {

       if ( *CurrentPackage == L';' ) {
           *CurrentPackage = L'\0';
           PackageCount++;
       }

       Len++;
       CurrentPackage++;
   }

   //
   // Don't forget to include the last package.
   //

   *CurrentPackage = L'\0';
   PackageCount++;

   CurrentPackage = wPackageList;

   //
   // Try to authenticate using each package until success.
   //

   LdapErr = LDAP_AUTH_METHOD_NOT_SUPPORTED;

   while ( ( LdapErr != LDAP_SUCCESS ) &&
           ( PackageCount > 0 ) ) {

       SecurityPackage = NULL;

       if ( ldapWStringsIdentical(
                           (const PWCHAR)CurrentPackage,
                           -1,
                           L"MSN",
                           -1 )) {

          SecurityPackage = SspiPackageSicily;

      } else if ( ldapWStringsIdentical(
                                 (const PWCHAR)CurrentPackage,
                                  -1,
                                  L"DPA",
                                  -1 )) {

          SecurityPackage = SspiPackageDpa;

      } else if ( ldapWStringsIdentical(
                                 (const PWCHAR)CurrentPackage,
                                  -1,
                                  L"NTLM",
                                  -1 )) {

          SecurityPackage = SspiPackageNtlm;

      }

      if ( SecurityPackage ) {

          LdapErr = LdapSspiBind( Connection,
                                  SecurityPackage,
                                  LDAP_AUTH_SICILY,
                                  0,
                                  CurrentPackage,
                                  NULL,
                                  BindCred );

          if ( ( LdapErr == LDAP_INVALID_CREDENTIALS ) &&
               ( SecurityPackage != SspiPackageNtlm ) ) {

              //
              //  if we've prompted the user for credentials and it failed
              //  with an invalid password, we fail the call since we
              //  prompted the user for a password.
              //

              goto ExitWithCleanup;
          }
      }

      //
      // Find the next package.
      //

      while ( *CurrentPackage != '\0' ) {
          CurrentPackage++;
      }

      CurrentPackage++;
      PackageCount--;

   }

ExitWithCleanup:

    ldapFree( PackageList, LDAP_SECURITY_SIGNATURE );
    ldapFree( wPackageList, LDAP_UNICODE_SIGNATURE );

    return LdapErr;
}

ULONG
LdapSetupSslSession (
    PLDAP_CONN Connection
    )
//
//  This must return a Win32 error code.
//
{

    ULONG err;
    PSECURESTREAM pSecureStream;

    (VOID) LdapInitSsl();

    if ( SspiPackageSslPct == NULL ) {
       return ERROR_NO_SUCH_PACKAGE;
    }

    ACQUIRE_LOCK( &Connection->StateLock );

    //
    // You can not negotiate an SSL connection while
    // a bind is in progress b/c the two procedures
    // use some common state variables...
    //

    if ( Connection->BindInProgress ) {
        RELEASE_LOCK( &Connection->StateLock );
        return ERROR_LOGON_SESSION_COLLISION;
    }

    //
    // You can't negotiate a secure connection more than once.
    //

    if ( Connection->SecureStream ) {
        RELEASE_LOCK( &Connection->StateLock );
        return ERROR_LOGON_SESSION_COLLISION;
    }

    //
    // You can't have both sealing/signing and SSL at the same time.
    //

    if ( Connection->UserSignDataChoice || Connection->UserSealDataChoice || Connection->CurrentSignStatus || Connection->CurrentSealStatus) {
        RELEASE_LOCK( &Connection->StateLock );
        return LDAP_UNWILLING_TO_PERFORM;
    }

    Connection->BindInProgress = TRUE;
    Connection->SslSetupInProgress = TRUE;

    LdapClearSspiState( Connection );

    RELEASE_LOCK( &Connection->StateLock );

    //
    // Set up the connection via the steam management object.
    //

    ASSERT( SslFunctionTableW != NULL );

    pSecureStream = new CryptStream( Connection, SslFunctionTableW, TRUE );

    if ( pSecureStream == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    err = pSecureStream->NegotiateSecureConnection( SspiPackageSslPct );

    if ( err != 0 ) {
        delete pSecureStream;
        Connection->SecureStream = NULL;
    } else {
        Connection->SecureStream = (PVOID)pSecureStream;
    }

    Connection->BindInProgress = FALSE;
    Connection->SslSetupInProgress = FALSE;

    return err;

}

ULONG
LdapMakeCredsWide(
    PCHAR pAnsiAuthIdent,
    PCHAR *ppWideAuthIdent,
    BOOLEAN FromWide
)
/*+++

Description:

    Take a SEC_WINNT_AUTH_IDENTITY_A and return
    a SEC_WINNT_AUTH_IDENTITY_W.  We do this because
    the NT SSPI providers only support unicode.  The
    caller must free the SEC_WINNT_AUTH_IDENTITY_W.

    Note that the lengths in this structure are the
    number the wchars in the string, but the strings
    still must be NULL terminated.

 ---*/
{

    PSEC_WINNT_AUTH_IDENTITY_A pIncoming;
    PSEC_WINNT_AUTH_IDENTITY_W pOutgoing;
    ULONG dwBytesNeeded, dwWcharsWritten;
    PWCHAR outputBuff;

    pIncoming = ( PSEC_WINNT_AUTH_IDENTITY_A ) pAnsiAuthIdent;

    //
    // Compute the necessary target buffer size.
    //
    // Account for possible alignment byte needed.
    //

    dwBytesNeeded = sizeof( SEC_WINNT_AUTH_IDENTITY_W ) + 1;

    dwBytesNeeded += ( ( pIncoming->UserLength + 1 ) * sizeof( WCHAR ) );
    dwBytesNeeded += ( ( pIncoming->DomainLength + 1 ) * sizeof( WCHAR ) );
    dwBytesNeeded += ( ( pIncoming->PasswordLength + 1 ) * sizeof( WCHAR ) );

    // We'll need up to DES_BLOCKLEN-1 bytes of padding for RtlEncryptMemory
    // (plus 1 byte for alignment if that is a odd number)
    dwBytesNeeded += (DES_BLOCKLEN-1);
    dwBytesNeeded += ((((DES_BLOCKLEN-1)%2) == 0) ? 0 : 1);

    //
    // Allocate the block.
    //

    pOutgoing = ( PSEC_WINNT_AUTH_IDENTITY_W )
                ldapMalloc( dwBytesNeeded, LDAP_SECURITY_SIGNATURE );

    if ( !pOutgoing ) {
        return LDAP_NO_MEMORY;
    }

    //
    // Set up the wide pointers, pre-marshalled.
    //

    outputBuff = (PWCHAR) ( ( ( PBYTE ) pOutgoing ) +
                                 sizeof( SEC_WINNT_AUTH_IDENTITY_W ) );

    // ensure alignment is correct for PUSHORT

    outputBuff = (PWCHAR)(PCHAR) ( (((ULONG_PTR) outputBuff) + 1) & ~1 );

    //
    // Convert the parameters to unicode.
    //

    if ( pIncoming->User ) {


        if ( pIncoming->UserLength ) {

            if (FromWide == TRUE) {

                dwWcharsWritten = pIncoming->UserLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->User,
                            dwWcharsWritten * sizeof(WCHAR) );
            } else {

                dwWcharsWritten = MultiByteToWideChar( CP_ACP,
                                                       0,
                                                       (const char *)pIncoming->User,
                                                       pIncoming->UserLength,
                                                       outputBuff,
                                                       ( pIncoming->UserLength * sizeof( WCHAR ) ) );
            }
        } else {

            dwWcharsWritten = 0;
        }

        pOutgoing->UserLength = dwWcharsWritten;
        pOutgoing->User = (unsigned short *)outputBuff;

        outputBuff += dwWcharsWritten;
        *(outputBuff++) = L'\0';

    } else {

        pOutgoing->User = NULL;
        pOutgoing->UserLength = 0;
    }

    if ( pIncoming->Domain ) {

        if ( pIncoming->DomainLength ) {

            if (FromWide == TRUE) {

                dwWcharsWritten = pIncoming->DomainLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->Domain,
                            dwWcharsWritten * sizeof(WCHAR) );
            } else {

                dwWcharsWritten = MultiByteToWideChar( CP_ACP,
                                                       0,
                                                       (const char *)pIncoming->Domain,
                                                       pIncoming->DomainLength,
                                                       outputBuff,
                                                       ( pIncoming->DomainLength * sizeof( WCHAR ) ) );
            }
        } else {

            dwWcharsWritten = 0;
        }

        pOutgoing->DomainLength = dwWcharsWritten;
        pOutgoing->Domain = (unsigned short *)outputBuff;

        outputBuff += dwWcharsWritten;
        *(outputBuff++) = L'\0';

    } else {

        pOutgoing->Domain = NULL;
        pOutgoing->DomainLength = 0;
    }

    if ( pIncoming->Password ) {

        if ( pIncoming->PasswordLength ) {

            if (FromWide == TRUE) {

                dwWcharsWritten = pIncoming->PasswordLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->Password,
                            dwWcharsWritten * sizeof(WCHAR) );
            } else {

                dwWcharsWritten = MultiByteToWideChar( CP_ACP,
                                                      0,
                                                      (const char *)pIncoming->Password,
                                                      pIncoming->PasswordLength,
                                                      outputBuff,
                                                      ( pIncoming->PasswordLength * sizeof( WCHAR ) ) );
            }
        } else {

            dwWcharsWritten = 0;
        }

        pOutgoing->PasswordLength = dwWcharsWritten;
        pOutgoing->Password = (unsigned short *)outputBuff;

        outputBuff += dwWcharsWritten;
        *(outputBuff++) = L'\0';

        // advance the buffer ptr by however many padding bytes we added.
        // outputBuff is a WCHAR ptr, so we have to convert from bytes to WCHARs
        outputBuff += (((DES_BLOCKLEN-1) + ((((DES_BLOCKLEN-1)%2) == 0) ? 0 : 1)) / sizeof (WCHAR));

    } else {

        pOutgoing->Password = NULL;
        pOutgoing->PasswordLength = 0;
    }

    //
    // Stuff in the flags and return.
    //

    pOutgoing->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    *ppWideAuthIdent = ( PCHAR ) pOutgoing;

    return LDAP_SUCCESS;
}

ULONG
LdapMakeCredsThin(
    PCHAR pWideAuthIdent,
    PCHAR *ppAnsiAuthIdent,
    BOOLEAN FromWide
)
/*+++

Description:

    Take a SEC_WINNT_AUTH_IDENTITY_W and return
    a SEC_WINNT_AUTH_IDENTITY_A.  We do this because
    the Win9x SSPI providers only support ansi.  The
    caller must free the SEC_WINNT_AUTH_IDENTITY_A.

    Note that the lengths in this structure are the
    number the chars in the string, but the strings
    still must be NULL terminated.

 ---*/
{

    PSEC_WINNT_AUTH_IDENTITY_W pIncoming;
    PSEC_WINNT_AUTH_IDENTITY_A pOutgoing;
    ULONG dwBytesNeeded, dwCharsWritten;
    PUCHAR outputBuff;

    pIncoming = ( PSEC_WINNT_AUTH_IDENTITY_W ) pWideAuthIdent;

    //
    // Compute the necessary target buffer size.
    //
    // Account for possible alignment byte needed.
    //

    dwBytesNeeded = sizeof( SEC_WINNT_AUTH_IDENTITY_A ) + 1;

    //
    //  We multiply by 2 so that we don't worry about long DBCS names.
    //

    dwBytesNeeded += ( pIncoming->UserLength + 1 ) * sizeof(WCHAR);
    dwBytesNeeded += ( pIncoming->DomainLength + 1 ) * sizeof(WCHAR);
    dwBytesNeeded += ( pIncoming->PasswordLength + 1 ) * sizeof(WCHAR);

    // We'll need up to DES_BLOCKLEN-1 bytes of padding for RtlEncryptMemory
    // (plus 1 byte for alignment if that is a odd number)
    dwBytesNeeded += (DES_BLOCKLEN-1);
    dwBytesNeeded += ((((DES_BLOCKLEN-1)%2) == 0) ? 0 : 1);

    //
    // Allocate the block.
    //

    pOutgoing = ( PSEC_WINNT_AUTH_IDENTITY_A )
                ldapMalloc( dwBytesNeeded, LDAP_SECURITY_SIGNATURE );

    if ( !pOutgoing ) {
        return LDAP_NO_MEMORY;
    }

    //
    // Set up the wide pointers, pre-marshalled.
    //

    outputBuff = (PUCHAR) ( ( ( PBYTE ) pOutgoing ) +
                                 sizeof( SEC_WINNT_AUTH_IDENTITY_A ) );

    //
    // Convert the parameters from unicode.
    //

    if ( pIncoming->User ) {

        if ( pIncoming->UserLength ) {

            if (FromWide == FALSE) {

                dwCharsWritten = pIncoming->UserLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->User,
                            dwCharsWritten );
            } else {

                dwCharsWritten = WideCharToMultiByte(  CP_ACP,
                                                       0,
                                                       (LPCWSTR)pIncoming->User,
                                                       pIncoming->UserLength,
                                                       (PCHAR) outputBuff,
                                                       pIncoming->UserLength + 1,
                                                       NULL,
                                                       NULL );
            }
        } else {

            dwCharsWritten = 0;
        }

        pOutgoing->UserLength = dwCharsWritten;
        pOutgoing->User = outputBuff;

        outputBuff += dwCharsWritten;
        *(outputBuff++) = '\0';

    } else {

        pOutgoing->User = NULL;
        pOutgoing->UserLength = 0;
    }

    if ( pIncoming->Domain ) {

        if ( pIncoming->DomainLength ) {

            if (FromWide == FALSE) {

                dwCharsWritten = pIncoming->DomainLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->Domain,
                            dwCharsWritten );
            } else {

                dwCharsWritten =  WideCharToMultiByte(  CP_ACP,
                                                       0,
                                                       (LPCWSTR)pIncoming->Domain,
                                                       pIncoming->DomainLength,
                                                       (PCHAR) outputBuff,
                                                       pIncoming->DomainLength + 1,
                                                       NULL,
                                                       NULL );
            }
        } else {

            dwCharsWritten = 0;
        }

        pOutgoing->DomainLength = dwCharsWritten;
        pOutgoing->Domain = outputBuff;

        outputBuff += dwCharsWritten;
        *(outputBuff++) = '\0';

    } else {

        pOutgoing->Domain = NULL;
        pOutgoing->DomainLength = 0;
    }

    if ( pIncoming->Password ) {

        if ( pIncoming->PasswordLength ) {

            if (FromWide == FALSE) {

                dwCharsWritten = pIncoming->PasswordLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->Password,
                            dwCharsWritten );
            } else {

                dwCharsWritten =  WideCharToMultiByte( CP_ACP,
                                                       0,
                                                       (LPCWSTR)pIncoming->Password,
                                                       pIncoming->PasswordLength,
                                                       (PCHAR) outputBuff,
                                                       pIncoming->PasswordLength + 1,
                                                       NULL,
                                                       NULL );
            }
        } else {

            dwCharsWritten = 0;
        }

        pOutgoing->PasswordLength = dwCharsWritten;
        pOutgoing->Password = outputBuff;

        outputBuff += dwCharsWritten;
        *(outputBuff++) = '\0';

        // advance the buffer ptr by however many padding bytes we added.
        // outputBuff is a WCHAR ptr, so we have to convert from bytes to WCHARs
        outputBuff += (((DES_BLOCKLEN-1) + ((((DES_BLOCKLEN-1)%2) == 0) ? 0 : 1)) / sizeof (WCHAR));

    } else {

        pOutgoing->Password = NULL;
        pOutgoing->PasswordLength = 0;
    }

    //
    // Stuff in the flags and return.
    //

    pOutgoing->Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

    *ppAnsiAuthIdent = ( PCHAR ) pOutgoing;

    return LDAP_SUCCESS;
}



ULONG
LdapMakeEXCredsWide(
    PCHAR pAnsiAuthIdent,
    PCHAR *ppWideAuthIdent,
    BOOLEAN FromWide
)
/*+++

Description:

    Take a SEC_WINNT_AUTH_IDENTITY_EXA and return
    a SEC_WINNT_AUTH_IDENTITY_EXW.  We do this because
    the NT SSPI providers only support unicode.  The
    caller must free the SEC_WINNT_AUTH_IDENTITY_W.

    Note that the lengths in this structure are the
    number the wchars in the string, but the strings
    still must be NULL terminated.

 ---*/
{

    PSEC_WINNT_AUTH_IDENTITY_EXA pIncoming;
    PSEC_WINNT_AUTH_IDENTITY_EXW pOutgoing;
    ULONG dwBytesNeeded, dwWcharsWritten;
    PWCHAR outputBuff;

    pIncoming = ( PSEC_WINNT_AUTH_IDENTITY_EXA ) pAnsiAuthIdent;

    //
    // Compute the necessary target buffer size.
    //
    // Account for possible alignment byte needed.
    //

    dwBytesNeeded = sizeof( SEC_WINNT_AUTH_IDENTITY_EXW ) + 1;

    dwBytesNeeded += ( ( pIncoming->UserLength + 1 ) * sizeof( WCHAR ) );
    dwBytesNeeded += ( ( pIncoming->DomainLength + 1 ) * sizeof( WCHAR ) );
    dwBytesNeeded += ( ( pIncoming->PasswordLength + 1 ) * sizeof( WCHAR ) );
    dwBytesNeeded += ( ( pIncoming->PackageListLength + 1 ) * sizeof( WCHAR ) );

    // We'll need up to DES_BLOCKLEN-1 bytes of padding for RtlEncryptMemory
    // (plus 1 byte for alignment if that is a odd number)
    dwBytesNeeded += (DES_BLOCKLEN-1);
    dwBytesNeeded += ((((DES_BLOCKLEN-1)%2) == 0) ? 0 : 1);

    //
    // Allocate the block.
    //

    pOutgoing = ( PSEC_WINNT_AUTH_IDENTITY_EXW )
                ldapMalloc( dwBytesNeeded, LDAP_SECURITY_SIGNATURE );

    if ( !pOutgoing ) {
        return LDAP_NO_MEMORY;
    }

    //
    // Set up the wide pointers, pre-marshalled.
    //

    outputBuff = (PWCHAR) ( ( ( PBYTE ) pOutgoing ) +
                                 sizeof( SEC_WINNT_AUTH_IDENTITY_EXW ) );

    // ensure alignment is correct for PUSHORT

    outputBuff = (PWCHAR)(PCHAR) ( (((ULONG_PTR) outputBuff) + 1) & ~1 );

    //
    // Convert the parameters to unicode.
    //

    if ( pIncoming->User ) {


        if ( pIncoming->UserLength ) {

            if (FromWide == TRUE) {

                dwWcharsWritten = pIncoming->UserLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->User,
                            dwWcharsWritten * sizeof(WCHAR) );
            } else {

                dwWcharsWritten = MultiByteToWideChar( CP_ACP,
                                                       0,
                                                       (const char *)pIncoming->User,
                                                       pIncoming->UserLength,
                                                       outputBuff,
                                                       ( pIncoming->UserLength * sizeof( WCHAR ) ) );
            }
        } else {

            dwWcharsWritten = 0;
        }

        pOutgoing->UserLength = dwWcharsWritten;
        pOutgoing->User = (unsigned short *)outputBuff;

        outputBuff += dwWcharsWritten;
        *(outputBuff++) = L'\0';

    } else {

        pOutgoing->User = NULL;
        pOutgoing->UserLength = 0;
    }

    if ( pIncoming->Domain ) {

        if ( pIncoming->DomainLength ) {

            if (FromWide == TRUE) {

                dwWcharsWritten = pIncoming->DomainLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->Domain,
                            dwWcharsWritten * sizeof(WCHAR) );
            } else {

                dwWcharsWritten = MultiByteToWideChar( CP_ACP,
                                                       0,
                                                       (const char *)pIncoming->Domain,
                                                       pIncoming->DomainLength,
                                                       outputBuff,
                                                       ( pIncoming->DomainLength * sizeof( WCHAR ) ) );
            }
        } else {

            dwWcharsWritten = 0;
        }

        pOutgoing->DomainLength = dwWcharsWritten;
        pOutgoing->Domain = (unsigned short *)outputBuff;

        outputBuff += dwWcharsWritten;
        *(outputBuff++) = L'\0';

    } else {

        pOutgoing->Domain = NULL;
        pOutgoing->DomainLength = 0;
    }

    if ( pIncoming->Password ) {

        if ( pIncoming->PasswordLength ) {

            if (FromWide == TRUE) {

                dwWcharsWritten = pIncoming->PasswordLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->Password,
                            dwWcharsWritten * sizeof(WCHAR) );
            } else {

                dwWcharsWritten = MultiByteToWideChar( CP_ACP,
                                                      0,
                                                      (const char *)pIncoming->Password,
                                                      pIncoming->PasswordLength,
                                                      outputBuff,
                                                      ( pIncoming->PasswordLength * sizeof( WCHAR ) ) );
            }
        } else {

            dwWcharsWritten = 0;
        }

        pOutgoing->PasswordLength = dwWcharsWritten;
        pOutgoing->Password = (unsigned short *)outputBuff;

        outputBuff += dwWcharsWritten;
        *(outputBuff++) = L'\0';

        // advance the buffer ptr by however many padding bytes we added.
        // outputBuff is a WCHAR ptr, so we have to convert from bytes to WCHARs
        outputBuff += (((DES_BLOCKLEN-1) + ((((DES_BLOCKLEN-1)%2) == 0) ? 0 : 1)) / sizeof (WCHAR));


    } else {

        pOutgoing->Password = NULL;
        pOutgoing->PasswordLength = 0;
    }

    if ( pIncoming->PackageList ) {

        if ( pIncoming->PackageListLength ) {

            if (FromWide == TRUE) {

                dwWcharsWritten = pIncoming->PackageListLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->PackageList,
                            dwWcharsWritten * sizeof(WCHAR) );
            } else {

                dwWcharsWritten = MultiByteToWideChar( CP_ACP,
                                                      0,
                                                      (const char *)pIncoming->PackageList,
                                                      pIncoming->PackageListLength,
                                                      outputBuff,
                                                      ( pIncoming->PackageListLength * sizeof( WCHAR ) ) );
            }
        } else {

            dwWcharsWritten = 0;
        }

        pOutgoing->PackageListLength = dwWcharsWritten;
        pOutgoing->PackageList = (unsigned short *)outputBuff;

        outputBuff += dwWcharsWritten;
        *(outputBuff++) = L'\0';

    } else {

        pOutgoing->PackageList = NULL;
        pOutgoing->PackageListLength = 0;
    }

    //
    // Stuff in the flags, the version and the length.
    //

    pOutgoing->Version = pIncoming->Version;
    pOutgoing->Length  = sizeof( SEC_WINNT_AUTH_IDENTITY_EXW );
    pOutgoing->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    *ppWideAuthIdent = ( PCHAR ) pOutgoing;

    return LDAP_SUCCESS;
}


ULONG
LdapMakeEXCredsThin(
    PCHAR pWideAuthIdent,
    PCHAR *ppAnsiAuthIdent,
    BOOLEAN FromWide
)
/*+++

Description:

    Take a SEC_WINNT_AUTH_IDENTITY_EXW and return
    a SEC_WINNT_AUTH_IDENTITY_EXA.  We do this because
    the Win9x SSPI providers only support ansi.  The
    caller must free the SEC_WINNT_AUTH_IDENTITY_EXA.

    Note that the lengths in this structure are the
    number the chars in the string, but the strings
    still must be NULL terminated.

 ---*/
{

    PSEC_WINNT_AUTH_IDENTITY_EXW pIncoming;
    PSEC_WINNT_AUTH_IDENTITY_EXA pOutgoing;
    ULONG dwBytesNeeded, dwCharsWritten;
    PUCHAR outputBuff;

    pIncoming = ( PSEC_WINNT_AUTH_IDENTITY_EXW ) pWideAuthIdent;

    //
    // Compute the necessary target buffer size.
    //
    // Account for possible alignment byte needed.
    //

    dwBytesNeeded = sizeof( SEC_WINNT_AUTH_IDENTITY_EXA ) + 1;

    //
    //  We multiply by 2 so that we don't worry about long DBCS names.
    //

    dwBytesNeeded += ( pIncoming->UserLength + 1 ) * sizeof(WCHAR);
    dwBytesNeeded += ( pIncoming->DomainLength + 1 ) * sizeof(WCHAR);
    dwBytesNeeded += ( pIncoming->PasswordLength + 1 ) * sizeof(WCHAR);
    dwBytesNeeded += ( pIncoming->PackageListLength + 1 ) * sizeof(WCHAR);

    // We'll need up to DES_BLOCKLEN-1 bytes of padding for RtlEncryptMemory
    // (plus 1 byte for alignment if that is a odd number)
    dwBytesNeeded += (DES_BLOCKLEN-1);
    dwBytesNeeded += ((((DES_BLOCKLEN-1)%2) == 0) ? 0 : 1);


    //
    // Allocate the block.
    //

    pOutgoing = ( PSEC_WINNT_AUTH_IDENTITY_EXA )
                ldapMalloc( dwBytesNeeded, LDAP_SECURITY_SIGNATURE );

    if ( !pOutgoing ) {
        return LDAP_NO_MEMORY;
    }

    //
    // Set up the wide pointers, pre-marshalled.
    //

    outputBuff = (PUCHAR) ( ( ( PBYTE ) pOutgoing ) +
                                 sizeof( SEC_WINNT_AUTH_IDENTITY_EXA ) );

    //
    // Convert the parameters from unicode.
    //

    if ( pIncoming->User ) {

        if ( pIncoming->UserLength ) {

            if (FromWide == FALSE) {

                dwCharsWritten = pIncoming->UserLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->User,
                            dwCharsWritten );
            } else {

                dwCharsWritten = WideCharToMultiByte(  CP_ACP,
                                                       0,
                                                       (LPCWSTR)pIncoming->User,
                                                       pIncoming->UserLength,
                                                       (PCHAR) outputBuff,
                                                       pIncoming->UserLength + 1,
                                                       NULL,
                                                       NULL );
            }
        } else {

            dwCharsWritten = 0;
        }

        pOutgoing->UserLength = dwCharsWritten;
        pOutgoing->User = outputBuff;

        outputBuff += dwCharsWritten;
        *(outputBuff++) = '\0';

    } else {

        pOutgoing->User = NULL;
        pOutgoing->UserLength = 0;
    }

    if ( pIncoming->Domain ) {

        if ( pIncoming->DomainLength ) {

            if (FromWide == FALSE) {

                dwCharsWritten = pIncoming->DomainLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->Domain,
                            dwCharsWritten );
            } else {

                dwCharsWritten =  WideCharToMultiByte(  CP_ACP,
                                                       0,
                                                       (LPCWSTR)pIncoming->Domain,
                                                       pIncoming->DomainLength,
                                                       (PCHAR) outputBuff,
                                                       pIncoming->DomainLength + 1,
                                                       NULL,
                                                       NULL );
            }
        } else {

            dwCharsWritten = 0;
        }

        pOutgoing->DomainLength = dwCharsWritten;
        pOutgoing->Domain = outputBuff;

        outputBuff += dwCharsWritten;
        *(outputBuff++) = '\0';

    } else {

        pOutgoing->Domain = NULL;
        pOutgoing->DomainLength = 0;
    }

    if ( pIncoming->Password ) {

        if ( pIncoming->PasswordLength ) {

            if (FromWide == FALSE) {

                dwCharsWritten = pIncoming->PasswordLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->Password,
                            dwCharsWritten );
            } else {

                dwCharsWritten =  WideCharToMultiByte( CP_ACP,
                                                       0,
                                                       (LPCWSTR)pIncoming->Password,
                                                       pIncoming->PasswordLength,
                                                       (PCHAR) outputBuff,
                                                       pIncoming->PasswordLength + 1,
                                                       NULL,
                                                       NULL );
            }
        } else {

            dwCharsWritten = 0;
        }

        pOutgoing->PasswordLength = dwCharsWritten;
        pOutgoing->Password = outputBuff;

        outputBuff += dwCharsWritten;
        *(outputBuff++) = '\0';

        // advance the buffer ptr by however many padding bytes we added.
        // outputBuff is a WCHAR ptr, so we have to convert from bytes to WCHARs
        outputBuff += (((DES_BLOCKLEN-1) + ((((DES_BLOCKLEN-1)%2) == 0) ? 0 : 1)) / sizeof (WCHAR));

    } else {

        pOutgoing->Password = NULL;
        pOutgoing->PasswordLength = 0;
    }


    if ( pIncoming->PackageList ) {

        if ( pIncoming->PackageListLength ) {

            if (FromWide == FALSE) {

                dwCharsWritten = pIncoming->PackageListLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->PackageList,
                            dwCharsWritten );
            } else {

                dwCharsWritten =  WideCharToMultiByte( CP_ACP,
                                                       0,
                                                       (LPCWSTR)pIncoming->PackageList,
                                                       pIncoming->PackageListLength,
                                                       (PCHAR) outputBuff,
                                                       pIncoming->PackageListLength + 1,
                                                       NULL,
                                                       NULL );
            }
        } else {

            dwCharsWritten = 0;
        }

        pOutgoing->PackageListLength = dwCharsWritten;
        pOutgoing->PackageList = outputBuff;

        outputBuff += dwCharsWritten;
        *(outputBuff++) = '\0';

    } else {

        pOutgoing->PackageList = NULL;
        pOutgoing->PackageListLength = 0;
    }

    //
    // Stuff in the flags, the version and the length
    //

    pOutgoing->Version = pIncoming->Version;
    pOutgoing->Length  = sizeof( SEC_WINNT_AUTH_IDENTITY_EXA );
    pOutgoing->Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

    *ppAnsiAuthIdent = ( PCHAR ) pOutgoing;

    return LDAP_SUCCESS;
}




ULONG
ProcessAlternateCreds (
      PLDAP_CONN Connection,
      PSecPkgInfoW Package,
      PWCHAR Credentials,
      PWCHAR *newcreds
      )
{
      ULONG err;
      BOOLEAN toWide;

      ASSERT( Credentials != NULL );


      if ((Package == SspiPackageSicily) ||
           (Package == SspiPackageDpa)) {

          toWide = FALSE;


       } else {

           //
           //  Win9x takes ANSI only
           //

           toWide = (BOOLEAN) (GlobalWin9x ? FALSE : TRUE);

       }

       ASSERT( sizeof( SEC_WINNT_AUTH_IDENTITY_A ) ==
               sizeof( SEC_WINNT_AUTH_IDENTITY_W ) );

       //
       // We have to detect whether the user has passed us an old style
       // SEC_WINNT_AUTH_IDENTITY structure or a newer style
       // SEC_WINNT_AUTH_IDENTITY_EX
       //
       // We examine the first field of the incoming structure. If it is a
       // pointer to a string or NULL, then it is an old style structure. New
       // style structures have a small non-zero verion in this field
       //

       PSEC_WINNT_AUTH_IDENTITY_EXA pIncomingEX = (PSEC_WINNT_AUTH_IDENTITY_EXA) Credentials;


       if ((pIncomingEX->Version > 0xFFFF)||(pIncomingEX->Version == 0)) {

          //
          // If we are using the older style structure
          //

          IF_DEBUG(TRACE1) {

             LdapPrint0(" The older style SEC_WINNT_AUTH_IDENTITY was detected\n");
          }


       PSEC_WINNT_AUTH_IDENTITY_A pIncoming = (PSEC_WINNT_AUTH_IDENTITY_A) Credentials;

       //
       //  if neither flag (or both) was specified, error out with invalid parameter
       //

       if ( (( pIncoming->Flags &
             ( SEC_WINNT_AUTH_IDENTITY_ANSI | SEC_WINNT_AUTH_IDENTITY_UNICODE))
             == 0 ) ||
            (( pIncoming->Flags &
             ( SEC_WINNT_AUTH_IDENTITY_ANSI | SEC_WINNT_AUTH_IDENTITY_UNICODE))
             == ( SEC_WINNT_AUTH_IDENTITY_ANSI | SEC_WINNT_AUTH_IDENTITY_UNICODE)) ) {

           IF_DEBUG( NETWORK_ERRORS ) {
               LdapPrint2( "LdapSspiBind Connection 0x%x had auth flags of 0x%x.\n",
                           Connection, pIncoming->Flags );
           }

           return LDAP_PARAM_ERROR;
       }

       //
       //  make a copy of the credentials to save on the connection for
       //  chasing referrals.
       //

       BOOLEAN fromWide = (BOOLEAN) ((pIncoming->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE) ?
                                       TRUE : FALSE);

       if (toWide == FALSE) {

          //
          // On Win9x, we convert from Unicode to ANSI
          //

           err = LdapMakeCredsThin( (PCHAR) pIncoming, (PCHAR *) newcreds, fromWide );

       } else {

          //
          // On NT, we convert from ANSI to Unicode
          //

           err = LdapMakeCredsWide( (PCHAR) pIncoming, (PCHAR *) newcreds, fromWide );
       }

           return err;


       } else {

          //
          // We are using the new style SEC_WINNT_AUTH_IDENTITY_EX structure
          //
          IF_DEBUG(TRACE1) {

          LdapPrint0(" The newer style SEC_WINNT_AUTH_IDENTITY_EX was detected\n");
          }
          //
          //  if neither flag (or both) was specified, error out with invalid parameter
          //

          if ( (( pIncomingEX->Flags &
                ( SEC_WINNT_AUTH_IDENTITY_ANSI | SEC_WINNT_AUTH_IDENTITY_UNICODE))
                == 0 ) ||
               (( pIncomingEX->Flags &
                ( SEC_WINNT_AUTH_IDENTITY_ANSI | SEC_WINNT_AUTH_IDENTITY_UNICODE))
                == ( SEC_WINNT_AUTH_IDENTITY_ANSI | SEC_WINNT_AUTH_IDENTITY_UNICODE)) ) {

              IF_DEBUG( NETWORK_ERRORS ) {
                  LdapPrint2( "LdapSspiBind Connection 0x%x had auth flags of 0x%x.\n",
                              Connection, pIncomingEX->Flags );
              }

              return LDAP_PARAM_ERROR;
          }

          //
          //  make a copy of the credentials to save on the connection for
          //  chasing referrals.
          //

          BOOLEAN fromWide = (BOOLEAN) ((pIncomingEX->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE) ?
                                          TRUE : FALSE);

          if (toWide == FALSE) {

              err = LdapMakeEXCredsThin( (PCHAR) pIncomingEX, (PCHAR *) newcreds, fromWide );

          } else {

              err = LdapMakeEXCredsWide( (PCHAR) pIncomingEX, (PCHAR *) newcreds, fromWide );
          }

          if (err != LDAP_SUCCESS) {

              return err;
          }
          ASSERT( newcreds != NULL );

          return err;

       }

}


int __cdecl ldap_sasl_bindA(
      LDAP  *ExternalHandle,
      const  PCHAR DistName,
      const  PCHAR  AuthMechanism,
      const  BERVAL   *cred,
      PLDAPControlA *ServerCtrls,
      PLDAPControlA *ClientCtrls,
      int *MessageNumber
     )
 {
     PLDAP_CONN Connection = NULL;
     ULONG err, rc = 0;
     PWCHAR wName = NULL, wMechanism = NULL;

     Connection = GetConnectionPointer(ExternalHandle);

     if (!Connection || !DistName || !AuthMechanism || !cred || !MessageNumber) {
         err = LDAP_PARAM_ERROR;
         goto error;
     }

     err = ToUnicodeWithAlloc( DistName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP);

     if (err != LDAP_SUCCESS) {

         SetConnectionError( Connection, err, NULL );
         err = (ULONG) -1;
         goto error;
     }

     err = ToUnicodeWithAlloc( AuthMechanism, -1, &wMechanism, LDAP_UNICODE_SIGNATURE, LANG_ACP );

     if (err != LDAP_SUCCESS) {

         SetConnectionError( Connection, err, NULL );
         err = (ULONG) -1;
         goto error;
     }

     rc = LdapExchangeOpaqueToken(Connection,
                             LDAP_AUTH_SASL,        // auth mechanism
                             wMechanism,            // oid
                             wName,                 // username
                             cred->bv_val,          // Credentials
                             cred->bv_len,          // Credential length
                             NULL,                  // return data
                             NULL,                  // return data in berval form
                             (PLDAPControlW *)ServerCtrls,           // server controls
                             (PLDAPControlW *)ClientCtrls,           // client controls
                             (PULONG) MessageNumber,
                             TRUE,                  // Send only
                             FALSE,                 // controls are not unicode
                             NULL                   // was message sent?
                             );

error:
    if (wName)
         ldapFree( wName, LDAP_UNICODE_SIGNATURE );

     if (wMechanism)
         ldapFree( wMechanism, LDAP_UNICODE_SIGNATURE );

     if (Connection)
         DereferenceLdapConnection( Connection );

     return rc;


 }



int __cdecl
ldap_sasl_bindW(
         LDAP  *ExternalHandle,
         const PWCHAR DistName,
         const PWCHAR AuthMechanism,
         const BERVAL   *cred,
         PLDAPControlW *ServerCtrls,
         PLDAPControlW *ClientCtrls,
         int *MessageNumber
         )
 {
     PLDAP_CONN Connection = NULL;
     ULONG rc = 0;

     Connection = GetConnectionPointer(ExternalHandle);

     if (!Connection || !DistName || !AuthMechanism || !cred || !MessageNumber) {
         rc = LDAP_PARAM_ERROR;
         goto error;
     }

     rc = LdapExchangeOpaqueToken(Connection,
                             LDAP_AUTH_SASL,        // auth mechanism
                             AuthMechanism,         // oid
                             DistName,              // username
                             cred->bv_val,          // Credentials
                             cred->bv_len,          // Credential length
                             NULL,                  // return data
                             NULL,                  // return data in berval form
                             ServerCtrls,           // server controls
                             ClientCtrls,           // client controls
                             (PULONG )MessageNumber,
                             TRUE,                  // Send only
                             TRUE,                  // Controls are unicode
                             NULL                   // was message sent?                             
                             );

error:
     if (Connection)
         DereferenceLdapConnection( Connection );

    return rc;
 }


int __cdecl
ldap_sasl_bind_sA(
          LDAP  *ExternalHandle,
          const PCHAR DistName,
          const PCHAR AuthMechanism,
          const BERVAL   *cred,
          PLDAPControlA *ServerCtrls,
          PLDAPControlA *ClientCtrls,
          PBERVAL *ServerData
         )
 {

     PLDAP_CONN Connection = NULL;
     ULONG rc = 0, err;
     PWCHAR wName = NULL, wMechanism = NULL;

     Connection = GetConnectionPointer(ExternalHandle);

     if (!Connection || !DistName ||
          !AuthMechanism || !cred ) {
         err = LDAP_PARAM_ERROR;
         goto error;
     }

     err = ToUnicodeWithAlloc( DistName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP);

     if (err != LDAP_SUCCESS) {

         SetConnectionError( Connection, err, NULL );
         err = (ULONG) -1;
         goto error;
     }

     err = ToUnicodeWithAlloc( AuthMechanism, -1, &wMechanism, LDAP_UNICODE_SIGNATURE, LANG_ACP );

     if (err != LDAP_SUCCESS) {

         SetConnectionError( Connection, err, NULL );
         err = (ULONG) -1;
         goto error;
     }

     rc = LdapExchangeOpaqueToken(Connection,
                             LDAP_AUTH_SASL,        // auth mechanism
                             wMechanism,            // oid
                             wName,                 // username
                             cred->bv_val,          // Credentials
                             cred->bv_len,          // Credential length
                             NULL,                  // return data
                             ServerData,            // return data in berval form
                             (PLDAPControlW *)ServerCtrls,           // server controls
                             (PLDAPControlW *)ClientCtrls,           // client controls
                             0,                     // Message Number
                             FALSE,                 // Send only
                             FALSE,                 // Controls are not unicode
                             NULL                   // was message sent?                             
                             );

error:
    if (wName)
         ldapFree( wName, LDAP_UNICODE_SIGNATURE );

     if (wMechanism)
         ldapFree( wMechanism, LDAP_UNICODE_SIGNATURE );

     if (Connection)
         DereferenceLdapConnection( Connection );

     return rc;

 }


int __cdecl ldap_sasl_bind_sW(
         LDAP  *ExternalHandle,
         const PWCHAR DistName,
         const PWCHAR AuthMechanism,
         const BERVAL   *cred,
         PLDAPControlW *ServerCtrls,
         PLDAPControlW *ClientCtrls,
         PBERVAL *ServerData
         )
 {

     PLDAP_CONN Connection = NULL;
     ULONG err = 0;

     Connection = GetConnectionPointer(ExternalHandle);

     if (!Connection || !DistName ||
          !AuthMechanism || !cred ) {
         err = LDAP_PARAM_ERROR;
         goto error;
     }

     err = LdapExchangeOpaqueToken(Connection,
                             LDAP_AUTH_SASL,        // auth mechanism
                             AuthMechanism,         // oid
                             DistName,              // username
                             cred->bv_val,          // Credentials
                             cred->bv_len,          // Credential length
                             NULL,                  // return data
                             ServerData,            // return data in berval form
                             ServerCtrls,           // server controls
                             ClientCtrls,           // client controls
                             0,                     // Message Number
                             FALSE,                 // Send only
                             TRUE,                  // Controls are unicode
                             NULL                   // was message sent?                             
                             );

error:
     if (Connection)
         DereferenceLdapConnection( Connection );

    return err;
 }



// security.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\transact.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    transact.cxx  Transaction support routines for the LDAP api

Abstract:

   This module implements routines that handle LDAP transactions.

Author:

    Anoop Anantha (AnoopA)        21-Feb-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

#define LDAP_START_TRANSACTION           1
#define LDAP_COMMIT_AND_END_TRANSACTION  2
#define LDAP_ABANDON_TRANSACTION         3

#define LDAP_SIMPLE_TRANSACTION          0
#define LDAP_DISTRIBUTED_TRANSACTION     1

ULONG
LdapCreateTransactionControlWithAlloc(
    IN  PLDAP_CONN connection,
    IN  PBERVAL Cookie,
    IN  BOOLEAN IsCritical,
    OUT PLDAPControlW *TransactionControl,
    ULONG CodePage
    );


//
// Move this section to winldap.h and add this file to the sources file
// to re-enable transaction support once the server folks are ready to
// support it.
//

#if 0


//
// The transaction APIs are used to start/end/abandon LDAP transaction. Typically
// the user calls ldap_start_transaction_s and gets back a transaction control from
// the server. This control is to be passed in with all subsequent requests which
// are part of that transaction. Finally, the transaction is ended/committed by
// calling ldap_end_transaction_s.
//

#define LDAP_TRANSACT_EXTENDED_OP_OID    "1.2.840.113556.1.4.1501"
#define LDAP_TRANSACT_EXTENDED_OP_OID_W L"1.2.840.113556.1.4.1501"

#define LDAP_SIMPLE_TRANSACT_OID    "1.2.840.113556.1.4.1502"
#define LDAP_SIMPLE_TRANSACT_OID_W L"1.2.840.113556.1.4.1502"

#define LDAP_DISTRIBUTED_TRANSACT_OID    "1.2.840.113556.1.4.1503"
#define LDAP_DISTRIBUTED_TRANSACT_OID_W L"1.2.840.113556.1.4.1503"



WINLDAPAPI ULONG LDAPAPI ldap_start_transaction_sW (
    IN   PLDAP          Connection,
    OUT  PULONG         ServerReturnValue,
    OUT  PULONG         TransactionTimeLimit,
    IN   PBERVAL        DistributedTransactionHandle,
    OUT  PLDAPControlW  *TransactionControl,
    IN   PLDAPControlW  *ServerControls,
    IN   PLDAPControlW  *ClientControls,
    IN   struct l_timeval  *TimeOut
);


WINLDAPAPI ULONG LDAPAPI ldap_start_transaction_sA (
    IN   PLDAP          Connection,
    OUT  PULONG         ServerReturnValue,
    OUT  PULONG         TransactionTimeLimit,
    IN   PBERVAL        DistributedTransactionHandle,
    OUT  PLDAPControlA  *TransactionControl,
    IN   PLDAPControlA  *ServerControls,
    IN   PLDAPControlA  *ClientControls,
    IN   struct l_timeval  *TimeOut
);

WINLDAPAPI ULONG LDAPAPI ldap_parse_transaction_controlA (
    IN    PLDAP           Connection,
    IN    PLDAPControlA  *ResponseControl,
    OUT   ULONG          *ServerError
    );

WINLDAPAPI ULONG LDAPAPI ldap_parse_transaction_controlW (
    IN    PLDAP           Connection,
    IN    PLDAPControlW  *ResponseControl,
    OUT   ULONG          *ServerError
    );

WINLDAPAPI ULONG LDAPAPI ldap_end_transaction_sW (
    IN  PLDAP       Connection,
    IN  PLDAPControlW TransactionControl,
    OUT PULONG      ServerReturnValue,
    IN  BOOLEAN     Abandon,
    IN  PLDAPControlW     *ServerControls,
    IN  PLDAPControlW     *ClientControls,
    IN  struct l_timeval  *TimeOut
    );

WINLDAPAPI ULONG LDAPAPI ldap_end_transaction_sA (
    IN  PLDAP         Connection,
    IN  PLDAPControlA TransactionControl,
    OUT PULONG        ServerReturnValue,
    IN  BOOLEAN          Abandon,
    IN  PLDAPControlA    *ServerControls,
    IN  PLDAPControlA    *ClientControls,
    IN  struct l_timeval  *TimeOut
    );


#if LDAP_UNICODE

#define ldap_start_transaction_s ldap_start_transaction_sW
#define ldap_end_transaction_s   ldap_end_transaction_sW
#define ldap_parse_transaction_control ldap_parse_transaction_controlW

#else

#define ldap_start_transaction_s ldap_start_transaction_sA
#define ldap_end_transaction_s   ldap_end_transaction_sA
#define ldap_parse_transaction_control ldap_parse_transaction_controlA

#endif


#endif

ULONG
LdapExchangeTransactionRequest(
    IN  PLDAP_CONN  Connection,
    IN  ULONG   TransactionOperation,
    OUT PULONG  ServerReturnValue,
    OUT PULONG  TransactionTimeLimit,
    IN  struct l_timeval  *TimeOut,
    IN  PBERVAL  cookie,
    IN OUT PLDAPControlW  *TransactionControl,
    IN  PLDAPControlW *ServerControls,
    IN  PLDAPControlW *ClientControls,
    ULONG CodePage
)
//
// This is the meat of the protocol. This is the main client interfact for
// exchanging a start/end/abandon transaction request.
// If the request was for starting a transaction, it allocate a transaction
// control for subsequent use.
//
// During a StartTransaction Operation, if the cookie is non-null, it represents a
// DistributedTransactionHandle.
//

{
    PLDAPSearch search;
    ULONG err;
    LDAPMessage   *Result = NULL;
    BERVAL  lauRequest = {0};
    PBERVAL ResultData = NULL;
    PWCHAR  ResultOID = NULL;
    ULONG msgId;
    ULONG hr;
    ULONG TransactionType;

    if ( TransactionControl  && ( TransactionOperation == LDAP_START_TRANSACTION)) {

        *TransactionControl = NULL;
    }

    if ( TransactionTimeLimit ) {

        *TransactionTimeLimit = 0;
    }
    
    if ( ServerReturnValue ) {

        *ServerReturnValue = LDAP_SUCCESS;
    }
    
    err = LdapConnect( Connection, NULL, FALSE );

    if (err != LDAP_SUCCESS) {
    
       SetConnectionError( Connection, err, NULL );
       return err;
    }
    
    //
    // Determine if this is a simple or distributed transaction
    //

    if ( TransactionOperation == LDAP_START_TRANSACTION ) {

        if (( cookie == NULL ) || ( cookie->bv_len == 0 ) ) {

            TransactionType = LDAP_SIMPLE_TRANSACTION;
        } else {
            TransactionType = LDAP_DISTRIBUTED_TRANSACTION;
        }
    
    } else if (( TransactionOperation == LDAP_COMMIT_AND_END_TRANSACTION ) ||
               ( TransactionOperation == LDAP_ABANDON_TRANSACTION )) {

        //
        // Look into the control to determine the control value. Note that
        // to reduce code, we are overloading the TransactionControl parameter
        // to also take in pointer to an LDAP control which we will examine
        // here.
        //

        ASSERT( TransactionControl != NULL );

        PLDAPControlW pTxControl = (PLDAPControlW) TransactionControl;
        PWCHAR temp = NULL;

        if ( CodePage == LANG_ACP) {
            
            err = ToUnicodeWithAlloc( (PCHAR) pTxControl->ldctl_oid,
                                      -1,
                                      &temp,
                                      LDAP_VALUE_SIGNATURE,
                                      LANG_ACP );
            
            if ( err != LDAP_SUCCESS) {
                SetConnectionError( Connection, err, NULL );
                return err;
            }
        }

        if ( ldapWStringsIdentical( (CodePage == LANG_UNICODE)?pTxControl->ldctl_oid:temp,
            -1,
            LDAP_SIMPLE_TRANSACT_OID_W,
            -1 ) ) {
                
            TransactionType = LDAP_SIMPLE_TRANSACTION;
            
        } else {
                
            TransactionType = LDAP_DISTRIBUTED_TRANSACTION;
        }

        ldapFree( temp, LDAP_VALUE_SIGNATURE );

    } else {

        return LDAP_PARAM_ERROR;
    }


    SetConnectionError( Connection, LDAP_SUCCESS, NULL );

    //
    // Send the extended request. It looks like this:
    //
    // An LDAP ExtendedRequest is defined as follows:
    //
    // ExtendedRequest ::= [APPLICATION 23] SEQUENCE {
    //         requestName             [0] LDAPOID,     // 1.2.840.113556.1.4.1501
    //         requestValue            [1] OCTET STRING OPTIONAL }
    //
    // A Start Transaction extended request is formed by setting the requestName
    // field to the OID of LDAP_TRANSACT_EXTENDED_OP_OID
    //
    // The requestValue is an OCTET STRING wrapping the BER-encoded version of
    // the following.
    //
    // lAUValue ::= SEQUENCE {
    //   semanticsOID    1.2.840.113556.1.4.1502   // Simple/Dist transaction semantics
    //   flag            integer                   // Start/End/Abandon transaction
    //   cookie          OCTET STRING              // Initial cookie
    // }
    //
    //

    CLdapBer *lber = NULL;

    lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

    if (lber == NULL) {
    
        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldapstarttransaction Connection 0x%x couldn't allocate lber.\n", Connection);
        }
        err = LDAP_NO_MEMORY;
        goto returnError;
    }
    
    hr = lber->HrStartWriteSequence();

    if (hr != NOERROR) {

        err = LDAP_ENCODING_ERROR;
        goto returnError;
    }
    
    hr = lber->HrAddValue( TransactionType == LDAP_SIMPLE_TRANSACTION ? LDAP_SIMPLE_TRANSACT_OID_W : LDAP_DISTRIBUTED_TRANSACT_OID_W );
    
    if (hr != NOERROR) {

        err = LDAP_ENCODING_ERROR;
        goto returnError;
    }
    
    hr = lber->HrAddValue( (LONG) TransactionOperation );

    if (hr != NOERROR) {

        err = LDAP_ENCODING_ERROR;
        goto returnError;
    }

    if (( cookie == NULL ) || ( cookie->bv_len == 0 )) {

        //
        // Send over a NULL cookie.
        //

        hr = lber->HrAddBinaryValue( (PBYTE) NULL,
                                     0
                                     );
    
    } else {

        hr = lber->HrAddBinaryValue( (PBYTE) cookie->bv_val,
                                     cookie->bv_len
                                     );
    }
                     
    if (hr != NOERROR) {

        err = LDAP_ENCODING_ERROR;
        goto returnError;
    }

    hr = lber->HrEndWriteSequence();
    ASSERT( hr == NOERROR );

    lauRequest.bv_len = lber->CbData();

    if (lauRequest.bv_len == 0) {

        err = LDAP_LOCAL_ERROR;
        goto returnError;
    }

    lauRequest.bv_val = (PCHAR) ldapMalloc( lauRequest.bv_len, LDAP_CONTROL_SIGNATURE );

    if (lauRequest.bv_val == NULL) {
    
        err = LDAP_NO_MEMORY;
        goto returnError;
    }
    
    CopyMemory( lauRequest.bv_val,
                lber->PbData(),
                lauRequest.bv_len );
    
    //
    // Send the extended request to the server.
    //

    err = LdapExtendedOp( Connection,
                          LDAP_TRANSACT_EXTENDED_OP_OID_W,
                          &lauRequest,
                          TRUE,          // Unicode
                          TRUE,          // Synchronous
                          ServerControls,
                          ClientControls,
                          &msgId
                          );

    //
    // Free the extended data we just sent across. We no longer need it.
    //

    ldapFree( lauRequest.bv_val, LDAP_CONTROL_SIGNATURE );

    if (msgId != (ULONG) -1) {
    
        //
        //  otherwise we simply need to wait for the response to come in.
        //
    
        err = ldap_result_with_error(  Connection,
                                       msgId,
                                       LDAP_MSG_ALL,
                                       TimeOut,
                                       &Result,
                                       NULL
                                       );
    
        if (Result != NULL) {
            
            err = ldap_result2error( Connection->ExternalInfo,
                                     Result,
                                     FALSE
                                     );
        }
    }


    if (err == LDAP_SUCCESS) {
        
        //
        // Parse the extended response for the cookie.
        //
        
        err = LdapParseExtendedResult( Connection,
                                       Result,
                                       &ResultOID,
                                       &ResultData,
                                       TRUE,       // Free the message
                                       LANG_UNICODE
                                       );

        if (err == LDAP_SUCCESS) {

            //
            // Verify that the response OID is indeed what we expect it to be.
            //

            if (!ldapWStringsIdentical( ResultOID,
                                       -1,
                                        LDAP_TRANSACT_EXTENDED_OP_OID_W,
                                       -1 )) {

                err = LDAP_OPERATIONS_ERROR;
                goto returnError;
            }

            //
            // Parse the response data to pick out the cookie and other fields.
            //
            // lAUValue ::= SEQUENCE {
            //
            //   error      ENUMERATED {
            //                success(0),
            //                gen failure (1),
            //                ...TBD...
            //               }
            //   timeout    integer
            //   cookie     OCTET STRING
            //  }
            //

            if ((ResultData == NULL) || (ResultData->bv_len == 0)) {
                
                //
                // Something wrong here.
                //

                LdapPrint2("ResultData is 0x%x len is 0x%x\n", ResultData, ResultData->bv_len);

                err = LDAP_OPERATIONS_ERROR;
                goto returnError;
            
            } else {

                BerElement *ber = NULL;
                PBERVAL    localCookie = NULL;
                int retval = LDAP_SUCCESS;
                int timeout = 0;

                ber = ber_init( ResultData );

                if ( ber == NULL ) {
                    err = LDAP_DECODING_ERROR;
                    goto returnError;
                }

                //
                // Pick out the enumerated server return value.
                //

                err = ber_scanf( ber, "{e", &retval  );

                if (err != LDAP_SUCCESS) {

                    ber_free( ber, 1);
                    goto returnError;
                }

                if ( ServerReturnValue ) {

                    *ServerReturnValue = retval;
                }
                
                //
                // Look for the timeout and cookie
                //

                err = ber_scanf( ber, "i", &timeout );

                if ((err != LDAP_SUCCESS) && ( TransactionOperation == LDAP_START_TRANSACTION )) {
                    ber_free( ber, 1);
                    goto returnError;
                }

                if ((err == LDAP_SUCCESS) && ( TransactionTimeLimit )) {

                    *TransactionTimeLimit = timeout;
                }

                err = ber_scanf( ber, "O", &localCookie  );

                if ((err != LDAP_SUCCESS) && ( TransactionOperation == LDAP_START_TRANSACTION )) {
                    ber_free( ber, 1);
                    goto returnError;
                }
                
                ber_free( ber, 1);
                
                err = LDAP_SUCCESS;

                //
                // Allocate a control and fill in the cookie as appropriate.
                //

                if ( TransactionOperation == LDAP_START_TRANSACTION ) {

                    err = LdapCreateTransactionControlWithAlloc( Connection,
                                                                 localCookie,
                                                                 TRUE,  // Criticality
                                                                 TransactionControl,
                                                                 CodePage
                                                                 );
                }
            }
        }
    }

returnError:

    if (lber != NULL) {
        delete lber;
    }

    //
    // We must always abandon the request because the library does not know
    // when an extended response ends.
    //

    LdapAbandon( Connection, msgId, FALSE );
    SetConnectionError( Connection, err, NULL );
    
    return err;

}



ULONG
LdapStartTransaction(
    IN  PLDAP  ExternalHandle,
    OUT PULONG  ServerReturnValue,
    OUT PULONG  TransactionTimeLimit,
    IN  struct l_timeval  *TimeOut,
    IN  PBERVAL  DistributedTransactionHandle,
    OUT PLDAPControlW  *TransactionControl,
    IN  PLDAPControlW  *ServerControls,
    IN  PLDAPControlW  *ClientControls,
    ULONG CodePage
)
//
// Sends out a Start Transaction PDU to the server. This is a synchronous call
// controlled by a client side timeout. On success, it allocates a Transaction
// control which must be later freed using ldap_control_free.
//
{
    PLDAP_CONN connection = NULL;
    ULONG err = 0;

    if ( TransactionControl == NULL ) {
    
        return LDAP_PARAM_ERROR;
    
    }
    
    connection = GetConnectionPointer(ExternalHandle);
    
    if (connection == NULL) {
    
        return LDAP_PARAM_ERROR;
    }

    err = LdapExchangeTransactionRequest( connection,
                                          LDAP_START_TRANSACTION,
                                          ServerReturnValue,
                                          TransactionTimeLimit,
                                          TimeOut,
                                          DistributedTransactionHandle,
                                          TransactionControl,
                                          ServerControls,
                                          ClientControls,
                                          CodePage );
    
    DereferenceLdapConnection( connection );

    return err;
}


ULONG
LdapEndTransaction(
    IN  PLDAP    ExternalHandle,
    IN  PLDAPControlW  TransactionControl,
    OUT PULONG ReturnValue,
    IN  BOOLEAN Abandon,
    IN  struct l_timeval  *TimeOut,
    IN  PLDAPControlW  *ServerControls,
    IN  PLDAPControlW  *ClientControls,
    IN  ULONG CodePage
)
//
// Sends out a Start Transaction PDU to the server. This is a synchronous call
// controlled by a client side timeout. On success, it denotes a successful
// End transaction exchange. The user still has to examine the ServerReturn value
// to determine if the commit/abandon succeeded.
//
{
    PLDAP_CONN connection = NULL;
    ULONG err;
    BerElement *pBer = NULL;
    PBERVAL    cookie = NULL;

    
    if ( TransactionControl == NULL ) {

        return LDAP_PARAM_ERROR;
    }

    connection = GetConnectionPointer(ExternalHandle);
    
    if (connection == NULL) {
    
        return LDAP_PARAM_ERROR;
    }

    //
    // Crack the control to retrieve the cookie to be used in this exchange.
    //

    pBer = ber_init( &(TransactionControl->ldctl_value) );

    if (pBer == NULL) {
        err = LDAP_DECODING_ERROR;
        goto returnError;
    }

    err = ber_scanf( pBer, "{O", &cookie  );

    if (err != LDAP_SUCCESS) {
        goto returnError;
    }


    err = LdapExchangeTransactionRequest ( connection,
                                           Abandon ? LDAP_ABANDON_TRANSACTION : LDAP_COMMIT_AND_END_TRANSACTION,
                                           ReturnValue,
                                           NULL,             // TransactionTimeLimit
                                           TimeOut,
                                           cookie,           // serverreturnedCookie
                                           (PLDAPControlW*) TransactionControl,
                                           ServerControls,
                                           ClientControls,
                                           CodePage
                                           );

  returnError:

    DereferenceLdapConnection( connection );

    if ( pBer ) {
        ber_free( pBer, 1);
    }

    if ( cookie ) {
        ber_bvfree( cookie );
    }
    
    return err;

}

ULONG
LdapEncodeTransactionControl (
    PLDAP_CONN      connection,
    PBERVAL  cookie,
    PLDAPControlW  OutputControl,
    BOOLEAN Criticality,
    ULONG CodePage
    )
{
    ULONG err;
    CLdapBer *lber = NULL;
    PLDAPSortKeyW sortKey;
    ULONG hr = NOERROR;

    if ((connection == NULL) || (OutputControl == NULL)) {

        return LDAP_PARAM_ERROR;
    }

    OutputControl->ldctl_oid = NULL;
    OutputControl->ldctl_iscritical = Criticality;

    if (CodePage == LANG_UNICODE) {

        OutputControl->ldctl_oid = ldap_dup_stringW( LDAP_SIMPLE_TRANSACT_OID_W,
                                                     0,
                                                     LDAP_VALUE_SIGNATURE );
    } else {

        OutputControl->ldctl_oid = (PWCHAR) ldap_dup_string(  LDAP_SIMPLE_TRANSACT_OID,
                                                              0,
                                                              LDAP_VALUE_SIGNATURE );
    }

    if (OutputControl->ldctl_oid == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodeTransactControl;
    }

    lber = new CLdapBer( connection->publicLdapStruct.ld_version );

    if (lber == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodeTransactControl;
    }

    //
    //
    // The lAUControlValue is an OCTET STRING wrapping the BER-encoded
    // version of the lAU identifier cookie:
    // lAUControlValue ::= SEQUENCE {
    //            cookie          OCTET STRING
    // }
    //


    hr = lber->HrStartWriteSequence();

    if (hr != LDAP_SUCCESS) {

        err = LDAP_ENCODING_ERROR;
        goto exitEncodeTransactControl;
    }

    hr = lber->HrAddBinaryValue( (PBYTE) cookie->bv_val, cookie->bv_len, BER_OCTETSTRING );

    if (hr != LDAP_SUCCESS) {

        err = LDAP_ENCODING_ERROR;
        goto exitEncodeTransactControl;
    }

    hr = lber->HrEndWriteSequence();
    ASSERT( hr == NOERROR );

    OutputControl->ldctl_value.bv_len = lber->CbData();

    if (OutputControl->ldctl_value.bv_len == 0) {

        err = LDAP_LOCAL_ERROR;
        goto exitEncodeTransactControl;
    }

    OutputControl->ldctl_value.bv_val = (PCHAR) ldapMalloc(
                            OutputControl->ldctl_value.bv_len,
                            LDAP_CONTROL_SIGNATURE );

    if (OutputControl->ldctl_value.bv_val == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodeTransactControl;
    }

    CopyMemory( OutputControl->ldctl_value.bv_val,
                lber->PbData(),
                OutputControl->ldctl_value.bv_len );

    err = LDAP_SUCCESS;

exitEncodeTransactControl:

    if (err != LDAP_SUCCESS) {

        if (OutputControl->ldctl_oid != NULL) {

            ldapFree( OutputControl->ldctl_oid, LDAP_VALUE_SIGNATURE );
            OutputControl->ldctl_oid = NULL;
        }

        OutputControl->ldctl_value.bv_len = 0;
    }

    if (lber != NULL) {
        delete lber;
    }
    
    return err;

}



ULONG
LdapCreateTransactionControlWithAlloc(
    IN  PLDAP_CONN connection,
    IN  PBERVAL Cookie,
    IN  BOOLEAN IsCritical,
    OUT PLDAPControlW *TransactionControl,
    ULONG CodePage
    )
{
    ULONG err;
    BOOLEAN criticality = IsCritical;
    PLDAPControlW  control = NULL;

    control = (PLDAPControlW) ldapMalloc( sizeof( LDAPControlW ), LDAP_CONTROL_SIGNATURE );

    if (control == NULL) {

        *TransactionControl = NULL;
        return LDAP_NO_MEMORY;
    }

    err = LdapEncodeTransactionControl(  connection,
                                         Cookie,
                                         control,
                                         criticality,
                                         CodePage );

    if (err != LDAP_SUCCESS) {

        ldap_control_freeW( control );
        control = NULL;
    }

    *TransactionControl = control;

    return err;

}



ULONG
LdapParseTransactionControl (
        IN  PLDAP_CONN      connection,
        IN  PLDAPControlW  *ServerControls,
        OUT ULONG          *Result,
        IN  ULONG           CodePage
        )
{
    ULONG err = LDAP_CONTROL_NOT_FOUND;
    CLdapBer *lber = NULL;
    ULONG  hr = NOERROR;

    //
    //  First thing is to zero out the parms passed in.
    //

    if (Result != NULL) {

        *Result = 0;
    }

    if (ServerControls != NULL) {

        PLDAPControlW *controls = ServerControls;
        PLDAPControlW currentControl;
        ULONG bytesTaken;
        LONG  txError;

        while (*controls != NULL) {

            currentControl = *controls;

            //
            //  check to see if the current control is the Transaction control
            //

            if ( ((CodePage == LANG_UNICODE) &&
                  ( ldapWStringsIdentical( currentControl->ldctl_oid,
                                           -1,
                                           LDAP_SIMPLE_TRANSACT_OID_W,
                                           -1 ) == TRUE )) ||
                 ((CodePage == LANG_ACP) &&
                  ( CompareStringA( LDAP_DEFAULT_LOCALE,
                                    NORM_IGNORECASE,
                                    (PCHAR) currentControl->ldctl_oid,
                                    -1,
                                    LDAP_SIMPLE_TRANSACT_OID,
                                    sizeof(LDAP_SIMPLE_TRANSACT_OID) ) == 2)) ) {

                //
                // The lAUResponseControlValue is defined as follows:
                //
                //  lAUResponseControlValue ::= SEQUENCE {
                //
                //          lauResult  ENUMERATED {
                //                        success (0),
                //                        timeLimitExceeded (3),
                //                        busy(51),
                //                        unwillingToPerform (53),
                //                        other(80) }
                //            }
                //

                lber = new CLdapBer( connection->publicLdapStruct.ld_version );

                if (lber == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint1( "LdapParseTxControl: unable to alloc msg for 0x%x.\n",
                                    connection );
                    }

                    err = LDAP_NO_MEMORY;
                    break;
                }

                hr = lber->HrLoadBer(   (const BYTE *) currentControl->ldctl_value.bv_val,
                                         currentControl->ldctl_value.bv_len,
                                         &bytesTaken,
                                         TRUE );    // we have the whole message guarenteed

                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseTxControl: loadBer error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    err = LDAP_DECODING_ERROR;
                    break;
                }

                hr = lber->HrStartReadSequence();
                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseTxControl: loadBer error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    err = LDAP_DECODING_ERROR;
                    break;
                }

                hr = lber->HrGetEnumValue( &txError );
                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseTxControl: getEnumValue error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    err = LDAP_DECODING_ERROR;
                    break;
                }

                if (Result != NULL) {

                    *Result = txError;
                }

                err = LDAP_SUCCESS;
                break;                  // done with loop... look no more
            }
            controls++;
        }
    }
    
    if (lber != NULL) {

        delete lber;
    }

    SetConnectionError( connection, err, NULL );
    return err;
}


WINLDAPAPI
ULONG LDAPAPI
ldap_start_transaction_sW (
    IN   PLDAP          ExternalHandle,
    OUT  PULONG         ServerReturnValue,
    OUT  PULONG         TransactionTimeLimit,
    IN   PBERVAL        DistributedTransactionHandle,
    OUT  PLDAPControlW  *TransactionControl,
    IN   PLDAPControlW  *ServerControls,
    IN   PLDAPControlW  *ClientControls,
    IN   struct l_timeval  *TimeOut
)
{

    return LdapStartTransaction( ExternalHandle,
                                 ServerReturnValue,
                                 TransactionTimeLimit,
                                 TimeOut,
                                 DistributedTransactionHandle,
                                 TransactionControl,
                                 ServerControls,
                                 ClientControls,
                                 LANG_UNICODE
                                 );
}

WINLDAPAPI
ULONG LDAPAPI
ldap_start_transaction_sA (
    IN   PLDAP          ExternalHandle,
    OUT  PULONG         ServerReturnValue,
    OUT  PULONG         TransactionTimeLimit,
    IN   PBERVAL        DistributedTransactionHandle,
    OUT  PLDAPControlA  *TransactionControl,
    IN   PLDAPControlA  *ServerControls,
    IN   PLDAPControlA  *ClientControls,
    IN   struct l_timeval  *TimeOut
)
{

    return LdapStartTransaction( ExternalHandle,
                                 ServerReturnValue,
                                 TransactionTimeLimit,
                                 TimeOut,
                                 DistributedTransactionHandle,
                                 (PLDAPControlW *) TransactionControl,
                                 (PLDAPControlW *) ServerControls,
                                 (PLDAPControlW *) ClientControls,
                                 LANG_ACP
                                 );
}


WINLDAPAPI
ULONG LDAPAPI
ldap_parse_transaction_controlA (
        IN   PLDAP           ExternalHandle,
        IN   PLDAPControlA  *ResponseControl,
        OUT  ULONG          *ServerError
        )
{

    PLDAP_CONN connection = NULL;
    ULONG err;
    
    connection = GetConnectionPointer(ExternalHandle);
    
    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapParseTransactionControl( connection,
                                       (PLDAPControlW *) ResponseControl,
                                       ServerError,
                                       LANG_ACP
                                       );
    
    DereferenceLdapConnection( connection );

    return err;
}


WINLDAPAPI
ULONG LDAPAPI
ldap_parse_transaction_controlW (
        IN   PLDAP           ExternalHandle,
        IN   PLDAPControlW  *ResponseControl,
        OUT  ULONG          *ServerError
        )
{

    PLDAP_CONN connection = NULL;
    ULONG err;
    
    connection = GetConnectionPointer(ExternalHandle);
    
    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }


    err = LdapParseTransactionControl( connection,
                                       ResponseControl,
                                       ServerError,
                                       LANG_UNICODE
                                       );

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI
ULONG LDAPAPI
ldap_end_transaction_sW (
    IN  PLDAP    ExternalHandle,
    IN  PLDAPControlW TransactionControl,
    OUT PULONG ReturnValue,
    IN  BOOLEAN Abandon,
    IN  PLDAPControlW  *ServerControls,
    IN  PLDAPControlW  *ClientControls,
    IN  struct l_timeval  *TimeOut
)
{

    return LdapEndTransaction( ExternalHandle,
                               TransactionControl,
                               ReturnValue,
                               Abandon,
                               TimeOut,
                               ServerControls,
                               ClientControls,
                               LANG_UNICODE);
}

WINLDAPAPI
ULONG LDAPAPI
ldap_end_transaction_sA (
    IN  PLDAP         ExternalHandle,
    IN  PLDAPControlA TransactionControl,
    OUT PULONG       ReturnValue,
    IN  BOOLEAN          Abandon,
    IN  PLDAPControlA  *ServerControls,
    IN  PLDAPControlA  *ClientControls,
    IN  struct l_timeval  *TimeOut
)
{

    return LdapEndTransaction( ExternalHandle,
                               (PLDAPControlW) TransactionControl,
                               ReturnValue,
                               Abandon,
                               TimeOut,
                               (PLDAPControlW *) ServerControls,
                               (PLDAPControlW *) ClientControls,
                               LANG_ACP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\starttls.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    starttls.cxx  StartTLS support routines for the LDAP api

Abstract:

   This module implements routines that handle establishment of
   Transport layer security on the fly. This implementation is
   based on v6 of the draft. draft-ietf-ldapext-ldapv3-tls-06.txt

Author:

    Anoop Anantha (AnoopA)        20-Mar-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"


ULONG
LdapStartTLS ( 
    IN  PLDAP ExternalHandle,
    OUT PULONG ServerReturnValue,
    OUT LDAPMessage  **result,
    IN  PLDAPControlW *ServerControls,
    IN  PLDAPControlW *ClientControls,
    IN  ULONG CodePage
 )
//
// This API is called by users to initiate Transport Level Security on an
// LDAP connection. If the server accepts our proposal and initiates TLS,
// this API will return LDAP_SUCCESS.
//
// If the server failed request for whatever reason, the API returns LDAP_OTHER
// and the ServerReturnValue will contain the error code from the server.
//
// It is possible that the server returns a referral - either in response to the
// StartTLS request or during the subsequent encrypted session. For security
// reasons, we have decided to NOT chase referrals by default. In the former case,
// the referral message is returned as an LDAPMessage to the user.
//
// The operation has a default timeout of about 30 seconds as defined by
// LDAP_SSL_NEGOTIATE_TIME_DEFAULT
//
{
    PLDAP_CONN connection = NULL;
    ULONG err;
    ULONG secErr = LDAP_SUCCESS;
    PLIST_ENTRY listEntry;
    PLDAP_REQUEST request;
    ULONG msgId;
    LDAPMessage   *Res = NULL;
    PWCHAR  ResultOID = NULL;
    ULONG ServerError = LDAP_PROTOCOL_ERROR;

    DBG_UNREFERENCED_PARAMETER( CodePage );
    
    connection = GetConnectionPointer(ExternalHandle);
    
    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    if (ServerReturnValue) {
        *ServerReturnValue = NULL;
    }

    if (result) {
        *result = NULL;
    }

    err = LdapConnect( connection, NULL, FALSE );
    
    if (err != LDAP_SUCCESS) {
    
       SetConnectionError( connection, err, NULL );
       DereferenceLdapConnection(connection);
       return err;
    }

    ACQUIRE_LOCK( &connection->StateLock );
    
    //
    // We fail the request if 
    // - TLS is already established.
    // - Signing/sealing is on.
    // - Bind is in progress
    //

    if ((connection->SecureStream)       ||
        (connection->SslSetupInProgress) ||
        (connection->BindInProgress)) {

        RELEASE_LOCK( &connection->StateLock );
        DereferenceLdapConnection(connection);
        return LDAP_UNWILLING_TO_PERFORM;
    }

    RELEASE_LOCK( &connection->StateLock );

    //
    // Step through the global request list to see if this connection has
    // any outstanding requests.
    //

    ACQUIRE_LOCK( &RequestListLock );

    listEntry = GlobalListRequests.Flink;

    while (listEntry != &GlobalListRequests) {

        request = CONTAINING_RECORD( listEntry, LDAP_REQUEST, RequestListEntry );
        request = ReferenceLdapRequest(request);

        if (!request) {
            listEntry = listEntry->Flink;
            continue;
        }

        ACQUIRE_LOCK( &request->Lock );

        if (connection == request->PrimaryConnection) {

            //
            // Bummer, we have outstanding requests on this connection.
            //

            DereferenceLdapRequest( request );
            RELEASE_LOCK( &request->Lock );
            RELEASE_LOCK( &RequestListLock );

            DereferenceLdapConnection(connection);
            return LDAP_UNWILLING_TO_PERFORM;
        }

        DereferenceLdapRequest( request );
        RELEASE_LOCK( &request->Lock );
    }

    //
    // We have no outstanding requests at this point. Hang on to the
    // requestlistlock to ensure that no new requests slip in.
    //
    //
    // Send the StartTLS PDU to the server. It looks like this
    //
    // An LDAP ExtendedRequest is defined as follows:
    //
    // ExtendedRequest ::= [APPLICATION 23] SEQUENCE {
    //         requestName             [0] LDAPOID,     // 1.3.6.1.4.1.1466.20037
    //         requestValue            [1] OCTET STRING OPTIONAL }
    //
    // The requestValue field is absent.
    //

    err = LdapExtendedOp( connection,
                          LDAP_START_TLS_OID_W, // requestName
                          NULL,          // requestValue
                          TRUE,          // Unicode
                          TRUE,          // Synchronous
                          ServerControls,
                          ClientControls,
                          &msgId
                          );

    if (err != LDAP_SUCCESS) {

        goto returnError;
    }

    if (msgId != (ULONG) -1) {
    
        //
        //  otherwise we simply need to wait for the response to come in.
        //
    
        struct l_timeval Timeout;

        Timeout.tv_sec = LDAP_SSL_NEGOTIATE_TIME_DEFAULT;
        Timeout.tv_usec = 0;

        err = ldap_result_with_error(  connection,
                                       msgId,
                                       LDAP_MSG_ALL,
                                       &Timeout,
                                       &Res,
                                       NULL
                                       );
    
        if (err != LDAP_SUCCESS) {

            goto returnError;
        }
        
        if (Res != NULL) {

            ServerError = ldap_result2error( connection->ExternalInfo,
                                             Res,
                                             FALSE
                                             );

            if (ServerReturnValue) {
                *ServerReturnValue = ServerError;
            }
        }
    }

    if (ServerError != LDAP_SUCCESS) {

        //
        // The server did not like our request for whatever reason. The user
        // has to consult the ServerReturnValue for more info.
        //

        err = LDAP_OTHER;
    }

    if ((ServerError == LDAP_REFERRAL) ||
         (ServerError == LDAP_REFERRAL_V2)) {
        
        //
        // Return the referral to the user.
        //

        if (result) {
            *result = Res;
        }
    }

    if (err == LDAP_SUCCESS) {
        
        //
        // Parse the extended response for the OID
        //
        
        err = LdapParseExtendedResult( connection,
                                       Res,
                                       &ResultOID,
                                       NULL,
                                       TRUE,       // Free the message
                                       LANG_UNICODE
                                       );

        if (err == LDAP_SUCCESS) {

            //
            // Verify that the response OID is indeed what we expect it to be.
            //

            if (!ldapWStringsIdentical( ResultOID,
                                       -1,
                                        LDAP_START_TLS_OID_W,
                                       -1 )) {

                err = LDAP_OPERATIONS_ERROR;
                goto returnError;
            }

        }
    }

    if (err != LDAP_SUCCESS) {

        goto returnError;
    }

    secErr = LdapConvertSecurityError( connection,
                                       LdapSetupSslSession( connection )
                                     );


    err = secErr;

returnError:

    RELEASE_LOCK( &RequestListLock );

    //
    // We must always abandon the request because the library does not know
    // when an extended response ends.
    //

    if (msgId != (ULONG) -1) {
        LdapAbandon( connection, msgId, FALSE );
    }

    if (err == LDAP_SUCCESS) {
        
        //
        // Disable automatic referral chasing on this connection.
        //
        
        ACQUIRE_LOCK( &connection->StateLock );

        connection->PreTLSOptions = connection->publicLdapStruct.ld_options;
        connection->publicLdapStruct.ld_options &= ~LDAP_OPT_CHASE_REFERRALS;
        connection->publicLdapStruct.ld_options &= ~LDAP_CHASE_SUBORDINATE_REFERRALS;
        connection->publicLdapStruct.ld_options &= ~LDAP_CHASE_EXTERNAL_REFERRALS;

        //
        // Disable autoreconnect on this connection.
        //
        
        connection->AutoReconnect = FALSE;

        connection->SslPort = TRUE;
        RELEASE_LOCK( &connection->StateLock );

    }
    else if (secErr != LDAP_SUCCESS) {
        //
        // We failed during SSL negotiations.
        // Terminate the connection.
        //
        //
        // We can't call CloseLdapConnection() because the user can't unbind the connection
        // due to the connection state being set to closed, thus leaking the connection.
        // Our only option is to set the state to HostConnectState to Error and set
        // autoreconnect to OFF. This will prevent autoreconnects yet convey an 
        // error (LDAP_SERVER_DOWN) to the user.  Preventing autoreconnect ensures that the
        // user won't unknowingly get reconnected with a non-secure connection.
        //

        connection->ServerDown = TRUE;
        connection->HostConnectState = HostConnectStateError;
        connection->AutoReconnect = FALSE;
    }

    DereferenceLdapConnection(connection);
    SetConnectionError( connection, err, NULL );
    return err;

}


WINLDAPAPI
BOOLEAN LDAPAPI
ldap_stop_tls_s ( 
    IN  PLDAP ExternalHandle
 )
//
// This API is called by the user to stop Transport Level Security on an open
// LDAP connection on which TLS has already been started.
//
// If the operation succeeds, the user can resume normal plaintext LDAP
// operations on the connection.
//
// If the operation fails, the user MUST close the connection by calling
// ldap_unbind as the TLS state of the connection will be indeterminate.
//
// The operation has a default timeout of about 30 seconds as defined by
// LDAP_SSL_NEGOTIATE_TIME_DEFAULT
//
{
    PLDAP_CONN connection = NULL;
    ULONG err;
    PLIST_ENTRY listEntry;
    PLDAP_REQUEST request;
    PSECURESTREAM pSecureStream;
    
    connection = GetConnectionPointer(ExternalHandle);
    
    if (connection == NULL) {
        return FALSE;
    }

    ACQUIRE_LOCK( &connection->StateLock );
    
    //
    // We fail the request if 
    //
    // - The connection is not actively connected to the server.
    // - TLS is not already established.
    // - Signing/sealing is on.
    // - Bind is in progress
    //

    pSecureStream = (PSECURESTREAM) connection->SecureStream;

    if ((connection->HostConnectState != HostConnectStateConnected)  ||
        (!pSecureStream) ||
//      (connection->UserSignDataChoice) ||
//      (connection->UserSealDataChoice) ||
        (connection->CurrentSignStatus) ||
        (connection->CurrentSealStatus) ||
        (connection->SslSetupInProgress) ||
        (connection->BindInProgress)) {

        RELEASE_LOCK( &connection->StateLock );
        DereferenceLdapConnection(connection);
        return FALSE;
    }

    RELEASE_LOCK( &connection->StateLock );

    //
    //  Abandon all requests where this connection is the primary conn
    //
    
    ACQUIRE_LOCK( &RequestListLock );

    listEntry = GlobalListRequests.Flink;

    while (listEntry != &GlobalListRequests) {

        request = CONTAINING_RECORD( listEntry, LDAP_REQUEST, RequestListEntry );

        request = ReferenceLdapRequest( request );

        if (!request) {
            listEntry = listEntry->Flink;
            continue;
        }

        ACQUIRE_LOCK( &request->Lock );

        if ( (request->PrimaryConnection == connection) &&
             (request->Closed == FALSE)) {

            RELEASE_LOCK( &request->Lock );
            RELEASE_LOCK( &RequestListLock );

            //
            //  Abandon the request explicitly.
            //

            LdapAbandon( request->PrimaryConnection,
                         request->MessageId,
                         TRUE );

            DereferenceLdapRequest( request );

            ACQUIRE_LOCK( &RequestListLock );

            //
            //  We have to start at the top of the list again because the
            //  list may have changed since we freed the lock.  Not the
            //  best, but unless we change the locking order, it will have
            //  to do.
            //

            listEntry = GlobalListRequests.Flink;

        } else {

            RELEASE_LOCK( &request->Lock );
            listEntry = listEntry->Flink;
            DereferenceLdapRequest( request );
        }
    }

    //
    // Bring down the TLS connection.
    //

    err = LdapConvertSecurityError( connection, 
                                    pSecureStream->TearDownSecureConnection()
                                    );

    if (err != LDAP_SUCCESS) {

        LdapPrint1("TearDownSecureConnection returned 0x%x\n", err);
    }

    delete pSecureStream;
    connection->SecureStream = NULL;

    RELEASE_LOCK( &RequestListLock );
    
    //
    // Restore the referral chasing and autoreconnect options on the connection.
    //

    ACQUIRE_LOCK( &connection->StateLock );
    
    connection->publicLdapStruct.ld_options |= connection->PreTLSOptions;
    connection->AutoReconnect = connection->UserAutoRecChoice;
    connection->SslPort = FALSE;

    RELEASE_LOCK( &connection->StateLock );

    DereferenceLdapConnection(connection);
    SetConnectionError( connection, err, NULL );
    return (err == LDAP_SUCCESS) ? TRUE : FALSE;
}


WINLDAPAPI
ULONG LDAPAPI
ldap_start_tls_sW (
    IN   PLDAP          ExternalHandle,
    OUT  PULONG         ServerReturnValue,
    OUT  LDAPMessage    **result,
    IN   PLDAPControlW  *ServerControls,
    IN   PLDAPControlW  *ClientControls
)
{

    return LdapStartTLS( ExternalHandle,
                         ServerReturnValue,
                         result,
                         ServerControls,
                         ClientControls,
                         LANG_UNICODE
                         );
}

WINLDAPAPI
ULONG LDAPAPI
ldap_start_tls_sA (
    IN   PLDAP          ExternalHandle,
    OUT  PULONG         ServerReturnValue,
    OUT  LDAPMessage    **result,
    IN   PLDAPControlA  *ServerControls,
    IN   PLDAPControlA  *ClientControls
)
{

    return LdapStartTLS( ExternalHandle,
                         ServerReturnValue,
                         result,
                         (PLDAPControlW *) ServerControls,
                         (PLDAPControlW *) ClientControls,
                         LANG_ACP
                         );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\subord.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    subord.cxx parse subordinate references from an LDAP server

Abstract:

   This module implements the gathering/parsing routines for subordinate
   referrals (references) for ldap search results.

Author:

    Andy Herron (andyhe)        30-Apr-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG
LdapParseReference (
        PLDAP_CONN connection,
        LDAPMessage *ResultMessage,
        PWCHAR **Referrals,                  // free with ldap_value_freeW
        BOOLEAN Unicode
        );

LDAPMessage * __cdecl
ldap_first_reference (
    LDAP *ExternalHandle,
    LDAPMessage *Results
    )
{
    PLDAP_CONN connection = NULL;
    LDAPMessage *result;

    connection = GetConnectionPointer(ExternalHandle);

    result = ldap_first_record( connection, Results, LDAP_RES_REFERRAL );

    if (connection)
        DereferenceLdapConnection( connection );

    return result;
}

LDAPMessage * __cdecl
ldap_next_reference (
    LDAP *ExternalHandle,
    LDAPMessage *entry
    )
{
    PLDAP_CONN connection = NULL;
    LDAPMessage *result;

    connection = GetConnectionPointer(ExternalHandle);

    result = ldap_next_record( connection, entry, LDAP_RES_REFERRAL );

    if (connection)
        DereferenceLdapConnection( connection );

    return result;
}


//
//  Count the number of subordinate references returned by the server in a
//  response to a search request.
//

ULONG __cdecl
ldap_count_references (
    LDAP *ExternalHandle,
    LDAPMessage *entry
    )
{
    PLDAP_CONN connection = NULL;
    ULONG cnt;

    connection = GetConnectionPointer(ExternalHandle);

    cnt = ldap_count_records( connection, entry, LDAP_RES_REFERRAL );

    if (connection)
        DereferenceLdapConnection( connection );

    return cnt;
}

PLDAPMessage
ldap_first_record (
    PLDAP_CONN connection,
    LDAPMessage *Results,
    ULONG MessageType
    )
{
    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    //
    //  return the first entry of a resultant message passed in.  skip any
    //  search result messages that may be in the middle of the message.
    //

    if (Results == (LDAPMessage *) -1 ) {

        return NULL;
    }

    while ((Results != NULL) &&
           (Results->lm_msgtype != MessageType )) {

        Results = Results->lm_chain;
    }

    return Results;
}


//
//  Return the next entry of a message.  It is freed when the message is
//  freed so should not be freed explicitly.
//
PLDAPMessage
ldap_next_record (
    PLDAP_CONN connection,
    LDAPMessage *entry,
    ULONG MessageType
    )
{
    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    //
    //  return the first entry of a resultant message passed in.
    //

    if (entry == NULL) {

        return NULL;
    }

    //
    //  skip any search result messages that may be in the middle of the
    //  message.
    //

    entry = entry->lm_chain;

    while ((entry != NULL) &&
           (entry->lm_msgtype != MessageType )) {

        entry = entry->lm_chain;
    }

    return entry;
}


ULONG
ldap_count_records (
    PLDAP_CONN connection,
    LDAPMessage *res,
    ULONG MessageType
    )
{
    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    ULONG count = 0;

    if ( (LONG_PTR) res != -1 ) {

        while (res != NULL) {

            if (res->lm_msgtype == MessageType) {

                count++;
            }
            res = res->lm_chain;
        }
    }
    return(count);
}

//
//  We return the list of subordinate referrals in a search response message.
//

ULONG __cdecl
ldap_parse_referenceW (
        LDAP *ExternalHandle,
        LDAPMessage *ResultMessage,
        PWCHAR **Referrals                   // free with ldap_value_freeW
        )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapParseReference(   connection,
                                ResultMessage,
                                Referrals,
                                TRUE );

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_parse_referenceA (
        LDAP *ExternalHandle,
        LDAPMessage *ResultMessage,
        PCHAR **Referrals                   // free with ldap_value_freeA
        )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapParseReference(   connection,
                                ResultMessage,
                                (PWCHAR **) Referrals,
                                FALSE );

    DereferenceLdapConnection( connection );

    return err;
}


ULONG
LdapParseReference (
        PLDAP_CONN connection,
        LDAPMessage *ResultMessage,
        PWCHAR **Referrals,                  // free with ldap_value_freeW
        BOOLEAN Unicode
        )
{
    CLdapBer *lber = NULL;
    ULONG hr;
    PWCHAR referralString = NULL;
    ULONG count = 0;
    ULONG arraySize = 0;

    if ((connection == NULL) ||
        (ResultMessage == NULL) ||
        (ResultMessage == (PLDAPMessage) -1) ||
        (ResultMessage->lm_msgtype != LDAP_RES_REFERRAL) ||
        (Referrals == NULL)) {

        return LDAP_PARAM_ERROR;
    }

    *Referrals = NULL;

    lber = (CLdapBer *) (ResultMessage->lm_ber);

    if (lber == NULL) {

        return LDAP_LOCAL_ERROR;
    }

    lber->Reset(FALSE);

    hr = LdapInitialDecodeMessage( connection, ResultMessage );

    if (hr != NOERROR) {

        IF_DEBUG(REFERRALS) {
            LdapPrint2( "HandleReferral error 0x%x while decoding referral for 0x%x\n",
                         hr, connection );
        }
        return hr;
    }

    while (hr == NOERROR) {

        if (Unicode) {

            hr = lber->HrGetValueWithAlloc( &referralString );

        } else {

            hr = lber->HrGetValueWithAlloc( (PCHAR *) &referralString );
        }

        if (hr != NOERROR || referralString == NULL) {

            IF_DEBUG(REFERRALS) {
                LdapPrint2( "HandleReferral error 0x%x while reading referral for 0x%x\n",
                             hr, connection );
            }
            break;
        }

        if (add_string_to_list( Referrals, &arraySize, referralString, FALSE ) > 0) {

            count++;

        } else {

            ldapFree( referralString, LDAP_VALUE_SIGNATURE );
        }
    }

    if (count > 0) {

        hr = LDAP_SUCCESS;
    }

    return hr;
}

// subord.cxx  eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\unbind.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    unbind.c  unbind a connection to an LDAP server

Abstract:

   This module implements the LDAP ldap_unbind API.

   It also implements routines to clean up LDAP connection blocks.

Author:

    Andy Herron    (andyhe)        17-May-1996
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"


//
//  This routine is one of the main entry points for clients calling into the
//  ldap API.
//

ULONG __cdecl
ldap_unbind (
    LDAP *ExternalHandle
    )
{
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    IF_DEBUG(CONNECTION) {
        LdapPrint2( "ldap_unbind called for conn 0x%x, host is %s.\n",
                        connection, connection->publicLdapStruct.ld_host);
    }

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=ldap_unbind]"));
    DSLOG((0,"[-]\n"));

    ACQUIRE_LOCK( &connection->StateLock);

    if (connection->HandlesGivenToCaller > 0) {

       connection->HandlesGivenToCaller--;
    }

    if ((connection->HandlesGivenToCaller == 0 ) &&
        (connection->HandlesGivenAsReferrals == 0)) {

        RELEASE_LOCK( &connection->StateLock);

        CloseLdapConnection( connection );

    }
    else {

        RELEASE_LOCK( &connection->StateLock);
    }

    DereferenceLdapConnection( connection );

    return LDAP_SUCCESS;
}


ULONG __cdecl
ldap_unbind_s (
    LDAP *ExternalHandle
    )
{
    return( ldap_unbind( ExternalHandle ) );
}

VOID
CloseLdapConnection (
    IN PLDAP_CONN Connection
    )

/*++

Routine Description:

    This function closes a connection (virtual circuit).

    *** This routine must NOT be entered with the connection lock held!

Arguments:

    Connection - Supplies a pointer to a Connection Block

Return Value:

    None.

--*/

{
    CLdapBer *lber;
    LONG messageNumber = 0;
    ULONG err;
    PLIST_ENTRY listEntry;
    PLDAP_MESSAGEWAIT waitStructure = NULL;

    ASSERT( Connection != NULL );

    //
    // Acquire the lock that guards the connection's state field.
    //

    ACQUIRE_LOCK( &Connection->StateLock);

    //
    // If the connection hasn't already been closed, do so now.
    //

    if (Connection->ConnObjectState == ConnObjectActive) {

        IF_DEBUG(CONNECTION) {
            LdapPrint1( "Closing connection at %lx\n", Connection );
        }

        Connection->ConnObjectState = ConnObjectClosing;

        RELEASE_LOCK( &Connection->StateLock );

        //
        // Wake up select
        //

        LdapWakeupSelect();

        //
        //  Signal all waiting threads.  This should cause the waiting thread
        //  to delete the wait block.
        //

        ACQUIRE_LOCK( &ConnectionListLock );

        listEntry = GlobalListWaiters.Flink;

        while (listEntry != &GlobalListWaiters) {

            waitStructure = CONTAINING_RECORD( listEntry,
                                               LDAP_MESSAGEWAIT,
                                               WaitListEntry );
            listEntry = listEntry->Flink;

            if (waitStructure->Connection == Connection) {

                waitStructure->Satisfied = TRUE;
                SetEvent( waitStructure->Event );
            }
        }

        RELEASE_LOCK( &ConnectionListLock );

        if ((Connection->TcpHandle != INVALID_SOCKET) &&
            (Connection->SentPacket == TRUE)          &&
            (Connection->HostConnectState == HostConnectStateConnected)) {

            //
            //  Send the server an unbind message if we actually have a connection
            //  to the server.
            //
            //  the ldapv2 disconnect message looks like this :
            //
            //  UnbindRequest ::= [APPLICATION 2] NULL
            //

            lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

            if (lber != NULL) {

                GET_NEXT_MESSAGE_NUMBER( messageNumber );
                Connection->publicLdapStruct.ld_msgid = messageNumber;

                lber->HrStartWriteSequence();
                lber->HrAddValue( messageNumber );

                lber->HrAddTag(LDAP_UNBIND_CMD);

                lber->HrEndWriteSequence();

                //
                //  send the unbind request.
                //

                err = LdapSend( Connection, lber );

                if (err != LDAP_SUCCESS) {

                    IF_DEBUG(NETWORK_ERRORS) {
                        LdapPrint2( "LdapCloseConn connection 0x%x send with error of 0x%x.\n",
                                    Connection, err );
                    }
                }

                delete lber;

            } else {

                IF_DEBUG(OUTMEMORY) {
                    LdapPrint1( "LdapCloseConn connection 0x%x could not allocate unbind.\n",
                                Connection );
                }
            }
        }

        CloseCredentials( Connection );

        //
        //  Remove all requests where this connection is the primary conn
        //

        ACQUIRE_LOCK( &RequestListLock );

        listEntry = GlobalListRequests.Flink;

        PLDAP_REQUEST request;

        while (listEntry != &GlobalListRequests) {

            request = CONTAINING_RECORD( listEntry, LDAP_REQUEST, RequestListEntry );

            request = ReferenceLdapRequest( request );

            if (!request) {
                listEntry = listEntry->Flink;
                continue;
            }

            if ( (request->PrimaryConnection == Connection) &&
                 (request->Closed == FALSE)) {

                RELEASE_LOCK( &RequestListLock );

                //
                //  CloseLdapMessage MUST remove it from the list or we loop here.
                //

                CloseLdapRequest( request );

                DereferenceLdapRequest( request );

                ACQUIRE_LOCK( &RequestListLock );

                //
                //  We have to start at the top of the list again because the
                //  list may have changed since we freed the lock.  Not the
                //  best, but unless we change the locking order, it will have
                //  to do.
                //

                listEntry = GlobalListRequests.Flink;

            } else {

                listEntry = listEntry->Flink;
                DereferenceLdapRequest( request );
            }
        }

        RELEASE_LOCK( &RequestListLock );

        //
        // We always dereference the connection after we call CloseLdapConnection
        // So, the ref count has to be greater than 1.
        //

        ASSERT( Connection->ReferenceCount > 1 );
        DereferenceLdapConnection( Connection );

        ACQUIRE_LOCK( &Connection->StateLock );

        Connection->ConnObjectState = ConnObjectClosed;

        RELEASE_LOCK( &Connection->StateLock );

    } else {

        RELEASE_LOCK( &Connection->StateLock);
    }

    return;

} // CloseLdapConnection


VOID
DereferenceLdapConnection2 (
    PLDAP_CONN Connection
    )
{
    PLIST_ENTRY receiveList;
    PERROR_ENTRY errorEntry;
    PLIST_ENTRY  errorList;
    PLDAP_RECVBUFFER buffer;
    PSECURESTREAM pSecureStream;
    ULONG CurrentThreadId = GetCurrentThreadId();
    PLIST_ENTRY pThreadListEntry = NULL;

    ASSERT( Connection->ConnObjectState == ConnObjectClosed );

    ldap_msgfree( Connection->BindResponse );

    //
    //  remove from global list of connections
    //

    ACQUIRE_LOCK( &ConnectionListLock );

    if (Connection->ConnectionListEntry.Flink != NULL) {

        RemoveEntryList( &Connection->ConnectionListEntry );
        Connection->ConnectionListEntry.Flink = NULL;
    }
    RELEASE_LOCK( &ConnectionListLock );

    //
    //  delete any partial messages we have allocated.
    //

    if (Connection->PendingMessage != NULL) {

        CLdapBer *lber = (CLdapBer *) Connection->PendingMessage->lm_ber;

        if (lber != NULL) {

            delete lber;
        }
        ldapFree( Connection->PendingMessage, LDAP_MESG_SIGNATURE );
        Connection->PendingMessage = NULL;
    }

    InterlockedDecrement( &GlobalConnectionCount );

    //
    //  now that conn is dead, free all receive buffers allocated for
    //  this connection.
    //

    receiveList = Connection->PendingCryptoList.Flink;
    while (receiveList != &Connection->PendingCryptoList) {

        buffer = CONTAINING_RECORD(   receiveList,
                                      LDAP_RECVBUFFER,
                                      ReceiveListEntry );

        receiveList = receiveList->Flink;

        LdapFreeReceiveStructure( buffer, TRUE );
    }

    receiveList = Connection->CompletedReceiveList.Flink;
    while (receiveList != &Connection->CompletedReceiveList) {

        buffer = CONTAINING_RECORD(   receiveList,
                                      LDAP_RECVBUFFER,
                                      ReceiveListEntry );

        receiveList = receiveList->Flink;

        LdapFreeReceiveStructure( buffer, TRUE );
    }

    //
    // Delete the error and attribute entries corresponding to
    // this connection for all threads.
    //
    ACQUIRE_LOCK( &PerThreadListLock );
    pThreadListEntry = GlobalPerThreadList.Flink;

    // iterate through each thread's THREAD_ENTRY
    while (pThreadListEntry != &GlobalPerThreadList) {
        PTHREAD_ENTRY pThreadEntry = NULL;

        PERROR_ENTRY pErrorEntry;
        PERROR_ENTRY * ppNextError;

        PLDAP_ATTR_NAME_THREAD_STORAGE pAttrEntry;
        PLDAP_ATTR_NAME_THREAD_STORAGE * ppNextAttr;
        
        pThreadEntry = CONTAINING_RECORD( pThreadListEntry, THREAD_ENTRY, ThreadEntry );
        pThreadListEntry = pThreadListEntry->Flink;

        // error entries
        pErrorEntry = pThreadEntry->pErrorList;
        ppNextError = &(pThreadEntry->pErrorList);

        while (pErrorEntry) {

            if (pErrorEntry->Connection == Connection) {
                *ppNextError = pErrorEntry->pNext;

                if (pErrorEntry->ErrorMessage != NULL) {

                    ldap_memfreeW( pErrorEntry->ErrorMessage );
                    pErrorEntry->ErrorMessage = NULL;
                }
                
                ldapFree( pErrorEntry, LDAP_ERROR_SIGNATURE );
                break;
            }

            ppNextError = &(pErrorEntry->pNext);
            pErrorEntry = pErrorEntry->pNext;
        }

        // attribute entries
        pAttrEntry = pThreadEntry->pCurrentAttrList;
        ppNextAttr = &(pThreadEntry->pCurrentAttrList);

        while (pAttrEntry) {

            if (pAttrEntry->PrimaryConn == Connection) {
                *ppNextAttr = pAttrEntry->pNext;
                ldapFree( pAttrEntry, LDAP_ATTR_THREAD_SIGNATURE );
                break;
            }

            ppNextAttr = &(pAttrEntry->pNext);
            pAttrEntry = pAttrEntry->pNext;
        }
        
    }
    
    RELEASE_LOCK( &PerThreadListLock );


    pSecureStream = (PSECURESTREAM) Connection->SecureStream;
    delete pSecureStream;

    DELETE_LOCK( &Connection->ScramblingLock );

    Connection->ExternalInfo = NULL;        // cause GET_CONN_POINTER to fail

    if (Connection->ConnectEvent != NULL) {

        CloseHandle( Connection->ConnectEvent );
    }

    if (GlobalDrainWinsockThread != CurrentThreadId) {
        
        //
        // Make sure there is no thread in DrainWinsock.
        //

        BeginSocketProtection( Connection );
    
    } else {

        //
        // We are being called from DrainWinsock. Since, we 
        // already own SelectLock1, we should not try to grab
        // SelectLock2 or we might deadlock.
        //

        ACQUIRE_LOCK( &Connection->SocketLock );
    }

    if (Connection->TcpHandle != INVALID_SOCKET) {

        int sockerr = (*pclosesocket)(Connection->TcpHandle);
        ASSERT(sockerr == 0); 
        Connection->TcpHandle = INVALID_SOCKET;
    }

    if (Connection->UdpHandle != INVALID_SOCKET) {

        int sockerr = (*pclosesocket)(Connection->UdpHandle);
        ASSERT(sockerr == 0); 
        Connection->UdpHandle = INVALID_SOCKET;
    }

    if (GlobalDrainWinsockThread != GetCurrentThreadId()) {
        
        EndSocketProtection( Connection );

    } else {

        RELEASE_LOCK( &Connection->SocketLock );
    }

    DELETE_LOCK( &Connection->SocketLock );
    DELETE_LOCK( &Connection->ReconnectLock );
    DELETE_LOCK( &Connection->StateLock );

    ldapFree( Connection->DNOnBind, LDAP_USER_DN_SIGNATURE );
    ldapFree( Connection->ListOfHosts, LDAP_HOST_NAME_SIGNATURE );
    ldapFree( Connection->ServiceNameForBind, LDAP_SERVICE_NAME_SIGNATURE );
    ldapFree( Connection->publicLdapStruct.ld_host, LDAP_HOST_NAME_SIGNATURE );

    if (Connection->ExplicitHostName != Connection->ListOfHosts) {

        ldapFree( Connection->ExplicitHostName, LDAP_HOST_NAME_SIGNATURE );
    }

    if (( Connection->HostNameW != Connection->ExplicitHostName ) &&
       ( Connection->HostNameW != Connection->ListOfHosts )) {

        ldapFree( Connection->HostNameW, LDAP_HOST_NAME_SIGNATURE );
    }

    if (Connection->DnsSuppliedName) {
       ldapFree( Connection->DnsSuppliedName, LDAP_HOST_NAME_SIGNATURE );
       Connection->DnsSuppliedName = NULL;
    }

    if (Connection->DomainName != NULL) {
       ldapFree( Connection->DomainName, LDAP_HOST_NAME_SIGNATURE );
       Connection->DomainName = NULL;
    }

    if (Connection->OptHostNameA != NULL) {
        ldapFree(Connection->OptHostNameA, LDAP_BUFFER_SIGNATURE);
        Connection->OptHostNameA = NULL;
    }

    if (Connection->SaslMethod != NULL) {
        ldapFree( Connection->SaslMethod, LDAP_SASL_SIGNATURE );
        Connection->SaslMethod = NULL;
    }

    FreeCurrentCredentials( Connection );

    ldapFree( Connection, LDAP_CONN_SIGNATURE );

    return;
}

// unbind.c eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\ber.h ===
//+---------------------------------------------------------------------------
//
//
//  File:       ber.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-10-95   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __BER_H__
#define __BER_H__

#if	DBG

#define BER_UNIVERSAL           0x00
#define BER_APPLICATION         0x40
#define BER_CONTEXT_SPECIFIC    0x80
#define BER_PRIVATE             0xC0

#define BER_PRIMITIVE           0x00
#define BER_CONSTRUCTED         0x20

#define BER_BOOL                1
#define BER_INTEGER             2
#define BER_BIT_STRING          3
#define BER_OCTET_STRING        4
#define BER_NULL                5
#define BER_OBJECT_ID           6
#define BER_OBJECT_DESC         7
#define BER_EXTERNAL            8
#define BER_REAL                9
#define BER_ENUMERATED          10

#define BER_SEQUENCE            16
#define BER_SET                 17

#define BER_NUMERIC_STRING      0x12
#define BER_PRINTABLE_STRING    0x13
#define BER_TELETEX_STRING      0x14
#define BER_VIDEOTEX_STRING     0x15
#define BER_GRAPHIC_STRING      0x19
#define BER_VISIBLE_STRING      0x1A
#define BER_GENERAL_STRING      0x1B

#define BER_UTC_TIME            23

typedef VOID (* OutputFn)(char *, ...);
typedef BOOL (* StopFn)(void);

#ifndef	EXTERN_C
#ifdef	__cplusplus
#define	EXTERN_C extern "C"
#else
#define	EXTERN_C
#endif
#endif

EXTERN_C
int
ber_decode(
    OutputFn Out,
    StopFn  Stop,
    LPBYTE  pBuffer,
    DWORD   Flags,
    int   Indent,
    int   Offset,
    int   TotalLength,
    int   BarDepth);

#define DECODE_NEST_OCTET_STRINGS   0x00000001
#define DECODE_VERBOSE_OIDS         0x00000002

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\utf8.cxx ===
/*++

Copyright (c) 1991-1996,  Microsoft Corporation  All rights reserved.

Module Name:

    utf.c

Abstract:

    This file contains functions that convert UTF strings to Unicode
    strings and Unicode string to UTF strings.

    External Routines found in this file:
      UTFCPInfo
      UTFToUnicode
      UnicodeToUTF

Revision History:

    02-06-96    JulieB    Created.
    03-05-97    AndyHe    Hacked up a piece of it for LDAP client since
                          Win9x doesn't have UTF-8 codepage available.
    06-29-99    AnoopA    Added Surrogate UTF-8 surrogate pair support.

--*/



//
//  Include Files.
//
#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

//
//  Constant Declarations.
//

#define ASCII             0x007f

#define SHIFT_IN          '+'     // beginning of a shift sequence
#define SHIFT_OUT         '-'     // end       of a shift sequence

#define UTF8_2_MAX        0x07ff  // max UTF8 2-byte sequence (32 * 64 = 2048)
#define UTF8_1ST_OF_2     0xc0    // 110x xxxx
#define UTF8_1ST_OF_3     0xe0    // 1110 xxxx
#define UTF8_1ST_OF_4         0xf0    // 1111 xxxx
#define UTF8_TRAIL        0x80    // 10xx xxxx

#define HIGHER_6_BIT(u)    ((u) >> 12)
#define MIDDLE_6_BIT(u)   (((u) & 0x0fc0) >> 6)
#define LOWER_6_BIT(u)    ((u) & 0x003f)

#define BIT7(a)           ((a) & 0x80)
#define BIT6(a)           ((a) & 0x40)

#define HIGH_SURROGATE_START  0xd800
#define HIGH_SURROGATE_END    0xdbff
#define LOW_SURROGATE_START   0xdc00
#define LOW_SURROGATE_END     0xdfff

////////////////////////////////////////////////////////////////////////////
//
//  UTF8ToUnicode
//
//  Maps a UTF-8 character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

WINLDAPAPI int LDAPAPI LdapUTF8ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest)
{
    int nTB = 0;                   // # trail bytes to follow
    int cchWC = 0;                 // # of Unicode code points generated
    LPCSTR pUTF8 = lpSrcStr;
    DWORD dwSurrogateChar = 0;     // Full surrogate char
    BOOL bSurrogatePair = FALSE;   // Indicate we'r collecting a surrogate pair
    char UTF8;


    while ((cchSrc--) && ((cchDest == 0) || (cchWC < cchDest)))
    {
        //
        //  See if there are any trail bytes.
        //
        if (BIT7(*pUTF8) == 0)
        {
            //
            //  Found ASCII.
            //
            if (cchDest)
            {
                lpDestStr[cchWC] = (WCHAR)*pUTF8;
            }
            bSurrogatePair = FALSE;
            cchWC++;
        }
        else if (BIT6(*pUTF8) == 0)
        {
            //
            //  Found a trail byte.
            //  Note : Ignore the trail byte if there was no lead byte.
            //
            if (nTB != 0)
            {
                //
                //  Decrement the trail byte counter.
                //
                nTB--;

                if (bSurrogatePair)
                {
                    dwSurrogateChar <<= 6;
                    dwSurrogateChar |= LOWER_6_BIT(*pUTF8);

                    if (nTB == 0)
                    {
                        if (cchDest)
                        {
                            if ((cchWC + 1) < cchDest)
                            {
                                lpDestStr[cchWC]   = (WCHAR)
                                                     (((dwSurrogateChar - 0x10000) >> 10) + HIGH_SURROGATE_START);

                                lpDestStr[cchWC+1] = (WCHAR)
                                                     ((dwSurrogateChar - 0x10000)%0x400 + LOW_SURROGATE_START);
                            }
                        }

                        cchWC += 2;
                        bSurrogatePair = FALSE;
                    }
                }
                else
                {
                    //
                    //  Make room for the trail byte and add the trail byte
                    //  value.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] <<= 6;
                        lpDestStr[cchWC] |= LOWER_6_BIT(*pUTF8);
                    }

                    if (nTB == 0)
                    {
                        //
                        //  End of sequence.  Advance the output counter.
                        //
                        cchWC++;
                    }
                }
            }
            else
            {
                // error - not expecting a trail byte
                bSurrogatePair = FALSE;
            }
        }
        else
        {
            //
            //  Found a lead byte.
            //
            if (nTB > 0)
            {
                //
                //  Error - previous sequence not finished.
                //
                nTB = 0;
                bSurrogatePair = FALSE;
                cchWC++;
            }
            else
            {
                //
                //  Calculate the number of bytes to follow.
                //  Look for the first 0 from left to right.
                //
                UTF8 = *pUTF8;
                while (BIT7(UTF8) != 0)
                {
                    UTF8 <<= 1;
                    nTB++;
                }

                //
                // If this is a surrogate unicode pair
                //
                if (nTB == 4)
                {
                    dwSurrogateChar = UTF8 >> nTB;
                    bSurrogatePair = TRUE;
                }

                //
                //  Store the value from the first byte and decrement
                //  the number of bytes to follow.
                //
                if (cchDest)
                {
                    lpDestStr[cchWC] = UTF8 >> nTB;
                }
                nTB--;
            }
        }

        pUTF8++;
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of Unicode characters written.
    //
    SetLastError(ERROR_SUCCESS);
    return (cchWC);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF8
//
//  Maps a Unicode character string to its UTF-8 string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

WINLDAPAPI int LDAPAPI LdapUnicodeToUTF8(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest)
{
    LPCWSTR lpWC = lpSrcStr;
    int     cchU8 = 0;                // # of UTF8 chars generated
    DWORD   dwSurrogateChar;
    WCHAR   wchHighSurrogate = 0;
    BOOL    bHandled;


    while ((cchSrc--) && ((cchDest == 0) || (cchU8 < cchDest)))
    {
        bHandled = FALSE;

        //
        // Check if high surrogate is available
        //
        if ((*lpWC >= HIGH_SURROGATE_START) && (*lpWC <= HIGH_SURROGATE_END))
        {
            if (cchDest)
            {
                // Another high surrogate, then treat the 1st as normal
                // Unicode character.
                if (wchHighSurrogate)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
                    }
                    else
                    {
                        // not enough buffer
                        cchSrc++;
                        break;
                    }
                }
            }
            else
            {
                cchU8 += 3;
            }
            wchHighSurrogate = *lpWC;
            bHandled = TRUE;
        }

        if (!bHandled && wchHighSurrogate)
        {
            if ((*lpWC >= LOW_SURROGATE_START) && (*lpWC <= LOW_SURROGATE_END))
            {
                 // wheee, valid surrogate pairs

                 if (cchDest)
                 {
                     if ((cchU8 + 3) < cchDest)
                     {
                         dwSurrogateChar = (((wchHighSurrogate-0xD800) << 10) + (*lpWC - 0xDC00) + 0x10000);

                         lpDestStr[cchU8++] = (UTF8_1ST_OF_4 |
                                               (unsigned char)(dwSurrogateChar >> 18));           // 3 bits from 1st byte

                         lpDestStr[cchU8++] =  (UTF8_TRAIL |
                                                (unsigned char)((dwSurrogateChar >> 12) & 0x3f)); // 6 bits from 2nd byte

                         lpDestStr[cchU8++] = (UTF8_TRAIL |
                                               (unsigned char)((dwSurrogateChar >> 6) & 0x3f));   // 6 bits from 3rd byte

                         lpDestStr[cchU8++] = (UTF8_TRAIL |
                                               (unsigned char)(0x3f & dwSurrogateChar));          // 6 bits from 4th byte
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
                 else
                 {
                     // we already counted 3 previously (in high surrogate)
                     cchU8 += 1;
                 }

                 bHandled = TRUE;
            }
            else
            {
                 // Bad Surrogate pair : ERROR
                 // Just process wchHighSurrogate , and the code below will
                 // process the current code point
                 if (cchDest)
                 {
                     if ((cchU8 + 2) < cchDest)
                     {
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
            }

            wchHighSurrogate = 0;
        }

        if (!bHandled)
        {
            if (*lpWC <= ASCII)
            {
                //
                //  Found ASCII.
                //
                if (cchDest)
                {
                    lpDestStr[cchU8] = (char)*lpWC;
                }
                cchU8++;
            }
            else if (*lpWC <= UTF8_2_MAX)
            {
                //
                //  Found 2 byte sequence if < 0x07ff (11 bits).
                //
                if (cchDest)
                {
                    if ((cchU8 + 1) < cchDest)
                    {
                        //
                        //  Use upper 5 bits in first byte.
                        //  Use lower 6 bits in second byte.
                        //
                        lpDestStr[cchU8++] = UTF8_1ST_OF_2 | (*lpWC >> 6);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 2;
                }
            }
            else
            {
                //
                //  Found 3 byte sequence.
                //
                if (cchDest)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        //
                        //  Use upper  4 bits in first byte.
                        //  Use middle 6 bits in second byte.
                        //  Use lower  6 bits in third byte.
                        //
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(*lpWC);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(*lpWC);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 3;
                }
            }
        }

        lpWC++;
    }

    //
    // If the last character was a high surrogate, then handle it as a normal
    // unicode character.
    //
    if ((cchSrc < 0) && (wchHighSurrogate != 0))
    {
        if (cchDest)
        {
            if ((cchU8 + 2) < cchDest)
            {
                lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
            }
            else
            {
                cchSrc++;
            }
        }
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }
    
    //
    //  Return the number of UTF-8 characters written.
    //
    return (cchU8);
}

// utf8.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\util.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c  utility routines for LDAP client DLL

Abstract:

   This module contains general utility routines for LDAP client DLL.

Author:

    Andy Herron (andyhe)        08-May-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG LdapAllocatedHeap = 0;

FNLOADSTRINGA pfLoadStringA = NULL;
FNWSPRINTFW pfwsprintfW = NULL;
FNMESAGEBOXW pfMessageBoxW = NULL;
BOOLEAN Faileduser32LoadLib = FALSE;
HINSTANCE USER32LibraryHandle = NULL;


PLDAP_CONN
GetConnectionPointer(
    LDAP *ExternalHandle
    )
{
    PLDAP_CONN connection = NULL;

    __try
    {
        if (ExternalHandle == NULL)
            return NULL;

        connection = (PLDAP_CONN)((PCHAR)ExternalHandle - FIELD_OFFSET(LDAP_CONN, TcpHandle));

        if (connection->ExternalInfo != ExternalHandle)
            return NULL;

        ACQUIRE_LOCK( &connection->StateLock );

        if (connection->ReferenceCount == 0) {

            RELEASE_LOCK( &connection->StateLock );
            return NULL;
        }

        if (connection->ConnObjectState != ConnObjectActive) {

            RELEASE_LOCK( &connection->StateLock );
            return NULL;
        }

        connection->ReferenceCount++;

        RELEASE_LOCK( &connection->StateLock );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return NULL;
    }

    return connection;
}

PLDAP_CONN
GetConnectionPointer2(
    LDAP *ExternalHandle
    )
{
    //
    // Special routine called during ldap_get_option and ldap_msgfree to reference
    // a connection which may have been closed. Note that we don't care about the
    // state of the connection during this operation.
    //

    PLDAP_CONN connection = NULL;

    __try
    {
        if (ExternalHandle == NULL)
            return NULL;

        connection = (PLDAP_CONN)((PCHAR)ExternalHandle - FIELD_OFFSET(LDAP_CONN, TcpHandle));

        if (connection->ExternalInfo != ExternalHandle)
            return NULL;

        ACQUIRE_LOCK( &connection->StateLock );

        if (connection->ReferenceCount == 0) {

            RELEASE_LOCK( &connection->StateLock );
            return NULL;
        }

        connection->ReferenceCount++;

        RELEASE_LOCK( &connection->StateLock );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return NULL;
    }

    return connection;
}

PLDAP_CONN
ReferenceLdapConnection(
    PLDAP_CONN connection
    )
{
    __try
    {
        if (connection == NULL)
            return NULL;

        ACQUIRE_LOCK( &connection->StateLock );

        if (connection->ReferenceCount == 0) {

            RELEASE_LOCK( &connection->StateLock );
            return NULL;
        }

        if (connection->ConnObjectState != ConnObjectActive) {

            RELEASE_LOCK( &connection->StateLock );
            return NULL;
        }

        connection->ReferenceCount++;

        RELEASE_LOCK( &connection->StateLock );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return NULL;
    }

    return connection;
}

PLDAP_REQUEST
ReferenceLdapRequest(
    PLDAP_REQUEST request
    )
{
    __try
    {
        if ( request == NULL)
            return NULL;

        ACQUIRE_LOCK( &request->Lock );

        if (request->ReferenceCount == 0) {

            RELEASE_LOCK( &request->Lock );
            return NULL;
        }

        request->ReferenceCount++;

        RELEASE_LOCK( &request->Lock );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return NULL;
    }

    return request;
}

LPVOID
ldapMalloc (
    DWORD Bytes,
    ULONG Tag
    )
{
    PLDAP_MEMORY_DESCRIPTOR allocBlock;

#if 0
    ASSERT( HeapValidate( LdapHeap, 0, 0 ) );
#endif

    allocBlock = (PLDAP_MEMORY_DESCRIPTOR) HeapAlloc( LdapHeap,
                            HEAP_ZERO_MEMORY,
                            Bytes + sizeof( LDAP_MEMORY_DESCRIPTOR ));

    IF_DEBUG(HEAP) {
        LdapPrint3( "ldapMalloc allocated 0x%x bytes at addr 0x%x of tag 0x%x.\n",
                Bytes, allocBlock, Tag );
    }

    if (allocBlock != NULL) {

        allocBlock->Tag = Tag;
        allocBlock->Length = Bytes;

        allocBlock++;   // skip over memory block descriptor

        LdapAllocatedHeap += Bytes;
    }

    IF_DEBUG(HEAP) {
        LdapPrint4( "ldapMalloc 0x%08x bytes at addr 0x%x of tag %x, tot=%d.\n",
                    Bytes, allocBlock, Tag, LdapAllocatedHeap );
    }

    return allocBlock;
}

VOID
ldapFree (
    LPVOID Block,
    ULONG  Tag
    )
{
    PLDAP_MEMORY_DESCRIPTOR allocBlock;

    if (Block == NULL) {
        return;
    }

    allocBlock = (PLDAP_MEMORY_DESCRIPTOR) Block;
    allocBlock--;   // point to header

    if (allocBlock->Tag == LDAP_DONT_FREE_SIGNATURE) {
        return;
    }

    if (allocBlock->Tag == LDAP_FREED_SIGNATURE) {

        LdapPrint1("Freeing memory at 0x%x which is already freed\n", Block);
        ASSERT( allocBlock->Tag != LDAP_FREED_SIGNATURE );
    }

    IF_DEBUG(HEAP) {
        LdapPrint3( "ldapfree freed       0x%x bytes at addr 0x%x of tag 0x%x.\n",
                allocBlock->Length, allocBlock, Tag );
    }


    if (allocBlock->Tag != Tag) {

        LdapPrint2("Expected tag 0x%x but found tag 0x%x\n", Tag, allocBlock->Tag );
        ASSERT( allocBlock->Tag == Tag );
    }


    LdapAllocatedHeap -= allocBlock->Length;

    IF_DEBUG(HEAP) {
       LdapPrint4( "ldapFree   0x%08x bytes at addr 0x%x of tag %x, tot=%d.\n",
                    allocBlock->Length, Block, Tag, LdapAllocatedHeap );
    }

    IF_DEBUG(HEAP) {
        ASSERT( HeapValidate( LdapHeap, 0, 0 ) );
    }

#if 0
    ASSERT( HeapValidate( LdapHeap, 0, 0 ) );
#endif

    allocBlock->Tag = LDAP_FREED_SIGNATURE;
    HeapFree( LdapHeap, 0, allocBlock );

    return;
}

BOOLEAN
ldapSwapTags (
    LPVOID Block,
    ULONG  OldTag,
    ULONG  NewTag
    )
{
    PLDAP_MEMORY_DESCRIPTOR allocBlock;
    BOOLEAN rc;

    if (Block == NULL) {
        return FALSE;
    }

    allocBlock = (PLDAP_MEMORY_DESCRIPTOR) Block;
    allocBlock--;   // point to header

    rc = (( allocBlock->Tag == OldTag ) ? TRUE : FALSE );

    allocBlock->Tag = NewTag;

    IF_DEBUG(HEAP) {
       ASSERT( HeapValidate( LdapHeap, 0, allocBlock ) );
    }

    return rc;
}


PLDAP_RECVBUFFER
LdapGetReceiveStructure (
    DWORD cbBuffer
    )
//
//  This routine allocates a receive buffer for a connection and puts it on
//  the pending list for the connection.  It then posts the receive to the
//  transport for overlapped i/o.
//
{
    PLDAP_RECVBUFFER receiveBuffer;

    receiveBuffer = (PLDAP_RECVBUFFER) ldapMalloc( sizeof( LDAP_RECVBUFFER ) +
                                                   cbBuffer,
                                                   LDAP_RECV_SIGNATURE );

    if (receiveBuffer == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap GetReceiveStructure failed alloc of 0x%x.\n",
                        sizeof( LDAP_RECVBUFFER ) +
                        INITIAL_MAX_RECEIVE_BUFFER );
        }

        return NULL;
    }

    //
    //  zero filled from malloc.  Fill in rest of fields.
    //

    receiveBuffer->BufferSize = cbBuffer;

    return receiveBuffer;
}

VOID
LdapFreeReceiveStructure (
    IN PLDAP_RECVBUFFER ReceiveBuffer,
    IN BOOLEAN HaveLock
    )
{
    PLDAP_CONN connection;

    connection = (PLDAP_CONN) InterlockedExchangePointer(  (PVOID *) &ReceiveBuffer->Connection,
                                                           NULL );

    if (connection != NULL) {

        if (!HaveLock) {
            ACQUIRE_LOCK( &ConnectionListLock );
        }

        RemoveEntryList( &ReceiveBuffer->ReceiveListEntry );

        if (!HaveLock) {
            RELEASE_LOCK( &ConnectionListLock );
        }
    }

    ldapFree( ReceiveBuffer, LDAP_RECV_SIGNATURE );

    return;
}


PLDAP_MESSAGEWAIT
LdapGetMessageWaitStructure (
    IN PLDAP_CONN Connection,
    IN ULONG CompleteMessages,
    IN ULONG MessageNumber,
    IN BOOLEAN PendingSendOnly
    )
//
//  The structure returned can has a few fields of interest :
//    - event for thread to wait on that is triggered when message comes in
//    - message number that waiting thread is interested in (none if interested
//      in all messages from server)
//    - list entry for per connection list of outstanding wait structures
//
{
    PLDAP_MESSAGEWAIT message = NULL;
    HANDLE event;

    event = CreateEvent( NULL, FALSE, FALSE, NULL );

    if (event == NULL) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "ldap GetMessageWaitStructure conn 0x%x failed alloc of event.\n",
                            Connection );
        }

        return NULL;
    }

    message = (PLDAP_MESSAGEWAIT) ldapMalloc( sizeof( LDAP_MESSAGEWAIT ),
                                                      LDAP_WAIT_SIGNATURE );

    if (message == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint2( "ldap GetMessageWaitStructure conn 0x%x failed alloc of 0x%x.\n",
                            Connection,
                            sizeof( LDAP_MESSAGEWAIT ));
        }

        CloseHandle( event );
        return NULL;
    }

    //
    //  zero filled from malloc.  Fill in rest of fields.
    //

    if (Connection != NULL) {

        //
        // Note that this can fail and return NULL if the
        // connection is being closed. This is fine, we'll
        // store NULL in the wait structure and it will
        // be taken care of when the structure is freed.
        //

        Connection = ReferenceLdapConnection( Connection );
    }

    message->Connection = Connection;
    message->MessageNumber = MessageNumber;
    message->Event = event;
    message->Satisfied = FALSE;
    message->MessageNumber = MessageNumber;
    message->AllOfMessage = CompleteMessages;
    message->PendingSendOnly = PendingSendOnly;

    ResetEvent( event );

    ACQUIRE_LOCK( &ConnectionListLock );
    InsertTailList( &GlobalListWaiters, &message->WaitListEntry );
    GlobalWaiterCount++;
    RELEASE_LOCK( &ConnectionListLock );

    return( message );
}

VOID
LdapFreeMessageWaitStructure (
    PLDAP_MESSAGEWAIT Message
    )
//
//  Free the wait structure.  The connectionListLock must be held here.
//
{
    PLDAP_CONN connection = Message->Connection;

    RemoveEntryList( &Message->WaitListEntry );
    GlobalWaiterCount--;

    //
    //  if this is the last waiter and we're shutting down, clear the
    //  shutdown event.
    //

    if ((GlobalWaiterCount == 0) &&
        (GlobalLdapShuttingDown == TRUE) &&
        (GlobalLdapShutdownEvent != NULL)) {

        SetEvent( GlobalLdapShutdownEvent );
    }

    if (connection != NULL) {

        DereferenceLdapConnection( connection );
    }

    CloseHandle( Message->Event );

    ldapFree( Message, LDAP_WAIT_SIGNATURE );

    return;
}


VOID
SetConnectionError (
    PLDAP_CONN Connection,
    ULONG   LdapError,
    PCHAR   DNNameInError
    )
{
    if (GlobalTlsLastErrorIndex != 0xFFFFFFFF) {

        TlsSetValue( GlobalTlsLastErrorIndex, UIntToPtr( LdapError ));
    }

    if ((Connection != NULL) && (LoadUser32Now())) {

        Connection->publicLdapStruct.ld_errno = LdapError;

        if ((int) LdapError < LDAP_SUCCESS ||
            LdapError > LDAP_MAX_ERROR_STRINGS) {

            IF_DEBUG(API_ERRORS) {
                LdapPrint1( "ldap SetConnectionError do not have text for message 0x%x.\n",
                                LdapError );
            }

            Connection->publicLdapStruct.ld_error = LdapErrorStrings[LDAP_OTHER];

        } else {

            Connection->publicLdapStruct.ld_error = LdapErrorStrings[LdapError];
        }
        Connection->publicLdapStruct.ld_matched = DNNameInError;

        if (*(Connection->publicLdapStruct.ld_error) == '\0') {

            IF_DEBUG(API_ERRORS) {
                LdapPrint1( "ldap SetConnectionError do not have text for message 0x%x.\n",
                                LdapError );
            }
            Connection->publicLdapStruct.ld_error = LdapErrorStrings[LDAP_OTHER];
        }
    }

    return;
}

ULONG __cdecl
ldap_msgfree (
    LDAPMessage *res
    )
{
    PLDAPMessage nextMessage;
    LBER *lber;

    if (res == NULL) {

        return LDAP_SUCCESS;
    }

    //
    //  free this plus all chained messages
    //

    while (res != NULL) {

        ASSERT( res->lm_next == NULL );

        nextMessage = res->lm_chain;

        lber = (LBER *) res->lm_ber;

        if (lber != NULL) {
            delete lber;
        }

        if (res->ConnectionReferenced && res->Connection != NULL) {

            PLDAP_CONN connection = NULL;

            //
            // We need to reference the connection even if it is in a closed
            // state. Hence the call to GetConnectionPointer2.
            //

            connection = GetConnectionPointer2(res->Connection);

            if (connection != NULL) {
                
                IF_DEBUG(REFCNT) {
                    LdapPrint2("Derefing Conn 0x%x with ref count 0x%x\n", connection, connection->ReferenceCount);
                }
                DereferenceLdapConnection( connection );
                
                //
                // Our intent is to dereference it - do it twice to compensate for
                // GetConnectionPointer2 referencing it again
                //
                
                DereferenceLdapConnection( connection );
                res->Connection = NULL;
            
            } else {
                IF_DEBUG(ERRORS) {
                    LdapPrint1("Referencing Conn 0x%x failed.\n", res->Connection);
                }
            }
        }

        ldapFree( res, LDAP_MESG_SIGNATURE );
        res = nextMessage;
    }

    return LDAP_SUCCESS;
}

PWCHAR __cdecl
ldap_err2stringW (
    ULONG err
    )
{
    PWCHAR msg = NULL;

    if (!LoadUser32Now()) {
       return NULL;
    }

    if (err < LDAP_MAX_ERROR_STRINGS ) {

        msg = &LdapErrorStringsW[err][0];
    }

    if (msg == NULL) {

        msg = &LdapErrorStringsW[LDAP_LOCAL_ERROR][0];
    }

    return msg;
}

PCHAR __cdecl
ldap_err2string (
    ULONG err
    )
{
    PCHAR msg = NULL;

    if (!LoadUser32Now()) {
       return NULL;
    }

    if (err < LDAP_MAX_ERROR_STRINGS ) {

        msg = &LdapErrorStrings[err][0];
    }

    if (msg == NULL) {

        msg = &LdapErrorStrings[LDAP_LOCAL_ERROR][0];
    }

    return msg;
}

void __cdecl
ldap_perror (
    LDAP *ld,
    PCHAR msg
    )
{
    //
    //  This is suppose to bring up a dialog showing the user what the
    //  error is.  Not useful in this implementation.
    //

    return;
}


VOID  __cdecl
ldap_memfree(
    PCHAR  Block
    )
{
    ULONG tag = LDAP_BUFFER_SIGNATURE;

    //
    //  This is used to free allocated DNs etc where there is no explicit free.
    //

    if (Block != NULL) {

        PLDAP_MEMORY_DESCRIPTOR allocBlock;

        allocBlock = (PLDAP_MEMORY_DESCRIPTOR) Block;
        allocBlock--;   // point to header

        if ( allocBlock->Tag == LDAP_GENERATED_DN_SIGNATURE ) {

            tag = LDAP_GENERATED_DN_SIGNATURE;

        } else if ( allocBlock->Tag == LDAP_VALUE_SIGNATURE ) {

            tag = LDAP_VALUE_SIGNATURE;

        } else if ( allocBlock->Tag == LDAP_ERROR_SIGNATURE ) {

            tag  = LDAP_ERROR_SIGNATURE;

        } if ( allocBlock->Tag == LDAP_CONTROL_SIGNATURE ) {

            tag = LDAP_CONTROL_SIGNATURE;
        }

        ldapFree( Block, tag );
    }
    return;
}


VOID  __cdecl
ldap_memfreeW(
    PWCHAR  Block
    )
{
    ldap_memfree( (PCHAR) Block );
    return;
}

//
//  misc functions for debugging etc.
//

ULONG __cdecl
ldap_set_dbg_flags (
    ULONG NewFlags
    )
//
//  Set the debug out flags to whatever is passed in.
//
{
    ULONG oldValue = LdapDebug;

#if LDAPDBG
        LdapPrint2( "ldap_set_dbg_flags setting debug outs to 0x%x, old value = 0x%x.\n",
                          NewFlags, oldValue );
#endif

    LdapDebug = NewFlags;
    return oldValue;
}

typedef ULONG (_cdecl *DBGPRINT)( PCH Format, ... );

VOID __cdecl
ldap_set_dbg_routine (
    DBGPRINT DebugPrintRoutine
    )
//
//  Set the debugout routine to whatever is passed in.
//
{
#if LDAPDBG
    if (DebugPrintRoutine == NULL) {

        LdapPrint0( "ldap_set_dbg_routine setting routine back to NULL.\n" );

//      GlobalLdapDbgPrint = DbgPrint;
        GlobalLdapDbgPrint = NULL;

        LdapPrint0( "ldap_set_dbg_routine setting routine back to DbgPrint.\n" );

    } else {

        LdapPrint1( "ldap_set_dbg_routine setting routine to 0x%x.\n", DebugPrintRoutine );

        GlobalLdapDbgPrint = DebugPrintRoutine;

        LdapPrint1( "ldap_set_dbg_routine setting routine to 0x%x.\n", DebugPrintRoutine );
    }
#endif

    return;
}

PCHAR
ldap_dup_string (
    PCHAR String,
    ULONG Extra,
    ULONG Tag
    )
{
    PCHAR newString;
    PCHAR ptr = String;
    ULONG i = 1;

    if (String == NULL) {
        return NULL;
    }

    while (*ptr != '\0') {
        ptr++;
        i++;
    }

    newString = (PCHAR) ldapMalloc( i + Extra, Tag );

    if (newString == NULL) {
        return NULL;
    }

    CopyMemory( newString, String, i );

    return newString;
}

PWCHAR
ldap_dup_stringW (
    PWCHAR String,
    ULONG Extra,
    ULONG Tag
    )
{
    PWCHAR newString;
    PWCHAR ptr = String;
    ULONG i = 1;

    if (String == NULL) {
        return NULL;
    }

    while (*ptr != L'\0') {
        ptr++;
        i++;
    }

    newString = (PWCHAR) ldapMalloc( (i + Extra) * sizeof(WCHAR), Tag );

    if (newString == NULL) {
        return NULL;
    }

    CopyMemory( newString, String, i * sizeof(WCHAR) );

    return newString;
}

#define INITIAL_NUMBER_OF_ENTRIES   6

ULONG
add_string_to_list (
    PWCHAR **ArrayToReturn,
    ULONG *ArraySize,
    PWCHAR StringToAdd,
    BOOLEAN CreateCopy
    )
//
//  This routine adds a duplicate of a string to an array of strings
//  by allocating both the duplicate and the array (if necessary).
//
//  Returns number of entries in the list, 0 if couldn't allocate
//
{
    PWCHAR string;
    PWCHAR *arrayEntries;
    ULONG entryCount = 1;
    ULONG totalEntries = *ArraySize;

    if (CreateCopy) {

        string = ldap_dup_stringW( StringToAdd, 0, LDAP_VALUE_SIGNATURE );

    } else {

        string = StringToAdd;
    }

    if (string == NULL) {

        return 0;
    }

    if (*ArrayToReturn == NULL) {

        arrayEntries = (PWCHAR *) ldapMalloc( INITIAL_NUMBER_OF_ENTRIES * sizeof( PWCHAR ),
                                              LDAP_VALUE_LIST_SIGNATURE );

        if (arrayEntries == NULL) {

            if (CreateCopy) {
                ldapFree( string, LDAP_VALUE_SIGNATURE );
            }
            return 0;
        }

        *ArrayToReturn = arrayEntries;
        *ArraySize = totalEntries = INITIAL_NUMBER_OF_ENTRIES;
        *arrayEntries = NULL;

    } else {

        arrayEntries = *ArrayToReturn;

        while (*arrayEntries != NULL) {

            arrayEntries++;
            entryCount++;
        }
    }

    if (entryCount == totalEntries) {

        PWCHAR *newArray;
        PWCHAR *oldArray;

        //
        //  have to realloc the list since it's too small
        //

        totalEntries *= 2;

        newArray = (PWCHAR *) ldapMalloc( totalEntries * sizeof( PWCHAR ),
                                          LDAP_VALUE_LIST_SIGNATURE );

        if (newArray == NULL) {

            if (CreateCopy) {
                ldapFree( string, LDAP_VALUE_SIGNATURE );
            }
            return 0;
        }

        arrayEntries = *ArrayToReturn;      // start at beginning for copy

        oldArray = *ArrayToReturn;          // save off old one to free

        *ArrayToReturn = newArray;          // save off start of new one

        while (*arrayEntries != NULL) {     // copy old to new one

            *(newArray++) = *(arrayEntries++);
        }
        arrayEntries = newArray;            // make the new one current

        ldapFree( oldArray, LDAP_VALUE_LIST_SIGNATURE );

        *ArraySize = totalEntries;
    }

    *arrayEntries = string;
    *(arrayEntries+1) = NULL;

    return entryCount+1;
}

//
//  some folks don't want us to pull in msvcrt dll... we'll use our own
//  routine for this.
//

VOID
ldap_MoveMemory (
    PCHAR dest,
    PCHAR source,
    ULONG length
    )
{
    if (dest > source) {

        dest += length;
        source += length;

        while (length-- > 0) {

            *(--dest) = *(--source);
        }

    } else if (dest != source) {

        while (length-- > 0) {

            *(dest++) = *(source++);
        }
    }
    return;
}

ULONG
FromUnicodeWithAlloc (
    PWCHAR Source,
    PCHAR *Output,
    ULONG Tag,
    ULONG Language
    )
{
    INT sLength = 0;
    INT tLength;

    *Output = NULL;

    if (Source == NULL) {
        return LDAP_SUCCESS;
    }

    sLength = strlenW( Source );

    //
    //  determine length of required string
    //

    if (Language == LANG_UTF8) {

        tLength = LdapUnicodeToUTF8( Source, sLength, NULL, 0 );

    } else {

        tLength = WideCharToMultiByte(  CP_ACP,
                                        0,
                                        Source,
                                        sLength,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL );
    }

    if ((tLength == 0) && (sLength > 0)) {

        return LDAP_PARAM_ERROR;
    }

    *Output = (PCHAR) ldapMalloc( tLength + 1, Tag );

    if (*Output == NULL) {

        return LDAP_NO_MEMORY;
    }

    if (sLength == 0) {

        tLength = 0;

    } else {

        if (Language == LANG_UTF8) {

            tLength = LdapUnicodeToUTF8( Source, sLength, *Output, sLength + 1 );

        } else {

            tLength = WideCharToMultiByte(  CP_ACP,
                                            0,
                                            Source,
                                            sLength,
                                            *Output,
                                            tLength + 1,
                                            NULL,
                                            NULL );
        }
    }

    *((*Output)+tLength) = '\0';

    return LDAP_SUCCESS;
}

ULONG
ToUnicodeWithAlloc (
    PCHAR Source,
    LONG SourceLength,
    PWCHAR *Output,
    ULONG Tag,
    ULONG Language
    )
{
    INT sLength = 0;
    INT tLength;

    *Output = NULL;

    if (Source == NULL) {
        return LDAP_SUCCESS;
    }

    //
    //  determine length of required string
    //

    if (SourceLength == -1) {

        SourceLength = (LONG) strlen( Source );
    }

    if (Language == LANG_UTF8) {

        sLength = LdapUTF8ToUnicode( Source, SourceLength, NULL, 0 );

    } else {


        sLength = MultiByteToWideChar(  CP_ACP,
                                        0,
                                        Source,
                                        SourceLength,
                                        NULL,
                                        0 );
    }

    if ((sLength == 0) && (SourceLength != 0)) {

        return LDAP_PARAM_ERROR;
    }

    *Output = (PWCHAR) ldapMalloc( ( sLength + 1 ) * sizeof(WCHAR) , Tag );

    if (*Output == NULL) {

        return LDAP_NO_MEMORY;
    }

    if (Language == LANG_UTF8) {

        tLength = LdapUTF8ToUnicode( Source, SourceLength, *Output, sLength + 1 );

    } else {

        tLength = MultiByteToWideChar(  CP_ACP,
                                        0,
                                        Source,
                                        SourceLength,
                                        *Output,
                                        sLength + 1 );
    }

    *((*Output)+tLength) = L'\0';

    return LDAP_SUCCESS;
}

ULONG
strlenW(
    PWCHAR string
    )
{
    ULONG count = 0;

    while (string != NULL && *string != L'\0') {
        count++;
        string++;
    }

    return count;
}


BOOLEAN
ldapWStringsIdentical (
    PWCHAR string1,
    LONG length1,
    PWCHAR string2,
    LONG length2
    )
//
//  Win9x doesn't implement CompareStringW, so we'll roll our own here.
//
{
    BOOLEAN rc = FALSE;
    ULONG err;

    if (string1 == NULL) {

        return (string2 == NULL) ? TRUE : FALSE;

    } else if (string2 == NULL) {

        return FALSE;
    }

    if (! GlobalWin9x ) {

        err = CompareStringW( LDAP_DEFAULT_LOCALE,
                              NORM_IGNORECASE,
                              string1,
                              length1,
                              string2,
                              length2
                              );

        rc = (err == 2) ? TRUE : FALSE;

    } else {

        WCHAR savedChar1 = L'\0';
        WCHAR savedChar2 = L'\0';
        BOOLEAN saved1 = FALSE;
        BOOLEAN saved2 = FALSE;

        if (length1 == (ULONG) -1) {

            length1 = strlenW( string1 );

        } else if (*(string1+length1) != L'\0') {

            saved1 = TRUE;
            savedChar1 = *(string1+length1);
            *(string1+length1) = L'\0';
        }

        if (length2 == (ULONG) -1) {

            length2 = strlenW( string2 );

        } else if (*(string2+length2) != L'\0') {

            saved2 = TRUE;
            savedChar2 = *(string2+length2);
            *(string2+length2) = L'\0';
        }

        if (length1 != length2) {

            rc = FALSE;

        } else {

            //
            //  we convert the strings to single byte codepage and then do the
            //  compare.
            //

            PCHAR smallString1 = NULL;
            PCHAR smallString2 = NULL;

            err = FromUnicodeWithAlloc( string1,
                                        &smallString1,
                                        LDAP_ANSI_SIGNATURE,
                                        LANG_ACP );

            if (err != LDAP_SUCCESS) {

                rc = FALSE;

            } else {

                err = FromUnicodeWithAlloc( string2,
                                            &smallString2,
                                            LDAP_ANSI_SIGNATURE,
                                            LANG_ACP );

                if (err != LDAP_SUCCESS) {

                    rc =  FALSE;

                } else {

                    err = CompareStringA( LDAP_DEFAULT_LOCALE,
                                          NORM_IGNORECASE,
                                          smallString1,
                                          (ULONG) -1,
                                          smallString2,
                                          (ULONG) -1
                                          );

                    rc = (err == 2) ? TRUE : FALSE;

                    ldapFree( smallString2, LDAP_ANSI_SIGNATURE );
                }

                ldapFree( smallString1, LDAP_ANSI_SIGNATURE );
            }
        }

        if (saved1 == TRUE) {
            *(string1+length1) = savedChar1;
        }
        if (saved2 == TRUE) {
            *(string2+length2) = savedChar2;
        }
    }

    return rc;
}

//
//  Thread Safe way to get last error code returned by LDAP API is to call
//  LdapGetLastError();
//

ULONG __cdecl
LdapGetLastError( VOID )
{
    ULONG err;

    if (GlobalTlsLastErrorIndex != 0xFFFFFFFF) {

        err = PtrToUlong(TlsGetValue( GlobalTlsLastErrorIndex ));

    } else {

        err = LDAP_LOCAL_ERROR;
    }
    return err;
}

//
//  Translate from LdapError to closest Win32 error code.
//

ULONG __cdecl
LdapMapErrorToWin32( ULONG LdapError )
{
    ULONG err;

    switch (LdapError) {

    case LDAP_SUCCESS :
        err = NO_ERROR ;
        break;

    case LDAP_ADMIN_LIMIT_EXCEEDED :
        err = ERROR_NOT_ENOUGH_QUOTA ;
        break;

    case LDAP_OPERATIONS_ERROR :
        err = ERROR_OPEN_FAILED ;
        break;

    case LDAP_PROTOCOL_ERROR :
        err = ERROR_INVALID_LEVEL ;
        break;

    case LDAP_TIMELIMIT_EXCEEDED :
        err = ERROR_TIMEOUT;
        break;

    case LDAP_SIZELIMIT_EXCEEDED :
        err = ERROR_MORE_DATA ;
        break;

    case LDAP_AUTH_METHOD_NOT_SUPPORTED :
        err = ERROR_ACCESS_DENIED ;
        break;

    case LDAP_STRONG_AUTH_REQUIRED :
        err = ERROR_ACCESS_DENIED ;
        break;

    // LDAP_REFERRAL_V2 has same value as LDAP_PARTIAL_RESULTS
    case LDAP_REFERRAL :
    case LDAP_PARTIAL_RESULTS :
        err = ERROR_MORE_DATA ;
        break;

    case LDAP_INVALID_SYNTAX :
        err = ERROR_INVALID_NAME ;
        break;

    case LDAP_NO_SUCH_OBJECT :
        err = ERROR_FILE_NOT_FOUND ;
        break;

    case LDAP_INVALID_DN_SYNTAX :
        err = ERROR_INVALID_PARAMETER ;
        break;

    case LDAP_INAPPROPRIATE_AUTH :
        err = ERROR_ACCESS_DENIED ;
        break;

    case LDAP_INVALID_CREDENTIALS :
        err = ERROR_WRONG_PASSWORD ;
        break;

    case LDAP_INSUFFICIENT_RIGHTS :
        err = ERROR_ACCESS_DENIED ;
        break;

    case LDAP_BUSY :
        err = ERROR_BUSY ;
        break;

    case LDAP_UNAVAILABLE :
        err = ERROR_DEV_NOT_EXIST ;
        break;

    case LDAP_UNWILLING_TO_PERFORM :
        err = ERROR_CAN_NOT_COMPLETE ;
        break;

    case LDAP_SORT_CONTROL_MISSING :
        err = ERROR_DS_SORT_CONTROL_MISSING;
        break;
    
    case LDAP_OFFSET_RANGE_ERROR :
        err = ERROR_DS_OFFSET_RANGE_ERROR;
        break;

    case LDAP_NAMING_VIOLATION :
        err = ERROR_INVALID_PARAMETER ;
        break;

    case LDAP_OBJECT_CLASS_VIOLATION :
        err = ERROR_INVALID_PARAMETER ;
        break;

    case LDAP_ALREADY_EXISTS :
        err = ERROR_ALREADY_EXISTS ;
        break;

    case LDAP_RESULTS_TOO_LARGE :
        err = ERROR_INSUFFICIENT_BUFFER ;
        break;

    case LDAP_OTHER :
        err = ERROR_DS_GENERIC_ERROR ;
        break;

    case LDAP_SERVER_DOWN :
        err = ERROR_BAD_NET_RESP ;
        break;

    case LDAP_LOCAL_ERROR :
        err = ERROR_DS_GENERIC_ERROR ;
        break;

    case LDAP_ENCODING_ERROR :
        err = ERROR_UNEXP_NET_ERR ;
        break;

    case LDAP_DECODING_ERROR :
        err = ERROR_UNEXP_NET_ERR ;
        break;

    case LDAP_TIMEOUT :
        err = ERROR_SERVICE_REQUEST_TIMEOUT ;
        break;

    case LDAP_AUTH_UNKNOWN :
        err = ERROR_WRONG_PASSWORD ;
        break;

    case LDAP_FILTER_ERROR :
        err = ERROR_INVALID_PARAMETER ;
        break;

    case LDAP_USER_CANCELLED :
        err = ERROR_CANCELLED ;
        break;

    case LDAP_PARAM_ERROR :
        err = ERROR_INVALID_PARAMETER ;
        break;

    case LDAP_NO_MEMORY :
        err = ERROR_NOT_ENOUGH_MEMORY ;
        break;

    case LDAP_CONSTRAINT_VIOLATION :
        err = ERROR_INVALID_PARAMETER ;
        break;

    case LDAP_UNAVAILABLE_CRIT_EXTENSION :
        err = ERROR_CAN_NOT_COMPLETE ;
        break;

    case LDAP_NO_SUCH_ATTRIBUTE :
        err = ERROR_INVALID_PARAMETER ;
        break;

    case LDAP_INAPPROPRIATE_MATCHING :
        err = ERROR_INVALID_PARAMETER ;
        break;

    case LDAP_ATTRIBUTE_OR_VALUE_EXISTS :
        err = ERROR_ALREADY_EXISTS;
        break;

    case LDAP_NOT_ALLOWED_ON_NONLEAF :
        err = ERROR_CAN_NOT_COMPLETE ;
        break;

    case LDAP_NOT_SUPPORTED :
        err = ERROR_CAN_NOT_COMPLETE ;
        break;

    case LDAP_NO_RESULTS_RETURNED :

    case LDAP_MORE_RESULTS_TO_RETURN :
        err = ERROR_MORE_DATA ;
        break;

    case LDAP_CONNECT_ERROR :
        err = ERROR_CONNECTION_REFUSED;
        break;

    case LDAP_NOT_ALLOWED_ON_RDN :
        err = ERROR_ACCESS_DENIED ;
        break;

    case LDAP_NO_OBJECT_CLASS_MODS :
        err = ERROR_ACCESS_DENIED ;
        break;

    case LDAP_AFFECTS_MULTIPLE_DSAS :
        err = ERROR_CAN_NOT_COMPLETE ;
        break;

    case LDAP_CONTROL_NOT_FOUND:
        err = ERROR_NOT_FOUND;
        break;

    case LDAP_COMPARE_TRUE :
    case LDAP_COMPARE_FALSE :
    case LDAP_UNDEFINED_TYPE :
    case LDAP_ALIAS_PROBLEM :
    case LDAP_IS_LEAF :
    case LDAP_ALIAS_DEREF_PROBLEM :
    case LDAP_LOOP_DETECT :

        err = ERROR_DS_GENERIC_ERROR ;
        break;

    default:

        IF_DEBUG(ERRORS) {
            LdapPrint1( "wldap32 : MapLdapErrorToWin32 couldn't map 0x%x.\n", LdapError );
        }
        err = ERROR_DS_GENERIC_ERROR ;
        break;
    }

    return err;
}



BOOLEAN LoadUser32Now(
    VOID
    )
{
    //
    // if the user32 DLL is not loaded, we make sure its loaded now.
    //

   if (Faileduser32LoadLib) {

      return FALSE;
   }

   if (pfLoadStringA) {

        return TRUE;
   }

    ACQUIRE_LOCK( &LoadLibLock );

    USER32LibraryHandle = LoadLibraryA( "USER32.DLL" );

    if (USER32LibraryHandle != NULL) {

       pfLoadStringA = (FNLOADSTRINGA) GetProcAddress( USER32LibraryHandle, "LoadStringA" );
       pfwsprintfW = (FNWSPRINTFW) GetProcAddress( USER32LibraryHandle, "wsprintfW" );
       pfMessageBoxW = (FNMESAGEBOXW) GetProcAddress( USER32LibraryHandle, "MessageBoxW" );

       if (pfLoadStringA == NULL) {

          //
          // No big deal. We won't die if we don't get these functions
          // Just don't try to load the dll again.
          //

          Faileduser32LoadLib = TRUE;
          FreeLibrary( USER32LibraryHandle );
          USER32LibraryHandle = NULL;
          RELEASE_LOCK( &LoadLibLock );
          return FALSE;

       } else {

          //
          //  Load the strings from the resource file
          //

          int i;

          for (i = 0; i < LDAP_MAX_ERROR_STRINGS; i++ ) {

                   pfLoadStringA(  GlobalLdapDllInstance,
                                   WINLDAP_BASE_MSG + i,
                                   &(LdapErrorStrings[i][0]),
                                   LDAP_ERROR_STR_LENGTH );

              MultiByteToWideChar(  CP_ACP,
                                    0,
                                    &(LdapErrorStrings[i][0]),
                                    (int) -1,
                                    &(LdapErrorStringsW[i][0]),
                                    LDAP_ERROR_STR_LENGTH );
          }

          RELEASE_LOCK( &LoadLibLock );
          return TRUE;
       }

    } else {

       //
       // We couldn't load the library. Don't try to load it again.
       //

          Faileduser32LoadLib = TRUE;
          RELEASE_LOCK( &LoadLibLock );
          return FALSE;
    }
}


//
// This routine walks the list of error messages for the current thread looking
// for the given connection. If it finds one, it deletes the old message and appends
// the new one. If it doesn't find an existing entry, it creates one and and inserts
// it into the list.
//
// There can be a maximum of one error string per thread per connection at a time.
//
VOID
InsertErrorMessage(
     PLDAP_CONN Connection,
     PWCHAR ErrorMessage
      )
{
    PLIST_ENTRY pThreadListEntry = NULL;
    PTHREAD_ENTRY pThreadEntry = NULL;

    PERROR_ENTRY pErrorEntry;
    PERROR_ENTRY * ppNext = NULL;
    
    ULONG CurrentThreadId = GetCurrentThreadId();
    BOOLEAN fRetriedFindThread = FALSE;

retryFindThread:

    ACQUIRE_LOCK( &PerThreadListLock );

    pThreadListEntry = GlobalPerThreadList.Flink;

    //
    // Search for this thread's THREAD_ENTRY
    //
    while (pThreadListEntry != &GlobalPerThreadList) {

        pThreadEntry = CONTAINING_RECORD( pThreadListEntry, THREAD_ENTRY, ThreadEntry );
        pThreadListEntry = pThreadListEntry->Flink;

        if (pThreadEntry->dwThreadID == CurrentThreadId) {
            break;
        }

        pThreadEntry = NULL;
    }

    if (!pThreadEntry && !fRetriedFindThread) {
        // this thread must have been created before this DLL was loaded-
        // create a per-thread entry for it now
        RELEASE_LOCK( &PerThreadListLock );
        
        IF_DEBUG(PARSE) {
            LdapPrint2( "InsertErrorMessage could not find ThreadEntry for conn 0x%x, thread 0x%x.  Creating one.\n",
                            Connection, CurrentThreadId );
        }

        if (!AddPerThreadEntry(CurrentThreadId)) {
            IF_DEBUG(PARSE) {
                LdapPrint2( "InsertErrorMessage AddPerThreadEntry failed, conn 0x%x, thread 0x%x.\n",
                                Connection, CurrentThreadId );
            }
            SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
            return;
        }

        fRetriedFindThread = TRUE;
        goto retryFindThread;
    }
    else if (!pThreadEntry) {
        // shouldn't happen --- somehow a thread entry wasn't created
        RELEASE_LOCK( &PerThreadListLock );
        IF_DEBUG(PARSE) {
            LdapPrint2( "InsertErrorMessage no per-thread entry, conn 0x%x, thread 0x%x.\n",
                            Connection, CurrentThreadId );
        }            
        ASSERT(pThreadEntry);
        SetConnectionError( Connection, LDAP_LOCAL_ERROR, NULL );
        return;
    }


    //
    // Now walk the error record list looking for a matching
    // connection
    //
    pErrorEntry = pThreadEntry->pErrorList;
    ppNext = &(pThreadEntry->pErrorList);

    while (pErrorEntry != NULL) {

        if (pErrorEntry->Connection == Connection) {
            ASSERT(pErrorEntry->ThreadId == CurrentThreadId);
            break;
        }

        ppNext = &(pErrorEntry->pNext);
        pErrorEntry = pErrorEntry->pNext;
    }

    if (pErrorEntry) {
        //
        // Found an existing error record for this connection,
        // recycle it
        //
        if (pErrorEntry->ErrorMessage != NULL) {

            ldap_memfreeW( pErrorEntry->ErrorMessage );
        }

        pErrorEntry->ErrorMessage = ErrorMessage;
    }
    else {
        pErrorEntry = (PERROR_ENTRY) ldapMalloc( sizeof( ERROR_ENTRY ), LDAP_ERROR_SIGNATURE);

        if (pErrorEntry != NULL) {

            pErrorEntry->Connection = Connection;
            pErrorEntry->ThreadId = CurrentThreadId;
            pErrorEntry->ErrorMessage = ErrorMessage;
            pErrorEntry->pNext = NULL;

            *ppNext = pErrorEntry;
            
        } else {
            RELEASE_LOCK( &PerThreadListLock );    
            SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
            return;
        }

    }

    RELEASE_LOCK( &PerThreadListLock );    

}


//
// This routine walks the list of error messages for the current thread looking
// for the given connection. If it finds an entry it makes a copy of the error message
// and returns it. If not, it returns NULL. The returned string should be freed
// by calling ldap_memfree
//
// There can be a maximum of one error string per thread per connection at a time.
//

PVOID
GetErrorMessage(
     PLDAP_CONN Connection,
     BOOLEAN    Unicode
      )
{
    PLIST_ENTRY pThreadListEntry = NULL;
    PTHREAD_ENTRY pThreadEntry = NULL;

    PERROR_ENTRY pErrorEntry;

    PVOID ErrorString = NULL;
    ULONG err = 0;

    ULONG CurrentThreadId = GetCurrentThreadId();
    BOOLEAN fRetriedFindThread = FALSE;

retryFindThread:

    ACQUIRE_LOCK( &PerThreadListLock );

    pThreadListEntry = GlobalPerThreadList.Flink;

    //
    // Search for this thread's THREAD_ENTRY
    //
    while (pThreadListEntry != &GlobalPerThreadList) {

        pThreadEntry = CONTAINING_RECORD( pThreadListEntry, THREAD_ENTRY, ThreadEntry );
        pThreadListEntry = pThreadListEntry->Flink;

        if (pThreadEntry->dwThreadID == CurrentThreadId) {
            break;
        }

        pThreadEntry = NULL;
    }
    
    if (!pThreadEntry && !fRetriedFindThread) {
        // this thread must have been created before this DLL was loaded-
        // create a per-thread entry for it now
        RELEASE_LOCK( &PerThreadListLock );
        
        IF_DEBUG(PARSE) {
            LdapPrint2( "GetErrorMessage could not find ThreadEntry for conn 0x%x, thread 0x%x.  Creating one.\n",
                            Connection, CurrentThreadId );
        }

        if (!AddPerThreadEntry(CurrentThreadId)) {
            IF_DEBUG(PARSE) {
                LdapPrint2( "GetErrorMessage AddPerThreadEntry failed, conn 0x%x, thread 0x%x.\n",
                                Connection, CurrentThreadId );
            }
            SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
            return NULL;
        }

        fRetriedFindThread = TRUE;
        goto retryFindThread;
    }
    else if (!pThreadEntry) {
        // shouldn't happen --- somehow a thread entry wasn't created
        RELEASE_LOCK( &PerThreadListLock );
        IF_DEBUG(PARSE) {
            LdapPrint2( "GetErrorMessage no per-thread entry, conn 0x%x, thread 0x%x.\n",
                            Connection, CurrentThreadId );
        }            
        ASSERT(pThreadEntry);
        SetConnectionError( Connection, LDAP_LOCAL_ERROR, NULL );
        return NULL;
    }

    //
    // Now walk the error record list looking for a matching
    // connection
    //
    pErrorEntry = pThreadEntry->pErrorList;

    while (pErrorEntry != NULL) {

        if (pErrorEntry->Connection == Connection) {
            ASSERT(pErrorEntry->ThreadId == CurrentThreadId);
            break;
        }

        pErrorEntry = pErrorEntry->pNext;
    }

    RELEASE_LOCK( &PerThreadListLock );

    //
    // Copy the error string found
    //
    if (pErrorEntry != NULL) {

        if (pErrorEntry->ErrorMessage != NULL) {

            if (Unicode) {

                ErrorString = ldap_dup_stringW( pErrorEntry->ErrorMessage,
                                                0,
                                                LDAP_ERROR_SIGNATURE  );

                if (ErrorString == NULL) {

                    SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
                }

            } else {

                err = FromUnicodeWithAlloc( pErrorEntry->ErrorMessage,
                                            (char**) &ErrorString,
                                            LDAP_ERROR_SIGNATURE,
                                            LANG_ACP );

                if (err != LDAP_SUCCESS) {

                    SetConnectionError( Connection, err, NULL );
                }
            }
        }
    }

    return ErrorString;
}


WINLDAPAPI LDAP * LDAPAPI ldap_conn_from_msg (
    LDAP *PrimaryConn,
    LDAPMessage *res
    )
//
//  Given an LDAP message, return the connection pointer where the message
//  came from.  It can return NULL if the connection has already been freed.
//
{
    PLDAP connection = NULL;

    //
    //  if the result is not null and the connection is either the primary or
    //  a referenced connection, then we return it.
    //

    if ((res != NULL) &&
        ((res->Connection == PrimaryConn) ||
          res->ConnectionReferenced) ) {

        connection = res->Connection;
    }

    return connection;
}

BOOLEAN
IsMessageIdValid(
     LONG MessageId
     )
{
    //
    // Walk through our list of active requests to find out if any outstanding
    // request is using this messageId.
    //

    PLDAP_REQUEST request = NULL;
    PLIST_ENTRY listEntry;

    if (MessageId == 0) {
        return FALSE;
    }

    ACQUIRE_LOCK( &RequestListLock );

    listEntry = GlobalListRequests.Flink;

    while ((listEntry != &GlobalListRequests) &&
           (request == NULL)) {

        request = CONTAINING_RECORD( listEntry, LDAP_REQUEST, RequestListEntry );
        request = ReferenceLdapRequest( request );

        listEntry = listEntry->Flink;
        
        if (!request) {
            continue;
        }
        
        if ( request->MessageId == MessageId) {

            DereferenceLdapRequest( request );
            RELEASE_LOCK( &RequestListLock );
            LdapPrint1("Message Id 0x%x is already in use \n", MessageId)
            return FALSE;
        }
            
        DereferenceLdapRequest( request );
        request = NULL;
    }

    RELEASE_LOCK( &RequestListLock );

    return TRUE;
}




VOID
DebugReferralOutput(
    PLDAP_REQUEST Request,
    PWCHAR HostAddr,
    PWCHAR NewUrlDN
    )

{
   WCHAR buffer[5000];
   int j;

   if ( PopupRegKeyFound && pfwsprintfW ) {

         j =  pfwsprintfW(buffer, L"Chasing referral to %s\n\
                           \tReferral DN is: %s\n\
                           \tParent searchDN was: %s\n\
                           \tParent search filter was: %s\n\
                           \tParent search filter was: %d\n",
                           HostAddr,
                           NewUrlDN,
                           Request->OriginalDN,
                           Request->search.SearchFilter,
                           Request->search.ScopeOfSearch);
      #if 0
         j += pfwsprintfW(buffer, L"Referral DN is %S\n", NewUrlDN);
         j += pfwsprintfW(buffer, L"Parent searchDN was %S\n", Request->OriginalDN);
         j += pfwsprintfW(buffer, L"Parent search filter was %S\n", Request->search.SearchFilter);

         if (Request->search.ScopeOfSearch == LDAP_SCOPE_SUBTREE) {
            j += pfwsprintfW(buffer, L"Searchscope was Subtree\n");
         } else if (Request->search.ScopeOfSearch == LDAP_SCOPE_BASE) {
            j += pfwsprintfW(buffer, L"Searchscope was base\n");
         } else {
            j += pfwsprintfW(buffer, L"Searchscope was Onelevel\n");
         }
      #endif

         DbgPrint("%S",buffer);

         if (pfMessageBoxW) {

            pfMessageBoxW(NULL, buffer, L"WLDAP32.DLL: Referral alert", MB_OK|MB_APPLMODAL);
         }

   }
}


VOID
LogAttributesAndControls(
    PWCHAR  AttributeList[],
    LDAPModW *ModificationList[],
    PLDAPControlW *ServerControls,
    BOOLEAN Unicode
    )
{
#if DBG
    if ( !DSLOG_ACTIVE ) {
        return;
    }

    DWORD len;
    DWORD i;

    if ( (AttributeList != NULL) && (AttributeList[0] != NULL) ) {

        i=0; len=0;

next_line1:
        while (AttributeList[i] != NULL) {
            if ( Unicode ) {
                DSLOG((DSLOG_FLAG_NOTIME,"[ATTR=%ws]", AttributeList[i]));
                len += strlenW(AttributeList[i]);
            } else {
                DSLOG((DSLOG_FLAG_NOTIME,"[ATTR=%s]", AttributeList[i]));
                len += (DWORD) strlen((PCHAR)AttributeList[i]);
            }
            i++;

            if ( (len > 40) && (AttributeList[i] != NULL) ) {
                len = 0;
                goto next_line1;
            }
        }
        DSLOG((0,"\n"));
    }

    if ( (ModificationList != NULL) && (ModificationList[0] != NULL) ) {

        i=0;

        while (ModificationList[i] != NULL) {
            if ( Unicode ) {
                DSLOG((DSLOG_FLAG_NOTIME,"[ML=op %d type %ws]\n",
                       ModificationList[i]->mod_op & 3,
                       ModificationList[i]->mod_type
                       ));
            } else {
                DSLOG((DSLOG_FLAG_NOTIME,"[ML=op %d type %s]\n",
                       ModificationList[i]->mod_op & 3,
                       ModificationList[i]->mod_type
                       ));
            }
            i++;
        }
    }

    if ( ServerControls != NULL ) {
        DWORD i=0;
        while ( ServerControls[i] != NULL ) {
            if ( Unicode ) {
                DSLOG((DSLOG_FLAG_NOTIME,"[CT=%ws]",ServerControls[i]->ldctl_oid));
            } else {
                DSLOG((DSLOG_FLAG_NOTIME,"[CT=%s]",ServerControls[i]->ldctl_oid));
            }
            i++;
        }
    }
#endif
} // LogAttributesAndControls


ULONGLONG
LdapGetTickCount(
    VOID
    )
/*++

Routine Description:

    Get current time with a resolution of 1 milli second.

Arguments:

    None.

Return Value:

    A 64 bit value representing time since Jan 1, 1601 in 1 millisecond intervals.

--*/
{

    FILETIME FileTime;

    GetSystemTimeAsFileTime( &FileTime );

    //
    // Convert nano seconds to milliseconds and return the value.
    //

    return ((((ULONGLONG)FileTime.dwHighDateTime)<<32) | FileTime.dwLowDateTime)/10000;

}

ULONG
LdapGetModuleBuildNum(
    VOID
    )
/*++

Routine Description:

    Get the SDK version of wldap32.dll.

Arguments:

    None.

Return Value:

    A 32 bit value denoting the SDK version of wldap32.dll.

--*/
{
    return LDAP_VENDOR_VERSION; // NT 5.1 * 100
}



VOID
RoundUnicodeStringMaxLength(
    UNICODE_STRING *pString,
    USHORT dwMultiple
    )
/*++

Routine Description:

    Adjusts the max length field of a UNICODE_STRING so
    that it is a multiple of dwMultiple.

    IMPORTANT: This function assumes that the UNICODE_STRING
    already points to a buffer of sufficient size.  To do this,
    make sure the buffer has at least dwMultiple-1 spare bytes.

Arguments:

    pString - ptr to UNICODE_STRING to adjust
    dwMultiple - multiple to round the strings max length up to

Return Value:

    none

--*/

{
    USHORT extra = (pString->MaximumLength % dwMultiple);
    ASSERT(extra < dwMultiple);

    if (extra == 0) {
        //
        // Already an exact multiple of dwMultiple, nothing
        // more to do
        //
        return;
    }

    pString->MaximumLength += (dwMultiple - extra);
}



VOID
EncodeUnicodeString(
    UNICODE_STRING *pString
    )
/*++

Routine Description:

    Encodes a Unicode string, using RtlEncryptMemory if available,
    else using RtlEncodeUnicodeString

Arguments:

    pString - ptr to UNICODE_STRING to encode

Return Value:

    none

--*/
    
{
    NTSTATUS stat;

    ASSERT(GlobalUseScrambling == TRUE);
    ASSERT(pRtlEncryptMemory || pRtlRunEncodeUnicodeString);
    ASSERT((pString->MaximumLength % DES_BLOCKLEN) == 0);

    if ((pString->Buffer == NULL) ||
        (pString->MaximumLength == 0)) {

        // nothing to encode, so do nothing
        // (RtlEncryptMemory will otherwise return an error);
        return;
    }

    if (pRtlEncryptMemory) {
        stat = pRtlEncryptMemory(pString->Buffer, pString->MaximumLength, 0);
        ASSERT(stat == STATUS_SUCCESS);        
    }
    else {
        pRtlRunEncodeUnicodeString(&GlobalSeed, pString);
    }
}



VOID
DecodeUnicodeString(
    UNICODE_STRING *pString
    )
/*++

Routine Description:

    Decodes a Unicode string, using RtlDecryptMemory if available,
    else using RtlDecodeUnicodeString

Arguments:

    pString - ptr to UNICODE_STRING to decode

Return Value:

    none

--*/
    
{
    NTSTATUS stat;

    ASSERT(GlobalUseScrambling == TRUE);
    ASSERT(pRtlDecryptMemory || pRtlRunDecodeUnicodeString);
    ASSERT((pString->MaximumLength % DES_BLOCKLEN) == 0);    

    if ((pString->Buffer == NULL) ||
        (pString->MaximumLength == 0)) {

        // nothing to decode, so do nothing
        // (RtlDecryptMemory will otherwise return an error);
        return;
    }
    
    if (pRtlDecryptMemory) {
        stat = pRtlDecryptMemory(pString->Buffer, pString->MaximumLength, 0);
        ASSERT(stat == STATUS_SUCCESS);
    }
    else {
        pRtlRunDecodeUnicodeString(GlobalSeed, pString);
    }
}

// util.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\win9x.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    win9x.cxx

Abstract:

   This module implements Win9x wrappers for Unicode security APIs


Author:

    Srinivasan Chandrasekar (srinivac)  20-Feb-1999

Revision History:

--*/

#include "precomp.h"
#include "ldapp2.hxx"
#pragma hdrstop

//
// Forward declarations
//
SECURITY_STATUS SEC_ENTRY Win9xEnumerateSecurityPackages(
    unsigned long SEC_FAR * pcPackages,
    PSecPkgInfoW SEC_FAR * ppPackageInfo
    );

SECURITY_STATUS SEC_ENTRY Win9xQueryCredentialsAttributes(
    PCredHandle phCredential,
    unsigned long ulAttribute,
    void SEC_FAR * pBuffer
    );

SECURITY_STATUS SEC_ENTRY
Win9xAcquireCredentialsHandle(
    SEC_WCHAR SEC_FAR * pszPrincipal,
    SEC_WCHAR SEC_FAR * pszPackage,
    unsigned long fCredentialUse,
    void SEC_FAR * pvLogonId,
    void SEC_FAR * pAuthData,
    SEC_GET_KEY_FN pGetKeyFn,
    void SEC_FAR * pvGetKeyArgument,
    PCredHandle phCredential,
    PTimeStamp ptsExpiry
    );

SECURITY_STATUS SEC_ENTRY
Win9xInitializeSecurityContext(
    PCredHandle phCredential,
    PCtxtHandle phContext,
    SEC_WCHAR SEC_FAR * pszTargetName,
    unsigned long fContextReq,
    unsigned long Reserved1,
    unsigned long TargetDataRep,
    PSecBufferDesc pInput,
    unsigned long Reserved2,
    PCtxtHandle phNewContext,
    PSecBufferDesc pOutput,
    unsigned long SEC_FAR * pfContextAttr,
    PTimeStamp ptsExpiry
    );

SECURITY_STATUS SEC_ENTRY
Win9xQueryContextAttributes(
    PCtxtHandle phContext,
    unsigned long ulAttribute,
    void SEC_FAR * pBuffer
    );

SECURITY_STATUS SEC_ENTRY
Win9xQuerySecurityPackageInfo(
    SEC_WCHAR SEC_FAR * pszPackageName,
    PSecPkgInfoW SEC_FAR *ppPackageInfo
    );

SECURITY_STATUS SEC_ENTRY
Win9xImportSecurityContext(
    SEC_WCHAR SEC_FAR *  pszPackage,
    PSecBuffer           pPackedContext,
    void SEC_FAR *       Token,
    PCtxtHandle          phContext
    );

BOOL ConvertPackagesToUnicode(
    PSecPkgInfoA pPackageInfoA,
    DWORD  cbNumPackages
    );

SECURITY_STATUS SEC_ENTRY Win9xSslEnumerateSecurityPackages(
    unsigned long SEC_FAR * pcPackages,
    PSecPkgInfoW SEC_FAR * ppPackageInfo
    );

SECURITY_STATUS SEC_ENTRY Win9xSslQueryCredentialsAttributes(
    PCredHandle phCredential,
    unsigned long ulAttribute,
    void SEC_FAR * pBuffer
    );

SECURITY_STATUS SEC_ENTRY
Win9xSslAcquireCredentialsHandle(
    SEC_WCHAR SEC_FAR * pszPrincipal,
    SEC_WCHAR SEC_FAR * pszPackage,
    unsigned long fCredentialUse,
    void SEC_FAR * pvLogonId,
    void SEC_FAR * pAuthData,
    SEC_GET_KEY_FN pGetKeyFn,
    void SEC_FAR * pvGetKeyArgument,
    PCredHandle phCredential,
    PTimeStamp ptsExpiry
    );

SECURITY_STATUS SEC_ENTRY
Win9xSslInitializeSecurityContext(
    PCredHandle phCredential,
    PCtxtHandle phContext,
    SEC_WCHAR SEC_FAR * pszTargetName,
    unsigned long fContextReq,
    unsigned long Reserved1,
    unsigned long TargetDataRep,
    PSecBufferDesc pInput,
    unsigned long Reserved2,
    PCtxtHandle phNewContext,
    PSecBufferDesc pOutput,
    unsigned long SEC_FAR * pfContextAttr,
    PTimeStamp ptsExpiry
    );

SECURITY_STATUS SEC_ENTRY
Win9xSslQuerySecurityPackageInfo(
    SEC_WCHAR SEC_FAR * pszPackageName,
    PSecPkgInfoW SEC_FAR *ppPackageInfo
    );

SECURITY_STATUS SEC_ENTRY
Win9xSslImportSecurityContext(
    SEC_WCHAR SEC_FAR *  pszPackage,
    PSecBuffer           pPackedContext,
    void SEC_FAR *       Token,
    PCtxtHandle          phContext
    );

//
// Global function table that maps to our conversion functions
//
SecurityFunctionTableW   UnicodeSecurityFunctionTable;
SecurityFunctionTableW   UnicodeSslFunctionTable;

PSecurityFunctionTableW Win9xSspiInitialize(
    void
    )
{
    FSECINITSECURITYINTERFACEA  pSspiInitializeA;

    ASSERT(pSspiInitialize);

    //
    // The global function pointer actually points to an ANSI function
    // In Win9x. We'll cast in call into it.
    //
    pSspiInitializeA = (FSECINITSECURITYINTERFACEA)pSspiInitialize;

    SspiFunctionTableA = (*pSspiInitializeA)();

    if (! SspiFunctionTableA)
    {
        //
        // The caller will take apropriate action
        //
        return NULL;
    }

    //
    // Now construct a Unicode function table and return it to the caller
    //
    UnicodeSecurityFunctionTable.dwVersion = SspiFunctionTableA->dwVersion;

    UnicodeSecurityFunctionTable.EnumerateSecurityPackagesW =
            (ENUMERATE_SECURITY_PACKAGES_FN_W)Win9xEnumerateSecurityPackages;

    UnicodeSecurityFunctionTable.QueryCredentialsAttributesW =
            (QUERY_CREDENTIALS_ATTRIBUTES_FN_W)Win9xQueryCredentialsAttributes;

    UnicodeSecurityFunctionTable.AcquireCredentialsHandleW =
            (ACQUIRE_CREDENTIALS_HANDLE_FN_W)Win9xAcquireCredentialsHandle;

    UnicodeSecurityFunctionTable.FreeCredentialsHandle =
            SspiFunctionTableA->FreeCredentialsHandle;

    UnicodeSecurityFunctionTable.InitializeSecurityContextW =
            (INITIALIZE_SECURITY_CONTEXT_FN_W)Win9xInitializeSecurityContext;

    UnicodeSecurityFunctionTable.AcceptSecurityContext =
            SspiFunctionTableA->AcceptSecurityContext;

    UnicodeSecurityFunctionTable.CompleteAuthToken =
            SspiFunctionTableA->CompleteAuthToken;

    UnicodeSecurityFunctionTable.DeleteSecurityContext =
            SspiFunctionTableA->DeleteSecurityContext;

    UnicodeSecurityFunctionTable.ApplyControlToken =
            SspiFunctionTableA->ApplyControlToken;

    UnicodeSecurityFunctionTable.QueryContextAttributesW =
            (QUERY_CONTEXT_ATTRIBUTES_FN_W)Win9xQueryContextAttributes;

    UnicodeSecurityFunctionTable.ImpersonateSecurityContext =
            SspiFunctionTableA->ImpersonateSecurityContext;

    UnicodeSecurityFunctionTable.RevertSecurityContext =
            SspiFunctionTableA->RevertSecurityContext;

    UnicodeSecurityFunctionTable.MakeSignature =
            SspiFunctionTableA->MakeSignature;

    UnicodeSecurityFunctionTable.VerifySignature =
            SspiFunctionTableA->VerifySignature;

    UnicodeSecurityFunctionTable.FreeContextBuffer =
            SspiFunctionTableA->FreeContextBuffer;

    UnicodeSecurityFunctionTable.QuerySecurityPackageInfoW =
            (QUERY_SECURITY_PACKAGE_INFO_FN_W)Win9xQuerySecurityPackageInfo;

    UnicodeSecurityFunctionTable.ExportSecurityContext =
            SspiFunctionTableA->ExportSecurityContext;

    UnicodeSecurityFunctionTable.ImportSecurityContextW =
            (IMPORT_SECURITY_CONTEXT_FN_W)Win9xImportSecurityContext;

    UnicodeSecurityFunctionTable.QuerySecurityContextToken =
            SspiFunctionTableA->QuerySecurityContextToken;

    UnicodeSecurityFunctionTable.EncryptMessage =
            (ENCRYPT_MESSAGE_FN) SspiFunctionTableA->Reserved3;

    UnicodeSecurityFunctionTable.DecryptMessage =
            (DECRYPT_MESSAGE_FN) SspiFunctionTableA->Reserved4;

    return (PSecurityFunctionTableW) &UnicodeSecurityFunctionTable;
}

//
// Function table wrapper functions for Win9x
//

SECURITY_STATUS SEC_ENTRY Win9xEnumerateSecurityPackages(
    unsigned long SEC_FAR * pcPackages,     // Receives num. packages
    PSecPkgInfoW SEC_FAR * ppPackageInfo    // Receives array of info
    )
{
    PSecPkgInfoA  pPackageInfoA = NULL;
    SECURITY_STATUS rc;

    //
    // Call Ansi function
    //
    ASSERT(SspiFunctionTableA);
    ASSERT(SspiFunctionTableA->EnumerateSecurityPackagesA);

    rc = SspiFunctionTableA->EnumerateSecurityPackagesA(
                                pcPackages,
                                &pPackageInfoA);

    if (rc != SEC_E_OK)
        goto error;

    //
    // Convert returned values to Unicode
    //
    if (!ConvertPackagesToUnicode(pPackageInfoA, *pcPackages))
    {
        rc = SEC_E_INSUFFICIENT_MEMORY;
        goto error;
    }

    *ppPackageInfo = (PSecPkgInfoW)pPackageInfoA;
    pPackageInfoA = NULL;

error:
    //
    // Clean up and leave
    //
    if (pPackageInfoA)
        SspiFunctionTableA->FreeContextBuffer((void*)pPackageInfoA);

    return rc;
}


SECURITY_STATUS SEC_ENTRY Win9xQueryCredentialsAttributes(
    PCredHandle phCredential,           // Credential to query
    unsigned long ulAttribute,          // Attribute to query
    void SEC_FAR * pBuffer              // Buffer for attributes
    )
{
    //
    // This function is not used by us
    //


    ASSERT(FALSE);
    return SEC_E_UNSUPPORTED_FUNCTION;
}

SECURITY_STATUS SEC_ENTRY
Win9xAcquireCredentialsHandle(
    SEC_WCHAR SEC_FAR * pszPrincipal,   // Name of principal
    SEC_WCHAR SEC_FAR * pszPackage,     // Name of package
    unsigned long fCredentialUse,       // Flags indicating use
    void SEC_FAR * pvLogonId,           // Pointer to logon ID
    void SEC_FAR * pAuthData,           // Package specific data
    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey()
    PCredHandle phCredential,           // (out) Cred Handle
    PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    )
{
    SEC_CHAR  *pszPrincipalA = NULL;
    SEC_CHAR  *pszPackageA = NULL;
    ULONG err;
    SECURITY_STATUS rc = SEC_E_INSUFFICIENT_MEMORY;

    //
    // Convert parameters to Ansi
    //
    err = FromUnicodeWithAlloc(pszPrincipal,
                               &pszPrincipalA,
                               LDAP_ANSI_SIGNATURE,
                               LANG_ACP);
    if (err != LDAP_SUCCESS)
        goto error;

    err = FromUnicodeWithAlloc(pszPackage,
                               &pszPackageA,
                               LDAP_ANSI_SIGNATURE,
                               LANG_ACP);
    if (err != LDAP_SUCCESS)
        goto error;

    //
    // Call Ansi function
    //
    ASSERT(SspiFunctionTableA);
    ASSERT(SspiFunctionTableA->AcquireCredentialsHandleA);

    rc = SspiFunctionTableA->AcquireCredentialsHandleA(
                                    pszPrincipalA,
                                    pszPackageA,
                                    fCredentialUse,
                                    pvLogonId,
                                    pAuthData,
                                    pGetKeyFn,
                                    pvGetKeyArgument,
                                    phCredential,
                                    ptsExpiry);

error:
    //
    // Clean up and leave
    //
    if (pszPrincipalA)
        ldapFree(pszPrincipalA, LDAP_ANSI_SIGNATURE);

    if (pszPackageA)
        ldapFree(pszPackageA, LDAP_ANSI_SIGNATURE);

    return rc;
}


SECURITY_STATUS SEC_ENTRY
Win9xInitializeSecurityContext(
    PCredHandle phCredential,               // Cred to base context
    PCtxtHandle phContext,                  // Existing context (OPT)
    SEC_WCHAR SEC_FAR * pszTargetName,      // Name of target
    unsigned long fContextReq,              // Context Requirements
    unsigned long Reserved1,                // Reserved, MBZ
    unsigned long TargetDataRep,            // Data rep of target
    PSecBufferDesc pInput,                  // Input Buffers
    unsigned long Reserved2,                // Reserved, MBZ
    PCtxtHandle phNewContext,               // (out) New Context handle
    PSecBufferDesc pOutput,                 // (inout) Output Buffers
    unsigned long SEC_FAR * pfContextAttr,  // (out) Context attrs
    PTimeStamp ptsExpiry                    // (out) Life span (OPT)
    )
{
    PSTR pszTargetNameA = NULL;
    ULONG err;
    SECURITY_STATUS rc = SEC_E_INSUFFICIENT_MEMORY;

    //
    // Convert parameters to Ansi
    //
    err = FromUnicodeWithAlloc(pszTargetName,
                               &pszTargetNameA,
                               LDAP_ANSI_SIGNATURE,
                               LANG_ACP);
    if (err != LDAP_SUCCESS)
        goto error;

    //
    // Call Ansi function
    //
    ASSERT(SspiFunctionTableA);
    ASSERT(SspiFunctionTableA->InitializeSecurityContextA);

    rc = SspiFunctionTableA->InitializeSecurityContextA(
                                    phCredential,
                                    phContext,
                                    pszTargetNameA,
                                    fContextReq,
                                    Reserved1,
                                    TargetDataRep,
                                    pInput,
                                    Reserved2,
                                    phNewContext,
                                    pOutput,
                                    pfContextAttr,
                                    ptsExpiry);

error:
    //
    // Clean up and leave
    //
    if (pszTargetNameA)
        ldapFree((void*)pszTargetNameA, LDAP_ANSI_SIGNATURE);

    return rc;
}


SECURITY_STATUS SEC_ENTRY
Win9xQueryContextAttributes(
    PCtxtHandle phContext,              // Context to query
    unsigned long ulAttribute,          // Attribute to query
    void SEC_FAR * pBuffer              // Buffer for attributes
    )
{
    //
    // Call Ansi function
    //
    ASSERT(FALSE);
    return SEC_E_UNSUPPORTED_FUNCTION;
}

SECURITY_STATUS SEC_ENTRY
Win9xQuerySecurityPackageInfo(
    SEC_WCHAR SEC_FAR * pszPackageName,     // Name of package
    PSecPkgInfoW SEC_FAR *ppPackageInfo     // Receives package info
    )
{
    //
    // This function is not used by us
    //
    ASSERT(FALSE);
    return SEC_E_UNSUPPORTED_FUNCTION;
}


SECURITY_STATUS SEC_ENTRY
Win9xImportSecurityContext(
    SEC_WCHAR SEC_FAR *  pszPackage,
    PSecBuffer           pPackedContext,        // (in) marshalled context
    void SEC_FAR *       Token,                 // (in, optional) handle to token for context
    PCtxtHandle          phContext              // (out) new context handle
    )
{
    //
    // This function is not used by us
    //
    ASSERT(FALSE);
    return SEC_E_UNSUPPORTED_FUNCTION;
}

BOOL
ConvertPackagesToUnicode(
    PSecPkgInfoA pPackageInfoA,
    DWORD  cbNumPackages
    )
{
    DWORD i;
    ULONG err;
    BOOL  rc = FALSE;

    //
    //  Note that the memory we are allocating here gets freed only when wldap32
    //  gets unloaded. This is not serious since this gets called only once,
    //  for about half a dozen security packages.
    //
    for (i = 0; i < cbNumPackages; i++)
    {
        err = ToUnicodeWithAlloc(pPackageInfoA->Name,
                                 -1,
                                 (PWSTR*)&pPackageInfoA->Name,
                                 LDAP_UNICODE_SIGNATURE,
                                 LANG_ACP);
        if (err != LDAP_SUCCESS)
            goto error;

        err = ToUnicodeWithAlloc(pPackageInfoA->Comment,
                                 -1,
                                 (PWSTR*)&pPackageInfoA->Comment,
                                 LDAP_UNICODE_SIGNATURE,
                                 LANG_ACP);
        if (err != LDAP_SUCCESS)
            goto error;

        pPackageInfoA++;
    }

    rc = TRUE;

error:
    return rc;
}


// ------------

PSecurityFunctionTableW Win9xSslInitialize(
    void
    )
{
    FSECINITSECURITYINTERFACEA  pSslInitializeA;

    ASSERT(pSslInitialize);

    //
    // The global function pointer actually points to an ANSI function
    // In Win9x. We'll cast in call into it.
    //
    pSslInitializeA = (FSECINITSECURITYINTERFACEA)pSslInitialize;

    SslFunctionTableA = (*pSslInitializeA)();

    if (! SslFunctionTableA)
    {
        //
        // The caller will take apropriate action
        //
        return NULL;
    }

    //
    // Now construct a Unicode function table and return it to the caller
    //
    UnicodeSslFunctionTable.dwVersion = SslFunctionTableA->dwVersion;

    UnicodeSslFunctionTable.EnumerateSecurityPackagesW =
            (ENUMERATE_SECURITY_PACKAGES_FN_W)Win9xSslEnumerateSecurityPackages;

    UnicodeSslFunctionTable.QueryCredentialsAttributesW =
            (QUERY_CREDENTIALS_ATTRIBUTES_FN_W)Win9xSslQueryCredentialsAttributes;

    UnicodeSslFunctionTable.AcquireCredentialsHandleW =
            (ACQUIRE_CREDENTIALS_HANDLE_FN_W)Win9xSslAcquireCredentialsHandle;

    UnicodeSslFunctionTable.FreeCredentialsHandle =
            SslFunctionTableA->FreeCredentialsHandle;

    UnicodeSslFunctionTable.InitializeSecurityContextW =
            (INITIALIZE_SECURITY_CONTEXT_FN_W)Win9xSslInitializeSecurityContext;

    UnicodeSslFunctionTable.AcceptSecurityContext =
            SslFunctionTableA->AcceptSecurityContext;

    UnicodeSslFunctionTable.CompleteAuthToken =
            SslFunctionTableA->CompleteAuthToken;

    UnicodeSslFunctionTable.DeleteSecurityContext =
            SslFunctionTableA->DeleteSecurityContext;

    UnicodeSslFunctionTable.ApplyControlToken =
            SslFunctionTableA->ApplyControlToken;

    UnicodeSslFunctionTable.QueryContextAttributesW =
            SslFunctionTableA->QueryContextAttributes;

    UnicodeSslFunctionTable.ImpersonateSecurityContext =
            SslFunctionTableA->ImpersonateSecurityContext;

    UnicodeSslFunctionTable.RevertSecurityContext =
            SslFunctionTableA->RevertSecurityContext;

    UnicodeSslFunctionTable.MakeSignature =
            SslFunctionTableA->MakeSignature;

    UnicodeSslFunctionTable.VerifySignature =
            SslFunctionTableA->VerifySignature;

    UnicodeSslFunctionTable.FreeContextBuffer =
            SslFunctionTableA->FreeContextBuffer;

    UnicodeSslFunctionTable.QuerySecurityPackageInfoW =
            (QUERY_SECURITY_PACKAGE_INFO_FN_W)Win9xSslQuerySecurityPackageInfo;

    UnicodeSslFunctionTable.ExportSecurityContext =
            SslFunctionTableA->ExportSecurityContext;

    UnicodeSslFunctionTable.ImportSecurityContextW =
            (IMPORT_SECURITY_CONTEXT_FN_W)Win9xSslImportSecurityContext;

    UnicodeSslFunctionTable.QuerySecurityContextToken =
            SslFunctionTableA->QuerySecurityContextToken;

    UnicodeSslFunctionTable.EncryptMessage =
            (ENCRYPT_MESSAGE_FN) SslFunctionTableA->Reserved3;

    UnicodeSslFunctionTable.DecryptMessage =
            (DECRYPT_MESSAGE_FN) SslFunctionTableA->Reserved4;

    return (PSecurityFunctionTableW) &UnicodeSslFunctionTable;
}


SECURITY_STATUS SEC_ENTRY Win9xSslEnumerateSecurityPackages(
    unsigned long SEC_FAR * pcPackages,     // Receives num. packages
    PSecPkgInfoW SEC_FAR * ppPackageInfo    // Receives array of info
    )
{
    PSecPkgInfoA  pPackageInfoA = NULL;
    SECURITY_STATUS rc;

    //
    // Call Ansi function
    //
    ASSERT(SslFunctionTableA);
    ASSERT(SslFunctionTableA->EnumerateSecurityPackagesA);

    rc = SslFunctionTableA->EnumerateSecurityPackagesA(
                                pcPackages,
                                &pPackageInfoA);

    if (rc != SEC_E_OK)
        goto error;

    //
    // Convert returned values to Unicode
    //
    if (!ConvertPackagesToUnicode(pPackageInfoA, *pcPackages))
    {
        rc = SEC_E_INSUFFICIENT_MEMORY;
        goto error;
    }

    *ppPackageInfo = (PSecPkgInfoW)pPackageInfoA;
    pPackageInfoA = NULL;

error:
    //
    // Clean up and leave
    //
    if (pPackageInfoA)
        SslFunctionTableA->FreeContextBuffer((void*)pPackageInfoA);

    return rc;
}


SECURITY_STATUS SEC_ENTRY Win9xSslQueryCredentialsAttributes(
    PCredHandle phCredential,           // Credential to query
    unsigned long ulAttribute,          // Attribute to query
    void SEC_FAR * pBuffer              // Buffer for attributes
    )
{
    //
    // This function is not used by us
    //
    ASSERT(FALSE);
    return SEC_E_UNSUPPORTED_FUNCTION;
}

SECURITY_STATUS SEC_ENTRY
Win9xSslAcquireCredentialsHandle(
    SEC_WCHAR SEC_FAR * pszPrincipal,   // Name of principal
    SEC_WCHAR SEC_FAR * pszPackage,     // Name of package
    unsigned long fCredentialUse,       // Flags indicating use
    void SEC_FAR * pvLogonId,           // Pointer to logon ID
    void SEC_FAR * pAuthData,           // Package specific data
    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey()
    PCredHandle phCredential,           // (out) Cred Handle
    PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    )
{
    SEC_CHAR  *pszPrincipalA = NULL;
    SEC_CHAR  *pszPackageA = NULL;
    ULONG err;
    SECURITY_STATUS rc = SEC_E_INSUFFICIENT_MEMORY;

    //
    // Convert parameters to Ansi
    //
    err = FromUnicodeWithAlloc(pszPrincipal,
                               &pszPrincipalA,
                               LDAP_ANSI_SIGNATURE,
                               LANG_ACP);
    if (err != LDAP_SUCCESS)
        goto error;

    err = FromUnicodeWithAlloc(pszPackage,
                               &pszPackageA,
                               LDAP_ANSI_SIGNATURE,
                               LANG_ACP);
    if (err != LDAP_SUCCESS)
        goto error;

    //
    // Call Ansi function
    //
    ASSERT(SslFunctionTableA);
    ASSERT(SslFunctionTableA->AcquireCredentialsHandleA);

    rc = SslFunctionTableA->AcquireCredentialsHandleA(
                                    pszPrincipalA,
                                    pszPackageA,
                                    fCredentialUse,
                                    pvLogonId,
                                    pAuthData,
                                    pGetKeyFn,
                                    pvGetKeyArgument,
                                    phCredential,
                                    ptsExpiry);

error:
    //
    // Clean up and leave
    //
    if (pszPrincipalA)
        ldapFree(pszPrincipalA, LDAP_ANSI_SIGNATURE);

    if (pszPackageA)
        ldapFree(pszPackageA, LDAP_ANSI_SIGNATURE);

    return rc;
}


SECURITY_STATUS SEC_ENTRY
Win9xSslInitializeSecurityContext(
    PCredHandle phCredential,               // Cred to base context
    PCtxtHandle phContext,                  // Existing context (OPT)
    SEC_WCHAR SEC_FAR * pszTargetName,      // Name of target
    unsigned long fContextReq,              // Context Requirements
    unsigned long Reserved1,                // Reserved, MBZ
    unsigned long TargetDataRep,            // Data rep of target
    PSecBufferDesc pInput,                  // Input Buffers
    unsigned long Reserved2,                // Reserved, MBZ
    PCtxtHandle phNewContext,               // (out) New Context handle
    PSecBufferDesc pOutput,                 // (inout) Output Buffers
    unsigned long SEC_FAR * pfContextAttr,  // (out) Context attrs
    PTimeStamp ptsExpiry                    // (out) Life span (OPT)
    )
{
    PSTR pszTargetNameA = NULL;
    ULONG err;
    SECURITY_STATUS rc = SEC_E_INSUFFICIENT_MEMORY;

    //
    // Convert parameters to Ansi
    //
    err = FromUnicodeWithAlloc(pszTargetName,
                               &pszTargetNameA,
                               LDAP_ANSI_SIGNATURE,
                               LANG_ACP);
    if (err != LDAP_SUCCESS)
        goto error;

    //
    // Call Ansi function
    //
    ASSERT(SslFunctionTableA);
    ASSERT(SslFunctionTableA->InitializeSecurityContextA);

    rc = SslFunctionTableA->InitializeSecurityContextA(
                                    phCredential,
                                    phContext,
                                    pszTargetNameA,
                                    fContextReq,
                                    Reserved1,
                                    TargetDataRep,
                                    pInput,
                                    Reserved2,
                                    phNewContext,
                                    pOutput,
                                    pfContextAttr,
                                    ptsExpiry);

error:
    //
    // Clean up and leave
    //
    if (pszTargetNameA)
        ldapFree((void*)pszTargetNameA, LDAP_ANSI_SIGNATURE);

    return rc;
}

SECURITY_STATUS SEC_ENTRY
Win9xSslQuerySecurityPackageInfo(
    SEC_WCHAR SEC_FAR * pszPackageName,     // Name of package
    PSecPkgInfoW SEC_FAR *ppPackageInfo     // Receives package info
    )
{
    //
    // This function is not used by us
    //
    ASSERT(FALSE);
    return SEC_E_UNSUPPORTED_FUNCTION;
}


SECURITY_STATUS SEC_ENTRY
Win9xSslImportSecurityContext(
    SEC_WCHAR SEC_FAR *  pszPackage,
    PSecBuffer           pPackedContext,        // (in) marshalled context
    void SEC_FAR *       Token,                 // (in, optional) handle to token for context
    PCtxtHandle          phContext              // (out) new context handle
    )
{
    //
    // This function is not used by us
    //
    ASSERT(FALSE);
    return SEC_E_UNSUPPORTED_FUNCTION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\berdump.c ===
#if	DBG

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsdexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ber.h"

#define iso_member          0x2a,               // iso(1) memberbody(2)
#define us                  0x86, 0x48,         // us(840)
#define rsadsi              0x86, 0xf7, 0x0d,   // rsadsi(113549)
#define pkcs                0x01,               // pkcs(1)

#define rsa_                iso_member us rsadsi
#define rsa_len             6
#define rsa_text            "iso(2) member-body(2) us(840) rsadsi(113549) "
#define pkcs_1              iso_member us rsadsi pkcs
#define pkcs_len            7
#define pkcs_text           "iso(2) member-body(2) us(840) rsadsi(113549) pkcs(1) "


#define joint_iso_ccitt_ds  0x55,
#define attributetype       0x04,

#define attributeType       joint_iso_ccitt_ds attributetype
#define attrtype_len        2

typedef struct _ObjectId {
    UCHAR       Sequence[16];
    DWORD       SequenceLen;
    PSTR        Name;
} ObjectId;

ObjectId    KnownObjectIds[] = {
    { {pkcs_1 1, 1}, pkcs_len + 2, pkcs_text "RSA"},
    { {pkcs_1 1, 2}, pkcs_len + 2, pkcs_text "MD2/RSA"},
    { {pkcs_1 1, 4}, pkcs_len + 2, pkcs_text "MD5/RSA"},
    { {rsa_ 3, 4}, rsa_len + 2, rsa_text "RC4"},
    { {attributeType 3}, attrtype_len + 1, "CN="},
    { {attributeType 6}, attrtype_len + 1, "C="},
    { {attributeType 7}, attrtype_len + 1, "L="},
    { {attributeType 8}, attrtype_len + 1, "S="},
    { {attributeType 10}, attrtype_len + 1, "O="},
    { {attributeType 11}, attrtype_len + 1, "OU="},
    };

ObjectId    KnownPrefixes[] = {
    { {pkcs_1}, pkcs_len, pkcs_text},
    { {iso_member us rsadsi}, pkcs_len - 1, "iso(2) member-body(2) us(840) rsadsi(113549) "},
    { {iso_member us}, pkcs_len - 4, "iso(2) member-body(2) us(840) "},
    { {iso_member}, pkcs_len - 6, "iso(2) member-body(2) " }
    };


typedef struct _NameTypes {
    PSTR        Prefix;
    UCHAR       Sequence[8];
    DWORD       SequenceLen;
} NameTypes;

NameTypes   KnownNameTypes[] = { {"CN=", {attributeType 3}, attrtype_len + 1},
                                 {"C=", {attributeType 6}, attrtype_len + 1},
                                 {"L=", {attributeType 7}, attrtype_len + 1},
                                 {"S=", {attributeType 8}, attrtype_len + 1},
                                 {"O=", {attributeType 10}, attrtype_len + 1},
                                 {"OU=", {attributeType 11}, attrtype_len + 1}
                               };
BYTE        Buffer[1024];

BOOL        BerVerbose = FALSE ;

char maparray[] = "0123456789abcdef";

#define MAX_OID_VALS    32

typedef struct _OID {
    unsigned cVal;
    unsigned Val[MAX_OID_VALS];
} OID;

typedef enum _OidResult {
    OidExact,
    OidPartial,
    OidMiss,
    OidError
} OidResult;


#if 0

extern  PNTSD_EXTENSION_APIS    pExtApis;
extern  HANDLE                  hDbgThread;
extern  HANDLE                  hDbgProcess;

#define DebuggerOut     (pExtApis->lpOutputRoutine)
#define GetSymbol       (pExtApis->lpGetSymbolRoutine)
#define GetExpr         (PVOID) (pExtApis->lpGetExpressionRoutine)
#define InitDebugHelp(hProc,hThd,pApis) {hDbgProcess = hProc; hDbgThread = hThd; pExtApis = pApis;}

#define ExitIfCtrlC()   if (pExtApis->lpCheckControlCRoutine()) return;
#define BreakIfCtrlC()  if (pExtApis->lpCheckControlCRoutine()) break;

#else

#define	DebuggerOut		OutputDebugString
#define	ExitifCtrlC()	((void)0)
#define	BreakIfCtrlC()	((void)0)

#endif


#define LINE_SIZE   192
#define INDENT_SIZE 4

#define OID_VERBOSE 0x0002
#define OID_PARTIAL 0x0001

char * DefaultTree =
   "1 iso\n"
   "    2 memberbody\n"
   "        840 us\n"
   "            113549 rsadsi\n"
   "                1 pkcs\n"
   "                    1 RSA\n"
   "                    3 pkcs-3\n"
   "                        1 dhKeyAgreement\n"
   "                2 digestAlgorithm\n"
   "                    2 MD2\n"
   "                    4 MD4\n"
   "                    5 MD5\n"
   "            113554 mit\n"
   "                1 infosys\n"
   "                    2 gssapi\n"
   "                        1 generic\n"
   "                            1 user_name\n"
   "                            2 machine_uid_name\n"
   "                            3 string_uid_name\n"
   "            113556 microsoft\n"
   "                1 ds\n"
   "    3 org\n"
   "        6 dod\n"
   "            1 internet\n"
   "                4 private\n"
   "                    1 enterprise\n"
   "                        311 microsoft\n"
   "                            1 software\n"
   "                                1 systems\n"
   "                                2 wins\n"
   "                                3 dhcp\n"
   "                                4 apps\n"
   "                                5 mos\n"
   "                                7 InternetServer\n"
   "                                8 ipx\n"
   "                                9 ripsap\n"
   "                            2 security\n"
   "                                1 certificates\n"
   "                                2 mechanisms\n"
   "                                    9 Negotiator\n"
   "                                    10 NTLM\n"
   "                                    12 SSL\n"
   "                5 security\n"
   "                    3 integrity\n"
   "                        1 md5-DES-CBC\n"
   "                        2 sum64-DES-CBC\n"
   "                    5 mechanisms\n"
   "                        1 spkm\n"
   "                            1 spkm-1\n"
   "                            2 spkm-2\n"
   "                            10 spkmGssTokens\n"
   "                    6 nametypes\n"
   "                        2 gss-host-based-services\n"
   "                        3 gss-anonymous-name\n"
   "                        4 gss-api-exported-name\n"
   "        14 oiw\n"
   "            3 secsig\n"
   "                2 algorithm\n"
   "                    7 DES-CBC\n"
   "                    10 DES-MAC\n"
   "                    18 SHA\n"
   "                    22 id-rsa-key-transport\n"
   "2 joint-iso-ccitt\n"
   "    5 ds\n"
   "        4 attribute-type\n"
   "            3 CommonName\n"
   "            6 Country\n"
   "            7 Locality\n"
   "            8 State\n"
   "            10 Organization\n"
   "            11 OrgUnit\n"
    ;


typedef struct _TreeFile {
    CHAR *  Buffer;
    CHAR *  Line;
    CHAR *  CurNul;
} TreeFile, * PTreeFile ;


BOOL
TreeFileInit(
    PTreeFile   pFile,
    PSTR        pStr)
{
    int l;


    l = strlen( pStr );

    if ( (pStr[l - 1] != '\r') &&
         (pStr[l - 1] != '\n') )
    {
        l++;
    }

    pFile->Buffer = LocalAlloc( LMEM_FIXED, l );

    if ( pFile->Buffer )
    {
        strcpy( pFile->Buffer, pStr );
        pFile->Line = pFile->Buffer ;
        pFile->CurNul = NULL ;
    }

    return (pFile->Buffer != NULL);

}

VOID
TreeFileDelete(
    PTreeFile   pFile
    )
{
    LocalFree( pFile->Buffer );

}

PSTR
TreeFileGetLine(
    PTreeFile   pFile )
{
    PSTR    Scan;
    PSTR    Line;

    if ( !pFile->Line )
    {
        return( NULL );
    }

    if ( pFile->CurNul )
    {
        *pFile->CurNul = '\n';
    }

    pFile->CurNul = NULL ;

    Scan = pFile->Line ;

    while ( *Scan && (*Scan != '\n') && (*Scan != '\r'))
    {
        Scan++;
    }

    //
    // Okay, get the line to return
    //

    Line = pFile->Line;

    //
    // If this is not the end, touch up the pointers:
    //

    if ( *Scan )
    {
        *Scan = '\0';

        pFile->CurNul = Scan;

        Scan += 1;

        while ( *Scan && ( (*Scan == '\r' ) || ( *Scan == '\n') ))
        {
            Scan++ ;
        }

        //
        // If this is the end, reset line
        //

        if ( *Scan == '\0' )
        {
            pFile->Line = NULL ;
        }
        else
        {
            pFile->Line = Scan;
        }

    }
    else
    {
        pFile->Line = NULL ;
    }

    return( Line );

}

VOID
TreeFileRewind(
    PTreeFile   pFile )
{

    if ( pFile->CurNul )
    {
        *pFile->CurNul = '\n';
    }

    pFile->CurNul = NULL ;

    pFile->Line = pFile->Buffer ;
}

int
tohex(
    BYTE    b,
    PSTR    psz)
{
    BYTE b1, b2;

    b1 = b >> 4;
    b2 = b & 0xF;

    *psz++ = maparray[b1];
    *psz = maparray[b2];

    return(3);
}


//+---------------------------------------------------------------------------
//
//  Function:   DecodeOID
//
//  Synopsis:   Decodes an OID into a simple structure
//
//  Arguments:  [pEncoded] --
//              [len]      --
//              [pOID]     --
//
//  History:    8-07-96   RichardW   Stolen directly from DonH
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
DecodeOID(unsigned char *pEncoded, int len, OID *pOID)
{
    unsigned cval;
    unsigned val;
    int i, j;

    if (len <=2) {
        return FALSE;
    }


    // The first two values are encoded in the first octet.

    pOID->Val[0] = pEncoded[0] / 40;
    pOID->Val[1] = pEncoded[0] % 40;

    //DebuggerOut("Encoded value %02x turned into %d and %d\n", pEncoded[0],
    //          pOID->Val[0], pOID->Val[1] );

    cval = 2;
    i = 1;

    while (i < len) {
        j = 0;
        val = pEncoded[i] & 0x7f;
        while (pEncoded[i] & 0x80) {
            val <<= 7;
            ++i;
            if (++j > 4 || i >= len) {
                // Either this value is bigger than we can handle (we
                // don't handle values that span more than four octets)
                // -or- the last octet in the encoded string has its
                // high bit set, indicating that it's not supposed to
                // be the last octet.  In either case, we're sunk.
                return FALSE;
            }
            val |= pEncoded[i] & 0x7f;
        }
        //ASSERT(i < len);
        pOID->Val[cval] = val;
        ++cval;
        ++i;
    }
    pOID->cVal = cval;

    return TRUE;
}

PSTR
GetLineWithIndent(
    PTreeFile   ptf,
    DWORD       i)
{
    PSTR    Scan;
    DWORD   test;


    do
    {
        Scan = TreeFileGetLine( ptf );


        if ( Scan && i )
        {
            if ( i < INDENT_SIZE )
            {
                test = 0;
            }
            else
            {
                test = i - INDENT_SIZE ;
            }

            if ( Scan[ test ] != ' ' )
            {
                {
                    Scan = NULL ;
                    break;
                }
            }

        }
        else
            test = 0;

    } while ( Scan && (Scan[i] == ' ')  );

    return( Scan );
}

OidResult
scan_oid_table(
    char *  Table,
    DWORD   Flags,
    PUCHAR  ObjectId,
    DWORD   Len,
    PSTR    pszRep,
    DWORD   MaxRep)
{
    CHAR    OidPath[ MAX_PATH ];
    OID     Oid;
    DWORD   i;
    DWORD   Indent;
    TreeFile    tf;
    PSTR    Scan;
    PSTR    Tag;
    PSTR    SubScan;
    DWORD   Index;
    DWORD   size;
    DWORD   TagSize;

    if (!DecodeOID( ObjectId, Len, &Oid ))
    {
        return( OidError );
    }


    i = 0;

    Indent = 0;

    if ( !TreeFileInit( &tf, Table ) )
    {
#if defined(DBG) && defined(ENABLE_DEBUG_OUTPUT)
        DebuggerOut("Unable to load prefix table\n");
#endif /* defined(DBG) && defined(ENABLE_DEBUG_OUTPUT) */
        return OidError ;
    }

    Tag = OidPath;

    size = 0;

    TagSize = 0;


    if ( (Flags & OID_VERBOSE) == 0 )
    {
        while ( i < Oid.cVal )
        {
            TagSize = _snprintf( Tag, MAX_PATH - size, "%d.",
                            Oid.Val[i] );

            size += TagSize;

            Tag += TagSize;

            i++;

        }

        strncpy( pszRep, OidPath, MaxRep );

        TreeFileDelete( &tf );

        return( OidExact );
    }

    while ( i < Oid.cVal )
    {

        do
        {

            Scan = GetLineWithIndent( &tf, Indent );


            if ( Scan )
            {
                Index = atoi(Scan);
            }
            else
            {
                Index = (DWORD) -1;
            }

            if ( Index == Oid.Val[i] )
            {
                break;
            }

        } while ( Scan );


        //
        // If Scan is NULL, we didn't get a match
        //

        if ( !Scan )
        {
            if ( i > 0 )
            {
                if ( Flags & OID_PARTIAL )
                {
                    while ( i < Oid.cVal )
                    {
                        TagSize = _snprintf( Tag, MAX_PATH - size, "%d ",
                                        Oid.Val[i] );

                        size += TagSize;

                        Tag += TagSize;

                        i++;

                    }
                    strncpy( pszRep, OidPath, MaxRep );
                }

                TreeFileDelete( &tf );

                return( OidPartial );

            }

            TreeFileDelete( &tf );

            return( OidMiss );
        }

        //
        // Got a hit:
        //

        SubScan = &Scan[Indent];

        while (*SubScan != ' ')
        {
            SubScan++;
        }

        SubScan++;

        TagSize = _snprintf( Tag, MAX_PATH - size, "%s(%d) ", SubScan, Index );

        size += TagSize;

        Tag += TagSize ;

        Indent += INDENT_SIZE ;

        i ++;


    }

    strncpy( pszRep, OidPath, MaxRep );

    TreeFileDelete( &tf );

    return( OidExact );


}

decode_to_string(
    LPBYTE  pBuffer,
    DWORD   Flags,
    DWORD   Type,
    DWORD   Len,
    PSTR    pszRep,
    DWORD   RepLen)
{
    PSTR    pstr;
    PSTR    lineptr;
    DWORD   i;


    switch (Type)
    {
        case BER_NULL:
            strcpy(pszRep, "<empty>");
            break;

        case BER_OBJECT_ID:
            scan_oid_table( DefaultTree,
                            OID_PARTIAL | (Flags & DECODE_VERBOSE_OIDS ? OID_VERBOSE : 0 ),
                            pBuffer, Len, pszRep, RepLen );

            break;

        case BER_PRINTABLE_STRING:
        case BER_TELETEX_STRING:
        case BER_GRAPHIC_STRING:
        case BER_VISIBLE_STRING:
        case BER_GENERAL_STRING:
            CopyMemory(pszRep, pBuffer, min(Len, RepLen - 1) );
            pszRep[min(Len, RepLen - 1)] = '\0';
            break;

        default:

            pstr = &pszRep[30];
            lineptr = pszRep;
            for (i = 0; i < min(Len, 8) ; i++ )
            {
                lineptr += tohex(*pBuffer, lineptr);
                if ((*pBuffer >= ' ') && (*pBuffer <= '|'))
                {
                    *pstr++ = *pBuffer;
                }
                else
                {
                    *pstr++ = '.';
                }

                pBuffer++;

            }
            *pstr++ = '\0';
    }
    return(0);
}

int
ber_decode(
    OutputFn Out,
    StopFn  Stop,
    LPBYTE  pBuffer,
    DWORD   Flags,
    int   Indent,
    int   Offset,
    int   TotalLength,
    int   BarDepth)
{
    char *  TypeName = NULL;
    char    msg[32];
    char *  pstr;
    int     i;
    int     Len;
    int     ByteCount;
    int     Accumulated;
    DWORD   Type;
    int     subsize;
    char    line[ LINE_SIZE ];
    BOOL    Nested;
    BOOL    Leaf;
    int     NewBarDepth;
    char    nonuniversal[ LINE_SIZE ];



    if ((Stop)())
    {
        return(0);
    }

    Type = *pBuffer;


	switch (Type & 0xC0) {
    case BER_UNIVERSAL:

        switch ( Type & 0x1F )
        {
            case BER_BOOL:
                TypeName = "Bool";
                break;

            case BER_INTEGER:
                TypeName = "Integer";
                break;

            case BER_BIT_STRING:
                TypeName = "Bit String";
                break;

            case BER_OCTET_STRING:
                TypeName = "Octet String";
                if ( Flags & DECODE_NEST_OCTET_STRINGS )
                {
                    TypeName = "Octet String (Expanding)";
                    Type |= BER_CONSTRUCTED ;
                    Flags &= ~( DECODE_NEST_OCTET_STRINGS );
                }
                break;

            case BER_NULL:
                TypeName = "Null";
                break;

            case BER_OBJECT_ID:
                TypeName = "Object ID";
                break;

            case BER_OBJECT_DESC:
                TypeName = "Object Descriptor";
                break;

            case BER_SEQUENCE:
                TypeName = "Sequence";
                break;

            case BER_SET:
                TypeName = "Set";
                break;

            case BER_NUMERIC_STRING:
                TypeName = "Numeric String";
                break;

            case BER_PRINTABLE_STRING:
                TypeName = "Printable String";
                break;

            case BER_TELETEX_STRING:
                TypeName = "TeleTex String";
                break;

            case BER_VIDEOTEX_STRING:
                TypeName = "VideoTex String";
                break;

            case BER_VISIBLE_STRING:
                TypeName = "Visible String";
                break;

            case BER_GENERAL_STRING:
                TypeName = "General String";
                break;

            case BER_GRAPHIC_STRING:
                TypeName = "Graphic String";
                break;

            case BER_UTC_TIME:
                TypeName = "UTC Time";
                break;


            default:
                TypeName = "Unknown";
                break;
        }
		break;

        case BER_APPLICATION:
            sprintf( nonuniversal, "[Application %d]", Type & 0x1F);
            TypeName = nonuniversal;
            break;

        case BER_CONTEXT_SPECIFIC:
            sprintf( nonuniversal, "[Context Specific %d]", Type & 0x1F);
            TypeName = nonuniversal;
            break;

        case BER_PRIVATE:
            sprintf( nonuniversal, "[Private %d]", Type & 0x1F);
            TypeName = nonuniversal ;
            break;
    }


    pstr = msg;
    for (i = 0; i < Indent ; i++ )
    {
        if (i < BarDepth)
        {
            *pstr++ = '|';
        }
        else
        {
            *pstr++ = ' ';
        }
        *pstr++ = ' ';
    }
    *pstr++ = '\0';

    pBuffer ++;
    Len = 0;

    if (*pBuffer & 0x80)
    {
        ByteCount = *pBuffer++ & 0x7f;

        for (i = 0; i < ByteCount ; i++ )
        {
            Len <<= 8;
            Len += *pBuffer++;
        }
    }
    else
    {
        ByteCount = 0;
        Len = *pBuffer++;
    }

    if (Offset + Len + 2 + ByteCount == TotalLength)
    {
        Leaf = TRUE;
    }
    else
    {
        Leaf = FALSE;
    }

    if (Type & BER_CONSTRUCTED)
    {
        Nested = TRUE;
    }
    else
    {
        Nested = FALSE;
    }

    (Out)("%s%c-%cType = %s [%02XH], Length = %d, %s ",
		msg,
		Leaf ? '+' /* supposed to be top-to-right bar */ : '+',
		Nested ? '+' : '-',
		TypeName, Type, Len,
		(Type & BER_CONSTRUCTED) ? "Constructed" : "Primitive");

    if (Type & BER_CONSTRUCTED)
    {
        (Out)("\n");
        Accumulated = 0;
        while (Accumulated < Len)
        {
            if (BarDepth < Indent)
            {
                NewBarDepth = BarDepth;
            }
            else
            {
                NewBarDepth = (Nested && Leaf) ? BarDepth : Indent + 1;
            }

            subsize = ber_decode(Out, Stop, pBuffer, Flags, Indent + 1,
                                    Accumulated, Len, NewBarDepth);
            Accumulated += subsize;
            pBuffer += subsize;
        }

        (Out)("%s%c\n", msg, ((Indent <= BarDepth) && !Leaf) ? 179 : 32);
    }
    else
    {
        memset(line, ' ', LINE_SIZE - 1);
        line[ LINE_SIZE - 1 ] = '\0';

        decode_to_string(pBuffer, Flags, Type, Len, line, LINE_SIZE);

        (Out)(" Value = %s\n", line);

    }

    return(Len + 2 + ByteCount);
}

BOOL
NeverStop(void)
{
    return(FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\cblist.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cbridgelist.h

Abstract:

    Functions for managing the list of Call bridge instances.

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef __h323ics_cblist_h
#define __h323ics_cblist_h

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

void	CallBridgeListStart		(void);
void	CallBridgeListStop		(void);
HRESULT	CallBridgeListRemove	(CALL_BRIDGE *);
HRESULT	CallBridgeListInsert	(CALL_BRIDGE *);


#endif //_portmgmt_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\crv.h ===
#ifndef __h323fltr_crv_h__
#define __h323fltr_crv_h__

HRESULT InitCrvAllocator();

HRESULT CleanupCrvAllocator();

// This should be moved into some common.h file
// The H.225 spec calls for a 2 byte call reference value
typedef WORD  CALL_REF_TYPE;

// If this flag is set in the CallReferenceValue then the
// PDU is sent by the originator of the call and vice-versa.
#define CALL_REF_FLAG 0x8000

// allocate a call reference value
// uses random numbers to exploit sparse usage of the
// call reference value space
BOOL    AllocCallRefVal(
    OUT CALL_REF_TYPE &CallRefVal
    );

// frees a currently allocated call ref value
void    DeallocCallRefVal(
    IN CALL_REF_TYPE CallRefVal
    );

#endif // __h323fltr_crv_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\dynarray.h ===
#ifndef	__h323ics_dynarray_h
#define	__h323ics_dynarray_h

// a dense array

typedef const void * BINARY_SEARCH_KEY;
template <class OBJECT>
class	DYNAMIC_ARRAY
{
public:

	// returns positive if ObjectA > ObjectB
	// returns negative if ObjectA < ObjectB
	// returns zero if ObjectA = ObjectB

	typedef int (__cdecl * COMPARE_FUNC) (const OBJECT * ObjectA, const OBJECT * ObjectB);

public:

	OBJECT *	Data;
	DWORD		Length;
	DWORD		MaxLength;

public:

	void	Clear	(void) {
		Length = 0;
	}

	void	Free	(void) {
		if (Data) {
			HeapFree (GetProcessHeap(), 0, Data);

			Data = NULL;
			Length = 0;
			MaxLength = 0;
		}
		else {
			_ASSERTE (!Length);
			_ASSERTE (!MaxLength);
		}
	}

	DWORD	GetLength	(void)	{ return Length; }
	DWORD	GetMax		(void)	{ return MaxLength; }

	BOOL	Grow	(DWORD MaxLengthRequested) {
		OBJECT *	NewData;
		DWORD		NewMaxLength;				// in OBJECT units
		DWORD		BytesRequested;

		if (MaxLengthRequested <= MaxLength)
			return TRUE;

		// very arbitrary heuristic
		NewMaxLength = MaxLengthRequested + (MaxLengthRequested >> 1) + 0x20;
		BytesRequested = NewMaxLength * sizeof (OBJECT);

		if (Data) {
			NewData = (OBJECT *) HeapReAlloc (GetProcessHeap(), 0, Data, BytesRequested);
			if (!NewData)
				DebugF (_T("DYNAMIC_ARRAY::Grow: HeapReAlloc failed, BytesRequested %08XH\n"), BytesRequested);
		}
		else {
			NewData = (OBJECT *) HeapAlloc (GetProcessHeap(), 0, BytesRequested);
			if (!NewData)
				DebugF (_T("DYNAMIC_ARRAY::Grow: HeapAlloc failed, BytesRequested %08XH\n"), BytesRequested);
		}

		if (!NewData)
			return FALSE;

		Data = NewData;
		MaxLength = NewMaxLength;

		return TRUE;
	}

	OBJECT *	AllocRangeAtPos	(DWORD pos, DWORD RangeLength) {
		_ASSERTE (pos <= Length);

		if (!Grow (Length + RangeLength))
			return NULL;

        memmove (Data + pos + RangeLength, Data + pos, (Length - pos) * sizeof (OBJECT));

		Length += RangeLength;

		return Data + pos;
	}

	OBJECT *	AllocAtPos	(DWORD pos) {

        return AllocRangeAtPos (pos, 1);
	}

	OBJECT *	AllocAtEnd	(void) {

        return AllocAtPos (Length);
	}

	void	DeleteRangeAtPos	(DWORD pos, DWORD RangeLength) {
		_ASSERTE (Data);
		_ASSERTE (MaxLength);
		_ASSERTE (Length);
		_ASSERTE (pos < Length);
        _ASSERTE (Length - pos >= RangeLength);
        
        memmove (Data + pos, Data + pos + RangeLength, (Length - pos - RangeLength) * sizeof (OBJECT));

        Length -= RangeLength;
	}

	void	DeleteAtPos		(DWORD pos) {

        DeleteRangeAtPos (pos, 1);

	}

	void	DeleteEntry	(OBJECT * Object) {
		_ASSERTE (Object >= Data);
		_ASSERTE (Object < Data + Length);

		DeleteAtPos ((DWORD)(Object - Data));
	}

	DYNAMIC_ARRAY	(void)
		: Data (NULL), Length (0), MaxLength (0) {}

	~DYNAMIC_ARRAY	(void) {
		Free();
	}

	void	QuickSort	(COMPARE_FUNC CompareFunc) {
		qsort (Data, Length, sizeof (OBJECT), (int (__cdecl *) (const void *, const void *)) CompareFunc);
	}


	// a templatized version of BinarySearch
	// SearchFunc should:
	// return positive if SearchKey > Comparand
	// return negative if SearchKey < Comparand
	// return zero if SearchKey = Comparand
	template <class SEARCH_KEY>
	BOOL BinarySearch (
		IN	INT (*SearchFunc) (const SEARCH_KEY * SearchKey, const OBJECT * Comparand),
		IN	const SEARCH_KEY *	SearchKey,
		OUT	DWORD *				ReturnIndex)
	{
		DWORD		Start;
		DWORD		End;
		DWORD		Index;
		OBJECT *	Object;
		int			CompareResult;

		assert (ReturnIndex);

		Start = 0;
		End = Length;

		for (;;) {

			Index = (Start + End) / 2;

			if (Index == End) {
				*ReturnIndex = Index;
				return FALSE;
			}

			Object = Data + Index;

			CompareResult = (*SearchFunc) (SearchKey, Object);

			if (CompareResult == 0) {
				*ReturnIndex = Index;
				return TRUE;
			}
			else if (CompareResult > 0) {
				Start = Index + 1;
			}
			else {
				End = Index;
			}
		}
	
	}

	BOOL FindIndex (COMPARE_FUNC	CompareFunc,
					OBJECT *		ObjectArg,
					DWORD *			ReturnIndex)
	{
		DWORD	Start;
		DWORD	End;
		DWORD	Index;
		OBJECT *Object;
		int		CompareResult;

		_ASSERTE (ReturnIndex);

		Start = 0;
		End = Length;

		for (;;) {

			Index = (Start + End) / 2;

			if (Index == End) {
				*ReturnIndex = Index;
				return FALSE;
			}

			Object = Data + Index;

			CompareResult = (*CompareFunc)(ObjectArg, Object);

			if (CompareResult == 0) {
				*ReturnIndex = Index;
				return TRUE;
			}
			else if (CompareResult > 0) {
				Start = Index + 1;
			}
			else {
				End = Index;
			}
		}
	
	}

	void	GetExtents	(
		OUT	OBJECT **	ReturnStart,
		OUT	OBJECT **	ReturnEnd)
	{
		_ASSERTE (ReturnStart);
		_ASSERTE (ReturnEnd);

		*ReturnStart = Data;
		*ReturnEnd = Data + Length;
	}

	OBJECT &	operator[]	(
		IN	DWORD	Index)
	{
		_ASSERTE (Index >= 0);
		_ASSERTE (Index < Length);

		return Data [Index];
	}
};

    // Hack/Hint for Alpha compiler
#define DECLARE_SEARCH_FUNC_CAST_X(Suffix,Key,Object)  typedef INT (* SEARCH_FUNC_##Suffix)(const Key *, const Object *)
#define DECLARE_SEARCH_FUNC_CAST(Key,Object) DECLARE_SEARCH_FUNC_CAST_X(Object,Key,Object)

	// I hope these don't conflict with someone else's m_Array, etc.
	// Should eventually globally replace all references to the right names
#define	m_Array		Data
#define	m_Length	Length
#define	m_Max		MaxLength


#endif // __h323ics_dynarray_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\emaccept.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    emaccept.cpp

Abstract:

    Contains all the event manager routines which
    manage the overlapped accept operations.

Environment:

    User Mode - Win32

History:

    1. created 
        Ajay Chitturi (ajaych)  12-Jun-1998

--*/




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "cbridge.h"
#include "ovioctx.h"
#include "cblist.h"
#include "main.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Constants	                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// Maximum number of simulatenous pending connections
const UINT MAX_LISTEN_BACKLOG =	5U;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static PAcceptContext g_pQ931AcceptCtxt = NULL;
static USHORT g_usQ931ConnectionPort = 0U;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Externally defined identifiers                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Overlapped accept functions                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT 
EventMgrCreateAcceptContext(IN  OVERLAPPED_PROCESSOR *pOvProcessor, 
                            IN  struct sockaddr_in   *pBindAddress,
                            OUT PAcceptContext       *ppAcceptCtxt)
/*++

Routine Description:

    This function creates a socket, binds it to bindAddress and
    issues a listen. It creates the Accept I/O Context and returns
    it to the caller.

Arguments:

    pOvProcessor - pointer to the overlapped processor object.
        Once the accept completes the callback of this object is 
        called.

    pBindAddress - pointer to the address to listen on.

    ppAcceptCtxt - A new Accept I/O context is allocated initialized
        and returned through this OUT parameter.

Return Values:

    Returns S_OK on success, E_OUTOFMEMORY if the memory allocator fails
    or E_FAIL if any of the Winsock functions fail.
    CODEWORK: map the exact winsock error to HRESULT and return it
    Document all possible errors

--*/
{
    SOCKET  listenSock;
    DWORD   err;
    PAcceptContext pAcceptCtxt;
    *ppAcceptCtxt = NULL;

	// Create an overlapped socket
	listenSock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, 
						   NULL, 0, 
						   WSA_FLAG_OVERLAPPED);

	if (listenSock == INVALID_SOCKET) 
	{
		DBGOUT((LOG_FAIL, 
				"Error creating listener socket error: %d pOvProcessor: %p\n",
				WSAGetLastError(), pOvProcessor));
		return E_FAIL; // CODEWORK what is the right error to return
	}

	// Bind the socket to the listen address
	if (bind(listenSock, 
			 (struct sockaddr *)pBindAddress,
			 sizeof(struct sockaddr_in)) == SOCKET_ERROR)
	{
		DBGOUT((LOG_FAIL, "bind() failed error: %d\n", WSAGetLastError()));
		closesocket(listenSock);
		listenSock = INVALID_SOCKET;
		return E_FAIL; // CODEWORK what is the right error ?
	}

    // Bind the socket handle to the I/O completion port
    if (EventMgrBindIoHandle(listenSock) != S_OK)
    {
        DBGOUT((LOG_FAIL, 
                "binding socket:%d to IOCP failed\n", 
                listenSock));
        closesocket(listenSock);
		listenSock = INVALID_SOCKET;
        return E_FAIL;
    }

    
    if (listen(listenSock, MAX_LISTEN_BACKLOG) == SOCKET_ERROR) 
    {
        DBGOUT((LOG_FAIL, 
                "listen() failed: 0x%x pOvProcessor; %p\n", 
                WSAGetLastError(), pOvProcessor));
        closesocket(listenSock);
		listenSock = INVALID_SOCKET;
        return E_FAIL; //WSAGetLastError(); XXX what is the right way
    }
    
    // Allocate memory from a private heap for accept contexts
    pAcceptCtxt = (PAcceptContext) HeapAlloc(g_hAcceptCtxtHeap, 
                                             0, // No Flags
                                             sizeof(AcceptContext));
    if (!pAcceptCtxt)
    {
        DBGOUT((LOG_FAIL, "Could not allocate Accept context"));
        closesocket(listenSock);
		listenSock = INVALID_SOCKET;

        return E_OUTOFMEMORY;
    }

    memset(pAcceptCtxt, 0, sizeof(AcceptContext));
    pAcceptCtxt->ioCtxt.reqType = EMGR_OV_IO_REQ_ACCEPT;
    pAcceptCtxt->ioCtxt.pOvProcessor = pOvProcessor;
    pAcceptCtxt->listenSock = listenSock;
    pAcceptCtxt->acceptSock = INVALID_SOCKET;
    
    *ppAcceptCtxt = pAcceptCtxt;
    return S_OK;
}



void
EventMgrFreeAcceptContext(PAcceptContext pAcceptCtxt)
/*++

Routine Description:

    This function frees the pAcceptCtxt.
    OvProcessor is owned by the Call Bridge Machine and 
    so we do not free it.

Arguments:

    pAcceptCtxt - pointer to the AcceptCtxt to be freed.

Return Values:

    This function has not return value.

--*/
{
    if (pAcceptCtxt->acceptSock != INVALID_SOCKET)
    {
        closesocket(pAcceptCtxt->acceptSock);
		pAcceptCtxt -> acceptSock = INVALID_SOCKET;
    }

    HeapFree(g_hAcceptCtxtHeap, 
             0, // no flags
             pAcceptCtxt);
}




HRESULT EventMgrIssueAcceptHelperFn(PAcceptContext pAcceptCtxt)
/*++

Routine Description:

    This function issues an Asynchronous overlapped accept using
    AcceptEx(). The accept socket is created and stored in the
    Accept context before making the call to AcceptEx().

    In case of an error, the caller needs to free pAcceptCtxt.

Arguments:

    pAcceptCtxt - pointer to the Accept I/O context.

Return Values:

    This function returns S_OK in case of success or E_FAIL
    in case of an error.
    CODEWORK: Need to convert Winsock errors to HRESULT and 
    return them instead.

--*/
{
    SOCKET acceptSock;
    DWORD lastError, bytesRead;
    HRESULT hRes = S_OK;

    _ASSERTE(pAcceptCtxt);

    // create an overlapped socket
    acceptSock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, 
                           NULL, 0, 
                           WSA_FLAG_OVERLAPPED);

    if (acceptSock == INVALID_SOCKET) 
    {
        DBGOUT((LOG_FAIL, "Error creating accept socket: %d\n",
                WSAGetLastError()));
        return E_FAIL;
    }

    pAcceptCtxt->acceptSock = acceptSock;

    // Bind the socket handle to the I/O completion port
    if (EventMgrBindIoHandle(acceptSock) != S_OK)
    {
        DBGOUT((LOG_FAIL, 
                "binding socket:%d to IOCP failed\n", 
                acceptSock));
        return E_FAIL;
    }

    memset(&pAcceptCtxt->ioCtxt.ov, 0, sizeof(OVERLAPPED));

    pAcceptCtxt->ioCtxt.pOvProcessor->GetCallBridge().AddRef();
       
	// Issue overlapped accept
     if (!AcceptEx(pAcceptCtxt->listenSock, 
                  acceptSock,
                  pAcceptCtxt->addrBuf,
                  0, // Read nothing from socket
                  sizeof(struct sockaddr_in) + 16,
                  sizeof(struct sockaddr_in) + 16,
                  &bytesRead,
                  &pAcceptCtxt->ioCtxt.ov)) 
    {
        lastError = WSAGetLastError();
        if (lastError != ERROR_IO_PENDING) 
        {
            pAcceptCtxt->ioCtxt.pOvProcessor->GetCallBridge().Release();
            
            // This means the overlapped AcceptEx() failed
            DBGOUT((LOG_FAIL, 
                "AcceptEx() failed error: %d listenSock: %d acceptSock: %d\n",
                lastError, pAcceptCtxt->listenSock,
                pAcceptCtxt->acceptSock));
            return E_FAIL;
        }
    }

	return S_OK;

}



HRESULT EventMgrIssueAccept(IN DWORD bindIPAddress,
                            IN OVERLAPPED_PROCESSOR &rOvProcessor,
                            OUT WORD& rBindPort,
                            OUT SOCKET& rListenSock)
/*++

Routine Description:

    This function is exported to the Call Bridge machine for
    making an asynchronous accept request for H.245 connections. 
    Once the accept is completed, the accept callback function on 
    rOvProcessor is called.
    
    This function calls bind() with on IP address "bindIPAddress"
    and port 0. Winsock allocates a free port which is got using
    getsockname(). This port is returned using the OUT param
    rBindPort.

    This function also returns the listen socket using the OUT
    param rListenSock. The Call Bridge machine can use this 
    socket to cancel the asynchronous Accept() request.
    Once this function succeeds only the Call bridge frees the
    listen socket.

Arguments:

    bindIPAddress - This is the IP address to listen on.
        This is in host byte order.

    rOvProcessor - A reference to the Overlapped processor. This
        is stored in the Accept I/O context. Once the accept 
        completes the AcceptCallback() on this object is called.

    rBindPort - The port on which the listen is issued is returned
        through this OUT param. This function calls bind() with on 
        IP address "bindIPAddress" and port 0. Winsock allocates a 
        free port which is got using getsockname(). This port is 
        returned using the OUT param rBindPort.
        The port returned is in host byte order.

    rListenSock - The listening socket is returned through this OUT
        param. The Call Bridge machine can use this socket to cancel 
        the asynchronous Accept() request. Once this function succeeds 
        only the Call bridge frees the listen socket.

Return Values:

    This function returns S_OK in case of success or E_FAIL
    in case of a failure.

--*/
{
    PAcceptContext pAcceptCtxt;
    struct sockaddr_in bindAddress;
    HRESULT hRes;
    int bindAddressLen = sizeof(struct sockaddr_in);

    memset(&bindAddress, 0, sizeof(bindAddress));

    bindAddress.sin_family      = AF_INET;
    bindAddress.sin_addr.s_addr = htonl(bindIPAddress);
    bindAddress.sin_port = htons(0);
    
    hRes = EventMgrCreateAcceptContext(&rOvProcessor,
                                       &bindAddress, &pAcceptCtxt);
    if (hRes != S_OK)
        return hRes;

    // Get the port
    if (getsockname(pAcceptCtxt->listenSock,
                    (struct sockaddr *)&bindAddress,
                    &bindAddressLen))
    {
        closesocket(pAcceptCtxt->listenSock);
        pAcceptCtxt->listenSock = INVALID_SOCKET;

		EventMgrFreeAcceptContext(pAcceptCtxt);
        return E_FAIL;
    }

    rBindPort = ntohs(bindAddress.sin_port);

    hRes = EventMgrIssueAcceptHelperFn(pAcceptCtxt);

    if (hRes != S_OK)
    {
		closesocket(pAcceptCtxt->listenSock);
        pAcceptCtxt->listenSock = INVALID_SOCKET;

        EventMgrFreeAcceptContext(pAcceptCtxt);
        return hRes;
    }

    rListenSock = pAcceptCtxt->listenSock;
    return S_OK;
}



void HandleAcceptCompletion(PAcceptContext pAcceptCtxt, DWORD status)
/*++

Routine Description:

    This function is called by the event loop when an accept I/O completes.
    The Call Bridge Machine's accept callback function is called for
    H.245 connections. 
  
    This function always frees pAcceptCtxt if another accept is not issued.
   
Arguments:

    pAcceptCtxt - The Accept I/O context. This contains the overlapped
        context on which the accept callback is called in the case of 
        H.245 connections and the listen and accept sockets.

    status - This conveys the WIN32 error status.

Return Values:

    This function does not return any error code. In case of an error,
    the call bridge machine is notified about the error in the callback.

--*/
{
    int locallen = sizeof(struct sockaddr_in);
    int remotelen = sizeof(struct sockaddr_in);
    struct sockaddr_in *pLocalAddr;
    struct sockaddr_in *pRemoteAddr;

    // If H.245 call the accept callback on overlapped processor
    // and free the accept I/O context.
    // The listening socket is closed by the Call bridge machine.
    if (status == NO_ERROR)
    {
        if (setsockopt(pAcceptCtxt->acceptSock,
                       SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT,
                       (char*)(&pAcceptCtxt->listenSock),
                       sizeof(SOCKET)) == SOCKET_ERROR)
        {
            DBGOUT((LOG_FAIL,
                    "setsockopt SO_UPDATE_ACCEPT_CONTEXT failed"
                    "acceptSock: %d listenSock: %d err: %d\n",
                    pAcceptCtxt->acceptSock, 
                    pAcceptCtxt->listenSock,
                    WSAGetLastError()));

            // make callback conveying the error

			SOCKADDR_IN	LocalAddress;
			SOCKADDR_IN	RemoteAddress;

			ZeroMemory (&LocalAddress, sizeof (SOCKADDR_IN));
			ZeroMemory (&RemoteAddress, sizeof (SOCKADDR_IN));

            pAcceptCtxt->ioCtxt.pOvProcessor->AcceptCallback(
                              WSAGetLastError(),
                              INVALID_SOCKET,
							  &LocalAddress,
							  &RemoteAddress);

        } else {

			// This function does not return anything
			GetAcceptExSockaddrs(pAcceptCtxt->addrBuf, 0,
							  sizeof(struct sockaddr_in) + 16,
							  sizeof(struct sockaddr_in) + 16,
							  (struct sockaddr**)&pLocalAddr,
							  &locallen,
							  (struct sockaddr**)&pRemoteAddr,
							  &remotelen);

			// make the callback
			pAcceptCtxt->ioCtxt.pOvProcessor->AcceptCallback(
								  S_OK,
								  pAcceptCtxt->acceptSock,
								  pLocalAddr,
								  pRemoteAddr);

			// ownership of pAcceptCtxt -> acceptSock has been transferred,
			// so we need to make sure the acceptSock won't be used
			pAcceptCtxt -> acceptSock = INVALID_SOCKET;
		}

    } // if (status == NO_ERROR)

    else
    {
        DBGOUT((LOG_FAIL,
                "error on H.245 accept callback: %d\n", 
                status));


		SOCKADDR_IN	LocalAddress;
		SOCKADDR_IN	RemoteAddress;

		ZeroMemory (&LocalAddress, sizeof (SOCKADDR_IN));
		ZeroMemory (&RemoteAddress, sizeof (SOCKADDR_IN));

        // make callback conveying the error
        pAcceptCtxt->ioCtxt.pOvProcessor->AcceptCallback(
                              HRESULT_FROM_WIN32_ERROR_CODE(status),
                              INVALID_SOCKET,
							  &LocalAddress,
							  &RemoteAddress);

    }

	EventMgrFreeAcceptContext (pAcceptCtxt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\cbridge.h ===
/*---------------------------------------------------
Copyright (c) 1998, Microsoft Corporation
File: cbridge.h

Purpose: 

    Contains the call bridge class declaration.
    Associated Q931 and H245 protocol stack related classes
    and constants are also declared here.

History:

    1. created 
        Byrisetty Rajeev (rajeevb)  12-Jun-1998
    2. moved several inline functions to q931.cpp, h245.cpp 
        (rajeevb, 21-Aug-1998)

---------------------------------------------------*/

#ifndef __PXSVC_CALL_BRIDGE_H__
#define __PXSVC_CALL_BRIDGE_H__

/*---------------------------------------------------
 DESIGN OVERVIEW:

    The CALL_BRIDGE completely describes an H.323 call being proxied. The
    proxy receives a call from the source and then originates a call
    to the destination. Each of these calls is represented by an H323_STATE.
    PDUs received on one call are processed and passed on to the other call.

    A source leads an H.323 call with Q.931. The SETUP PDU contains info for
    the proxy to locate the destination. The two end points exchange their
    H.245 channel addresses at this stage. This portion of the call is
    encapsulated in Q931_INFO. *The proxy must replace any end-point address
    and port with its own address and port to protect internal corporate
    addresses and retain control of the multi-layered H.323 call setup*.

    The H.245 channel is used to exchange end-point capabilities. This
    information is of no significance today (in future, security exchanges 
    etc. may be done). H245_INFO represents an H.245 channel end-point. We
    merely pass on the source/destination PDUs.

    The H.245 channel is used to maintain (open, close) logical channels. 
    The logical channel messages exchange end-point address and port to
    send audio/video media to. These addresses/ports are replaced with the
    proxy's address/ports. Each logical channel is represented by a 
    LOGICAL_CHANNEL instance. An H245_INFO instance contains an array of
    LOGICAL_CHANNELs which were originated from the corresponding client
    end-point. Hence, all of the logical channel related state is contained
    in a single LOGICAL_CHANNEL instance (unlike two instances for the 
    Q931_INFO and H245_INFO which have a SOURCE and DEST instance).

    Audio/video media are sent in RTP streams (with RTCP for control info).
    The proxy uses NAT to forward these packets after replacing the
    source and destination address/port.


 CLASS HIERARCHY :

    The Q931_INFO and H323_INFO classes need to make overlapped calls to 
    accept connections, send and receive data. The OVERLAPPED_PROCESSOR
    provides call back methods to the event manager and completely 
    encapsulates the socket representing a connection. Both Q931_INFO and
    H323_INFO are derived from it and pass themselves as OVERLAPPED_PROCESSOR
    to the event manager while registering callbacks.

    When making an overlapped call, a context is also passed in. This context
    enables the caller to retrieve relevant information when the corresponding
    callback is received. The EVENT_MANAGER_CONTEXT provides the base class
    abstraction for the callback context. Q931/H245 Source/Dest instances
    derive their own contexts from this base class (for storing their state).

    The Q931_INFO and H323_INFO classes need to create and cancel timers. The
    TIMER_PROCESSOR provides call back methods to the event manager and
    helper methods for this.

    Both SOURCE and DEST versions are derived from the base classes for 
    Q931_INFO, H245_INFO and H323_STATE. While the states and transitions
    for H.245 (for the proxy) are more or less symmetric, those for Q.931
    are quite different. A SOURCE_H323_STATE contains a SOURCE_Q931_INFO and
    a SOURCE_H245_INFO (similarly for the DEST version).

    A CALL_BRIDGE contains a SOURCE_H323_STATE and a DEST_H323_STATE. Hence
    all the Q931, H245 and generic data is stored in a single memory block for
    the CALL_BRIDGE. Additional memory is needed for the LOGICAL_CHANNEL_ARRAY
    (one per H245_INFO instance) and each of the LOGICAL_CHANNEL instances. There
    might be a better way to allocate this memory to reduce memory allocations/freeing.

    A single critical section protects all accesses to a CALL_BRIDGE and
    is acquired inside the CALL_BRIDGE method being called. The CALL_BRIDGE
    also destroys itself when it is appropriate and releases the critical
    section before doing so (The CALL_BRIDGE cannot get called at such a point)

  SCALABILITY ISSUES :

  1. We currently use a single critical section per instance of the CALL_BRIDGE.
    This is clearly not scalable to a large number of connections. We plan 
    to use dynamic critical sections for this. This involves using a pool of
    critical sections and a critical section from the pool is assigned to 
    a CALL_BRIDGE instance dynamically.

  2. We currently need 4 ports (RTP/RTCP send/receive) for each of the two 
    calls being bridged in a CALL_BRIDGE for a total of 8 ports per 
    proxied call. This also means that we would need a socket for each of
    the ports to actually reserve the port. The following approaches will 
    make this scalable -
        * AjayCh is talking with NKSrin for an IOCTL to the TCP/IP stack for
        reserving a pool of ports at a time (just like memory). This would
        thus preclude any need for keeeping a socket open just for reserving
        a port and reduce the number of calls needed to do so.
        * The TCP/IP stack treats ports as global objects and would make the
        reserved port unavailable on ALL interfaces. However, a port can be
        reused several times as long as it satisfies the unique 5tuple 
        requirement for sockets 
        (protocol, src addr, src port, dest addr, dest port). We can reuse 
        the allocated port in the following ways -
            ** for each interface on the machine.
            ** for each different remote end-point address/port pairs
---------------------------------------------------*/

/*---------------------------------------------------
 NOTES:

 1. Typically, constructors are avoided and replaced by Init fns as
    they can return error codes.

 2. The attempt is to convert all error codes to HRESULTs as early in
    the execution as possible.

 3. Separate heaps are used for different classes. This reduces heap
    contention as well as fragmentation. This is done by over-riding
    new/delete.

 4. inline fns are used where 
        - a virtual fn is not needed
            - amount of code is small   AND/OR
            - number of calls to the fn is few (1-2).

    since some inline fn definitions involve calling other inline
    functions, there are several dependencies among the classes
    declared below. This forces declaration of all these classes
    in a single header file.

 5. We need to count all outstanding overlapped calls and make sure
    there are none before destroying a CALL_BRIDGE instance (to avoid
    avs when the event manager calls back and to release the associated
    contexts). We try to keep track of all this inside the CALL_BRIDGE
    centrally.

 6. We try to maintain the abstraction of two separate calls being bridged
    as far as possible. As a convention, methods processing PDUs/messages
    directly received from a socket start with "Handle". These methods pass
    on the received PDU/message to the "other" H245 or Q931 instance (for the
    bridged call). The "other" methods which process these start with 
    "Process". They decide whether or not the PDU/message must be sent to 
    the other end-point.

 7. NAT has problems with unidirectional redirects. If a unidirectional
    redirect X is setup and we later try to setup a unidirectional redirect
    Y in the reverse direction that shares all the parameters of X, NAT 
    exhibits undefined behaviour. This is solved by the following steps -
        * We only setup unidirectional redirects. Thus, RTCP requires 2 
          separate redirects.
        * Logical channel signaling only exchanges addresses/ports to receive
          media on. We exploit that by using different ports for sending and
          receiving media.

 8. We have tried to restrict the use of virtual functions and use inline
    functions wherever possible. Proliferation of short virtual fns can
    result in performance problems.

 9. Overlapped callbacks pass in H245, Q931 pdus that were read along 
    with the corresponding context. We follow a flexible convention for 
    freeing them - 
        * if the callback or any called method frees them or reuses
          them for sending out the opposite end, it sets them to null.
        * if not set to null on return, the event manager which called the
          callback frees these.

 10. Currently all state transitions are in code (ex. 
        if current state == b1, current state = b2 etc.). Its usually
    better to do this in data (ex. an array {current state, new state}).
    However, I haven't been able to figure out an appropriate model for 
    this so far.

 11. Commenting doesn't have the NT standard blocks explaining each fn,
    parameters, return code etc. I have instead, written a small block of
    comments at the top of the function when appropriate. I have also tried
    to comment logical blocks of code.
---------------------------------------------------*/

#include "sockinfo.h"
#include "q931info.h"
#include "logchan.h"
#include "h245info.h"
#include "ipnatapi.h"

enum	CALL_DIRECTION
{
	CALL_DIRECTION_INBOUND,			// the originator of the call is on the private LAN
	CALL_DIRECTION_OUTBOUND,		// the originator of the call is on the "real" internet (outside)
};

// Call state description - one side of a call
class H323_STATE 
{
public:

    inline H323_STATE();

    // initialize when a tcp connection is established on a listening
    // interface 
    inline void Init(
        IN CALL_BRIDGE  &CallBridge,
        IN Q931_INFO    &Q931Info,
        IN H245_INFO    &H245Info,
        IN BOOL          fIsInternal,
        IN BOOL          fIsSource   // source call state iff TRUE
        );

    inline CALL_BRIDGE &GetCallBridge();

    inline BOOL IsSourceCall();

    inline BOOL IsInternal();

    inline Q931_INFO &GetQ931Info();

    inline H245_INFO &GetH245Info();

    inline H323_STATE &GetOtherH323State();

protected:

    // it belongs to this call bridge
    CALL_BRIDGE *m_pCallBridge;

    // TRUE iff its the source call state
    BOOL        m_fIsSourceCall;

    // TRUE iff its a firewall interface address inside the firewall
    BOOL        m_fIsInternal;

    // contains the Q931 tcp info, timeout, remote end info
    Q931_INFO   *m_pQ931Info;

    // contains the H.245 tcp info, timeout, remote end info
    H245_INFO   *m_pH245Info;
};


inline 
H323_STATE::H323_STATE()
    : m_pCallBridge(NULL),
      m_fIsSourceCall(FALSE),
      m_fIsInternal(FALSE),
      m_pQ931Info(NULL),
      m_pH245Info(NULL)
{
}

inline void 
H323_STATE::Init(
    IN CALL_BRIDGE  &CallBridge,
    IN Q931_INFO    &Q931Info,
    IN H245_INFO    &H245Info,
    IN BOOL          fIsInternal,
    IN BOOL          fIsSource   // source call state iff TRUE
    )
{
    _ASSERTE(NULL == m_pCallBridge);
    _ASSERTE(NULL == m_pQ931Info);
    _ASSERTE(NULL == m_pH245Info);

    m_pCallBridge   = &CallBridge;
    m_pQ931Info     = &Q931Info;
    m_pH245Info     = &H245Info;
    m_fIsInternal   = fIsInternal;
    m_fIsSourceCall = fIsSource;
}


inline CALL_BRIDGE &
H323_STATE::GetCallBridge()
{
    _ASSERTE(NULL != m_pCallBridge);
    return *m_pCallBridge;
}

inline BOOL 
H323_STATE::IsSourceCall()
{
    return m_fIsSourceCall;
}

inline BOOL 
H323_STATE::IsInternal()
{
    return m_fIsInternal;
}

inline Q931_INFO &
H323_STATE::GetQ931Info()
{
    _ASSERTE(NULL != m_pQ931Info);
    return *m_pQ931Info;
}

inline H245_INFO &
H323_STATE::GetH245Info()
{
    _ASSERTE(NULL != m_pH245Info);
    return *m_pH245Info;
}


// Source call state description - one side of a call
class SOURCE_H323_STATE :
    public H323_STATE
{
public:

    inline SOURCE_H323_STATE();

    // initialize when a tcp connection is established on a listening
    // interface 
    inline void Init(
        IN CALL_BRIDGE  &CallBridge,
        IN BOOL          fIsInternal
        );

    inline SOURCE_Q931_INFO &GetSourceQ931Info();

    inline SOURCE_H245_INFO &GetSourceH245Info();

    inline DEST_H323_STATE &GetDestH323State();

protected:

    // contains the source Q931 tcp info, timeout, remote end info
    SOURCE_Q931_INFO    m_SourceQ931Info;

    // contains the H.245 tcp info, timeout, remote end info
    SOURCE_H245_INFO    m_SourceH245Info;

private:

    // base class Init, cannot be called
    inline void Init(
        IN CALL_BRIDGE  &CallBridge,
        IN Q931_INFO    &Q931Info,
        IN H245_INFO    &H245Info,
        IN BOOL          fIsInternal,
        IN BOOL          fIsSource   // source call state iff TRUE
        )
    {
        _ASSERTE(FALSE);
    }

};


inline 
SOURCE_H323_STATE::SOURCE_H323_STATE(
    )
{
}

// initialize when a tcp connection is established on a listening
// interface 
inline void 
SOURCE_H323_STATE::Init(
    IN CALL_BRIDGE  &CallBridge,
    IN BOOL          fIsInternal
    )
{
    m_SourceQ931Info.Init(*this);
    m_SourceH245Info.Init(*this);
    H323_STATE::Init(
        CallBridge, 
        m_SourceQ931Info, 
        m_SourceH245Info, 
        fIsInternal, 
        TRUE
        );
}

inline SOURCE_Q931_INFO &
SOURCE_H323_STATE::GetSourceQ931Info(
    )
{
    return m_SourceQ931Info;
}


inline SOURCE_H245_INFO &
SOURCE_H323_STATE::GetSourceH245Info()
{
    return m_SourceH245Info;
}

// Destination call state description - one side of a call
class DEST_H323_STATE :
    public H323_STATE
{
public:

    inline DEST_H323_STATE();

    // initialize when a tcp connection is established on a listening
    // interface 
    inline HRESULT Init(
        IN CALL_BRIDGE  &CallBridge,
        IN BOOL          fIsInternal
        );

    inline DEST_Q931_INFO &GetDestQ931Info();

    inline DEST_H245_INFO &GetDestH245Info();

    inline SOURCE_H323_STATE &GetSourceH323State();

protected:

    // contains the destination Q931 tcp info, timeout, remote end info
    DEST_Q931_INFO  m_DestQ931Info;

    // contains the H.245 tcp info, timeout, remote end info
    DEST_H245_INFO  m_DestH245Info;

private:

    // base class Init, cannot be called
    inline void Init(
        IN CALL_BRIDGE  &CallBridge,
        IN Q931_INFO    &Q931Info,
        IN H245_INFO    &H245Info,
        IN BOOL          fIsInternal,
        IN BOOL          fIsSource   // source call state iff TRUE
        )
    {
        _ASSERTE(FALSE);
    }

};

inline 
DEST_H323_STATE::DEST_H323_STATE()
{
}

// initialize when a tcp connection is established on a listening
// interface 
inline HRESULT 
DEST_H323_STATE::Init(
    IN CALL_BRIDGE  &CallBridge,
    IN BOOL          fIsInternal
    )
{
    HRESULT HResult = m_DestQ931Info.Init(*this);
    if (FAILED(HResult))
    {
        return HResult;
    }
    _ASSERTE(S_FALSE != HResult);

    m_DestH245Info.Init(*this);
    H323_STATE::Init(
        CallBridge, 
        m_DestQ931Info,
        m_DestH245Info,
        fIsInternal, 
        FALSE
        );

    return S_OK;
}


inline DEST_Q931_INFO &
DEST_H323_STATE::GetDestQ931Info(
    )
{
    return m_DestQ931Info;
}


inline DEST_H245_INFO &
DEST_H323_STATE::GetDestH245Info(
    )
{
    return m_DestH245Info;
}


// The CALL_BRIDGE represents an active call that is being proxied.
// Number of outstanding i/os is stored only in the call bridge instance
// it is only needed to determine when the call bridge instance can safely
// be shut down
class	CALL_BRIDGE :
public	SIMPLE_CRITICAL_SECTION_BASE,
public  LIFETIME_CONTROLLER
{
public:

	enum	STATE {
		STATE_NONE,
		STATE_CONNECTED,
		STATE_TERMINATED,
	};
	
protected:	

	STATE				State;

	CALL_DIRECTION		CallDirection;

    // call state info for the source side. i.e. the side which 
    // sends the Setup packet
    SOURCE_H323_STATE   m_SourceH323State;

    // call sate info for the destination side. i.e. the recepient
    // of the setup packet
    DEST_H323_STATE     m_DestH323State;

private:

    HRESULT InitializeLocked (
        IN	SOCKET			IncomingSocket,
		IN	SOCKADDR_IN *	LocalAddress,
		IN	SOCKADDR_IN *	RemoteAddress,
		IN	CALL_DIRECTION	ArgCallDirection,
		IN	SOCKADDR_IN *	ArgActualDestinationAddress);


public:

    CALL_BRIDGE		(void);
    ~CALL_BRIDGE	(void);

    // initialize member call state instances
    HRESULT Initialize (
        IN	SOCKET			IncomingSocket,
		IN	SOCKADDR_IN *	LocalAddress,
		IN	SOCKADDR_IN *	RemoteAddress,
		IN	CALL_DIRECTION	ArgCallDirection,
		IN	SOCKADDR_IN *	ArgActualDestinationAddress);


	// this function may be called by any thread that holds a safe,
	// counted reference to this object.
	void	TerminateExternal	(void);

// private:

	friend	class	Q931_INFO;
	friend	class	H245_INFO;
	friend	class	SOURCE_H245_INFO;
	friend	class	DEST_H245_INFO;
	friend	class	LOGICAL_CHANNEL;

    inline BOOL IsTerminated();
    inline BOOL IsTerminatedExternal();
    inline void CancelAllTimers();

#if !defined(_MY_DEBUG_MEMORY)
    // overload new and delete to use a private heap
    inline void * operator new(size_t size);
    inline void operator delete(void *p);
#endif // _MY_DEBUG_MEMORY

    // tells the call bridge to terminate later
    // this should only be called after sending a RELEASE
    // COMPLETE PDU
    void TerminateCallOnReleaseComplete();
    void Terminate ();
    
    inline SOURCE_H323_STATE &GetSourceH323State();

    inline DEST_H323_STATE &GetDestH323State();

    inline BOOL IsOutgoingCall();

};



#if !defined(_MY_DEBUG_MEMORY)
// We overload the new and delete operators to allocate from 
// a private heap
inline void *
CALL_BRIDGE::operator new(
   IN size_t size
   )
{
    _ASSERTE(g_hCallBridgeHeap != NULL);

    return (HeapAlloc(g_hCallBridgeHeap,
              0, // no flags
              size));
}


inline void
CALL_BRIDGE::operator delete(
   IN void *p
   )
{
    _ASSERTE(g_hCallBridgeHeap != NULL);
    if (!HeapFree(g_hCallBridgeHeap,
         0, // no flags
         p))
    {
        DBGOUT((LOG_FAIL, "Failed to delete CALL_BRIDGE * %p", p));
    }
}
#endif // _MY_DEBUG_MEMORY


inline void
CALL_BRIDGE::CancelAllTimers()
{
    m_SourceH323State.GetQ931Info().TimprocCancelTimer();
    m_DestH323State.GetQ931Info().TimprocCancelTimer();
    GetSourceH323State().GetH245Info().GetLogicalChannelArray().CancelAllTimers();
    GetDestH323State().GetH245Info().GetLogicalChannelArray().CancelAllTimers();
}



//
//
//
inline BOOL
CALL_BRIDGE::IsTerminated()
{
    return State == STATE_TERMINATED;
}

inline BOOL
CALL_BRIDGE::IsTerminatedExternal()
{
	BOOL IsCallBridgeTerminated = TRUE;

	Lock ();

	IsCallBridgeTerminated = IsTerminated ();

	Unlock ();

	return IsCallBridgeTerminated;
}


inline SOURCE_H323_STATE &
CALL_BRIDGE::GetSourceH323State()
{
    return m_SourceH323State;
}

inline DEST_H323_STATE &
CALL_BRIDGE::GetDestH323State()
{
    return m_DestH323State;
}

inline BOOL
CALL_BRIDGE::IsOutgoingCall()
{
	return CallDirection == CALL_DIRECTION_OUTBOUND;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Misc. inline functions that require declarations                          //
// which are made after them                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


// CODEWORK: I know this whole thing looks really messy.
// Need to think of a way to clean it up so that all the
// classes can be in different files.

// 
// OVERLAPPED_PROCESSOR

inline CALL_BRIDGE & 
OVERLAPPED_PROCESSOR::GetCallBridge()
{
    return m_pH323State->GetCallBridge();
}

// Q931_INFO


inline CALL_REF_TYPE 
Q931_INFO::GetCallRefVal()
{
    return m_CallRefVal;
}


// SOURCE_Q931_INFO

inline HRESULT 
SOURCE_Q931_INFO::SetIncomingSocket(
	IN	SOCKET	IncomingSocket,
	IN	SOCKADDR_IN *	LocalAddress,
	IN	SOCKADDR_IN *	RemoteAddress)
{
	assert (IncomingSocket != INVALID_SOCKET);
    assert (m_pH323State->IsSourceCall());
    assert (Q931_SOURCE_STATE_INIT == m_Q931SourceState);

    m_SocketInfo.Init(
        IncomingSocket,
		LocalAddress,
		RemoteAddress);

    m_Q931SourceState  = Q931_SOURCE_STATE_CON_ESTD;

    return QueueReceive();
}


inline DEST_Q931_INFO &
SOURCE_Q931_INFO::GetDestQ931Info()
{
    return ((SOURCE_H323_STATE *)m_pH323State)->GetDestH323State().GetDestQ931Info();
}


inline SOURCE_H245_INFO &
SOURCE_Q931_INFO::GetSourceH245Info()
{
    return ((SOURCE_H323_STATE *)m_pH323State)->GetSourceH245Info();
}


// DEST_Q931_INFO

inline SOURCE_Q931_INFO &
DEST_Q931_INFO::GetSourceQ931Info()
{
    return 
  ((DEST_H323_STATE *)m_pH323State)->GetSourceH323State().GetSourceQ931Info();
}

inline DEST_H245_INFO &
DEST_Q931_INFO::GetDestH245Info()
{
    return ((DEST_H323_STATE *)m_pH323State)->GetDestH245Info();
}

inline void 
DEST_Q931_INFO::StoreActualDestination(
	IN	SOCKADDR_IN *	ArgActualDestination)
{
	assert (ArgActualDestination);

	m_ActualDestinationAddress = *ArgActualDestination;
};

inline void 
DEST_Q931_INFO::GetActualDestination (
	OUT	SOCKADDR_IN *	ReturnActualDestination)
{

	assert (ReturnActualDestination);

	*ReturnActualDestination = m_ActualDestinationAddress;
};

// LOGICAL_CHANNEL

inline CALL_BRIDGE & 
LOGICAL_CHANNEL::GetCallBridge()
{
    return GetH245Info().GetCallBridge();
}

inline void 
LOGICAL_CHANNEL::DeleteAndRemoveSelf()
{
    // remove self from the logical channel array
    m_pH245Info->GetLogicalChannelArray().Remove(*this);

	TimprocCancelTimer ();

    // destroy self
    delete this;
}

// H245_INFO


inline H245_INFO &
H245_INFO::GetOtherH245Info()
{
    return GetH323State().GetOtherH323State().GetH245Info();
}


// SOURCE_H245_INFO

inline SOURCE_Q931_INFO &
SOURCE_H245_INFO::GetSourceQ931Info()
{
    return ((SOURCE_H323_STATE *)m_pH323State)->GetSourceQ931Info();
}

// SOURCE_Q931_INFO

inline DEST_H245_INFO &
SOURCE_H245_INFO::GetDestH245Info()
{
    return ((SOURCE_H323_STATE *)m_pH323State)->GetDestH323State().GetDestH245Info();
}

// DEST_H245_INFO

inline DEST_Q931_INFO &
DEST_H245_INFO::GetDestQ931Info()
{
    return ((DEST_H323_STATE *)m_pH323State)->GetDestQ931Info();
}


// H323_STATE

inline H323_STATE &
H323_STATE::GetOtherH323State()
{
    return (TRUE == m_fIsSourceCall)? 
        (H323_STATE &)m_pCallBridge->GetDestH323State() : 
        (H323_STATE &)m_pCallBridge->GetSourceH323State();
}


// SOURCE_H323_STATE

inline DEST_H323_STATE &
SOURCE_H323_STATE::GetDestH323State()
{
    return GetCallBridge().GetDestH323State();
}


// DEST_H323_STATE

inline SOURCE_H323_STATE &
DEST_H323_STATE::GetSourceH323State()
{
    return GetCallBridge().GetSourceH323State();
}



#endif // __PXSVC_CALL_BRIDGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\emrecv.cpp ===
/*
 * Copyright (c) 1998, Microsoft Corporation
 * File: emrecv.cpp
 *
 * Purpose: 
 * 
 * Contains all the event manager routines which
 * manage the overlapped recv operations
 * 
 *
 * History:
 *
 *   1. created 
 *       Ajay Chitturi (ajaych)  12-Jun-1998
 *
 */

#include "stdafx.h"
#include "cbridge.h"
#include "ovioctx.h"


//XXX This should be an inline function
static PSendRecvContext
EventMgrCreateRecvContext(
       IN SOCKET                    sock,
       IN OVERLAPPED_PROCESSOR &    rOvProcessor
       )
    
{
    PSendRecvContext pRecvContext;

    // IO Context part - make this a separate inline function
    pRecvContext = (PSendRecvContext) HeapAlloc(g_hSendRecvCtxtHeap,
						0, // No Flags
						sizeof(SendRecvContext));
    if (!pRecvContext)
        return NULL;

    memset(pRecvContext, 0, sizeof(SendRecvContext));

    pRecvContext->ioCtxt.reqType = EMGR_OV_IO_REQ_RECV;
    pRecvContext->ioCtxt.pOvProcessor = &rOvProcessor;

    // Recv Context part
    pRecvContext->sock = sock;
    pRecvContext->dwTpktHdrBytesDone = 0;
    pRecvContext->dwDataLen = 0;
    pRecvContext->pbData = NULL;
    pRecvContext->dwDataBytesDone = 0;

	DBGOUT ((LOG_VERBOSE, "EventMgrCreateRecvContext -- Created Recv context %x", pRecvContext));

    return pRecvContext;
}

// If you do not want to free the event manager context
// set it to NULL before calling this function.
void EventMgrFreeRecvContext(
     PSendRecvContext pRecvCtxt
     )
{
    // Socket and OvProcessor are owned by the 
    // Call Bridge Machine

    if (pRecvCtxt->pbData != NULL)
    {        EM_FREE(pRecvCtxt->pbData);
    }
    
    HeapFree(g_hSendRecvCtxtHeap,
             0, // no flags
             pRecvCtxt);

	DBGOUT ((LOG_VERBOSE, "EventMgrFreeRecvContext -- Freed Recv context %x", pRecvCtxt));

}

/*
 * Call ReadFile to start an overlapped request
 * on a socket.  Make sure we handle errors
 * that are recoverable.
 * 
 * pRecvCtxt is not freed in case of an error
 */

static
HRESULT EventMgrIssueRecvHelperFn(
        PSendRecvContext pRecvCtxt
        )
{
    int     i = 0;
    BOOL    bResult;
    int     err;
    DWORD   dwNumRead, dwToRead;
    PBYTE   pbReadBuf;
    
    _ASSERTE(pRecvCtxt);

	if (pRecvCtxt ->ioCtxt.pOvProcessor->IsSocketValid())
	{
        if (pRecvCtxt->dwTpktHdrBytesDone < TPKT_HEADER_SIZE) 
        {
            dwToRead = TPKT_HEADER_SIZE - pRecvCtxt->dwTpktHdrBytesDone;
            pbReadBuf = pRecvCtxt->pbTpktHdr + pRecvCtxt->dwTpktHdrBytesDone;
        }
        else 
        {
            dwToRead = pRecvCtxt->dwDataLen - pRecvCtxt->dwDataBytesDone;
            pbReadBuf = pRecvCtxt->pbData + pRecvCtxt->dwDataBytesDone;
        }

        DBGOUT ((LOG_VERBOSE, "EventMgrIssueRecvHelperFn -- numBytes -- %d, pRecvCtxt -- %x  Sock -- %x", 
                dwToRead, pRecvCtxt, pRecvCtxt -> sock));

        // Kick off the first read
        while (++i)
        {
            memset(&pRecvCtxt->ioCtxt.ov, 0, sizeof(OVERLAPPED));
            // make an overlapped IO Request
            // XXX The socket may not be valid at this point
            
            pRecvCtxt->ioCtxt.pOvProcessor->GetCallBridge().AddRef();

            bResult = ReadFile((HANDLE)pRecvCtxt->sock, 
                               pbReadBuf,
                               dwToRead,
                               &dwNumRead,
                               &pRecvCtxt->ioCtxt.ov
                               );

            // It succeeded immediately, but do not process it
            // here, wait for the completion packet.
            if (bResult)
                return S_OK;

            err = GetLastError();

            // This is what we want to happen, its not an error
            if (err == ERROR_IO_PENDING)
                return S_OK;

            pRecvCtxt->ioCtxt.pOvProcessor->GetCallBridge().Release ();

            // Handle recoverable error
            if ( err == ERROR_INVALID_USER_BUFFER ||
                 err == ERROR_NOT_ENOUGH_QUOTA ||
                 err == ERROR_NOT_ENOUGH_MEMORY )
            {
                if (i <= 5) // I just picked a number
                {
                    Sleep(50);  // Wait around and try later
                    continue;
                }
                DBGOUT((LOG_FAIL, 
                        "Fatal Error: EventMgrIssueRecv - "
                        "System ran out of non-paged space"));
            }

            // This means this is an unrecoverable error
            // one possibility is that that Call bridge could have closed
            // the socket some time in between

            break;
        }//while(++i)

        DBGOUT((LOG_FAIL, "EventMgrIssueRecvHelperFn - ReadFile failed err: %d", err));

        return E_FAIL;

	} else {
		       
		DBGOUT((LOG_FAIL, "EventMgrIssueRecvHelperFn - Overlapped processor %x had invalid socket.", pRecvCtxt ->ioCtxt.pOvProcessor));

		return E_ABORT;
	}

	return S_OK;
} //EventMgrIssueRecv()


/* 
 * The Call Bridge Machine calls this function to issue asynchronous
 * receive requests 
 *
 */
HRESULT EventMgrIssueRecv(
        IN SOCKET                   sock,
        IN OVERLAPPED_PROCESSOR &   rOvProcessor
        )
{
    PSendRecvContext pRecvCtxt = 
        EventMgrCreateRecvContext(sock, rOvProcessor);
    
    if (!pRecvCtxt)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hRes = EventMgrIssueRecvHelperFn(pRecvCtxt);

    if (FAILED(hRes))
    {
        EventMgrFreeRecvContext(pRecvCtxt);
    }
    
    return hRes;
}

/*
 * Make the error callback.
 *
 * Since this is called only in case of an error this need not be an
 * inline function
 *
 */
void MakeErrorRecvCallback(
     HRESULT            hRes,
     PSendRecvContext   pRecvCtxt
     )
{
    DBGOUT((LOG_FAIL, 
            "Error on Q.931 recv callback status: 0x%x \n", 
            hRes));

    pRecvCtxt->ioCtxt.pOvProcessor->ReceiveCallback(hRes, NULL, NULL);
}




// This function passes the decoded PDUs to the Call bridge Machine.
// This function frees the PDUs after the callback function returns.
// The PDUs are allocated by the ASN1 library and the corresponding
// functions need to be used to free the PDUs.

/* 
 * This function is called by the event loop when a recv I/O completes.
 * The Call Bridge Machine's recv call back function is called. 
 *
 * This function does not return any error code. In case of an error,
 * the call bridge machine is notified about the error in the callback.
 *
 * This function always frees pRecvCtxt if another Recv is not issued
 */
void HandleRecvCompletion(
     PSendRecvContext   pRecvCtxt,
     DWORD              dwNumRead,
     DWORD              status
     )
{
    HRESULT hRes;
    
    _ASSERTE(dwNumRead >= 0);

	DBGOUT ((LOG_VERBOSE, "HandleRecvCompletion: pRecvCtxt - %x    Sock - %x dwNumRead - %d    status - %d",
			pRecvCtxt, pRecvCtxt->sock, dwNumRead, status));
    
	if (status != NO_ERROR || dwNumRead == 0)
    {
        // This means an error occured in the read operation
        // We need to call the callback with the error status
        if (status == NO_ERROR && dwNumRead == 0)
		{
			Debug (_T("NATH323: transport connection was closed by peer\n"));

            hRes = E_FAIL; // XXX should E_CONNRESET or some such
		}
        else 
		{
            hRes = HRESULT_FROM_WIN32_ERROR_CODE(status);
		}

        // make callback
        MakeErrorRecvCallback(hRes, pRecvCtxt);
        EventMgrFreeRecvContext(pRecvCtxt);
        return;
    }

    if (pRecvCtxt->dwTpktHdrBytesDone < TPKT_HEADER_SIZE)
	{
        // This means we are still reading the TPKT header
        pRecvCtxt->dwTpktHdrBytesDone += dwNumRead;
	}
    else
	{
        // This means we are reading the data
        pRecvCtxt->dwDataBytesDone += dwNumRead;
	}

    // If the TPKT header has been read completely we need to
    // extract the packet size, set it appropriately
    // and allocate the data buffer
    if (pRecvCtxt->dwDataLen == 0 &&
        pRecvCtxt->dwTpktHdrBytesDone == TPKT_HEADER_SIZE) 
    {
        hRes = S_OK;

        pRecvCtxt->dwDataLen = GetPktLenFromTPKTHdr(pRecvCtxt->pbTpktHdr);

        // The length of the PDU fits in 2 bytes
        _ASSERTE(pRecvCtxt->dwDataLen < (1L << 16));
        pRecvCtxt->pbData = (PBYTE) EM_MALLOC(pRecvCtxt->dwDataLen);
        if (!pRecvCtxt->pbData)
        {
            DBGOUT((LOG_FAIL, "HandleRecvCompletion(): Could not allocate pbData"));

            MakeErrorRecvCallback(E_OUTOFMEMORY, pRecvCtxt);
            EventMgrFreeRecvContext(pRecvCtxt);
            return;
        }
        memset(pRecvCtxt->pbData, 0, pRecvCtxt->dwDataLen);

        hRes = EventMgrIssueRecvHelperFn(pRecvCtxt);

        if (hRes != S_OK)
        {
            MakeErrorRecvCallback(hRes, pRecvCtxt);
            EventMgrFreeRecvContext(pRecvCtxt);
            return;
        }
        else
		{
            // Succeeded in making an overlapped recv request 
            return;
		}
    }
    
    if (pRecvCtxt->dwTpktHdrBytesDone < TPKT_HEADER_SIZE ||
        pRecvCtxt->dwDataBytesDone < pRecvCtxt->dwDataLen)
    {
        hRes = S_OK;
        hRes = EventMgrIssueRecvHelperFn(pRecvCtxt);
        if (hRes != S_OK)
        {
            MakeErrorRecvCallback(hRes, pRecvCtxt);
            EventMgrFreeRecvContext(pRecvCtxt);
            return;
        }
        else
        {
            // Succeeded in making an overlapped recv request 
            return;
        }
    }
    
    // Received a complete PDU
    // need to decode the packet and call the appropriate callback
    // and free pRecvCtxt 

    pRecvCtxt->ioCtxt.pOvProcessor->ReceiveCallback(S_OK,
        pRecvCtxt->pbData,
        pRecvCtxt->dwDataLen);

    // It is the responsibility of the callback function to free the buffer.
    pRecvCtxt->pbData = NULL;
    pRecvCtxt->dwDataLen = 0;
    
    // Clean up Recv context structure
    EventMgrFreeRecvContext(pRecvCtxt);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\emsend.cpp ===
/*
 * Copyright (c) 1998, Microsoft Corporation
 * File: emsend.cpp
 *
 * Purpose: 
 * 
 * Contains all the event manager routines which
 * manage the overlapped send operations
 * 
 *
 * History:
 *
 *   1. created 
 *       Ajay Chitturi (ajaych)  12-Jun-1998
 *
 */

#include "stdafx.h"
#include "cbridge.h"
#include "ovioctx.h"


static HRESULT EventMgrIssueSendHelperFn(PSendRecvContext pSendCtxt);



/*
 * This function allocates and returns an initialized SendRecvContext or
 * NULL in case of no memory
 * XXX This should be an inline function
 */
static PSendRecvContext 
EventMgrCreateSendContext(
       IN SOCKET                   sock,
       IN OVERLAPPED_PROCESSOR &   rOvProcessor,
       IN BYTE                    *pBuf,
       IN DWORD                    BufLen
       )
{
    PSendRecvContext pSendContext;

    pSendContext = (PSendRecvContext) HeapAlloc(g_hSendRecvCtxtHeap,
						0, // No Flags
						sizeof(SendRecvContext));
    if (!pSendContext)
        return NULL;

    memset(pSendContext, 0, sizeof(SendRecvContext));
    // IO Context part - make this a separate inline function
    pSendContext->ioCtxt.reqType = EMGR_OV_IO_REQ_SEND;
    pSendContext->ioCtxt.pOvProcessor = &rOvProcessor;

    // Send Context part
    pSendContext->pbData = pBuf;
    pSendContext->dwDataLen = BufLen;

    pSendContext->sock = sock;
    pSendContext->dwTpktHdrBytesDone = 0;
    pSendContext->dwDataBytesDone = 0;

    return pSendContext;
}

void
EventMgrFreeSendContext(
       IN PSendRecvContext			pSendCtxt
       )
{
    // Socket, OvProcessor are owned by the 
    // Call Bridge Machine

    // BUGBUG: We need to make sure the buffer passed in to IssueSend() is
    // always allocated using EM_MALLOC() similar to the Comet filter.
    // It should also allocate the TPKT header and fill it in before passing
    // the buffer to the IssueSend() function. This function should just
    // call EM_FREE() on the buffer (in send completion).
    // This has been fixed now - add proper doc.

    EM_FREE(pSendCtxt->pbData);
   
    HeapFree(g_hSendRecvCtxtHeap,
             0, // no flags
             pSendCtxt);
}



/*++

Routine Description:
    This function issues an asynch send of the buffer on the socket.
    Calling this passes the ownership of the buffer and this buffer is
    freed right here in case of an error. If the call succeeds,
    HandleSendCompletion() is responsible for freeing the buffer once
    all the bytes are sent.
    
Arguments:
    
Return Values:
    
--*/


HRESULT EventMgrIssueSend(
        IN SOCKET                   sock,
        IN OVERLAPPED_PROCESSOR &   rOverlappedProcessor,
        IN BYTE                    *pBuf,
        IN DWORD                    BufLen
        )
{
    PSendRecvContext pSendCtxt;
    HRESULT hRes;

    // Create Send overlapped I/O context
    pSendCtxt = EventMgrCreateSendContext(sock, 
                                          rOverlappedProcessor,
                                          pBuf, BufLen);
    if (!pSendCtxt)
    {
        return E_OUTOFMEMORY;
    }

    // TPKT is already filled in by the encode functions in pdu.cpp
    // Fill in the TPKT header based on the packet length
    // SetupTPKTHeader(pSendCtxt->pbTpktHdr, pSendCtxt->dwDataLen);

    // Do an asynchronous Write
    hRes = EventMgrIssueSendHelperFn(pSendCtxt);
    if (hRes != S_OK)
    {
        // This calls also frees the buffer.
        EventMgrFreeSendContext(pSendCtxt);
    }
    
    return hRes;
}

/*
 * Call WriteFile to start an overlapped request
 * on a socket.  Make sure we handle errors
 * that are recoverable.
 * 
 * pSendCtxt is not freed. It is freed only in HandleSendCompletion.
 * NO more TPKT stuff.
 */
static
HRESULT EventMgrIssueSendHelperFn(
        IN PSendRecvContext pSendCtxt
        )
{
    DWORD dwWritten, dwToSend;
    int   i = 0;
    BOOL  bResult;
    int   err;
    PBYTE pbSendBuf;  
    
    _ASSERTE(pSendCtxt);

	DBGOUT ((LOG_VERBOSE, "EventMgrIssueSendHelperFn -- context &%x\n", pSendCtxt));

	if (pSendCtxt ->ioCtxt.pOvProcessor->IsSocketValid())
	{
        dwToSend = pSendCtxt->dwDataLen - pSendCtxt->dwDataBytesDone;
        pbSendBuf = pSendCtxt->pbData + pSendCtxt->dwDataBytesDone;

        // Kick off the first read
        while (++i)
        {
            // make an overlapped I/O Request
            memset(&pSendCtxt->ioCtxt.ov, 0, sizeof(OVERLAPPED));

            pSendCtxt->ioCtxt.pOvProcessor->GetCallBridge().AddRef();

            bResult = WriteFile((HANDLE)pSendCtxt->sock,
                                pbSendBuf,
                                dwToSend,
                                &dwWritten,
                                &pSendCtxt->ioCtxt.ov
                                );
            // It succeeded immediately, but do not process it
            // here, wait for the completion packet.
            if (bResult)
                return S_OK;

            err = GetLastError();

            // This is what we want to happen, its not an error
            if (err == ERROR_IO_PENDING)
                return S_OK;

            pSendCtxt->ioCtxt.pOvProcessor->GetCallBridge().Release();

            // Handle recoverable errors
            if ( err == ERROR_INVALID_USER_BUFFER ||
                 err == ERROR_NOT_ENOUGH_QUOTA ||
                 err == ERROR_NOT_ENOUGH_MEMORY )
            {
                if (i <= 5) // I just picked a number
                {
                    Sleep(50);  // Wait around and try later
                    continue;
                }

                DBGOUT((LOG_FAIL, 
                        "Fatal Error: EventMgrIssueSend - "
                        "System ran out of non-paged space\n"));
            }

            // This means this is an unrecoverable error
            // one possibility is that that Call bridge could have closed
            // the socket some time in between
            break;
        }
        DBGOUT((LOG_FAIL, 
                "EventMgrIssueSend - WriteFile(sock: %d) failed err: %d\n", 
                pSendCtxt->sock, err));
        return E_FAIL;
	} else {
			DBGOUT((LOG_FAIL, "EventMgrIssueSendHelperFn - Overlapped processor %x had invalid socket.\n", pSendCtxt ->ioCtxt.pOvProcessor));

		return E_ABORT;
	}

	// Treat as success if overlapped process had its socket disabled
	return S_OK;
}

/* 
 * This function is called by the event loop when a send I/O completes.
 * The Call Bridge Machine's send call back function is called. 
 *
 * This function does not return any error code. In case of an error,
 * the call bridge machine is notified about the error in the callback.
 *
 * This function always frees pSendCtxt if another Send is not issued
 *
 * NO More TPKT stuff.
 */
void HandleSendCompletion(
     IN PSendRecvContext   pSendCtxt,
     IN DWORD              dwNumSent,
     IN DWORD              status
     )
{

    _ASSERTE(dwNumSent >= 0);

    if (status != NO_ERROR || dwNumSent == 0)
    {
        // This means the send request failed
        HRESULT hRes;
        if (status != NO_ERROR)
        {
            hRes = E_FAIL; //the socket was closed
        }
        else 
        {
            hRes = HRESULT_FROM_WIN32_ERROR_CODE(status);
        }
        
        DBGOUT((LOG_TRCE, 
                "Error on send callback status: %d dwNumSent: %d\n", 
                status, dwNumSent));

        pSendCtxt->ioCtxt.pOvProcessor->SendCallback(hRes);
    }
    else 
    {
        pSendCtxt->dwDataBytesDone += dwNumSent;

        // Check if the send completed
        if (pSendCtxt->dwDataBytesDone < pSendCtxt->dwDataLen)
        {
            HRESULT hRes = S_OK;
            hRes = EventMgrIssueSendHelperFn(pSendCtxt);
            if (hRes != S_OK)
            {
                pSendCtxt->ioCtxt.pOvProcessor->SendCallback(hRes);
                EventMgrFreeSendContext(pSendCtxt);
            }
            return;
        }

        // The send completed. Make the callback
        pSendCtxt->ioCtxt.pOvProcessor->SendCallback(S_OK);
    }
    // XXX Check the error status of the callback
        
    // clean up I/O context structure
    EventMgrFreeSendContext(pSendCtxt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\gkwsock.cpp ===
#include "stdafx.h"
#include "gkwsock.h"


// ASYNC_ACCEPT --------------------------------------------------------------------------


ASYNC_ACCEPT::ASYNC_ACCEPT (void)
{
	AcceptSocket = INVALID_SOCKET;
	ClientSocket = INVALID_SOCKET;
	AcceptFunc = NULL;
	AcceptFuncContext = NULL;
	ReferenceCount = 0L;
	StopNotifyEvent = NULL;
}

ASYNC_ACCEPT::~ASYNC_ACCEPT (void)
{
	assert (AcceptSocket == INVALID_SOCKET);
	assert (ClientSocket == INVALID_SOCKET);
	assert (ReferenceCount == 0L);
	assert (!StopNotifyEvent);
}

HRESULT ASYNC_ACCEPT::StartIo (
	IN	SOCKADDR_IN *		SocketAddress,
	IN	ASYNC_ACCEPT_FUNC	ArgAcceptFunc,
	IN	PVOID				ArgAcceptContext)
{
	HRESULT		Result;

	assert (SocketAddress);
	assert (ArgAcceptFunc);

	Lock ();

	if (AcceptSocket == INVALID_SOCKET && ReferenceCount == 0L) {
		// this object is not currently in use
		// so, it's acceptable to use it

		assert (!AcceptFunc);
		assert (!AcceptFuncContext);
		assert (!StopNotifyEvent);

		// This increase in reference count is needed
		// to shut down the service gracefully
		// Reference count on ASYNC_ACCEPT objects
		// will never drop to zero unless StopWait is called.
		// StopWait will call matching Release, which will
		// bring the reference count to the expected value of 0. 
		AddRef ();

		Result = StartIoLocked (SocketAddress);

		if (Result == S_OK) {

			assert (AcceptSocket != INVALID_SOCKET);

			AcceptFunc = ArgAcceptFunc;
			AcceptFuncContext = ArgAcceptContext;
		}
		else {

			Release ();
		}
	}
	else {
		Debug (_T("ASYNC_ACCEPT::StartIo: this object is already in use, must first call Stop and wait for sync counter\n"));
		Result = E_FAIL;
	}

	Unlock();

	return Result;
}


HRESULT ASYNC_ACCEPT::StartIoLocked (
	IN	SOCKADDR_IN *		SocketAddress)
{
	HRESULT		Result;

	assert (SocketAddress);
	assert (AcceptSocket == INVALID_SOCKET);
	assert (ClientSocket == INVALID_SOCKET);
	assert (ReferenceCount == 1);
	assert (!StopNotifyEvent);
  
	StopNotifyEvent = CreateEvent (NULL, TRUE, FALSE, NULL);

	if (!StopNotifyEvent) {

		Result = GetLastErrorAsResult ();
		DebugLastError (_T("ASYNC_ACCEPT::StartIoLocked: failed to create stop notify event\n"));

	} else {

		AcceptSocket = WSASocket (AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);

		if (AcceptSocket == INVALID_SOCKET) {

			Result = GetLastErrorAsResult ();
			DebugLastError (_T("ASYNC_ACCEPT::StartIoLocked: failed to create accept socket\n"));

		} else { 

			if (bind (AcceptSocket, (SOCKADDR *) SocketAddress, sizeof (SOCKADDR_IN))) {

				Result = GetLastErrorAsResult ();
				DebugLastErrorF (_T("ASYNC_ACCEPT::StartIoLocked: failed to bind accept socket to address %08X:%04X\n"),
						ntohl (SocketAddress -> sin_addr.s_addr),
						ntohs (SocketAddress -> sin_port));

			} else {

				if (listen (AcceptSocket, 10)) {

					Result = GetLastErrorAsResult ();
					DebugLastError (_T("ASYNC_ACCEPT::StartIoLocked: failed to listen on accept socket\n"));

				} else {
				
					if (!BindIoCompletionCallback ((HANDLE) AcceptSocket, ASYNC_ACCEPT::IoCompletionCallback, 0)) {
					
						Result = GetLastErrorAsResult ();
						DebugLastError (_T("ASYNC_ACCEPT::StartIoLocked: failed to bind i/o completion callback\n"));
					
					} else {
 					
						Result = IssueAccept ();
					
						if (Result == S_OK) {
					
							return Result;
					
						}
					}
				}
			}

			closesocket (AcceptSocket);
			AcceptSocket = INVALID_SOCKET;
		}

		CloseHandle (StopNotifyEvent);
		StopNotifyEvent = NULL;
	}

	return Result;
}


HRESULT ASYNC_ACCEPT::GetListenSocketAddress (
	OUT	SOCKADDR_IN *	ReturnSocketAddress)
{
	HRESULT		Result;
	INT			SocketAddressLength;

	Lock();

	if (AcceptSocket != INVALID_SOCKET) {

		SocketAddressLength = sizeof (SOCKADDR_IN);
		if (getsockname (AcceptSocket, (SOCKADDR *) ReturnSocketAddress, &SocketAddressLength) == SOCKET_ERROR) {
			Result = GetLastErrorAsResult();
		}
		else {
			Result = S_OK;
		}
	}
	else {
		Result = E_INVALIDARG;
	}

	Unlock();

	return Result;
}

HRESULT ASYNC_ACCEPT::IssueAccept (void)
{
	HRESULT Result;

	AssertLocked();
	assert (ClientSocket == INVALID_SOCKET);
//	assert (ReferenceCount == 0);

	ClientSocket = WSASocket (AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);
	if (ClientSocket == INVALID_SOCKET) {
		Result = GetLastErrorAsResult ();
		DebugLastError (_T("ASYNC_ACCEPT::IssueAccept: failed to create client socket.\n"));
		return Result;
	}

	ZeroMemory (&Overlapped, sizeof (OVERLAPPED));

	AddRef();

	if (!AcceptEx (AcceptSocket,
		ClientSocket,
		ClientInfoBuffer,
		0,
		sizeof (SOCKADDR_IN) + 0x10,
		sizeof (SOCKADDR_IN) + 0x10,
		&ClientInfoBufferLength,
		&Overlapped)) {

		if (WSAGetLastError() != WSA_IO_PENDING) {
			// an error occurred
			Release ();
			Result = GetLastErrorAsResult ();
			DebugLastError (_T("ASYNC_ACCEPT::IssueAccept: failed to issue accept.\n"));
			return Result;
		}
	}

	return S_OK;
}

// static
void ASYNC_ACCEPT::IoCompletionCallback (DWORD Status, DWORD BytesTransferred, LPOVERLAPPED Overlapped)
{
	ASYNC_ACCEPT *	AsyncAccept;

	AsyncAccept = CONTAINING_RECORD (Overlapped, ASYNC_ACCEPT, Overlapped);

	AsyncAccept -> IoComplete (Status, BytesTransferred);

	AsyncAccept -> Release ();
}

void ASYNC_ACCEPT::IoComplete (DWORD Status, DWORD BytesTransferred)
{
	ASYNC_ACCEPT_FUNC	LocalAcceptFunc;
	PVOID				LocalAcceptFuncContext;
	SOCKADDR_IN			LocalAddressCopy;
	SOCKADDR_IN			RemoteAddressCopy;
	SOCKET				LocalClientSocket;
	SOCKADDR *			LocalAddress;
	INT					LocalAddressLength;
	SOCKADDR *			RemoteAddress;
	INT					RemoteAddressLength;
	INT					Result;

	Lock();

	assert (ClientSocket != INVALID_SOCKET);
	assert (ReferenceCount > 0);

	if (AcceptSocket == INVALID_SOCKET) {
		// Stop has been called
		// just immediately disconnect the client
		// we'll deal with object lifetime below

		closesocket (ClientSocket);
		ClientSocket = INVALID_SOCKET;
	}
	else {
		// the context is in the normal state
		// continue processing

		if (Status == ERROR_SUCCESS) {
			// a client has successfully connected

			GetAcceptExSockaddrs (
				ClientInfoBuffer,
				0,									// no initial recv
				sizeof (SOCKADDR_IN) + 0x10,
				sizeof (SOCKADDR_IN) + 0x10,
				&LocalAddress,
				&LocalAddressLength,
				&RemoteAddress,
				&RemoteAddressLength);

			// copy information out of the context
			// so that it will be valid after we issue a new accept and unlock
			LocalAddressCopy = *(SOCKADDR_IN *) LocalAddress;
			RemoteAddressCopy = *(SOCKADDR_IN *) RemoteAddress;
			LocalClientSocket = ClientSocket;
			LocalAcceptFunc = AcceptFunc;
			LocalAcceptFuncContext = AcceptFuncContext;

			ClientSocket = INVALID_SOCKET;

			// update the accept context
			Result = setsockopt (ClientSocket, SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT,
				reinterpret_cast <char *> (&AcceptSocket), sizeof (SOCKET));

			// issue a new accept
			IssueAccept();

			Unlock();

			(*LocalAcceptFunc) (LocalAcceptFuncContext, LocalClientSocket, &LocalAddressCopy, &RemoteAddressCopy);

			Lock();
		}
		else {
			// some error has occurred
			// this is usually (but not always) fatal

			assert (ClientSocket != INVALID_SOCKET);

			closesocket (ClientSocket);
			ClientSocket = INVALID_SOCKET;

			switch (Status) {
			case	STATUS_CANCELLED:
				Debug (_T("ASYNC_ACCEPT::IoComplete: accept failed, STATUS_CANCELED, original thread probably exited, resubmitting request...\n"));
				break;

			default:
				DebugError (Status, _T("AsyncAccept: async accept FAILED, sleeping 2000ms and retrying...\n"));
				Sleep (2000);
				break;
			}

			IssueAccept();
		}
	}

	Unlock();
}

void ASYNC_ACCEPT::StopWait (void)
{
	DWORD Status;

	Lock();

	if (AcceptSocket != INVALID_SOCKET) {

		// closing the socket cancels all pending i/o
		// we do NOT close the ClientSocket
		// only the i/o completion callback path may do that
		closesocket (AcceptSocket);
		AcceptSocket = INVALID_SOCKET;
		AcceptFunc = NULL;
		AcceptFuncContext = NULL;

		if (ClientSocket != INVALID_SOCKET) {
			// an accept is still pending. it may complete successfully,
			// or it may complete with STATUS_CANCELED (since we just closed AcceptSocket)
			// in either case, we must wait for the i/o complete callback to run.
			// AcceptSocket = INVALID_SOCKET is an indicator to the completion callback
			// that it should abort / return immediately. 

			assert (StopNotifyEvent);

			Unlock ();

			// This is the counterpart to the AddRef called in 
			// StartIoLocked (see comment there)
			Release ();

			DebugF (_T("ASYNC_ACCEPT::StopWait: waiting for i/o completion thread...\n"));
			
			Status = WaitForSingleObject (StopNotifyEvent, INFINITE);

			assert (Status == WAIT_OBJECT_0);

			Lock ();
		}
	}
	else {
		assert (!AcceptFunc);
		assert (!AcceptFuncContext);
	}

	assert (StopNotifyEvent);
	CloseHandle (StopNotifyEvent);
	StopNotifyEvent = NULL;

	Unlock();
}


void ASYNC_ACCEPT::AddRef (void) {
	assert (ReferenceCount >= 0L);
	InterlockedIncrement (&ReferenceCount);
}


void ASYNC_ACCEPT::Release (void) {
	LONG Count;

	assert (ReferenceCount >= 0L);

	Count = InterlockedDecrement (&ReferenceCount);

	if (Count == 0L) {
		DebugF (_T("ASYNC_ACCEPT::Release -- Reference count dropped to zero. (this is %x)\n"), this);
		
		assert (StopNotifyEvent);
		SetEvent (StopNotifyEvent);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\gkwsock.h ===
#ifndef	__iptel_gkutil_gkwsock_h
#define	__iptel_gkutil_gkwsock_h

#define	ASYNC_ACCEPT_BUFFER_SIZE		0x100

struct	ASYNC_ACCEPT;

typedef void (*ASYNC_ACCEPT_FUNC)
	(PVOID				Context,
	SOCKET				ClientSocket,
	SOCKADDR_IN *		LocalAddress,
	SOCKADDR_IN *		RemoteAddress);

// if ClientSocket != INVALID_SOCKET, then there is an accept pending
// otherwise, no accept is pending.
struct	ASYNC_ACCEPT :
public	SIMPLE_CRITICAL_SECTION_BASE
{
private:
	LONG					ReferenceCount;
	SOCKET					AcceptSocket;
	SOCKET					ClientSocket;
	BYTE					ClientInfoBuffer	[ASYNC_ACCEPT_BUFFER_SIZE];
	DWORD					ClientInfoBufferLength;
	OVERLAPPED				Overlapped;
	ASYNC_ACCEPT_FUNC		AcceptFunc;
	PVOID					AcceptFuncContext;
	HANDLE					StopNotifyEvent;

private:

	HRESULT	StartIoLocked (
		IN	SOCKADDR_IN *		SocketAddress);

	void	IoComplete		(DWORD, DWORD);

	HRESULT	IssueAccept		(void);

	static	void	IoCompletionCallback	(DWORD, DWORD, LPOVERLAPPED);

public:
	ASYNC_ACCEPT	(void);

	~ASYNC_ACCEPT	(void);

	HRESULT	StartIo	(
		IN	SOCKADDR_IN *		SocketAddress,
		IN	ASYNC_ACCEPT_FUNC	AcceptFunc,
		IN	PVOID				Context);

	HRESULT	GetListenSocketAddress (
		OUT	SOCKADDR_IN *		ReturnSocketAddress);

	void StopWait (void);

	void AddRef (void);
	void Release (void);
};

#endif // __iptel_gkutil_gkwsock_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\h245info.h ===
#ifndef _cbridge_h245_h_
#define _cbridge_h245_h_

// H245 states
// H245_STATE_CON_LISTEN is only applicable to the source side
// H245_STATE_CON_INFO is only applicable to the dest side
enum H245_STATE
{
    H245_STATE_NOT_INIT = 0,
    H245_STATE_INIT,
	H245_STATE_CON_LISTEN,
	H245_STATE_CON_INFO,
	H245_STATE_CON_ESTD
};

class H245_INFO :
    public OVERLAPPED_PROCESSOR
{
	// we need to let the LOGICAL_CHANNEL send PDUs using the
	// H245 sockets and transition to shutdown mode
	friend HRESULT 
		LOGICAL_CHANNEL::ProcessOpenLogicalChannelRejectPDU(
		IN      MultimediaSystemControlMessage   *pH245pdu
		);

    // XXX Is this the only way out ?
    friend HRESULT
    T120_LOGICAL_CHANNEL::HandleOpenLogicalChannelPDU(
        IN H245_INFO                            &H245Info,
        IN MEDIA_TYPE                           MediaType,
        IN WORD                                 LogicalChannelNumber,
        IN BYTE                                 SessionId,
        IN DWORD                                T120ConnectToIPAddr,
        IN WORD                                 T120ConnectToPort,
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    friend HRESULT
    T120_LOGICAL_CHANNEL::ProcessOpenLogicalChannelAckPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

public:

	inline H245_INFO();

    inline void Init(
        IN H323_STATE   &H323State
        );

    inline H245_INFO &GetOtherH245Info();

    inline LOGICAL_CHANNEL_ARRAY &GetLogicalChannelArray();

    HRESULT ProcessMessage(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    virtual ~H245_INFO();

protected:

    H245_STATE  m_H245State;

	// logical channels
	LOGICAL_CHANNEL_ARRAY   m_LogicalChannelArray;

	// the other h245 addresses are needed because we need to 
	// cancel NAT redirections in the logical channel destructor
	// and we can't access the other h245 instance there because
	// it may have been destroyed already 

    // queue an asynchronous receive call back
    inline HRESULT QueueReceive();

    // queue an asynchronous send call back
    inline HRESULT QueueSend(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    virtual HRESULT AcceptCallback(
		IN	DWORD			Status,
		IN	SOCKET			Socket,
		IN	SOCKADDR_IN *	LocalAddress,
		IN	SOCKADDR_IN *	RemoteAddress)
    {
        _ASSERTE(FALSE);
        return E_UNEXPECTED;
    }

    virtual HRESULT ReceiveCallback(
        IN      HRESULT                 CallbackHResult,
        IN      BYTE                   *pBuf,
        IN      DWORD                   BufLen
        );

    virtual HRESULT ReceiveCallback(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    virtual HRESULT SendCallback(
        IN      HRESULT					 CallbackHResult
        );

private:
    
    HRESULT HandleRequestMessage(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    HRESULT ProcessResponseMessage(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    HRESULT CheckOpenLogicalChannelPDU(
        IN  MultimediaSystemControlMessage  &H245pdu,
        OUT BYTE                            &SessionId,
        OUT MEDIA_TYPE                      &MediaType
        );
    
    HRESULT CheckOpenLogicalChannelPDU(
        IN  MultimediaSystemControlMessage  &H245pdu,
        OUT BYTE                            &SessionId,
        OUT DWORD                           &SourceIPv4Address,
        OUT WORD                            &SourceRTCPPort
        );

    HRESULT HandleOpenLogicalChannelPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    HRESULT HandleCloseLogicalChannelPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    HRESULT CheckOpenRtpLogicalChannelPDU(
        IN  OpenLogicalChannel              &OlcPDU,
		OUT	SOCKADDR_IN *					ReturnSourceAddress);
    
    HRESULT CheckOpenT120LogicalChannelPDU(
        IN  OpenLogicalChannel  &OlcPDU,
        OUT DWORD               &T120ConnectToIPAddr,
        OUT WORD                &T120ConnectToPort
        );

    HRESULT CreateRtpLogicalChannel(
        IN      OpenLogicalChannel               &OlcPDU,
        IN      BYTE                              SessionId,
        IN      MEDIA_TYPE                        MediaType,
        IN      MultimediaSystemControlMessage   *pH245pdu,
        OUT     LOGICAL_CHANNEL                 **ppReturnLogicalChannel 
        );
    
    HRESULT CreateT120LogicalChannel(
        IN      OpenLogicalChannel               &OlcPDU,
        IN      BYTE                              SessionId,
        IN      MEDIA_TYPE                        MediaType,
        IN      MultimediaSystemControlMessage   *pH245pdu,
        OUT     LOGICAL_CHANNEL                 **ppReturnLogicalChannel 
        );
        
};


inline 
H245_INFO::H245_INFO(
	)
	: m_H245State(H245_STATE_NOT_INIT)
{
}

inline void
H245_INFO::Init(
    IN H323_STATE   &H323State
    )
{
    // initialize the overlaped processor
    OVERLAPPED_PROCESSOR::Init(OPT_H245, H323State);

    m_LogicalChannelArray.Init();
    m_H245State     = H245_STATE_INIT;
}


inline LOGICAL_CHANNEL_ARRAY &
H245_INFO::GetLogicalChannelArray(
    )
{
    return m_LogicalChannelArray;
}

class SOURCE_H245_INFO :
	public H245_INFO
{
public:

	inline SOURCE_H245_INFO();

    inline void Init(
        IN SOURCE_H323_STATE   &SourceH323State
        );

	inline SOURCE_Q931_INFO &GetSourceQ931Info();

    inline DEST_H245_INFO &GetDestH245Info();

	HRESULT ListenForCaller	(
		IN	SOCKADDR_IN *	ListenAddress);

protected:
	
    virtual HRESULT AcceptCallback(
		IN	DWORD			Status,
		IN	SOCKET			Socket,
		IN	SOCKADDR_IN *	LocalAddress,
		IN	SOCKADDR_IN *	RemoteAddress);
};

	
inline 
SOURCE_H245_INFO::SOURCE_H245_INFO(
	)
{
}

inline void
SOURCE_H245_INFO::Init(
    IN SOURCE_H323_STATE   &SourceH323State
    )
{
    H245_INFO::Init((H323_STATE &)SourceH323State);
}


class DEST_H245_INFO :
	public H245_INFO
{
public:

	inline DEST_H245_INFO();

    inline void Init(
        IN DEST_H323_STATE   &DestH323State
        );

	inline void SetCalleeInfo(
		IN	SOCKADDR_IN *	CalleeAddress);

	inline DEST_Q931_INFO &GetDestQ931Info();

	inline HRESULT ConnectToCallee();

protected:

	SOCKADDR_IN		m_CalleeAddress;
};

	
inline 
DEST_H245_INFO::DEST_H245_INFO(
	)
{
}

inline void
DEST_H245_INFO::Init(
    IN DEST_H323_STATE   &DestH323State
    )
{
    H245_INFO::Init((H323_STATE &)DestH323State);
}


inline void 
DEST_H245_INFO::SetCalleeInfo (
	IN	SOCKADDR_IN *	ArgCalleeAddress)
{
	assert (ArgCalleeAddress);

	m_CalleeAddress = *ArgCalleeAddress;

	// state transition to H245_STATE_CON_INFO
	m_H245State = H245_STATE_CON_INFO;
}

#endif // _cbridge_h245_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\h323icsp.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    h323icsp.h

Abstract:

    This module defines the interface between the H.323 proxy (H323ICS.LIB)
    and ICS (IPNATHLP.DLL). The routines whose prototypes appear here are
    invoked by ICS from within the RRAS stub created for the H.323 proxy.
    (See 'MS_IP_H323' in 'ROUTPROT.H'.)

Author:

    Abolade Gbadegesin (aboladeg)   22-Jun-1999

Revision History:

--*/

#ifndef _H323ICSP_H_
#define _H323ICSP_H_

#ifndef	EXTERN_C
#ifdef	__cplusplus
#define	EXTERN_C	extern "C"
#else
#define	EXTERN_C
#endif
#endif

#define INVALID_INTERFACE_INDEX     ((ULONG)-1)

EXTERN_C BOOLEAN
H323ProxyInitializeModule(
    VOID
    );

EXTERN_C VOID
H323ProxyCleanupModule(
    VOID
    );

EXTERN_C ULONG
H323ProxyStartService(
    VOID
    );

EXTERN_C VOID
H323ProxyStopService(
    VOID
    );

EXTERN_C ULONG
H323ProxyActivateInterface(
    ULONG Index,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    );

EXTERN_C VOID
H323ProxyDeactivateInterface(
    ULONG Index
    );

#endif // _H323ICSP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\iocompl.h ===
void HandleSendCompletion(PSendRecvContext pSendCtxt, DWORD dwNumRead,
			 DWORD status);
void HandleRecvCompletion(PSendRecvContext pRecvCtxt, DWORD dwNumRead,
			 DWORD status);
void HandleAcceptCompletion(PAcceptContext pAcceptCtxt, DWORD status);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\h323ics.h ===
#ifndef	__h323ics_h
#define	__h323ics_h

// this file contains declarations for the H323ICS.DLL entry points.

#define	H323ICS_SERVICE_NAME				_T("SharedAccess")
#define	H323ICS_SERVICE_DISPLAY_NAME		_T("H.323 support for ICS service")
#define	H323ICS_EVENT_SOURCE_NAME			_T("H323ICS")

// relative to HKEY_LOCAL_MACHINE
#define	H323ICS_SERVICE_KEY_PATH				_T("System\\CurrentControlSet\\Services\\") H323ICS_SERVICE_NAME
#define	H323ICS_SERVICE_PARAMETERS_KEY_PATH	H323ICS_SERVICE_KEY_PATH _T("\\Parameters")

// values which may be set in H323ICS_SERVICE_PARAMETERS_KEY_PATH
#define H323ICS_REG_VAL_TRACE_FILENAME	 _T("TraceFilename")			// REG_SZ
#define H323ICS_REG_VAL_TRACE_FLAGS		 _T("TraceFlags")				// REG_DWORD, 0 to 5
#define H323ICS_REG_VAL_ALLOW_T120_FLAG	 _T("AllowT120")				// REG_DWORD, 0 or non-zero
#define H323ICS_REG_VAL_DEFAULT_LOCAL_DEST_ADDR _T("DefaultQ931Destination")	// REG_SZ, textual IP address


#endif // __h323ics_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\h245pp.h ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for Multimedia System Control (H.245) */

#ifndef _H245PP_Module_H_
#define _H245PP_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct UnicastAddress_iPSourceRouteAddress_route * PUnicastAddress_iPSourceRouteAddress_route;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers * PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers;

typedef struct RedundancyEncodingCapability_secondaryEncoding * PRedundancyEncodingCapability_secondaryEncoding;

typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom * PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom;

typedef struct MultiplexElement_type_subElementList * PMultiplexElement_type_subElementList;

typedef struct RequestAllTerminalIDsResponse_terminalInformation * PRequestAllTerminalIDsResponse_terminalInformation;

typedef struct EncryptionSync_escrowentry * PEncryptionSync_escrowentry;

typedef struct H263Options_customPictureFormat * PH263Options_customPictureFormat;

typedef struct H263Options_customPictureClockFrequency * PH263Options_customPictureClockFrequency;

typedef struct MultipointCapability_mediaDistributionCapability * PMultipointCapability_mediaDistributionCapability;

typedef struct H222Capability_vcCapability * PH222Capability_vcCapability;

typedef struct CapabilityDescriptor_simultaneousCapabilities * PCapabilityDescriptor_simultaneousCapabilities;

typedef struct CertSelectionCriteria * PCertSelectionCriteria;

typedef struct CommunicationModeTableEntry_nonStandard * PCommunicationModeTableEntry_nonStandard;

typedef struct MultiplexEntrySend_multiplexEntryDescriptors * PMultiplexEntrySend_multiplexEntryDescriptors;

typedef struct H2250LogicalChannelAckParameters_nonStandard * PH2250LogicalChannelAckParameters_nonStandard;

typedef struct H2250LogicalChannelParameters_nonStandard * PH2250LogicalChannelParameters_nonStandard;

typedef struct ConferenceCapability_nonStandardData * PConferenceCapability_nonStandardData;

typedef struct H263Options_modeCombos * PH263Options_modeCombos;

typedef struct TransportCapability_qOSCapabilities * PTransportCapability_qOSCapabilities;

typedef struct EncryptionCapability * PEncryptionCapability;

typedef struct EnhancementLayerInfo_spatialEnhancement * PEnhancementLayerInfo_spatialEnhancement;

typedef struct EnhancementLayerInfo_snrEnhancement * PEnhancementLayerInfo_snrEnhancement;

typedef struct H2250Capability_redundancyEncodingCapability * PH2250Capability_redundancyEncodingCapability;

typedef struct EnhancementLayerInfo_bPictureEnhancement * PEnhancementLayerInfo_bPictureEnhancement;

typedef struct MediaDistributionCapability_distributedData * PMediaDistributionCapability_distributedData;

typedef struct MediaDistributionCapability_centralizedData * PMediaDistributionCapability_centralizedData;

typedef struct CommunicationModeResponse_communicationModeTable * PCommunicationModeResponse_communicationModeTable;

typedef struct CommunicationModeCommand_communicationModeTable * PCommunicationModeCommand_communicationModeTable;

typedef struct TerminalCapabilitySet_capabilityTable * PTerminalCapabilitySet_capabilityTable;

typedef struct RequestMode_requestedModes * PRequestMode_requestedModes;

typedef struct UnicastAddress_iPSourceRouteAddress_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} UnicastAddress_iPSourceRouteAddress_route_Seq;

typedef ASN1uint16_t CustomPictureFormat_pixelAspectInformation_pixelAspectCode_Set;

typedef ASN1uint16_t MediaPacketizationCapability_rtpPayloadType_Seq;

typedef ASN1uint16_t RTPH263VideoRedundancyEncoding_containedThreads_Seq;

typedef ASN1uint16_t RTPH263VideoRedundancyFrameMapping_frameSequence_Seq;

typedef ASN1uint16_t SequenceNumber;

typedef ASN1uint16_t CapabilityTableEntryNumber;

typedef ASN1uint16_t CapabilityDescriptorNumber;

typedef ASN1uint16_t LogicalChannelNumber;

typedef ASN1uint16_t MultiplexTableEntryNumber;

typedef ASN1uint16_t McuNumber;

typedef ASN1uint16_t TerminalNumber;

typedef struct TerminalID {
    ASN1uint32_t length;
    ASN1octet_t value[128];
} TerminalID;

typedef struct ConferenceID {
    ASN1uint32_t length;
    ASN1octet_t value[32];
} ConferenceID;

typedef struct Password {
    ASN1uint32_t length;
    ASN1octet_t value[32];
} Password;

typedef struct NewATMVCIndication_aal_aal1_errorCorrection {
    ASN1choice_t choice;
#   define nullErrorCorrection_chosen 1
#   define longInterleaver_chosen 2
#   define shortInterleaver_chosen 3
#   define errorCorrectionOnly_chosen 4
} NewATMVCIndication_aal_aal1_errorCorrection;

typedef struct NewATMVCIndication_aal_aal1_clockRecovery {
    ASN1choice_t choice;
#   define nullClockRecovery_chosen 1
#   define srtsClockRecovery_chosen 2
#   define adaptiveClockRecovery_chosen 3
} NewATMVCIndication_aal_aal1_clockRecovery;

typedef struct MiscellaneousCommand_type_progressiveRefinementStart_repeatCount {
    ASN1choice_t choice;
#   define doOneProgression_chosen 1
#   define doContinuousProgressions_chosen 2
#   define doOneIndependentProgression_chosen 3
#   define doContinuousIndependentProgressions_chosen 4
} MiscellaneousCommand_type_progressiveRefinementStart_repeatCount;

typedef struct V76LogicalChannelParameters_mode_eRM_recovery {
    ASN1choice_t choice;
#   define rej_chosen 1
#   define sREJ_chosen 2
#   define mSREJ_chosen 3
} V76LogicalChannelParameters_mode_eRM_recovery;

typedef struct CustomPictureFormat_pixelAspectInformation_extendedPAR_Set {
    ASN1uint16_t width;
    ASN1uint16_t height;
} CustomPictureFormat_pixelAspectInformation_extendedPAR_Set;

typedef struct CustomPictureFormat_mPI_customPCF_Set {
    ASN1uint16_t clockConversionCode;
    ASN1uint16_t clockDivisor;
    ASN1uint16_t customMPI;
} CustomPictureFormat_mPI_customPCF_Set;

typedef struct VCCapability_availableBitRates_type_rangeOfBitRates {
    ASN1uint16_t lowerBitRate;
    ASN1uint16_t higherBitRate;
} VCCapability_availableBitRates_type_rangeOfBitRates;

typedef struct TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded {
    ASN1choice_t choice;
    union {
#	define highestEntryNumberProcessed_chosen 1
	CapabilityTableEntryNumber highestEntryNumberProcessed;
#	define noneProcessed_chosen 2
    } u;
} TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded;

typedef struct VCCapability_availableBitRates_type {
    ASN1choice_t choice;
    union {
#	define singleBitRate_chosen 1
	ASN1uint16_t singleBitRate;
#	define rangeOfBitRates_chosen 2
	VCCapability_availableBitRates_type_rangeOfBitRates rangeOfBitRates;
    } u;
} VCCapability_availableBitRates_type;

typedef struct H223Capability_h223MultiplexTableCapability_enhanced {
    ASN1uint16_t maximumNestingDepth;
    ASN1uint16_t maximumElementListSize;
    ASN1uint16_t maximumSubElementListSize;
} H223Capability_h223MultiplexTableCapability_enhanced;

typedef struct CustomPictureFormat_mPI_customPCF {
    ASN1uint32_t count;
    CustomPictureFormat_mPI_customPCF_Set value[16];
} CustomPictureFormat_mPI_customPCF;

typedef struct CustomPictureFormat_pixelAspectInformation_extendedPAR {
    ASN1uint32_t count;
    CustomPictureFormat_pixelAspectInformation_extendedPAR_Set value[256];
} CustomPictureFormat_pixelAspectInformation_extendedPAR;

typedef struct CustomPictureFormat_pixelAspectInformation_pixelAspectCode {
    ASN1uint32_t count;
    CustomPictureFormat_pixelAspectInformation_pixelAspectCode_Set value[14];
} CustomPictureFormat_pixelAspectInformation_pixelAspectCode;

typedef struct H223LogicalChannelParameters_adaptationLayerType_al3 {
    ASN1uint16_t controlFieldOctets;
    ASN1uint32_t sendBufferSize;
} H223LogicalChannelParameters_adaptationLayerType_al3;

typedef struct V76LogicalChannelParameters_mode_eRM {
    ASN1uint16_t windowSize;
    V76LogicalChannelParameters_mode_eRM_recovery recovery;
} V76LogicalChannelParameters_mode_eRM;

typedef struct UnicastAddress_iPSourceRouteAddress_route {
    PUnicastAddress_iPSourceRouteAddress_route next;
    UnicastAddress_iPSourceRouteAddress_route_Seq value;
} UnicastAddress_iPSourceRouteAddress_route_Element;

typedef struct UnicastAddress_iPSourceRouteAddress_routing {
    ASN1choice_t choice;
#   define strict_chosen 1
#   define loose_chosen 2
} UnicastAddress_iPSourceRouteAddress_routing;

typedef struct H223ModeParameters_adaptationLayerType_al3 {
    ASN1uint16_t controlFieldOctets;
    ASN1uint32_t sendBufferSize;
} H223ModeParameters_adaptationLayerType_al3;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers {
    ASN1uint32_t count;
    CapabilityDescriptorNumber value[256];
} SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers {
    PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers next;
    CapabilityTableEntryNumber value;
} SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_Element;

typedef struct MiscellaneousCommand_type_progressiveRefinementStart {
    MiscellaneousCommand_type_progressiveRefinementStart_repeatCount repeatCount;
} MiscellaneousCommand_type_progressiveRefinementStart;

typedef struct MiscellaneousCommand_type_videoFastUpdateMB {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define firstGOB_present 0x80
    ASN1uint16_t firstGOB;
#   define firstMB_present 0x40
    ASN1uint16_t firstMB;
    ASN1uint16_t numberOfMBs;
} MiscellaneousCommand_type_videoFastUpdateMB;

typedef struct MiscellaneousCommand_type_videoFastUpdateGOB {
    ASN1uint16_t firstGOB;
    ASN1uint16_t numberOfGOBs;
} MiscellaneousCommand_type_videoFastUpdateGOB;

typedef struct MiscellaneousIndication_type_videoNotDecodedMBs {
    ASN1uint16_t firstMB;
    ASN1uint16_t numberOfMBs;
    ASN1uint16_t temporalReference;
} MiscellaneousIndication_type_videoNotDecodedMBs;

typedef struct NewATMVCIndication_aal_aal5 {
    ASN1uint16_t forwardMaximumSDUSize;
    ASN1uint16_t backwardMaximumSDUSize;
} NewATMVCIndication_aal_aal5;

typedef struct NewATMVCIndication_aal_aal1 {
    NewATMVCIndication_aal_aal1_clockRecovery clockRecovery;
    NewATMVCIndication_aal_aal1_errorCorrection errorCorrection;
    ASN1bool_t structuredDataTransfer;
    ASN1bool_t partiallyFilledCells;
} NewATMVCIndication_aal_aal1;

typedef struct NewATMVCIndication_reverseParameters_multiplex {
    ASN1choice_t choice;
#   define NewATMVCIndication_reverseParameters_multiplex_noMultiplex_chosen 1
#   define NewATMVCIndication_reverseParameters_multiplex_transportStream_chosen 2
#   define NewATMVCIndication_reverseParameters_multiplex_programStream_chosen 3
} NewATMVCIndication_reverseParameters_multiplex;

typedef struct UserInputIndication_signal_rtp {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define timestamp_present 0x80
    ASN1uint32_t timestamp;
#   define expirationTime_present 0x40
    ASN1uint32_t expirationTime;
    LogicalChannelNumber logicalChannelNumber;
} UserInputIndication_signal_rtp;

typedef struct UserInputIndication_signalUpdate_rtp {
    LogicalChannelNumber logicalChannelNumber;
} UserInputIndication_signalUpdate_rtp;

typedef struct UserInputIndication_signalUpdate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t duration;
#   define UserInputIndication_signalUpdate_rtp_present 0x80
    UserInputIndication_signalUpdate_rtp rtp;
} UserInputIndication_signalUpdate;

typedef struct UserInputIndication_signal {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1char_t signalType[2];
#   define duration_present 0x80
    ASN1uint16_t duration;
#   define UserInputIndication_signal_rtp_present 0x40
    UserInputIndication_signal_rtp rtp;
} UserInputIndication_signal;

typedef struct NewATMVCIndication_reverseParameters {
    ASN1uint16_t bitRate;
    ASN1bool_t bitRateLockedToPCRClock;
    ASN1bool_t bitRateLockedToNetworkClock;
    NewATMVCIndication_reverseParameters_multiplex multiplex;
} NewATMVCIndication_reverseParameters;

typedef struct NewATMVCIndication_multiplex {
    ASN1choice_t choice;
#   define NewATMVCIndication_multiplex_noMultiplex_chosen 1
#   define NewATMVCIndication_multiplex_transportStream_chosen 2
#   define NewATMVCIndication_multiplex_programStream_chosen 3
} NewATMVCIndication_multiplex;

typedef struct NewATMVCIndication_aal {
    ASN1choice_t choice;
    union {
#	define aal1_chosen 1
	NewATMVCIndication_aal_aal1 aal1;
#	define aal5_chosen 2
	NewATMVCIndication_aal_aal5 aal5;
    } u;
} NewATMVCIndication_aal;

typedef struct JitterIndication_scope {
    ASN1choice_t choice;
    union {
#	define JitterIndication_scope_logicalChannelNumber_chosen 1
	LogicalChannelNumber logicalChannelNumber;
#	define JitterIndication_scope_resourceID_chosen 2
	ASN1uint16_t resourceID;
#	define JitterIndication_scope_wholeMultiplex_chosen 3
    } u;
} JitterIndication_scope;

typedef struct FunctionNotSupported_cause {
    ASN1choice_t choice;
#   define syntaxError_chosen 1
#   define semanticError_chosen 2
#   define unknownFunction_chosen 3
} FunctionNotSupported_cause;

typedef struct H223MultiplexReconfiguration_h223AnnexADoubleFlag {
    ASN1choice_t choice;
#   define start_chosen 1
#   define stop_chosen 2
} H223MultiplexReconfiguration_h223AnnexADoubleFlag;

typedef struct H223MultiplexReconfiguration_h223ModeChange {
    ASN1choice_t choice;
#   define toLevel0_chosen 1
#   define toLevel1_chosen 2
#   define toLevel2_chosen 3
#   define toLevel2withOptionalHeader_chosen 4
} H223MultiplexReconfiguration_h223ModeChange;

typedef struct EndSessionCommand_isdnOptions {
    ASN1choice_t choice;
#   define EndSessionCommand_isdnOptions_telephonyMode_chosen 1
#   define v108_chosen 2
} EndSessionCommand_isdnOptions;

typedef struct EndSessionCommand_gstnOptions {
    ASN1choice_t choice;
#   define EndSessionCommand_gstnOptions_telephonyMode_chosen 1
#   define v8bis_chosen 2
#   define v34DSVD_chosen 3
#   define v34DuplexFAX_chosen 4
#   define v34H324_chosen 5
} EndSessionCommand_gstnOptions;

typedef struct FlowControlCommand_restriction {
    ASN1choice_t choice;
    union {
#	define maximumBitRate_chosen 1
	ASN1uint32_t maximumBitRate;
#	define noRestriction_chosen 2
    } u;
} FlowControlCommand_restriction;

typedef struct FlowControlCommand_scope {
    ASN1choice_t choice;
    union {
#	define FlowControlCommand_scope_logicalChannelNumber_chosen 1
	LogicalChannelNumber logicalChannelNumber;
#	define FlowControlCommand_scope_resourceID_chosen 2
	ASN1uint16_t resourceID;
#	define FlowControlCommand_scope_wholeMultiplex_chosen 3
    } u;
} FlowControlCommand_scope;

typedef struct SendTerminalCapabilitySet_specificRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t multiplexCapability;
#   define capabilityTableEntryNumbers_present 0x80
    PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers capabilityTableEntryNumbers;
#   define capabilityDescriptorNumbers_present 0x40
    SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers capabilityDescriptorNumbers;
} SendTerminalCapabilitySet_specificRequest;

typedef struct RemoteMCResponse_reject {
    ASN1choice_t choice;
#   define RemoteMCResponse_reject_unspecified_chosen 1
#   define RemoteMCResponse_reject_functionNotSupported_chosen 2
} RemoteMCResponse_reject;

typedef struct ConferenceResponse_sendThisSourceResponse {
    ASN1choice_t choice;
#   define grantedSendThisSource_chosen 1
#   define deniedSendThisSource_chosen 2
} ConferenceResponse_sendThisSourceResponse;

typedef struct ConferenceResponse_makeTerminalBroadcasterResponse {
    ASN1choice_t choice;
#   define grantedMakeTerminalBroadcaster_chosen 1
#   define deniedMakeTerminalBroadcaster_chosen 2
} ConferenceResponse_makeTerminalBroadcasterResponse;

typedef struct ConferenceResponse_broadcastMyLogicalChannelResponse {
    ASN1choice_t choice;
#   define grantedBroadcastMyLogicalChannel_chosen 1
#   define deniedBroadcastMyLogicalChannel_chosen 2
} ConferenceResponse_broadcastMyLogicalChannelResponse;

typedef struct ConferenceResponse_extensionAddressResponse {
    TerminalID extensionAddress;
} ConferenceResponse_extensionAddressResponse;

typedef struct ConferenceResponse_makeMeChairResponse {
    ASN1choice_t choice;
#   define grantedChairToken_chosen 1
#   define deniedChairToken_chosen 2
} ConferenceResponse_makeMeChairResponse;

typedef struct MaintenanceLoopReject_cause {
    ASN1choice_t choice;
#   define canNotPerformLoop_chosen 1
} MaintenanceLoopReject_cause;

typedef struct MaintenanceLoopReject_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopReject_type_systemLoop_chosen 1
#	define MaintenanceLoopReject_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopReject_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopReject_type;

typedef struct MaintenanceLoopAck_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopAck_type_systemLoop_chosen 1
#	define MaintenanceLoopAck_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopAck_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopAck_type;

typedef struct MaintenanceLoopRequest_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopRequest_type_systemLoop_chosen 1
#	define MaintenanceLoopRequest_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopRequest_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopRequest_type;

typedef struct G7231AnnexCMode_g723AnnexCAudioMode {
    ASN1uint16_t highRateMode0;
    ASN1uint16_t highRateMode1;
    ASN1uint16_t lowRateMode0;
    ASN1uint16_t lowRateMode1;
    ASN1uint16_t sidMode0;
    ASN1uint16_t sidMode1;
} G7231AnnexCMode_g723AnnexCAudioMode;

typedef struct IS13818AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS13818AudioMode_multichannelType_singleChannel_chosen 1
#   define IS13818AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS13818AudioMode_multichannelType_twoChannelDual_chosen 3
#   define threeChannels2_1_chosen 4
#   define threeChannels3_0_chosen 5
#   define fourChannels2_0_2_0_chosen 6
#   define fourChannels2_2_chosen 7
#   define fourChannels3_1_chosen 8
#   define fiveChannels3_0_2_0_chosen 9
#   define fiveChannels3_2_chosen 10
} IS13818AudioMode_multichannelType;

typedef struct IS13818AudioMode_audioSampling {
    ASN1choice_t choice;
#   define audioSampling16k_chosen 1
#   define audioSampling22k05_chosen 2
#   define audioSampling24k_chosen 3
#   define IS13818AudioMode_audioSampling_audioSampling32k_chosen 4
#   define IS13818AudioMode_audioSampling_audioSampling44k1_chosen 5
#   define IS13818AudioMode_audioSampling_audioSampling48k_chosen 6
} IS13818AudioMode_audioSampling;

typedef struct IS13818AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS13818AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS13818AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS13818AudioMode_audioLayer_audioLayer3_chosen 3
} IS13818AudioMode_audioLayer;

typedef struct IS11172AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS11172AudioMode_multichannelType_singleChannel_chosen 1
#   define IS11172AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS11172AudioMode_multichannelType_twoChannelDual_chosen 3
} IS11172AudioMode_multichannelType;

typedef struct IS11172AudioMode_audioSampling {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioSampling_audioSampling32k_chosen 1
#   define IS11172AudioMode_audioSampling_audioSampling44k1_chosen 2
#   define IS11172AudioMode_audioSampling_audioSampling48k_chosen 3
} IS11172AudioMode_audioSampling;

typedef struct IS11172AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS11172AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS11172AudioMode_audioLayer_audioLayer3_chosen 3
} IS11172AudioMode_audioLayer;

typedef struct AudioMode_g7231 {
    ASN1choice_t choice;
#   define noSilenceSuppressionLowRate_chosen 1
#   define noSilenceSuppressionHighRate_chosen 2
#   define silenceSuppressionLowRate_chosen 3
#   define silenceSuppressionHighRate_chosen 4
} AudioMode_g7231;

typedef struct H263VideoMode_resolution {
    ASN1choice_t choice;
#   define sqcif_chosen 1
#   define H263VideoMode_resolution_qcif_chosen 2
#   define H263VideoMode_resolution_cif_chosen 3
#   define cif4_chosen 4
#   define cif16_chosen 5
} H263VideoMode_resolution;

typedef struct H262VideoMode_profileAndLevel {
    ASN1choice_t choice;
#   define profileAndLevel_SPatML_chosen 1
#   define profileAndLevel_MPatLL_chosen 2
#   define profileAndLevel_MPatML_chosen 3
#   define profileAndLevel_MPatH_14_chosen 4
#   define profileAndLevel_MPatHL_chosen 5
#   define profileAndLevel_SNRatLL_chosen 6
#   define profileAndLevel_SNRatML_chosen 7
#   define profileAndLevel_SpatialatH_14_chosen 8
#   define profileAndLevel_HPatML_chosen 9
#   define profileAndLevel_HPatH_14_chosen 10
#   define profileAndLevel_HPatHL_chosen 11
} H262VideoMode_profileAndLevel;

typedef struct H261VideoMode_resolution {
    ASN1choice_t choice;
#   define H261VideoMode_resolution_qcif_chosen 1
#   define H261VideoMode_resolution_cif_chosen 2
} H261VideoMode_resolution;

typedef struct RequestModeReject_cause {
    ASN1choice_t choice;
#   define modeUnavailable_chosen 1
#   define multipointConstraint_chosen 2
#   define requestDenied_chosen 3
} RequestModeReject_cause;

typedef struct RequestModeAck_response {
    ASN1choice_t choice;
#   define willTransmitMostPreferredMode_chosen 1
#   define willTransmitLessPreferredMode_chosen 2
} RequestModeAck_response;

typedef struct RequestMultiplexEntryRelease_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryRelease_entryNumbers;

typedef struct RequestMultiplexEntryRejectionDescriptions_cause {
    ASN1choice_t choice;
#   define RequestMultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen 1
} RequestMultiplexEntryRejectionDescriptions_cause;

typedef struct RequestMultiplexEntryReject_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryReject_entryNumbers;

typedef struct RequestMultiplexEntryAck_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryAck_entryNumbers;

typedef struct RequestMultiplexEntry_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntry_entryNumbers;

typedef struct MultiplexEntrySendRelease_multiplexTableEntryNumber {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} MultiplexEntrySendRelease_multiplexTableEntryNumber;

typedef struct MultiplexEntryRejectionDescriptions_cause {
    ASN1choice_t choice;
#   define MultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen 1
#   define descriptorTooComplex_chosen 2
} MultiplexEntryRejectionDescriptions_cause;

typedef struct MultiplexEntrySendAck_multiplexTableEntryNumber {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} MultiplexEntrySendAck_multiplexTableEntryNumber;

typedef struct MultiplexElement_repeatCount {
    ASN1choice_t choice;
    union {
#	define MultiplexElement_repeatCount_finite_chosen 1
	ASN1uint16_t finite;
#	define untilClosingFlag_chosen 2
    } u;
} MultiplexElement_repeatCount;

typedef struct MultiplexElement_type {
    ASN1choice_t choice;
    union {
#	define MultiplexElement_type_logicalChannelNumber_chosen 1
	ASN1uint16_t logicalChannelNumber;
#	define subElementList_chosen 2
	PMultiplexElement_type_subElementList subElementList;
    } u;
} MultiplexElement_type;

typedef struct RequestChannelCloseReject_cause {
    ASN1choice_t choice;
#   define RequestChannelCloseReject_cause_unspecified_chosen 1
} RequestChannelCloseReject_cause;

typedef struct RequestChannelClose_reason {
    ASN1choice_t choice;
#   define RequestChannelClose_reason_unknown_chosen 1
#   define normal_chosen 2
#   define RequestChannelClose_reason_reopen_chosen 3
#   define RequestChannelClose_reason_reservationFailure_chosen 4
} RequestChannelClose_reason;

typedef struct CloseLogicalChannel_reason {
    ASN1choice_t choice;
#   define CloseLogicalChannel_reason_unknown_chosen 1
#   define CloseLogicalChannel_reason_reopen_chosen 2
#   define CloseLogicalChannel_reason_reservationFailure_chosen 3
} CloseLogicalChannel_reason;

typedef struct CloseLogicalChannel_source {
    ASN1choice_t choice;
#   define user_chosen 1
#   define lcse_chosen 2
} CloseLogicalChannel_source;

typedef struct OpenLogicalChannelReject_cause {
    ASN1choice_t choice;
#   define OpenLogicalChannelReject_cause_unspecified_chosen 1
#   define unsuitableReverseParameters_chosen 2
#   define dataTypeNotSupported_chosen 3
#   define dataTypeNotAvailable_chosen 4
#   define unknownDataType_chosen 5
#   define dataTypeALCombinationNotSupported_chosen 6
#   define multicastChannelNotAllowed_chosen 7
#   define insufficientBandwidth_chosen 8
#   define separateStackEstablishmentFailed_chosen 9
#   define invalidSessionID_chosen 10
#   define masterSlaveConflict_chosen 11
#   define waitForCommunicationMode_chosen 12
#   define invalidDependentChannel_chosen 13
#   define replacementForRejected_chosen 14
} OpenLogicalChannelReject_cause;

typedef struct MulticastAddress_iP6Address {
    struct MulticastAddress_iP6Address_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } network;
    ASN1uint16_t tsapIdentifier;
} MulticastAddress_iP6Address;

typedef struct MulticastAddress_iPAddress {
    struct MulticastAddress_iPAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
} MulticastAddress_iPAddress;

typedef struct UnicastAddress_iPSourceRouteAddress {
    UnicastAddress_iPSourceRouteAddress_routing routing;
    struct UnicastAddress_iPSourceRouteAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
    PUnicastAddress_iPSourceRouteAddress_route route;
} UnicastAddress_iPSourceRouteAddress;

typedef struct UnicastAddress_iP6Address {
    struct UnicastAddress_iP6Address_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } network;
    ASN1uint16_t tsapIdentifier;
} UnicastAddress_iP6Address;

typedef struct UnicastAddress_iPXAddress {
    struct UnicastAddress_iPXAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct UnicastAddress_iPXAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct UnicastAddress_iPXAddress_tsapIdentifier_tsapIdentifier {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } tsapIdentifier;
} UnicastAddress_iPXAddress;

typedef struct UnicastAddress_iPAddress {
    struct UnicastAddress_iPAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
} UnicastAddress_iPAddress;

typedef struct H2250LogicalChannelParameters_mediaPacketization {
    ASN1choice_t choice;
    union {
#	define h261aVideoPacketization_chosen 1
#	define rtpPayloadType_chosen 2
	ASN1uint16_t rtpPayloadType;
    } u;
} H2250LogicalChannelParameters_mediaPacketization;

typedef struct V76LogicalChannelParameters_mode {
    ASN1choice_t choice;
    union {
#	define eRM_chosen 1
	V76LogicalChannelParameters_mode_eRM eRM;
#	define uNERM_chosen 2
    } u;
} V76LogicalChannelParameters_mode;

typedef struct V76LogicalChannelParameters_suspendResume {
    ASN1choice_t choice;
#   define noSuspendResume_chosen 1
#   define V76LogicalChannelParameters_suspendResume_suspendResumewAddress_chosen 2
#   define V76LogicalChannelParameters_suspendResume_suspendResumewoAddress_chosen 3
} V76LogicalChannelParameters_suspendResume;

typedef struct H223AnnexCArqParameters_numberOfRetransmissions {
    ASN1choice_t choice;
    union {
#	define H223AnnexCArqParameters_numberOfRetransmissions_finite_chosen 1
	ASN1uint16_t finite;
#	define infinite_chosen 2
    } u;
} H223AnnexCArqParameters_numberOfRetransmissions;

typedef struct H223AL3MParameters_fecType {
    ASN1choice_t choice;
#   define H223AL3MParameters_fecType_rcpcRate8by8_chosen 1
#   define H223AL3MParameters_fecType_rcpcRate8by9_chosen 2
#   define H223AL3MParameters_fecType_rcpcRate8by10_chosen 3
#   define H223AL3MParameters_fecType_rcpcRate8by12_chosen 4
#   define H223AL3MParameters_fecType_rcpcRate8by16_chosen 5
#   define H223AL3MParameters_fecType_rcpcRate8by20_chosen 6
#   define H223AL3MParameters_fecType_rcpcRate8by24_chosen 7
#   define H223AL3MParameters_fecType_rcpcRate8by32_chosen 8
} H223AL3MParameters_fecType;

typedef struct H223AL3MParameters_crcLength {
    ASN1choice_t choice;
#   define H223AL3MParameters_crcLength_crc4bit_chosen 1
#   define H223AL3MParameters_crcLength_crc12bit_chosen 2
#   define H223AL3MParameters_crcLength_crc20bit_chosen 3
#   define H223AL3MParameters_crcLength_crc28bit_chosen 4
} H223AL3MParameters_crcLength;

typedef struct H223AL3MParameters_headerFormat {
    ASN1choice_t choice;
#   define H223AL3MParameters_headerFormat_sebch16_7_chosen 1
#   define H223AL3MParameters_headerFormat_golay24_12_chosen 2
} H223AL3MParameters_headerFormat;

typedef struct H223AL2MParameters_headerFEC {
    ASN1choice_t choice;
#   define sebch16_5_chosen 1
#   define H223AL2MParameters_headerFEC_golay24_12_chosen 2
} H223AL2MParameters_headerFEC;

typedef struct H223AL1MParameters_fecType {
    ASN1choice_t choice;
#   define H223AL1MParameters_fecType_rcpcRate8by8_chosen 1
#   define H223AL1MParameters_fecType_rcpcRate8by9_chosen 2
#   define H223AL1MParameters_fecType_rcpcRate8by10_chosen 3
#   define H223AL1MParameters_fecType_rcpcRate8by12_chosen 4
#   define H223AL1MParameters_fecType_rcpcRate8by16_chosen 5
#   define H223AL1MParameters_fecType_rcpcRate8by20_chosen 6
#   define H223AL1MParameters_fecType_rcpcRate8by24_chosen 7
#   define H223AL1MParameters_fecType_rcpcRate8by32_chosen 8
} H223AL1MParameters_fecType;

typedef struct H223AL1MParameters_crcLength {
    ASN1choice_t choice;
#   define H223AL1MParameters_crcLength_crc4bit_chosen 1
#   define H223AL1MParameters_crcLength_crc12bit_chosen 2
#   define H223AL1MParameters_crcLength_crc20bit_chosen 3
#   define H223AL1MParameters_crcLength_crc28bit_chosen 4
} H223AL1MParameters_crcLength;

typedef struct H223AL1MParameters_headerFEC {
    ASN1choice_t choice;
#   define H223AL1MParameters_headerFEC_sebch16_7_chosen 1
#   define H223AL1MParameters_headerFEC_golay24_12_chosen 2
} H223AL1MParameters_headerFEC;

typedef struct H223AL1MParameters_transferMode {
    ASN1choice_t choice;
#   define framed_chosen 1
#   define unframed_chosen 2
} H223AL1MParameters_transferMode;

typedef struct Q2931Address_address {
    ASN1choice_t choice;
    union {
#	define internationalNumber_chosen 1
	ASN1char_t internationalNumber[17];
#	define nsapAddress_chosen 2
	struct Q2931Address_address_nsapAddress_nsapAddress {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsapAddress;
    } u;
} Q2931Address_address;

typedef struct NetworkAccessParameters_t120SetupProcedure {
    ASN1choice_t choice;
#   define issueJoin_chosen 1
#   define issueQueryAndJoin_chosen 2
#   define issueCreate_chosen 3
#   define issueInvite_chosen 4
#   define waitForInvite_chosen 5
} NetworkAccessParameters_t120SetupProcedure;

typedef struct NetworkAccessParameters_distribution {
    ASN1choice_t choice;
#   define unicast_chosen 1
#   define multicast_chosen 2
} NetworkAccessParameters_distribution;

typedef struct T84Profile_t84Restricted {
    ASN1bool_t qcif;
    ASN1bool_t cif;
    ASN1bool_t ccir601Seq;
    ASN1bool_t ccir601Prog;
    ASN1bool_t hdtvSeq;
    ASN1bool_t hdtvProg;
    ASN1bool_t g3FacsMH200x100;
    ASN1bool_t g3FacsMH200x200;
    ASN1bool_t g4FacsMMR200x100;
    ASN1bool_t g4FacsMMR200x200;
    ASN1bool_t jbig200x200Seq;
    ASN1bool_t jbig200x200Prog;
    ASN1bool_t jbig300x300Seq;
    ASN1bool_t jbig300x300Prog;
    ASN1bool_t digPhotoLow;
    ASN1bool_t digPhotoMedSeq;
    ASN1bool_t digPhotoMedProg;
    ASN1bool_t digPhotoHighSeq;
    ASN1bool_t digPhotoHighProg;
} T84Profile_t84Restricted;

typedef struct G7231AnnexCCapability_g723AnnexCAudioMode {
    ASN1uint16_t highRateMode0;
    ASN1uint16_t highRateMode1;
    ASN1uint16_t lowRateMode0;
    ASN1uint16_t lowRateMode1;
    ASN1uint16_t sidMode0;
    ASN1uint16_t sidMode1;
} G7231AnnexCCapability_g723AnnexCAudioMode;

typedef struct AudioCapability_g7231 {
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
} AudioCapability_g7231;

typedef struct CustomPictureFormat_pixelAspectInformation {
    ASN1choice_t choice;
    union {
#	define anyPixelAspectRatio_chosen 1
	ASN1bool_t anyPixelAspectRatio;
#	define pixelAspectCode_chosen 2
	CustomPictureFormat_pixelAspectInformation_pixelAspectCode pixelAspectCode;
#	define extendedPAR_chosen 3
	CustomPictureFormat_pixelAspectInformation_extendedPAR extendedPAR;
    } u;
} CustomPictureFormat_pixelAspectInformation;

typedef struct CustomPictureFormat_mPI {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define standardMPI_present 0x80
    ASN1uint16_t standardMPI;
#   define customPCF_present 0x40
    CustomPictureFormat_mPI_customPCF customPCF;
} CustomPictureFormat_mPI;

typedef struct RefPictureSelection_videoBackChannelSend {
    ASN1choice_t choice;
#   define RefPictureSelection_videoBackChannelSend_none_chosen 1
#   define ackMessageOnly_chosen 2
#   define nackMessageOnly_chosen 3
#   define ackOrNackMessageOnly_chosen 4
#   define ackAndNackMessage_chosen 5
} RefPictureSelection_videoBackChannelSend;

typedef struct RefPictureSelection_additionalPictureMemory {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define sqcifAdditionalPictureMemory_present 0x80
    ASN1uint16_t sqcifAdditionalPictureMemory;
#   define qcifAdditionalPictureMemory_present 0x40
    ASN1uint16_t qcifAdditionalPictureMemory;
#   define cifAdditionalPictureMemory_present 0x20
    ASN1uint16_t cifAdditionalPictureMemory;
#   define cif4AdditionalPictureMemory_present 0x10
    ASN1uint16_t cif4AdditionalPictureMemory;
#   define cif16AdditionalPictureMemory_present 0x8
    ASN1uint16_t cif16AdditionalPictureMemory;
#   define bigCpfAdditionalPictureMemory_present 0x4
    ASN1uint16_t bigCpfAdditionalPictureMemory;
} RefPictureSelection_additionalPictureMemory;

typedef struct RTPH263VideoRedundancyFrameMapping_frameSequence {
    ASN1uint32_t count;
    RTPH263VideoRedundancyFrameMapping_frameSequence_Seq value[256];
} RTPH263VideoRedundancyFrameMapping_frameSequence;

typedef struct RTPH263VideoRedundancyEncoding_containedThreads {
    ASN1uint32_t count;
    RTPH263VideoRedundancyEncoding_containedThreads_Seq value[256];
} RTPH263VideoRedundancyEncoding_containedThreads;

typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping {
    ASN1choice_t choice;
    union {
#	define roundrobin_chosen 1
#	define custom_chosen 2
	PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom custom;
    } u;
} RTPH263VideoRedundancyEncoding_frameToThreadMapping;

typedef struct RedundancyEncodingCapability_secondaryEncoding {
    PRedundancyEncodingCapability_secondaryEncoding next;
    CapabilityTableEntryNumber value;
} RedundancyEncodingCapability_secondaryEncoding_Element;

typedef struct MediaPacketizationCapability_rtpPayloadType {
    ASN1uint32_t count;
    MediaPacketizationCapability_rtpPayloadType_Seq value[256];
} MediaPacketizationCapability_rtpPayloadType;

typedef struct H2250Capability_mcCapability {
    ASN1bool_t centralizedConferenceMC;
    ASN1bool_t decentralizedConferenceMC;
} H2250Capability_mcCapability;

typedef struct H223Capability_mobileOperationTransmitCapability {
    ASN1bool_t modeChangeCapability;
    ASN1bool_t h223AnnexA;
    ASN1bool_t h223AnnexADoubleFlag;
    ASN1bool_t h223AnnexB;
    ASN1bool_t h223AnnexBwithHeader;
} H223Capability_mobileOperationTransmitCapability;

typedef struct H223Capability_h223MultiplexTableCapability {
    ASN1choice_t choice;
    union {
#	define basic_chosen 1
#	define enhanced_chosen 2
	H223Capability_h223MultiplexTableCapability_enhanced enhanced;
    } u;
} H223Capability_h223MultiplexTableCapability;

typedef struct VCCapability_availableBitRates {
    VCCapability_availableBitRates_type type;
} VCCapability_availableBitRates;

typedef struct VCCapability_aal5 {
    ASN1uint16_t forwardMaximumSDUSize;
    ASN1uint16_t backwardMaximumSDUSize;
} VCCapability_aal5;

typedef struct VCCapability_aal1 {
    ASN1bool_t nullClockRecovery;
    ASN1bool_t srtsClockRecovery;
    ASN1bool_t adaptiveClockRecovery;
    ASN1bool_t nullErrorCorrection;
    ASN1bool_t longInterleaver;
    ASN1bool_t shortInterleaver;
    ASN1bool_t errorCorrectionOnly;
    ASN1bool_t structuredDataTransfer;
    ASN1bool_t partiallyFilledCells;
} VCCapability_aal1;

typedef struct Capability_h233EncryptionReceiveCapability {
    ASN1uint16_t h233IVResponseTime;
} Capability_h233EncryptionReceiveCapability;

typedef struct TerminalCapabilitySetReject_cause {
    ASN1choice_t choice;
    union {
#	define TerminalCapabilitySetReject_cause_unspecified_chosen 1
#	define undefinedTableEntryUsed_chosen 2
#	define descriptorCapacityExceeded_chosen 3
#	define tableEntryCapacityExceeded_chosen 4
	TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded tableEntryCapacityExceeded;
    } u;
} TerminalCapabilitySetReject_cause;

typedef struct MasterSlaveDeterminationReject_cause {
    ASN1choice_t choice;
#   define identicalNumbers_chosen 1
} MasterSlaveDeterminationReject_cause;

typedef struct MasterSlaveDeterminationAck_decision {
    ASN1choice_t choice;
#   define master_chosen 1
#   define slave_chosen 2
} MasterSlaveDeterminationAck_decision;

typedef struct NonStandardIdentifier_h221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} NonStandardIdentifier_h221NonStandard;

typedef struct NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221NonStandard_chosen 2
	NonStandardIdentifier_h221NonStandard h221NonStandard;
    } u;
} NonStandardIdentifier;

typedef struct MasterSlaveDetermination {
    ASN1uint16_t terminalType;
    ASN1uint32_t statusDeterminationNumber;
} MasterSlaveDetermination;

typedef struct MasterSlaveDeterminationAck {
    MasterSlaveDeterminationAck_decision decision;
} MasterSlaveDeterminationAck;

typedef struct MasterSlaveDeterminationReject {
    MasterSlaveDeterminationReject_cause cause;
} MasterSlaveDeterminationReject;

typedef struct MasterSlaveDeterminationRelease {
    char placeholder;
} MasterSlaveDeterminationRelease;

typedef struct CapabilityDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityDescriptorNumber capabilityDescriptorNumber;
#   define simultaneousCapabilities_present 0x80
    PCapabilityDescriptor_simultaneousCapabilities simultaneousCapabilities;
} CapabilityDescriptor;

typedef struct AlternativeCapabilitySet {
    ASN1uint32_t count;
    CapabilityTableEntryNumber value[256];
} AlternativeCapabilitySet;

typedef struct TerminalCapabilitySetAck {
    SequenceNumber sequenceNumber;
} TerminalCapabilitySetAck;

typedef struct TerminalCapabilitySetReject {
    SequenceNumber sequenceNumber;
    TerminalCapabilitySetReject_cause cause;
} TerminalCapabilitySetReject;

typedef struct TerminalCapabilitySetRelease {
    char placeholder;
} TerminalCapabilitySetRelease;

typedef struct H222Capability {
    ASN1uint16_t numberOfVCs;
    PH222Capability_vcCapability vcCapability;
} H222Capability;

typedef struct VCCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define aal1_present 0x80
    VCCapability_aal1 aal1;
#   define aal5_present 0x40
    VCCapability_aal5 aal5;
    ASN1bool_t transportStream;
    ASN1bool_t programStream;
    VCCapability_availableBitRates availableBitRates;
} VCCapability;

typedef struct H223AnnexCCapability {
    ASN1bool_t videoWithAL1M;
    ASN1bool_t videoWithAL2M;
    ASN1bool_t videoWithAL3M;
    ASN1bool_t audioWithAL1M;
    ASN1bool_t audioWithAL2M;
    ASN1bool_t audioWithAL3M;
    ASN1bool_t dataWithAL1M;
    ASN1bool_t dataWithAL2M;
    ASN1bool_t dataWithAL3M;
    ASN1bool_t alpduInterleaving;
    ASN1uint16_t maximumAL2MSDUSize;
    ASN1uint16_t maximumAL3MSDUSize;
} H223AnnexCCapability;

typedef struct V75Capability {
    ASN1bool_t audioHeader;
} V75Capability;

typedef struct MediaPacketizationCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t h261aVideoPacketization;
#   define rtpPayloadType_present 0x80
    MediaPacketizationCapability_rtpPayloadType rtpPayloadType;
} MediaPacketizationCapability;

typedef struct QOSMode {
    ASN1choice_t choice;
    union {
#	define guaranteedQOS_chosen 1
	ASN1bool_t guaranteedQOS;
#	define controlledLoad_chosen 2
	ASN1bool_t controlledLoad;
    } u;
} QOSMode;

typedef struct ATMParameters {
    ASN1uint16_t maxNTUSize;
    ASN1bool_t atmUBR;
    ASN1bool_t atmrtVBR;
    ASN1bool_t atmnrtVBR;
    ASN1bool_t atmABR;
    ASN1bool_t atmCBR;
} ATMParameters;

typedef struct MediaTransportType {
    ASN1choice_t choice;
#   define ip_UDP_chosen 1
#   define ip_TCP_chosen 2
#   define atm_AAL5_UNIDIR_chosen 3
#   define atm_AAL5_BIDIR_chosen 4
} MediaTransportType;

typedef struct MediaChannelCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define mediaTransport_present 0x80
    MediaTransportType mediaTransport;
} MediaChannelCapability;

typedef struct RTPH263VideoRedundancyEncoding {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t numberOfThreads;
    ASN1uint16_t framesBetweenSyncPoints;
    RTPH263VideoRedundancyEncoding_frameToThreadMapping frameToThreadMapping;
#   define containedThreads_present 0x80
    RTPH263VideoRedundancyEncoding_containedThreads containedThreads;
} RTPH263VideoRedundancyEncoding;

typedef struct RTPH263VideoRedundancyFrameMapping {
    ASN1uint16_t threadNumber;
    RTPH263VideoRedundancyFrameMapping_frameSequence frameSequence;
} RTPH263VideoRedundancyFrameMapping;

typedef struct MultipointCapability {
    ASN1bool_t multicastCapability;
    ASN1bool_t multiUniCastConference;
    PMultipointCapability_mediaDistributionCapability mediaDistributionCapability;
} MultipointCapability;

typedef struct MediaDistributionCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t centralizedControl;
    ASN1bool_t distributedControl;
    ASN1bool_t centralizedAudio;
    ASN1bool_t distributedAudio;
    ASN1bool_t centralizedVideo;
    ASN1bool_t distributedVideo;
#   define centralizedData_present 0x80
    PMediaDistributionCapability_centralizedData centralizedData;
#   define distributedData_present 0x40
    PMediaDistributionCapability_distributedData distributedData;
} MediaDistributionCapability;

typedef struct H261VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H261VideoCapability_qcifMPI_present 0x80
    ASN1uint16_t qcifMPI;
#   define H261VideoCapability_cifMPI_present 0x40
    ASN1uint16_t cifMPI;
    ASN1bool_t temporalSpatialTradeOffCapability;
    ASN1uint16_t maxBitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoCapability;

typedef struct H262VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t profileAndLevel_SPatML;
    ASN1bool_t profileAndLevel_MPatLL;
    ASN1bool_t profileAndLevel_MPatML;
    ASN1bool_t profileAndLevel_MPatH_14;
    ASN1bool_t profileAndLevel_MPatHL;
    ASN1bool_t profileAndLevel_SNRatLL;
    ASN1bool_t profileAndLevel_SNRatML;
    ASN1bool_t profileAndLevel_SpatialatH_14;
    ASN1bool_t profileAndLevel_HPatML;
    ASN1bool_t profileAndLevel_HPatH_14;
    ASN1bool_t profileAndLevel_HPatHL;
#   define H262VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoCapability_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoCapability;

typedef struct EnhancementLayerInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t baseBitRateConstrained;
#   define snrEnhancement_present 0x80
    PEnhancementLayerInfo_snrEnhancement snrEnhancement;
#   define spatialEnhancement_present 0x40
    PEnhancementLayerInfo_spatialEnhancement spatialEnhancement;
#   define bPictureEnhancement_present 0x20
    PEnhancementLayerInfo_bPictureEnhancement bPictureEnhancement;
} EnhancementLayerInfo;

typedef struct TransparencyParameters {
    ASN1uint16_t presentationOrder;
    ASN1int32_t offset_x;
    ASN1int32_t offset_y;
    ASN1uint16_t scale_x;
    ASN1uint16_t scale_y;
} TransparencyParameters;

typedef struct RefPictureSelection {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define additionalPictureMemory_present 0x80
    RefPictureSelection_additionalPictureMemory additionalPictureMemory;
    ASN1bool_t videoMux;
    RefPictureSelection_videoBackChannelSend videoBackChannelSend;
} RefPictureSelection;

typedef struct CustomPictureClockFrequency {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t clockConversionCode;
    ASN1uint16_t clockDivisor;
#   define CustomPictureClockFrequency_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define CustomPictureClockFrequency_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define CustomPictureClockFrequency_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define CustomPictureClockFrequency_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define CustomPictureClockFrequency_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
} CustomPictureClockFrequency;

typedef struct CustomPictureFormat {
    ASN1uint16_t maxCustomPictureWidth;
    ASN1uint16_t maxCustomPictureHeight;
    ASN1uint16_t minCustomPictureWidth;
    ASN1uint16_t minCustomPictureHeight;
    CustomPictureFormat_mPI mPI;
    CustomPictureFormat_pixelAspectInformation pixelAspectInformation;
} CustomPictureFormat;

typedef struct H263ModeComboFlags {
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
    ASN1bool_t advancedIntraCodingMode;
    ASN1bool_t deblockingFilterMode;
    ASN1bool_t unlimitedMotionVectors;
    ASN1bool_t slicesInOrder_NonRect;
    ASN1bool_t slicesInOrder_Rect;
    ASN1bool_t slicesNoOrder_NonRect;
    ASN1bool_t slicesNoOrder_Rect;
    ASN1bool_t improvedPBFramesMode;
    ASN1bool_t referencePicSelect;
    ASN1bool_t dynamicPictureResizingByFour;
    ASN1bool_t dynamicPictureResizingSixteenthPel;
    ASN1bool_t dynamicWarpingHalfPel;
    ASN1bool_t dynamicWarpingSixteenthPel;
    ASN1bool_t reducedResolutionUpdate;
    ASN1bool_t independentSegmentDecoding;
    ASN1bool_t alternateInterVLCMode;
    ASN1bool_t modifiedQuantizationMode;
} H263ModeComboFlags;

typedef struct IS11172VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoCapability_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoCapability;

typedef struct G7231AnnexCCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
#   define g723AnnexCAudioMode_present 0x80
    G7231AnnexCCapability_g723AnnexCAudioMode g723AnnexCAudioMode;
} G7231AnnexCCapability;

typedef struct IS11172AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1uint16_t bitRate;
} IS11172AudioCapability;

typedef struct IS13818AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling16k;
    ASN1bool_t audioSampling22k05;
    ASN1bool_t audioSampling24k;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1bool_t threeChannels2_1;
    ASN1bool_t threeChannels3_0;
    ASN1bool_t fourChannels2_0_2_0;
    ASN1bool_t fourChannels2_2;
    ASN1bool_t fourChannels3_1;
    ASN1bool_t fiveChannels3_0_2_0;
    ASN1bool_t fiveChannels3_2;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioCapability;

typedef struct GSMAudioCapability {
    ASN1uint16_t audioUnitSize;
    ASN1bool_t comfortNoise;
    ASN1bool_t scrambled;
} GSMAudioCapability;

typedef struct V42bis {
    ASN1uint32_t numberOfCodewords;
    ASN1uint16_t maximumStringLength;
} V42bis;

typedef struct T84Profile {
    ASN1choice_t choice;
    union {
#	define t84Unrestricted_chosen 1
#	define t84Restricted_chosen 2
	T84Profile_t84Restricted t84Restricted;
    } u;
} T84Profile;

typedef struct ConferenceCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ConferenceCapability_nonStandardData_present 0x80
    PConferenceCapability_nonStandardData nonStandardData;
    ASN1bool_t chairControlCapability;
} ConferenceCapability;

typedef struct Q2931Address {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Q2931Address_address address;
#   define subaddress_present 0x80
    struct Q2931Address_subaddress_subaddress {
	ASN1uint32_t length;
	ASN1octet_t value[20];
    } subaddress;
} Q2931Address;

typedef struct V75Parameters {
    ASN1bool_t audioHeaderPresent;
} V75Parameters;

typedef struct H222LogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t resourceID;
    ASN1uint16_t subChannelID;
#   define pcr_pid_present 0x80
    ASN1uint16_t pcr_pid;
#   define programDescriptors_present 0x40
    ASN1octetstring_t programDescriptors;
#   define streamDescriptors_present 0x20
    ASN1octetstring_t streamDescriptors;
} H222LogicalChannelParameters;

typedef struct H223AL2MParameters {
    H223AL2MParameters_headerFEC headerFEC;
    ASN1bool_t alpduInterleaving;
} H223AL2MParameters;

typedef struct H223AnnexCArqParameters {
    H223AnnexCArqParameters_numberOfRetransmissions numberOfRetransmissions;
    ASN1uint32_t sendBufferSize;
} H223AnnexCArqParameters;

typedef struct CRCLength {
    ASN1choice_t choice;
#   define crc8bit_chosen 1
#   define crc16bit_chosen 2
#   define crc32bit_chosen 3
} CRCLength;

typedef struct EscrowData {
    ASN1objectidentifier_t escrowID;
    ASN1bitstring_t escrowValue;
} EscrowData;

typedef struct OpenLogicalChannelReject {
    LogicalChannelNumber forwardLogicalChannelNumber;
    OpenLogicalChannelReject_cause cause;
} OpenLogicalChannelReject;

typedef struct OpenLogicalChannelConfirm {
    LogicalChannelNumber forwardLogicalChannelNumber;
} OpenLogicalChannelConfirm;

typedef struct CloseLogicalChannel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
    CloseLogicalChannel_source source;
#   define CloseLogicalChannel_reason_present 0x80
    CloseLogicalChannel_reason reason;
} CloseLogicalChannel;

typedef struct CloseLogicalChannelAck {
    LogicalChannelNumber forwardLogicalChannelNumber;
} CloseLogicalChannelAck;

typedef struct RequestChannelCloseAck {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelCloseAck;

typedef struct RequestChannelCloseReject {
    LogicalChannelNumber forwardLogicalChannelNumber;
    RequestChannelCloseReject_cause cause;
} RequestChannelCloseReject;

typedef struct RequestChannelCloseRelease {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelCloseRelease;

typedef struct MultiplexEntrySend {
    SequenceNumber sequenceNumber;
    PMultiplexEntrySend_multiplexEntryDescriptors multiplexEntryDescriptors;
} MultiplexEntrySend;

typedef struct MultiplexElement {
    MultiplexElement_type type;
    MultiplexElement_repeatCount repeatCount;
} MultiplexElement;

typedef struct MultiplexEntrySendAck {
    SequenceNumber sequenceNumber;
    MultiplexEntrySendAck_multiplexTableEntryNumber multiplexTableEntryNumber;
} MultiplexEntrySendAck;

typedef struct MultiplexEntryRejectionDescriptions {
    MultiplexTableEntryNumber multiplexTableEntryNumber;
    MultiplexEntryRejectionDescriptions_cause cause;
} MultiplexEntryRejectionDescriptions;

typedef struct MultiplexEntrySendRelease {
    MultiplexEntrySendRelease_multiplexTableEntryNumber multiplexTableEntryNumber;
} MultiplexEntrySendRelease;

typedef struct RequestMultiplexEntry {
    RequestMultiplexEntry_entryNumbers entryNumbers;
} RequestMultiplexEntry;

typedef struct RequestMultiplexEntryAck {
    RequestMultiplexEntryAck_entryNumbers entryNumbers;
} RequestMultiplexEntryAck;

typedef struct RequestMultiplexEntryRejectionDescriptions {
    MultiplexTableEntryNumber multiplexTableEntryNumber;
    RequestMultiplexEntryRejectionDescriptions_cause cause;
} RequestMultiplexEntryRejectionDescriptions;

typedef struct RequestMultiplexEntryRelease {
    RequestMultiplexEntryRelease_entryNumbers entryNumbers;
} RequestMultiplexEntryRelease;

typedef struct RequestMode {
    SequenceNumber sequenceNumber;
    PRequestMode_requestedModes requestedModes;
} RequestMode;

typedef struct RequestModeAck {
    SequenceNumber sequenceNumber;
    RequestModeAck_response response;
} RequestModeAck;

typedef struct RequestModeReject {
    SequenceNumber sequenceNumber;
    RequestModeReject_cause cause;
} RequestModeReject;

typedef struct RequestModeRelease {
    char placeholder;
} RequestModeRelease;

typedef struct V76ModeParameters {
    ASN1choice_t choice;
#   define V76ModeParameters_suspendResumewAddress_chosen 1
#   define V76ModeParameters_suspendResumewoAddress_chosen 2
} V76ModeParameters;

typedef struct H261VideoMode {
    H261VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoMode;

typedef struct H262VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H262VideoMode_profileAndLevel profileAndLevel;
#   define H262VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoMode_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoMode;

typedef struct IS11172VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoMode_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoMode;

typedef struct IS11172AudioMode {
    IS11172AudioMode_audioLayer audioLayer;
    IS11172AudioMode_audioSampling audioSampling;
    IS11172AudioMode_multichannelType multichannelType;
    ASN1uint16_t bitRate;
} IS11172AudioMode;

typedef struct IS13818AudioMode {
    IS13818AudioMode_audioLayer audioLayer;
    IS13818AudioMode_audioSampling audioSampling;
    IS13818AudioMode_multichannelType multichannelType;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioMode;

typedef struct G7231AnnexCMode {
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
    G7231AnnexCMode_g723AnnexCAudioMode g723AnnexCAudioMode;
} G7231AnnexCMode;

typedef struct RoundTripDelayRequest {
    SequenceNumber sequenceNumber;
} RoundTripDelayRequest;

typedef struct RoundTripDelayResponse {
    SequenceNumber sequenceNumber;
} RoundTripDelayResponse;

typedef struct MaintenanceLoopRequest {
    MaintenanceLoopRequest_type type;
} MaintenanceLoopRequest;

typedef struct MaintenanceLoopAck {
    MaintenanceLoopAck_type type;
} MaintenanceLoopAck;

typedef struct MaintenanceLoopReject {
    MaintenanceLoopReject_type type;
    MaintenanceLoopReject_cause cause;
} MaintenanceLoopReject;

typedef struct MaintenanceLoopOffCommand {
    char placeholder;
} MaintenanceLoopOffCommand;

typedef struct CommunicationModeCommand {
    PCommunicationModeCommand_communicationModeTable communicationModeTable;
} CommunicationModeCommand;

typedef struct CommunicationModeRequest {
    char placeholder;
} CommunicationModeRequest;

typedef struct CommunicationModeResponse {
    ASN1choice_t choice;
    union {
#	define communicationModeTable_chosen 1
	PCommunicationModeResponse_communicationModeTable communicationModeTable;
    } u;
} CommunicationModeResponse;

typedef struct Criteria {
    ASN1objectidentifier_t field;
    struct Criteria_value_value {
	ASN1uint32_t length;
	ASN1octet_t value[65535];
    } value;
} Criteria;

typedef struct TerminalLabel {
    McuNumber mcuNumber;
    TerminalNumber terminalNumber;
} TerminalLabel;

typedef struct RequestAllTerminalIDsResponse {
    PRequestAllTerminalIDsResponse_terminalInformation terminalInformation;
} RequestAllTerminalIDsResponse;

typedef struct TerminalInformation {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} TerminalInformation;

typedef struct RemoteMCRequest {
    ASN1choice_t choice;
#   define masterActivate_chosen 1
#   define slaveActivate_chosen 2
#   define deActivate_chosen 3
} RemoteMCRequest;

typedef struct RemoteMCResponse {
    ASN1choice_t choice;
    union {
#	define accept_chosen 1
#	define reject_chosen 2
	RemoteMCResponse_reject reject;
    } u;
} RemoteMCResponse;

typedef struct SendTerminalCapabilitySet {
    ASN1choice_t choice;
    union {
#	define specificRequest_chosen 1
	SendTerminalCapabilitySet_specificRequest specificRequest;
#	define genericRequest_chosen 2
    } u;
} SendTerminalCapabilitySet;

typedef struct FlowControlCommand {
    FlowControlCommand_scope scope;
    FlowControlCommand_restriction restriction;
} FlowControlCommand;

typedef struct SubstituteConferenceIDCommand {
    struct SubstituteConferenceIDCommand_conferenceIdentifier_conferenceIdentifier {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } conferenceIdentifier;
} SubstituteConferenceIDCommand;

typedef struct KeyProtectionMethod {
    ASN1bool_t secureChannel;
    ASN1bool_t sharedSecret;
    ASN1bool_t certProtectedKey;
} KeyProtectionMethod;

typedef struct EncryptionUpdateRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define keyProtectionMethod_present 0x80
    KeyProtectionMethod keyProtectionMethod;
} EncryptionUpdateRequest;

typedef struct H223MultiplexReconfiguration {
    ASN1choice_t choice;
    union {
#	define h223ModeChange_chosen 1
	H223MultiplexReconfiguration_h223ModeChange h223ModeChange;
#	define h223AnnexADoubleFlag_chosen 2
	H223MultiplexReconfiguration_h223AnnexADoubleFlag h223AnnexADoubleFlag;
    } u;
} H223MultiplexReconfiguration;

typedef struct FunctionNotSupported {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    FunctionNotSupported_cause cause;
#   define returnedFunction_present 0x80
    ASN1octetstring_t returnedFunction;
} FunctionNotSupported;

typedef struct ConferenceIndication {
    ASN1choice_t choice;
    union {
#	define sbeNumber_chosen 1
	ASN1uint16_t sbeNumber;
#	define terminalNumberAssign_chosen 2
	TerminalLabel terminalNumberAssign;
#	define terminalJoinedConference_chosen 3
	TerminalLabel terminalJoinedConference;
#	define terminalLeftConference_chosen 4
	TerminalLabel terminalLeftConference;
#	define seenByAtLeastOneOther_chosen 5
#	define cancelSeenByAtLeastOneOther_chosen 6
#	define seenByAll_chosen 7
#	define cancelSeenByAll_chosen 8
#	define terminalYouAreSeeing_chosen 9
	TerminalLabel terminalYouAreSeeing;
#	define requestForFloor_chosen 10
#	define withdrawChairToken_chosen 11
#	define floorRequested_chosen 12
	TerminalLabel floorRequested;
    } u;
} ConferenceIndication;

typedef struct JitterIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    JitterIndication_scope scope;
    ASN1uint16_t estimatedReceivedJitterMantissa;
    ASN1uint16_t estimatedReceivedJitterExponent;
#   define skippedFrameCount_present 0x80
    ASN1uint16_t skippedFrameCount;
#   define additionalDecoderBuffer_present 0x40
    ASN1uint32_t additionalDecoderBuffer;
} JitterIndication;

typedef struct H223SkewIndication {
    LogicalChannelNumber logicalChannelNumber1;
    LogicalChannelNumber logicalChannelNumber2;
    ASN1uint16_t skew;
} H223SkewIndication;

typedef struct H2250MaximumSkewIndication {
    LogicalChannelNumber logicalChannelNumber1;
    LogicalChannelNumber logicalChannelNumber2;
    ASN1uint16_t maximumSkew;
} H2250MaximumSkewIndication;

typedef struct VendorIdentification {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    NonStandardIdentifier vendor;
#   define productNumber_present 0x80
    struct VendorIdentification_productNumber_productNumber {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } productNumber;
#   define versionNumber_present 0x40
    struct VendorIdentification_versionNumber_versionNumber {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } versionNumber;
} VendorIdentification;

typedef struct NewATMVCIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t resourceID;
    ASN1uint16_t bitRate;
    ASN1bool_t bitRateLockedToPCRClock;
    ASN1bool_t bitRateLockedToNetworkClock;
    NewATMVCIndication_aal aal;
    NewATMVCIndication_multiplex multiplex;
#   define reverseParameters_present 0x80
    NewATMVCIndication_reverseParameters reverseParameters;
} NewATMVCIndication;

typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom {
    PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom next;
    RTPH263VideoRedundancyFrameMapping value;
} RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_Element;

typedef struct MultiplexElement_type_subElementList {
    ASN1uint32_t count;
    MultiplexElement value[255];
} MultiplexElement_type_subElementList;

typedef struct RequestAllTerminalIDsResponse_terminalInformation {
    PRequestAllTerminalIDsResponse_terminalInformation next;
    TerminalInformation value;
} RequestAllTerminalIDsResponse_terminalInformation_Element;

typedef struct ConferenceResponse_terminalCertificateResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ConferenceResponse_terminalCertificateResponse_terminalLabel_present 0x80
    TerminalLabel terminalLabel;
#   define certificateResponse_present 0x40
    struct ConferenceResponse_terminalCertificateResponse_certificateResponse_certificateResponse {
	ASN1uint32_t length;
	ASN1octet_t value[65535];
    } certificateResponse;
} ConferenceResponse_terminalCertificateResponse;

typedef struct ConferenceResponse_chairTokenOwnerResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_chairTokenOwnerResponse;

typedef struct ConferenceResponse_terminalListResponse {
    ASN1uint32_t count;
    TerminalLabel value[256];
} ConferenceResponse_terminalListResponse;

typedef struct ConferenceResponse_passwordResponse {
    TerminalLabel terminalLabel;
    Password password;
} ConferenceResponse_passwordResponse;

typedef struct ConferenceResponse_conferenceIDResponse {
    TerminalLabel terminalLabel;
    ConferenceID conferenceID;
} ConferenceResponse_conferenceIDResponse;

typedef struct ConferenceResponse_terminalIDResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_terminalIDResponse;

typedef struct ConferenceResponse_mCTerminalIDResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_mCTerminalIDResponse;

typedef struct ConferenceRequest_requestTerminalCertificate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ConferenceRequest_requestTerminalCertificate_terminalLabel_present 0x80
    TerminalLabel terminalLabel;
#   define certSelectionCriteria_present 0x40
    PCertSelectionCriteria certSelectionCriteria;
#   define sRandom_present 0x20
    ASN1uint32_t sRandom;
} ConferenceRequest_requestTerminalCertificate;

typedef struct RequestMultiplexEntryReject_rejectionDescriptions {
    ASN1uint32_t count;
    RequestMultiplexEntryRejectionDescriptions value[15];
} RequestMultiplexEntryReject_rejectionDescriptions;

typedef struct MultiplexEntrySendReject_rejectionDescriptions {
    ASN1uint32_t count;
    MultiplexEntryRejectionDescriptions value[15];
} MultiplexEntrySendReject_rejectionDescriptions;

typedef struct MultiplexEntryDescriptor_elementList {
    ASN1uint32_t count;
    MultiplexElement value[256];
} MultiplexEntryDescriptor_elementList;

typedef struct EncryptionSync_escrowentry {
    PEncryptionSync_escrowentry next;
    EscrowData value;
} EncryptionSync_escrowentry_Element;

typedef struct H223AL3MParameters_arqType {
    ASN1choice_t choice;
    union {
#	define H223AL3MParameters_arqType_noArq_chosen 1
#	define H223AL3MParameters_arqType_typeIArq_chosen 2
	H223AnnexCArqParameters typeIArq;
#	define H223AL3MParameters_arqType_typeIIArq_chosen 3
	H223AnnexCArqParameters typeIIArq;
    } u;
} H223AL3MParameters_arqType;

typedef struct H223AL1MParameters_arqType {
    ASN1choice_t choice;
    union {
#	define H223AL1MParameters_arqType_noArq_chosen 1
#	define H223AL1MParameters_arqType_typeIArq_chosen 2
	H223AnnexCArqParameters typeIArq;
#	define H223AL1MParameters_arqType_typeIIArq_chosen 3
	H223AnnexCArqParameters typeIIArq;
    } u;
} H223AL1MParameters_arqType;

typedef struct H263VideoModeCombos_h263VideoCoupledModes {
    ASN1uint32_t count;
    H263ModeComboFlags value[16];
} H263VideoModeCombos_h263VideoCoupledModes;

typedef struct H263Options_customPictureFormat {
    PH263Options_customPictureFormat next;
    CustomPictureFormat value;
} H263Options_customPictureFormat_Element;

typedef struct H263Options_customPictureClockFrequency {
    PH263Options_customPictureClockFrequency next;
    CustomPictureClockFrequency value;
} H263Options_customPictureClockFrequency_Element;

typedef struct MultipointCapability_mediaDistributionCapability {
    PMultipointCapability_mediaDistributionCapability next;
    MediaDistributionCapability value;
} MultipointCapability_mediaDistributionCapability_Element;

typedef struct TransportCapability_mediaChannelCapabilities {
    ASN1uint32_t count;
    MediaChannelCapability value[256];
} TransportCapability_mediaChannelCapabilities;

typedef struct H222Capability_vcCapability {
    PH222Capability_vcCapability next;
    VCCapability value;
} H222Capability_vcCapability_Element;

typedef struct CapabilityDescriptor_simultaneousCapabilities {
    PCapabilityDescriptor_simultaneousCapabilities next;
    AlternativeCapabilitySet value;
} CapabilityDescriptor_simultaneousCapabilities_Element;

typedef struct TerminalCapabilitySet_capabilityDescriptors {
    ASN1uint32_t count;
    CapabilityDescriptor value[256];
} TerminalCapabilitySet_capabilityDescriptors;

typedef struct NonStandardParameter {
    NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} NonStandardParameter;

typedef struct H223Capability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t transportWithI_frames;
    ASN1bool_t videoWithAL1;
    ASN1bool_t videoWithAL2;
    ASN1bool_t videoWithAL3;
    ASN1bool_t audioWithAL1;
    ASN1bool_t audioWithAL2;
    ASN1bool_t audioWithAL3;
    ASN1bool_t dataWithAL1;
    ASN1bool_t dataWithAL2;
    ASN1bool_t dataWithAL3;
    ASN1uint16_t maximumAl2SDUSize;
    ASN1uint16_t maximumAl3SDUSize;
    ASN1uint16_t maximumDelayJitter;
    H223Capability_h223MultiplexTableCapability h223MultiplexTableCapability;
#   define maxMUXPDUSizeCapability_present 0x80
    ASN1bool_t maxMUXPDUSizeCapability;
#   define nsrpSupport_present 0x40
    ASN1bool_t nsrpSupport;
#   define mobileOperationTransmitCapability_present 0x20
    H223Capability_mobileOperationTransmitCapability mobileOperationTransmitCapability;
#   define h223AnnexCCapability_present 0x10
    H223AnnexCCapability h223AnnexCCapability;
} H223Capability;

typedef struct V76Capability {
    ASN1bool_t suspendResumeCapabilitywAddress;
    ASN1bool_t suspendResumeCapabilitywoAddress;
    ASN1bool_t rejCapability;
    ASN1bool_t sREJCapability;
    ASN1bool_t mREJCapability;
    ASN1bool_t crc8bitCapability;
    ASN1bool_t crc16bitCapability;
    ASN1bool_t crc32bitCapability;
    ASN1bool_t uihCapability;
    ASN1uint16_t numOfDLCS;
    ASN1bool_t twoOctetAddressFieldCapability;
    ASN1bool_t loopBackTestCapability;
    ASN1uint16_t n401Capability;
    ASN1uint16_t maxWindowSizeCapability;
    V75Capability v75Capability;
} V76Capability;

typedef struct RSVPParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define qosMode_present 0x80
    QOSMode qosMode;
#   define tokenRate_present 0x40
    ASN1uint32_t tokenRate;
#   define bucketSize_present 0x20
    ASN1uint32_t bucketSize;
#   define peakRate_present 0x10
    ASN1uint32_t peakRate;
#   define minPoliced_present 0x8
    ASN1uint32_t minPoliced;
#   define maxPktSize_present 0x4
    ASN1uint32_t maxPktSize;
} RSVPParameters;

typedef struct QOSCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define QOSCapability_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
#   define rsvpParameters_present 0x40
    RSVPParameters rsvpParameters;
#   define atmParameters_present 0x20
    ATMParameters atmParameters;
} QOSCapability;

typedef struct TransportCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define TransportCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
#   define qOSCapabilities_present 0x40
    PTransportCapability_qOSCapabilities qOSCapabilities;
#   define mediaChannelCapabilities_present 0x20
    TransportCapability_mediaChannelCapabilities mediaChannelCapabilities;
} TransportCapability;

typedef struct RedundancyEncodingMethod {
    ASN1choice_t choice;
    union {
#	define RedundancyEncodingMethod_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define rtpAudioRedundancyEncoding_chosen 2
#	define rtpH263VideoRedundancyEncoding_chosen 3
	RTPH263VideoRedundancyEncoding rtpH263VideoRedundancyEncoding;
    } u;
} RedundancyEncodingMethod;

typedef struct H263Options {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t advancedIntraCodingMode;
    ASN1bool_t deblockingFilterMode;
    ASN1bool_t improvedPBFramesMode;
    ASN1bool_t unlimitedMotionVectors;
    ASN1bool_t fullPictureFreeze;
    ASN1bool_t partialPictureFreezeAndRelease;
    ASN1bool_t resizingPartPicFreezeAndRelease;
    ASN1bool_t fullPictureSnapshot;
    ASN1bool_t partialPictureSnapshot;
    ASN1bool_t videoSegmentTagging;
    ASN1bool_t progressiveRefinement;
    ASN1bool_t dynamicPictureResizingByFour;
    ASN1bool_t dynamicPictureResizingSixteenthPel;
    ASN1bool_t dynamicWarpingHalfPel;
    ASN1bool_t dynamicWarpingSixteenthPel;
    ASN1bool_t independentSegmentDecoding;
    ASN1bool_t slicesInOrder_NonRect;
    ASN1bool_t slicesInOrder_Rect;
    ASN1bool_t slicesNoOrder_NonRect;
    ASN1bool_t slicesNoOrder_Rect;
    ASN1bool_t alternateInterVLCMode;
    ASN1bool_t modifiedQuantizationMode;
    ASN1bool_t reducedResolutionUpdate;
#   define transparencyParameters_present 0x80
    TransparencyParameters transparencyParameters;
    ASN1bool_t separateVideoBackChannel;
#   define refPictureSelection_present 0x40
    RefPictureSelection refPictureSelection;
#   define customPictureClockFrequency_present 0x20
    PH263Options_customPictureClockFrequency customPictureClockFrequency;
#   define customPictureFormat_present 0x10
    PH263Options_customPictureFormat customPictureFormat;
#   define modeCombos_present 0x8
    PH263Options_modeCombos modeCombos;
} H263Options;

typedef struct H263VideoModeCombos {
    H263ModeComboFlags h263VideoUncoupledModes;
    H263VideoModeCombos_h263VideoCoupledModes h263VideoCoupledModes;
} H263VideoModeCombos;

typedef struct AudioCapability {
    ASN1choice_t choice;
    union {
#	define AudioCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioCapability_g711Alaw64k_chosen 2
	ASN1uint16_t g711Alaw64k;
#	define AudioCapability_g711Alaw56k_chosen 3
	ASN1uint16_t g711Alaw56k;
#	define AudioCapability_g711Ulaw64k_chosen 4
	ASN1uint16_t g711Ulaw64k;
#	define AudioCapability_g711Ulaw56k_chosen 5
	ASN1uint16_t g711Ulaw56k;
#	define AudioCapability_g722_64k_chosen 6
	ASN1uint16_t g722_64k;
#	define AudioCapability_g722_56k_chosen 7
	ASN1uint16_t g722_56k;
#	define AudioCapability_g722_48k_chosen 8
	ASN1uint16_t g722_48k;
#	define AudioCapability_g7231_chosen 9
	AudioCapability_g7231 g7231;
#	define AudioCapability_g728_chosen 10
	ASN1uint16_t g728;
#	define AudioCapability_g729_chosen 11
	ASN1uint16_t g729;
#	define AudioCapability_g729AnnexA_chosen 12
	ASN1uint16_t g729AnnexA;
#	define is11172AudioCapability_chosen 13
	IS11172AudioCapability is11172AudioCapability;
#	define is13818AudioCapability_chosen 14
	IS13818AudioCapability is13818AudioCapability;
#	define AudioCapability_g729wAnnexB_chosen 15
	ASN1uint16_t g729wAnnexB;
#	define AudioCapability_g729AnnexAwAnnexB_chosen 16
	ASN1uint16_t g729AnnexAwAnnexB;
#	define g7231AnnexCCapability_chosen 17
	G7231AnnexCCapability g7231AnnexCCapability;
#	define AudioCapability_gsmFullRate_chosen 18
	GSMAudioCapability gsmFullRate;
#	define AudioCapability_gsmHalfRate_chosen 19
	GSMAudioCapability gsmHalfRate;
#	define AudioCapability_gsmEnhancedFullRate_chosen 20
	GSMAudioCapability gsmEnhancedFullRate;
    } u;
} AudioCapability;

typedef struct CompressionType {
    ASN1choice_t choice;
    union {
#	define v42bis_chosen 1
	V42bis v42bis;
    } u;
} CompressionType;

typedef struct MediaEncryptionAlgorithm {
    ASN1choice_t choice;
    union {
#	define MediaEncryptionAlgorithm_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define algorithm_chosen 2
	ASN1objectidentifier_t algorithm;
    } u;
} MediaEncryptionAlgorithm;

typedef struct AuthenticationCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define AuthenticationCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
} AuthenticationCapability;

typedef struct IntegrityCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define IntegrityCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
} IntegrityCapability;

typedef struct H223AL1MParameters {
    H223AL1MParameters_transferMode transferMode;
    H223AL1MParameters_headerFEC headerFEC;
    H223AL1MParameters_crcLength crcLength;
    H223AL1MParameters_fecType fecType;
    H223AL1MParameters_arqType arqType;
    ASN1bool_t alpduInterleaving;
    ASN1bool_t alsduSegmentation;
} H223AL1MParameters;

typedef struct H223AL3MParameters {
    H223AL3MParameters_headerFormat headerFormat;
    H223AL3MParameters_crcLength crcLength;
    H223AL3MParameters_fecType fecType;
    H223AL3MParameters_arqType arqType;
    ASN1bool_t alpduInterleaving;
} H223AL3MParameters;

typedef struct V76HDLCParameters {
    CRCLength crcLength;
    ASN1uint16_t n401;
    ASN1bool_t loopbackTestProcedure;
} V76HDLCParameters;

typedef struct UnicastAddress {
    ASN1choice_t choice;
    union {
#	define UnicastAddress_iPAddress_chosen 1
	UnicastAddress_iPAddress iPAddress;
#	define iPXAddress_chosen 2
	UnicastAddress_iPXAddress iPXAddress;
#	define UnicastAddress_iP6Address_chosen 3
	UnicastAddress_iP6Address iP6Address;
#	define netBios_chosen 4
	struct UnicastAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define iPSourceRouteAddress_chosen 5
	UnicastAddress_iPSourceRouteAddress iPSourceRouteAddress;
#	define UnicastAddress_nsap_chosen 6
	struct UnicastAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define UnicastAddress_nonStandardAddress_chosen 7
	NonStandardParameter nonStandardAddress;
    } u;
} UnicastAddress;

typedef struct MulticastAddress {
    ASN1choice_t choice;
    union {
#	define MulticastAddress_iPAddress_chosen 1
	MulticastAddress_iPAddress iPAddress;
#	define MulticastAddress_iP6Address_chosen 2
	MulticastAddress_iP6Address iP6Address;
#	define MulticastAddress_nsap_chosen 3
	struct MulticastAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define MulticastAddress_nonStandardAddress_chosen 4
	NonStandardParameter nonStandardAddress;
    } u;
} MulticastAddress;

typedef struct EncryptionSync {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define EncryptionSync_nonStandard_present 0x80
    NonStandardParameter nonStandard;
    ASN1uint16_t synchFlag;
    struct EncryptionSync_h235Key_h235Key {
	ASN1uint32_t length;
	ASN1octet_t value[65535];
    } h235Key;
#   define escrowentry_present 0x40
    PEncryptionSync_escrowentry escrowentry;
} EncryptionSync;

typedef struct RequestChannelClose {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
#   define qosCapability_present 0x80
    QOSCapability qosCapability;
#   define RequestChannelClose_reason_present 0x40
    RequestChannelClose_reason reason;
} RequestChannelClose;

typedef struct MultiplexEntryDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    MultiplexTableEntryNumber multiplexTableEntryNumber;
#   define elementList_present 0x80
    MultiplexEntryDescriptor_elementList elementList;
} MultiplexEntryDescriptor;

typedef struct MultiplexEntrySendReject {
    SequenceNumber sequenceNumber;
    MultiplexEntrySendReject_rejectionDescriptions rejectionDescriptions;
} MultiplexEntrySendReject;

typedef struct RequestMultiplexEntryReject {
    RequestMultiplexEntryReject_entryNumbers entryNumbers;
    RequestMultiplexEntryReject_rejectionDescriptions rejectionDescriptions;
} RequestMultiplexEntryReject;

typedef struct H263VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H263VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
#   define H263VideoMode_errorCompensation_present 0x80
    ASN1bool_t errorCompensation;
#   define H263VideoMode_enhancementLayerInfo_present 0x40
    EnhancementLayerInfo enhancementLayerInfo;
#   define H263VideoMode_h263Options_present 0x20
    H263Options h263Options;
} H263VideoMode;

typedef struct AudioMode {
    ASN1choice_t choice;
    union {
#	define AudioMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioMode_g711Alaw64k_chosen 2
#	define AudioMode_g711Alaw56k_chosen 3
#	define AudioMode_g711Ulaw64k_chosen 4
#	define AudioMode_g711Ulaw56k_chosen 5
#	define AudioMode_g722_64k_chosen 6
#	define AudioMode_g722_56k_chosen 7
#	define AudioMode_g722_48k_chosen 8
#	define AudioMode_g728_chosen 9
#	define AudioMode_g729_chosen 10
#	define AudioMode_g729AnnexA_chosen 11
#	define AudioMode_g7231_chosen 12
	AudioMode_g7231 g7231;
#	define is11172AudioMode_chosen 13
	IS11172AudioMode is11172AudioMode;
#	define is13818AudioMode_chosen 14
	IS13818AudioMode is13818AudioMode;
#	define AudioMode_g729wAnnexB_chosen 15
	ASN1uint16_t g729wAnnexB;
#	define AudioMode_g729AnnexAwAnnexB_chosen 16
	ASN1uint16_t g729AnnexAwAnnexB;
#	define g7231AnnexCMode_chosen 17
	G7231AnnexCMode g7231AnnexCMode;
#	define AudioMode_gsmFullRate_chosen 18
	GSMAudioCapability gsmFullRate;
#	define AudioMode_gsmHalfRate_chosen 19
	GSMAudioCapability gsmHalfRate;
#	define AudioMode_gsmEnhancedFullRate_chosen 20
	GSMAudioCapability gsmEnhancedFullRate;
    } u;
} AudioMode;

typedef struct EncryptionMode {
    ASN1choice_t choice;
    union {
#	define EncryptionMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h233Encryption_chosen 2
    } u;
} EncryptionMode;

typedef struct ConferenceRequest {
    ASN1choice_t choice;
    union {
#	define terminalListRequest_chosen 1
#	define makeMeChair_chosen 2
#	define cancelMakeMeChair_chosen 3
#	define dropTerminal_chosen 4
	TerminalLabel dropTerminal;
#	define requestTerminalID_chosen 5
	TerminalLabel requestTerminalID;
#	define enterH243Password_chosen 6
#	define enterH243TerminalID_chosen 7
#	define enterH243ConferenceID_chosen 8
#	define enterExtensionAddress_chosen 9
#	define requestChairTokenOwner_chosen 10
#	define requestTerminalCertificate_chosen 11
	ConferenceRequest_requestTerminalCertificate requestTerminalCertificate;
#	define ConferenceRequest_broadcastMyLogicalChannel_chosen 12
	LogicalChannelNumber broadcastMyLogicalChannel;
#	define ConferenceRequest_makeTerminalBroadcaster_chosen 13
	TerminalLabel makeTerminalBroadcaster;
#	define ConferenceRequest_sendThisSource_chosen 14
	TerminalLabel sendThisSource;
#	define requestAllTerminalIDs_chosen 15
#	define remoteMCRequest_chosen 16
	RemoteMCRequest remoteMCRequest;
    } u;
} ConferenceRequest;

typedef struct CertSelectionCriteria {
    PCertSelectionCriteria next;
    Criteria value;
} CertSelectionCriteria_Element;

typedef struct ConferenceResponse {
    ASN1choice_t choice;
    union {
#	define mCTerminalIDResponse_chosen 1
	ConferenceResponse_mCTerminalIDResponse mCTerminalIDResponse;
#	define terminalIDResponse_chosen 2
	ConferenceResponse_terminalIDResponse terminalIDResponse;
#	define conferenceIDResponse_chosen 3
	ConferenceResponse_conferenceIDResponse conferenceIDResponse;
#	define passwordResponse_chosen 4
	ConferenceResponse_passwordResponse passwordResponse;
#	define terminalListResponse_chosen 5
	ConferenceResponse_terminalListResponse terminalListResponse;
#	define videoCommandReject_chosen 6
#	define terminalDropReject_chosen 7
#	define makeMeChairResponse_chosen 8
	ConferenceResponse_makeMeChairResponse makeMeChairResponse;
#	define extensionAddressResponse_chosen 9
	ConferenceResponse_extensionAddressResponse extensionAddressResponse;
#	define chairTokenOwnerResponse_chosen 10
	ConferenceResponse_chairTokenOwnerResponse chairTokenOwnerResponse;
#	define terminalCertificateResponse_chosen 11
	ConferenceResponse_terminalCertificateResponse terminalCertificateResponse;
#	define broadcastMyLogicalChannelResponse_chosen 12
	ConferenceResponse_broadcastMyLogicalChannelResponse broadcastMyLogicalChannelResponse;
#	define makeTerminalBroadcasterResponse_chosen 13
	ConferenceResponse_makeTerminalBroadcasterResponse makeTerminalBroadcasterResponse;
#	define sendThisSourceResponse_chosen 14
	ConferenceResponse_sendThisSourceResponse sendThisSourceResponse;
#	define requestAllTerminalIDsResponse_chosen 15
	RequestAllTerminalIDsResponse requestAllTerminalIDsResponse;
#	define remoteMCResponse_chosen 16
	RemoteMCResponse remoteMCResponse;
    } u;
} ConferenceResponse;

typedef struct EndSessionCommand {
    ASN1choice_t choice;
    union {
#	define EndSessionCommand_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define disconnect_chosen 2
#	define gstnOptions_chosen 3
	EndSessionCommand_gstnOptions gstnOptions;
#	define isdnOptions_chosen 4
	EndSessionCommand_isdnOptions isdnOptions;
    } u;
} EndSessionCommand;

typedef struct ConferenceCommand {
    ASN1choice_t choice;
    union {
#	define ConferenceCommand_broadcastMyLogicalChannel_chosen 1
	LogicalChannelNumber broadcastMyLogicalChannel;
#	define cancelBroadcastMyLogicalChannel_chosen 2
	LogicalChannelNumber cancelBroadcastMyLogicalChannel;
#	define ConferenceCommand_makeTerminalBroadcaster_chosen 3
	TerminalLabel makeTerminalBroadcaster;
#	define cancelMakeTerminalBroadcaster_chosen 4
#	define ConferenceCommand_sendThisSource_chosen 5
	TerminalLabel sendThisSource;
#	define cancelSendThisSource_chosen 6
#	define dropConference_chosen 7
#	define substituteConferenceIDCommand_chosen 8
	SubstituteConferenceIDCommand substituteConferenceIDCommand;
    } u;
} ConferenceCommand;

typedef struct UserInputIndication_userInputSupportIndication {
    ASN1choice_t choice;
    union {
#	define UserInputIndication_userInputSupportIndication_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define UserInputIndication_userInputSupportIndication_basicString_chosen 2
#	define UserInputIndication_userInputSupportIndication_iA5String_chosen 3
#	define UserInputIndication_userInputSupportIndication_generalString_chosen 4
    } u;
} UserInputIndication_userInputSupportIndication;

typedef struct MiscellaneousIndication_type {
    ASN1choice_t choice;
    union {
#	define logicalChannelActive_chosen 1
#	define logicalChannelInactive_chosen 2
#	define multipointConference_chosen 3
#	define cancelMultipointConference_chosen 4
#	define multipointZeroComm_chosen 5
#	define cancelMultipointZeroComm_chosen 6
#	define multipointSecondaryStatus_chosen 7
#	define cancelMultipointSecondaryStatus_chosen 8
#	define videoIndicateReadyToActivate_chosen 9
#	define MiscellaneousIndication_type_videoTemporalSpatialTradeOff_chosen 10
	ASN1uint16_t videoTemporalSpatialTradeOff;
#	define videoNotDecodedMBs_chosen 11
	MiscellaneousIndication_type_videoNotDecodedMBs videoNotDecodedMBs;
#	define transportCapability_chosen 12
	TransportCapability transportCapability;
    } u;
} MiscellaneousIndication_type;

typedef struct MiscellaneousCommand_type {
    ASN1choice_t choice;
    union {
#	define equaliseDelay_chosen 1
#	define zeroDelay_chosen 2
#	define multipointModeCommand_chosen 3
#	define cancelMultipointModeCommand_chosen 4
#	define videoFreezePicture_chosen 5
#	define videoFastUpdatePicture_chosen 6
#	define videoFastUpdateGOB_chosen 7
	MiscellaneousCommand_type_videoFastUpdateGOB videoFastUpdateGOB;
#	define MiscellaneousCommand_type_videoTemporalSpatialTradeOff_chosen 8
	ASN1uint16_t videoTemporalSpatialTradeOff;
#	define videoSendSyncEveryGOB_chosen 9
#	define videoSendSyncEveryGOBCancel_chosen 10
#	define videoFastUpdateMB_chosen 11
	MiscellaneousCommand_type_videoFastUpdateMB videoFastUpdateMB;
#	define maxH223MUXPDUsize_chosen 12
	ASN1uint16_t maxH223MUXPDUsize;
#	define encryptionUpdate_chosen 13
	EncryptionSync encryptionUpdate;
#	define encryptionUpdateRequest_chosen 14
	EncryptionUpdateRequest encryptionUpdateRequest;
#	define switchReceiveMediaOff_chosen 15
#	define switchReceiveMediaOn_chosen 16
#	define progressiveRefinementStart_chosen 17
	MiscellaneousCommand_type_progressiveRefinementStart progressiveRefinementStart;
#	define progressiveRefinementAbortOne_chosen 18
#	define progressiveRefinementAbortContinuous_chosen 19
    } u;
} MiscellaneousCommand_type;

typedef struct EncryptionCommand_encryptionAlgorithmID {
    SequenceNumber h233AlgorithmIdentifier;
    NonStandardParameter associatedAlgorithm;
} EncryptionCommand_encryptionAlgorithmID;

typedef struct CommunicationModeTableEntry_nonStandard {
    PCommunicationModeTableEntry_nonStandard next;
    NonStandardParameter value;
} CommunicationModeTableEntry_nonStandard_Element;

typedef struct RedundancyEncodingMode_secondaryEncoding {
    ASN1choice_t choice;
    union {
#	define RedundancyEncodingMode_secondaryEncoding_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define RedundancyEncodingMode_secondaryEncoding_audioData_chosen 2
	AudioMode audioData;
    } u;
} RedundancyEncodingMode_secondaryEncoding;

typedef struct H223ModeParameters_adaptationLayerType {
    ASN1choice_t choice;
    union {
#	define H223ModeParameters_adaptationLayerType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223ModeParameters_adaptationLayerType_al1Framed_chosen 2
#	define H223ModeParameters_adaptationLayerType_al1NotFramed_chosen 3
#	define H223ModeParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen 4
#	define H223ModeParameters_adaptationLayerType_al2WithSequenceNumbers_chosen 5
#	define H223ModeParameters_adaptationLayerType_al3_chosen 6
	H223ModeParameters_adaptationLayerType_al3 al3;
#	define H223ModeParameters_adaptationLayerType_al1M_chosen 7
	H223AL1MParameters al1M;
#	define H223ModeParameters_adaptationLayerType_al2M_chosen 8
	H223AL2MParameters al2M;
#	define H223ModeParameters_adaptationLayerType_al3M_chosen 9
	H223AL3MParameters al3M;
    } u;
} H223ModeParameters_adaptationLayerType;

typedef struct MultiplexEntrySend_multiplexEntryDescriptors {
    PMultiplexEntrySend_multiplexEntryDescriptors next;
    MultiplexEntryDescriptor value;
} MultiplexEntrySend_multiplexEntryDescriptors_Element;

typedef struct H2250LogicalChannelAckParameters_nonStandard {
    PH2250LogicalChannelAckParameters_nonStandard next;
    NonStandardParameter value;
} H2250LogicalChannelAckParameters_nonStandard_Element;

typedef struct H2250LogicalChannelParameters_nonStandard {
    PH2250LogicalChannelParameters_nonStandard next;
    NonStandardParameter value;
} H2250LogicalChannelParameters_nonStandard_Element;

typedef struct H223LogicalChannelParameters_adaptationLayerType {
    ASN1choice_t choice;
    union {
#	define H223LogicalChannelParameters_adaptationLayerType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223LogicalChannelParameters_adaptationLayerType_al1Framed_chosen 2
#	define H223LogicalChannelParameters_adaptationLayerType_al1NotFramed_chosen 3
#	define H223LogicalChannelParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen 4
#	define H223LogicalChannelParameters_adaptationLayerType_al2WithSequenceNumbers_chosen 5
#	define H223LogicalChannelParameters_adaptationLayerType_al3_chosen 6
	H223LogicalChannelParameters_adaptationLayerType_al3 al3;
#	define H223LogicalChannelParameters_adaptationLayerType_al1M_chosen 7
	H223AL1MParameters al1M;
#	define H223LogicalChannelParameters_adaptationLayerType_al2M_chosen 8
	H223AL2MParameters al2M;
#	define H223LogicalChannelParameters_adaptationLayerType_al3M_chosen 9
	H223AL3MParameters al3M;
    } u;
} H223LogicalChannelParameters_adaptationLayerType;

typedef struct ConferenceCapability_nonStandardData {
    PConferenceCapability_nonStandardData next;
    NonStandardParameter value;
} ConferenceCapability_nonStandardData_Element;

typedef struct UserInputCapability_nonStandard {
    ASN1uint32_t count;
    NonStandardParameter value[16];
} UserInputCapability_nonStandard;

typedef struct DataProtocolCapability_v76wCompression {
    ASN1choice_t choice;
    union {
#	define transmitCompression_chosen 1
	CompressionType transmitCompression;
#	define receiveCompression_chosen 2
	CompressionType receiveCompression;
#	define transmitAndReceiveCompression_chosen 3
	CompressionType transmitAndReceiveCompression;
    } u;
} DataProtocolCapability_v76wCompression;

typedef struct H263Options_modeCombos {
    PH263Options_modeCombos next;
    H263VideoModeCombos value;
} H263Options_modeCombos_Element;

typedef struct TransportCapability_qOSCapabilities {
    PTransportCapability_qOSCapabilities next;
    QOSCapability value;
} TransportCapability_qOSCapabilities_Element;

typedef struct NonStandardMessage {
    NonStandardParameter nonStandardData;
} NonStandardMessage;

typedef struct H2250Capability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t maximumAudioDelayJitter;
    MultipointCapability receiveMultipointCapability;
    MultipointCapability transmitMultipointCapability;
    MultipointCapability receiveAndTransmitMultipointCapability;
    H2250Capability_mcCapability mcCapability;
    ASN1bool_t rtcpVideoControlCapability;
    MediaPacketizationCapability mediaPacketizationCapability;
#   define H2250Capability_transportCapability_present 0x80
    TransportCapability transportCapability;
#   define redundancyEncodingCapability_present 0x40
    PH2250Capability_redundancyEncodingCapability redundancyEncodingCapability;
#   define logicalChannelSwitchingCapability_present 0x20
    ASN1bool_t logicalChannelSwitchingCapability;
#   define t120DynamicPortCapability_present 0x10
    ASN1bool_t t120DynamicPortCapability;
} H2250Capability;

typedef struct RedundancyEncodingCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RedundancyEncodingMethod redundancyEncodingMethod;
    CapabilityTableEntryNumber primaryEncoding;
#   define RedundancyEncodingCapability_secondaryEncoding_present 0x80
    PRedundancyEncodingCapability_secondaryEncoding secondaryEncoding;
} RedundancyEncodingCapability;

typedef struct H263VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H263VideoCapability_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define H263VideoCapability_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define H263VideoCapability_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define H263VideoCapability_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define H263VideoCapability_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
    ASN1uint32_t maxBitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
    ASN1bool_t temporalSpatialTradeOffCapability;
#   define hrd_B_present 0x4
    ASN1uint32_t hrd_B;
#   define bppMaxKb_present 0x2
    ASN1uint16_t bppMaxKb;
#   define H263VideoCapability_slowSqcifMPI_present 0x8000
    ASN1uint16_t slowSqcifMPI;
#   define H263VideoCapability_slowQcifMPI_present 0x4000
    ASN1uint16_t slowQcifMPI;
#   define H263VideoCapability_slowCifMPI_present 0x2000
    ASN1uint16_t slowCifMPI;
#   define H263VideoCapability_slowCif4MPI_present 0x1000
    ASN1uint16_t slowCif4MPI;
#   define H263VideoCapability_slowCif16MPI_present 0x800
    ASN1uint16_t slowCif16MPI;
#   define H263VideoCapability_errorCompensation_present 0x400
    ASN1bool_t errorCompensation;
#   define H263VideoCapability_enhancementLayerInfo_present 0x200
    EnhancementLayerInfo enhancementLayerInfo;
#   define H263VideoCapability_h263Options_present 0x100
    H263Options h263Options;
} H263VideoCapability;

typedef struct EnhancementOptions {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define EnhancementOptions_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define EnhancementOptions_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define EnhancementOptions_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define EnhancementOptions_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define EnhancementOptions_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
    ASN1uint32_t maxBitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t temporalSpatialTradeOffCapability;
#   define EnhancementOptions_slowSqcifMPI_present 0x4
    ASN1uint16_t slowSqcifMPI;
#   define EnhancementOptions_slowQcifMPI_present 0x2
    ASN1uint16_t slowQcifMPI;
#   define EnhancementOptions_slowCifMPI_present 0x1
    ASN1uint16_t slowCifMPI;
#   define EnhancementOptions_slowCif4MPI_present 0x8000
    ASN1uint16_t slowCif4MPI;
#   define EnhancementOptions_slowCif16MPI_present 0x4000
    ASN1uint16_t slowCif16MPI;
    ASN1bool_t errorCompensation;
#   define EnhancementOptions_h263Options_present 0x2000
    H263Options h263Options;
} EnhancementOptions;

typedef struct DataProtocolCapability {
    ASN1choice_t choice;
    union {
#	define DataProtocolCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define v14buffered_chosen 2
#	define v42lapm_chosen 3
#	define hdlcFrameTunnelling_chosen 4
#	define h310SeparateVCStack_chosen 5
#	define h310SingleVCStack_chosen 6
#	define transparent_chosen 7
#	define segmentationAndReassembly_chosen 8
#	define hdlcFrameTunnelingwSAR_chosen 9
#	define v120_chosen 10
#	define separateLANStack_chosen 11
#	define v76wCompression_chosen 12
	DataProtocolCapability_v76wCompression v76wCompression;
    } u;
} DataProtocolCapability;

typedef struct EncryptionAuthenticationAndIntegrity {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define encryptionCapability_present 0x80
    PEncryptionCapability encryptionCapability;
#   define authenticationCapability_present 0x40
    AuthenticationCapability authenticationCapability;
#   define integrityCapability_present 0x20
    IntegrityCapability integrityCapability;
} EncryptionAuthenticationAndIntegrity;

typedef struct EncryptionCapability {
    PEncryptionCapability next;
    MediaEncryptionAlgorithm value;
} EncryptionCapability_Element;

typedef struct UserInputCapability {
    ASN1choice_t choice;
    union {
#	define UserInputCapability_nonStandard_chosen 1
	UserInputCapability_nonStandard nonStandard;
#	define UserInputCapability_basicString_chosen 2
#	define UserInputCapability_iA5String_chosen 3
#	define UserInputCapability_generalString_chosen 4
#	define dtmf_chosen 5
#	define hookflash_chosen 6
    } u;
} UserInputCapability;

typedef struct H223LogicalChannelParameters {
    H223LogicalChannelParameters_adaptationLayerType adaptationLayerType;
    ASN1bool_t segmentableFlag;
} H223LogicalChannelParameters;

typedef struct V76LogicalChannelParameters {
    V76HDLCParameters hdlcParameters;
    V76LogicalChannelParameters_suspendResume suspendResume;
    ASN1bool_t uIH;
    V76LogicalChannelParameters_mode mode;
    V75Parameters v75Parameters;
} V76LogicalChannelParameters;

typedef struct H245TransportAddress {
    ASN1choice_t choice;
    union {
#	define unicastAddress_chosen 1
	UnicastAddress unicastAddress;
#	define multicastAddress_chosen 2
	MulticastAddress multicastAddress;
    } u;
} H245TransportAddress;

typedef struct H2250LogicalChannelAckParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H2250LogicalChannelAckParameters_nonStandard_present 0x80
    PH2250LogicalChannelAckParameters_nonStandard nonStandard;
#   define sessionID_present 0x40
    ASN1uint16_t sessionID;
#   define H2250LogicalChannelAckParameters_mediaChannel_present 0x20
    H245TransportAddress mediaChannel;
#   define H2250LogicalChannelAckParameters_mediaControlChannel_present 0x10
    H245TransportAddress mediaControlChannel;
#   define H2250LogicalChannelAckParameters_dynamicRTPPayloadType_present 0x8
    ASN1uint16_t dynamicRTPPayloadType;
#   define flowControlToZero_present 0x8000
    ASN1bool_t flowControlToZero;
} H2250LogicalChannelAckParameters;

typedef struct H223ModeParameters {
    H223ModeParameters_adaptationLayerType adaptationLayerType;
    ASN1bool_t segmentableFlag;
} H223ModeParameters;

typedef struct RedundancyEncodingMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RedundancyEncodingMethod redundancyEncodingMethod;
#   define RedundancyEncodingMode_secondaryEncoding_present 0x80
    RedundancyEncodingMode_secondaryEncoding secondaryEncoding;
} RedundancyEncodingMode;

typedef struct VideoMode {
    ASN1choice_t choice;
    union {
#	define VideoMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoMode_chosen 2
	H261VideoMode h261VideoMode;
#	define h262VideoMode_chosen 3
	H262VideoMode h262VideoMode;
#	define h263VideoMode_chosen 4
	H263VideoMode h263VideoMode;
#	define is11172VideoMode_chosen 5
	IS11172VideoMode is11172VideoMode;
    } u;
} VideoMode;

typedef struct EncryptionCommand {
    ASN1choice_t choice;
    union {
#	define encryptionSE_chosen 1
	ASN1octetstring_t encryptionSE;
#	define encryptionIVRequest_chosen 2
#	define encryptionAlgorithmID_chosen 3
	EncryptionCommand_encryptionAlgorithmID encryptionAlgorithmID;
    } u;
} EncryptionCommand;

typedef struct MiscellaneousCommand {
    LogicalChannelNumber logicalChannelNumber;
    MiscellaneousCommand_type type;
} MiscellaneousCommand;

typedef struct MiscellaneousIndication {
    LogicalChannelNumber logicalChannelNumber;
    MiscellaneousIndication_type type;
} MiscellaneousIndication;

typedef struct MCLocationIndication {
    H245TransportAddress signalAddress;
} MCLocationIndication;

typedef struct UserInputIndication {
    ASN1choice_t choice;
    union {
#	define UserInputIndication_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define alphanumeric_chosen 2
	ASN1ztcharstring_t alphanumeric;
#	define userInputSupportIndication_chosen 3
	UserInputIndication_userInputSupportIndication userInputSupportIndication;
#	define signal_chosen 4
	UserInputIndication_signal signal;
#	define signalUpdate_chosen 5
	UserInputIndication_signalUpdate signalUpdate;
    } u;
} UserInputIndication;

typedef struct DataApplicationCapability_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataApplicationCapability_application_nlpid;

typedef struct DataApplicationCapability_application_t84 {
    DataProtocolCapability t84Protocol;
    T84Profile t84Profile;
} DataApplicationCapability_application_t84;

typedef struct DataMode_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataMode_application_nlpid;

typedef struct DataMode_application {
    ASN1choice_t choice;
    union {
#	define DataMode_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataMode_application_t120_chosen 2
	DataProtocolCapability t120;
#	define DataMode_application_dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataMode_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataMode_application_t84_chosen 5
	DataProtocolCapability t84;
#	define DataMode_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataMode_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataMode_application_nlpid_chosen 8
	DataMode_application_nlpid nlpid;
#	define DataMode_application_dsvdControl_chosen 9
#	define DataMode_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
#	define DataMode_application_t30fax_chosen 11
	DataProtocolCapability t30fax;
#	define DataMode_application_t140_chosen 12
	DataProtocolCapability t140;
    } u;
} DataMode_application;

typedef struct OpenLogicalChannelAck_forwardMultiplexAckParameters {
    ASN1choice_t choice;
    union {
#	define h2250LogicalChannelAckParameters_chosen 1
	H2250LogicalChannelAckParameters h2250LogicalChannelAckParameters;
    } u;
} OpenLogicalChannelAck_forwardMultiplexAckParameters;

typedef struct NetworkAccessParameters_networkAddress {
    ASN1choice_t choice;
    union {
#	define q2931Address_chosen 1
	Q2931Address q2931Address;
#	define e164Address_chosen 2
	ASN1char_t e164Address[129];
#	define localAreaAddress_chosen 3
	H245TransportAddress localAreaAddress;
    } u;
} NetworkAccessParameters_networkAddress;

typedef struct DataApplicationCapability_application {
    ASN1choice_t choice;
    union {
#	define DataApplicationCapability_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataApplicationCapability_application_t120_chosen 2
	DataProtocolCapability t120;
#	define DataApplicationCapability_application_dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataApplicationCapability_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataApplicationCapability_application_t84_chosen 5
	DataApplicationCapability_application_t84 t84;
#	define DataApplicationCapability_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataApplicationCapability_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataApplicationCapability_application_nlpid_chosen 8
	DataApplicationCapability_application_nlpid nlpid;
#	define DataApplicationCapability_application_dsvdControl_chosen 9
#	define DataApplicationCapability_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
#	define DataApplicationCapability_application_t30fax_chosen 11
	DataProtocolCapability t30fax;
#	define DataApplicationCapability_application_t140_chosen 12
	DataProtocolCapability t140;
    } u;
} DataApplicationCapability_application;

typedef struct EnhancementLayerInfo_spatialEnhancement {
    PEnhancementLayerInfo_spatialEnhancement next;
    EnhancementOptions value;
} EnhancementLayerInfo_spatialEnhancement_Element;

typedef struct EnhancementLayerInfo_snrEnhancement {
    PEnhancementLayerInfo_snrEnhancement next;
    EnhancementOptions value;
} EnhancementLayerInfo_snrEnhancement_Element;

typedef struct H2250Capability_redundancyEncodingCapability {
    PH2250Capability_redundancyEncodingCapability next;
    RedundancyEncodingCapability value;
} H2250Capability_redundancyEncodingCapability_Element;

typedef struct CommandMessage {
    ASN1choice_t choice;
    union {
#	define CommandMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define maintenanceLoopOffCommand_chosen 2
	MaintenanceLoopOffCommand maintenanceLoopOffCommand;
#	define sendTerminalCapabilitySet_chosen 3
	SendTerminalCapabilitySet sendTerminalCapabilitySet;
#	define encryptionCommand_chosen 4
	EncryptionCommand encryptionCommand;
#	define flowControlCommand_chosen 5
	FlowControlCommand flowControlCommand;
#	define endSessionCommand_chosen 6
	EndSessionCommand endSessionCommand;
#	define miscellaneousCommand_chosen 7
	MiscellaneousCommand miscellaneousCommand;
#	define communicationModeCommand_chosen 8
	CommunicationModeCommand communicationModeCommand;
#	define conferenceCommand_chosen 9
	ConferenceCommand conferenceCommand;
#	define h223MultiplexReconfiguration_chosen 10
	H223MultiplexReconfiguration h223MultiplexReconfiguration;
    } u;
} CommandMessage;

typedef struct H235SecurityCapability {
    EncryptionAuthenticationAndIntegrity encryptionAuthenticationAndIntegrity;
    CapabilityTableEntryNumber mediaCapability;
} H235SecurityCapability;

typedef struct MultiplexCapability {
    ASN1choice_t choice;
    union {
#	define MultiplexCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h222Capability_chosen 2
	H222Capability h222Capability;
#	define h223Capability_chosen 3
	H223Capability h223Capability;
#	define v76Capability_chosen 4
	V76Capability v76Capability;
#	define h2250Capability_chosen 5
	H2250Capability h2250Capability;
    } u;
} MultiplexCapability;

typedef struct VideoCapability {
    ASN1choice_t choice;
    union {
#	define VideoCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoCapability_chosen 2
	H261VideoCapability h261VideoCapability;
#	define h262VideoCapability_chosen 3
	H262VideoCapability h262VideoCapability;
#	define h263VideoCapability_chosen 4
	H263VideoCapability h263VideoCapability;
#	define is11172VideoCapability_chosen 5
	IS11172VideoCapability is11172VideoCapability;
    } u;
} VideoCapability;

typedef struct BEnhancementParameters {
    EnhancementOptions enhancementOptions;
    ASN1uint16_t numberOfBPictures;
} BEnhancementParameters;

typedef struct DataApplicationCapability {
    DataApplicationCapability_application application;
    ASN1uint32_t maxBitRate;
} DataApplicationCapability;

typedef struct NetworkAccessParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define distribution_present 0x80
    NetworkAccessParameters_distribution distribution;
    NetworkAccessParameters_networkAddress networkAddress;
    ASN1bool_t associateConference;
#   define externalReference_present 0x40
    struct NetworkAccessParameters_externalReference_externalReference {
	ASN1uint32_t length;
	ASN1octet_t value[255];
    } externalReference;
#   define t120SetupProcedure_present 0x8000
    NetworkAccessParameters_t120SetupProcedure t120SetupProcedure;
} NetworkAccessParameters;

typedef struct H2250ModeParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define redundancyEncodingMode_present 0x80
    RedundancyEncodingMode redundancyEncodingMode;
} H2250ModeParameters;

typedef struct DataMode {
    DataMode_application application;
    ASN1uint32_t bitRate;
} DataMode;

typedef struct CommunicationModeTableEntry_dataType {
    ASN1choice_t choice;
    union {
#	define CommunicationModeTableEntry_dataType_videoData_chosen 1
	VideoCapability videoData;
#	define CommunicationModeTableEntry_dataType_audioData_chosen 2
	AudioCapability audioData;
#	define CommunicationModeTableEntry_dataType_data_chosen 3
	DataApplicationCapability data;
    } u;
} CommunicationModeTableEntry_dataType;

typedef struct H235Mode_mediaMode {
    ASN1choice_t choice;
    union {
#	define H235Mode_mediaMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H235Mode_mediaMode_videoMode_chosen 2
	VideoMode videoMode;
#	define H235Mode_mediaMode_audioMode_chosen 3
	AudioMode audioMode;
#	define H235Mode_mediaMode_dataMode_chosen 4
	DataMode dataMode;
    } u;
} H235Mode_mediaMode;

typedef struct H235Media_mediaType {
    ASN1choice_t choice;
    union {
#	define H235Media_mediaType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H235Media_mediaType_videoData_chosen 2
	VideoCapability videoData;
#	define H235Media_mediaType_audioData_chosen 3
	AudioCapability audioData;
#	define H235Media_mediaType_data_chosen 4
	DataApplicationCapability data;
    } u;
} H235Media_mediaType;

typedef struct EnhancementLayerInfo_bPictureEnhancement {
    PEnhancementLayerInfo_bPictureEnhancement next;
    BEnhancementParameters value;
} EnhancementLayerInfo_bPictureEnhancement_Element;

typedef struct MediaDistributionCapability_distributedData {
    PMediaDistributionCapability_distributedData next;
    DataApplicationCapability value;
} MediaDistributionCapability_distributedData_Element;

typedef struct MediaDistributionCapability_centralizedData {
    PMediaDistributionCapability_centralizedData next;
    DataApplicationCapability value;
} MediaDistributionCapability_centralizedData_Element;

typedef struct TerminalCapabilitySet {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SequenceNumber sequenceNumber;
    ASN1objectidentifier_t protocolIdentifier;
#   define multiplexCapability_present 0x80
    MultiplexCapability multiplexCapability;
#   define capabilityTable_present 0x40
    PTerminalCapabilitySet_capabilityTable capabilityTable;
#   define capabilityDescriptors_present 0x20
    TerminalCapabilitySet_capabilityDescriptors capabilityDescriptors;
} TerminalCapabilitySet;

typedef struct Capability {
    ASN1choice_t choice;
    union {
#	define Capability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define receiveVideoCapability_chosen 2
	VideoCapability receiveVideoCapability;
#	define transmitVideoCapability_chosen 3
	VideoCapability transmitVideoCapability;
#	define receiveAndTransmitVideoCapability_chosen 4
	VideoCapability receiveAndTransmitVideoCapability;
#	define receiveAudioCapability_chosen 5
	AudioCapability receiveAudioCapability;
#	define transmitAudioCapability_chosen 6
	AudioCapability transmitAudioCapability;
#	define receiveAndTransmitAudioCapability_chosen 7
	AudioCapability receiveAndTransmitAudioCapability;
#	define receiveDataApplicationCapability_chosen 8
	DataApplicationCapability receiveDataApplicationCapability;
#	define transmitDataApplicationCapability_chosen 9
	DataApplicationCapability transmitDataApplicationCapability;
#	define receiveAndTransmitDataApplicationCapability_chosen 10
	DataApplicationCapability receiveAndTransmitDataApplicationCapability;
#	define h233EncryptionTransmitCapability_chosen 11
	ASN1bool_t h233EncryptionTransmitCapability;
#	define h233EncryptionReceiveCapability_chosen 12
	Capability_h233EncryptionReceiveCapability h233EncryptionReceiveCapability;
#	define conferenceCapability_chosen 13
	ConferenceCapability conferenceCapability;
#	define h235SecurityCapability_chosen 14
	H235SecurityCapability h235SecurityCapability;
#	define maxPendingReplacementFor_chosen 15
	ASN1uint16_t maxPendingReplacementFor;
#	define receiveUserInputCapability_chosen 16
	UserInputCapability receiveUserInputCapability;
#	define transmitUserInputCapability_chosen 17
	UserInputCapability transmitUserInputCapability;
#	define receiveAndTransmitUserInputCapability_chosen 18
	UserInputCapability receiveAndTransmitUserInputCapability;
    } u;
} Capability;

typedef struct H235Media {
    EncryptionAuthenticationAndIntegrity encryptionAuthenticationAndIntegrity;
    H235Media_mediaType mediaType;
} H235Media;

typedef struct H235Mode {
    EncryptionAuthenticationAndIntegrity encryptionAuthenticationAndIntegrity;
    H235Mode_mediaMode mediaMode;
} H235Mode;

typedef struct ModeElement_type {
    ASN1choice_t choice;
    union {
#	define ModeElement_type_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define ModeElement_type_videoMode_chosen 2
	VideoMode videoMode;
#	define ModeElement_type_audioMode_chosen 3
	AudioMode audioMode;
#	define ModeElement_type_dataMode_chosen 4
	DataMode dataMode;
#	define encryptionMode_chosen 5
	EncryptionMode encryptionMode;
#	define h235Mode_chosen 6
	H235Mode h235Mode;
    } u;
} ModeElement_type;

typedef struct CapabilityTableEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityTableEntryNumber capabilityTableEntryNumber;
#   define capability_present 0x80
    Capability capability;
} CapabilityTableEntry;

typedef struct DataType {
    ASN1choice_t choice;
    union {
#	define DataType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define nullData_chosen 2
#	define DataType_videoData_chosen 3
	VideoCapability videoData;
#	define DataType_audioData_chosen 4
	AudioCapability audioData;
#	define DataType_data_chosen 5
	DataApplicationCapability data;
#	define encryptionData_chosen 6
	EncryptionMode encryptionData;
#	define h235Control_chosen 7
	NonStandardParameter h235Control;
#	define h235Media_chosen 8
	H235Media h235Media;
    } u;
} DataType;

typedef struct RedundancyEncoding {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RedundancyEncodingMethod redundancyEncodingMethod;
#   define RedundancyEncoding_secondaryEncoding_present 0x80
    DataType secondaryEncoding;
} RedundancyEncoding;

typedef struct ModeElement {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ModeElement_type type;
#   define h223ModeParameters_present 0x80
    H223ModeParameters h223ModeParameters;
#   define v76ModeParameters_present 0x8000
    V76ModeParameters v76ModeParameters;
#   define h2250ModeParameters_present 0x4000
    H2250ModeParameters h2250ModeParameters;
} ModeElement;

typedef struct CommunicationModeTableEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define CommunicationModeTableEntry_nonStandard_present 0x80
    PCommunicationModeTableEntry_nonStandard nonStandard;
    ASN1uint16_t sessionID;
#   define CommunicationModeTableEntry_associatedSessionID_present 0x40
    ASN1uint16_t associatedSessionID;
#   define CommunicationModeTableEntry_terminalLabel_present 0x20
    TerminalLabel terminalLabel;
    ASN1char16string_t sessionDescription;
    CommunicationModeTableEntry_dataType dataType;
#   define CommunicationModeTableEntry_mediaChannel_present 0x10
    H245TransportAddress mediaChannel;
#   define CommunicationModeTableEntry_mediaGuaranteedDelivery_present 0x8
    ASN1bool_t mediaGuaranteedDelivery;
#   define CommunicationModeTableEntry_mediaControlChannel_present 0x4
    H245TransportAddress mediaControlChannel;
#   define CommunicationModeTableEntry_mediaControlGuaranteedDelivery_present 0x2
    ASN1bool_t mediaControlGuaranteedDelivery;
#   define CommunicationModeTableEntry_redundancyEncoding_present 0x8000
    RedundancyEncoding redundancyEncoding;
#   define sessionDependency_present 0x4000
    ASN1uint16_t sessionDependency;
} CommunicationModeTableEntry;

typedef struct CommunicationModeResponse_communicationModeTable {
    PCommunicationModeResponse_communicationModeTable next;
    CommunicationModeTableEntry value;
} CommunicationModeResponse_communicationModeTable_Element;

typedef struct CommunicationModeCommand_communicationModeTable {
    PCommunicationModeCommand_communicationModeTable next;
    CommunicationModeTableEntry value;
} CommunicationModeCommand_communicationModeTable_Element;

typedef struct TerminalCapabilitySet_capabilityTable {
    PTerminalCapabilitySet_capabilityTable next;
    CapabilityTableEntry value;
} TerminalCapabilitySet_capabilityTable_Element;

typedef struct H2250LogicalChannelParameters {
    union {
	ASN1uint32_t bit_mask;
	ASN1octet_t o[3];
    };
#   define H2250LogicalChannelParameters_nonStandard_present 0x80
    PH2250LogicalChannelParameters_nonStandard nonStandard;
    ASN1uint16_t sessionID;
#   define H2250LogicalChannelParameters_associatedSessionID_present 0x40
    ASN1uint16_t associatedSessionID;
#   define H2250LogicalChannelParameters_mediaChannel_present 0x20
    H245TransportAddress mediaChannel;
#   define H2250LogicalChannelParameters_mediaGuaranteedDelivery_present 0x10
    ASN1bool_t mediaGuaranteedDelivery;
#   define H2250LogicalChannelParameters_mediaControlChannel_present 0x8
    H245TransportAddress mediaControlChannel;
#   define H2250LogicalChannelParameters_mediaControlGuaranteedDelivery_present 0x4
    ASN1bool_t mediaControlGuaranteedDelivery;
#   define silenceSuppression_present 0x2
    ASN1bool_t silenceSuppression;
#   define destination_present 0x1
    TerminalLabel destination;
#   define H2250LogicalChannelParameters_dynamicRTPPayloadType_present 0x8000
    ASN1uint16_t dynamicRTPPayloadType;
#   define mediaPacketization_present 0x4000
    H2250LogicalChannelParameters_mediaPacketization mediaPacketization;
#   define H2250LogicalChannelParameters_transportCapability_present 0x800000
    TransportCapability transportCapability;
#   define H2250LogicalChannelParameters_redundancyEncoding_present 0x400000
    RedundancyEncoding redundancyEncoding;
#   define source_present 0x200000
    TerminalLabel source;
} H2250LogicalChannelParameters;

typedef struct ModeDescription {
    ASN1uint32_t count;
    ModeElement value[256];
} ModeDescription;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen 1
	H222LogicalChannelParameters h222LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen 2
	H223LogicalChannelParameters h223LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen 3
	V76LogicalChannelParameters v76LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 4
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_none_chosen 5
    } u;
} OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen 1
	H223LogicalChannelParameters h223LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen 2
	V76LogicalChannelParameters v76LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 3
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
    } u;
} OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen 1
	H222LogicalChannelParameters h222LogicalChannelParameters;
#	define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 2
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
    } u;
} OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters;

typedef struct RequestMode_requestedModes {
    PRequestMode_requestedModes next;
    ModeDescription value;
} RequestMode_requestedModes_Element;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber reverseLogicalChannelNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber_present 0x80
    ASN1uint16_t portNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_present 0x40
    OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_replacementFor_present 0x8000
    LogicalChannelNumber replacementFor;
} OpenLogicalChannelAck_reverseLogicalChannelParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    DataType dataType;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_present 0x80
    OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
#   define reverseLogicalChannelDependency_present 0x8000
    LogicalChannelNumber reverseLogicalChannelDependency;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_replacementFor_present 0x4000
    LogicalChannelNumber replacementFor;
} OpenLogicalChannel_reverseLogicalChannelParameters;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define OpenLogicalChannel_forwardLogicalChannelParameters_portNumber_present 0x80
    ASN1uint16_t portNumber;
    DataType dataType;
    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters multiplexParameters;
#   define forwardLogicalChannelDependency_present 0x8000
    LogicalChannelNumber forwardLogicalChannelDependency;
#   define OpenLogicalChannel_forwardLogicalChannelParameters_replacementFor_present 0x4000
    LogicalChannelNumber replacementFor;
} OpenLogicalChannel_forwardLogicalChannelParameters;

typedef struct OpenLogicalChannel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
    OpenLogicalChannel_forwardLogicalChannelParameters forwardLogicalChannelParameters;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_present 0x80
    OpenLogicalChannel_reverseLogicalChannelParameters reverseLogicalChannelParameters;
#   define OpenLogicalChannel_separateStack_present 0x8000
    NetworkAccessParameters separateStack;
#   define OpenLogicalChannel_encryptionSync_present 0x4000
    EncryptionSync encryptionSync;
} OpenLogicalChannel;

typedef struct OpenLogicalChannelAck {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_present 0x80
    OpenLogicalChannelAck_reverseLogicalChannelParameters reverseLogicalChannelParameters;
#   define OpenLogicalChannelAck_separateStack_present 0x8000
    NetworkAccessParameters separateStack;
#   define forwardMultiplexAckParameters_present 0x4000
    OpenLogicalChannelAck_forwardMultiplexAckParameters forwardMultiplexAckParameters;
#   define OpenLogicalChannelAck_encryptionSync_present 0x2000
    EncryptionSync encryptionSync;
} OpenLogicalChannelAck;

typedef struct RequestMessage {
    ASN1choice_t choice;
    union {
#	define RequestMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define masterSlaveDetermination_chosen 2
	MasterSlaveDetermination masterSlaveDetermination;
#	define terminalCapabilitySet_chosen 3
	TerminalCapabilitySet terminalCapabilitySet;
#	define openLogicalChannel_chosen 4
	OpenLogicalChannel openLogicalChannel;
#	define closeLogicalChannel_chosen 5
	CloseLogicalChannel closeLogicalChannel;
#	define requestChannelClose_chosen 6
	RequestChannelClose requestChannelClose;
#	define multiplexEntrySend_chosen 7
	MultiplexEntrySend multiplexEntrySend;
#	define requestMultiplexEntry_chosen 8
	RequestMultiplexEntry requestMultiplexEntry;
#	define requestMode_chosen 9
	RequestMode requestMode;
#	define roundTripDelayRequest_chosen 10
	RoundTripDelayRequest roundTripDelayRequest;
#	define maintenanceLoopRequest_chosen 11
	MaintenanceLoopRequest maintenanceLoopRequest;
#	define communicationModeRequest_chosen 12
	CommunicationModeRequest communicationModeRequest;
#	define conferenceRequest_chosen 13
	ConferenceRequest conferenceRequest;
    } u;
} RequestMessage;

typedef struct ResponseMessage {
    ASN1choice_t choice;
    union {
#	define ResponseMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define masterSlaveDeterminationAck_chosen 2
	MasterSlaveDeterminationAck masterSlaveDeterminationAck;
#	define masterSlaveDeterminationReject_chosen 3
	MasterSlaveDeterminationReject masterSlaveDeterminationReject;
#	define terminalCapabilitySetAck_chosen 4
	TerminalCapabilitySetAck terminalCapabilitySetAck;
#	define terminalCapabilitySetReject_chosen 5
	TerminalCapabilitySetReject terminalCapabilitySetReject;
#	define openLogicalChannelAck_chosen 6
	OpenLogicalChannelAck openLogicalChannelAck;
#	define openLogicalChannelReject_chosen 7
	OpenLogicalChannelReject openLogicalChannelReject;
#	define closeLogicalChannelAck_chosen 8
	CloseLogicalChannelAck closeLogicalChannelAck;
#	define requestChannelCloseAck_chosen 9
	RequestChannelCloseAck requestChannelCloseAck;
#	define requestChannelCloseReject_chosen 10
	RequestChannelCloseReject requestChannelCloseReject;
#	define multiplexEntrySendAck_chosen 11
	MultiplexEntrySendAck multiplexEntrySendAck;
#	define multiplexEntrySendReject_chosen 12
	MultiplexEntrySendReject multiplexEntrySendReject;
#	define requestMultiplexEntryAck_chosen 13
	RequestMultiplexEntryAck requestMultiplexEntryAck;
#	define requestMultiplexEntryReject_chosen 14
	RequestMultiplexEntryReject requestMultiplexEntryReject;
#	define requestModeAck_chosen 15
	RequestModeAck requestModeAck;
#	define requestModeReject_chosen 16
	RequestModeReject requestModeReject;
#	define roundTripDelayResponse_chosen 17
	RoundTripDelayResponse roundTripDelayResponse;
#	define maintenanceLoopAck_chosen 18
	MaintenanceLoopAck maintenanceLoopAck;
#	define maintenanceLoopReject_chosen 19
	MaintenanceLoopReject maintenanceLoopReject;
#	define communicationModeResponse_chosen 20
	CommunicationModeResponse communicationModeResponse;
#	define conferenceResponse_chosen 21
	ConferenceResponse conferenceResponse;
    } u;
} ResponseMessage;

typedef struct FunctionNotUnderstood {
    ASN1choice_t choice;
    union {
#	define FunctionNotUnderstood_request_chosen 1
	RequestMessage request;
#	define FunctionNotUnderstood_response_chosen 2
	ResponseMessage response;
#	define FunctionNotUnderstood_command_chosen 3
	CommandMessage command;
    } u;
} FunctionNotUnderstood;

typedef struct IndicationMessage {
    ASN1choice_t choice;
    union {
#	define IndicationMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define functionNotUnderstood_chosen 2
	FunctionNotUnderstood functionNotUnderstood;
#	define masterSlaveDeterminationRelease_chosen 3
	MasterSlaveDeterminationRelease masterSlaveDeterminationRelease;
#	define terminalCapabilitySetRelease_chosen 4
	TerminalCapabilitySetRelease terminalCapabilitySetRelease;
#	define openLogicalChannelConfirm_chosen 5
	OpenLogicalChannelConfirm openLogicalChannelConfirm;
#	define requestChannelCloseRelease_chosen 6
	RequestChannelCloseRelease requestChannelCloseRelease;
#	define multiplexEntrySendRelease_chosen 7
	MultiplexEntrySendRelease multiplexEntrySendRelease;
#	define requestMultiplexEntryRelease_chosen 8
	RequestMultiplexEntryRelease requestMultiplexEntryRelease;
#	define requestModeRelease_chosen 9
	RequestModeRelease requestModeRelease;
#	define miscellaneousIndication_chosen 10
	MiscellaneousIndication miscellaneousIndication;
#	define jitterIndication_chosen 11
	JitterIndication jitterIndication;
#	define h223SkewIndication_chosen 12
	H223SkewIndication h223SkewIndication;
#	define newATMVCIndication_chosen 13
	NewATMVCIndication newATMVCIndication;
#	define userInput_chosen 14
	UserInputIndication userInput;
#	define h2250MaximumSkewIndication_chosen 15
	H2250MaximumSkewIndication h2250MaximumSkewIndication;
#	define mcLocationIndication_chosen 16
	MCLocationIndication mcLocationIndication;
#	define conferenceIndication_chosen 17
	ConferenceIndication conferenceIndication;
#	define vendorIdentification_chosen 18
	VendorIdentification vendorIdentification;
#	define IndicationMessage_functionNotSupported_chosen 19
	FunctionNotSupported functionNotSupported;
    } u;
} IndicationMessage;

typedef struct MultimediaSystemControlMessage {
    ASN1choice_t choice;
    union {
#	define MultimediaSystemControlMessage_request_chosen 1
	RequestMessage request;
#	define MultimediaSystemControlMessage_response_chosen 2
	ResponseMessage response;
#	define MultimediaSystemControlMessage_command_chosen 3
	CommandMessage command;
#	define indication_chosen 4
	IndicationMessage indication;
    } u;
} MultimediaSystemControlMessage;
#define MultimediaSystemControlMessage_PDU 0
#define SIZE_H245PP_Module_PDU_0 sizeof(MultimediaSystemControlMessage)


extern ASN1module_t H245PP_Module;
extern void ASN1CALL H245PP_Module_Startup(void);
extern void ASN1CALL H245PP_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route val);
	extern void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn(PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
	extern void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern int ASN1CALL ASN1Enc_RedundancyEncodingCapability_secondaryEncoding_ElmFn(ASN1encoding_t enc, PRedundancyEncodingCapability_secondaryEncoding val);
    extern int ASN1CALL ASN1Dec_RedundancyEncodingCapability_secondaryEncoding_ElmFn(ASN1decoding_t dec, PRedundancyEncodingCapability_secondaryEncoding val);
	extern void ASN1CALL ASN1Free_RedundancyEncodingCapability_secondaryEncoding_ElmFn(PRedundancyEncodingCapability_secondaryEncoding val);
    extern int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(ASN1encoding_t enc, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val);
    extern int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(ASN1decoding_t dec, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val);
	extern void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val);
    extern int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(ASN1encoding_t enc, PRequestAllTerminalIDsResponse_terminalInformation val);
    extern int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(ASN1decoding_t dec, PRequestAllTerminalIDsResponse_terminalInformation val);
	extern void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(PRequestAllTerminalIDsResponse_terminalInformation val);
    extern int ASN1CALL ASN1Enc_EncryptionSync_escrowentry_ElmFn(ASN1encoding_t enc, PEncryptionSync_escrowentry val);
    extern int ASN1CALL ASN1Dec_EncryptionSync_escrowentry_ElmFn(ASN1decoding_t dec, PEncryptionSync_escrowentry val);
	extern void ASN1CALL ASN1Free_EncryptionSync_escrowentry_ElmFn(PEncryptionSync_escrowentry val);
    extern int ASN1CALL ASN1Enc_H263Options_customPictureFormat_ElmFn(ASN1encoding_t enc, PH263Options_customPictureFormat val);
    extern int ASN1CALL ASN1Dec_H263Options_customPictureFormat_ElmFn(ASN1decoding_t dec, PH263Options_customPictureFormat val);
	extern void ASN1CALL ASN1Free_H263Options_customPictureFormat_ElmFn(PH263Options_customPictureFormat val);
    extern int ASN1CALL ASN1Enc_H263Options_customPictureClockFrequency_ElmFn(ASN1encoding_t enc, PH263Options_customPictureClockFrequency val);
    extern int ASN1CALL ASN1Dec_H263Options_customPictureClockFrequency_ElmFn(ASN1decoding_t dec, PH263Options_customPictureClockFrequency val);
	extern void ASN1CALL ASN1Free_H263Options_customPictureClockFrequency_ElmFn(PH263Options_customPictureClockFrequency val);
    extern int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability val);
	extern void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn(PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Enc_H222Capability_vcCapability_ElmFn(ASN1encoding_t enc, PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Dec_H222Capability_vcCapability_ElmFn(ASN1decoding_t dec, PH222Capability_vcCapability val);
	extern void ASN1CALL ASN1Free_H222Capability_vcCapability_ElmFn(PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities val);
    extern int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities val);
	extern void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities_ElmFn(PCapabilityDescriptor_simultaneousCapabilities val);
    extern int ASN1CALL ASN1Enc_CertSelectionCriteria_ElmFn(ASN1encoding_t enc, PCertSelectionCriteria val);
    extern int ASN1CALL ASN1Dec_CertSelectionCriteria_ElmFn(ASN1decoding_t dec, PCertSelectionCriteria val);
	extern void ASN1CALL ASN1Free_CertSelectionCriteria_ElmFn(PCertSelectionCriteria val);
    extern int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard val);
    extern int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard val);
	extern void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard_ElmFn(PCommunicationModeTableEntry_nonStandard val);
    extern int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors val);
	extern void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard val);
	extern void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard_ElmFn(PH2250LogicalChannelAckParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard val);
	extern void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn(PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData_ElmFn(ASN1encoding_t enc, PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData_ElmFn(ASN1decoding_t dec, PConferenceCapability_nonStandardData val);
	extern void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData_ElmFn(PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Enc_H263Options_modeCombos_ElmFn(ASN1encoding_t enc, PH263Options_modeCombos val);
    extern int ASN1CALL ASN1Dec_H263Options_modeCombos_ElmFn(ASN1decoding_t dec, PH263Options_modeCombos val);
	extern void ASN1CALL ASN1Free_H263Options_modeCombos_ElmFn(PH263Options_modeCombos val);
    extern int ASN1CALL ASN1Enc_TransportCapability_qOSCapabilities_ElmFn(ASN1encoding_t enc, PTransportCapability_qOSCapabilities val);
    extern int ASN1CALL ASN1Dec_TransportCapability_qOSCapabilities_ElmFn(ASN1decoding_t dec, PTransportCapability_qOSCapabilities val);
	extern void ASN1CALL ASN1Free_TransportCapability_qOSCapabilities_ElmFn(PTransportCapability_qOSCapabilities val);
    extern int ASN1CALL ASN1Enc_EncryptionCapability_ElmFn(ASN1encoding_t enc, PEncryptionCapability val);
    extern int ASN1CALL ASN1Dec_EncryptionCapability_ElmFn(ASN1decoding_t dec, PEncryptionCapability val);
	extern void ASN1CALL ASN1Free_EncryptionCapability_ElmFn(PEncryptionCapability val);
    extern int ASN1CALL ASN1Enc_EnhancementLayerInfo_spatialEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_spatialEnhancement val);
    extern int ASN1CALL ASN1Dec_EnhancementLayerInfo_spatialEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_spatialEnhancement val);
	extern void ASN1CALL ASN1Free_EnhancementLayerInfo_spatialEnhancement_ElmFn(PEnhancementLayerInfo_spatialEnhancement val);
    extern int ASN1CALL ASN1Enc_EnhancementLayerInfo_snrEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_snrEnhancement val);
    extern int ASN1CALL ASN1Dec_EnhancementLayerInfo_snrEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_snrEnhancement val);
	extern void ASN1CALL ASN1Free_EnhancementLayerInfo_snrEnhancement_ElmFn(PEnhancementLayerInfo_snrEnhancement val);
    extern int ASN1CALL ASN1Enc_H2250Capability_redundancyEncodingCapability_ElmFn(ASN1encoding_t enc, PH2250Capability_redundancyEncodingCapability val);
    extern int ASN1CALL ASN1Dec_H2250Capability_redundancyEncodingCapability_ElmFn(ASN1decoding_t dec, PH2250Capability_redundancyEncodingCapability val);
	extern void ASN1CALL ASN1Free_H2250Capability_redundancyEncodingCapability_ElmFn(PH2250Capability_redundancyEncodingCapability val);
    extern int ASN1CALL ASN1Enc_EnhancementLayerInfo_bPictureEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_bPictureEnhancement val);
    extern int ASN1CALL ASN1Dec_EnhancementLayerInfo_bPictureEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_bPictureEnhancement val);
	extern void ASN1CALL ASN1Free_EnhancementLayerInfo_bPictureEnhancement_ElmFn(PEnhancementLayerInfo_bPictureEnhancement val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_distributedData val);
	extern void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData_ElmFn(PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData val);
	extern void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData_ElmFn(PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable val);
    extern int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable val);
	extern void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable_ElmFn(PCommunicationModeResponse_communicationModeTable val);
    extern int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable val);
    extern int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable val);
	extern void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable_ElmFn(PCommunicationModeCommand_communicationModeTable val);
    extern int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable val);
    extern int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable val);
	extern void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable_ElmFn(PTerminalCapabilitySet_capabilityTable val);
    extern int ASN1CALL ASN1Enc_RequestMode_requestedModes_ElmFn(ASN1encoding_t enc, PRequestMode_requestedModes val);
    extern int ASN1CALL ASN1Dec_RequestMode_requestedModes_ElmFn(ASN1decoding_t dec, PRequestMode_requestedModes val);
	extern void ASN1CALL ASN1Free_RequestMode_requestedModes_ElmFn(PRequestMode_requestedModes val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _H245PP_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\h225pp.h ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for H.235 Security Messages v1 (H.235) */
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for Multimedia System Control (H.245) */
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for H.323 Messages v2 (H.225) */

#ifndef _H225PP_Module_H_
#define _H225PP_Module_H_

#include "msper.h"

#include "h245pp.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct InfoRequestResponse_perCallInfo_Seq_substituteConfIDs * PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs;

typedef struct TransportAddress_ipSourceRoute_route * PTransportAddress_ipSourceRoute_route;

typedef struct RTPSession_associatedSessionIds * PRTPSession_associatedSessionIds;

typedef struct GatekeeperRequest_algorithmOIDs * PGatekeeperRequest_algorithmOIDs;

typedef struct Progress_UUIE_fastStart * PProgress_UUIE_fastStart;

typedef struct Setup_UUIE_destExtraCRV * PSetup_UUIE_destExtraCRV;

typedef struct H323_UU_PDU_h245Control * PH323_UU_PDU_h245Control;

typedef struct H323_UU_PDU_h4501SupplementaryService * PH323_UU_PDU_h4501SupplementaryService;

typedef struct InfoRequestResponse_perCallInfo_Seq_tokens * PInfoRequestResponse_perCallInfo_Seq_tokens;

typedef struct ResourcesAvailableConfirm_tokens * PResourcesAvailableConfirm_tokens;

typedef struct ResourcesAvailableIndicate_tokens * PResourcesAvailableIndicate_tokens;

typedef struct RequestInProgress_tokens * PRequestInProgress_tokens;

typedef struct UnknownMessageResponse_tokens * PUnknownMessageResponse_tokens;

typedef struct H225NonStandardMessage_tokens * PH225NonStandardMessage_tokens;

typedef struct InfoRequestNak_tokens * PInfoRequestNak_tokens;

typedef struct InfoRequestAck_tokens * PInfoRequestAck_tokens;

typedef struct InfoRequestResponse_tokens * PInfoRequestResponse_tokens;

typedef struct InfoRequest_tokens * PInfoRequest_tokens;

typedef struct DisengageReject_tokens * PDisengageReject_tokens;

typedef struct DisengageConfirm_tokens * PDisengageConfirm_tokens;

typedef struct DisengageRequest_tokens * PDisengageRequest_tokens;

typedef struct LocationReject_tokens * PLocationReject_tokens;

typedef struct LocationConfirm_tokens * PLocationConfirm_tokens;

typedef struct LocationRequest_tokens * PLocationRequest_tokens;

typedef struct BandwidthReject_tokens * PBandwidthReject_tokens;

typedef struct BandwidthConfirm_tokens * PBandwidthConfirm_tokens;

typedef struct BandwidthRequest_tokens * PBandwidthRequest_tokens;

typedef struct AdmissionReject_tokens * PAdmissionReject_tokens;

typedef struct AdmissionConfirm_tokens * PAdmissionConfirm_tokens;

typedef struct AdmissionRequest_tokens * PAdmissionRequest_tokens;

typedef struct UnregistrationReject_tokens * PUnregistrationReject_tokens;

typedef struct UnregistrationConfirm_tokens * PUnregistrationConfirm_tokens;

typedef struct UnregistrationRequest_tokens * PUnregistrationRequest_tokens;

typedef struct RegistrationReject_tokens * PRegistrationReject_tokens;

typedef struct RegistrationConfirm_tokens * PRegistrationConfirm_tokens;

typedef struct RegistrationRequest_tokens * PRegistrationRequest_tokens;

typedef struct GatekeeperReject_tokens * PGatekeeperReject_tokens;

typedef struct GatekeeperConfirm_tokens * PGatekeeperConfirm_tokens;

typedef struct GatekeeperRequest_authenticationCapability * PGatekeeperRequest_authenticationCapability;

typedef struct GatekeeperRequest_tokens * PGatekeeperRequest_tokens;

typedef struct Endpoint_tokens * PEndpoint_tokens;

typedef struct Progress_UUIE_tokens * PProgress_UUIE_tokens;

typedef struct Facility_UUIE_tokens * PFacility_UUIE_tokens;

typedef struct Setup_UUIE_tokens * PSetup_UUIE_tokens;

typedef struct Connect_UUIE_tokens * PConnect_UUIE_tokens;

typedef struct CallProceeding_UUIE_tokens * PCallProceeding_UUIE_tokens;

typedef struct Alerting_UUIE_tokens * PAlerting_UUIE_tokens;

typedef struct GatekeeperConfirm_integrity * PGatekeeperConfirm_integrity;

typedef struct GatekeeperRequest_integrity * PGatekeeperRequest_integrity;

typedef struct NonStandardProtocol_dataRatesSupported * PNonStandardProtocol_dataRatesSupported;

typedef struct T120OnlyCaps_dataRatesSupported * PT120OnlyCaps_dataRatesSupported;

typedef struct VoiceCaps_dataRatesSupported * PVoiceCaps_dataRatesSupported;

typedef struct H324Caps_dataRatesSupported * PH324Caps_dataRatesSupported;

typedef struct H323Caps_dataRatesSupported * PH323Caps_dataRatesSupported;

typedef struct H322Caps_dataRatesSupported * PH322Caps_dataRatesSupported;

typedef struct H321Caps_dataRatesSupported * PH321Caps_dataRatesSupported;

typedef struct H320Caps_dataRatesSupported * PH320Caps_dataRatesSupported;

typedef struct H310Caps_dataRatesSupported * PH310Caps_dataRatesSupported;

typedef struct Setup_UUIE_h245SecurityCapability * PSetup_UUIE_h245SecurityCapability;

typedef struct H323_UU_PDU_nonStandardControl * PH323_UU_PDU_nonStandardControl;

typedef struct InfoRequestResponse_perCallInfo_Seq_data * PInfoRequestResponse_perCallInfo_Seq_data;

typedef struct InfoRequestResponse_perCallInfo_Seq_video * PInfoRequestResponse_perCallInfo_Seq_video;

typedef struct InfoRequestResponse_perCallInfo_Seq_audio * PInfoRequestResponse_perCallInfo_Seq_audio;

typedef struct InfoRequestNak_alternateGatekeeper * PInfoRequestNak_alternateGatekeeper;

typedef struct InfoRequestResponse_perCallInfo * PInfoRequestResponse_perCallInfo;

typedef struct InfoRequestResponse_callSignalAddress * PInfoRequestResponse_callSignalAddress;

typedef struct DisengageReject_alternateGatekeeper * PDisengageReject_alternateGatekeeper;

typedef struct LocationReject_alternateGatekeeper * PLocationReject_alternateGatekeeper;

typedef struct BandwidthReject_alternateGatekeeper * PBandwidthReject_alternateGatekeeper;

typedef struct AdmissionReject_alternateGatekeeper * PAdmissionReject_alternateGatekeeper;

typedef struct UnregistrationReject_alternateGatekeeper * PUnregistrationReject_alternateGatekeeper;

typedef struct UnregistrationRequest_callSignalAddress * PUnregistrationRequest_callSignalAddress;

typedef struct RegistrationReject_alternateGatekeeper * PRegistrationReject_alternateGatekeeper;

typedef struct RegistrationConfirm_alternateGatekeeper * PRegistrationConfirm_alternateGatekeeper;

typedef struct RegistrationConfirm_callSignalAddress * PRegistrationConfirm_callSignalAddress;

typedef struct RegistrationRequest_rasAddress * PRegistrationRequest_rasAddress;

typedef struct RegistrationRequest_callSignalAddress * PRegistrationRequest_callSignalAddress;

typedef struct GatekeeperReject_alternateGatekeeper * PGatekeeperReject_alternateGatekeeper;

typedef struct GatekeeperConfirm_alternateGatekeeper * PGatekeeperConfirm_alternateGatekeeper;

typedef struct Endpoint_rasAddress * PEndpoint_rasAddress;

typedef struct Endpoint_callSignalAddress * PEndpoint_callSignalAddress;

typedef struct ResourcesAvailableIndicate_protocols * PResourcesAvailableIndicate_protocols;

typedef struct InfoRequestResponse_endpointAlias * PInfoRequestResponse_endpointAlias;

typedef struct LocationConfirm_alternateEndpoints * PLocationConfirm_alternateEndpoints;

typedef struct LocationConfirm_remoteExtensionAddress * PLocationConfirm_remoteExtensionAddress;

typedef struct LocationConfirm_destExtraCallInfo * PLocationConfirm_destExtraCallInfo;

typedef struct LocationConfirm_destinationInfo * PLocationConfirm_destinationInfo;

typedef struct LocationRequest_sourceInfo * PLocationRequest_sourceInfo;

typedef struct LocationRequest_destinationInfo * PLocationRequest_destinationInfo;

typedef struct AdmissionConfirm_alternateEndpoints * PAdmissionConfirm_alternateEndpoints;

typedef struct AdmissionConfirm_remoteExtensionAddress * PAdmissionConfirm_remoteExtensionAddress;

typedef struct AdmissionConfirm_destExtraCallInfo * PAdmissionConfirm_destExtraCallInfo;

typedef struct AdmissionConfirm_destinationInfo * PAdmissionConfirm_destinationInfo;

typedef struct AdmissionRequest_destAlternatives * PAdmissionRequest_destAlternatives;

typedef struct AdmissionRequest_srcAlternatives * PAdmissionRequest_srcAlternatives;

typedef struct AdmissionRequest_srcInfo * PAdmissionRequest_srcInfo;

typedef struct AdmissionRequest_destExtraCallInfo * PAdmissionRequest_destExtraCallInfo;

typedef struct AdmissionRequest_destinationInfo * PAdmissionRequest_destinationInfo;

typedef struct UnregistrationRequest_alternateEndpoints * PUnregistrationRequest_alternateEndpoints;

typedef struct UnregistrationRequest_endpointAlias * PUnregistrationRequest_endpointAlias;

typedef struct RegistrationRejectReason_duplicateAlias * PRegistrationRejectReason_duplicateAlias;

typedef struct RegistrationConfirm_terminalAlias * PRegistrationConfirm_terminalAlias;

typedef struct RegistrationRequest_alternateEndpoints * PRegistrationRequest_alternateEndpoints;

typedef struct RegistrationRequest_terminalAlias * PRegistrationRequest_terminalAlias;

typedef struct GatekeeperRequest_alternateEndpoints * PGatekeeperRequest_alternateEndpoints;

typedef struct GatekeeperRequest_endpointAlias * PGatekeeperRequest_endpointAlias;

typedef struct Endpoint_destExtraCallInfo * PEndpoint_destExtraCallInfo;

typedef struct Endpoint_destinationInfo * PEndpoint_destinationInfo;

typedef struct Endpoint_aliasAddress * PEndpoint_aliasAddress;

typedef struct NonStandardProtocol_supportedPrefixes * PNonStandardProtocol_supportedPrefixes;

typedef struct T120OnlyCaps_supportedPrefixes * PT120OnlyCaps_supportedPrefixes;

typedef struct VoiceCaps_supportedPrefixes * PVoiceCaps_supportedPrefixes;

typedef struct H324Caps_supportedPrefixes * PH324Caps_supportedPrefixes;

typedef struct H323Caps_supportedPrefixes * PH323Caps_supportedPrefixes;

typedef struct H322Caps_supportedPrefixes * PH322Caps_supportedPrefixes;

typedef struct H321Caps_supportedPrefixes * PH321Caps_supportedPrefixes;

typedef struct H320Caps_supportedPrefixes * PH320Caps_supportedPrefixes;

typedef struct H310Caps_supportedPrefixes * PH310Caps_supportedPrefixes;

typedef struct GatewayInfo_protocol * PGatewayInfo_protocol;

typedef struct Facility_UUIE_destExtraCallInfo * PFacility_UUIE_destExtraCallInfo;

typedef struct Facility_UUIE_alternativeAliasAddress * PFacility_UUIE_alternativeAliasAddress;

typedef struct Setup_UUIE_destExtraCallInfo * PSetup_UUIE_destExtraCallInfo;

typedef struct Setup_UUIE_destinationAddress * PSetup_UUIE_destinationAddress;

typedef struct Setup_UUIE_sourceAddress * PSetup_UUIE_sourceAddress;

typedef struct InfoRequestResponse_perCallInfo_Seq_cryptoTokens * PInfoRequestResponse_perCallInfo_Seq_cryptoTokens;

typedef struct ResourcesAvailableConfirm_cryptoTokens * PResourcesAvailableConfirm_cryptoTokens;

typedef struct ResourcesAvailableIndicate_cryptoTokens * PResourcesAvailableIndicate_cryptoTokens;

typedef struct RequestInProgress_cryptoTokens * PRequestInProgress_cryptoTokens;

typedef struct UnknownMessageResponse_cryptoTokens * PUnknownMessageResponse_cryptoTokens;

typedef struct H225NonStandardMessage_cryptoTokens * PH225NonStandardMessage_cryptoTokens;

typedef struct InfoRequestNak_cryptoTokens * PInfoRequestNak_cryptoTokens;

typedef struct InfoRequestAck_cryptoTokens * PInfoRequestAck_cryptoTokens;

typedef struct InfoRequestResponse_cryptoTokens * PInfoRequestResponse_cryptoTokens;

typedef struct InfoRequest_cryptoTokens * PInfoRequest_cryptoTokens;

typedef struct DisengageReject_cryptoTokens * PDisengageReject_cryptoTokens;

typedef struct DisengageConfirm_cryptoTokens * PDisengageConfirm_cryptoTokens;

typedef struct DisengageRequest_cryptoTokens * PDisengageRequest_cryptoTokens;

typedef struct LocationReject_cryptoTokens * PLocationReject_cryptoTokens;

typedef struct LocationConfirm_cryptoTokens * PLocationConfirm_cryptoTokens;

typedef struct LocationRequest_cryptoTokens * PLocationRequest_cryptoTokens;

typedef struct BandwidthReject_cryptoTokens * PBandwidthReject_cryptoTokens;

typedef struct BandwidthConfirm_cryptoTokens * PBandwidthConfirm_cryptoTokens;

typedef struct BandwidthRequest_cryptoTokens * PBandwidthRequest_cryptoTokens;

typedef struct AdmissionReject_cryptoTokens * PAdmissionReject_cryptoTokens;

typedef struct AdmissionConfirm_cryptoTokens * PAdmissionConfirm_cryptoTokens;

typedef struct AdmissionRequest_cryptoTokens * PAdmissionRequest_cryptoTokens;

typedef struct UnregistrationReject_cryptoTokens * PUnregistrationReject_cryptoTokens;

typedef struct UnregistrationConfirm_cryptoTokens * PUnregistrationConfirm_cryptoTokens;

typedef struct UnregistrationRequest_cryptoTokens * PUnregistrationRequest_cryptoTokens;

typedef struct RegistrationReject_cryptoTokens * PRegistrationReject_cryptoTokens;

typedef struct RegistrationConfirm_cryptoTokens * PRegistrationConfirm_cryptoTokens;

typedef struct RegistrationRequest_cryptoTokens * PRegistrationRequest_cryptoTokens;

typedef struct GatekeeperReject_cryptoTokens * PGatekeeperReject_cryptoTokens;

typedef struct GatekeeperConfirm_cryptoTokens * PGatekeeperConfirm_cryptoTokens;

typedef struct GatekeeperRequest_cryptoTokens * PGatekeeperRequest_cryptoTokens;

typedef struct FastCap_caps * PFastCap_caps;

typedef struct Progress_UUIE_cryptoTokens * PProgress_UUIE_cryptoTokens;

typedef struct Facility_UUIE_conferences * PFacility_UUIE_conferences;

typedef struct Facility_UUIE_cryptoTokens * PFacility_UUIE_cryptoTokens;

typedef struct Setup_UUIE_cryptoTokens * PSetup_UUIE_cryptoTokens;

typedef struct Connect_UUIE_cryptoTokens * PConnect_UUIE_cryptoTokens;

typedef struct CallProceeding_UUIE_cryptoTokens * PCallProceeding_UUIE_cryptoTokens;

typedef struct Alerting_UUIE_cryptoTokens * PAlerting_UUIE_cryptoTokens;

typedef struct InfoRequestResponse_perCallInfo_Seq_pdu * PInfoRequestResponse_perCallInfo_Seq_pdu;

typedef struct Setup_UUIE_fastStart * PSetup_UUIE_fastStart;

typedef struct Connect_UUIE_fastStart * PConnect_UUIE_fastStart;

typedef struct CallProceeding_UUIE_fastStart * PCallProceeding_UUIE_fastStart;

typedef struct Alerting_UUIE_fastStart * PAlerting_UUIE_fastStart;

typedef struct TransportAddress_ipSourceRoute_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} TransportAddress_ipSourceRoute_route_Seq;

typedef ASN1octetstring_t H323_UU_PDU_h4501SupplementaryService_Seq;

typedef ASN1octetstring_t H323_UU_PDU_h245Control_Seq;

typedef ASN1octetstring_t Progress_UUIE_fastStart_Seq;

typedef ASN1objectidentifier_t GatekeeperRequest_algorithmOIDs_Seq;

typedef ASN1uint16_t RTPSession_associatedSessionIds_Seq;

typedef struct ChallengeString {
    ASN1uint32_t length;
    ASN1octet_t value[128];
} ChallengeString;

typedef ASN1uint32_t H235TimeStamp;

typedef ASN1int32_t RandomVal;

typedef ASN1char16string_t H235Password;

typedef ASN1char16string_t Identifier;

typedef struct IV8 {
    ASN1uint32_t length;
    ASN1octet_t value[8];
} IV8;

typedef ASN1char_t NumberDigits[129];

typedef struct GloballyUniqueID {
    ASN1uint32_t length;
    ASN1octet_t value[16];
} GloballyUniqueID;

typedef GloballyUniqueID ConferenceIdentifier;

typedef ASN1uint16_t RequestSeqNum;

typedef ASN1char16string_t GatekeeperIdentifier;

typedef ASN1uint32_t BandWidth;

typedef ASN1uint16_t CallReferenceValue;

typedef ASN1char16string_t EndpointIdentifier;

typedef ASN1objectidentifier_t ProtocolIdentifier;

typedef ASN1intx_t TimeToLive;

typedef struct InfoRequestResponse_perCallInfo_Seq_substituteConfIDs {
    PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs next;
    ConferenceIdentifier value;
} InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_Element;

typedef struct TransportAddress_ipSourceRoute_routing {
    ASN1choice_t choice;
#   define TransportAddress_ipSourceRoute_routing_strict_chosen 1
#   define TransportAddress_ipSourceRoute_routing_loose_chosen 2
} TransportAddress_ipSourceRoute_routing;

typedef struct TransportAddress_ipSourceRoute_route {
    PTransportAddress_ipSourceRoute_route next;
    TransportAddress_ipSourceRoute_route_Seq value;
} TransportAddress_ipSourceRoute_route_Element;

typedef struct RTPSession_associatedSessionIds {
    PRTPSession_associatedSessionIds next;
    RTPSession_associatedSessionIds_Seq value;
} RTPSession_associatedSessionIds_Element;

typedef struct RegistrationConfirm_preGrantedARQ {
    ASN1bool_t makeCall;
    ASN1bool_t useGKCallSignalAddressToMakeCall;
    ASN1bool_t answerCall;
    ASN1bool_t useGKCallSignalAddressToAnswer;
} RegistrationConfirm_preGrantedARQ;

typedef struct GatekeeperRequest_algorithmOIDs {
    PGatekeeperRequest_algorithmOIDs next;
    GatekeeperRequest_algorithmOIDs_Seq value;
} GatekeeperRequest_algorithmOIDs_Element;

typedef struct TransportAddress_ip6Address {
    struct TransportAddress_ip6Address_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } ip;
    ASN1uint16_t port;
} TransportAddress_ip6Address;

typedef struct TransportAddress_ipxAddress {
    struct TransportAddress_ipxAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct TransportAddress_ipxAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct TransportAddress_ipxAddress_port_port {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } port;
} TransportAddress_ipxAddress;

typedef struct TransportAddress_ipSourceRoute {
    struct TransportAddress_ipSourceRoute_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
    PTransportAddress_ipSourceRoute_route route;
    TransportAddress_ipSourceRoute_routing routing;
} TransportAddress_ipSourceRoute;

typedef struct TransportAddress_ipAddress {
    struct TransportAddress_ipAddress_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
} TransportAddress_ipAddress;

typedef struct Progress_UUIE_fastStart {
    PProgress_UUIE_fastStart next;
    Progress_UUIE_fastStart_Seq value;
} Progress_UUIE_fastStart_Element;

typedef struct Setup_UUIE_conferenceGoal {
    ASN1choice_t choice;
#   define create_chosen 1
#   define join_chosen 2
#   define invite_chosen 3
#   define capability_negotiation_chosen 4
#   define callIndependentSupplementaryService_chosen 5
} Setup_UUIE_conferenceGoal;

typedef struct Setup_UUIE_destExtraCRV {
    PSetup_UUIE_destExtraCRV next;
    CallReferenceValue value;
} Setup_UUIE_destExtraCRV_Element;

typedef struct H323_UU_PDU_h245Control {
    PH323_UU_PDU_h245Control next;
    H323_UU_PDU_h245Control_Seq value;
} H323_UU_PDU_h245Control_Element;

typedef struct H323_UU_PDU_h4501SupplementaryService {
    PH323_UU_PDU_h4501SupplementaryService next;
    H323_UU_PDU_h4501SupplementaryService_Seq value;
} H323_UU_PDU_h4501SupplementaryService_Element;

typedef struct H323_UserInformation_user_data {
    ASN1uint16_t protocol_discriminator;
    struct H323_UserInformation_user_data_user_information_user_information {
	ASN1uint32_t length;
	ASN1octet_t value[131];
    } user_information;
} H323_UserInformation_user_data;

typedef struct H235NonStandardParameter {
    ASN1objectidentifier_t nonStandardIdentifier;
    ASN1octetstring_t data;
} H235NonStandardParameter;

typedef struct DHset {
    ASN1bitstring_t halfkey;
    ASN1bitstring_t modSize;
    ASN1bitstring_t generator;
} DHset;

typedef struct TypedCertificate {
    ASN1objectidentifier_t type;
    ASN1octetstring_t certificate;
} TypedCertificate;

typedef struct AuthenticationMechanism {
    ASN1choice_t choice;
    union {
#	define dhExch_chosen 1
#	define pwdSymEnc_chosen 2
#	define pwdHash_chosen 3
#	define certSign_chosen 4
#	define AuthenticationMechanism_ipsec_chosen 5
#	define AuthenticationMechanism_tls_chosen 6
#	define AuthenticationMechanism_nonStandard_chosen 7
	H235NonStandardParameter nonStandard;
    } u;
} AuthenticationMechanism;

typedef struct ClearToken {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1objectidentifier_t tokenOID;
#   define ClearToken_timeStamp_present 0x80
    H235TimeStamp timeStamp;
#   define password_present 0x40
    H235Password password;
#   define dhkey_present 0x20
    DHset dhkey;
#   define challenge_present 0x10
    ChallengeString challenge;
#   define random_present 0x8
    RandomVal random;
#   define ClearToken_certificate_present 0x4
    TypedCertificate certificate;
#   define generalID_present 0x2
    Identifier generalID;
#   define ClearToken_nonStandard_present 0x1
    H235NonStandardParameter nonStandard;
} ClearToken;

typedef struct Params {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ranInt_present 0x80
    ASN1int32_t ranInt;
#   define iv8_present 0x40
    IV8 iv8;
} Params;

typedef struct EncodedGeneralToken {
    ASN1objectidentifier_t id;
    ClearToken type;
} EncodedGeneralToken;

typedef ClearToken PwdCertToken;

typedef struct EncodedPwdCertToken {
    ASN1objectidentifier_t id;
    PwdCertToken type;
} EncodedPwdCertToken;

typedef struct ReleaseCompleteReason {
    ASN1choice_t choice;
#   define noBandwidth_chosen 1
#   define gatekeeperResources_chosen 2
#   define unreachableDestination_chosen 3
#   define destinationRejection_chosen 4
#   define ReleaseCompleteReason_invalidRevision_chosen 5
#   define noPermission_chosen 6
#   define unreachableGatekeeper_chosen 7
#   define gatewayResources_chosen 8
#   define badFormatAddress_chosen 9
#   define adaptiveBusy_chosen 10
#   define inConf_chosen 11
#   define ReleaseCompleteReason_undefinedReason_chosen 12
#   define facilityCallDeflection_chosen 13
#   define securityDenied_chosen 14
#   define ReleaseCompleteReason_calledPartyNotRegistered_chosen 15
#   define callerNotregistered_chosen 16
} ReleaseCompleteReason;

typedef struct FacilityReason {
    ASN1choice_t choice;
#   define FacilityReason_routeCallToGatekeeper_chosen 1
#   define callForwarded_chosen 2
#   define routeCallToMC_chosen 3
#   define FacilityReason_undefinedReason_chosen 4
#   define conferenceListChoice_chosen 5
} FacilityReason;

typedef struct H221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} H221NonStandard;

typedef struct H225NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define H225NonStandardIdentifier_object_chosen 1
	ASN1objectidentifier_t object;
#	define H225NonStandardIdentifier_h221NonStandard_chosen 2
	H221NonStandard h221NonStandard;
    } u;
} H225NonStandardIdentifier;

typedef struct PublicTypeOfNumber {
    ASN1choice_t choice;
#   define PublicTypeOfNumber_unknown_chosen 1
#   define PublicTypeOfNumber_internationalNumber_chosen 2
#   define nationalNumber_chosen 3
#   define networkSpecificNumber_chosen 4
#   define subscriberNumber_chosen 5
#   define PublicTypeOfNumber_abbreviatedNumber_chosen 6
} PublicTypeOfNumber;

typedef struct PrivateTypeOfNumber {
    ASN1choice_t choice;
#   define PrivateTypeOfNumber_unknown_chosen 1
#   define level2RegionalNumber_chosen 2
#   define level1RegionalNumber_chosen 3
#   define pISNSpecificNumber_chosen 4
#   define localNumber_chosen 5
#   define PrivateTypeOfNumber_abbreviatedNumber_chosen 6
} PrivateTypeOfNumber;

typedef struct Q954Details {
    ASN1bool_t conferenceCalling;
    ASN1bool_t threePartyService;
} Q954Details;

typedef struct CallIdentifier {
    GloballyUniqueID guid;
} CallIdentifier;

typedef struct ICV {
    ASN1objectidentifier_t algorithmOID;
    ASN1bitstring_t icv;
} ICV;

typedef struct GatekeeperRejectReason {
    ASN1choice_t choice;
#   define GatekeeperRejectReason_resourceUnavailable_chosen 1
#   define terminalExcluded_chosen 2
#   define GatekeeperRejectReason_invalidRevision_chosen 3
#   define GatekeeperRejectReason_undefinedReason_chosen 4
#   define GatekeeperRejectReason_securityDenial_chosen 5
} GatekeeperRejectReason;

typedef struct RegistrationRejectReason {
    ASN1choice_t choice;
    union {
#	define discoveryRequired_chosen 1
#	define RegistrationRejectReason_invalidRevision_chosen 2
#	define invalidCallSignalAddress_chosen 3
#	define invalidRASAddress_chosen 4
#	define duplicateAlias_chosen 5
	PRegistrationRejectReason_duplicateAlias duplicateAlias;
#	define invalidTerminalType_chosen 6
#	define RegistrationRejectReason_undefinedReason_chosen 7
#	define transportNotSupported_chosen 8
#	define transportQOSNotSupported_chosen 9
#	define RegistrationRejectReason_resourceUnavailable_chosen 10
#	define invalidAlias_chosen 11
#	define RegistrationRejectReason_securityDenial_chosen 12
    } u;
} RegistrationRejectReason;

typedef struct UnregRequestReason {
    ASN1choice_t choice;
#   define reregistrationRequired_chosen 1
#   define ttlExpired_chosen 2
#   define UnregRequestReason_securityDenial_chosen 3
#   define UnregRequestReason_undefinedReason_chosen 4
} UnregRequestReason;

typedef struct UnregRejectReason {
    ASN1choice_t choice;
#   define notCurrentlyRegistered_chosen 1
#   define callInProgress_chosen 2
#   define UnregRejectReason_undefinedReason_chosen 3
#   define permissionDenied_chosen 4
#   define UnregRejectReason_securityDenial_chosen 5
} UnregRejectReason;

typedef struct CallType {
    ASN1choice_t choice;
#   define pointToPoint_chosen 1
#   define oneToN_chosen 2
#   define nToOne_chosen 3
#   define nToN_chosen 4
} CallType;

typedef struct CallModel {
    ASN1choice_t choice;
#   define direct_chosen 1
#   define gatekeeperRouted_chosen 2
} CallModel;

typedef struct TransportQOS {
    ASN1choice_t choice;
#   define endpointControlled_chosen 1
#   define gatekeeperControlled_chosen 2
#   define noControl_chosen 3
} TransportQOS;

typedef struct UUIEsRequested {
    ASN1bool_t setup;
    ASN1bool_t callProceeding;
    ASN1bool_t connect;
    ASN1bool_t alerting;
    ASN1bool_t userInformation;
    ASN1bool_t releaseComplete;
    ASN1bool_t facility;
    ASN1bool_t progress;
    ASN1bool_t empty;
} UUIEsRequested;

typedef struct AdmissionRejectReason {
    ASN1choice_t choice;
#   define AdmissionRejectReason_calledPartyNotRegistered_chosen 1
#   define AdmissionRejectReason_invalidPermission_chosen 2
#   define AdmissionRejectReason_requestDenied_chosen 3
#   define AdmissionRejectReason_undefinedReason_chosen 4
#   define callerNotRegistered_chosen 5
#   define AdmissionRejectReason_routeCallToGatekeeper_chosen 6
#   define invalidEndpointIdentifier_chosen 7
#   define AdmissionRejectReason_resourceUnavailable_chosen 8
#   define AdmissionRejectReason_securityDenial_chosen 9
#   define qosControlNotSupported_chosen 10
#   define incompleteAddress_chosen 11
} AdmissionRejectReason;

typedef struct BandRejectReason {
    ASN1choice_t choice;
#   define notBound_chosen 1
#   define invalidConferenceID_chosen 2
#   define BandRejectReason_invalidPermission_chosen 3
#   define insufficientResources_chosen 4
#   define BandRejectReason_invalidRevision_chosen 5
#   define BandRejectReason_undefinedReason_chosen 6
#   define BandRejectReason_securityDenial_chosen 7
} BandRejectReason;

typedef struct LocationRejectReason {
    ASN1choice_t choice;
#   define LocationRejectReason_notRegistered_chosen 1
#   define LocationRejectReason_invalidPermission_chosen 2
#   define LocationRejectReason_requestDenied_chosen 3
#   define LocationRejectReason_undefinedReason_chosen 4
#   define LocationRejectReason_securityDenial_chosen 5
} LocationRejectReason;

typedef struct DisengageReason {
    ASN1choice_t choice;
#   define forcedDrop_chosen 1
#   define normalDrop_chosen 2
#   define DisengageReason_undefinedReason_chosen 3
} DisengageReason;

typedef struct DisengageRejectReason {
    ASN1choice_t choice;
#   define DisengageRejectReason_notRegistered_chosen 1
#   define requestToDropOther_chosen 2
#   define DisengageRejectReason_securityDenial_chosen 3
} DisengageRejectReason;

typedef struct InfoRequestNakReason {
    ASN1choice_t choice;
#   define InfoRequestNakReason_notRegistered_chosen 1
#   define InfoRequestNakReason_securityDenial_chosen 2
#   define InfoRequestNakReason_undefinedReason_chosen 3
} InfoRequestNakReason;

typedef struct UnknownMessageResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define UnknownMessageResponse_tokens_present 0x80
    PUnknownMessageResponse_tokens tokens;
#   define UnknownMessageResponse_cryptoTokens_present 0x40
    PUnknownMessageResponse_cryptoTokens cryptoTokens;
#   define UnknownMessageResponse_integrityCheckValue_present 0x20
    ICV integrityCheckValue;
} UnknownMessageResponse;

typedef struct InfoRequestResponse_perCallInfo_Seq_tokens {
    PInfoRequestResponse_perCallInfo_Seq_tokens next;
    ClearToken value;
} InfoRequestResponse_perCallInfo_Seq_tokens_Element;

typedef struct ResourcesAvailableConfirm_tokens {
    PResourcesAvailableConfirm_tokens next;
    ClearToken value;
} ResourcesAvailableConfirm_tokens_Element;

typedef struct ResourcesAvailableIndicate_tokens {
    PResourcesAvailableIndicate_tokens next;
    ClearToken value;
} ResourcesAvailableIndicate_tokens_Element;

typedef struct RequestInProgress_tokens {
    PRequestInProgress_tokens next;
    ClearToken value;
} RequestInProgress_tokens_Element;

typedef struct UnknownMessageResponse_tokens {
    PUnknownMessageResponse_tokens next;
    ClearToken value;
} UnknownMessageResponse_tokens_Element;

typedef struct H225NonStandardMessage_tokens {
    PH225NonStandardMessage_tokens next;
    ClearToken value;
} H225NonStandardMessage_tokens_Element;

typedef struct InfoRequestNak_tokens {
    PInfoRequestNak_tokens next;
    ClearToken value;
} InfoRequestNak_tokens_Element;

typedef struct InfoRequestAck_tokens {
    PInfoRequestAck_tokens next;
    ClearToken value;
} InfoRequestAck_tokens_Element;

typedef struct InfoRequestResponse_tokens {
    PInfoRequestResponse_tokens next;
    ClearToken value;
} InfoRequestResponse_tokens_Element;

typedef struct InfoRequest_tokens {
    PInfoRequest_tokens next;
    ClearToken value;
} InfoRequest_tokens_Element;

typedef struct DisengageReject_tokens {
    PDisengageReject_tokens next;
    ClearToken value;
} DisengageReject_tokens_Element;

typedef struct DisengageConfirm_tokens {
    PDisengageConfirm_tokens next;
    ClearToken value;
} DisengageConfirm_tokens_Element;

typedef struct DisengageRequest_tokens {
    PDisengageRequest_tokens next;
    ClearToken value;
} DisengageRequest_tokens_Element;

typedef struct LocationReject_tokens {
    PLocationReject_tokens next;
    ClearToken value;
} LocationReject_tokens_Element;

typedef struct LocationConfirm_tokens {
    PLocationConfirm_tokens next;
    ClearToken value;
} LocationConfirm_tokens_Element;

typedef struct LocationRequest_tokens {
    PLocationRequest_tokens next;
    ClearToken value;
} LocationRequest_tokens_Element;

typedef struct BandwidthReject_tokens {
    PBandwidthReject_tokens next;
    ClearToken value;
} BandwidthReject_tokens_Element;

typedef struct BandwidthConfirm_tokens {
    PBandwidthConfirm_tokens next;
    ClearToken value;
} BandwidthConfirm_tokens_Element;

typedef struct BandwidthRequest_tokens {
    PBandwidthRequest_tokens next;
    ClearToken value;
} BandwidthRequest_tokens_Element;

typedef struct AdmissionReject_tokens {
    PAdmissionReject_tokens next;
    ClearToken value;
} AdmissionReject_tokens_Element;

typedef struct AdmissionConfirm_tokens {
    PAdmissionConfirm_tokens next;
    ClearToken value;
} AdmissionConfirm_tokens_Element;

typedef struct AdmissionRequest_tokens {
    PAdmissionRequest_tokens next;
    ClearToken value;
} AdmissionRequest_tokens_Element;

typedef struct UnregistrationReject_tokens {
    PUnregistrationReject_tokens next;
    ClearToken value;
} UnregistrationReject_tokens_Element;

typedef struct UnregistrationConfirm_tokens {
    PUnregistrationConfirm_tokens next;
    ClearToken value;
} UnregistrationConfirm_tokens_Element;

typedef struct UnregistrationRequest_tokens {
    PUnregistrationRequest_tokens next;
    ClearToken value;
} UnregistrationRequest_tokens_Element;

typedef struct RegistrationReject_tokens {
    PRegistrationReject_tokens next;
    ClearToken value;
} RegistrationReject_tokens_Element;

typedef struct RegistrationConfirm_tokens {
    PRegistrationConfirm_tokens next;
    ClearToken value;
} RegistrationConfirm_tokens_Element;

typedef struct RegistrationRequest_tokens {
    PRegistrationRequest_tokens next;
    ClearToken value;
} RegistrationRequest_tokens_Element;

typedef struct GatekeeperReject_tokens {
    PGatekeeperReject_tokens next;
    ClearToken value;
} GatekeeperReject_tokens_Element;

typedef struct GatekeeperConfirm_tokens {
    PGatekeeperConfirm_tokens next;
    ClearToken value;
} GatekeeperConfirm_tokens_Element;

typedef struct GatekeeperRequest_authenticationCapability {
    PGatekeeperRequest_authenticationCapability next;
    AuthenticationMechanism value;
} GatekeeperRequest_authenticationCapability_Element;

typedef struct GatekeeperRequest_tokens {
    PGatekeeperRequest_tokens next;
    ClearToken value;
} GatekeeperRequest_tokens_Element;

typedef struct Endpoint_tokens {
    PEndpoint_tokens next;
    ClearToken value;
} Endpoint_tokens_Element;

typedef struct Progress_UUIE_tokens {
    PProgress_UUIE_tokens next;
    ClearToken value;
} Progress_UUIE_tokens_Element;

typedef struct Facility_UUIE_tokens {
    PFacility_UUIE_tokens next;
    ClearToken value;
} Facility_UUIE_tokens_Element;

typedef struct Setup_UUIE_tokens {
    PSetup_UUIE_tokens next;
    ClearToken value;
} Setup_UUIE_tokens_Element;

typedef struct Connect_UUIE_tokens {
    PConnect_UUIE_tokens next;
    ClearToken value;
} Connect_UUIE_tokens_Element;

typedef struct CallProceeding_UUIE_tokens {
    PCallProceeding_UUIE_tokens next;
    ClearToken value;
} CallProceeding_UUIE_tokens_Element;

typedef struct Alerting_UUIE_tokens {
    PAlerting_UUIE_tokens next;
    ClearToken value;
} Alerting_UUIE_tokens_Element;

typedef struct SIGNED_EncodedGeneralToken {
    EncodedGeneralToken toBeSigned;
    ASN1objectidentifier_t algorithmOID;
    Params paramS;
    ASN1bitstring_t signature;
} SIGNED_EncodedGeneralToken;

typedef struct ENCRYPTED {
    ASN1objectidentifier_t algorithmOID;
    Params paramS;
    ASN1octetstring_t encryptedData;
} ENCRYPTED;

typedef struct HASHED {
    ASN1objectidentifier_t algorithmOID;
    Params paramS;
    ASN1bitstring_t hash;
} HASHED;

typedef struct SIGNED_EncodedPwdCertToken {
    EncodedPwdCertToken toBeSigned;
    ASN1objectidentifier_t algorithmOID;
    Params paramS;
    ASN1bitstring_t signature;
} SIGNED_EncodedPwdCertToken;

typedef struct Information_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ProtocolIdentifier protocolIdentifier;
#   define Information_UUIE_callIdentifier_present 0x80
    CallIdentifier callIdentifier;
} Information_UUIE;

typedef struct ReleaseComplete_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
#   define ReleaseComplete_UUIE_reason_present 0x80
    ReleaseCompleteReason reason;
#   define ReleaseComplete_UUIE_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
} ReleaseComplete_UUIE;

typedef struct VendorIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H221NonStandard vendor;
#   define productId_present 0x80
    struct VendorIdentifier_productId_productId {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } productId;
#   define versionId_present 0x40
    struct VendorIdentifier_versionId_versionId {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } versionId;
} VendorIdentifier;

typedef struct H225NonStandardParameter {
    H225NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} H225NonStandardParameter;

typedef struct PublicPartyNumber {
    PublicTypeOfNumber publicTypeOfNumber;
    NumberDigits publicNumberDigits;
} PublicPartyNumber;

typedef struct PrivatePartyNumber {
    PrivateTypeOfNumber privateTypeOfNumber;
    NumberDigits privateNumberDigits;
} PrivatePartyNumber;

typedef struct SecurityServiceMode {
    ASN1choice_t choice;
    union {
#	define SecurityServiceMode_nonStandard_chosen 1
	H225NonStandardParameter nonStandard;
#	define SecurityServiceMode_none_chosen 2
#	define SecurityServiceMode_default_chosen 3
    } u;
} SecurityServiceMode;

typedef struct SecurityCapabilities {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define SecurityCapabilities_nonStandard_present 0x80
    H225NonStandardParameter nonStandard;
    SecurityServiceMode encryption;
    SecurityServiceMode authenticaton;
    SecurityServiceMode integrity;
} SecurityCapabilities;

typedef struct H245Security {
    ASN1choice_t choice;
    union {
#	define H245Security_nonStandard_chosen 1
	H225NonStandardParameter nonStandard;
#	define noSecurity_chosen 2
#	define H245Security_tls_chosen 3
	SecurityCapabilities tls;
#	define H245Security_ipsec_chosen 4
	SecurityCapabilities ipsec;
    } u;
} H245Security;

typedef struct QseriesOptions {
    ASN1bool_t q932Full;
    ASN1bool_t q951Full;
    ASN1bool_t q952Full;
    ASN1bool_t q953Full;
    ASN1bool_t q955Full;
    ASN1bool_t q956Full;
    ASN1bool_t q957Full;
    Q954Details q954Info;
} QseriesOptions;

typedef struct EncryptIntAlg {
    ASN1choice_t choice;
    union {
#	define EncryptIntAlg_nonStandard_chosen 1
	H225NonStandardParameter nonStandard;
#	define isoAlgorithm_chosen 2
	ASN1objectidentifier_t isoAlgorithm;
    } u;
} EncryptIntAlg;

typedef struct NonIsoIntegrityMechanism {
    ASN1choice_t choice;
    union {
#	define hMAC_MD5_chosen 1
#	define hMAC_iso10118_2_s_chosen 2
	EncryptIntAlg hMAC_iso10118_2_s;
#	define hMAC_iso10118_2_l_chosen 3
	EncryptIntAlg hMAC_iso10118_2_l;
#	define hMAC_iso10118_3_chosen 4
	ASN1objectidentifier_t hMAC_iso10118_3;
    } u;
} NonIsoIntegrityMechanism;

typedef struct IntegrityMechanism {
    ASN1choice_t choice;
    union {
#	define IntegrityMechanism_nonStandard_chosen 1
	H225NonStandardParameter nonStandard;
#	define digSig_chosen 2
#	define iso9797_chosen 3
	ASN1objectidentifier_t iso9797;
#	define nonIsoIM_chosen 4
	NonIsoIntegrityMechanism nonIsoIM;
    } u;
} IntegrityMechanism;

typedef ClearToken FastStartToken;

typedef struct EncodedFastStartToken {
    ASN1objectidentifier_t id;
    FastStartToken type;
} EncodedFastStartToken;

typedef struct DataRate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define DataRate_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    BandWidth channelRate;
#   define channelMultiplier_present 0x40
    ASN1uint16_t channelMultiplier;
} DataRate;

typedef struct GatekeeperReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define GatekeeperReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define GatekeeperReject_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
    GatekeeperRejectReason rejectReason;
#   define GatekeeperReject_alternateGatekeeper_present 0x8000
    PGatekeeperReject_alternateGatekeeper alternateGatekeeper;
#   define GatekeeperReject_altGKisPermanent_present 0x4000
    ASN1bool_t altGKisPermanent;
#   define GatekeeperReject_tokens_present 0x2000
    PGatekeeperReject_tokens tokens;
#   define GatekeeperReject_cryptoTokens_present 0x1000
    PGatekeeperReject_cryptoTokens cryptoTokens;
#   define GatekeeperReject_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
} GatekeeperReject;

typedef struct RegistrationConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define RegistrationConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    PRegistrationConfirm_callSignalAddress callSignalAddress;
#   define RegistrationConfirm_terminalAlias_present 0x40
    PRegistrationConfirm_terminalAlias terminalAlias;
#   define RegistrationConfirm_gatekeeperIdentifier_present 0x20
    GatekeeperIdentifier gatekeeperIdentifier;
    EndpointIdentifier endpointIdentifier;
#   define RegistrationConfirm_alternateGatekeeper_present 0x8000
    PRegistrationConfirm_alternateGatekeeper alternateGatekeeper;
#   define RegistrationConfirm_timeToLive_present 0x4000
    TimeToLive timeToLive;
#   define RegistrationConfirm_tokens_present 0x2000
    PRegistrationConfirm_tokens tokens;
#   define RegistrationConfirm_cryptoTokens_present 0x1000
    PRegistrationConfirm_cryptoTokens cryptoTokens;
#   define RegistrationConfirm_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
#   define RegistrationConfirm_willRespondToIRR_present 0x400
    ASN1bool_t willRespondToIRR;
#   define preGrantedARQ_present 0x200
    RegistrationConfirm_preGrantedARQ preGrantedARQ;
} RegistrationConfirm;

typedef struct RegistrationReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define RegistrationReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    RegistrationRejectReason rejectReason;
#   define RegistrationReject_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
#   define RegistrationReject_alternateGatekeeper_present 0x8000
    PRegistrationReject_alternateGatekeeper alternateGatekeeper;
#   define RegistrationReject_altGKisPermanent_present 0x4000
    ASN1bool_t altGKisPermanent;
#   define RegistrationReject_tokens_present 0x2000
    PRegistrationReject_tokens tokens;
#   define RegistrationReject_cryptoTokens_present 0x1000
    PRegistrationReject_cryptoTokens cryptoTokens;
#   define RegistrationReject_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
} RegistrationReject;

typedef struct UnregistrationRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    PUnregistrationRequest_callSignalAddress callSignalAddress;
#   define UnregistrationRequest_endpointAlias_present 0x80
    PUnregistrationRequest_endpointAlias endpointAlias;
#   define UnregistrationRequest_nonStandardData_present 0x40
    H225NonStandardParameter nonStandardData;
#   define UnregistrationRequest_endpointIdentifier_present 0x20
    EndpointIdentifier endpointIdentifier;
#   define UnregistrationRequest_alternateEndpoints_present 0x8000
    PUnregistrationRequest_alternateEndpoints alternateEndpoints;
#   define UnregistrationRequest_gatekeeperIdentifier_present 0x4000
    GatekeeperIdentifier gatekeeperIdentifier;
#   define UnregistrationRequest_tokens_present 0x2000
    PUnregistrationRequest_tokens tokens;
#   define UnregistrationRequest_cryptoTokens_present 0x1000
    PUnregistrationRequest_cryptoTokens cryptoTokens;
#   define UnregistrationRequest_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
#   define UnregistrationRequest_reason_present 0x400
    UnregRequestReason reason;
} UnregistrationRequest;

typedef struct UnregistrationConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
#   define UnregistrationConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define UnregistrationConfirm_tokens_present 0x8000
    PUnregistrationConfirm_tokens tokens;
#   define UnregistrationConfirm_cryptoTokens_present 0x4000
    PUnregistrationConfirm_cryptoTokens cryptoTokens;
#   define UnregistrationConfirm_integrityCheckValue_present 0x2000
    ICV integrityCheckValue;
} UnregistrationConfirm;

typedef struct UnregistrationReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    UnregRejectReason rejectReason;
#   define UnregistrationReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define UnregistrationReject_alternateGatekeeper_present 0x8000
    PUnregistrationReject_alternateGatekeeper alternateGatekeeper;
#   define UnregistrationReject_altGKisPermanent_present 0x4000
    ASN1bool_t altGKisPermanent;
#   define UnregistrationReject_tokens_present 0x2000
    PUnregistrationReject_tokens tokens;
#   define UnregistrationReject_cryptoTokens_present 0x1000
    PUnregistrationReject_cryptoTokens cryptoTokens;
#   define UnregistrationReject_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
} UnregistrationReject;

typedef struct AdmissionReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    AdmissionRejectReason rejectReason;
#   define AdmissionReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define AdmissionReject_alternateGatekeeper_present 0x8000
    PAdmissionReject_alternateGatekeeper alternateGatekeeper;
#   define AdmissionReject_altGKisPermanent_present 0x4000
    ASN1bool_t altGKisPermanent;
#   define AdmissionReject_tokens_present 0x2000
    PAdmissionReject_tokens tokens;
#   define AdmissionReject_cryptoTokens_present 0x1000
    PAdmissionReject_cryptoTokens cryptoTokens;
#   define AdmissionReject_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
} AdmissionReject;

typedef struct BandwidthRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    EndpointIdentifier endpointIdentifier;
    ConferenceIdentifier conferenceID;
    CallReferenceValue callReferenceValue;
#   define callType_present 0x80
    CallType callType;
    BandWidth bandWidth;
#   define BandwidthRequest_nonStandardData_present 0x40
    H225NonStandardParameter nonStandardData;
#   define BandwidthRequest_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define BandwidthRequest_gatekeeperIdentifier_present 0x4000
    GatekeeperIdentifier gatekeeperIdentifier;
#   define BandwidthRequest_tokens_present 0x2000
    PBandwidthRequest_tokens tokens;
#   define BandwidthRequest_cryptoTokens_present 0x1000
    PBandwidthRequest_cryptoTokens cryptoTokens;
#   define BandwidthRequest_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
#   define BandwidthRequest_answeredCall_present 0x400
    ASN1bool_t answeredCall;
} BandwidthRequest;

typedef struct BandwidthConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    BandWidth bandWidth;
#   define BandwidthConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define BandwidthConfirm_tokens_present 0x8000
    PBandwidthConfirm_tokens tokens;
#   define BandwidthConfirm_cryptoTokens_present 0x4000
    PBandwidthConfirm_cryptoTokens cryptoTokens;
#   define BandwidthConfirm_integrityCheckValue_present 0x2000
    ICV integrityCheckValue;
} BandwidthConfirm;

typedef struct BandwidthReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    BandRejectReason rejectReason;
    BandWidth allowedBandWidth;
#   define BandwidthReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define BandwidthReject_alternateGatekeeper_present 0x8000
    PBandwidthReject_alternateGatekeeper alternateGatekeeper;
#   define BandwidthReject_altGKisPermanent_present 0x4000
    ASN1bool_t altGKisPermanent;
#   define BandwidthReject_tokens_present 0x2000
    PBandwidthReject_tokens tokens;
#   define BandwidthReject_cryptoTokens_present 0x1000
    PBandwidthReject_cryptoTokens cryptoTokens;
#   define BandwidthReject_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
} BandwidthReject;

typedef struct LocationReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    LocationRejectReason rejectReason;
#   define LocationReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define LocationReject_alternateGatekeeper_present 0x8000
    PLocationReject_alternateGatekeeper alternateGatekeeper;
#   define LocationReject_altGKisPermanent_present 0x4000
    ASN1bool_t altGKisPermanent;
#   define LocationReject_tokens_present 0x2000
    PLocationReject_tokens tokens;
#   define LocationReject_cryptoTokens_present 0x1000
    PLocationReject_cryptoTokens cryptoTokens;
#   define LocationReject_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
} LocationReject;

typedef struct DisengageRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    EndpointIdentifier endpointIdentifier;
    ConferenceIdentifier conferenceID;
    CallReferenceValue callReferenceValue;
    DisengageReason disengageReason;
#   define DisengageRequest_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define DisengageRequest_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define DisengageRequest_gatekeeperIdentifier_present 0x4000
    GatekeeperIdentifier gatekeeperIdentifier;
#   define DisengageRequest_tokens_present 0x2000
    PDisengageRequest_tokens tokens;
#   define DisengageRequest_cryptoTokens_present 0x1000
    PDisengageRequest_cryptoTokens cryptoTokens;
#   define DisengageRequest_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
#   define DisengageRequest_answeredCall_present 0x400
    ASN1bool_t answeredCall;
} DisengageRequest;

typedef struct DisengageConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
#   define DisengageConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define DisengageConfirm_tokens_present 0x8000
    PDisengageConfirm_tokens tokens;
#   define DisengageConfirm_cryptoTokens_present 0x4000
    PDisengageConfirm_cryptoTokens cryptoTokens;
#   define DisengageConfirm_integrityCheckValue_present 0x2000
    ICV integrityCheckValue;
} DisengageConfirm;

typedef struct DisengageReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    DisengageRejectReason rejectReason;
#   define DisengageReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define DisengageReject_alternateGatekeeper_present 0x8000
    PDisengageReject_alternateGatekeeper alternateGatekeeper;
#   define DisengageReject_altGKisPermanent_present 0x4000
    ASN1bool_t altGKisPermanent;
#   define DisengageReject_tokens_present 0x2000
    PDisengageReject_tokens tokens;
#   define DisengageReject_cryptoTokens_present 0x1000
    PDisengageReject_cryptoTokens cryptoTokens;
#   define DisengageReject_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
} DisengageReject;

typedef struct InfoRequestAck {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define InfoRequestAck_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define InfoRequestAck_tokens_present 0x40
    PInfoRequestAck_tokens tokens;
#   define InfoRequestAck_cryptoTokens_present 0x20
    PInfoRequestAck_cryptoTokens cryptoTokens;
#   define InfoRequestAck_integrityCheckValue_present 0x10
    ICV integrityCheckValue;
} InfoRequestAck;

typedef struct InfoRequestNak {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define InfoRequestNak_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    InfoRequestNakReason nakReason;
#   define InfoRequestNak_alternateGatekeeper_present 0x40
    PInfoRequestNak_alternateGatekeeper alternateGatekeeper;
    ASN1bool_t altGKisPermanent;
#   define InfoRequestNak_tokens_present 0x20
    PInfoRequestNak_tokens tokens;
#   define InfoRequestNak_cryptoTokens_present 0x10
    PInfoRequestNak_cryptoTokens cryptoTokens;
#   define InfoRequestNak_integrityCheckValue_present 0x8
    ICV integrityCheckValue;
} InfoRequestNak;

typedef struct H225NonStandardMessage {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    H225NonStandardParameter nonStandardData;
#   define H225NonStandardMessage_tokens_present 0x80
    PH225NonStandardMessage_tokens tokens;
#   define H225NonStandardMessage_cryptoTokens_present 0x40
    PH225NonStandardMessage_cryptoTokens cryptoTokens;
#   define H225NonStandardMessage_integrityCheckValue_present 0x20
    ICV integrityCheckValue;
} H225NonStandardMessage;

typedef struct RequestInProgress {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define RequestInProgress_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define RequestInProgress_tokens_present 0x40
    PRequestInProgress_tokens tokens;
#   define RequestInProgress_cryptoTokens_present 0x20
    PRequestInProgress_cryptoTokens cryptoTokens;
#   define RequestInProgress_integrityCheckValue_present 0x10
    ICV integrityCheckValue;
    ASN1uint16_t delay;
} RequestInProgress;

typedef struct ResourcesAvailableIndicate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define ResourcesAvailableIndicate_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    EndpointIdentifier endpointIdentifier;
    PResourcesAvailableIndicate_protocols protocols;
    ASN1bool_t almostOutOfResources;
#   define ResourcesAvailableIndicate_tokens_present 0x40
    PResourcesAvailableIndicate_tokens tokens;
#   define ResourcesAvailableIndicate_cryptoTokens_present 0x20
    PResourcesAvailableIndicate_cryptoTokens cryptoTokens;
#   define ResourcesAvailableIndicate_integrityCheckValue_present 0x10
    ICV integrityCheckValue;
} ResourcesAvailableIndicate;

typedef struct ResourcesAvailableConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define ResourcesAvailableConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define ResourcesAvailableConfirm_tokens_present 0x40
    PResourcesAvailableConfirm_tokens tokens;
#   define ResourcesAvailableConfirm_cryptoTokens_present 0x20
    PResourcesAvailableConfirm_cryptoTokens cryptoTokens;
#   define ResourcesAvailableConfirm_integrityCheckValue_present 0x10
    ICV integrityCheckValue;
} ResourcesAvailableConfirm;

typedef struct GatekeeperConfirm_integrity {
    PGatekeeperConfirm_integrity next;
    IntegrityMechanism value;
} GatekeeperConfirm_integrity_Element;

typedef struct GatekeeperRequest_integrity {
    PGatekeeperRequest_integrity next;
    IntegrityMechanism value;
} GatekeeperRequest_integrity_Element;

typedef struct CryptoH323Token_cryptoGKPwdHash {
    GatekeeperIdentifier gatekeeperId;
    H235TimeStamp timeStamp;
    HASHED token;
} CryptoH323Token_cryptoGKPwdHash;

typedef struct NonStandardProtocol_dataRatesSupported {
    PNonStandardProtocol_dataRatesSupported next;
    DataRate value;
} NonStandardProtocol_dataRatesSupported_Element;

typedef struct T120OnlyCaps_dataRatesSupported {
    PT120OnlyCaps_dataRatesSupported next;
    DataRate value;
} T120OnlyCaps_dataRatesSupported_Element;

typedef struct VoiceCaps_dataRatesSupported {
    PVoiceCaps_dataRatesSupported next;
    DataRate value;
} VoiceCaps_dataRatesSupported_Element;

typedef struct H324Caps_dataRatesSupported {
    PH324Caps_dataRatesSupported next;
    DataRate value;
} H324Caps_dataRatesSupported_Element;

typedef struct H323Caps_dataRatesSupported {
    PH323Caps_dataRatesSupported next;
    DataRate value;
} H323Caps_dataRatesSupported_Element;

typedef struct H322Caps_dataRatesSupported {
    PH322Caps_dataRatesSupported next;
    DataRate value;
} H322Caps_dataRatesSupported_Element;

typedef struct H321Caps_dataRatesSupported {
    PH321Caps_dataRatesSupported next;
    DataRate value;
} H321Caps_dataRatesSupported_Element;

typedef struct H320Caps_dataRatesSupported {
    PH320Caps_dataRatesSupported next;
    DataRate value;
} H320Caps_dataRatesSupported_Element;

typedef struct H310Caps_dataRatesSupported {
    PH310Caps_dataRatesSupported next;
    DataRate value;
} H310Caps_dataRatesSupported_Element;

typedef struct Setup_UUIE_h245SecurityCapability {
    PSetup_UUIE_h245SecurityCapability next;
    H245Security value;
} Setup_UUIE_h245SecurityCapability_Element;

typedef struct H323_UU_PDU_nonStandardControl {
    PH323_UU_PDU_nonStandardControl next;
    H225NonStandardParameter value;
} H323_UU_PDU_nonStandardControl_Element;

typedef struct CryptoToken_cryptoHashedToken {
    ASN1objectidentifier_t tokenOID;
    ClearToken hashedVals;
    HASHED token;
} CryptoToken_cryptoHashedToken;

typedef struct CryptoToken_cryptoSignedToken {
    ASN1objectidentifier_t tokenOID;
    SIGNED_EncodedGeneralToken token;
} CryptoToken_cryptoSignedToken;

typedef struct CryptoToken_cryptoEncryptedToken {
    ASN1objectidentifier_t tokenOID;
    ENCRYPTED token;
} CryptoToken_cryptoEncryptedToken;

typedef struct CryptoToken {
    ASN1choice_t choice;
    union {
#	define cryptoEncryptedToken_chosen 1
	CryptoToken_cryptoEncryptedToken cryptoEncryptedToken;
#	define cryptoSignedToken_chosen 2
	CryptoToken_cryptoSignedToken cryptoSignedToken;
#	define cryptoHashedToken_chosen 3
	CryptoToken_cryptoHashedToken cryptoHashedToken;
#	define cryptoPwdEncr_chosen 4
	ENCRYPTED cryptoPwdEncr;
    } u;
} CryptoToken;

typedef struct SIGNED_EncodedFastStartToken {
    EncodedFastStartToken toBeSigned;
    ASN1objectidentifier_t algorithmOID;
    Params paramS;
    ASN1bitstring_t signature;
} SIGNED_EncodedFastStartToken;

typedef struct TransportAddress {
    ASN1choice_t choice;
    union {
#	define ipAddress_chosen 1
	TransportAddress_ipAddress ipAddress;
#	define ipSourceRoute_chosen 2
	TransportAddress_ipSourceRoute ipSourceRoute;
#	define ipxAddress_chosen 3
	TransportAddress_ipxAddress ipxAddress;
#	define ip6Address_chosen 4
	TransportAddress_ip6Address ip6Address;
#	define TransportAddress_netBios_chosen 5
	struct TransportAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define TransportAddress_nsap_chosen 6
	struct TransportAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define TransportAddress_nonStandardAddress_chosen 7
	H225NonStandardParameter nonStandardAddress;
    } u;
} TransportAddress;

typedef struct GatewayInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define protocol_present 0x80
    PGatewayInfo_protocol protocol;
#   define GatewayInfo_nonStandardData_present 0x40
    H225NonStandardParameter nonStandardData;
} GatewayInfo;

typedef struct H310Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H310Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H310Caps_dataRatesSupported_present 0x8000
    PH310Caps_dataRatesSupported dataRatesSupported;
#   define H310Caps_supportedPrefixes_present 0x4000
    PH310Caps_supportedPrefixes supportedPrefixes;
} H310Caps;

typedef struct H320Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H320Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H320Caps_dataRatesSupported_present 0x8000
    PH320Caps_dataRatesSupported dataRatesSupported;
#   define H320Caps_supportedPrefixes_present 0x4000
    PH320Caps_supportedPrefixes supportedPrefixes;
} H320Caps;

typedef struct H321Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H321Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H321Caps_dataRatesSupported_present 0x8000
    PH321Caps_dataRatesSupported dataRatesSupported;
#   define H321Caps_supportedPrefixes_present 0x4000
    PH321Caps_supportedPrefixes supportedPrefixes;
} H321Caps;

typedef struct H322Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H322Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H322Caps_dataRatesSupported_present 0x8000
    PH322Caps_dataRatesSupported dataRatesSupported;
#   define H322Caps_supportedPrefixes_present 0x4000
    PH322Caps_supportedPrefixes supportedPrefixes;
} H322Caps;

typedef struct H323Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H323Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H323Caps_dataRatesSupported_present 0x8000
    PH323Caps_dataRatesSupported dataRatesSupported;
#   define H323Caps_supportedPrefixes_present 0x4000
    PH323Caps_supportedPrefixes supportedPrefixes;
} H323Caps;

typedef struct H324Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H324Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H324Caps_dataRatesSupported_present 0x8000
    PH324Caps_dataRatesSupported dataRatesSupported;
#   define H324Caps_supportedPrefixes_present 0x4000
    PH324Caps_supportedPrefixes supportedPrefixes;
} H324Caps;

typedef struct VoiceCaps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define VoiceCaps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define VoiceCaps_dataRatesSupported_present 0x8000
    PVoiceCaps_dataRatesSupported dataRatesSupported;
#   define VoiceCaps_supportedPrefixes_present 0x4000
    PVoiceCaps_supportedPrefixes supportedPrefixes;
} VoiceCaps;

typedef struct T120OnlyCaps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define T120OnlyCaps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define T120OnlyCaps_dataRatesSupported_present 0x8000
    PT120OnlyCaps_dataRatesSupported dataRatesSupported;
#   define T120OnlyCaps_supportedPrefixes_present 0x4000
    PT120OnlyCaps_supportedPrefixes supportedPrefixes;
} T120OnlyCaps;

typedef struct NonStandardProtocol {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define NonStandardProtocol_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define NonStandardProtocol_dataRatesSupported_present 0x40
    PNonStandardProtocol_dataRatesSupported dataRatesSupported;
    PNonStandardProtocol_supportedPrefixes supportedPrefixes;
} NonStandardProtocol;

typedef struct McuInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define McuInfo_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
} McuInfo;

typedef struct TerminalInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define TerminalInfo_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
} TerminalInfo;

typedef struct GatekeeperInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define GatekeeperInfo_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
} GatekeeperInfo;

typedef struct PartyNumber {
    ASN1choice_t choice;
    union {
#	define publicNumber_chosen 1
	PublicPartyNumber publicNumber;
#	define dataPartyNumber_chosen 2
	NumberDigits dataPartyNumber;
#	define telexPartyNumber_chosen 3
	NumberDigits telexPartyNumber;
#	define privateNumber_chosen 4
	PrivatePartyNumber privateNumber;
#	define nationalStandardPartyNumber_chosen 5
	NumberDigits nationalStandardPartyNumber;
    } u;
} PartyNumber;

typedef struct AlternateGK {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    TransportAddress rasAddress;
#   define AlternateGK_gatekeeperIdentifier_present 0x80
    GatekeeperIdentifier gatekeeperIdentifier;
    ASN1bool_t needToRegister;
    ASN1uint16_t priority;
} AlternateGK;

typedef struct GatekeeperConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define GatekeeperConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define GatekeeperConfirm_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
    TransportAddress rasAddress;
#   define GatekeeperConfirm_alternateGatekeeper_present 0x8000
    PGatekeeperConfirm_alternateGatekeeper alternateGatekeeper;
#   define authenticationMode_present 0x4000
    AuthenticationMechanism authenticationMode;
#   define GatekeeperConfirm_tokens_present 0x2000
    PGatekeeperConfirm_tokens tokens;
#   define GatekeeperConfirm_cryptoTokens_present 0x1000
    PGatekeeperConfirm_cryptoTokens cryptoTokens;
#   define algorithmOID_present 0x800
    ASN1objectidentifier_t algorithmOID;
#   define GatekeeperConfirm_integrity_present 0x400
    PGatekeeperConfirm_integrity integrity;
#   define GatekeeperConfirm_integrityCheckValue_present 0x200
    ICV integrityCheckValue;
} GatekeeperConfirm;

typedef struct AdmissionRequest {
    union {
	ASN1uint32_t bit_mask;
	ASN1octet_t o[3];
    };
    RequestSeqNum requestSeqNum;
    CallType callType;
#   define callModel_present 0x80
    CallModel callModel;
    EndpointIdentifier endpointIdentifier;
#   define AdmissionRequest_destinationInfo_present 0x40
    PAdmissionRequest_destinationInfo destinationInfo;
#   define AdmissionRequest_destCallSignalAddress_present 0x20
    TransportAddress destCallSignalAddress;
#   define AdmissionRequest_destExtraCallInfo_present 0x10
    PAdmissionRequest_destExtraCallInfo destExtraCallInfo;
    PAdmissionRequest_srcInfo srcInfo;
#   define srcCallSignalAddress_present 0x8
    TransportAddress srcCallSignalAddress;
    BandWidth bandWidth;
    CallReferenceValue callReferenceValue;
#   define AdmissionRequest_nonStandardData_present 0x4
    H225NonStandardParameter nonStandardData;
#   define AdmissionRequest_callServices_present 0x2
    QseriesOptions callServices;
    ConferenceIdentifier conferenceID;
    ASN1bool_t activeMC;
    ASN1bool_t answerCall;
#   define AdmissionRequest_canMapAlias_present 0x8000
    ASN1bool_t canMapAlias;
#   define AdmissionRequest_callIdentifier_present 0x4000
    CallIdentifier callIdentifier;
#   define srcAlternatives_present 0x2000
    PAdmissionRequest_srcAlternatives srcAlternatives;
#   define destAlternatives_present 0x1000
    PAdmissionRequest_destAlternatives destAlternatives;
#   define AdmissionRequest_gatekeeperIdentifier_present 0x800
    GatekeeperIdentifier gatekeeperIdentifier;
#   define AdmissionRequest_tokens_present 0x400
    PAdmissionRequest_tokens tokens;
#   define AdmissionRequest_cryptoTokens_present 0x200
    PAdmissionRequest_cryptoTokens cryptoTokens;
#   define AdmissionRequest_integrityCheckValue_present 0x100
    ICV integrityCheckValue;
#   define AdmissionRequest_transportQOS_present 0x800000
    TransportQOS transportQOS;
#   define AdmissionRequest_willSupplyUUIEs_present 0x400000
    ASN1bool_t willSupplyUUIEs;
} AdmissionRequest;

typedef struct LocationRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
#   define LocationRequest_endpointIdentifier_present 0x80
    EndpointIdentifier endpointIdentifier;
    PLocationRequest_destinationInfo destinationInfo;
#   define LocationRequest_nonStandardData_present 0x40
    H225NonStandardParameter nonStandardData;
    TransportAddress replyAddress;
#   define sourceInfo_present 0x8000
    PLocationRequest_sourceInfo sourceInfo;
#   define LocationRequest_canMapAlias_present 0x4000
    ASN1bool_t canMapAlias;
#   define LocationRequest_gatekeeperIdentifier_present 0x2000
    GatekeeperIdentifier gatekeeperIdentifier;
#   define LocationRequest_tokens_present 0x1000
    PLocationRequest_tokens tokens;
#   define LocationRequest_cryptoTokens_present 0x800
    PLocationRequest_cryptoTokens cryptoTokens;
#   define LocationRequest_integrityCheckValue_present 0x400
    ICV integrityCheckValue;
} LocationRequest;

typedef struct InfoRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    CallReferenceValue callReferenceValue;
#   define InfoRequest_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define replyAddress_present 0x40
    TransportAddress replyAddress;
#   define InfoRequest_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define InfoRequest_tokens_present 0x4000
    PInfoRequest_tokens tokens;
#   define InfoRequest_cryptoTokens_present 0x2000
    PInfoRequest_cryptoTokens cryptoTokens;
#   define InfoRequest_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
#   define InfoRequest_uuiesRequested_present 0x800
    UUIEsRequested uuiesRequested;
} InfoRequest;

typedef struct TransportChannelInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define sendAddress_present 0x80
    TransportAddress sendAddress;
#   define recvAddress_present 0x40
    TransportAddress recvAddress;
} TransportChannelInfo;

typedef struct RTPSession {
    TransportChannelInfo rtpAddress;
    TransportChannelInfo rtcpAddress;
    ASN1ztcharstring_t cname;
    ASN1uint32_t ssrc;
    ASN1uint16_t sessionId;
    PRTPSession_associatedSessionIds associatedSessionIds;
} RTPSession;

typedef struct InfoRequestResponse_perCallInfo_Seq_data {
    PInfoRequestResponse_perCallInfo_Seq_data next;
    TransportChannelInfo value;
} InfoRequestResponse_perCallInfo_Seq_data_Element;

typedef struct InfoRequestResponse_perCallInfo_Seq_video {
    PInfoRequestResponse_perCallInfo_Seq_video next;
    RTPSession value;
} InfoRequestResponse_perCallInfo_Seq_video_Element;

typedef struct InfoRequestResponse_perCallInfo_Seq_audio {
    PInfoRequestResponse_perCallInfo_Seq_audio next;
    RTPSession value;
} InfoRequestResponse_perCallInfo_Seq_audio_Element;

typedef struct InfoRequestResponse_perCallInfo_Seq {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define InfoRequestResponse_perCallInfo_Seq_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    CallReferenceValue callReferenceValue;
    ConferenceIdentifier conferenceID;
#   define originator_present 0x40
    ASN1bool_t originator;
#   define audio_present 0x20
    PInfoRequestResponse_perCallInfo_Seq_audio audio;
#   define video_present 0x10
    PInfoRequestResponse_perCallInfo_Seq_video video;
#   define data_present 0x8
    PInfoRequestResponse_perCallInfo_Seq_data data;
    TransportChannelInfo h245;
    TransportChannelInfo callSignaling;
    CallType callType;
    BandWidth bandWidth;
    CallModel callModel;
#   define InfoRequestResponse_perCallInfo_Seq_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define InfoRequestResponse_perCallInfo_Seq_tokens_present 0x4000
    PInfoRequestResponse_perCallInfo_Seq_tokens tokens;
#   define InfoRequestResponse_perCallInfo_Seq_cryptoTokens_present 0x2000
    PInfoRequestResponse_perCallInfo_Seq_cryptoTokens cryptoTokens;
#   define substituteConfIDs_present 0x1000
    PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs substituteConfIDs;
#   define pdu_present 0x800
    PInfoRequestResponse_perCallInfo_Seq_pdu pdu;
} InfoRequestResponse_perCallInfo_Seq;

typedef struct InfoRequestNak_alternateGatekeeper {
    PInfoRequestNak_alternateGatekeeper next;
    AlternateGK value;
} InfoRequestNak_alternateGatekeeper_Element;

typedef struct InfoRequestResponse_perCallInfo {
    PInfoRequestResponse_perCallInfo next;
    InfoRequestResponse_perCallInfo_Seq value;
} InfoRequestResponse_perCallInfo_Element;

typedef struct InfoRequestResponse_callSignalAddress {
    PInfoRequestResponse_callSignalAddress next;
    TransportAddress value;
} InfoRequestResponse_callSignalAddress_Element;

typedef struct DisengageReject_alternateGatekeeper {
    PDisengageReject_alternateGatekeeper next;
    AlternateGK value;
} DisengageReject_alternateGatekeeper_Element;

typedef struct LocationReject_alternateGatekeeper {
    PLocationReject_alternateGatekeeper next;
    AlternateGK value;
} LocationReject_alternateGatekeeper_Element;

typedef struct BandwidthReject_alternateGatekeeper {
    PBandwidthReject_alternateGatekeeper next;
    AlternateGK value;
} BandwidthReject_alternateGatekeeper_Element;

typedef struct AdmissionReject_alternateGatekeeper {
    PAdmissionReject_alternateGatekeeper next;
    AlternateGK value;
} AdmissionReject_alternateGatekeeper_Element;

typedef struct UnregistrationReject_alternateGatekeeper {
    PUnregistrationReject_alternateGatekeeper next;
    AlternateGK value;
} UnregistrationReject_alternateGatekeeper_Element;

typedef struct UnregistrationRequest_callSignalAddress {
    PUnregistrationRequest_callSignalAddress next;
    TransportAddress value;
} UnregistrationRequest_callSignalAddress_Element;

typedef struct RegistrationReject_alternateGatekeeper {
    PRegistrationReject_alternateGatekeeper next;
    AlternateGK value;
} RegistrationReject_alternateGatekeeper_Element;

typedef struct RegistrationConfirm_alternateGatekeeper {
    PRegistrationConfirm_alternateGatekeeper next;
    AlternateGK value;
} RegistrationConfirm_alternateGatekeeper_Element;

typedef struct RegistrationConfirm_callSignalAddress {
    PRegistrationConfirm_callSignalAddress next;
    TransportAddress value;
} RegistrationConfirm_callSignalAddress_Element;

typedef struct RegistrationRequest_rasAddress {
    PRegistrationRequest_rasAddress next;
    TransportAddress value;
} RegistrationRequest_rasAddress_Element;

typedef struct RegistrationRequest_callSignalAddress {
    PRegistrationRequest_callSignalAddress next;
    TransportAddress value;
} RegistrationRequest_callSignalAddress_Element;

typedef struct GatekeeperReject_alternateGatekeeper {
    PGatekeeperReject_alternateGatekeeper next;
    AlternateGK value;
} GatekeeperReject_alternateGatekeeper_Element;

typedef struct GatekeeperConfirm_alternateGatekeeper {
    PGatekeeperConfirm_alternateGatekeeper next;
    AlternateGK value;
} GatekeeperConfirm_alternateGatekeeper_Element;

typedef struct Endpoint_rasAddress {
    PEndpoint_rasAddress next;
    TransportAddress value;
} Endpoint_rasAddress_Element;

typedef struct Endpoint_callSignalAddress {
    PEndpoint_callSignalAddress next;
    TransportAddress value;
} Endpoint_callSignalAddress_Element;

typedef struct EndpointType {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define EndpointType_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define vendor_present 0x40
    VendorIdentifier vendor;
#   define gatekeeper_present 0x20
    GatekeeperInfo gatekeeper;
#   define gateway_present 0x10
    GatewayInfo gateway;
#   define mcu_present 0x8
    McuInfo mcu;
#   define terminal_present 0x4
    TerminalInfo terminal;
    ASN1bool_t mc;
    ASN1bool_t undefinedNode;
} EndpointType;

typedef struct SupportedProtocols {
    ASN1choice_t choice;
    union {
#	define nonStandardData_chosen 1
	H225NonStandardParameter nonStandardData;
#	define h310_chosen 2
	H310Caps h310;
#	define h320_chosen 3
	H320Caps h320;
#	define h321_chosen 4
	H321Caps h321;
#	define h322_chosen 5
	H322Caps h322;
#	define h323_chosen 6
	H323Caps h323;
#	define h324_chosen 7
	H324Caps h324;
#	define voice_chosen 8
	VoiceCaps voice;
#	define t120_only_chosen 9
	T120OnlyCaps t120_only;
#	define nonStandardProtocol_chosen 10
	NonStandardProtocol nonStandardProtocol;
    } u;
} SupportedProtocols;

typedef struct AliasAddress {
    ASN1choice_t choice;
    union {
#	define e164_chosen 1
	ASN1char_t e164[129];
#	define h323_ID_chosen 2
	ASN1char16string_t h323_ID;
#	define url_ID_chosen 3
	ASN1char_t url_ID[513];
#	define transportID_chosen 4
	TransportAddress transportID;
#	define email_ID_chosen 5
	ASN1char_t email_ID[513];
#	define partyNumber_chosen 6
	PartyNumber partyNumber;
    } u;
} AliasAddress;

typedef struct Endpoint {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define Endpoint_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define aliasAddress_present 0x40
    PEndpoint_aliasAddress aliasAddress;
#   define callSignalAddress_present 0x20
    PEndpoint_callSignalAddress callSignalAddress;
#   define rasAddress_present 0x10
    PEndpoint_rasAddress rasAddress;
#   define endpointType_present 0x8
    EndpointType endpointType;
#   define Endpoint_tokens_present 0x4
    PEndpoint_tokens tokens;
#   define priority_present 0x2
    ASN1uint16_t priority;
#   define Endpoint_destinationInfo_present 0x1
    PEndpoint_destinationInfo destinationInfo;
#   define Endpoint_destExtraCallInfo_present 0x8000
    PEndpoint_destExtraCallInfo destExtraCallInfo;
} Endpoint;

typedef struct SupportedPrefix {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define SupportedPrefix_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    AliasAddress prefix;
} SupportedPrefix;

typedef struct GatekeeperRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define GatekeeperRequest_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    TransportAddress rasAddress;
    EndpointType endpointType;
#   define GatekeeperRequest_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
#   define GatekeeperRequest_callServices_present 0x20
    QseriesOptions callServices;
#   define GatekeeperRequest_endpointAlias_present 0x10
    PGatekeeperRequest_endpointAlias endpointAlias;
#   define GatekeeperRequest_alternateEndpoints_present 0x8000
    PGatekeeperRequest_alternateEndpoints alternateEndpoints;
#   define GatekeeperRequest_tokens_present 0x4000
    PGatekeeperRequest_tokens tokens;
#   define GatekeeperRequest_cryptoTokens_present 0x2000
    PGatekeeperRequest_cryptoTokens cryptoTokens;
#   define GatekeeperRequest_authenticationCapability_present 0x1000
    PGatekeeperRequest_authenticationCapability authenticationCapability;
#   define algorithmOIDs_present 0x800
    PGatekeeperRequest_algorithmOIDs algorithmOIDs;
#   define GatekeeperRequest_integrity_present 0x400
    PGatekeeperRequest_integrity integrity;
#   define GatekeeperRequest_integrityCheckValue_present 0x200
    ICV integrityCheckValue;
} GatekeeperRequest;

typedef struct RegistrationRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define RegistrationRequest_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    ASN1bool_t discoveryComplete;
    PRegistrationRequest_callSignalAddress callSignalAddress;
    PRegistrationRequest_rasAddress rasAddress;
    EndpointType terminalType;
#   define RegistrationRequest_terminalAlias_present 0x40
    PRegistrationRequest_terminalAlias terminalAlias;
#   define RegistrationRequest_gatekeeperIdentifier_present 0x20
    GatekeeperIdentifier gatekeeperIdentifier;
    VendorIdentifier endpointVendor;
#   define RegistrationRequest_alternateEndpoints_present 0x8000
    PRegistrationRequest_alternateEndpoints alternateEndpoints;
#   define RegistrationRequest_timeToLive_present 0x4000
    TimeToLive timeToLive;
#   define RegistrationRequest_tokens_present 0x2000
    PRegistrationRequest_tokens tokens;
#   define RegistrationRequest_cryptoTokens_present 0x1000
    PRegistrationRequest_cryptoTokens cryptoTokens;
#   define RegistrationRequest_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
#   define keepAlive_present 0x400
    ASN1bool_t keepAlive;
#   define RegistrationRequest_endpointIdentifier_present 0x200
    EndpointIdentifier endpointIdentifier;
#   define RegistrationRequest_willSupplyUUIEs_present 0x100
    ASN1bool_t willSupplyUUIEs;
} RegistrationRequest;

typedef struct AdmissionConfirm {
    union {
	ASN1uint32_t bit_mask;
	ASN1octet_t o[3];
    };
    RequestSeqNum requestSeqNum;
    BandWidth bandWidth;
    CallModel callModel;
    TransportAddress destCallSignalAddress;
#   define irrFrequency_present 0x80
    ASN1uint16_t irrFrequency;
#   define AdmissionConfirm_nonStandardData_present 0x40
    H225NonStandardParameter nonStandardData;
#   define AdmissionConfirm_destinationInfo_present 0x8000
    PAdmissionConfirm_destinationInfo destinationInfo;
#   define AdmissionConfirm_destExtraCallInfo_present 0x4000
    PAdmissionConfirm_destExtraCallInfo destExtraCallInfo;
#   define AdmissionConfirm_destinationType_present 0x2000
    EndpointType destinationType;
#   define AdmissionConfirm_remoteExtensionAddress_present 0x1000
    PAdmissionConfirm_remoteExtensionAddress remoteExtensionAddress;
#   define AdmissionConfirm_alternateEndpoints_present 0x800
    PAdmissionConfirm_alternateEndpoints alternateEndpoints;
#   define AdmissionConfirm_tokens_present 0x400
    PAdmissionConfirm_tokens tokens;
#   define AdmissionConfirm_cryptoTokens_present 0x200
    PAdmissionConfirm_cryptoTokens cryptoTokens;
#   define AdmissionConfirm_integrityCheckValue_present 0x100
    ICV integrityCheckValue;
#   define AdmissionConfirm_transportQOS_present 0x800000
    TransportQOS transportQOS;
#   define AdmissionConfirm_willRespondToIRR_present 0x400000
    ASN1bool_t willRespondToIRR;
#   define AdmissionConfirm_uuiesRequested_present 0x200000
    UUIEsRequested uuiesRequested;
} AdmissionConfirm;

typedef struct LocationConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    TransportAddress callSignalAddress;
    TransportAddress rasAddress;
#   define LocationConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define LocationConfirm_destinationInfo_present 0x8000
    PLocationConfirm_destinationInfo destinationInfo;
#   define LocationConfirm_destExtraCallInfo_present 0x4000
    PLocationConfirm_destExtraCallInfo destExtraCallInfo;
#   define LocationConfirm_destinationType_present 0x2000
    EndpointType destinationType;
#   define LocationConfirm_remoteExtensionAddress_present 0x1000
    PLocationConfirm_remoteExtensionAddress remoteExtensionAddress;
#   define LocationConfirm_alternateEndpoints_present 0x800
    PLocationConfirm_alternateEndpoints alternateEndpoints;
#   define LocationConfirm_tokens_present 0x400
    PLocationConfirm_tokens tokens;
#   define LocationConfirm_cryptoTokens_present 0x200
    PLocationConfirm_cryptoTokens cryptoTokens;
#   define LocationConfirm_integrityCheckValue_present 0x100
    ICV integrityCheckValue;
} LocationConfirm;

typedef struct InfoRequestResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define InfoRequestResponse_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    RequestSeqNum requestSeqNum;
    EndpointType endpointType;
    EndpointIdentifier endpointIdentifier;
    TransportAddress rasAddress;
    PInfoRequestResponse_callSignalAddress callSignalAddress;
#   define InfoRequestResponse_endpointAlias_present 0x40
    PInfoRequestResponse_endpointAlias endpointAlias;
#   define perCallInfo_present 0x20
    PInfoRequestResponse_perCallInfo perCallInfo;
#   define InfoRequestResponse_tokens_present 0x8000
    PInfoRequestResponse_tokens tokens;
#   define InfoRequestResponse_cryptoTokens_present 0x4000
    PInfoRequestResponse_cryptoTokens cryptoTokens;
#   define InfoRequestResponse_integrityCheckValue_present 0x2000
    ICV integrityCheckValue;
#   define needResponse_present 0x1000
    ASN1bool_t needResponse;
} InfoRequestResponse;

typedef struct ResourcesAvailableIndicate_protocols {
    PResourcesAvailableIndicate_protocols next;
    SupportedProtocols value;
} ResourcesAvailableIndicate_protocols_Element;

typedef struct InfoRequestResponse_endpointAlias {
    PInfoRequestResponse_endpointAlias next;
    AliasAddress value;
} InfoRequestResponse_endpointAlias_Element;

typedef struct LocationConfirm_alternateEndpoints {
    PLocationConfirm_alternateEndpoints next;
    Endpoint value;
} LocationConfirm_alternateEndpoints_Element;

typedef struct LocationConfirm_remoteExtensionAddress {
    PLocationConfirm_remoteExtensionAddress next;
    AliasAddress value;
} LocationConfirm_remoteExtensionAddress_Element;

typedef struct LocationConfirm_destExtraCallInfo {
    PLocationConfirm_destExtraCallInfo next;
    AliasAddress value;
} LocationConfirm_destExtraCallInfo_Element;

typedef struct LocationConfirm_destinationInfo {
    PLocationConfirm_destinationInfo next;
    AliasAddress value;
} LocationConfirm_destinationInfo_Element;

typedef struct LocationRequest_sourceInfo {
    PLocationRequest_sourceInfo next;
    AliasAddress value;
} LocationRequest_sourceInfo_Element;

typedef struct LocationRequest_destinationInfo {
    PLocationRequest_destinationInfo next;
    AliasAddress value;
} LocationRequest_destinationInfo_Element;

typedef struct AdmissionConfirm_alternateEndpoints {
    PAdmissionConfirm_alternateEndpoints next;
    Endpoint value;
} AdmissionConfirm_alternateEndpoints_Element;

typedef struct AdmissionConfirm_remoteExtensionAddress {
    PAdmissionConfirm_remoteExtensionAddress next;
    AliasAddress value;
} AdmissionConfirm_remoteExtensionAddress_Element;

typedef struct AdmissionConfirm_destExtraCallInfo {
    PAdmissionConfirm_destExtraCallInfo next;
    AliasAddress value;
} AdmissionConfirm_destExtraCallInfo_Element;

typedef struct AdmissionConfirm_destinationInfo {
    PAdmissionConfirm_destinationInfo next;
    AliasAddress value;
} AdmissionConfirm_destinationInfo_Element;

typedef struct AdmissionRequest_destAlternatives {
    PAdmissionRequest_destAlternatives next;
    Endpoint value;
} AdmissionRequest_destAlternatives_Element;

typedef struct AdmissionRequest_srcAlternatives {
    PAdmissionRequest_srcAlternatives next;
    Endpoint value;
} AdmissionRequest_srcAlternatives_Element;

typedef struct AdmissionRequest_srcInfo {
    PAdmissionRequest_srcInfo next;
    AliasAddress value;
} AdmissionRequest_srcInfo_Element;

typedef struct AdmissionRequest_destExtraCallInfo {
    PAdmissionRequest_destExtraCallInfo next;
    AliasAddress value;
} AdmissionRequest_destExtraCallInfo_Element;

typedef struct AdmissionRequest_destinationInfo {
    PAdmissionRequest_destinationInfo next;
    AliasAddress value;
} AdmissionRequest_destinationInfo_Element;

typedef struct UnregistrationRequest_alternateEndpoints {
    PUnregistrationRequest_alternateEndpoints next;
    Endpoint value;
} UnregistrationRequest_alternateEndpoints_Element;

typedef struct UnregistrationRequest_endpointAlias {
    PUnregistrationRequest_endpointAlias next;
    AliasAddress value;
} UnregistrationRequest_endpointAlias_Element;

typedef struct RegistrationRejectReason_duplicateAlias {
    PRegistrationRejectReason_duplicateAlias next;
    AliasAddress value;
} RegistrationRejectReason_duplicateAlias_Element;

typedef struct RegistrationConfirm_terminalAlias {
    PRegistrationConfirm_terminalAlias next;
    AliasAddress value;
} RegistrationConfirm_terminalAlias_Element;

typedef struct RegistrationRequest_alternateEndpoints {
    PRegistrationRequest_alternateEndpoints next;
    Endpoint value;
} RegistrationRequest_alternateEndpoints_Element;

typedef struct RegistrationRequest_terminalAlias {
    PRegistrationRequest_terminalAlias next;
    AliasAddress value;
} RegistrationRequest_terminalAlias_Element;

typedef struct GatekeeperRequest_alternateEndpoints {
    PGatekeeperRequest_alternateEndpoints next;
    Endpoint value;
} GatekeeperRequest_alternateEndpoints_Element;

typedef struct GatekeeperRequest_endpointAlias {
    PGatekeeperRequest_endpointAlias next;
    AliasAddress value;
} GatekeeperRequest_endpointAlias_Element;

typedef struct CryptoH323Token_cryptoEPPwdHash {
    AliasAddress alias;
    H235TimeStamp timeStamp;
    HASHED token;
} CryptoH323Token_cryptoEPPwdHash;

typedef struct Endpoint_destExtraCallInfo {
    PEndpoint_destExtraCallInfo next;
    AliasAddress value;
} Endpoint_destExtraCallInfo_Element;

typedef struct Endpoint_destinationInfo {
    PEndpoint_destinationInfo next;
    AliasAddress value;
} Endpoint_destinationInfo_Element;

typedef struct Endpoint_aliasAddress {
    PEndpoint_aliasAddress next;
    AliasAddress value;
} Endpoint_aliasAddress_Element;

typedef struct NonStandardProtocol_supportedPrefixes {
    PNonStandardProtocol_supportedPrefixes next;
    SupportedPrefix value;
} NonStandardProtocol_supportedPrefixes_Element;

typedef struct T120OnlyCaps_supportedPrefixes {
    PT120OnlyCaps_supportedPrefixes next;
    SupportedPrefix value;
} T120OnlyCaps_supportedPrefixes_Element;

typedef struct VoiceCaps_supportedPrefixes {
    PVoiceCaps_supportedPrefixes next;
    SupportedPrefix value;
} VoiceCaps_supportedPrefixes_Element;

typedef struct H324Caps_supportedPrefixes {
    PH324Caps_supportedPrefixes next;
    SupportedPrefix value;
} H324Caps_supportedPrefixes_Element;

typedef struct H323Caps_supportedPrefixes {
    PH323Caps_supportedPrefixes next;
    SupportedPrefix value;
} H323Caps_supportedPrefixes_Element;

typedef struct H322Caps_supportedPrefixes {
    PH322Caps_supportedPrefixes next;
    SupportedPrefix value;
} H322Caps_supportedPrefixes_Element;

typedef struct H321Caps_supportedPrefixes {
    PH321Caps_supportedPrefixes next;
    SupportedPrefix value;
} H321Caps_supportedPrefixes_Element;

typedef struct H320Caps_supportedPrefixes {
    PH320Caps_supportedPrefixes next;
    SupportedPrefix value;
} H320Caps_supportedPrefixes_Element;

typedef struct H310Caps_supportedPrefixes {
    PH310Caps_supportedPrefixes next;
    SupportedPrefix value;
} H310Caps_supportedPrefixes_Element;

typedef struct GatewayInfo_protocol {
    PGatewayInfo_protocol next;
    SupportedProtocols value;
} GatewayInfo_protocol_Element;

typedef struct Facility_UUIE_destExtraCallInfo {
    PFacility_UUIE_destExtraCallInfo next;
    AliasAddress value;
} Facility_UUIE_destExtraCallInfo_Element;

typedef struct Facility_UUIE_alternativeAliasAddress {
    PFacility_UUIE_alternativeAliasAddress next;
    AliasAddress value;
} Facility_UUIE_alternativeAliasAddress_Element;

typedef struct Setup_UUIE_destExtraCallInfo {
    PSetup_UUIE_destExtraCallInfo next;
    AliasAddress value;
} Setup_UUIE_destExtraCallInfo_Element;

typedef struct Setup_UUIE_destinationAddress {
    PSetup_UUIE_destinationAddress next;
    AliasAddress value;
} Setup_UUIE_destinationAddress_Element;

typedef struct Setup_UUIE_sourceAddress {
    PSetup_UUIE_sourceAddress next;
    AliasAddress value;
} Setup_UUIE_sourceAddress_Element;

typedef struct Facility_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
#   define alternativeAddress_present 0x80
    TransportAddress alternativeAddress;
#   define alternativeAliasAddress_present 0x40
    PFacility_UUIE_alternativeAliasAddress alternativeAliasAddress;
#   define Facility_UUIE_conferenceID_present 0x20
    ConferenceIdentifier conferenceID;
    FacilityReason reason;
#   define Facility_UUIE_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define Facility_UUIE_destExtraCallInfo_present 0x4000
    PFacility_UUIE_destExtraCallInfo destExtraCallInfo;
#   define Facility_UUIE_remoteExtensionAddress_present 0x2000
    AliasAddress remoteExtensionAddress;
#   define Facility_UUIE_tokens_present 0x1000
    PFacility_UUIE_tokens tokens;
#   define Facility_UUIE_cryptoTokens_present 0x800
    PFacility_UUIE_cryptoTokens cryptoTokens;
#   define conferences_present 0x400
    PFacility_UUIE_conferences conferences;
} Facility_UUIE;

typedef struct ConferenceList {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ConferenceList_conferenceID_present 0x80
    ConferenceIdentifier conferenceID;
#   define conferenceAlias_present 0x40
    AliasAddress conferenceAlias;
#   define ConferenceList_nonStandardData_present 0x20
    H225NonStandardParameter nonStandardData;
} ConferenceList;

typedef struct Progress_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ProtocolIdentifier protocolIdentifier;
    EndpointType destinationInfo;
#   define Progress_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
    CallIdentifier callIdentifier;
#   define Progress_UUIE_h245SecurityMode_present 0x40
    H245Security h245SecurityMode;
#   define Progress_UUIE_tokens_present 0x20
    PProgress_UUIE_tokens tokens;
#   define Progress_UUIE_cryptoTokens_present 0x10
    PProgress_UUIE_cryptoTokens cryptoTokens;
#   define Progress_UUIE_fastStart_present 0x8
    PProgress_UUIE_fastStart fastStart;
} Progress_UUIE;

typedef struct FastCap {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define caps_present 0x80
    PFastCap_caps caps;
#   define multiplexCap_present 0x40
    MultiplexCapability multiplexCap;
} FastCap;

typedef struct CryptoH323Token {
    ASN1choice_t choice;
    union {
#	define cryptoEPPwdHash_chosen 1
	CryptoH323Token_cryptoEPPwdHash cryptoEPPwdHash;
#	define cryptoGKPwdHash_chosen 2
	CryptoH323Token_cryptoGKPwdHash cryptoGKPwdHash;
#	define cryptoEPPwdEncr_chosen 3
	ENCRYPTED cryptoEPPwdEncr;
#	define cryptoGKPwdEncr_chosen 4
	ENCRYPTED cryptoGKPwdEncr;
#	define cryptoEPCert_chosen 5
	SIGNED_EncodedPwdCertToken cryptoEPCert;
#	define cryptoGKCert_chosen 6
	SIGNED_EncodedPwdCertToken cryptoGKCert;
#	define cryptoFastStart_chosen 7
	SIGNED_EncodedFastStartToken cryptoFastStart;
#	define nestedcryptoToken_chosen 8
	CryptoToken nestedcryptoToken;
    } u;
} CryptoH323Token;

typedef struct RasMessage {
    ASN1choice_t choice;
    union {
#	define gatekeeperRequest_chosen 1
	GatekeeperRequest gatekeeperRequest;
#	define gatekeeperConfirm_chosen 2
	GatekeeperConfirm gatekeeperConfirm;
#	define gatekeeperReject_chosen 3
	GatekeeperReject gatekeeperReject;
#	define registrationRequest_chosen 4
	RegistrationRequest registrationRequest;
#	define registrationConfirm_chosen 5
	RegistrationConfirm registrationConfirm;
#	define registrationReject_chosen 6
	RegistrationReject registrationReject;
#	define unregistrationRequest_chosen 7
	UnregistrationRequest unregistrationRequest;
#	define unregistrationConfirm_chosen 8
	UnregistrationConfirm unregistrationConfirm;
#	define unregistrationReject_chosen 9
	UnregistrationReject unregistrationReject;
#	define admissionRequest_chosen 10
	AdmissionRequest admissionRequest;
#	define admissionConfirm_chosen 11
	AdmissionConfirm admissionConfirm;
#	define admissionReject_chosen 12
	AdmissionReject admissionReject;
#	define bandwidthRequest_chosen 13
	BandwidthRequest bandwidthRequest;
#	define bandwidthConfirm_chosen 14
	BandwidthConfirm bandwidthConfirm;
#	define bandwidthReject_chosen 15
	BandwidthReject bandwidthReject;
#	define disengageRequest_chosen 16
	DisengageRequest disengageRequest;
#	define disengageConfirm_chosen 17
	DisengageConfirm disengageConfirm;
#	define disengageReject_chosen 18
	DisengageReject disengageReject;
#	define locationRequest_chosen 19
	LocationRequest locationRequest;
#	define locationConfirm_chosen 20
	LocationConfirm locationConfirm;
#	define locationReject_chosen 21
	LocationReject locationReject;
#	define infoRequest_chosen 22
	InfoRequest infoRequest;
#	define infoRequestResponse_chosen 23
	InfoRequestResponse infoRequestResponse;
#	define nonStandardMessage_chosen 24
	H225NonStandardMessage nonStandardMessage;
#	define unknownMessageResponse_chosen 25
	UnknownMessageResponse unknownMessageResponse;
#	define requestInProgress_chosen 26
	RequestInProgress requestInProgress;
#	define resourcesAvailableIndicate_chosen 27
	ResourcesAvailableIndicate resourcesAvailableIndicate;
#	define resourcesAvailableConfirm_chosen 28
	ResourcesAvailableConfirm resourcesAvailableConfirm;
#	define infoRequestAck_chosen 29
	InfoRequestAck infoRequestAck;
#	define infoRequestNak_chosen 30
	InfoRequestNak infoRequestNak;
    } u;
} RasMessage;
#define RasMessage_PDU 0
#define SIZE_H225PP_Module_PDU_0 sizeof(RasMessage)

typedef struct InfoRequestResponse_perCallInfo_Seq_cryptoTokens {
    PInfoRequestResponse_perCallInfo_Seq_cryptoTokens next;
    CryptoH323Token value;
} InfoRequestResponse_perCallInfo_Seq_cryptoTokens_Element;

typedef struct ResourcesAvailableConfirm_cryptoTokens {
    PResourcesAvailableConfirm_cryptoTokens next;
    CryptoH323Token value;
} ResourcesAvailableConfirm_cryptoTokens_Element;

typedef struct ResourcesAvailableIndicate_cryptoTokens {
    PResourcesAvailableIndicate_cryptoTokens next;
    CryptoH323Token value;
} ResourcesAvailableIndicate_cryptoTokens_Element;

typedef struct RequestInProgress_cryptoTokens {
    PRequestInProgress_cryptoTokens next;
    CryptoH323Token value;
} RequestInProgress_cryptoTokens_Element;

typedef struct UnknownMessageResponse_cryptoTokens {
    PUnknownMessageResponse_cryptoTokens next;
    CryptoH323Token value;
} UnknownMessageResponse_cryptoTokens_Element;

typedef struct H225NonStandardMessage_cryptoTokens {
    PH225NonStandardMessage_cryptoTokens next;
    CryptoH323Token value;
} H225NonStandardMessage_cryptoTokens_Element;

typedef struct InfoRequestNak_cryptoTokens {
    PInfoRequestNak_cryptoTokens next;
    CryptoH323Token value;
} InfoRequestNak_cryptoTokens_Element;

typedef struct InfoRequestAck_cryptoTokens {
    PInfoRequestAck_cryptoTokens next;
    CryptoH323Token value;
} InfoRequestAck_cryptoTokens_Element;

typedef struct InfoRequestResponse_cryptoTokens {
    PInfoRequestResponse_cryptoTokens next;
    CryptoH323Token value;
} InfoRequestResponse_cryptoTokens_Element;

typedef struct InfoRequest_cryptoTokens {
    PInfoRequest_cryptoTokens next;
    CryptoH323Token value;
} InfoRequest_cryptoTokens_Element;

typedef struct DisengageReject_cryptoTokens {
    PDisengageReject_cryptoTokens next;
    CryptoH323Token value;
} DisengageReject_cryptoTokens_Element;

typedef struct DisengageConfirm_cryptoTokens {
    PDisengageConfirm_cryptoTokens next;
    CryptoH323Token value;
} DisengageConfirm_cryptoTokens_Element;

typedef struct DisengageRequest_cryptoTokens {
    PDisengageRequest_cryptoTokens next;
    CryptoH323Token value;
} DisengageRequest_cryptoTokens_Element;

typedef struct LocationReject_cryptoTokens {
    PLocationReject_cryptoTokens next;
    CryptoH323Token value;
} LocationReject_cryptoTokens_Element;

typedef struct LocationConfirm_cryptoTokens {
    PLocationConfirm_cryptoTokens next;
    CryptoH323Token value;
} LocationConfirm_cryptoTokens_Element;

typedef struct LocationRequest_cryptoTokens {
    PLocationRequest_cryptoTokens next;
    CryptoH323Token value;
} LocationRequest_cryptoTokens_Element;

typedef struct BandwidthReject_cryptoTokens {
    PBandwidthReject_cryptoTokens next;
    CryptoH323Token value;
} BandwidthReject_cryptoTokens_Element;

typedef struct BandwidthConfirm_cryptoTokens {
    PBandwidthConfirm_cryptoTokens next;
    CryptoH323Token value;
} BandwidthConfirm_cryptoTokens_Element;

typedef struct BandwidthRequest_cryptoTokens {
    PBandwidthRequest_cryptoTokens next;
    CryptoH323Token value;
} BandwidthRequest_cryptoTokens_Element;

typedef struct AdmissionReject_cryptoTokens {
    PAdmissionReject_cryptoTokens next;
    CryptoH323Token value;
} AdmissionReject_cryptoTokens_Element;

typedef struct AdmissionConfirm_cryptoTokens {
    PAdmissionConfirm_cryptoTokens next;
    CryptoH323Token value;
} AdmissionConfirm_cryptoTokens_Element;

typedef struct AdmissionRequest_cryptoTokens {
    PAdmissionRequest_cryptoTokens next;
    CryptoH323Token value;
} AdmissionRequest_cryptoTokens_Element;

typedef struct UnregistrationReject_cryptoTokens {
    PUnregistrationReject_cryptoTokens next;
    CryptoH323Token value;
} UnregistrationReject_cryptoTokens_Element;

typedef struct UnregistrationConfirm_cryptoTokens {
    PUnregistrationConfirm_cryptoTokens next;
    CryptoH323Token value;
} UnregistrationConfirm_cryptoTokens_Element;

typedef struct UnregistrationRequest_cryptoTokens {
    PUnregistrationRequest_cryptoTokens next;
    CryptoH323Token value;
} UnregistrationRequest_cryptoTokens_Element;

typedef struct RegistrationReject_cryptoTokens {
    PRegistrationReject_cryptoTokens next;
    CryptoH323Token value;
} RegistrationReject_cryptoTokens_Element;

typedef struct RegistrationConfirm_cryptoTokens {
    PRegistrationConfirm_cryptoTokens next;
    CryptoH323Token value;
} RegistrationConfirm_cryptoTokens_Element;

typedef struct RegistrationRequest_cryptoTokens {
    PRegistrationRequest_cryptoTokens next;
    CryptoH323Token value;
} RegistrationRequest_cryptoTokens_Element;

typedef struct GatekeeperReject_cryptoTokens {
    PGatekeeperReject_cryptoTokens next;
    CryptoH323Token value;
} GatekeeperReject_cryptoTokens_Element;

typedef struct GatekeeperConfirm_cryptoTokens {
    PGatekeeperConfirm_cryptoTokens next;
    CryptoH323Token value;
} GatekeeperConfirm_cryptoTokens_Element;

typedef struct GatekeeperRequest_cryptoTokens {
    PGatekeeperRequest_cryptoTokens next;
    CryptoH323Token value;
} GatekeeperRequest_cryptoTokens_Element;

typedef struct FastCap_caps {
    PFastCap_caps next;
    Capability value;
} FastCap_caps_Element;

typedef struct Progress_UUIE_cryptoTokens {
    PProgress_UUIE_cryptoTokens next;
    CryptoH323Token value;
} Progress_UUIE_cryptoTokens_Element;

typedef struct Facility_UUIE_conferences {
    PFacility_UUIE_conferences next;
    ConferenceList value;
} Facility_UUIE_conferences_Element;

typedef struct Facility_UUIE_cryptoTokens {
    PFacility_UUIE_cryptoTokens next;
    CryptoH323Token value;
} Facility_UUIE_cryptoTokens_Element;

typedef struct Setup_UUIE_cryptoTokens {
    PSetup_UUIE_cryptoTokens next;
    CryptoH323Token value;
} Setup_UUIE_cryptoTokens_Element;

typedef struct Connect_UUIE_cryptoTokens {
    PConnect_UUIE_cryptoTokens next;
    CryptoH323Token value;
} Connect_UUIE_cryptoTokens_Element;

typedef struct CallProceeding_UUIE_cryptoTokens {
    PCallProceeding_UUIE_cryptoTokens next;
    CryptoH323Token value;
} CallProceeding_UUIE_cryptoTokens_Element;

typedef struct Alerting_UUIE_cryptoTokens {
    PAlerting_UUIE_cryptoTokens next;
    CryptoH323Token value;
} Alerting_UUIE_cryptoTokens_Element;

typedef struct Alerting_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
    EndpointType destinationInfo;
#   define Alerting_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
#   define Alerting_UUIE_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define Alerting_UUIE_h245SecurityMode_present 0x4000
    H245Security h245SecurityMode;
#   define Alerting_UUIE_tokens_present 0x2000
    PAlerting_UUIE_tokens tokens;
#   define Alerting_UUIE_cryptoTokens_present 0x1000
    PAlerting_UUIE_cryptoTokens cryptoTokens;
#   define Alerting_UUIE_fastStart_present 0x800
    PAlerting_UUIE_fastStart fastStart;
#   define Alerting_UUIE_fastCap_present 0x400
    FastCap fastCap;
} Alerting_UUIE;

typedef struct CallProceeding_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
    EndpointType destinationInfo;
#   define CallProceeding_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
#   define CallProceeding_UUIE_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define CallProceeding_UUIE_h245SecurityMode_present 0x4000
    H245Security h245SecurityMode;
#   define CallProceeding_UUIE_tokens_present 0x2000
    PCallProceeding_UUIE_tokens tokens;
#   define CallProceeding_UUIE_cryptoTokens_present 0x1000
    PCallProceeding_UUIE_cryptoTokens cryptoTokens;
#   define CallProceeding_UUIE_fastStart_present 0x800
    PCallProceeding_UUIE_fastStart fastStart;
#   define CallProceeding_UUIE_fastCap_present 0x400
    FastCap fastCap;
} CallProceeding_UUIE;

typedef struct Connect_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
#   define Connect_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
    EndpointType destinationInfo;
    ConferenceIdentifier conferenceID;
#   define Connect_UUIE_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define Connect_UUIE_h245SecurityMode_present 0x4000
    H245Security h245SecurityMode;
#   define Connect_UUIE_tokens_present 0x2000
    PConnect_UUIE_tokens tokens;
#   define Connect_UUIE_cryptoTokens_present 0x1000
    PConnect_UUIE_cryptoTokens cryptoTokens;
#   define Connect_UUIE_fastStart_present 0x800
    PConnect_UUIE_fastStart fastStart;
#   define Connect_UUIE_fastCap_present 0x400
    FastCap fastCap;
} Connect_UUIE;

typedef struct Setup_UUIE {
    union {
	ASN1uint32_t bit_mask;
	ASN1octet_t o[3];
    };
    ProtocolIdentifier protocolIdentifier;
#   define Setup_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
#   define sourceAddress_present 0x40
    PSetup_UUIE_sourceAddress sourceAddress;
    EndpointType sourceInfo;
#   define destinationAddress_present 0x20
    PSetup_UUIE_destinationAddress destinationAddress;
#   define Setup_UUIE_destCallSignalAddress_present 0x10
    TransportAddress destCallSignalAddress;
#   define Setup_UUIE_destExtraCallInfo_present 0x8
    PSetup_UUIE_destExtraCallInfo destExtraCallInfo;
#   define destExtraCRV_present 0x4
    PSetup_UUIE_destExtraCRV destExtraCRV;
    ASN1bool_t activeMC;
    ConferenceIdentifier conferenceID;
    Setup_UUIE_conferenceGoal conferenceGoal;
#   define Setup_UUIE_callServices_present 0x2
    QseriesOptions callServices;
    CallType callType;
#   define sourceCallSignalAddress_present 0x8000
    TransportAddress sourceCallSignalAddress;
#   define Setup_UUIE_remoteExtensionAddress_present 0x4000
    AliasAddress remoteExtensionAddress;
#   define Setup_UUIE_callIdentifier_present 0x2000
    CallIdentifier callIdentifier;
#   define h245SecurityCapability_present 0x1000
    PSetup_UUIE_h245SecurityCapability h245SecurityCapability;
#   define Setup_UUIE_tokens_present 0x800
    PSetup_UUIE_tokens tokens;
#   define Setup_UUIE_cryptoTokens_present 0x400
    PSetup_UUIE_cryptoTokens cryptoTokens;
#   define Setup_UUIE_fastStart_present 0x200
    PSetup_UUIE_fastStart fastStart;
#   define Setup_UUIE_fastCap_present 0x100
    FastCap fastCap;
#   define canOverlapSend_present 0x800000
    ASN1bool_t canOverlapSend;
} Setup_UUIE;

typedef struct H323_UU_PDU_h323_message_body {
    ASN1choice_t choice;
    union {
#	define setup_chosen 1
	Setup_UUIE setup;
#	define callProceeding_chosen 2
	CallProceeding_UUIE callProceeding;
#	define connect_chosen 3
	Connect_UUIE connect;
#	define alerting_chosen 4
	Alerting_UUIE alerting;
#	define userInformation_chosen 5
	Information_UUIE userInformation;
#	define releaseComplete_chosen 6
	ReleaseComplete_UUIE releaseComplete;
#	define facility_chosen 7
	Facility_UUIE facility;
#	define progress_chosen 8
	Progress_UUIE progress;
#	define empty_chosen 9
    } u;
} H323_UU_PDU_h323_message_body;

typedef struct H323_UU_PDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    H323_UU_PDU_h323_message_body h323_message_body;
#   define H323_UU_PDU_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define h4501SupplementaryService_present 0x8000
    PH323_UU_PDU_h4501SupplementaryService h4501SupplementaryService;
#   define h245Tunneling_present 0x4000
    ASN1bool_t h245Tunneling;
#   define h245Control_present 0x2000
    PH323_UU_PDU_h245Control h245Control;
#   define nonStandardControl_present 0x1000
    PH323_UU_PDU_nonStandardControl nonStandardControl;
} H323_UU_PDU;

typedef struct InfoRequestResponse_perCallInfo_Seq_pdu_Seq {
    H323_UU_PDU h323pdu;
    ASN1bool_t sent;
} InfoRequestResponse_perCallInfo_Seq_pdu_Seq;

typedef struct InfoRequestResponse_perCallInfo_Seq_pdu {
    PInfoRequestResponse_perCallInfo_Seq_pdu next;
    InfoRequestResponse_perCallInfo_Seq_pdu_Seq value;
} InfoRequestResponse_perCallInfo_Seq_pdu_Element;

typedef struct H323_UserInformation {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H323_UU_PDU h323_uu_pdu;
#   define user_data_present 0x80
    H323_UserInformation_user_data user_data;
} H323_UserInformation;
#define H323_UserInformation_PDU 1
#define SIZE_H225PP_Module_PDU_1 sizeof(H323_UserInformation)

typedef struct Setup_UUIE_fastStart {
    PSetup_UUIE_fastStart next;
    OpenLogicalChannel value;
} Setup_UUIE_fastStart_Element;

typedef struct Connect_UUIE_fastStart {
    PConnect_UUIE_fastStart next;
    OpenLogicalChannel value;
} Connect_UUIE_fastStart_Element;

typedef struct CallProceeding_UUIE_fastStart {
    PCallProceeding_UUIE_fastStart next;
    OpenLogicalChannel value;
} CallProceeding_UUIE_fastStart_Element;

typedef struct Alerting_UUIE_fastStart {
    PAlerting_UUIE_fastStart next;
    OpenLogicalChannel value;
} Alerting_UUIE_fastStart_Element;


extern ASN1module_t H225PP_Module;
extern void ASN1CALL H225PP_Module_Startup(void);
extern void ASN1CALL H225PP_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val);
    extern int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route val);
	extern void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn(PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route val);
	extern void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn(PTransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Enc_RTPSession_associatedSessionIds_ElmFn(ASN1encoding_t enc, PRTPSession_associatedSessionIds val);
    extern int ASN1CALL ASN1Dec_RTPSession_associatedSessionIds_ElmFn(ASN1decoding_t dec, PRTPSession_associatedSessionIds val);
	extern void ASN1CALL ASN1Free_RTPSession_associatedSessionIds_ElmFn(PRTPSession_associatedSessionIds val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_algorithmOIDs_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_algorithmOIDs val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_algorithmOIDs_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_algorithmOIDs val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_algorithmOIDs_ElmFn(PGatekeeperRequest_algorithmOIDs val);
    extern int ASN1CALL ASN1Enc_Progress_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PProgress_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_Progress_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PProgress_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_Progress_UUIE_fastStart_ElmFn(PProgress_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCRV_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destExtraCRV val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCRV_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destExtraCRV val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_destExtraCRV_ElmFn(PSetup_UUIE_destExtraCRV val);
    extern int ASN1CALL ASN1Enc_H323_UU_PDU_h245Control_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_h245Control val);
    extern int ASN1CALL ASN1Dec_H323_UU_PDU_h245Control_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_h245Control val);
	extern void ASN1CALL ASN1Free_H323_UU_PDU_h245Control_ElmFn(PH323_UU_PDU_h245Control val);
    extern int ASN1CALL ASN1Enc_H323_UU_PDU_h4501SupplementaryService_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_h4501SupplementaryService val);
    extern int ASN1CALL ASN1Dec_H323_UU_PDU_h4501SupplementaryService_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_h4501SupplementaryService val);
	extern void ASN1CALL ASN1Free_H323_UU_PDU_h4501SupplementaryService_ElmFn(PH323_UU_PDU_h4501SupplementaryService val);
    extern int ASN1CALL ASN1Enc_RedundancyEncodingCapability_secondaryEncoding_ElmFn(ASN1encoding_t enc, PRedundancyEncodingCapability_secondaryEncoding val);
    extern int ASN1CALL ASN1Dec_RedundancyEncodingCapability_secondaryEncoding_ElmFn(ASN1decoding_t dec, PRedundancyEncodingCapability_secondaryEncoding val);
	extern void ASN1CALL ASN1Free_RedundancyEncodingCapability_secondaryEncoding_ElmFn(PRedundancyEncodingCapability_secondaryEncoding val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_tokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_tokens val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(PInfoRequestResponse_perCallInfo_Seq_tokens val);
    extern int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(ASN1encoding_t enc, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val);
    extern int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(ASN1decoding_t dec, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val);
	extern void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val);
    extern int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_tokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_tokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableConfirm_tokens val);
	extern void ASN1CALL ASN1Free_ResourcesAvailableConfirm_tokens_ElmFn(PResourcesAvailableConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_tokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_tokens val);
    extern int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_tokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_tokens val);
	extern void ASN1CALL ASN1Free_ResourcesAvailableIndicate_tokens_ElmFn(PResourcesAvailableIndicate_tokens val);
    extern int ASN1CALL ASN1Enc_RequestInProgress_tokens_ElmFn(ASN1encoding_t enc, PRequestInProgress_tokens val);
    extern int ASN1CALL ASN1Dec_RequestInProgress_tokens_ElmFn(ASN1decoding_t dec, PRequestInProgress_tokens val);
	extern void ASN1CALL ASN1Free_RequestInProgress_tokens_ElmFn(PRequestInProgress_tokens val);
    extern int ASN1CALL ASN1Enc_UnknownMessageResponse_tokens_ElmFn(ASN1encoding_t enc, PUnknownMessageResponse_tokens val);
    extern int ASN1CALL ASN1Dec_UnknownMessageResponse_tokens_ElmFn(ASN1decoding_t dec, PUnknownMessageResponse_tokens val);
	extern void ASN1CALL ASN1Free_UnknownMessageResponse_tokens_ElmFn(PUnknownMessageResponse_tokens val);
    extern int ASN1CALL ASN1Enc_H225NonStandardMessage_tokens_ElmFn(ASN1encoding_t enc, PH225NonStandardMessage_tokens val);
    extern int ASN1CALL ASN1Dec_H225NonStandardMessage_tokens_ElmFn(ASN1decoding_t dec, PH225NonStandardMessage_tokens val);
	extern void ASN1CALL ASN1Free_H225NonStandardMessage_tokens_ElmFn(PH225NonStandardMessage_tokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestNak_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestNak_tokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestNak_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestNak_tokens val);
	extern void ASN1CALL ASN1Free_InfoRequestNak_tokens_ElmFn(PInfoRequestNak_tokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestAck_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestAck_tokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestAck_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestAck_tokens val);
	extern void ASN1CALL ASN1Free_InfoRequestAck_tokens_ElmFn(PInfoRequestAck_tokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_tokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_tokens val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_tokens_ElmFn(PInfoRequestResponse_tokens val);
    extern int ASN1CALL ASN1Enc_InfoRequest_tokens_ElmFn(ASN1encoding_t enc, PInfoRequest_tokens val);
    extern int ASN1CALL ASN1Dec_InfoRequest_tokens_ElmFn(ASN1decoding_t dec, PInfoRequest_tokens val);
	extern void ASN1CALL ASN1Free_InfoRequest_tokens_ElmFn(PInfoRequest_tokens val);
    extern int ASN1CALL ASN1Enc_DisengageReject_tokens_ElmFn(ASN1encoding_t enc, PDisengageReject_tokens val);
    extern int ASN1CALL ASN1Dec_DisengageReject_tokens_ElmFn(ASN1decoding_t dec, PDisengageReject_tokens val);
	extern void ASN1CALL ASN1Free_DisengageReject_tokens_ElmFn(PDisengageReject_tokens val);
    extern int ASN1CALL ASN1Enc_DisengageConfirm_tokens_ElmFn(ASN1encoding_t enc, PDisengageConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_DisengageConfirm_tokens_ElmFn(ASN1decoding_t dec, PDisengageConfirm_tokens val);
	extern void ASN1CALL ASN1Free_DisengageConfirm_tokens_ElmFn(PDisengageConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_DisengageRequest_tokens_ElmFn(ASN1encoding_t enc, PDisengageRequest_tokens val);
    extern int ASN1CALL ASN1Dec_DisengageRequest_tokens_ElmFn(ASN1decoding_t dec, PDisengageRequest_tokens val);
	extern void ASN1CALL ASN1Free_DisengageRequest_tokens_ElmFn(PDisengageRequest_tokens val);
    extern int ASN1CALL ASN1Enc_LocationReject_tokens_ElmFn(ASN1encoding_t enc, PLocationReject_tokens val);
    extern int ASN1CALL ASN1Dec_LocationReject_tokens_ElmFn(ASN1decoding_t dec, PLocationReject_tokens val);
	extern void ASN1CALL ASN1Free_LocationReject_tokens_ElmFn(PLocationReject_tokens val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_tokens_ElmFn(ASN1encoding_t enc, PLocationConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_tokens_ElmFn(ASN1decoding_t dec, PLocationConfirm_tokens val);
	extern void ASN1CALL ASN1Free_LocationConfirm_tokens_ElmFn(PLocationConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_LocationRequest_tokens_ElmFn(ASN1encoding_t enc, PLocationRequest_tokens val);
    extern int ASN1CALL ASN1Dec_LocationRequest_tokens_ElmFn(ASN1decoding_t dec, PLocationRequest_tokens val);
	extern void ASN1CALL ASN1Free_LocationRequest_tokens_ElmFn(PLocationRequest_tokens val);
    extern int ASN1CALL ASN1Enc_BandwidthReject_tokens_ElmFn(ASN1encoding_t enc, PBandwidthReject_tokens val);
    extern int ASN1CALL ASN1Dec_BandwidthReject_tokens_ElmFn(ASN1decoding_t dec, PBandwidthReject_tokens val);
	extern void ASN1CALL ASN1Free_BandwidthReject_tokens_ElmFn(PBandwidthReject_tokens val);
    extern int ASN1CALL ASN1Enc_BandwidthConfirm_tokens_ElmFn(ASN1encoding_t enc, PBandwidthConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_BandwidthConfirm_tokens_ElmFn(ASN1decoding_t dec, PBandwidthConfirm_tokens val);
	extern void ASN1CALL ASN1Free_BandwidthConfirm_tokens_ElmFn(PBandwidthConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_BandwidthRequest_tokens_ElmFn(ASN1encoding_t enc, PBandwidthRequest_tokens val);
    extern int ASN1CALL ASN1Dec_BandwidthRequest_tokens_ElmFn(ASN1decoding_t dec, PBandwidthRequest_tokens val);
	extern void ASN1CALL ASN1Free_BandwidthRequest_tokens_ElmFn(PBandwidthRequest_tokens val);
    extern int ASN1CALL ASN1Enc_AdmissionReject_tokens_ElmFn(ASN1encoding_t enc, PAdmissionReject_tokens val);
    extern int ASN1CALL ASN1Dec_AdmissionReject_tokens_ElmFn(ASN1decoding_t dec, PAdmissionReject_tokens val);
	extern void ASN1CALL ASN1Free_AdmissionReject_tokens_ElmFn(PAdmissionReject_tokens val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_tokens_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_tokens_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_tokens val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_tokens_ElmFn(PAdmissionConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_tokens_ElmFn(ASN1encoding_t enc, PAdmissionRequest_tokens val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_tokens_ElmFn(ASN1decoding_t dec, PAdmissionRequest_tokens val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_tokens_ElmFn(PAdmissionRequest_tokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationReject_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationReject_tokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationReject_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationReject_tokens val);
	extern void ASN1CALL ASN1Free_UnregistrationReject_tokens_ElmFn(PUnregistrationReject_tokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationConfirm_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationConfirm_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationConfirm_tokens val);
	extern void ASN1CALL ASN1Free_UnregistrationConfirm_tokens_ElmFn(PUnregistrationConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_tokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_tokens val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_tokens_ElmFn(PUnregistrationRequest_tokens val);
    extern int ASN1CALL ASN1Enc_RegistrationReject_tokens_ElmFn(ASN1encoding_t enc, PRegistrationReject_tokens val);
    extern int ASN1CALL ASN1Dec_RegistrationReject_tokens_ElmFn(ASN1decoding_t dec, PRegistrationReject_tokens val);
	extern void ASN1CALL ASN1Free_RegistrationReject_tokens_ElmFn(PRegistrationReject_tokens val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_tokens_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_tokens_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_tokens val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_tokens_ElmFn(PRegistrationConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_tokens_ElmFn(ASN1encoding_t enc, PRegistrationRequest_tokens val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_tokens_ElmFn(ASN1decoding_t dec, PRegistrationRequest_tokens val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_tokens_ElmFn(PRegistrationRequest_tokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperReject_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperReject_tokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperReject_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperReject_tokens val);
	extern void ASN1CALL ASN1Free_GatekeeperReject_tokens_ElmFn(PGatekeeperReject_tokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperConfirm_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperConfirm_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_tokens val);
	extern void ASN1CALL ASN1Free_GatekeeperConfirm_tokens_ElmFn(PGatekeeperConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_authenticationCapability_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_authenticationCapability val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_authenticationCapability_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_authenticationCapability val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_authenticationCapability_ElmFn(PGatekeeperRequest_authenticationCapability val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_tokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_tokens val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_tokens_ElmFn(PGatekeeperRequest_tokens val);
    extern int ASN1CALL ASN1Enc_Endpoint_tokens_ElmFn(ASN1encoding_t enc, PEndpoint_tokens val);
    extern int ASN1CALL ASN1Dec_Endpoint_tokens_ElmFn(ASN1decoding_t dec, PEndpoint_tokens val);
	extern void ASN1CALL ASN1Free_Endpoint_tokens_ElmFn(PEndpoint_tokens val);
    extern int ASN1CALL ASN1Enc_Progress_UUIE_tokens_ElmFn(ASN1encoding_t enc, PProgress_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_Progress_UUIE_tokens_ElmFn(ASN1decoding_t dec, PProgress_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_Progress_UUIE_tokens_ElmFn(PProgress_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_tokens_ElmFn(ASN1encoding_t enc, PFacility_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_tokens_ElmFn(ASN1decoding_t dec, PFacility_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_tokens_ElmFn(PFacility_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_tokens_ElmFn(ASN1encoding_t enc, PSetup_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_tokens_ElmFn(ASN1decoding_t dec, PSetup_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_tokens_ElmFn(PSetup_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_Connect_UUIE_tokens_ElmFn(ASN1encoding_t enc, PConnect_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_Connect_UUIE_tokens_ElmFn(ASN1decoding_t dec, PConnect_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_Connect_UUIE_tokens_ElmFn(PConnect_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_CallProceeding_UUIE_tokens_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_CallProceeding_UUIE_tokens_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_CallProceeding_UUIE_tokens_ElmFn(PCallProceeding_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_Alerting_UUIE_tokens_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_Alerting_UUIE_tokens_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_Alerting_UUIE_tokens_ElmFn(PAlerting_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_EncryptionSync_escrowentry_ElmFn(ASN1encoding_t enc, PEncryptionSync_escrowentry val);
    extern int ASN1CALL ASN1Dec_EncryptionSync_escrowentry_ElmFn(ASN1decoding_t dec, PEncryptionSync_escrowentry val);
	extern void ASN1CALL ASN1Free_EncryptionSync_escrowentry_ElmFn(PEncryptionSync_escrowentry val);
    extern int ASN1CALL ASN1Enc_H263Options_customPictureFormat_ElmFn(ASN1encoding_t enc, PH263Options_customPictureFormat val);
    extern int ASN1CALL ASN1Dec_H263Options_customPictureFormat_ElmFn(ASN1decoding_t dec, PH263Options_customPictureFormat val);
	extern void ASN1CALL ASN1Free_H263Options_customPictureFormat_ElmFn(PH263Options_customPictureFormat val);
    extern int ASN1CALL ASN1Enc_H263Options_customPictureClockFrequency_ElmFn(ASN1encoding_t enc, PH263Options_customPictureClockFrequency val);
    extern int ASN1CALL ASN1Dec_H263Options_customPictureClockFrequency_ElmFn(ASN1decoding_t dec, PH263Options_customPictureClockFrequency val);
	extern void ASN1CALL ASN1Free_H263Options_customPictureClockFrequency_ElmFn(PH263Options_customPictureClockFrequency val);
    extern int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability val);
	extern void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn(PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Enc_H222Capability_vcCapability_ElmFn(ASN1encoding_t enc, PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Dec_H222Capability_vcCapability_ElmFn(ASN1decoding_t dec, PH222Capability_vcCapability val);
	extern void ASN1CALL ASN1Free_H222Capability_vcCapability_ElmFn(PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Enc_GatekeeperConfirm_integrity_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_integrity val);
    extern int ASN1CALL ASN1Dec_GatekeeperConfirm_integrity_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_integrity val);
	extern void ASN1CALL ASN1Free_GatekeeperConfirm_integrity_ElmFn(PGatekeeperConfirm_integrity val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_integrity_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_integrity val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_integrity_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_integrity val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_integrity_ElmFn(PGatekeeperRequest_integrity val);
    extern int ASN1CALL ASN1Enc_NonStandardProtocol_dataRatesSupported_ElmFn(ASN1encoding_t enc, PNonStandardProtocol_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_NonStandardProtocol_dataRatesSupported_ElmFn(ASN1decoding_t dec, PNonStandardProtocol_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_NonStandardProtocol_dataRatesSupported_ElmFn(PNonStandardProtocol_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_T120OnlyCaps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PT120OnlyCaps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_T120OnlyCaps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PT120OnlyCaps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_T120OnlyCaps_dataRatesSupported_ElmFn(PT120OnlyCaps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_VoiceCaps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PVoiceCaps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_VoiceCaps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PVoiceCaps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_VoiceCaps_dataRatesSupported_ElmFn(PVoiceCaps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H324Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH324Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H324Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH324Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H324Caps_dataRatesSupported_ElmFn(PH324Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H323Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH323Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H323Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH323Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H323Caps_dataRatesSupported_ElmFn(PH323Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H322Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH322Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H322Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH322Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H322Caps_dataRatesSupported_ElmFn(PH322Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H321Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH321Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H321Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH321Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H321Caps_dataRatesSupported_ElmFn(PH321Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H320Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH320Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H320Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH320Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H320Caps_dataRatesSupported_ElmFn(PH320Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H310Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH310Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H310Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH310Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H310Caps_dataRatesSupported_ElmFn(PH310Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_h245SecurityCapability_ElmFn(ASN1encoding_t enc, PSetup_UUIE_h245SecurityCapability val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_h245SecurityCapability_ElmFn(ASN1decoding_t dec, PSetup_UUIE_h245SecurityCapability val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_h245SecurityCapability_ElmFn(PSetup_UUIE_h245SecurityCapability val);
    extern int ASN1CALL ASN1Enc_H323_UU_PDU_nonStandardControl_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_nonStandardControl val);
    extern int ASN1CALL ASN1Dec_H323_UU_PDU_nonStandardControl_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_nonStandardControl val);
	extern void ASN1CALL ASN1Free_H323_UU_PDU_nonStandardControl_ElmFn(PH323_UU_PDU_nonStandardControl val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard val);
	extern void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn(PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData_ElmFn(ASN1encoding_t enc, PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData_ElmFn(ASN1decoding_t dec, PConferenceCapability_nonStandardData val);
	extern void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData_ElmFn(PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Enc_H263Options_modeCombos_ElmFn(ASN1encoding_t enc, PH263Options_modeCombos val);
    extern int ASN1CALL ASN1Dec_H263Options_modeCombos_ElmFn(ASN1decoding_t dec, PH263Options_modeCombos val);
	extern void ASN1CALL ASN1Free_H263Options_modeCombos_ElmFn(PH263Options_modeCombos val);
    extern int ASN1CALL ASN1Enc_TransportCapability_qOSCapabilities_ElmFn(ASN1encoding_t enc, PTransportCapability_qOSCapabilities val);
    extern int ASN1CALL ASN1Dec_TransportCapability_qOSCapabilities_ElmFn(ASN1decoding_t dec, PTransportCapability_qOSCapabilities val);
	extern void ASN1CALL ASN1Free_TransportCapability_qOSCapabilities_ElmFn(PTransportCapability_qOSCapabilities val);
    extern int ASN1CALL ASN1Enc_EncryptionCapability_ElmFn(ASN1encoding_t enc, PEncryptionCapability val);
    extern int ASN1CALL ASN1Dec_EncryptionCapability_ElmFn(ASN1decoding_t dec, PEncryptionCapability val);
	extern void ASN1CALL ASN1Free_EncryptionCapability_ElmFn(PEncryptionCapability val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_data val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_data val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(PInfoRequestResponse_perCallInfo_Seq_data val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_video val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_video val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(PInfoRequestResponse_perCallInfo_Seq_video val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_audio val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_audio val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(PInfoRequestResponse_perCallInfo_Seq_audio val);
    extern int ASN1CALL ASN1Enc_InfoRequestNak_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PInfoRequestNak_alternateGatekeeper val);
    extern int ASN1CALL ASN1Dec_InfoRequestNak_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PInfoRequestNak_alternateGatekeeper val);
	extern void ASN1CALL ASN1Free_InfoRequestNak_alternateGatekeeper_ElmFn(PInfoRequestNak_alternateGatekeeper val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_ElmFn(PInfoRequestResponse_perCallInfo val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_callSignalAddress_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_callSignalAddress_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_callSignalAddress val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_callSignalAddress_ElmFn(PInfoRequestResponse_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_DisengageReject_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PDisengageReject_alternateGatekeeper val);
    extern int ASN1CALL ASN1Dec_DisengageReject_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PDisengageReject_alternateGatekeeper val);
	extern void ASN1CALL ASN1Free_DisengageReject_alternateGatekeeper_ElmFn(PDisengageReject_alternateGatekeeper val);
    extern int ASN1CALL ASN1Enc_LocationReject_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PLocationReject_alternateGatekeeper val);
    extern int ASN1CALL ASN1Dec_LocationReject_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PLocationReject_alternateGatekeeper val);
	extern void ASN1CALL ASN1Free_LocationReject_alternateGatekeeper_ElmFn(PLocationReject_alternateGatekeeper val);
    extern int ASN1CALL ASN1Enc_BandwidthReject_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PBandwidthReject_alternateGatekeeper val);
    extern int ASN1CALL ASN1Dec_BandwidthReject_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PBandwidthReject_alternateGatekeeper val);
	extern void ASN1CALL ASN1Free_BandwidthReject_alternateGatekeeper_ElmFn(PBandwidthReject_alternateGatekeeper val);
    extern int ASN1CALL ASN1Enc_AdmissionReject_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PAdmissionReject_alternateGatekeeper val);
    extern int ASN1CALL ASN1Dec_AdmissionReject_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PAdmissionReject_alternateGatekeeper val);
	extern void ASN1CALL ASN1Free_AdmissionReject_alternateGatekeeper_ElmFn(PAdmissionReject_alternateGatekeeper val);
    extern int ASN1CALL ASN1Enc_UnregistrationReject_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PUnregistrationReject_alternateGatekeeper val);
    extern int ASN1CALL ASN1Dec_UnregistrationReject_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PUnregistrationReject_alternateGatekeeper val);
	extern void ASN1CALL ASN1Free_UnregistrationReject_alternateGatekeeper_ElmFn(PUnregistrationReject_alternateGatekeeper val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_callSignalAddress_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_callSignalAddress_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_callSignalAddress val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_callSignalAddress_ElmFn(PUnregistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_RegistrationReject_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PRegistrationReject_alternateGatekeeper val);
    extern int ASN1CALL ASN1Dec_RegistrationReject_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PRegistrationReject_alternateGatekeeper val);
	extern void ASN1CALL ASN1Free_RegistrationReject_alternateGatekeeper_ElmFn(PRegistrationReject_alternateGatekeeper val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_alternateGatekeeper val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_alternateGatekeeper val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_alternateGatekeeper_ElmFn(PRegistrationConfirm_alternateGatekeeper val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_callSignalAddress_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_callSignalAddress_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_callSignalAddress val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_callSignalAddress_ElmFn(PRegistrationConfirm_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_rasAddress_ElmFn(ASN1encoding_t enc, PRegistrationRequest_rasAddress val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_rasAddress_ElmFn(ASN1decoding_t dec, PRegistrationRequest_rasAddress val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_rasAddress_ElmFn(PRegistrationRequest_rasAddress val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_callSignalAddress_ElmFn(ASN1encoding_t enc, PRegistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_callSignalAddress_ElmFn(ASN1decoding_t dec, PRegistrationRequest_callSignalAddress val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_callSignalAddress_ElmFn(PRegistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_GatekeeperReject_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PGatekeeperReject_alternateGatekeeper val);
    extern int ASN1CALL ASN1Dec_GatekeeperReject_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PGatekeeperReject_alternateGatekeeper val);
	extern void ASN1CALL ASN1Free_GatekeeperReject_alternateGatekeeper_ElmFn(PGatekeeperReject_alternateGatekeeper val);
    extern int ASN1CALL ASN1Enc_GatekeeperConfirm_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_alternateGatekeeper val);
    extern int ASN1CALL ASN1Dec_GatekeeperConfirm_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_alternateGatekeeper val);
	extern void ASN1CALL ASN1Free_GatekeeperConfirm_alternateGatekeeper_ElmFn(PGatekeeperConfirm_alternateGatekeeper val);
    extern int ASN1CALL ASN1Enc_Endpoint_rasAddress_ElmFn(ASN1encoding_t enc, PEndpoint_rasAddress val);
    extern int ASN1CALL ASN1Dec_Endpoint_rasAddress_ElmFn(ASN1decoding_t dec, PEndpoint_rasAddress val);
	extern void ASN1CALL ASN1Free_Endpoint_rasAddress_ElmFn(PEndpoint_rasAddress val);
    extern int ASN1CALL ASN1Enc_Endpoint_callSignalAddress_ElmFn(ASN1encoding_t enc, PEndpoint_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_Endpoint_callSignalAddress_ElmFn(ASN1decoding_t dec, PEndpoint_callSignalAddress val);
	extern void ASN1CALL ASN1Free_Endpoint_callSignalAddress_ElmFn(PEndpoint_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_EnhancementLayerInfo_spatialEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_spatialEnhancement val);
    extern int ASN1CALL ASN1Dec_EnhancementLayerInfo_spatialEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_spatialEnhancement val);
	extern void ASN1CALL ASN1Free_EnhancementLayerInfo_spatialEnhancement_ElmFn(PEnhancementLayerInfo_spatialEnhancement val);
    extern int ASN1CALL ASN1Enc_EnhancementLayerInfo_snrEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_snrEnhancement val);
    extern int ASN1CALL ASN1Dec_EnhancementLayerInfo_snrEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_snrEnhancement val);
	extern void ASN1CALL ASN1Free_EnhancementLayerInfo_snrEnhancement_ElmFn(PEnhancementLayerInfo_snrEnhancement val);
    extern int ASN1CALL ASN1Enc_H2250Capability_redundancyEncodingCapability_ElmFn(ASN1encoding_t enc, PH2250Capability_redundancyEncodingCapability val);
    extern int ASN1CALL ASN1Dec_H2250Capability_redundancyEncodingCapability_ElmFn(ASN1decoding_t dec, PH2250Capability_redundancyEncodingCapability val);
	extern void ASN1CALL ASN1Free_H2250Capability_redundancyEncodingCapability_ElmFn(PH2250Capability_redundancyEncodingCapability val);
    extern int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_protocols_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_protocols val);
    extern int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_protocols_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_protocols val);
	extern void ASN1CALL ASN1Free_ResourcesAvailableIndicate_protocols_ElmFn(PResourcesAvailableIndicate_protocols val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_endpointAlias_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_endpointAlias val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_endpointAlias_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_endpointAlias val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_endpointAlias_ElmFn(PInfoRequestResponse_endpointAlias val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_alternateEndpoints_ElmFn(ASN1encoding_t enc, PLocationConfirm_alternateEndpoints val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_alternateEndpoints_ElmFn(ASN1decoding_t dec, PLocationConfirm_alternateEndpoints val);
	extern void ASN1CALL ASN1Free_LocationConfirm_alternateEndpoints_ElmFn(PLocationConfirm_alternateEndpoints val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PLocationConfirm_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PLocationConfirm_remoteExtensionAddress val);
	extern void ASN1CALL ASN1Free_LocationConfirm_remoteExtensionAddress_ElmFn(PLocationConfirm_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PLocationConfirm_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PLocationConfirm_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_LocationConfirm_destExtraCallInfo_ElmFn(PLocationConfirm_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_destinationInfo_ElmFn(ASN1encoding_t enc, PLocationConfirm_destinationInfo val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_destinationInfo_ElmFn(ASN1decoding_t dec, PLocationConfirm_destinationInfo val);
	extern void ASN1CALL ASN1Free_LocationConfirm_destinationInfo_ElmFn(PLocationConfirm_destinationInfo val);
    extern int ASN1CALL ASN1Enc_LocationRequest_sourceInfo_ElmFn(ASN1encoding_t enc, PLocationRequest_sourceInfo val);
    extern int ASN1CALL ASN1Dec_LocationRequest_sourceInfo_ElmFn(ASN1decoding_t dec, PLocationRequest_sourceInfo val);
	extern void ASN1CALL ASN1Free_LocationRequest_sourceInfo_ElmFn(PLocationRequest_sourceInfo val);
    extern int ASN1CALL ASN1Enc_LocationRequest_destinationInfo_ElmFn(ASN1encoding_t enc, PLocationRequest_destinationInfo val);
    extern int ASN1CALL ASN1Dec_LocationRequest_destinationInfo_ElmFn(ASN1decoding_t dec, PLocationRequest_destinationInfo val);
	extern void ASN1CALL ASN1Free_LocationRequest_destinationInfo_ElmFn(PLocationRequest_destinationInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_alternateEndpoints_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_alternateEndpoints val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_alternateEndpoints_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_alternateEndpoints val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_alternateEndpoints_ElmFn(PAdmissionConfirm_alternateEndpoints val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_remoteExtensionAddress val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_remoteExtensionAddress_ElmFn(PAdmissionConfirm_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_destExtraCallInfo_ElmFn(PAdmissionConfirm_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_destinationInfo_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_destinationInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_destinationInfo_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_destinationInfo val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_destinationInfo_ElmFn(PAdmissionConfirm_destinationInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_destAlternatives_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destAlternatives val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_destAlternatives_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destAlternatives val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_destAlternatives_ElmFn(PAdmissionRequest_destAlternatives val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_srcAlternatives_ElmFn(ASN1encoding_t enc, PAdmissionRequest_srcAlternatives val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_srcAlternatives_ElmFn(ASN1decoding_t dec, PAdmissionRequest_srcAlternatives val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_srcAlternatives_ElmFn(PAdmissionRequest_srcAlternatives val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_srcInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_srcInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_srcInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_srcInfo val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_srcInfo_ElmFn(PAdmissionRequest_srcInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_destExtraCallInfo_ElmFn(PAdmissionRequest_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_destinationInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destinationInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_destinationInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destinationInfo val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_destinationInfo_ElmFn(PAdmissionRequest_destinationInfo val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_alternateEndpoints val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_alternateEndpoints_ElmFn(PUnregistrationRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_endpointAlias_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_endpointAlias val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_endpointAlias_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_endpointAlias val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_endpointAlias_ElmFn(PUnregistrationRequest_endpointAlias val);
    extern int ASN1CALL ASN1Enc_RegistrationRejectReason_duplicateAlias_ElmFn(ASN1encoding_t enc, PRegistrationRejectReason_duplicateAlias val);
    extern int ASN1CALL ASN1Dec_RegistrationRejectReason_duplicateAlias_ElmFn(ASN1decoding_t dec, PRegistrationRejectReason_duplicateAlias val);
	extern void ASN1CALL ASN1Free_RegistrationRejectReason_duplicateAlias_ElmFn(PRegistrationRejectReason_duplicateAlias val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_terminalAlias_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_terminalAlias val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_terminalAlias_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_terminalAlias val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_terminalAlias_ElmFn(PRegistrationConfirm_terminalAlias val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PRegistrationRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PRegistrationRequest_alternateEndpoints val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_alternateEndpoints_ElmFn(PRegistrationRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_terminalAlias_ElmFn(ASN1encoding_t enc, PRegistrationRequest_terminalAlias val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_terminalAlias_ElmFn(ASN1decoding_t dec, PRegistrationRequest_terminalAlias val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_terminalAlias_ElmFn(PRegistrationRequest_terminalAlias val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_alternateEndpoints val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_alternateEndpoints_ElmFn(PGatekeeperRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_endpointAlias_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_endpointAlias val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_endpointAlias_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_endpointAlias val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_endpointAlias_ElmFn(PGatekeeperRequest_endpointAlias val);
    extern int ASN1CALL ASN1Enc_Endpoint_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PEndpoint_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_Endpoint_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PEndpoint_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_Endpoint_destExtraCallInfo_ElmFn(PEndpoint_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_Endpoint_destinationInfo_ElmFn(ASN1encoding_t enc, PEndpoint_destinationInfo val);
    extern int ASN1CALL ASN1Dec_Endpoint_destinationInfo_ElmFn(ASN1decoding_t dec, PEndpoint_destinationInfo val);
	extern void ASN1CALL ASN1Free_Endpoint_destinationInfo_ElmFn(PEndpoint_destinationInfo val);
    extern int ASN1CALL ASN1Enc_Endpoint_aliasAddress_ElmFn(ASN1encoding_t enc, PEndpoint_aliasAddress val);
    extern int ASN1CALL ASN1Dec_Endpoint_aliasAddress_ElmFn(ASN1decoding_t dec, PEndpoint_aliasAddress val);
	extern void ASN1CALL ASN1Free_Endpoint_aliasAddress_ElmFn(PEndpoint_aliasAddress val);
    extern int ASN1CALL ASN1Enc_NonStandardProtocol_supportedPrefixes_ElmFn(ASN1encoding_t enc, PNonStandardProtocol_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_NonStandardProtocol_supportedPrefixes_ElmFn(ASN1decoding_t dec, PNonStandardProtocol_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_NonStandardProtocol_supportedPrefixes_ElmFn(PNonStandardProtocol_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_T120OnlyCaps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PT120OnlyCaps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_T120OnlyCaps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PT120OnlyCaps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_T120OnlyCaps_supportedPrefixes_ElmFn(PT120OnlyCaps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_VoiceCaps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PVoiceCaps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_VoiceCaps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PVoiceCaps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_VoiceCaps_supportedPrefixes_ElmFn(PVoiceCaps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H324Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH324Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H324Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH324Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H324Caps_supportedPrefixes_ElmFn(PH324Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H323Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH323Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H323Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH323Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H323Caps_supportedPrefixes_ElmFn(PH323Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H322Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH322Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H322Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH322Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H322Caps_supportedPrefixes_ElmFn(PH322Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H321Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH321Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H321Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH321Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H321Caps_supportedPrefixes_ElmFn(PH321Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H320Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH320Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H320Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH320Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H320Caps_supportedPrefixes_ElmFn(PH320Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H310Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH310Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H310Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH310Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H310Caps_supportedPrefixes_ElmFn(PH310Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_GatewayInfo_protocol_ElmFn(ASN1encoding_t enc, PGatewayInfo_protocol val);
    extern int ASN1CALL ASN1Dec_GatewayInfo_protocol_ElmFn(ASN1decoding_t dec, PGatewayInfo_protocol val);
	extern void ASN1CALL ASN1Free_GatewayInfo_protocol_ElmFn(PGatewayInfo_protocol val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PFacility_UUIE_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PFacility_UUIE_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_destExtraCallInfo_ElmFn(PFacility_UUIE_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_alternativeAliasAddress_ElmFn(ASN1encoding_t enc, PFacility_UUIE_alternativeAliasAddress val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_alternativeAliasAddress_ElmFn(ASN1decoding_t dec, PFacility_UUIE_alternativeAliasAddress val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_alternativeAliasAddress_ElmFn(PFacility_UUIE_alternativeAliasAddress val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_destExtraCallInfo_ElmFn(PSetup_UUIE_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_destinationAddress_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destinationAddress val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_destinationAddress_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destinationAddress val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_destinationAddress_ElmFn(PSetup_UUIE_destinationAddress val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_sourceAddress_ElmFn(ASN1encoding_t enc, PSetup_UUIE_sourceAddress val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_sourceAddress_ElmFn(ASN1decoding_t dec, PSetup_UUIE_sourceAddress val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_sourceAddress_ElmFn(PSetup_UUIE_sourceAddress val);
    extern int ASN1CALL ASN1Enc_EnhancementLayerInfo_bPictureEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_bPictureEnhancement val);
    extern int ASN1CALL ASN1Dec_EnhancementLayerInfo_bPictureEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_bPictureEnhancement val);
	extern void ASN1CALL ASN1Free_EnhancementLayerInfo_bPictureEnhancement_ElmFn(PEnhancementLayerInfo_bPictureEnhancement val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_distributedData val);
	extern void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData_ElmFn(PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData val);
	extern void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData_ElmFn(PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_ResourcesAvailableConfirm_cryptoTokens_ElmFn(PResourcesAvailableConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_cryptoTokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_cryptoTokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_cryptoTokens val);
	extern void ASN1CALL ASN1Free_ResourcesAvailableIndicate_cryptoTokens_ElmFn(PResourcesAvailableIndicate_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_RequestInProgress_cryptoTokens_ElmFn(ASN1encoding_t enc, PRequestInProgress_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_RequestInProgress_cryptoTokens_ElmFn(ASN1decoding_t dec, PRequestInProgress_cryptoTokens val);
	extern void ASN1CALL ASN1Free_RequestInProgress_cryptoTokens_ElmFn(PRequestInProgress_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_UnknownMessageResponse_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnknownMessageResponse_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_UnknownMessageResponse_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnknownMessageResponse_cryptoTokens val);
	extern void ASN1CALL ASN1Free_UnknownMessageResponse_cryptoTokens_ElmFn(PUnknownMessageResponse_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_H225NonStandardMessage_cryptoTokens_ElmFn(ASN1encoding_t enc, PH225NonStandardMessage_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_H225NonStandardMessage_cryptoTokens_ElmFn(ASN1decoding_t dec, PH225NonStandardMessage_cryptoTokens val);
	extern void ASN1CALL ASN1Free_H225NonStandardMessage_cryptoTokens_ElmFn(PH225NonStandardMessage_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestNak_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestNak_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestNak_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestNak_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequestNak_cryptoTokens_ElmFn(PInfoRequestNak_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestAck_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestAck_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestAck_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestAck_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequestAck_cryptoTokens_ElmFn(PInfoRequestAck_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_cryptoTokens_ElmFn(PInfoRequestResponse_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequest_cryptoTokens_ElmFn(PInfoRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_DisengageReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_DisengageReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_DisengageReject_cryptoTokens_ElmFn(PDisengageReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_DisengageConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_DisengageConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_DisengageConfirm_cryptoTokens_ElmFn(PDisengageConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_DisengageRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_DisengageRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_DisengageRequest_cryptoTokens_ElmFn(PDisengageRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_LocationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_LocationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_LocationReject_cryptoTokens_ElmFn(PLocationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_LocationConfirm_cryptoTokens_ElmFn(PLocationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_LocationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_LocationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_LocationRequest_cryptoTokens_ElmFn(PLocationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_BandwidthReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_BandwidthReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_BandwidthReject_cryptoTokens_ElmFn(PBandwidthReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_BandwidthConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_BandwidthConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_BandwidthConfirm_cryptoTokens_ElmFn(PBandwidthConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_BandwidthRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_BandwidthRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_BandwidthRequest_cryptoTokens_ElmFn(PBandwidthRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_AdmissionReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_AdmissionReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_AdmissionReject_cryptoTokens_ElmFn(PAdmissionReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_cryptoTokens_ElmFn(PAdmissionConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_cryptoTokens_ElmFn(PAdmissionRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_UnregistrationReject_cryptoTokens_ElmFn(PUnregistrationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_UnregistrationConfirm_cryptoTokens_ElmFn(PUnregistrationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_cryptoTokens_ElmFn(PUnregistrationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_RegistrationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_RegistrationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_RegistrationReject_cryptoTokens_ElmFn(PRegistrationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_cryptoTokens_ElmFn(PRegistrationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_cryptoTokens_ElmFn(PRegistrationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_GatekeeperReject_cryptoTokens_ElmFn(PGatekeeperReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_GatekeeperConfirm_cryptoTokens_ElmFn(PGatekeeperConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_cryptoTokens_ElmFn(PGatekeeperRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_FastCap_caps_ElmFn(ASN1encoding_t enc, PFastCap_caps val);
    extern int ASN1CALL ASN1Dec_FastCap_caps_ElmFn(ASN1decoding_t dec, PFastCap_caps val);
	extern void ASN1CALL ASN1Free_FastCap_caps_ElmFn(PFastCap_caps val);
    extern int ASN1CALL ASN1Enc_Progress_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PProgress_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Progress_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PProgress_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Progress_UUIE_cryptoTokens_ElmFn(PProgress_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_conferences_ElmFn(ASN1encoding_t enc, PFacility_UUIE_conferences val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_conferences_ElmFn(ASN1decoding_t dec, PFacility_UUIE_conferences val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_conferences_ElmFn(PFacility_UUIE_conferences val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PFacility_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PFacility_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_cryptoTokens_ElmFn(PFacility_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PSetup_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PSetup_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_cryptoTokens_ElmFn(PSetup_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Connect_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PConnect_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Connect_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PConnect_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Connect_UUIE_cryptoTokens_ElmFn(PConnect_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_CallProceeding_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_CallProceeding_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_CallProceeding_UUIE_cryptoTokens_ElmFn(PCallProceeding_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Alerting_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Alerting_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Alerting_UUIE_cryptoTokens_ElmFn(PAlerting_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_pdu val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_pdu val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(PInfoRequestResponse_perCallInfo_Seq_pdu val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PSetup_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PSetup_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_fastStart_ElmFn(PSetup_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_Connect_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PConnect_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_Connect_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PConnect_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_Connect_UUIE_fastStart_ElmFn(PConnect_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_CallProceeding_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_CallProceeding_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_CallProceeding_UUIE_fastStart_ElmFn(PCallProceeding_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_Alerting_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_Alerting_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_Alerting_UUIE_fastStart_ElmFn(PAlerting_UUIE_fastStart val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _H225PP_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\h323asn1.h ===
#ifndef	__h323ics_h323asn1_h
#define	__h323ics_h323asn1_h

#include "q931msg.h"

DWORD H225EncodePdu (
	IN	DWORD		PduType,
	IN	PVOID		PduStructure,
	OUT	PUCHAR *	ReturnBuffer,
	OUT	PDWORD		ReturnBufferLength);

DWORD H225DecodePdu (
	IN	PUCHAR		Buffer,
	IN	DWORD		BufferLength,
	IN	DWORD		PduType,
	OUT	PVOID *		ReturnPduStructure);

DWORD H225FreePdu (
	IN	DWORD		PduType,
	IN	PVOID		PduStructure);

DWORD H225FreeBuffer (
	IN	PUCHAR		Buffer);

DWORD H245EncodePdu (
	IN	DWORD		PduType,
	IN	PVOID		PduStructure,
	OUT	PUCHAR *	ReturnBuffer,
	OUT	PDWORD		ReturnBufferLength);

DWORD H245DecodePdu (
	IN	PUCHAR		Buffer,
	IN	DWORD		BufferLength,
	IN	DWORD		PduType,
	OUT	PVOID *		ReturnPduStructure);

DWORD H245FreePdu (
	IN	DWORD		PduType,
	IN	PVOID		PduStructure);

DWORD H245FreeBuffer (
	IN	PUCHAR		Buffer);

// These macros define declarations for inline functions.
// This provides type safety when encoding and decoding certain PDUs.

#define	DECLARE_CODER_FUNCS(MODULE,STRUCTURE) \
/* static */ __inline DWORD MODULE ## EncodePdu_ ## STRUCTURE	\
	(STRUCTURE * PduStructure, OUT PUCHAR * ReturnBuffer, OUT PDWORD ReturnBufferLength)	\
	{ return MODULE ## EncodePdu (STRUCTURE ## _PDU, PduStructure, ReturnBuffer, ReturnBufferLength); }	\
/* static */ __inline DWORD MODULE ## DecodePdu_ ## STRUCTURE	\
	(IN PUCHAR Buffer, IN DWORD BufferLength, OUT STRUCTURE ** ReturnPduStructure)	\
	{ return MODULE ## DecodePdu (Buffer, BufferLength, STRUCTURE ## _PDU, (PVOID *) ReturnPduStructure); }	\
/* static */ __inline DWORD MODULE ## FreePdu_ ## STRUCTURE	\
	(IN STRUCTURE * PduStructure)	\
	{ return MODULE ## FreePdu (STRUCTURE ## _PDU, PduStructure); }

DECLARE_CODER_FUNCS (H225, RasMessage)
DECLARE_CODER_FUNCS (H225, H323_UserInformation)
DECLARE_CODER_FUNCS (H245, MultimediaSystemControlMessage)

void	H323ASN1Initialize	(void);
void	H323ASN1Shutdown	(void);


HRESULT EncodeQ931PDU(
        IN  Q931_MESSAGE           *pQ931msg,
        IN  H323_UserInformation   *pUserInformation,
        OUT BYTE                  **ppReturnEncodedData,
        OUT DWORD				   *pReturnEncodedDataLength
        );

HRESULT EncodeH245PDU(
	IN	MultimediaSystemControlMessage &rH245pdu,
	OUT	BYTE                          **ppReturnEncodedData,
	OUT	DWORD                          *pReturnEncodedDataLength);

HRESULT DecodeQ931PDU(
        IN  BYTE                       *pbData,
        IN  DWORD                       dwDataLen,
        OUT Q931_MESSAGE             **ppReturnQ931msg,
        OUT H323_UserInformation      **ppReturnH323UserInfo);

HRESULT DecodeH245PDU(
	IN  LPBYTE                              Data,
	IN  DWORD                               DataLength,
	OUT MultimediaSystemControlMessage    **ppReturnH245pdu);

HRESULT Q931EncodeCallProceedingMessage(
    IN      WORD                    CallRefVal,
    IN OUT  Q931_MESSAGE           *pReturnQ931msg,
    IN OUT  H323_UserInformation   *pReturnH323UserInfo);

HRESULT Q931EncodeReleaseCompleteMessage(
    IN      WORD                    CallRefVal,
    IN OUT  Q931_MESSAGE           *pReturnQ931msg,
    IN OUT  H323_UserInformation   *pReturnH323UserInfo);

// These functions should only be used for PDU structures generated
// using the decode functions.
// If you allocate the PDU structures yourself (for eg. CallProceeding PDU)
// then you need to free it yourself depending on how you allocated the
// structure.
void FreeQ931PDU(
     IN Q931_MESSAGE           *pQ931msg,
     IN H323_UserInformation   *pH323UserInformation);

void FreeH245PDU(
     MultimediaSystemControlMessage *pH245pdu);


#endif // __h323ics_h323asn1_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\ldap.h ===
#ifndef _LDAP_Module_H_
#define _LDAP_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct SearchResponse_entry_attributes_Seq_values * PSearchResponse_entry_attributes_Seq_values;

typedef struct ModifyRequest_modifications_Seq_modification_values * PModifyRequest_modifications_Seq_modification_values;

typedef struct AddRequest_attrs_Seq_values * PAddRequest_attrs_Seq_values;

typedef struct SearchResponse_entry_attributes * PSearchResponse_entry_attributes;

typedef struct SubstringFilter_attributes * PSubstringFilter_attributes;

typedef struct AddRequest_attrs * PAddRequest_attrs;

typedef struct ModifyRequest_modifications * PModifyRequest_modifications;

typedef struct SearchRequest_attributes * PSearchRequest_attributes;

typedef struct Filter_or * PFilter_or;

typedef struct Filter_and * PFilter_and;

typedef struct UnbindRequest {
    char placeholder;
} UnbindRequest;

typedef ASN1uint32_t MessageID;

typedef ASN1octetstring_t AttributeValue;

typedef ASN1octetstring_t LDAPString;

typedef MessageID AbandonRequest;

typedef LDAPString LDAPDN;

typedef LDAPString RelativeLDAPDN;

typedef LDAPString AttributeType;

typedef LDAPDN DelRequest;

typedef struct SearchResponse_entry_attributes_Seq_values {
    PSearchResponse_entry_attributes_Seq_values next;
    AttributeValue value;
} SearchResponse_entry_attributes_Seq_values_Element;

typedef struct ModifyRequest_modifications_Seq_modification_values {
    PModifyRequest_modifications_Seq_modification_values next;
    AttributeValue value;
} ModifyRequest_modifications_Seq_modification_values_Element;

typedef struct AddRequest_attrs_Seq_values {
    PAddRequest_attrs_Seq_values next;
    AttributeValue value;
} AddRequest_attrs_Seq_values_Element;

typedef struct ModifyRequest_modifications_Seq_modification {
    AttributeType type;
    PModifyRequest_modifications_Seq_modification_values values;
} ModifyRequest_modifications_Seq_modification;

typedef struct SearchResponse_entry_attributes_Seq {
    AttributeType type;
    PSearchResponse_entry_attributes_Seq_values values;
} SearchResponse_entry_attributes_Seq;

typedef struct SearchResponse_entry_attributes {
    PSearchResponse_entry_attributes next;
    SearchResponse_entry_attributes_Seq value;
} SearchResponse_entry_attributes_Element;

typedef enum operation {
    add = 0,
    operation_delete = 1,
    replace = 2,
} operation;
typedef struct ModifyRequest_modifications_Seq {
    operation operation;
    ModifyRequest_modifications_Seq_modification modification;
} ModifyRequest_modifications_Seq;

typedef struct AddRequest_attrs_Seq {
    AttributeType type;
    PAddRequest_attrs_Seq_values values;
} AddRequest_attrs_Seq;

typedef struct SubstringFilter_attributes_Seq {
    ASN1choice_t choice;
    union {
#	define initial_choice 1
	LDAPString initial;
#	define any_choice 2
	LDAPString any;
#	define final_choice 3
	LDAPString final;
    } u;
} SubstringFilter_attributes_Seq;

typedef struct SubstringFilter_attributes {
    PSubstringFilter_attributes next;
    SubstringFilter_attributes_Seq value;
} SubstringFilter_attributes_Element;

typedef struct AddRequest_attrs {
    PAddRequest_attrs next;
    AddRequest_attrs_Seq value;
} AddRequest_attrs_Element;

typedef struct ModifyRequest_modifications {
    PModifyRequest_modifications next;
    ModifyRequest_modifications_Seq value;
} ModifyRequest_modifications_Element;

typedef struct SearchResponse_entry {
    LDAPDN objectName;
    PSearchResponse_entry_attributes attributes;
} SearchResponse_entry;

typedef struct SearchRequest_attributes {
    PSearchRequest_attributes next;
    AttributeType value;
} SearchRequest_attributes_Element;

typedef struct SaslCredentials {
    LDAPString mechanism;
    ASN1octetstring_t credentials;
} SaslCredentials;

typedef struct ModifyRequest {
    LDAPDN object;
    PModifyRequest_modifications modifications;
} ModifyRequest;

typedef struct AddRequest {
    LDAPDN entry;
    PAddRequest_attrs attrs;
} AddRequest;

typedef struct ModifyRDNRequest {
    LDAPDN entry;
    RelativeLDAPDN newrdn;
} ModifyRDNRequest;

typedef enum resultCode {
    success = 0,
    operationsError = 1,
    protocolError = 2,
    timeLimitExceeded = 3,
    sizeLimitExceeded = 4,
    compareFalse = 5,
    compareTrue = 6,
    authMethodNotSupported = 7,
    strongAuthRequired = 8,
    noSuchAttribute = 16,
    undefinedAttributeType = 17,
    inappropriateMatching = 18,
    constraintViolation = 19,
    attributeOrValueExists = 20,
    invalidAttributeSyntax = 21,
    noSuchObject = 32,
    aliasProblem = 33,
    invalidDNSyntax = 34,
    isLeaf = 35,
    aliasDereferencingProblem = 36,
    inappropriateAuthentication = 48,
    invalidCredentials = 49,
    insufficientAccessRights = 50,
    busy = 51,
    unavailable = 52,
    unwillingToPerform = 53,
    loopDetect = 54,
    namingViolation = 64,
    objectClassViolation = 65,
    notAllowedOnNonLeaf = 66,
    notAllowedOnRDN = 67,
    entryAlreadyExists = 68,
    objectClassModsProhibited = 69,
    other = 80,
} resultCode;
typedef struct LDAPResult {
    resultCode resultCode;
    LDAPDN matchedDN;
    LDAPString errorMessage;
} LDAPResult;

typedef struct AttributeValueAssertion {
    AttributeType attributeType;
    AttributeValue attributeValue;
} AttributeValueAssertion;

typedef struct SubstringFilter {
    AttributeType type;
    PSubstringFilter_attributes attributes;
} SubstringFilter;

typedef struct AuthenticationChoice {
    ASN1choice_t choice;
    union {
#	define simple_choice 1
	ASN1octetstring_t simple;
#	define sasl_choice 2
	SaslCredentials sasl;
#	define sicilyNegotiate_choice 3
	ASN1octetstring_t sicilyNegotiate;
#	define sicilyInitial_choice 4
	ASN1octetstring_t sicilyInitial;
#	define sicilySubsequent_choice 5
	ASN1octetstring_t sicilySubsequent;
    } u;
} AuthenticationChoice;

typedef LDAPResult BindResponse;

typedef struct SearchResponse {
    ASN1choice_t choice;
    union {
#	define entry_choice 1
	SearchResponse_entry entry;
#	define resultCode_choice 2
	LDAPResult resultCode;
    } u;
} SearchResponse;

typedef LDAPResult ModifyResponse;

typedef LDAPResult AddResponse;

typedef LDAPResult DelResponse;

typedef LDAPResult ModifyRDNResponse;

typedef struct CompareRequest {
    LDAPDN entry;
    AttributeValueAssertion ava;
} CompareRequest;

typedef LDAPResult CompareResponse;

typedef struct Filter {
    ASN1choice_t choice;
    union {
#	define and_choice 1
	PFilter_and and;
#	define or_choice 2
	PFilter_or or;
#	define equalityMatch_choice 3
	AttributeValueAssertion equalityMatch;
#	define substrings_choice 4
	SubstringFilter substrings;
#	define greaterOrEqual_choice 5
	AttributeValueAssertion greaterOrEqual;
#	define lessOrEqual_choice 6
	AttributeValueAssertion lessOrEqual;
#	define present_choice 7
	AttributeType present;
#	define approxMatch_choice 8
	AttributeValueAssertion approxMatch;
    } u;
} Filter;

typedef struct Filter_or {
    PFilter_or next;
    Filter value;
} Filter_or_Element;

typedef struct Filter_and {
    PFilter_and next;
    Filter value;
} Filter_and_Element;

typedef struct BindRequest {
    ASN1uint16_t version;
    LDAPDN name;
    AuthenticationChoice authentication;
} BindRequest;

typedef enum scope {
    baseObject = 0,
    singleLevel = 1,
    wholeSubtree = 2,
} scope;
typedef enum derefAliases {
    neverDerefAliases = 0,
    derefInSearching = 1,
    derefFindingBaseObj = 2,
    alwaysDerefAliases = 3,
} derefAliases;
typedef struct SearchRequest {
    LDAPDN baseObject;
    scope scope;
    derefAliases derefAliases;
    ASN1uint32_t sizeLimit;
    ASN1uint32_t timeLimit;
    ASN1bool_t attrsOnly;
    Filter filter;
    PSearchRequest_attributes attributes;
} SearchRequest;

typedef struct LDAPMessage_protocolOp {
    ASN1choice_t choice;
    union {
#	define bindRequest_choice 1
	BindRequest bindRequest;
#	define bindResponse_choice 2
	BindResponse bindResponse;
#	define unbindRequest_choice 3
	UnbindRequest unbindRequest;
#	define searchRequest_choice 4
	SearchRequest searchRequest;
#	define searchResponse_choice 5
	SearchResponse searchResponse;
#	define modifyRequest_choice 6
	ModifyRequest modifyRequest;
#	define modifyResponse_choice 7
	ModifyResponse modifyResponse;
#	define addRequest_choice 8
	AddRequest addRequest;
#	define addResponse_choice 9
	AddResponse addResponse;
#	define delRequest_choice 10
	DelRequest delRequest;
#	define delResponse_choice 11
	DelResponse delResponse;
#	define modifyRDNRequest_choice 12
	ModifyRDNRequest modifyRDNRequest;
#	define modifyRDNResponse_choice 13
	ModifyRDNResponse modifyRDNResponse;
#	define compareDNRequest_choice 14
	CompareRequest compareDNRequest;
#	define compareDNResponse_choice 15
	CompareResponse compareDNResponse;
#	define abandonRequest_choice 16
	AbandonRequest abandonRequest;
    } u;
} LDAPMessage_protocolOp;

typedef struct LDAPMessage {
    MessageID messageID;
    LDAPMessage_protocolOp protocolOp;
} LDAPMessage;
#define LDAPMessage_ID 0
#define SIZE_LDAP_Module_ID_0 sizeof(LDAPMessage)

extern ASN1int32_t maxInt;

extern ASN1module_t LDAP_Module;
extern void ASN1CALL LDAP_Module_Startup(void);
extern void ASN1CALL LDAP_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _LDAP_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\ldap.c ===
#include <windows.h>
#include "ldap.h"

ASN1module_t LDAP_Module = NULL;

static int ASN1CALL ASN1Enc_SearchResponse_entry_attributes_Seq_values(ASN1encoding_t enc, ASN1uint32_t tag, PSearchResponse_entry_attributes_Seq_values *val);
static int ASN1CALL ASN1Enc_ModifyRequest_modifications_Seq_modification_values(ASN1encoding_t enc, ASN1uint32_t tag, PModifyRequest_modifications_Seq_modification_values *val);
static int ASN1CALL ASN1Enc_AddRequest_attrs_Seq_values(ASN1encoding_t enc, ASN1uint32_t tag, PAddRequest_attrs_Seq_values *val);
static int ASN1CALL ASN1Enc_ModifyRequest_modifications_Seq_modification(ASN1encoding_t enc, ASN1uint32_t tag, ModifyRequest_modifications_Seq_modification *val);
static int ASN1CALL ASN1Enc_SearchResponse_entry_attributes_Seq(ASN1encoding_t enc, ASN1uint32_t tag, SearchResponse_entry_attributes_Seq *val);
static int ASN1CALL ASN1Enc_SearchResponse_entry_attributes(ASN1encoding_t enc, ASN1uint32_t tag, PSearchResponse_entry_attributes *val);
static int ASN1CALL ASN1Enc_ModifyRequest_modifications_Seq(ASN1encoding_t enc, ASN1uint32_t tag, ModifyRequest_modifications_Seq *val);
static int ASN1CALL ASN1Enc_AddRequest_attrs_Seq(ASN1encoding_t enc, ASN1uint32_t tag, AddRequest_attrs_Seq *val);
static int ASN1CALL ASN1Enc_SubstringFilter_attributes_Seq(ASN1encoding_t enc, ASN1uint32_t tag, SubstringFilter_attributes_Seq *val);
static int ASN1CALL ASN1Enc_SubstringFilter_attributes(ASN1encoding_t enc, ASN1uint32_t tag, PSubstringFilter_attributes *val);
static int ASN1CALL ASN1Enc_AddRequest_attrs(ASN1encoding_t enc, ASN1uint32_t tag, PAddRequest_attrs *val);
static int ASN1CALL ASN1Enc_ModifyRequest_modifications(ASN1encoding_t enc, ASN1uint32_t tag, PModifyRequest_modifications *val);
static int ASN1CALL ASN1Enc_SearchResponse_entry(ASN1encoding_t enc, ASN1uint32_t tag, SearchResponse_entry *val);
static int ASN1CALL ASN1Enc_SearchRequest_attributes(ASN1encoding_t enc, ASN1uint32_t tag, PSearchRequest_attributes *val);
static int ASN1CALL ASN1Enc_SaslCredentials(ASN1encoding_t enc, ASN1uint32_t tag, SaslCredentials *val);
static int ASN1CALL ASN1Enc_ModifyRequest(ASN1encoding_t enc, ASN1uint32_t tag, ModifyRequest *val);
static int ASN1CALL ASN1Enc_AddRequest(ASN1encoding_t enc, ASN1uint32_t tag, AddRequest *val);
static int ASN1CALL ASN1Enc_ModifyRDNRequest(ASN1encoding_t enc, ASN1uint32_t tag, ModifyRDNRequest *val);
static int ASN1CALL ASN1Enc_LDAPResult(ASN1encoding_t enc, ASN1uint32_t tag, LDAPResult *val);
static int ASN1CALL ASN1Enc_AttributeValueAssertion(ASN1encoding_t enc, ASN1uint32_t tag, AttributeValueAssertion *val);
static int ASN1CALL ASN1Enc_SubstringFilter(ASN1encoding_t enc, ASN1uint32_t tag, SubstringFilter *val);
static int ASN1CALL ASN1Enc_AuthenticationChoice(ASN1encoding_t enc, ASN1uint32_t tag, AuthenticationChoice *val);
static int ASN1CALL ASN1Enc_BindResponse(ASN1encoding_t enc, ASN1uint32_t tag, BindResponse *val);
static int ASN1CALL ASN1Enc_SearchResponse(ASN1encoding_t enc, ASN1uint32_t tag, SearchResponse *val);
static int ASN1CALL ASN1Enc_ModifyResponse(ASN1encoding_t enc, ASN1uint32_t tag, ModifyResponse *val);
static int ASN1CALL ASN1Enc_AddResponse(ASN1encoding_t enc, ASN1uint32_t tag, AddResponse *val);
static int ASN1CALL ASN1Enc_DelResponse(ASN1encoding_t enc, ASN1uint32_t tag, DelResponse *val);
static int ASN1CALL ASN1Enc_ModifyRDNResponse(ASN1encoding_t enc, ASN1uint32_t tag, ModifyRDNResponse *val);
static int ASN1CALL ASN1Enc_CompareRequest(ASN1encoding_t enc, ASN1uint32_t tag, CompareRequest *val);
static int ASN1CALL ASN1Enc_CompareResponse(ASN1encoding_t enc, ASN1uint32_t tag, CompareResponse *val);
static int ASN1CALL ASN1Enc_Filter(ASN1encoding_t enc, ASN1uint32_t tag, Filter *val);
static int ASN1CALL ASN1Enc_Filter_or(ASN1encoding_t enc, ASN1uint32_t tag, PFilter_or *val);
static int ASN1CALL ASN1Enc_Filter_and(ASN1encoding_t enc, ASN1uint32_t tag, PFilter_and *val);
static int ASN1CALL ASN1Enc_BindRequest(ASN1encoding_t enc, ASN1uint32_t tag, BindRequest *val);
static int ASN1CALL ASN1Enc_SearchRequest(ASN1encoding_t enc, ASN1uint32_t tag, SearchRequest *val);
static int ASN1CALL ASN1Enc_LDAPMessage_protocolOp(ASN1encoding_t enc, ASN1uint32_t tag, LDAPMessage_protocolOp *val);
static int ASN1CALL ASN1Enc_LDAPMessage(ASN1encoding_t enc, ASN1uint32_t tag, LDAPMessage *val);
static int ASN1CALL ASN1Dec_SearchResponse_entry_attributes_Seq_values(ASN1decoding_t dec, ASN1uint32_t tag, PSearchResponse_entry_attributes_Seq_values *val);
static int ASN1CALL ASN1Dec_ModifyRequest_modifications_Seq_modification_values(ASN1decoding_t dec, ASN1uint32_t tag, PModifyRequest_modifications_Seq_modification_values *val);
static int ASN1CALL ASN1Dec_AddRequest_attrs_Seq_values(ASN1decoding_t dec, ASN1uint32_t tag, PAddRequest_attrs_Seq_values *val);
static int ASN1CALL ASN1Dec_ModifyRequest_modifications_Seq_modification(ASN1decoding_t dec, ASN1uint32_t tag, ModifyRequest_modifications_Seq_modification *val);
static int ASN1CALL ASN1Dec_SearchResponse_entry_attributes_Seq(ASN1decoding_t dec, ASN1uint32_t tag, SearchResponse_entry_attributes_Seq *val);
static int ASN1CALL ASN1Dec_SearchResponse_entry_attributes(ASN1decoding_t dec, ASN1uint32_t tag, PSearchResponse_entry_attributes *val);
static int ASN1CALL ASN1Dec_ModifyRequest_modifications_Seq(ASN1decoding_t dec, ASN1uint32_t tag, ModifyRequest_modifications_Seq *val);
static int ASN1CALL ASN1Dec_AddRequest_attrs_Seq(ASN1decoding_t dec, ASN1uint32_t tag, AddRequest_attrs_Seq *val);
static int ASN1CALL ASN1Dec_SubstringFilter_attributes_Seq(ASN1decoding_t dec, ASN1uint32_t tag, SubstringFilter_attributes_Seq *val);
static int ASN1CALL ASN1Dec_SubstringFilter_attributes(ASN1decoding_t dec, ASN1uint32_t tag, PSubstringFilter_attributes *val);
static int ASN1CALL ASN1Dec_AddRequest_attrs(ASN1decoding_t dec, ASN1uint32_t tag, PAddRequest_attrs *val);
static int ASN1CALL ASN1Dec_ModifyRequest_modifications(ASN1decoding_t dec, ASN1uint32_t tag, PModifyRequest_modifications *val);
static int ASN1CALL ASN1Dec_SearchResponse_entry(ASN1decoding_t dec, ASN1uint32_t tag, SearchResponse_entry *val);
static int ASN1CALL ASN1Dec_SearchRequest_attributes(ASN1decoding_t dec, ASN1uint32_t tag, PSearchRequest_attributes *val);
static int ASN1CALL ASN1Dec_SaslCredentials(ASN1decoding_t dec, ASN1uint32_t tag, SaslCredentials *val);
static int ASN1CALL ASN1Dec_ModifyRequest(ASN1decoding_t dec, ASN1uint32_t tag, ModifyRequest *val);
static int ASN1CALL ASN1Dec_AddRequest(ASN1decoding_t dec, ASN1uint32_t tag, AddRequest *val);
static int ASN1CALL ASN1Dec_ModifyRDNRequest(ASN1decoding_t dec, ASN1uint32_t tag, ModifyRDNRequest *val);
static int ASN1CALL ASN1Dec_LDAPResult(ASN1decoding_t dec, ASN1uint32_t tag, LDAPResult *val);
static int ASN1CALL ASN1Dec_AttributeValueAssertion(ASN1decoding_t dec, ASN1uint32_t tag, AttributeValueAssertion *val);
static int ASN1CALL ASN1Dec_SubstringFilter(ASN1decoding_t dec, ASN1uint32_t tag, SubstringFilter *val);
static int ASN1CALL ASN1Dec_AuthenticationChoice(ASN1decoding_t dec, ASN1uint32_t tag, AuthenticationChoice *val);
static int ASN1CALL ASN1Dec_BindResponse(ASN1decoding_t dec, ASN1uint32_t tag, BindResponse *val);
static int ASN1CALL ASN1Dec_SearchResponse(ASN1decoding_t dec, ASN1uint32_t tag, SearchResponse *val);
static int ASN1CALL ASN1Dec_ModifyResponse(ASN1decoding_t dec, ASN1uint32_t tag, ModifyResponse *val);
static int ASN1CALL ASN1Dec_AddResponse(ASN1decoding_t dec, ASN1uint32_t tag, AddResponse *val);
static int ASN1CALL ASN1Dec_DelResponse(ASN1decoding_t dec, ASN1uint32_t tag, DelResponse *val);
static int ASN1CALL ASN1Dec_ModifyRDNResponse(ASN1decoding_t dec, ASN1uint32_t tag, ModifyRDNResponse *val);
static int ASN1CALL ASN1Dec_CompareRequest(ASN1decoding_t dec, ASN1uint32_t tag, CompareRequest *val);
static int ASN1CALL ASN1Dec_CompareResponse(ASN1decoding_t dec, ASN1uint32_t tag, CompareResponse *val);
static int ASN1CALL ASN1Dec_Filter(ASN1decoding_t dec, ASN1uint32_t tag, Filter *val);
static int ASN1CALL ASN1Dec_Filter_or(ASN1decoding_t dec, ASN1uint32_t tag, PFilter_or *val);
static int ASN1CALL ASN1Dec_Filter_and(ASN1decoding_t dec, ASN1uint32_t tag, PFilter_and *val);
static int ASN1CALL ASN1Dec_BindRequest(ASN1decoding_t dec, ASN1uint32_t tag, BindRequest *val);
static int ASN1CALL ASN1Dec_SearchRequest(ASN1decoding_t dec, ASN1uint32_t tag, SearchRequest *val);
static int ASN1CALL ASN1Dec_LDAPMessage_protocolOp(ASN1decoding_t dec, ASN1uint32_t tag, LDAPMessage_protocolOp *val);
static int ASN1CALL ASN1Dec_LDAPMessage(ASN1decoding_t dec, ASN1uint32_t tag, LDAPMessage *val);
static void ASN1CALL ASN1Free_SearchResponse_entry_attributes_Seq_values(PSearchResponse_entry_attributes_Seq_values *val);
static void ASN1CALL ASN1Free_ModifyRequest_modifications_Seq_modification_values(PModifyRequest_modifications_Seq_modification_values *val);
static void ASN1CALL ASN1Free_AddRequest_attrs_Seq_values(PAddRequest_attrs_Seq_values *val);
static void ASN1CALL ASN1Free_ModifyRequest_modifications_Seq_modification(ModifyRequest_modifications_Seq_modification *val);
static void ASN1CALL ASN1Free_SearchResponse_entry_attributes_Seq(SearchResponse_entry_attributes_Seq *val);
static void ASN1CALL ASN1Free_SearchResponse_entry_attributes(PSearchResponse_entry_attributes *val);
static void ASN1CALL ASN1Free_ModifyRequest_modifications_Seq(ModifyRequest_modifications_Seq *val);
static void ASN1CALL ASN1Free_AddRequest_attrs_Seq(AddRequest_attrs_Seq *val);
static void ASN1CALL ASN1Free_SubstringFilter_attributes_Seq(SubstringFilter_attributes_Seq *val);
static void ASN1CALL ASN1Free_SubstringFilter_attributes(PSubstringFilter_attributes *val);
static void ASN1CALL ASN1Free_AddRequest_attrs(PAddRequest_attrs *val);
static void ASN1CALL ASN1Free_ModifyRequest_modifications(PModifyRequest_modifications *val);
static void ASN1CALL ASN1Free_SearchResponse_entry(SearchResponse_entry *val);
static void ASN1CALL ASN1Free_SearchRequest_attributes(PSearchRequest_attributes *val);
static void ASN1CALL ASN1Free_SaslCredentials(SaslCredentials *val);
static void ASN1CALL ASN1Free_ModifyRequest(ModifyRequest *val);
static void ASN1CALL ASN1Free_AddRequest(AddRequest *val);
static void ASN1CALL ASN1Free_ModifyRDNRequest(ModifyRDNRequest *val);
static void ASN1CALL ASN1Free_LDAPResult(LDAPResult *val);
static void ASN1CALL ASN1Free_AttributeValueAssertion(AttributeValueAssertion *val);
static void ASN1CALL ASN1Free_SubstringFilter(SubstringFilter *val);
static void ASN1CALL ASN1Free_AuthenticationChoice(AuthenticationChoice *val);
static void ASN1CALL ASN1Free_BindResponse(BindResponse *val);
static void ASN1CALL ASN1Free_SearchResponse(SearchResponse *val);
static void ASN1CALL ASN1Free_ModifyResponse(ModifyResponse *val);
static void ASN1CALL ASN1Free_AddResponse(AddResponse *val);
static void ASN1CALL ASN1Free_DelResponse(DelResponse *val);
static void ASN1CALL ASN1Free_ModifyRDNResponse(ModifyRDNResponse *val);
static void ASN1CALL ASN1Free_CompareRequest(CompareRequest *val);
static void ASN1CALL ASN1Free_CompareResponse(CompareResponse *val);
static void ASN1CALL ASN1Free_Filter(Filter *val);
static void ASN1CALL ASN1Free_Filter_or(PFilter_or *val);
static void ASN1CALL ASN1Free_Filter_and(PFilter_and *val);
static void ASN1CALL ASN1Free_BindRequest(BindRequest *val);
static void ASN1CALL ASN1Free_SearchRequest(SearchRequest *val);
static void ASN1CALL ASN1Free_LDAPMessage_protocolOp(LDAPMessage_protocolOp *val);
static void ASN1CALL ASN1Free_LDAPMessage(LDAPMessage *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[1] = {
    (ASN1EncFun_t) ASN1Enc_LDAPMessage,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[1] = {
    (ASN1DecFun_t) ASN1Dec_LDAPMessage,
};
static const ASN1FreeFun_t freefntab[1] = {
    (ASN1FreeFun_t) ASN1Free_LDAPMessage,
};
static const ULONG sizetab[1] = {
    SIZE_LDAP_Module_ID_0,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */
ASN1int32_t maxInt = 2147483647;

void ASN1CALL LDAP_Module_Startup(void)
{
    LDAP_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_BER, ASN1FLAGS_NONE, 1, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x0);
}

void ASN1CALL LDAP_Module_Cleanup(void)
{
    ASN1_CloseModule(LDAP_Module);
    LDAP_Module = NULL;
}

static int ASN1CALL ASN1Enc_SearchResponse_entry_attributes_Seq_values(ASN1encoding_t enc, ASN1uint32_t tag, PSearchResponse_entry_attributes_Seq_values *val)
{
    PSearchResponse_entry_attributes_Seq_values f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncOctetString(enc, 0x4, (f->value).length, (f->value).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SearchResponse_entry_attributes_Seq_values(ASN1decoding_t dec, ASN1uint32_t tag, PSearchResponse_entry_attributes_Seq_values *val)
{
    PSearchResponse_entry_attributes_Seq_values *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PSearchResponse_entry_attributes_Seq_values)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecOctetString(dd, 0x4, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SearchResponse_entry_attributes_Seq_values(PSearchResponse_entry_attributes_Seq_values *val)
{
    PSearchResponse_entry_attributes_Seq_values f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1octetstring_free(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_ModifyRequest_modifications_Seq_modification_values(ASN1encoding_t enc, ASN1uint32_t tag, PModifyRequest_modifications_Seq_modification_values *val)
{
    PModifyRequest_modifications_Seq_modification_values f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncOctetString(enc, 0x4, (f->value).length, (f->value).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ModifyRequest_modifications_Seq_modification_values(ASN1decoding_t dec, ASN1uint32_t tag, PModifyRequest_modifications_Seq_modification_values *val)
{
    PModifyRequest_modifications_Seq_modification_values *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PModifyRequest_modifications_Seq_modification_values)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecOctetString(dd, 0x4, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ModifyRequest_modifications_Seq_modification_values(PModifyRequest_modifications_Seq_modification_values *val)
{
    PModifyRequest_modifications_Seq_modification_values f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1octetstring_free(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_AddRequest_attrs_Seq_values(ASN1encoding_t enc, ASN1uint32_t tag, PAddRequest_attrs_Seq_values *val)
{
    PAddRequest_attrs_Seq_values f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncOctetString(enc, 0x4, (f->value).length, (f->value).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AddRequest_attrs_Seq_values(ASN1decoding_t dec, ASN1uint32_t tag, PAddRequest_attrs_Seq_values *val)
{
    PAddRequest_attrs_Seq_values *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PAddRequest_attrs_Seq_values)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecOctetString(dd, 0x4, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AddRequest_attrs_Seq_values(PAddRequest_attrs_Seq_values *val)
{
    PAddRequest_attrs_Seq_values f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1octetstring_free(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_ModifyRequest_modifications_Seq_modification(ASN1encoding_t enc, ASN1uint32_t tag, ModifyRequest_modifications_Seq_modification *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->type).length, ((val)->type).value))
	return 0;
    if (!ASN1Enc_ModifyRequest_modifications_Seq_modification_values(enc, 0, &(val)->values))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ModifyRequest_modifications_Seq_modification(ASN1decoding_t dec, ASN1uint32_t tag, ModifyRequest_modifications_Seq_modification *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->type))
	return 0;
    if (!ASN1Dec_ModifyRequest_modifications_Seq_modification_values(dd, 0, &(val)->values))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ModifyRequest_modifications_Seq_modification(ModifyRequest_modifications_Seq_modification *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->type);
	ASN1Free_ModifyRequest_modifications_Seq_modification_values(&(val)->values);
    }
}

static int ASN1CALL ASN1Enc_SearchResponse_entry_attributes_Seq(ASN1encoding_t enc, ASN1uint32_t tag, SearchResponse_entry_attributes_Seq *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->type).length, ((val)->type).value))
	return 0;
    if (!ASN1Enc_SearchResponse_entry_attributes_Seq_values(enc, 0, &(val)->values))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SearchResponse_entry_attributes_Seq(ASN1decoding_t dec, ASN1uint32_t tag, SearchResponse_entry_attributes_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->type))
	return 0;
    if (!ASN1Dec_SearchResponse_entry_attributes_Seq_values(dd, 0, &(val)->values))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SearchResponse_entry_attributes_Seq(SearchResponse_entry_attributes_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->type);
	ASN1Free_SearchResponse_entry_attributes_Seq_values(&(val)->values);
    }
}

static int ASN1CALL ASN1Enc_SearchResponse_entry_attributes(ASN1encoding_t enc, ASN1uint32_t tag, PSearchResponse_entry_attributes *val)
{
    PSearchResponse_entry_attributes f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_SearchResponse_entry_attributes_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SearchResponse_entry_attributes(ASN1decoding_t dec, ASN1uint32_t tag, PSearchResponse_entry_attributes *val)
{
    PSearchResponse_entry_attributes *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PSearchResponse_entry_attributes)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_SearchResponse_entry_attributes_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SearchResponse_entry_attributes(PSearchResponse_entry_attributes *val)
{
    PSearchResponse_entry_attributes f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_SearchResponse_entry_attributes_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_ModifyRequest_modifications_Seq(ASN1encoding_t enc, ASN1uint32_t tag, ModifyRequest_modifications_Seq *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0xa, (val)->operation))
	return 0;
    if (!ASN1Enc_ModifyRequest_modifications_Seq_modification(enc, 0, &(val)->modification))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ModifyRequest_modifications_Seq(ASN1decoding_t dec, ASN1uint32_t tag, ModifyRequest_modifications_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0xa, (ASN1uint32_t *) &(val)->operation))
	return 0;
    if (!ASN1Dec_ModifyRequest_modifications_Seq_modification(dd, 0, &(val)->modification))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ModifyRequest_modifications_Seq(ModifyRequest_modifications_Seq *val)
{
    if (val) {
	ASN1Free_ModifyRequest_modifications_Seq_modification(&(val)->modification);
    }
}

static int ASN1CALL ASN1Enc_AddRequest_attrs_Seq(ASN1encoding_t enc, ASN1uint32_t tag, AddRequest_attrs_Seq *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->type).length, ((val)->type).value))
	return 0;
    if (!ASN1Enc_AddRequest_attrs_Seq_values(enc, 0, &(val)->values))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AddRequest_attrs_Seq(ASN1decoding_t dec, ASN1uint32_t tag, AddRequest_attrs_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->type))
	return 0;
    if (!ASN1Dec_AddRequest_attrs_Seq_values(dd, 0, &(val)->values))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AddRequest_attrs_Seq(AddRequest_attrs_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->type);
	ASN1Free_AddRequest_attrs_Seq_values(&(val)->values);
    }
}

static int ASN1CALL ASN1Enc_SubstringFilter_attributes_Seq(ASN1encoding_t enc, ASN1uint32_t tag, SubstringFilter_attributes_Seq *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncOctetString(enc, 0x80000000, ((val)->u.initial).length, ((val)->u.initial).value))
	    return 0;
	break;
    case 2:
	if (!ASN1BEREncOctetString(enc, 0x80000001, ((val)->u.any).length, ((val)->u.any).value))
	    return 0;
	break;
    case 3:
	if (!ASN1BEREncOctetString(enc, 0x80000002, ((val)->u.final).length, ((val)->u.final).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SubstringFilter_attributes_Seq(ASN1decoding_t dec, ASN1uint32_t tag, SubstringFilter_attributes_Seq *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecOctetString(dec, 0x80000000, &(val)->u.initial))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000001, &(val)->u.any))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1BERDecOctetString(dec, 0x80000002, &(val)->u.final))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SubstringFilter_attributes_Seq(SubstringFilter_attributes_Seq *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1octetstring_free(&(val)->u.initial);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.any);
	    break;
	case 3:
	    ASN1octetstring_free(&(val)->u.final);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_SubstringFilter_attributes(ASN1encoding_t enc, ASN1uint32_t tag, PSubstringFilter_attributes *val)
{
    PSubstringFilter_attributes f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_SubstringFilter_attributes_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SubstringFilter_attributes(ASN1decoding_t dec, ASN1uint32_t tag, PSubstringFilter_attributes *val)
{
    PSubstringFilter_attributes *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PSubstringFilter_attributes)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_SubstringFilter_attributes_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SubstringFilter_attributes(PSubstringFilter_attributes *val)
{
    PSubstringFilter_attributes f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_SubstringFilter_attributes_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_AddRequest_attrs(ASN1encoding_t enc, ASN1uint32_t tag, PAddRequest_attrs *val)
{
    PAddRequest_attrs f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_AddRequest_attrs_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AddRequest_attrs(ASN1decoding_t dec, ASN1uint32_t tag, PAddRequest_attrs *val)
{
    PAddRequest_attrs *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PAddRequest_attrs)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_AddRequest_attrs_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AddRequest_attrs(PAddRequest_attrs *val)
{
    PAddRequest_attrs f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_AddRequest_attrs_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_ModifyRequest_modifications(ASN1encoding_t enc, ASN1uint32_t tag, PModifyRequest_modifications *val)
{
    PModifyRequest_modifications f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_ModifyRequest_modifications_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ModifyRequest_modifications(ASN1decoding_t dec, ASN1uint32_t tag, PModifyRequest_modifications *val)
{
    PModifyRequest_modifications *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PModifyRequest_modifications)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_ModifyRequest_modifications_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ModifyRequest_modifications(PModifyRequest_modifications *val)
{
    PModifyRequest_modifications f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_ModifyRequest_modifications_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_SearchResponse_entry(ASN1encoding_t enc, ASN1uint32_t tag, SearchResponse_entry *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000004, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->objectName).length, ((val)->objectName).value))
	return 0;
    if (!ASN1Enc_SearchResponse_entry_attributes(enc, 0, &(val)->attributes))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SearchResponse_entry(ASN1decoding_t dec, ASN1uint32_t tag, SearchResponse_entry *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000004, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->objectName))
	return 0;
    if (!ASN1Dec_SearchResponse_entry_attributes(dd, 0, &(val)->attributes))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SearchResponse_entry(SearchResponse_entry *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->objectName);
	ASN1Free_SearchResponse_entry_attributes(&(val)->attributes);
    }
}

static int ASN1CALL ASN1Enc_SearchRequest_attributes(ASN1encoding_t enc, ASN1uint32_t tag, PSearchRequest_attributes *val)
{
    PSearchRequest_attributes f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncOctetString(enc, 0x4, (f->value).length, (f->value).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SearchRequest_attributes(ASN1decoding_t dec, ASN1uint32_t tag, PSearchRequest_attributes *val)
{
    PSearchRequest_attributes *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PSearchRequest_attributes)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecOctetString(dd, 0x4, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SearchRequest_attributes(PSearchRequest_attributes *val)
{
    PSearchRequest_attributes f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1octetstring_free(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_SaslCredentials(ASN1encoding_t enc, ASN1uint32_t tag, SaslCredentials *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->mechanism).length, ((val)->mechanism).value))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->credentials).length, ((val)->credentials).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SaslCredentials(ASN1decoding_t dec, ASN1uint32_t tag, SaslCredentials *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->mechanism))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->credentials))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SaslCredentials(SaslCredentials *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->mechanism);
	ASN1octetstring_free(&(val)->credentials);
    }
}

static int ASN1CALL ASN1Enc_ModifyRequest(ASN1encoding_t enc, ASN1uint32_t tag, ModifyRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000006, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->object).length, ((val)->object).value))
	return 0;
    if (!ASN1Enc_ModifyRequest_modifications(enc, 0, &(val)->modifications))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ModifyRequest(ASN1decoding_t dec, ASN1uint32_t tag, ModifyRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000006, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->object))
	return 0;
    if (!ASN1Dec_ModifyRequest_modifications(dd, 0, &(val)->modifications))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ModifyRequest(ModifyRequest *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->object);
	ASN1Free_ModifyRequest_modifications(&(val)->modifications);
    }
}

static int ASN1CALL ASN1Enc_AddRequest(ASN1encoding_t enc, ASN1uint32_t tag, AddRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000008, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->entry).length, ((val)->entry).value))
	return 0;
    if (!ASN1Enc_AddRequest_attrs(enc, 0, &(val)->attrs))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AddRequest(ASN1decoding_t dec, ASN1uint32_t tag, AddRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000008, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->entry))
	return 0;
    if (!ASN1Dec_AddRequest_attrs(dd, 0, &(val)->attrs))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AddRequest(AddRequest *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->entry);
	ASN1Free_AddRequest_attrs(&(val)->attrs);
    }
}

static int ASN1CALL ASN1Enc_ModifyRDNRequest(ASN1encoding_t enc, ASN1uint32_t tag, ModifyRDNRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000c, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->entry).length, ((val)->entry).value))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->newrdn).length, ((val)->newrdn).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ModifyRDNRequest(ASN1decoding_t dec, ASN1uint32_t tag, ModifyRDNRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000c, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->entry))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->newrdn))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ModifyRDNRequest(ModifyRDNRequest *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->entry);
	ASN1octetstring_free(&(val)->newrdn);
    }
}

static int ASN1CALL ASN1Enc_LDAPResult(ASN1encoding_t enc, ASN1uint32_t tag, LDAPResult *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0xa, (val)->resultCode))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->matchedDN).length, ((val)->matchedDN).value))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->errorMessage).length, ((val)->errorMessage).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LDAPResult(ASN1decoding_t dec, ASN1uint32_t tag, LDAPResult *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0xa, (ASN1uint32_t *) &(val)->resultCode))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->matchedDN))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->errorMessage))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LDAPResult(LDAPResult *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->matchedDN);
	ASN1octetstring_free(&(val)->errorMessage);
    }
}

static int ASN1CALL ASN1Enc_AttributeValueAssertion(ASN1encoding_t enc, ASN1uint32_t tag, AttributeValueAssertion *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->attributeType).length, ((val)->attributeType).value))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->attributeValue).length, ((val)->attributeValue).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeValueAssertion(ASN1decoding_t dec, ASN1uint32_t tag, AttributeValueAssertion *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->attributeType))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->attributeValue))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeValueAssertion(AttributeValueAssertion *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->attributeType);
	ASN1octetstring_free(&(val)->attributeValue);
    }
}

static int ASN1CALL ASN1Enc_SubstringFilter(ASN1encoding_t enc, ASN1uint32_t tag, SubstringFilter *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->type).length, ((val)->type).value))
	return 0;
    if (!ASN1Enc_SubstringFilter_attributes(enc, 0, &(val)->attributes))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SubstringFilter(ASN1decoding_t dec, ASN1uint32_t tag, SubstringFilter *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->type))
	return 0;
    if (!ASN1Dec_SubstringFilter_attributes(dd, 0, &(val)->attributes))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SubstringFilter(SubstringFilter *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->type);
	ASN1Free_SubstringFilter_attributes(&(val)->attributes);
    }
}

static int ASN1CALL ASN1Enc_AuthenticationChoice(ASN1encoding_t enc, ASN1uint32_t tag, AuthenticationChoice *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncOctetString(enc, 0x80000000, ((val)->u.simple).length, ((val)->u.simple).value))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_SaslCredentials(enc, 0x80000003, &(val)->u.sasl))
	    return 0;
	break;
    case 3:
	if (!ASN1BEREncOctetString(enc, 0x80000009, ((val)->u.sicilyNegotiate).length, ((val)->u.sicilyNegotiate).value))
	    return 0;
	break;
    case 4:
	if (!ASN1BEREncOctetString(enc, 0x8000000a, ((val)->u.sicilyInitial).length, ((val)->u.sicilyInitial).value))
	    return 0;
	break;
    case 5:
	if (!ASN1BEREncOctetString(enc, 0x8000000b, ((val)->u.sicilySubsequent).length, ((val)->u.sicilySubsequent).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AuthenticationChoice(ASN1decoding_t dec, ASN1uint32_t tag, AuthenticationChoice *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecOctetString(dec, 0x80000000, &(val)->u.simple))
	    return 0;
	break;
    case 0x80000003:
	(val)->choice = 2;
	if (!ASN1Dec_SaslCredentials(dec, 0x80000003, &(val)->u.sasl))
	    return 0;
	break;
    case 0x80000009:
	(val)->choice = 3;
	if (!ASN1BERDecOctetString(dec, 0x80000009, &(val)->u.sicilyNegotiate))
	    return 0;
	break;
    case 0x8000000a:
	(val)->choice = 4;
	if (!ASN1BERDecOctetString(dec, 0x8000000a, &(val)->u.sicilyInitial))
	    return 0;
	break;
    case 0x8000000b:
	(val)->choice = 5;
	if (!ASN1BERDecOctetString(dec, 0x8000000b, &(val)->u.sicilySubsequent))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AuthenticationChoice(AuthenticationChoice *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1octetstring_free(&(val)->u.simple);
	    break;
	case 2:
	    ASN1Free_SaslCredentials(&(val)->u.sasl);
	    break;
	case 3:
	    ASN1octetstring_free(&(val)->u.sicilyNegotiate);
	    break;
	case 4:
	    ASN1octetstring_free(&(val)->u.sicilyInitial);
	    break;
	case 5:
	    ASN1octetstring_free(&(val)->u.sicilySubsequent);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BindResponse(ASN1encoding_t enc, ASN1uint32_t tag, BindResponse *val)
{
    if (!ASN1Enc_LDAPResult(enc, tag ? tag : 0x40000001, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BindResponse(ASN1decoding_t dec, ASN1uint32_t tag, BindResponse *val)
{
    if (!ASN1Dec_LDAPResult(dec, tag ? tag : 0x40000001, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BindResponse(BindResponse *val)
{
    if (val) {
	ASN1Free_LDAPResult(val);
    }
}

static int ASN1CALL ASN1Enc_SearchResponse(ASN1encoding_t enc, ASN1uint32_t tag, SearchResponse *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_SearchResponse_entry(enc, 0, &(val)->u.entry))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_LDAPResult(enc, 0x40000005, &(val)->u.resultCode))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SearchResponse(ASN1decoding_t dec, ASN1uint32_t tag, SearchResponse *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x40000004:
	(val)->choice = 1;
	if (!ASN1Dec_SearchResponse_entry(dec, 0, &(val)->u.entry))
	    return 0;
	break;
    case 0x40000005:
	(val)->choice = 2;
	if (!ASN1Dec_LDAPResult(dec, 0x40000005, &(val)->u.resultCode))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SearchResponse(SearchResponse *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_SearchResponse_entry(&(val)->u.entry);
	    break;
	case 2:
	    ASN1Free_LDAPResult(&(val)->u.resultCode);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ModifyResponse(ASN1encoding_t enc, ASN1uint32_t tag, ModifyResponse *val)
{
    if (!ASN1Enc_LDAPResult(enc, tag ? tag : 0x40000007, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ModifyResponse(ASN1decoding_t dec, ASN1uint32_t tag, ModifyResponse *val)
{
    if (!ASN1Dec_LDAPResult(dec, tag ? tag : 0x40000007, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ModifyResponse(ModifyResponse *val)
{
    if (val) {
	ASN1Free_LDAPResult(val);
    }
}

static int ASN1CALL ASN1Enc_AddResponse(ASN1encoding_t enc, ASN1uint32_t tag, AddResponse *val)
{
    if (!ASN1Enc_LDAPResult(enc, tag ? tag : 0x40000009, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AddResponse(ASN1decoding_t dec, ASN1uint32_t tag, AddResponse *val)
{
    if (!ASN1Dec_LDAPResult(dec, tag ? tag : 0x40000009, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AddResponse(AddResponse *val)
{
    if (val) {
	ASN1Free_LDAPResult(val);
    }
}

static int ASN1CALL ASN1Enc_DelResponse(ASN1encoding_t enc, ASN1uint32_t tag, DelResponse *val)
{
    if (!ASN1Enc_LDAPResult(enc, tag ? tag : 0x4000000b, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DelResponse(ASN1decoding_t dec, ASN1uint32_t tag, DelResponse *val)
{
    if (!ASN1Dec_LDAPResult(dec, tag ? tag : 0x4000000b, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DelResponse(DelResponse *val)
{
    if (val) {
	ASN1Free_LDAPResult(val);
    }
}

static int ASN1CALL ASN1Enc_ModifyRDNResponse(ASN1encoding_t enc, ASN1uint32_t tag, ModifyRDNResponse *val)
{
    if (!ASN1Enc_LDAPResult(enc, tag ? tag : 0x4000000d, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ModifyRDNResponse(ASN1decoding_t dec, ASN1uint32_t tag, ModifyRDNResponse *val)
{
    if (!ASN1Dec_LDAPResult(dec, tag ? tag : 0x4000000d, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ModifyRDNResponse(ModifyRDNResponse *val)
{
    if (val) {
	ASN1Free_LDAPResult(val);
    }
}

static int ASN1CALL ASN1Enc_CompareRequest(ASN1encoding_t enc, ASN1uint32_t tag, CompareRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000e, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->entry).length, ((val)->entry).value))
	return 0;
    if (!ASN1Enc_AttributeValueAssertion(enc, 0, &(val)->ava))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CompareRequest(ASN1decoding_t dec, ASN1uint32_t tag, CompareRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000e, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->entry))
	return 0;
    if (!ASN1Dec_AttributeValueAssertion(dd, 0, &(val)->ava))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CompareRequest(CompareRequest *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->entry);
	ASN1Free_AttributeValueAssertion(&(val)->ava);
    }
}

static int ASN1CALL ASN1Enc_CompareResponse(ASN1encoding_t enc, ASN1uint32_t tag, CompareResponse *val)
{
    if (!ASN1Enc_LDAPResult(enc, tag ? tag : 0x4000000f, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CompareResponse(ASN1decoding_t dec, ASN1uint32_t tag, CompareResponse *val)
{
    if (!ASN1Dec_LDAPResult(dec, tag ? tag : 0x4000000f, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CompareResponse(CompareResponse *val)
{
    if (val) {
	ASN1Free_LDAPResult(val);
    }
}

static int ASN1CALL ASN1Enc_Filter(ASN1encoding_t enc, ASN1uint32_t tag, Filter *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_Filter_and(enc, 0, &(val)->u.and))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_Filter_or(enc, 0, &(val)->u.or))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_AttributeValueAssertion(enc, 0x80000003, &(val)->u.equalityMatch))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_SubstringFilter(enc, 0x80000004, &(val)->u.substrings))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_AttributeValueAssertion(enc, 0x80000005, &(val)->u.greaterOrEqual))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_AttributeValueAssertion(enc, 0x80000006, &(val)->u.lessOrEqual))
	    return 0;
	break;
    case 7:
	if (!ASN1BEREncOctetString(enc, 0x80000007, ((val)->u.present).length, ((val)->u.present).value))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_AttributeValueAssertion(enc, 0x80000008, &(val)->u.approxMatch))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Filter(ASN1decoding_t dec, ASN1uint32_t tag, Filter *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1Dec_Filter_and(dec, 0, &(val)->u.and))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1Dec_Filter_or(dec, 0, &(val)->u.or))
	    return 0;
	break;
    case 0x80000003:
	(val)->choice = 3;
	if (!ASN1Dec_AttributeValueAssertion(dec, 0x80000003, &(val)->u.equalityMatch))
	    return 0;
	break;
    case 0x80000004:
	(val)->choice = 4;
	if (!ASN1Dec_SubstringFilter(dec, 0x80000004, &(val)->u.substrings))
	    return 0;
	break;
    case 0x80000005:
	(val)->choice = 5;
	if (!ASN1Dec_AttributeValueAssertion(dec, 0x80000005, &(val)->u.greaterOrEqual))
	    return 0;
	break;
    case 0x80000006:
	(val)->choice = 6;
	if (!ASN1Dec_AttributeValueAssertion(dec, 0x80000006, &(val)->u.lessOrEqual))
	    return 0;
	break;
    case 0x80000007:
	(val)->choice = 7;
	if (!ASN1BERDecOctetString(dec, 0x80000007, &(val)->u.present))
	    return 0;
	break;
    case 0x80000008:
	(val)->choice = 8;
	if (!ASN1Dec_AttributeValueAssertion(dec, 0x80000008, &(val)->u.approxMatch))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Filter(Filter *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_Filter_and(&(val)->u.and);
	    break;
	case 2:
	    ASN1Free_Filter_or(&(val)->u.or);
	    break;
	case 3:
	    ASN1Free_AttributeValueAssertion(&(val)->u.equalityMatch);
	    break;
	case 4:
	    ASN1Free_SubstringFilter(&(val)->u.substrings);
	    break;
	case 5:
	    ASN1Free_AttributeValueAssertion(&(val)->u.greaterOrEqual);
	    break;
	case 6:
	    ASN1Free_AttributeValueAssertion(&(val)->u.lessOrEqual);
	    break;
	case 7:
	    ASN1octetstring_free(&(val)->u.present);
	    break;
	case 8:
	    ASN1Free_AttributeValueAssertion(&(val)->u.approxMatch);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_Filter_or(ASN1encoding_t enc, ASN1uint32_t tag, PFilter_or *val)
{
    PFilter_or f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_Filter(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Filter_or(ASN1decoding_t dec, ASN1uint32_t tag, PFilter_or *val)
{
    PFilter_or *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PFilter_or)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_Filter(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Filter_or(PFilter_or *val)
{
    PFilter_or f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_Filter(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_Filter_and(ASN1encoding_t enc, ASN1uint32_t tag, PFilter_and *val)
{
    PFilter_and f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000000, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_Filter(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Filter_and(ASN1decoding_t dec, ASN1uint32_t tag, PFilter_and *val)
{
    PFilter_and *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000000, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PFilter_and)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_Filter(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Filter_and(PFilter_and *val)
{
    PFilter_and f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_Filter(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_BindRequest(ASN1encoding_t enc, ASN1uint32_t tag, BindRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000000, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->name).length, ((val)->name).value))
	return 0;
    if (!ASN1Enc_AuthenticationChoice(enc, 0, &(val)->authentication))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BindRequest(ASN1decoding_t dec, ASN1uint32_t tag, BindRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000000, &dd, &di))
	return 0;
    if (!ASN1BERDecU16Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->name))
	return 0;
    if (!ASN1Dec_AuthenticationChoice(dd, 0, &(val)->authentication))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BindRequest(BindRequest *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->name);
	ASN1Free_AuthenticationChoice(&(val)->authentication);
    }
}

static int ASN1CALL ASN1Enc_SearchRequest(ASN1encoding_t enc, ASN1uint32_t tag, SearchRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000003, &nLenOff))
	return 0;
    if (!ASN1BEREncOctetString(enc, 0x4, ((val)->baseObject).length, ((val)->baseObject).value))
	return 0;
    if (!ASN1BEREncU32(enc, 0xa, (val)->scope))
	return 0;
    if (!ASN1BEREncU32(enc, 0xa, (val)->derefAliases))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->sizeLimit))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->timeLimit))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->attrsOnly))
	return 0;
    if (!ASN1Enc_Filter(enc, 0, &(val)->filter))
	return 0;
    if (!ASN1Enc_SearchRequest_attributes(enc, 0, &(val)->attributes))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SearchRequest(ASN1decoding_t dec, ASN1uint32_t tag, SearchRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000003, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->baseObject))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0xa, (ASN1uint32_t *) &(val)->scope))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0xa, (ASN1uint32_t *) &(val)->derefAliases))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->sizeLimit))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->timeLimit))
	return 0;
    if (!ASN1BERDecBool(dd, 0x1, &(val)->attrsOnly))
	return 0;
    if (!ASN1Dec_Filter(dd, 0, &(val)->filter))
	return 0;
    if (!ASN1Dec_SearchRequest_attributes(dd, 0, &(val)->attributes))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SearchRequest(SearchRequest *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->baseObject);
	ASN1Free_Filter(&(val)->filter);
	ASN1Free_SearchRequest_attributes(&(val)->attributes);
    }
}

static int ASN1CALL ASN1Enc_LDAPMessage_protocolOp(ASN1encoding_t enc, ASN1uint32_t tag, LDAPMessage_protocolOp *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_BindRequest(enc, 0, &(val)->u.bindRequest))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_BindResponse(enc, 0, &(val)->u.bindResponse))
	    return 0;
	break;
    case 3:
	if (!ASN1BEREncNull(enc, 0x40000002))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_SearchRequest(enc, 0, &(val)->u.searchRequest))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_SearchResponse(enc, 0, &(val)->u.searchResponse))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_ModifyRequest(enc, 0, &(val)->u.modifyRequest))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_ModifyResponse(enc, 0, &(val)->u.modifyResponse))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_AddRequest(enc, 0, &(val)->u.addRequest))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_AddResponse(enc, 0, &(val)->u.addResponse))
	    return 0;
	break;
    case 10:
	if (!ASN1BEREncOctetString(enc, 0x4000000a, ((val)->u.delRequest).length, ((val)->u.delRequest).value))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_DelResponse(enc, 0, &(val)->u.delResponse))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_ModifyRDNRequest(enc, 0, &(val)->u.modifyRDNRequest))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_ModifyRDNResponse(enc, 0, &(val)->u.modifyRDNResponse))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_CompareRequest(enc, 0, &(val)->u.compareDNRequest))
	    return 0;
	break;
    case 15:
	if (!ASN1Enc_CompareResponse(enc, 0, &(val)->u.compareDNResponse))
	    return 0;
	break;
    case 16:
	if (!ASN1BEREncU32(enc, 0x40000010, (val)->u.abandonRequest))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_LDAPMessage_protocolOp(ASN1decoding_t dec, ASN1uint32_t tag, LDAPMessage_protocolOp *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x40000000:
	(val)->choice = 1;
	if (!ASN1Dec_BindRequest(dec, 0, &(val)->u.bindRequest))
	    return 0;
	break;
    case 0x40000001:
	(val)->choice = 2;
	if (!ASN1Dec_BindResponse(dec, 0, &(val)->u.bindResponse))
	    return 0;
	break;
    case 0x40000002:
	(val)->choice = 3;
	if (!ASN1BERDecNull(dec, 0x40000002))
	    return 0;
	break;
    case 0x40000003:
	(val)->choice = 4;
	if (!ASN1Dec_SearchRequest(dec, 0, &(val)->u.searchRequest))
	    return 0;
	break;
    case 0x40000004:
    case 0x40000005:
	(val)->choice = 5;
	if (!ASN1Dec_SearchResponse(dec, 0, &(val)->u.searchResponse))
	    return 0;
	break;
    case 0x40000006:
	(val)->choice = 6;
	if (!ASN1Dec_ModifyRequest(dec, 0, &(val)->u.modifyRequest))
	    return 0;
	break;
    case 0x40000007:
	(val)->choice = 7;
	if (!ASN1Dec_ModifyResponse(dec, 0, &(val)->u.modifyResponse))
	    return 0;
	break;
    case 0x40000008:
	(val)->choice = 8;
	if (!ASN1Dec_AddRequest(dec, 0, &(val)->u.addRequest))
	    return 0;
	break;
    case 0x40000009:
	(val)->choice = 9;
	if (!ASN1Dec_AddResponse(dec, 0, &(val)->u.addResponse))
	    return 0;
	break;
    case 0x4000000a:
	(val)->choice = 10;
	if (!ASN1BERDecOctetString(dec, 0x4000000a, &(val)->u.delRequest))
	    return 0;
	break;
    case 0x4000000b:
	(val)->choice = 11;
	if (!ASN1Dec_DelResponse(dec, 0, &(val)->u.delResponse))
	    return 0;
	break;
    case 0x4000000c:
	(val)->choice = 12;
	if (!ASN1Dec_ModifyRDNRequest(dec, 0, &(val)->u.modifyRDNRequest))
	    return 0;
	break;
    case 0x4000000d:
	(val)->choice = 13;
	if (!ASN1Dec_ModifyRDNResponse(dec, 0, &(val)->u.modifyRDNResponse))
	    return 0;
	break;
    case 0x4000000e:
	(val)->choice = 14;
	if (!ASN1Dec_CompareRequest(dec, 0, &(val)->u.compareDNRequest))
	    return 0;
	break;
    case 0x4000000f:
	(val)->choice = 15;
	if (!ASN1Dec_CompareResponse(dec, 0, &(val)->u.compareDNResponse))
	    return 0;
	break;
    case 0x40000010:
	(val)->choice = 16;
	if (!ASN1BERDecU32Val(dec, 0x40000010, (ASN1uint32_t *) &(val)->u.abandonRequest))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_LDAPMessage_protocolOp(LDAPMessage_protocolOp *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_BindRequest(&(val)->u.bindRequest);
	    break;
	case 2:
	    ASN1Free_BindResponse(&(val)->u.bindResponse);
	    break;
	case 4:
	    ASN1Free_SearchRequest(&(val)->u.searchRequest);
	    break;
	case 5:
	    ASN1Free_SearchResponse(&(val)->u.searchResponse);
	    break;
	case 6:
	    ASN1Free_ModifyRequest(&(val)->u.modifyRequest);
	    break;
	case 7:
	    ASN1Free_ModifyResponse(&(val)->u.modifyResponse);
	    break;
	case 8:
	    ASN1Free_AddRequest(&(val)->u.addRequest);
	    break;
	case 9:
	    ASN1Free_AddResponse(&(val)->u.addResponse);
	    break;
	case 10:
	    ASN1octetstring_free(&(val)->u.delRequest);
	    break;
	case 11:
	    ASN1Free_DelResponse(&(val)->u.delResponse);
	    break;
	case 12:
	    ASN1Free_ModifyRDNRequest(&(val)->u.modifyRDNRequest);
	    break;
	case 13:
	    ASN1Free_ModifyRDNResponse(&(val)->u.modifyRDNResponse);
	    break;
	case 14:
	    ASN1Free_CompareRequest(&(val)->u.compareDNRequest);
	    break;
	case 15:
	    ASN1Free_CompareResponse(&(val)->u.compareDNResponse);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_LDAPMessage(ASN1encoding_t enc, ASN1uint32_t tag, LDAPMessage *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->messageID))
	return 0;
    if (!ASN1Enc_LDAPMessage_protocolOp(enc, 0, &(val)->protocolOp))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LDAPMessage(ASN1decoding_t dec, ASN1uint32_t tag, LDAPMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->messageID))
	return 0;
    if (!ASN1Dec_LDAPMessage_protocolOp(dd, 0, &(val)->protocolOp))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LDAPMessage(LDAPMessage *val)
{
    if (val) {
	ASN1Free_LDAPMessage_protocolOp(&(val)->protocolOp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\logchan.h ===
#ifndef __h323ics_logchan_h
#define __h323ics_logchan_h

// This decides the maximum number of T120 TCP/IP Connections
// to be allowed. We create so many NAT redirects.
#define MAX_T120_TCP_CONNECTIONS_ALLOWED 5

// Logical channel states. These are
// H245 related but there is one per
// logical channel
// NOTE: there is no enum value for the final closed state
// as the logical channel is destroyed when that state is reached
enum LOGICAL_CHANNEL_STATE
{
    LC_STATE_NOT_INIT = 0,
    LC_STATE_OPEN_RCVD,
    LC_STATE_OPEN_ACK_RCVD,
    LC_STATE_CLOSE_RCVD,
    LC_STATE_OPENED_CLOSE_RCVD
};


// Media Types of the logical channels

enum MEDIA_TYPE
{
    MEDIA_TYPE_UNDEFINED    = 0,
    MEDIA_TYPE_RTP          = 0x1000,
    MEDIA_TYPE_T120         = 0x2000,
    MEDIA_TYPE_AUDIO        = MEDIA_TYPE_RTP  | 0x1, //0x1001
    MEDIA_TYPE_VIDEO        = MEDIA_TYPE_RTP  | 0x2, //0x1002
    MEDIA_TYPE_DATA         = MEDIA_TYPE_T120 | 0x1, //0x2000
};

inline BOOL IsMediaTypeRtp(MEDIA_TYPE MediaType)
{
    return (MediaType & MEDIA_TYPE_RTP);
}

inline BOOL IsMediaTypeT120(MEDIA_TYPE MediaType)
{
    return (MediaType & MEDIA_TYPE_T120);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Logical Channel                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


// This is an abstract base class which defines the operations
// for different types of logical channels.
// RTP_LOGICAL_CHANNEL and T120_LOGICAL_CHANNEL are derived from
// this class.

// Only OpenLogicalChannel and OpenLogicalChannelAck PDUs need
// to be handled differently for the RTP and T.120 Logical channels
// So all the other methods are defined in this class.

class LOGICAL_CHANNEL :
    public TIMER_PROCESSOR
{
    
public:

    inline LOGICAL_CHANNEL();

    HRESULT CreateTimer(DWORD TimeoutValue);

    // the event manager tells us about timer expiry via this method
    virtual void TimerCallback();

    virtual HRESULT HandleCloseLogicalChannelPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    // This is a pure virtual function which is different
    // for the RTP and T.120 logical channels.
    virtual HRESULT ProcessOpenLogicalChannelAckPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        )= 0;

    virtual HRESULT ProcessOpenLogicalChannelRejectPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    virtual HRESULT ProcessCloseLogicalChannelAckPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    // releases any pending associations
    virtual ~LOGICAL_CHANNEL();

    inline BYTE GetSessionId();

    inline WORD GetLogicalChannelNumber();

    inline MEDIA_TYPE GetMediaType();

    inline LOGICAL_CHANNEL_STATE GetLogicalChannelState();
    
	void IncrementLifetimeCounter  (void);
	void DecrementLifetimeCounter (void);

protected:

    // Initializes member variables
    inline void InitLogicalChannel(
        IN H245_INFO               *pH245Info,
        IN MEDIA_TYPE               MediaType,
        IN WORD                     LogicalChannelNumber,
        IN BYTE                     SessionId,
        IN LOGICAL_CHANNEL_STATE    LogicalChannelState
        );
    
    // returns a reference to the source H245 info
    inline H245_INFO &GetH245Info();

    inline CALL_BRIDGE &GetCallBridge();

    inline void DeleteAndRemoveSelf();

    // the logical channel belongs to this H245 channel
    // this supplies the ip addresses needed for NAT redirect
    H245_INFO *m_pH245Info;

    // handle for any active timers
    // TIMER_HANDLE m_TimerHandle;

    // state of the logical channel
    LOGICAL_CHANNEL_STATE   m_LogicalChannelState;

    // logical channel number
    // cannot be 0 as that is reserved for the h245 channel
    WORD    m_LogicalChannelNumber;

    // The type of the media (currently Audio/Video/Data)
    MEDIA_TYPE m_MediaType;

    // session id - this is used to associate with a 
    // logical  channel from the other end if any
    BYTE    m_SessionId;
    
}; // class LOGICAL_CHANNEL

inline 
LOGICAL_CHANNEL::LOGICAL_CHANNEL(
    )
{
    InitLogicalChannel(NULL, MEDIA_TYPE_UNDEFINED,
                       0,0,LC_STATE_NOT_INIT);
}

inline 
LOGICAL_CHANNEL::~LOGICAL_CHANNEL(
    )
{}

inline void
LOGICAL_CHANNEL::InitLogicalChannel(
    IN H245_INFO               *pH245Info,
    IN MEDIA_TYPE               MediaType,
    IN WORD                     LogicalChannelNumber,
    IN BYTE                     SessionId,
    IN LOGICAL_CHANNEL_STATE    LogicalChannelState
    )
{
    m_pH245Info             = pH245Info;
    m_MediaType             = MediaType;
    m_LogicalChannelNumber  = LogicalChannelNumber;
    m_SessionId             = SessionId;
    m_LogicalChannelState   = LogicalChannelState;
}


inline BYTE 
LOGICAL_CHANNEL::GetSessionId(
    )
{
    return m_SessionId;
}

inline WORD 
LOGICAL_CHANNEL::GetLogicalChannelNumber(
    )
{
    return m_LogicalChannelNumber;
}

inline MEDIA_TYPE 
LOGICAL_CHANNEL::GetMediaType(
    )
{

    return m_MediaType;
}

inline LOGICAL_CHANNEL_STATE 
LOGICAL_CHANNEL::GetLogicalChannelState(
    )
{
    return m_LogicalChannelState;
}

// returns a reference to the source H245 info
inline H245_INFO &
LOGICAL_CHANNEL::GetH245Info(
    )
{
    _ASSERTE(NULL != m_pH245Info);
    return *m_pH245Info;
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// RTP Logical Channel                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


class RTP_LOGICAL_CHANNEL :
    public LOGICAL_CHANNEL
{
public:

    inline RTP_LOGICAL_CHANNEL();

    // all of these are available in the OPEN LOGICAL CHANNEL message
    // except the associated logical channel, which if supplied provides
    // the member m_Own*RTP/RTCP Ports. If not, these are allocated.
    // the association is implied by a matching session id in a logical
    // channel in the other call state
    // it modifies the RTCP address information in the OLC PDU
    // and passes it on to the other H245 instance for forwarding.
    HRESULT HandleOpenLogicalChannelPDU(
        IN H245_INFO                            &H245Info,
        IN MEDIA_TYPE                           MediaType,
        IN DWORD                                LocalIPv4Address,
        IN DWORD                                RemoteIPv4Address,
        IN DWORD                                OtherLocalIPv4Address,
        IN DWORD                                OtherRemoteIPv4Address,
        IN WORD                                 LogicalChannelNumber,
        IN BYTE                                 SessionId,
        IN RTP_LOGICAL_CHANNEL                  *pAssocLogicalChannel,
		IN DWORD								SourceRTCPIPv4Address,
		IN WORD									SourceRTCPPort,
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    virtual HRESULT ProcessOpenLogicalChannelAckPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    // releases any pending associations
    virtual ~RTP_LOGICAL_CHANNEL();

    inline DWORD GetSourceRTCPIPv4Address();

    inline WORD GetSourceRTCPPort();

    inline WORD GetOwnSourceSendRTCPPort();

    inline WORD GetOwnSourceRecvRTCPPort();

    inline WORD GetOwnSourceRecvRTPPort();

    inline WORD GetOwnDestSendRTCPPort();

    inline WORD GetOwnDestRecvRTCPPort();

    inline WORD GetOwnDestSendRTPPort();

    inline DWORD GetDestRTCPIPv4Address();

    inline WORD GetDestRTCPPort();

    inline DWORD GetDestRTPIPv4Address();

    inline WORD GetDestRTPPort();


protected:

    // points to the associated logical channel from the other end if any
    // non-NULL iff associated
    // need to ensure that the AssocLogicalChannel also points
    // to this logical channel
    // CODEWORK: Do assertion checks for this condition.
    RTP_LOGICAL_CHANNEL *m_pAssocLogicalChannel;

    // local and remote addresses for the h245 instance this logical
    // channel is associated with (source side)
    DWORD   m_OwnSourceIPv4Address;
    DWORD   m_SourceIPv4Address;

    // local and remote addresses for the other h245 instance 
    // (dest side)
    DWORD   m_OwnDestIPv4Address;
    DWORD   m_DestIPv4Address;

    // these ports are negotiated in h245 OpenLogicalChannel and
    // OpenLogicalChannelAck. They are given to NAT for redirecting
    // RTP and RTCP traffic
    // while the RTP packets flow only one way (source->dest), RTCP
    // packets flow both ways

    // we only know the source's receive RTCP port. the send port
    // is not known
    DWORD   m_SourceRTCPIPv4Address;
    WORD    m_SourceRTCPPort;

    // these are the send/recv RTP/RTCP ports on the interface that 
    // communicates with the source. since we don't deal with the
    // reverse RTP stream, we don't need a send RTP port
    WORD    m_OwnSourceSendRTCPPort;
    WORD    m_OwnSourceRecvRTCPPort;
    WORD    m_OwnSourceRecvRTPPort;

    // these are the send/recv RTP/RTCP ports on the interface that 
    // communicates with the source. since we don't deal with the
    // reverse RTP stream, we don't need a recv RTP port
    WORD    m_OwnDestSendRTCPPort;
    WORD    m_OwnDestSendRTPPort;
    WORD    m_OwnDestRecvRTCPPort;

    WORD    m_OwnAssocLCRecvRTPPort; // this is used to allocate consecutive
                                     // ports for RTP/RTCP.
    WORD    m_OwnAssocLCSendRTPPort;
    
    // destination's RTCP ip address, port
    DWORD   m_DestRTCPIPv4Address;
    WORD    m_DestRTCPPort;

    // destination's RTP ip address, port
    DWORD   m_DestRTPIPv4Address;
    WORD    m_DestRTPPort;


    // SetAssociationRef, ResetAssociationRef methods can be accessed
    // by other LOGICAL_CHANNEL instances but not by other instances of
    // classes that are not derived from LOGICAL_CHANNEL

    inline void SetAssociationRef(
        IN RTP_LOGICAL_CHANNEL &LogicalChannel
        );

    inline void ResetAssociationRef();

    inline void ReleaseAssociationAndPorts();

private:
    
    // set the RTP and RTCP ports. if there is an associated channel,
    // we must share the RTCP ports
    HRESULT SetPorts();

    HRESULT CheckOpenLogicalChannelAckPDU(
        IN  MultimediaSystemControlMessage  &H245pdu,
        OUT BYTE                            &SessionId,
        OUT DWORD                           &DestRTPIPv4Address,
        OUT WORD                            &DestRTPPort,
        OUT DWORD                           &DestRTCPIPv4Address,
        OUT WORD                            &DestRTCPPort
        );

    // opens the forward RTP, forward RTCP and reverse RTCP streams
    HRESULT OpenNATMappings();

    // closes any NAT mappings
    void CloseNATMappings();
};

inline 
RTP_LOGICAL_CHANNEL::RTP_LOGICAL_CHANNEL(
    )
    : m_pAssocLogicalChannel(NULL),
      //m_TimerHandle(NULL),
      m_OwnSourceIPv4Address(0),
      m_SourceIPv4Address(0),
      m_OwnDestIPv4Address(0),
      m_DestIPv4Address(0),
      m_SourceRTCPIPv4Address(0),
      m_SourceRTCPPort(0),
      m_OwnSourceSendRTCPPort(0),
      m_OwnSourceRecvRTCPPort(0),
      m_OwnSourceRecvRTPPort(0),
      m_OwnDestSendRTCPPort(0),
      m_OwnDestRecvRTCPPort(0),
      m_OwnDestSendRTPPort(0),
      m_DestRTCPIPv4Address(0),
      m_DestRTCPPort(0),
      m_DestRTPIPv4Address(0),
      m_DestRTPPort(0)
{
    InitLogicalChannel(NULL, MEDIA_TYPE_UNDEFINED,
                       0,0,LC_STATE_NOT_INIT);
}

inline void 
RTP_LOGICAL_CHANNEL::SetAssociationRef(
    IN RTP_LOGICAL_CHANNEL &LogicalChannel
    )
{
    // if the source or dest terminal is generating two logical
    // channels (in the same direction) with the same session id, we'll
    // find a prior logical channel in the array with the same session id
    // and thus never reach here
    _ASSERTE(NULL == m_pAssocLogicalChannel);
    m_pAssocLogicalChannel = &LogicalChannel;
}

inline void 
RTP_LOGICAL_CHANNEL::ResetAssociationRef(
    )
{
    _ASSERTE(NULL != m_pAssocLogicalChannel);
    m_pAssocLogicalChannel = NULL;

    // we, now, own the RTP/RTCP ports that were being shared so far
}

inline DWORD 
RTP_LOGICAL_CHANNEL::GetSourceRTCPIPv4Address(
    )
{
    return m_SourceRTCPIPv4Address;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetSourceRTCPPort(
    )
{
    return m_SourceRTCPPort;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetOwnSourceSendRTCPPort(
    )
{
    return m_OwnSourceSendRTCPPort;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetOwnSourceRecvRTCPPort(
    )
{
    return m_OwnSourceRecvRTCPPort;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetOwnSourceRecvRTPPort(
    )
{
    return m_OwnSourceRecvRTPPort;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetOwnDestSendRTCPPort(
    )
{
    return m_OwnDestSendRTCPPort;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetOwnDestRecvRTCPPort(
    )
{
    return m_OwnDestRecvRTCPPort;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetOwnDestSendRTPPort(
    )
{
    return m_OwnDestSendRTPPort;
}


inline DWORD 
RTP_LOGICAL_CHANNEL::GetDestRTCPIPv4Address(
    )
{
    return m_DestRTCPIPv4Address;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetDestRTCPPort(
    )
{
    return m_DestRTCPPort;
}

inline DWORD 
RTP_LOGICAL_CHANNEL::GetDestRTPIPv4Address(
    )
{
    return m_DestRTPIPv4Address;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetDestRTPPort(
    )
{
    return m_DestRTPPort;
}




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// T.120 Logical Channel                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


class T120_LOGICAL_CHANNEL :
    public LOGICAL_CHANNEL
{
public:

    inline T120_LOGICAL_CHANNEL();

    // all of these are available in the OPEN LOGICAL CHANNEL message
    // it modifies the OLC PDU and passes it on to the other H245
    // instance for forwarding ???
    HRESULT HandleOpenLogicalChannelPDU(
        IN H245_INFO                            &H245Info,
        IN MEDIA_TYPE                           MediaType,
        IN WORD                                 LogicalChannelNumber,
        IN BYTE                                 SessionId,
        IN DWORD                                T120ConnectToIPAddr,
        IN WORD                                 T120ConnectToPort,
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    virtual HRESULT ProcessOpenLogicalChannelAckPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    // releases any pending associations
    virtual ~T120_LOGICAL_CHANNEL();


protected:

    // We store all the address and port information in host order.
    // We need to convert them to network order before we pass them
    // to the NAT functions.
    
    // These are the IP Address and port the T.120 end point is listening
    // on for the T.120 connection. We need to connect to this address.
    DWORD   m_T120ConnectToIPAddr;
    WORD    m_T120ConnectToPort;
    
    // These are the IP Address and port we will be listening on.
    // We send this information in the OLC or OLCAck PDU and the T.120
    // end point will connect to this address.
    DWORD   m_T120ListenOnIPAddr;
    WORD    m_T120ListenOnPort;

    // These are the IP Address and port we will be using in the NAT
    // redirect as the new source address of the TCP connection.
    // Once the remote T.120 end point receives a TCP conection,
    // it thinks that the connection is "from" this address.
    // CODEWORK: Any better names ??
    DWORD   m_T120ConnectFromIPAddr;
    WORD    m_T120ConnectFromPorts[MAX_T120_TCP_CONNECTIONS_ALLOWED];

    // Note that we do not know the actual source address and port
    // from which the T.120 endpoint connects. This address is only
    // established when the T.120 endpoint actually calls connect.
    // We pass 0 (wild card) for these fields in the NAT redirect.

private:
    // Allocate m_T120ConnectFromPorts and m_T120ListenOnPort
    HRESULT SetPorts(
        DWORD T120ConnectToIPAddr,
        WORD  T120ConnectToPort,
        DWORD T120ListenOnIPAddr,
        DWORD T120ConnectFromIPAddr
        );

    // Free m_T120ConnectFromPorts and m_T120ListenOnPort
    // if they have been allocated.
    HRESULT FreePorts();
    
    // opens the bidirectional NAT redirect for the TCP stream
    HRESULT CreateNatRedirect();

    // closes any NAT redirect
    void CancelNatRedirect();

    HRESULT CheckOpenLogicalChannelAckPDU(
        IN  OpenLogicalChannelAck   &OlcPDU,
        OUT DWORD                   &T120ConnectToIPAddr,
        OUT WORD                    &T120ConnectToPort
        );
};


inline 
T120_LOGICAL_CHANNEL::T120_LOGICAL_CHANNEL(
    )
    : m_T120ConnectToIPAddr(INADDR_NONE),
      m_T120ConnectToPort(0),
      m_T120ListenOnIPAddr(INADDR_NONE),
      m_T120ListenOnPort(0),
      m_T120ConnectFromIPAddr(INADDR_NONE)
{
    for (int i = 0; i < MAX_T120_TCP_CONNECTIONS_ALLOWED; i++)
    {
        m_T120ConnectFromPorts[i] = 0;
    }
    
    InitLogicalChannel(NULL,MEDIA_TYPE_UNDEFINED,
                       0,0,LC_STATE_NOT_INIT);
}


// expandable array of pointer values
template <class T>
class DYNAMIC_POINTER_ARRAY
{
public:

    // number of blocks allocated for a new addition
    // when the array becomes full
#define DEFAULT_BLOCK_SIZE 4

	inline DYNAMIC_POINTER_ARRAY();

    // assumption: other member variables are all 0/NULL
    inline void Init(
        IN DWORD BlockSize = DEFAULT_BLOCK_SIZE
        );

    virtual ~DYNAMIC_POINTER_ARRAY();

    inline T **GetData()
    {
        return m_pData;
    }

    inline DWORD GetSize()
    {
        return m_NumElements;
    }

    DWORD Find(
        IN T& Val
        ) const;

    HRESULT Add(
        IN T &NewVal
        );

    inline T *Get(
        IN  DWORD   Index
        );
    
    inline HRESULT RemoveAt(
        IN DWORD Index
        );

    inline HRESULT Remove(
        IN  T   &Val
        );

protected:

    T       **m_pData;
    DWORD   m_NumElements;

    DWORD   m_AllocElements;

    DWORD   m_BlockSize;
};


template <class T>
inline 
DYNAMIC_POINTER_ARRAY<T>::DYNAMIC_POINTER_ARRAY(
	)
	: m_pData(NULL),
	  m_NumElements(0),
	  m_AllocElements(0),
	  m_BlockSize(0)
{
}

template <class T>
inline void 
DYNAMIC_POINTER_ARRAY<T>::Init(
    IN DWORD BlockSize /* = DEFAULT_BLOCK_SIZE */
    )
{
	_ASSERTE(NULL == m_pData);
    if (0 != BlockSize)
    {
        m_BlockSize = BlockSize;
    }
    else
    {
        m_BlockSize = DEFAULT_BLOCK_SIZE;
    }
}


// NOTE: uses realloc and free to grow/manage the array of pointers.
// This is better than new/delete as the additional memory is allocated
// in-place (i.e. the array ptr remains same) eliminating the need to copy
// memory from the old block to the new block and also reduces 
// heap fragmentation
template <class T>
HRESULT
DYNAMIC_POINTER_ARRAY<T>::Add(
    IN T &NewVal
    )
{
	if(m_NumElements == m_AllocElements)
    {
        typedef T *T_PTR;
        T** ppT = NULL;
        DWORD NewAllocElements = m_NumElements + m_BlockSize;
        ppT = (class LOGICAL_CHANNEL **) 
				realloc(m_pData, NewAllocElements * sizeof(T_PTR));
        if(NULL == ppT)
        {
            return E_OUTOFMEMORY;
        }

		// set the m_pData member to the newly allocated memory
        m_pData = ppT;
		m_AllocElements = NewAllocElements;
    }

    m_pData[m_NumElements] = &NewVal;
    m_NumElements++;
    return S_OK;
}

template <class T>
inline T *
DYNAMIC_POINTER_ARRAY<T>::Get(
    IN  DWORD   Index
    )
{
    _ASSERTE(Index < m_NumElements);
    if (Index < m_NumElements)
    {
        return m_pData[Index];
    }
    else
    {
        return NULL;
    }
}
    
template <class T>
inline HRESULT 
DYNAMIC_POINTER_ARRAY<T>::RemoveAt(
    IN DWORD Index
    )
{
    _ASSERTE(Index < m_NumElements);
    if (Index >= m_NumElements)
    {
        return E_FAIL;
    }

    // move all elements (to the right), left by one block
    memmove(
        (void*)&m_pData[Index], 
        (void*)&m_pData[Index + 1], 
        (m_NumElements - (Index + 1)) * sizeof(T *)
        );
    m_NumElements--;    
    return S_OK;
}

template <class T>
inline HRESULT 
DYNAMIC_POINTER_ARRAY<T>::Remove(
    IN  T   &Val
    )
{
    DWORD Index = Find(Val);
    if(Index >= m_NumElements)
    {
        return E_FAIL;
    }

    return RemoveAt(Index);
}

template <class T>
DWORD 
DYNAMIC_POINTER_ARRAY<T>::Find(
    IN T& Val
    ) const
{
    // search for an array element thats same as the passed
	// in value
    for(DWORD Index = 0; Index < m_NumElements; Index++)
    {
        if(m_pData[(DWORD)Index] == &Val)
        {
            return Index;
        }
    }

    return m_NumElements;      // not found
}

template <class T>
/* virtual */
DYNAMIC_POINTER_ARRAY<T>::~DYNAMIC_POINTER_ARRAY(
    )
{
    if (NULL != m_pData)
    {
        // delete each of the elements in the array
        for(DWORD Index = 0; Index < m_NumElements; Index++)
        {
            _ASSERTE(NULL != m_pData[Index]);
            delete m_pData[Index];
        }

        // free the array memory block
		free(m_pData);
    }
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Logical Channel Array                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


class LOGICAL_CHANNEL_ARRAY :
    public DYNAMIC_POINTER_ARRAY<LOGICAL_CHANNEL>
{
    typedef DYNAMIC_POINTER_ARRAY<LOGICAL_CHANNEL> BASE_CLASS;

public:

    inline LOGICAL_CHANNEL *FindByLogicalChannelNum(
        IN WORD LogicalChannelNumber
        );

    inline LOGICAL_CHANNEL *FindBySessionId(
        IN BYTE SessionId
        );

    inline void CancelAllTimers();
};


inline LOGICAL_CHANNEL *
LOGICAL_CHANNEL_ARRAY::FindByLogicalChannelNum(
    IN WORD LogicalChannelNumber
    )
{
    // check the logical channel number for each element in the array
    // search from back
    if (0 == m_NumElements) return NULL;
    for(DWORD Index = m_NumElements-1; Index < m_NumElements; Index--)
    {
        _ASSERTE(NULL != m_pData[Index]);
        if (m_pData[Index]->GetLogicalChannelNumber()
             == LogicalChannelNumber)
        {
            return m_pData[Index];
        }
    }

    // nothing found
    return NULL;
}

// SessionID is meaningful only for RTP logical channels.
// We look for only RTP logical channels.

inline LOGICAL_CHANNEL *
LOGICAL_CHANNEL_ARRAY::FindBySessionId(
    IN BYTE SessionId
    )
{
    // 0 is used by a slave terminal to request a session id from the master
    // hence, we shouldn't be searching for a match with 0
    _ASSERTE(0 != SessionId);

    // check the session for each element in the array
    // search from back
    if (0 == m_NumElements) return NULL;
    for(DWORD Index = m_NumElements-1; Index < m_NumElements; Index--)
    {
        _ASSERTE(NULL != m_pData[Index]);
        // SessionID is meaningful only for RTP logical channels.
        // We look for only RTP logical channels.
        if (IsMediaTypeRtp(m_pData[Index]->GetMediaType()) &&
            m_pData[Index]->GetSessionId() == SessionId)
        {
            return m_pData[Index];
        }
    }

    // nothing found
    return NULL;
}

inline void LOGICAL_CHANNEL_ARRAY::CancelAllTimers (void)
{
    for (DWORD Index = 0; Index < m_NumElements; Index++)
    {
        m_pData[(DWORD)Index]->TimprocCancelTimer();
    }
}

#endif // __h323ics_logchan_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\main.h ===
#ifndef	__nath323_main_h
#define	__nath323_main_h

// The init routine will read the registry and fill in these values


extern	HINSTANCE	DllInstance;		// the instance handle of this DLL
extern	HKEY		PxParametersKey;	// HKLM\CurrentControlSet\H323ICS\Parameters

	// these two elements contain the network address and mask
	// that ICS uses for the private (internal) interface
	// these values are probed once during service startup
	// using the RasLoadSharedAccessSettings function.
extern	DWORD		RasSharedScopeAddress;	// in host order
extern	DWORD		RasSharedScopeMask;		// in host order

extern	HANDLE		g_NatHandle;

extern	SYNC_COUNTER	PxSyncCounter;
extern  SYNC_COUNTER	LdapSyncCounter;

// Private Interface Address
// Defined in file 'eventmgr.cpp'
extern	IN_ADDR		g_PrivateInterfaceAddress;
extern	BOOL		g_RegAllowT120;

HRESULT EventMgrIssueAccept (
        IN  DWORD                   bindIPAddress,			// in HOST order
        IN  OVERLAPPED_PROCESSOR &  overlappedProcessor, 
        OUT WORD &                  bindPort,				// in HOST order
        OUT SOCKET &                rListenSock);

HRESULT EventMgrIssueSend(
        IN SOCKET                   sock,
        IN OVERLAPPED_PROCESSOR &   rOverlappedProcessor,
        IN BYTE                    *pBuf,
        IN DWORD                    BufLen);
    
HRESULT EventMgrIssueRecv(
        IN SOCKET                   sock,
        IN OVERLAPPED_PROCESSOR &   overlappedProcessor);

HRESULT EventMgrIssueTimeout(
        IN  DWORD               TimeoutValue,
        IN  TIMER_PROCESSOR &   TimerProcessor,
        OUT TIMER_HANDLE &      TimerHandle);

HRESULT EventMgrCancelTimeout(
        IN TIMER_HANDLE TimerHandle);

HRESULT EventMgrBindIoHandle(
        SOCKET);


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// HANDLES to the heaps used
// We use different heaps for objects of different sizes in order
// to prevent fragementation (for fixed size objects)
// HANDLES to the heaps used in evtmgr

// -XXX- this is another example of rajeevian needless complexity,
// -XXX- and wasteful overengineering.  if you're trying to find
// -XXX- memory leaks, there are better ways!  if you're trying to
// -XXX- improve performance, there are better ways than allocating
// -XXX- a heap per object type!

#if	DBG

extern	HANDLE	g_hSendRecvCtxtHeap;
extern	HANDLE	g_hAcceptCtxtHeap;
extern	HANDLE	g_hCbridgeListEntryHeap;
extern	HANDLE	g_hCallBridgeHeap;
extern	HANDLE	g_hEventMgrCtxtHeap;
extern	HANDLE	g_hDefaultEventMgrHeap;

#else

#define	g_hSendRecvCtxtHeap		GetProcessHeap()
#define	g_hAcceptCtxtHeap		GetProcessHeap()
#define	g_hCbridgeListEntryHeap	GetProcessHeap()
#define	g_hCallBridgeHeap		GetProcessHeap()
#define	g_hEventMgrCtxtHeap		GetProcessHeap()
#define	g_hDefaultEventMgrHeap	GetProcessHeap()

#endif

// If you want to use the DEBUG CRT's malloc enable the following
// instead of different heaps
#ifdef _MY_DEBUG_MEMORY // DEBUG_MEMORY

#define HeapAlloc(heap, flags, size) \
	_malloc_dbg(size, _NORMAL_BLOCK, __FILE__, __LINE__)
//malloc(size)
#define HeapFree(heap, flags, ptr) \
	_free_dbg(ptr, _NORMAL_BLOCK)
//free(ptr)

#define EM_MALLOC(size) \
	_malloc_dbg(size, _NORMAL_BLOCK, __FILE__, __LINE__)
//malloc(size)
#define EM_FREE(ptr) \
	_free_dbg(ptr, _NORMAL_BLOCK)
//free(ptr)

#else // _MY_DEBUG_MEMORY

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Inline Functions                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// By default we allocate from the g_hDefaultEventMgrHeap heap
__inline void *EM_MALLOC(size_t size)
{
    _ASSERTE(g_hDefaultEventMgrHeap);
    return (HeapAlloc(g_hDefaultEventMgrHeap,	
		      0, /* no flags */
		      (size)));
}

__inline void EM_FREE(void *ptr)
{
    _ASSERTE(g_hDefaultEventMgrHeap);
    HeapFree(g_hDefaultEventMgrHeap,	
	     0, /* no flags */
	     (ptr));
}

#endif // _MY_DEBUG_MEMORY



// Classes (Q931 src, dest and H245) inheriting
// from this create timers
// this class provides the callback method for the event manager

class TIMER_PROCESSOR
{
protected:
	TIMER_HANDLE		m_TimerHandle;			// RTL timer queue timer

public:

	TIMER_PROCESSOR			(void)
	:	m_TimerHandle		(NULL)
	{}

    // This method is implemented by Q931_INFO and LOGICAL_CHANNEL
	virtual void TimerCallback	(void) = 0;

	virtual void IncrementLifetimeCounter (void) = 0;
	virtual void DecrementLifetimeCounter (void) = 0;
		
	DWORD TimprocCreateTimer	(
		IN	DWORD	Interval);			// in milliseconds

	DWORD TimprocCancelTimer	(void);
};


#define	NATH323_TIMER_QUEUE		NULL			// use default timer queue

#endif // __nath323_main_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\ldappx.h ===
#ifndef	__h323ics_ldappx_h
#define	__h323ics_ldappx_h


// LdapProxyStart is responsible for creating the listen socket for new LDAP connections,
// for issuing the NAT redirect for LDAP connections, and for enabling the state machine
// to receive new LDAP connections.

HRESULT	LdapProxyStart	(void);

// LdapActivate performs all initializations necessary when a network interface is
// activated.

HRESULT LdapActivate    (void);

// LdapProxyStop is responsible for undoing all of the work that LdapProxyStart performed.
// It deletes the NAT redirect, deletes all LDAP connections (or, at least, it releases them
// -- they may not delete themselves yet if they have pending i/o or timer callbacks),
// and disables the creation of new LDAP connections.

void	LdapProxyStop	(void);

// LdapDeactivate performs necessary cleanup when a network interface is being
// deactivated

void	LdapDeactivate  (void);

// LdapQueryTable queries the LDAP translation table for a given alias.
// The alias was one that was previously registered by an LDAP endpoint.
// We do not care about the type of the alias (h323_ID vs emailID, etc.) --
// the semantics of the alias type are left to the Q.931 code.
//
// returns S_OK on success
// returns S_FALSE if no entry was found
// returns an error code if an actual error occurred.

HRESULT	LdapQueryTable (
	IN	ANSI_STRING *	Alias,
	OUT	IN_ADDR *		ReturnClientAddress);

#endif // __h323ics_ldappx_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\ldappx.cpp ===
#include "stdafx.h"
#include "main.h"
#include "gkwsock.h"
#include "ber.h"
#include "limits.h"

#define LDAP_PATH_SEP_CHAR      ','
#define LDAP_PATH_EQUAL_CHAR    '='

extern "C" BOOLEAN NhIsLocalAddress(ULONG Address);

typedef MessageID   LDAP_MESSAGE_ID;

#define ASN_SEQUENCE_TAG                0x30
#define ASN_LONG_HEADER_BIT             0x80
#define ASN_MIN_HEADER_LEN              2           // This value is fixed

#define LDAP_MAX_CONNECTION_BACKLOG     5
#define LDAP_STANDARD_PORT              389         // well-known LDAP port
#define LDAP_ALTERNATE_PORT             1002        // alternate (ILS) LDAP port
#define LDAP_BUFFER_RECEIVE_SIZE        0x400
#define LDAP_BUFFER_MAX_RECV_SIZE       0x80000UL   // Limit on maximum one-time receive

// data structures -------------------------------------------------------------------

class   LDAP_SOCKET;
class   LDAP_CONNECTION;

// This is how an entry in the LDAP connection mapping table
// looks like.
struct  LDAP_TRANSLATION_ENTRY
{
    ANSI_STRING     Alias;              // memory owned, use FreeAnsiString
    ANSI_STRING     DirectoryPath;      // memory owned, use FreeAnsiString
    ANSI_STRING     CN;                 // subset of DirectoryPath, NOT owned, do NOT free
    IN_ADDR         ClientAddress;
    SOCKADDR_IN     ServerAddress;

    void    FreeContents    (void) {
        FreeAnsiString (&Alias);
        FreeAnsiString (&DirectoryPath);

        CN.Buffer = NULL;
    }
};

class   LDAP_TRANSLATION_TABLE :
public  SIMPLE_CRITICAL_SECTION_BASE
{
private:
    // ordered by Alias
    DYNAMIC_ARRAY <LDAP_TRANSLATION_ENTRY>      Array;

    BOOL        IsEnabled;

private:

    HRESULT InsertEntryLocked (
        IN  ANSI_STRING *   Alias,
        IN  ANSI_STRING *   DirectoryPath,
        IN  IN_ADDR         ClientAddress,
        IN  SOCKADDR_IN *   ServerAddress);

    HRESULT FindEntryByPathServer (
        IN  ANSI_STRING *   DirectoryPath,
        IN  SOCKADDR_IN *   ServerAddress,
        OUT LDAP_TRANSLATION_ENTRY **   ReturnTranslationEntry);

public:

    LDAP_TRANSLATION_TABLE  (void);
    ~LDAP_TRANSLATION_TABLE (void);

    void    Enable    (BOOL SetEnable);

#if DBG
    HRESULT PrintTable(void);
#endif

    HRESULT QueryTableByAlias (
        IN  ANSI_STRING *   Alias,
        OUT IN_ADDR *       ReturnClientAddress);

    HRESULT QueryTableByCN (
        IN  ANSI_STRING *   CN,
        OUT IN_ADDR *       ReturnClientAddress);

    HRESULT InsertEntry (
        IN  ANSI_STRING *   Alias,
        IN  ANSI_STRING *   DirectoryPath,
        IN  IN_ADDR         ClientAddress,
        IN  SOCKADDR_IN *   ServerAddress);

    HRESULT RemoveEntry (
        IN  SOCKADDR_IN *   ServerAddress,
        IN  ANSI_STRING *   DirectoryPath);

    HRESULT RemoveEntryByAlias (
        IN  ANSI_STRING *   Alias);
};


class   LDAP_BUFFER
{
public: 
    LDAP_BUFFER     (void);
    ~LDAP_BUFFER    (void);

public:
    DYNAMIC_ARRAY <BYTE>    Data;
    LIST_ENTRY              ListEntry;
};

enum NOTIFY_REASON
{
    SOCKET_SEND_COMPLETE,
    SOCKET_RECEIVE_COMPLETE,
};

struct  LDAP_OVERLAPPED
{
    OVERLAPPED      Overlapped;
    BOOL            IsPending;
    DWORD           BytesTransferred;
    LDAP_SOCKET *   Socket;
};

class   LDAP_PUMP
{
    friend  class   LDAP_CONNECTION;
    friend  class   LDAP_SOCKET;

private:
    LDAP_CONNECTION *   Connection;
    LDAP_SOCKET *       Source;
    LDAP_SOCKET *       Dest;
    BOOL                IsPassiveDataTransfer;

public:
    LDAP_PUMP   (
        IN  LDAP_CONNECTION *   ArgConnection,
        IN  LDAP_SOCKET *       ArgSource,
        IN  LDAP_SOCKET *       ArgDest);

    ~LDAP_PUMP  (void);

    void    Start           (void);
    void    Stop            (void);

    // source is indicating that it has received data
    void    OnRecvBuffer    (LDAP_BUFFER *);

    // dest is indicating that it has finished sending data
    void    OnSendDrain     (void);

    void    SendQueueBuffer     (
        IN  LDAP_BUFFER *   Buffer);

    BOOL    CanIssueRecv    (void);

    void    Terminate       (void);

    void    EncodeSendMessage   (
        IN  LDAPMessage *   Message);

    void    StartPassiveDataTransfer (void);

    BOOL    IsActivelyPassingData (void) const;
};

class   LDAP_SOCKET
{
    friend  class   LDAP_CONNECTION;
    friend  class   LDAP_PUMP;

public:
    enum    STATE {
        STATE_NONE,
        STATE_CONNECT_PENDING,
        STATE_CONNECTED,
        STATE_TERMINATED,
    };

private:

    SOCKADDR_IN             ActualDestinationAddress;
    SOCKADDR_IN             RealSourceAddress;

    BOOL                    IsNatRedirectActive;

    LDAP_CONNECTION *       LdapConnection;
    LDAP_PUMP *             RecvPump;
    LDAP_PUMP *             SendPump;
    SOCKET                  Socket;
    STATE                   State;

    // receive state
    LDAP_OVERLAPPED         RecvOverlapped;
    LDAP_BUFFER *           RecvBuffer;             // must be valid if RecvOverlapped.IsPending, must be null otherwise
    DWORD                   RecvFlags;
    LIST_ENTRY              RecvBufferQueue;        // contains LDAP_BUFFER.ListEntry
    DWORD                   BytesToReceive;
    SAMPLE_PREDICTOR <5>    RecvSizePredictor;
    
    // send state
    LDAP_OVERLAPPED         SendOverlapped;
    LDAP_BUFFER *           SendBuffer;             // must be valid if SendOverlapped.IsPending, must be null otherwise
    LIST_ENTRY              SendBufferQueue;        // contains LDAP_BUFFER.ListEntry

    // async connect state
    HANDLE                  ConnectEvent;
    HANDLE                  ConnectWaitHandle;

private:

    inline  void    Lock            (void);
    inline  void    Unlock          (void);
    inline  void    AssertLocked    (void);

    void OnConnectCompletionLocked (void);

    void    DeleteSendQueue     (void);
    void    OnIoComplete        (DWORD Status, DWORD BytesTransferred, LDAP_OVERLAPPED *);
    void    OnRecvComplete      (DWORD Status);
    void    OnSendComplete      (DWORD Status);

    void    RecvBuildBuffer (
        IN  LPBYTE  Data,
        IN  DWORD   Length);

    void    DeleteBufferList    (
        IN  LIST_ENTRY *    ListHead);

    BOOL    RecvRemoveBuffer    (
        OUT LDAP_BUFFER **  ReturnBuffer);

    // returns TRUE if a message was dequeued
    BOOL    SendNextBuffer  (void);

public:

    LDAP_SOCKET (
        IN  LDAP_CONNECTION *   ArgLdapConnection,
        IN  LDAP_PUMP *         ArgRecvPump,
        IN  LDAP_PUMP *         ArgSendPump);

    ~LDAP_SOCKET (void);

    HRESULT RecvIssue       (void);

    // may queue the buffer
    void    SendQueueBuffer (
        LDAP_BUFFER *   Buffer);

    static void IoCompletionCallback (
        DWORD Status,
        DWORD Length,
        LPOVERLAPPED Overlapped);

    static void OnConnectCompletion (
        PVOID Context,
        BOOLEAN TimerOrWaitFired);

    HRESULT AcceptSocket (
        SOCKET LocalClientSocket);

    HRESULT IssueConnect (
        SOCKADDR_IN * DestinationAddress);

    void OnIoCompletion  (
        LDAP_BUFFER * Message, 
        DWORD Status, 
        DWORD BytesTransferred);

    void Terminate (void);

    STATE   GetState (void) {

        AssertLocked();

        return State;
    }
};


// this represents a single outstanding operation that the client has initiated.

enum    LDAP_OPERATION_TYPE
{
    LDAP_OPERATION_ADD,
    LDAP_OPERATION_SEARCH,
    LDAP_OPERATION_MODIFY,
    LDAP_OPERATION_DELETE,
};

struct  LDAP_OPERATION
{
    LDAP_MESSAGE_ID     MessageID;
    DWORD               Type;
    ANSI_STRING         DirectoryPath;          // owned by process heap
    ANSI_STRING         Alias;                  // owned by process heap
    IN_ADDR             ClientAddress;
    SOCKADDR_IN         ServerAddress;

    void    FreeContents    (void) {

        FreeAnsiString (&DirectoryPath);

        FreeAnsiString (&Alias);
    }
};


class   LDAP_CONNECTION :
public  SIMPLE_CRITICAL_SECTION_BASE,
public  LIFETIME_CONTROLLER
{
    friend    class    LDAP_SOCKET;

public:

    enum    STATE {
        STATE_NONE,
        STATE_CONNECT_PENDING,
        STATE_CONNECTED,
        STATE_TERMINATED,
    };

    LIST_ENTRY      ListEntry;

private:

    LDAP_SOCKET     ClientSocket;
    LDAP_SOCKET     ServerSocket;

    LDAP_PUMP       PumpClientToServer;
    LDAP_PUMP       PumpServerToClient;
    
    STATE           State;

    DYNAMIC_ARRAY <LDAP_OPERATION>  OperationArray;

private:

    void Close (void);

    void    StartIo     (void);

    BOOL    ProcessLdapMessage (
        IN  LDAP_PUMP *     Pump,
        IN  LDAPMessage *   LdapMessage);

    // client to server messages

    BOOL    ProcessAddRequest (
        IN  LDAPMessage *   Message);

    BOOL    ProcessModifyRequest (
        IN  LDAP_MESSAGE_ID MessageID,
        IN  ModifyRequest * Request);

    BOOL    ProcessDeleteRequest (
        IN  LDAP_MESSAGE_ID MessageID,
        IN  DelRequest *    Request);
    
    BOOL    ProcessSearchRequest (
        IN  LDAPMessage *   Message);

    // server to client messages

    void    ProcessAddResponse (
        IN  LDAPMessage *       Response);

    void    ProcessModifyResponse (
        IN  LDAP_MESSAGE_ID     MessageID,
        IN  ModifyResponse *    Response);

    void    ProcessDeleteResponse (
        IN  LDAP_MESSAGE_ID     MessageID,
        IN  DelResponse *       Response);

    BOOL    ProcessSearchResponse (
        IN  LDAPMessage *   Message);

    BOOL    FindOperationIndexByMessageID (
        IN  LDAP_MESSAGE_ID     MessageID,
        OUT DWORD *             ReturnIndex);

    BOOL    FindOperationByMessageID    (
        IN  LDAP_MESSAGE_ID     MessageID,
        OUT LDAP_OPERATION **   ReturnOperation);

    static INT BinarySearchOperationByMessageID (
        IN  const   LDAP_MESSAGE_ID *   SearchKey,
        IN  const   LDAP_OPERATION *    Comparand);

    HRESULT CreateOperation (
        IN  LDAP_OPERATION_TYPE     Type,
        IN  LDAP_MESSAGE_ID         MessageID,
        IN  ANSI_STRING *           DirectoryPath,
        IN  ANSI_STRING *           Alias,
        IN  IN_ADDR                 ClientAddress,
        IN  SOCKADDR_IN *           ServerAddress);

    // retrieve the local address of the connection to the server
    BOOL    GetExternalLocalAddress (
        OUT SOCKADDR_IN *   ReturnAddress);

public:
    LDAP_CONNECTION     (void); 
    ~LDAP_CONNECTION    (void);

    HRESULT AcceptSocket (
        IN    SOCKET        Socket,
        IN    SOCKADDR_IN * LocalAddress,
        IN    SOCKADDR_IN * RemoteAddress,
        IN    SOCKADDR_IN * ArgActualDestinationAddress);

    // process a given LDAP message buffer
    // in the context of a given pump (direction)
    void    ProcessBuffer (
        IN  LDAP_PUMP *     Pump,
        IN  LDAP_BUFFER *   Buffer);

    void    OnStateChange (
        LDAP_SOCKET * NotifyingSocket,
        LDAP_SOCKET::STATE NewState);

    void Terminate (void);

    void TerminateExternal (void);

    // safe, external version
    STATE   GetState    (void) {
        STATE   ReturnState;

        Lock();

        ReturnState = State;

        Unlock();

        return ReturnState;
    }
};

DECLARE_SEARCH_FUNC_CAST(LDAP_MESSAGE_ID, LDAP_OPERATION);

inline void LDAP_SOCKET::Lock   (void)  { LdapConnection -> Lock (); }
inline void LDAP_SOCKET::Unlock (void)  { LdapConnection -> Unlock (); }
inline void LDAP_SOCKET::AssertLocked (void) { LdapConnection -> AssertLocked(); }

class   LDAP_CONNECTION_ARRAY :
public  SIMPLE_CRITICAL_SECTION_BASE {

private:

    // Contains set/array of LDAP_CONNECTION references
    DYNAMIC_ARRAY <LDAP_CONNECTION *>    ConnectionArray;

    // Controls whether or not the structure will accept
    // new LDAP connections
    BOOL IsEnabled;

public:

    LDAP_CONNECTION_ARRAY (void);

    HRESULT InsertConnection (
        LDAP_CONNECTION * LdapConnection);

    void    RemoveConnection    (
        LDAP_CONNECTION *   LdapConnection);

    void Start (void);
    void Stop  (void);
     
};

class    LDAP_ACCEPT
{

private:

    // Contain accept context
    ASYNC_ACCEPT AsyncAcceptContext;

    // Contain address on which we listen for LDAP connections
    SOCKADDR_IN  ListenSocketAddress;

    // Handles for dynamic redirects from the standard and
    // alternate LDAP ports
    HANDLE       IoDynamicRedirectHandle1;
    HANDLE       IoDynamicRedirectHandle2;

private:

    HRESULT CreateBindSocket  (void);

    HRESULT StartNatRedirects (void);

    static void AsyncAcceptFunc (
        IN    PVOID            Context,
        IN    SOCKET           Socket,
        IN    SOCKADDR_IN *    LocalAddress,
        IN    SOCKADDR_IN *    RemoteAddress);

public:

    LDAP_ACCEPT     (void);

    HRESULT   Start   (void);

    void      Stop    (void);
};

class   LDAP_CODER :
public  SIMPLE_CRITICAL_SECTION_BASE
{
private:
    ASN1encoding_t  Encoder;
    ASN1decoding_t  Decoder;

public:
    LDAP_CODER      (void);
    ~LDAP_CODER     (void);

    DWORD   Start   (void);
    void    Stop    (void);

    ASN1error_e Decode (
        IN  LPBYTE  Data,
        IN  DWORD   Length,
        OUT LDAPMessage **  ReturnPduStructure,
        OUT DWORD * ReturnIndex);
};

struct  LDAP_PATH_ELEMENTS
{
    ANSI_STRING     CN;
    ANSI_STRING     C;
    ANSI_STRING     O;
    ANSI_STRING     ObjectClass;
};

struct  LDAP_OBJECT_NAME_ELEMENTS
{
    ANSI_STRING     CN;
    ANSI_STRING     O;
    ANSI_STRING     OU;
};

// global data -------------------------------------------------------------------------------

static  LDAP_ACCEPT                 LdapAccept;
static  LDAP_CONNECTION_ARRAY       LdapConnectionArray;
static  LDAP_TRANSLATION_TABLE      LdapTranslationTable;
static  LDAP_CODER                  LdapCoder;
SYNC_COUNTER                        LdapSyncCounter;

// utility functions ------------------------------------------------------------------------

// extern ------------------------------------------------------------------------------------

HRESULT LdapProxyStart (void)
{
    HRESULT Status;

    Status = LdapSyncCounter.Start ();
    if (Status != ERROR_SUCCESS)
        return Status;

    Status = LdapCoder.Start();
    if (Status != ERROR_SUCCESS)
        return Status; 

    LdapTranslationTable.Enable (TRUE);

    LdapConnectionArray.Start ();

    return S_OK;
}

HRESULT LdapActivate (void) 
{
    return LdapAccept.Start ();
}

// LdapProxyStop is responsible for undoing all of the work that LdapProxyStart performed.
// It deletes the NAT redirect, deletes all LDAP connections (or, at least, it releases them
// -- they may not delete themselves yet if they have pending I/O or timer callbacks),
// and disables the creation of new LDAP connections.

void LdapProxyStop (void)
{
    LdapConnectionArray.Stop ();

    LdapTranslationTable.Enable (FALSE);

    LdapCoder.Stop();

    LdapSyncCounter.Wait (INFINITE);
}

void LdapDeactivate (void) 
{
    LdapAccept.Stop ();
}
    
// LdapQueryTable queries the LDAP translation table for a given alias.
// The alias was one that was previously registered by a LDAP endpoint.
// We do not care about the type of the alias (h323_ID vs emailID, etc.) --
// the semantics of the alias type are left to the Q.931 code.
//
// returns S_OK on success
// returns S_FALSE if no entry was found
// returns an error code if an actual error occurred.

HRESULT LdapQueryTable (
    IN  ANSI_STRING *   Alias,
    OUT IN_ADDR *   ReturnClientAddress)
{
    HRESULT     Result;

    assert (Alias);
    assert (ReturnClientAddress);

    Result = LdapTranslationTable.QueryTableByAlias (Alias, ReturnClientAddress);
    if (Result == S_OK)
        return Result;

    Result = LdapTranslationTable.QueryTableByCN (Alias, ReturnClientAddress);
    if (Result == S_OK)
        return Result;

    DebugF (_T("LDAP: failed to resolve inbound alias (%.*S)\n"),
        ANSI_STRING_PRINTF (Alias));

    return Result;
}

#if DBG

void LdapPrintTable (void) {
    LdapTranslationTable.PrintTable ();
}

static BOOL BerDumpStopFn (VOID)
{
    return FALSE;
}

static void BerDumpOutputFn (char * Format, ...)
{
#if defined(DBG) && defined(ENABLE_DEBUG_OUTPUT)
    va_list Va;
    CHAR    Text    [0x200];

    va_start (Va, Format);
    _vsnprintf (Text, 0x200, Format, Va);
    va_end (Va);

    OutputDebugStringA (Text);
#endif // defined(DBG) && defined(ENABLE_DEBUG_OUTPUT)
}

static void BerDump (IN LPBYTE Data, IN DWORD Length)
{
    ber_decode (BerDumpOutputFn, BerDumpStopFn, Data,
        0, // DECODE_NEST_OCTET_STRINGS,
        0, 0, Length, 0);
}

#endif

static DWORD LdapDeterminePacketBoundary (
    IN   LDAP_BUFFER * Buffer,
    IN   DWORD         PacketOffset,   
    OUT  DWORD *       NextPacketOffset,   // Points to the beginning of next packet only if function returns ERROR_SUCCESS 
    OUT  DWORD *       NextReceiveSize)    // Is only meaningful when function returns any value other than ERROR_SUCCESS
{
    DWORD   PayloadLength;
    DWORD   ASNHeaderLength = ASN_MIN_HEADER_LEN;
    DWORD   PacketSize;
    DWORD   ByteIndex;
    DWORD   Length;
    LPBYTE  Data;

    assert (Buffer);
    assert (Buffer -> Data.Data);

    Length = Buffer -> Data.Length - PacketOffset;
    Data   = Buffer -> Data.Data;
    
    // Pick reasonable default for the size of
    // next receive request. Will be changed if necessary

    *NextReceiveSize = LDAP_BUFFER_RECEIVE_SIZE;

    if (Length != 0) {

        if (Data [PacketOffset] == ASN_SEQUENCE_TAG) {

            if (Length >= ASN_MIN_HEADER_LEN) {
            
                if (Data [PacketOffset + 1] & ASN_LONG_HEADER_BIT) {
                    // Long (more than ASN_MIN_HEADER_LEN bytes) ASN header
                    // Size of the payload length field is indicated in the
                    // second nybble of second byte

                    ASNHeaderLength += Data [PacketOffset + 1] & ~ASN_LONG_HEADER_BIT;

                    // This is where the limit on payload length is established.
                    // The test below assures it won't be greater than 2 ^ sizeof (DWORD) (4 GBytes)
                    if (ASNHeaderLength <= ASN_MIN_HEADER_LEN + sizeof (DWORD)) {

                        if (Length >= ASNHeaderLength) {

                            PayloadLength  = 0;

                            for (ByteIndex = ASN_MIN_HEADER_LEN;
                                 ByteIndex < ASNHeaderLength; 
                                 ByteIndex++) {
                                
                                 PayloadLength *= 1 << CHAR_BIT;
                                 PayloadLength += (DWORD) Data [PacketOffset + ByteIndex];  
                            }
                        }

                    } else {

                        DebugF (_T("LdapDeterminePacketBoundary: Payload size field is too big.\n"));

                        return ERROR_INVALID_DATA;
                    }

                } else  {

                    // Short (Exactly ASN_MIN_HEADER_LEN bytes) ASN header
                    // Payload length is indicated in the second byte

                    PayloadLength = (DWORD) Data [PacketOffset + 1];
                }

                PacketSize = ASNHeaderLength + PayloadLength;

                if (Length >= PacketSize) {

                    *NextPacketOffset = PacketOffset + PacketSize;

                    return ERROR_SUCCESS;

                 } else {
                    
                    *NextReceiveSize = PacketSize - Length;
                }
            }

        } else {

            Debug (_T("LdapDeterminePacketBoundary: failed to find sequence tag\n"));
            
            return ERROR_INVALID_DATA;
        }
    }

    return ERROR_MORE_DATA;
}

static BOOL FindChar (
    IN  ANSI_STRING *   String,
    IN  CHAR            Char,
    OUT USHORT *        ReturnIndex)
{
    LPSTR   Pos;
    LPSTR   End;

    assert (String);
    assert (ReturnIndex);

    Pos = String -> Buffer;
    End = String -> Buffer + String -> Length / sizeof (CHAR);

    for (; Pos < End; Pos++) {
        if (*Pos == Char) {
            *ReturnIndex = (USHORT) (Pos - String -> Buffer);
            return TRUE;
        }
    }

    return FALSE;
}

static  const   ANSI_STRING     LdapText_C  = ANSI_STRING_INIT("c");
static  const   ANSI_STRING     LdapText_CN = ANSI_STRING_INIT("cn");
static  const   ANSI_STRING     LdapText_ObjectClass = ANSI_STRING_INIT("objectClass");
static  const   ANSI_STRING     LdapText_O  = ANSI_STRING_INIT("o");
static  const   ANSI_STRING     LdapText_OU = ANSI_STRING_INIT("ou");
static  const   ANSI_STRING     LdapText_RTPerson = ANSI_STRING_INIT("RTPerson");
static  const   ANSI_STRING     LdapText_Attribute_sipaddress = ANSI_STRING_INIT("sipaddress");
static  const   ANSI_STRING     LdapText_Attribute_rfc822mailbox = ANSI_STRING_INIT("rfc822mailbox");
static  const   ANSI_STRING     LdapText_Attribute_ipAddress = ANSI_STRING_INIT("ipAddress");
static  const   ANSI_STRING     LdapText_Attribute_comment = ANSI_STRING_INIT("comment");
static  const   ANSI_STRING     LdapText_GeneratedByTAPI = ANSI_STRING_INIT("Generated by TAPI3");
static  const   ANSI_STRING     LdapText_ModifiedByICS = ANSI_STRING_INIT("Made possible by ICS");
static  const   ANSI_STRING     LdapText_DummyString = ANSI_STRING_INIT("Empty String.");

static void ParseDirectoryPathElement (
    IN      ANSI_STRING *           Element,
    IN  OUT LDAP_PATH_ELEMENTS *    PathElements)
{
    ANSI_STRING     Tag;
    ANSI_STRING     Value;
    USHORT          Index;

    if (FindChar (Element, LDAP_PATH_EQUAL_CHAR, &Index)) {
        assert (Index * sizeof (CHAR) < Element -> Length);

        Tag.Buffer = Element -> Buffer;
        Tag.Length = Index * sizeof (CHAR);

        Index++;        // step over separator

        Value.Buffer = Element -> Buffer + Index;
        Value.Length = Element -> Length - Index * sizeof (CHAR);

        DebugF (_T("\telement (%.*S)=(%.*S)\n"),
            ANSI_STRING_PRINTF (&Tag),
            ANSI_STRING_PRINTF (&Value));

        if (RtlEqualStringConst (&Tag, &LdapText_C, TRUE))
            PathElements -> C = Value;
        else if (RtlEqualStringConst (&Tag, &LdapText_CN, TRUE))
            PathElements -> CN = Value;
        else if (RtlEqualStringConst (&Tag, &LdapText_ObjectClass, TRUE))
            PathElements -> ObjectClass = Value;
        else if (RtlEqualStringConst (&Tag, &LdapText_O, TRUE))
            PathElements -> O = Value;
        else {
            DebugF (_T("LDAP: ParseDirectoryPath: unrecognized path element (%.*S)\n"),
                ANSI_STRING_PRINTF (Element));
        }
    }
    else {
        DebugF (_T("\tinvalid-element (%.*S)\n"),
            Element -> Length / sizeof (CHAR),
            Element -> Buffer);
    }
}

static void ParseDirectoryPath (
    IN  ANSI_STRING *           DirectoryPath,
    OUT LDAP_PATH_ELEMENTS *    ReturnData)
{
    ANSI_STRING     SubString;
    USHORT          Index;
    ANSI_STRING     Element;

    assert (DirectoryPath);
    assert (ReturnData);
    assert (DirectoryPath -> Buffer);

    ZeroMemory (ReturnData, sizeof (LDAP_PATH_ELEMENTS));

    SubString = *DirectoryPath;

    DebugF (_T("LDAP: ParseDirectoryPath: DirectoryPath (%.*S)\n"),
        DirectoryPath -> Length / sizeof (CHAR),
        DirectoryPath -> Buffer);

    while (FindChar (&SubString, LDAP_PATH_SEP_CHAR, &Index)) {
        assert (Index * sizeof (CHAR) < SubString.Length);

        Element.Buffer = SubString.Buffer;
        Element.Length = Index * sizeof (CHAR);

        Index++;        // step over separator

        SubString.Buffer += Index;
        SubString.Length -= Index * sizeof (CHAR);

        ParseDirectoryPathElement (&Element, ReturnData);
    }

    ParseDirectoryPathElement (&SubString, ReturnData);
}

static void ParseObjectNameElement (
    IN      ANSI_STRING *               Element,
    IN  OUT LDAP_OBJECT_NAME_ELEMENTS * ObjectNameElements)
{
    ANSI_STRING     Tag;
    ANSI_STRING     Value;
    USHORT          Index;

    if (FindChar (Element, LDAP_PATH_EQUAL_CHAR, &Index)) {
        assert (Index * sizeof (CHAR) < Element -> Length);

        Tag.Buffer = Element -> Buffer;
        Tag.Length = Index * sizeof (CHAR);

        Index++;        // step over separator

        Value.Buffer = Element -> Buffer + Index;
        Value.Length = Element -> Length - Index * sizeof (CHAR);

        DebugF (_T("\telement (%.*S)=(%.*S)\n"),
            ANSI_STRING_PRINTF (&Tag),
            ANSI_STRING_PRINTF (&Value));

        if (RtlEqualStringConst (&Tag, &LdapText_CN, TRUE))
            ObjectNameElements -> CN = Value;
        else if (RtlEqualStringConst (&Tag, &LdapText_O, TRUE))
            ObjectNameElements -> O = Value;
        else if (RtlEqualStringConst (&Tag, &LdapText_OU, TRUE))
            ObjectNameElements -> OU = Value;
        else {
            DebugF (_T("LDAP: ParseObjectNameElement: unrecognized path element (%.*S)\n"),
                ANSI_STRING_PRINTF (Element));
        }
    }
    else {
        DebugF (_T("\tinvalid-element (%.*S)\n"),
            Element -> Length / sizeof (CHAR),
            Element -> Buffer);
    }
}

static void ParseObjectName (
    IN  ANSI_STRING *               ObjectName,
    OUT LDAP_OBJECT_NAME_ELEMENTS * ReturnData)
{
    ANSI_STRING     SubString;
    USHORT          Index;
    ANSI_STRING     Element;

    assert (ObjectName);
    assert (ReturnData);
    assert (ObjectName -> Buffer);

    ZeroMemory (ReturnData, sizeof (LDAP_OBJECT_NAME_ELEMENTS));

    SubString = *ObjectName;

    DebugF (_T("LDAP: ParseObjectName: ObjectName (%.*S)\n"),
        ObjectName -> Length / sizeof (CHAR),
        ObjectName -> Buffer);

    while (FindChar (&SubString, LDAP_PATH_SEP_CHAR, &Index)) {
        assert (Index * sizeof (CHAR) < SubString.Length);

        Element.Buffer = SubString.Buffer;
        Element.Length = Index * sizeof (CHAR);

        Index++;        // step over separator

        SubString.Buffer += Index;
        SubString.Length -= Index * sizeof (CHAR);

        ParseObjectNameElement (&Element, ReturnData);
    }

    ParseObjectNameElement (&SubString, ReturnData);
}

// LDAP_TRANSLATION_TABLE ------------------------------------------------

LDAP_TRANSLATION_TABLE::LDAP_TRANSLATION_TABLE (void)
{
    IsEnabled = FALSE;
}

LDAP_TRANSLATION_TABLE::~LDAP_TRANSLATION_TABLE (void)
{
    assert (!IsEnabled);
    assert (Array.Length == 0);
}

void LDAP_TRANSLATION_TABLE::Enable (BOOL SetEnabled)
{
    Lock();

    IsEnabled = SetEnabled;

    if (!IsEnabled) {
        Array.Free();
    }

    Unlock ();
}

HRESULT LDAP_TRANSLATION_TABLE::QueryTableByAlias (
    IN  ANSI_STRING *   Alias,
    OUT IN_ADDR *       ReturnClientAddress)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    DWORD       Index;
    HRESULT     Result;
    
    assert (Alias);
    assert (ReturnClientAddress);

    Lock();

    if (IsEnabled) {

        Result = S_FALSE;

        Array.GetExtents (&Pos, &End);
        for (; Pos < End; Pos++) {
            if (RtlEqualStringConst (&Pos -> Alias, Alias, TRUE)) {
                *ReturnClientAddress = Pos -> ClientAddress;
                Result = S_OK;
                break;
            }
        }

    }
    else {
        Result = S_FALSE;
    }

    Unlock();

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::QueryTableByCN (
    IN  ANSI_STRING *   CN,
    OUT IN_ADDR *       ReturnClientAddress)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    HRESULT     Result;

    assert (CN);
    assert (ReturnClientAddress);

    Lock();

    if (IsEnabled) {

        Result = S_FALSE;

        Array.GetExtents (&Pos, &End);
        for (; Pos < End; Pos++) {
            if (RtlEqualStringConst (&Pos -> CN, CN, TRUE)) {
                *ReturnClientAddress = Pos -> ClientAddress;
                Result = S_OK;
                break;
            }
        }
    }
    else {

        Result = S_FALSE;
    }

    Unlock();

    return Result;
}

#if DBG
HRESULT LDAP_TRANSLATION_TABLE::PrintTable(void)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    HRESULT     Result;
    unsigned i;
    CHAR * Buffer = NULL;

    DebugF (_T("LDAP: Printing out LDAP translation table.\n"));
 
    Lock();

    if (IsEnabled) {

        Result = S_FALSE;

        Array.GetExtents (&Pos, &End);

        DebugF (_T("\n"));

        for (; Pos < End; Pos++) {
            DebugF (_T("\tEntry at %x\n"), Pos);

            Buffer = new CHAR [Pos->Alias.Length + 1];
            for (i=0; i < Pos->Alias.Length; i++)
                Buffer[i] = Pos->Alias.Buffer[i];
            Buffer[Pos->Alias.Length] = '\0';
            DebugF (_T("\t\tAlias - %S\n"), Buffer);
            delete [] Buffer;
            Buffer = NULL;

            Buffer = new CHAR [Pos->DirectoryPath.Length + 1];
            for (i=0; i < Pos->DirectoryPath.Length; i++)
                Buffer[i] = Pos->DirectoryPath.Buffer[i];
            Buffer[Pos->DirectoryPath.Length] = '\0';
            DebugF (_T("\t\tDirectoryPath - %S\n"), Buffer);
            delete [] Buffer;
            Buffer = NULL;

            Buffer = new CHAR [Pos->CN.Length + 1];
            for (i=0; i < Pos->CN.Length; i++)
                Buffer[i] = Pos->CN.Buffer[i];
            Buffer[Pos->CN.Length] = '\0';
            DebugF (_T("\t\tCN - %S\n"), Buffer);
            delete [] Buffer;
            Buffer = NULL;

            DebugF (_T("\t\tClientAddress - %x\n"), ntohl(Pos->ClientAddress.s_addr));
            DebugF (_T("\t\tServerAddress - %x:%x\n"),
                SOCKADDR_IN_PRINTF (&Pos -> ServerAddress));
        }

        DebugF (_T("\n"));

        Result = S_OK;
    }
    else {

        Result = S_FALSE;
    }

    Unlock();

    return Result;
}
#endif

HRESULT LDAP_TRANSLATION_TABLE::InsertEntry (
    IN  ANSI_STRING *   Alias,
    IN  ANSI_STRING *   DirectoryPath,
    IN  IN_ADDR         ClientAddress,
    IN  SOCKADDR_IN *   ServerAddress)
{
    HRESULT  Result;

    assert (Alias);
    assert (Alias -> Buffer);
    assert (DirectoryPath);
    assert (DirectoryPath -> Buffer);
    assert (ServerAddress);

    Lock();

    Result = InsertEntryLocked (Alias, DirectoryPath, ClientAddress, ServerAddress);

    Unlock();

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::FindEntryByPathServer (
    IN  ANSI_STRING *   DirectoryPath,
    IN  SOCKADDR_IN *   ServerAddress,
    OUT LDAP_TRANSLATION_ENTRY **   ReturnTranslationEntry)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    HRESULT     Result;

    Result = S_FALSE;

    Array.GetExtents (&Pos, &End);
    for (; Pos < End; Pos++) {

        if (RtlEqualStringConst (&Pos -> DirectoryPath, DirectoryPath, TRUE)
            && IsEqualSocketAddress (&Pos -> ServerAddress, ServerAddress)) {

            *ReturnTranslationEntry = Pos;
            Result = S_OK;
            break;
        }
    }

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::InsertEntryLocked (
    IN  ANSI_STRING *   Alias,
    IN  ANSI_STRING *   DirectoryPath,
    IN  IN_ADDR         ClientAddress,
    IN  SOCKADDR_IN *   ServerAddress)
{
    LDAP_TRANSLATION_ENTRY *    TranslationEntry;
    LDAP_PATH_ELEMENTS  PathElements;
    HRESULT         Result;
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;

    assert (Alias);
    assert (DirectoryPath);
    assert (ServerAddress);

    if (!IsEnabled)
        return S_FALSE;

    // locate any existing entry
    // the identity of the entry is determined by the tuple:
    //      < ServerAddress DirectoryPath >

    if (FindEntryByPathServer (DirectoryPath, ServerAddress, &TranslationEntry) == S_OK) {
        Debug (_T("LDAP: replacing existing translation entry\n"));

        TranslationEntry -> FreeContents();
    }
    else {
        Debug (_T("LDAP: allocating new translation entry\n"));

        TranslationEntry = Array.AllocAtEnd();
        if (!TranslationEntry) {
            Debug (_T("LDAP: failed to allocate translation entry\n"));
            return E_OUTOFMEMORY;
        }
    }

    TranslationEntry -> ClientAddress = ClientAddress;
    TranslationEntry -> ServerAddress = *ServerAddress;

    // copy the strings
    CopyAnsiString (Alias, &TranslationEntry -> Alias);
    CopyAnsiString (DirectoryPath, &TranslationEntry -> DirectoryPath);

    if (TranslationEntry -> DirectoryPath.Buffer) {
        ParseDirectoryPath (&TranslationEntry -> DirectoryPath, &PathElements);
        if (PathElements.CN.Buffer) {
            TranslationEntry -> CN = PathElements.CN;
        }
        else {
            Debug (_T("LDAP: cannot insert translation entry -- CN is not specified\n"));
            TranslationEntry -> CN.Buffer = NULL;
        }
    }
    else {
        TranslationEntry -> CN.Buffer = NULL;
    }


    // test and make sure all allocation code paths succeeded
    if (TranslationEntry -> Alias.Buffer
        && TranslationEntry -> DirectoryPath.Buffer
        && TranslationEntry -> CN.Buffer) {

        Result = S_OK;

    } else {
        Debug (_T("LDAP_TRANSLATION_TABLE::InsertEntryLocked: failed to allocate memory (or failed to find cn)\n"));

        FreeAnsiString (&TranslationEntry -> Alias);
        FreeAnsiString (&TranslationEntry -> DirectoryPath);

        Array.DeleteEntry (TranslationEntry);

        Result = E_OUTOFMEMORY;
    }

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::RemoveEntry (
    IN  SOCKADDR_IN *   ServerAddress,
    IN  ANSI_STRING *   DirectoryPath)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    HRESULT     Result;
    
    Lock();

    assert (ServerAddress);
    assert (DirectoryPath);

    Result = S_FALSE;

    Array.GetExtents (&Pos, &End);
    for (; Pos < End; Pos++) {

        if (RtlEqualString (DirectoryPath, &Pos -> DirectoryPath, TRUE)
            && Compare_SOCKADDR_IN (ServerAddress, &Pos -> ServerAddress) == 0) {

            Pos -> FreeContents();

            Array.DeleteEntry (Pos);

            Result = S_OK;

            break;
        }
    }

    Unlock();

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::RemoveEntryByAlias (
    IN  ANSI_STRING *   Alias)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    HRESULT     Result;
    
    Lock();

    assert (Alias);

    Result = S_FALSE;

    Array.GetExtents (&Pos, &End);
    for (; Pos < End; Pos++) {

        if (RtlEqualString (Alias, &Pos -> Alias, TRUE)) {

            Pos -> FreeContents();

            Array.DeleteEntry (Pos);

            Result = S_OK;

            break;
        }
    }

    Unlock();

    return Result;
}

// LDAP_SOCKET ----------------------------------------------

LDAP_SOCKET::LDAP_SOCKET (
    IN  LDAP_CONNECTION *   ArgLdapConnection,
    IN  LDAP_PUMP *         ArgRecvPump,
    IN  LDAP_PUMP *         ArgSendPump)
{
    assert (ArgLdapConnection);
    assert (ArgRecvPump);
    assert (ArgSendPump);

    LdapConnection = ArgLdapConnection;
    RecvPump = ArgRecvPump;
    SendPump = ArgSendPump;

    State = STATE_NONE;
    BytesToReceive = LDAP_BUFFER_RECEIVE_SIZE;
    Socket = INVALID_SOCKET;

    ZeroMemory (&RecvOverlapped, sizeof RecvOverlapped);
    RecvOverlapped.Socket = this;
    RecvBuffer = NULL;
    InitializeListHead (&RecvBufferQueue);

    ZeroMemory (&SendOverlapped, sizeof SendOverlapped);
    SendOverlapped.Socket = this;
    SendBuffer = NULL;
    InitializeListHead (&SendBufferQueue);

    ConnectEvent = NULL;
    ConnectWaitHandle = NULL;

    IsNatRedirectActive = FALSE;
}

LDAP_SOCKET::~LDAP_SOCKET (void)
{
    DeleteBufferList (&RecvBufferQueue);
    DeleteBufferList (&SendBufferQueue);

    if (RecvBuffer) {

        delete RecvBuffer;

        RecvBuffer = NULL;
    }

    assert (IsListEmpty (&RecvBufferQueue));
    assert (IsListEmpty (&SendBufferQueue));
    assert (!SendBuffer);
    assert (!ConnectEvent);
    assert (!ConnectWaitHandle);
}

void LDAP_SOCKET::DeleteBufferList (LIST_ENTRY * ListHead)
{
    LIST_ENTRY *    ListEntry;
    LDAP_BUFFER *   Buffer;

    while (!IsListEmpty (ListHead)) {
        ListEntry = RemoveHeadList (ListHead);
        Buffer = CONTAINING_RECORD (ListEntry, LDAP_BUFFER, ListEntry);
        delete Buffer;
    }
}

BOOL LDAP_SOCKET::RecvRemoveBuffer (
    OUT LDAP_BUFFER **  ReturnBuffer)
{
    LIST_ENTRY *    ListEntry;

    assert (ReturnBuffer);

    if (IsListEmpty (&RecvBufferQueue))
        return FALSE;
    else {
        ListEntry = RemoveHeadList (&RecvBufferQueue);
        *ReturnBuffer = CONTAINING_RECORD (ListEntry, LDAP_BUFFER, ListEntry);
        return TRUE;
    }
}

void LDAP_SOCKET::RecvBuildBuffer (
    IN  LPBYTE  Data,
    IN  DWORD   Length)
{
    LDAP_BUFFER *   Buffer;

    assert (Data);
    AssertLocked();

    Buffer = new LDAP_BUFFER;

    if (!Buffer) {
        Debug (_T("LDAP_SOCKET::RecvBuildBuffer: allocation failure\n"));
        return;
    }

    if (Buffer -> Data.Grow (Length)) {
        memcpy (Buffer -> Data.Data, Data, Length);
        Buffer -> Data.Length = Length;

        InsertTailList (&RecvBufferQueue, &Buffer -> ListEntry);
    }
    else {
        Debug (_T("LDAP_SOCKET::RecvBuildBuffer: allocation failure\n"));

        delete Buffer;
    }
}

HRESULT LDAP_SOCKET::AcceptSocket (
    SOCKET LocalClientSocket)
{
    if (State != STATE_NONE) {

        Debug (_T("LDAP_SOCKET::AcceptSocket: not in a valid state for AcceptSocket (State != STATE_NONE)\n"));
        return E_UNEXPECTED;
    }

    State  = STATE_CONNECTED;
    Socket = LocalClientSocket;

    // notify parent about state change
    LdapConnection -> OnStateChange (this, State);
    
    if (!BindIoCompletionCallback ((HANDLE) Socket, LDAP_SOCKET::IoCompletionCallback, 0)) {

        DebugLastError (_T("LDAP_SOCKET::AcceptSocket: failed to bind I/O completion callback\n"));

        return GetLastErrorAsResult ();
    }
        
    return S_OK;
}

HRESULT LDAP_SOCKET::IssueConnect (
    SOCKADDR_IN * DestinationAddress)
{

    HRESULT Status;
    HRESULT Result         = E_FAIL;
    INT RealSourceAddrSize = sizeof (SOCKADDR_IN);
    SOCKET UDP_Socket      = INVALID_SOCKET;

    assert (DestinationAddress);

    if (State != STATE_NONE) {

        Debug (_T("LDAP_SOCKET::IssueConnect: not in a valid state for IssueConnect (State != STATE_NONE)\n"));
        
        return E_UNEXPECTED;
    }

    assert (Socket == INVALID_SOCKET);
    assert (!ConnectEvent);
    assert (!ConnectWaitHandle);

    ActualDestinationAddress = *DestinationAddress;

    UDP_Socket = socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP);

    if (UDP_Socket == INVALID_SOCKET){
         
        Result = GetLastErrorAsResult ();

        DebugLastError (_T("LDAP_SOCKET::IssueConnect: failed to create UDP socket.\n"));

    } else {
        if (SOCKET_ERROR == connect (UDP_Socket, (PSOCKADDR)DestinationAddress, sizeof (SOCKADDR_IN))) {
    
            Result = GetLastErrorAsResult ();

            DebugLastError (_T("LDAP_SOCKET::IssueConnect: failed to connect UDP socket.\n"));

        } else {

            RealSourceAddrSize = sizeof (SOCKADDR_IN);

            if (getsockname (UDP_Socket, (struct sockaddr *)&RealSourceAddress, &RealSourceAddrSize)) {

                Result = GetLastErrorAsResult ();

                DebugLastError (_T("LDAP_SOCKET::IssueConnect: failed to get name of UDP socket.\n"));

            } else {

                RealSourceAddress.sin_port = htons (0); 

                Socket = WSASocket (AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);

                if (Socket == INVALID_SOCKET) {

                    Result = GetLastErrorAsResult ();

                    DebugLastError (_T("LDAP_SOCKET::IssueConnect: failed to create dest socket.\n"));

                } else {
                
                    if (SOCKET_ERROR == bind(Socket, (PSOCKADDR)&RealSourceAddress, RealSourceAddrSize)) {

                        Result = GetLastErrorAsResult();

                        DebugLastError (_T("LDAP_SOCKET::IssueConnect: failed to bind dest socket.\n"));

                    } else {

                        if (getsockname (Socket, (struct sockaddr *)&RealSourceAddress, &RealSourceAddrSize)) {

                            Result = GetLastErrorAsResult ();

                            DebugLastError (_T("LDAP_SOCKET::IssueConnect: failed to get name of TCP socket.\n"));

                        } else {

                            DWORD RetCode;

                            if( NO_ERROR != NatCreateRedirect ( 
                                    g_NatHandle, 
                                    0, 
                                    IPPROTO_TCP, 
                                    DestinationAddress -> sin_addr.s_addr,
                                    DestinationAddress -> sin_port,
                                    RealSourceAddress.sin_addr.s_addr, 
                                    RealSourceAddress.sin_port,
                                    DestinationAddress -> sin_addr.s_addr,
                                    DestinationAddress -> sin_port,
                                    RealSourceAddress.sin_addr.s_addr, 
                                    RealSourceAddress.sin_port, 
                                    NULL, 
                                    NULL, 
                                    NULL)) {    
                                
                                Result = GetLastErrorAsResult();

                                DebugLastError (_T("LDAP_SOCKET::IssueConnect: failed to create trivial NAT redirect.\n"));
                        
                            } else {

                                // we have successfully created a redirect
                                IsNatRedirectActive = TRUE;

                                do
                                {
                                    ConnectEvent = CreateEvent (NULL, FALSE, FALSE, NULL); 

                                    if (!ConnectEvent) { 

                                        Result = GetLastErrorAsResult();

                                        DebugLastError (_T("LDAP_SOCKET::IssueConnect: failed to create event.\n"));
                                        break;
                                    }

                                    Status = WSAEventSelect (Socket, ConnectEvent, FD_CONNECT);

                                    if (Status) {
                                        Result = GetLastErrorAsResult();

                                        DebugLastError (_T("LDAP_SOCKET::IssueConnect: failed to select events on the socket.\n"));
                                        break;
                                    }

                                    LdapConnection -> AddRef ();
        
                                    if (!RegisterWaitForSingleObject (
                                            &ConnectWaitHandle, 
                                            ConnectEvent, 
                                            LDAP_SOCKET::OnConnectCompletion,
                                            this,
                                            INFINITE,
                                            WT_EXECUTEDEFAULT)) {

                                        Result = GetLastErrorAsResult();

                                        DebugLastError (_T("LDAP_SOCKET::IssueConnect: failed to RegisterWaitForSingleObject.\n"));
                                        
                                        LdapConnection -> Release ();

                                        break;
                                    } 
                                    
                                    if (connect (Socket, (SOCKADDR *)DestinationAddress, sizeof (SOCKADDR_IN))) {
                                        if(WSAGetLastError() == WSAEWOULDBLOCK) {
                                                // the normal case -- i/o is now pending
                                                //          //__DebugF (_T("LDAP: connection to %08X:%04X in progress\n"),
                                                //              SOCKADDR_IN_PRINTF (DestinationAddress));

                                                State = STATE_CONNECT_PENDING;

                                                LdapConnection->OnStateChange (this, State);

                                                Result = S_OK;

                                        } else {

                                            // a real error
                                    
                                                Result = GetLastErrorAsResult();
                                                    
                                                DebugLastError (_T("LDAP_SOCKET::IssueConnect: failed to issue async connect\n"));
         
                                                LdapConnection -> Release ();
                                        }

                                        break;

                                    } else {
                                        // connect completed synchronously
                                        // this should never occur

                                        Debug (_T("LDAP: connection completed synchronously -- this should never occur\n"));
                                       
                                        LdapConnection -> Release ();

                                        Result = E_UNEXPECTED;

                                    }
                               } while(FALSE);
                           }
                        }
                    }
                }
            }
        }
        
        closesocket (UDP_Socket);
        UDP_Socket = INVALID_SOCKET;
    }
            
    return Result;
}

// static
void LDAP_SOCKET::IoCompletionCallback (
    DWORD           Status, 
    DWORD           BytesTransferred, 
    LPOVERLAPPED    Overlapped)
{
    LDAP_OVERLAPPED *   LdapOverlapped;
    LDAP_CONNECTION *   Connection;

    LdapOverlapped = CONTAINING_RECORD (Overlapped, LDAP_OVERLAPPED, Overlapped);

    assert (LdapOverlapped -> Socket);

    Connection = LdapOverlapped -> Socket -> LdapConnection;

    LdapOverlapped -> Socket -> OnIoComplete (Status, BytesTransferred, LdapOverlapped);

    Connection -> Release();
}

void LDAP_SOCKET::OnIoComplete (
    DWORD               Status, 
    DWORD               BytesTransferred, 
    LDAP_OVERLAPPED *   Overlapped)
{
    Lock();

    assert (Overlapped -> IsPending);

    Overlapped -> IsPending = FALSE;
    Overlapped -> BytesTransferred = BytesTransferred;

    if (Overlapped == &RecvOverlapped)
        OnRecvComplete (Status);
    else if (Overlapped == &SendOverlapped)
        OnSendComplete (Status);
    else {
        AssertNeverReached();
    }

    Unlock();
}

// static
void LDAP_SOCKET::OnConnectCompletion (
    PVOID       Context,
    BOOLEAN     TimerOrWaitFired)
{
    LDAP_SOCKET *   LdapSocket;

    assert (Context);

    LdapSocket = (LDAP_SOCKET *) Context;

    LdapSocket -> Lock ();
    LdapSocket -> OnConnectCompletionLocked ();
    LdapSocket -> Unlock ();

    LdapSocket -> LdapConnection -> Release ();
}

void LDAP_SOCKET::OnRecvComplete (DWORD Status)
{
    DWORD StartOffset;
    DWORD NextPacketOffset;
    DWORD NextReceiveSize = 0;
    DWORD Result;

    LIST_ENTRY *    ListEntry;
    LDAP_BUFFER *   Buffer;


    if (Status != ERROR_SUCCESS) {

        if (State != STATE_TERMINATED) {

            Terminate();
        }

        return;
    }

    if (RecvOverlapped.BytesTransferred == 0) {

#if DBG
        if (this == &LdapConnection -> ClientSocket)
        {
            Debug (_T("LDAP: client has closed transport socket\n"));
        }
        else if (this == &LdapConnection -> ServerSocket)
        {
            Debug (_T("LDAP: server has closed transport socket\n"));
        }
        else
            AssertNeverReached();
#endif

        Terminate();

        return;
    }

    assert (RecvBuffer);

    assert (RecvBuffer -> Data.Length + RecvOverlapped.BytesTransferred
        <= RecvBuffer -> Data.MaxLength);

    RecvBuffer -> Data.Length += RecvOverlapped.BytesTransferred;

#if 0
    DebugF (_T("LDAP: received %d bytes, total accumulated message %d bytes\n"),
        RecvOverlapped.BytesTransferred,
        RecvBuffer -> Data.Length);
#endif

    if (State == STATE_TERMINATED) {

        Debug (_T("LDAP_SOCKET::OnRecvComplete: object is terminating, no further processing will occur\n"));
        return;
    }

    if (RecvPump -> IsActivelyPassingData ()) {

        StartOffset = 0;

        for (;;) {

            assert (StartOffset <= RecvBuffer -> Data.Length);

            Result = LdapDeterminePacketBoundary (
                            RecvBuffer,
                            StartOffset, 
                            &NextPacketOffset,
                            &NextReceiveSize);

            if (Result == ERROR_SUCCESS) {

                RecvBuildBuffer (&RecvBuffer -> Data.Data [StartOffset], NextPacketOffset - StartOffset);

                StartOffset = NextPacketOffset;

            } else {

                RecvBuffer -> Data.DeleteRangeAtPos (0, StartOffset);

                if (Result == ERROR_INVALID_DATA) {

                    RecvPump -> StartPassiveDataTransfer ();

                    DebugF (_T("LDAP_SOCKET::OnRecvComplete -- Starting non-interpreting data transfer.\n"));

                    InsertTailList (&RecvBufferQueue, &RecvBuffer -> ListEntry);

                    RecvBuffer = NULL;

                } 

                BytesToReceive = NextReceiveSize;

                break;

            } 

        }

    } else {
        LONG    PreviousRecvSize;
        LONG    PredictedRecvSize;
        HRESULT QueryResult;
        DWORD   BytesPreviouslyRequested = BytesToReceive;
        
        QueryResult = RecvSizePredictor.RetrieveOldSample (0, &PreviousRecvSize);

        if (ERROR_SUCCESS != RecvSizePredictor.AddSample ((LONG) RecvOverlapped.BytesTransferred)) {

            delete RecvBuffer;
            RecvBuffer = NULL;

            DebugError (Status, _T("LDAP_SOCKET::OnRecvComplete: error occurred, terminating socket\n"));

            Terminate();

            return;
        }

        if (BytesPreviouslyRequested == RecvOverlapped.BytesTransferred) {
            // Exact receive

            if (ERROR_SUCCESS != QueryResult) {

                BytesToReceive = (DWORD) (RecvOverlapped.BytesTransferred * 1.5);

            } else {

                PredictedRecvSize = RecvSizePredictor.PredictNextSample ();

                if (PredictedRecvSize < (LONG) RecvOverlapped.BytesTransferred) {

                    if ((DWORD) PreviousRecvSize < RecvOverlapped.BytesTransferred) {

                        BytesToReceive =  RecvOverlapped.BytesTransferred * 1000 / (DWORD) PreviousRecvSize * 
                                          RecvOverlapped.BytesTransferred        / 1000;

                    } else {

                        BytesToReceive = (DWORD) PreviousRecvSize;
                    }

                } else {
                    
                    BytesToReceive = (DWORD) PredictedRecvSize;
                }

            }

        } else {
            // Inexact receive
        
            PredictedRecvSize = RecvSizePredictor.PredictNextSample ();

            BytesToReceive = (PredictedRecvSize < LDAP_BUFFER_RECEIVE_SIZE) ? 
                              LDAP_BUFFER_RECEIVE_SIZE :
                             (DWORD) PredictedRecvSize;

        }

        if (BytesToReceive > LDAP_BUFFER_MAX_RECV_SIZE)  {

            DebugF (_T("LDAP_SOCKET::OnRecvComplete -- intended to receive %d bytes. Lowering the number to %d bytes.\n"),
                    BytesToReceive, LDAP_BUFFER_MAX_RECV_SIZE);

            BytesToReceive = LDAP_BUFFER_MAX_RECV_SIZE;
        }

        InsertTailList (&RecvBufferQueue, &RecvBuffer -> ListEntry);
            
        RecvBuffer = NULL;
    }


    while (!IsListEmpty (&RecvBufferQueue)) {

        ListEntry = RemoveHeadList (&RecvBufferQueue);

        Buffer = CONTAINING_RECORD (ListEntry, LDAP_BUFFER, ListEntry);

        RecvPump -> OnRecvBuffer (Buffer);
    }

    RecvIssue ();
}

void LDAP_SOCKET::OnSendComplete (DWORD Status)
{
    assert (SendBuffer);

//  DebugF (_T("LDAP: completed sending message, length %d\n"), SendOverlapped.BytesTransferred);

    delete SendBuffer;
    SendBuffer = NULL;

    // before notifying the owning context, transmit any buffers
    // that are queued for send.

    if (SendNextBuffer())
        return;

    SendPump -> OnSendDrain();
}

void LDAP_SOCKET::OnConnectCompletionLocked (void) {

    WSANETWORKEVENTS NetworkEvents;
    BOOL SuccessSoFar = TRUE;

    AssertLocked();

    if (State != STATE_CONNECT_PENDING) {
        Debug (_T("LDAP: connect request completed, but socket is no longer interested\n"));
        return;
    }

    if (WSAEnumNetworkEvents (Socket, ConnectEvent, &NetworkEvents)) {

        DebugLastError (_T("LDAP: failed to retrieve network events.\n"));

        Terminate();

        return;
    }

    if (!(NetworkEvents.lNetworkEvents & FD_CONNECT)) {

        Debug (_T("LDAP: connect event fired, but event mask does not indicate that connect completed -- internal error\n"));
        
        Terminate();

        return;
    }

    if (NetworkEvents.iErrorCode [FD_CONNECT_BIT]) {
     
        DebugError (NetworkEvents.iErrorCode [FD_CONNECT_BIT],
            _T("LDAP: async connect request failed."));

        Terminate();

        return;
    }

    assert (ConnectWaitHandle);
    UnregisterWaitEx (ConnectWaitHandle, NULL);
    ConnectWaitHandle = NULL;

    assert (ConnectEvent);

    // refrain from receiving notifications of further transport events
    WSAEventSelect (Socket, ConnectEvent, 0);

    CloseHandle(ConnectEvent);
    ConnectEvent = NULL;

    DebugF (_T("LDAP: connection to server established\n"));

    if (!BindIoCompletionCallback ((HANDLE)Socket, LDAP_SOCKET::IoCompletionCallback, 0)) {
        DebugLastError (_T("LDAP: failed to bind i/o completion callback\n"));

        Terminate();

        return;
    }
    
    // Async connect succeeded
    State = STATE_CONNECTED;

    LdapConnection -> OnStateChange (this, State);
}


void LDAP_SOCKET::Terminate (void)
{
    switch (State) {

    case    STATE_TERMINATED:
        // nothing to do
        return;

    case    STATE_NONE:
        // a different kind of nothing to do
        break;

    default:
        // in all other states, the socket handle must be set
        assert (Socket != INVALID_SOCKET);

        State = STATE_TERMINATED;

        closesocket (Socket);
        Socket = INVALID_SOCKET;

        if (ConnectEvent) {
            CloseHandle (ConnectEvent);
            ConnectEvent = NULL;
        }

        if (IsNatRedirectActive) {
            NatCancelRedirect ( 
                g_NatHandle, 
                IPPROTO_TCP, 
                ActualDestinationAddress.sin_addr.s_addr,
                ActualDestinationAddress.sin_port,
                RealSourceAddress.sin_addr.s_addr, 
                RealSourceAddress.sin_port,
                ActualDestinationAddress.sin_addr.s_addr,
                ActualDestinationAddress.sin_port,
                RealSourceAddress.sin_addr.s_addr, 
                RealSourceAddress.sin_port);

            IsNatRedirectActive = FALSE;
        }

        if (ConnectWaitHandle) {

            if (UnregisterWaitEx (ConnectWaitHandle, NULL)) {

                LdapConnection -> Release ();
                
            } else {

                DebugF (_T("LDAP_SOCKET::Terminate -- UnregisterWaitEx failed for %x\n"), this);
            }

            ConnectWaitHandle = NULL;
        }

        SendPump -> Terminate ();
        RecvPump -> Terminate ();

        break;
    }
    

    LdapConnection -> OnStateChange (this, State);
}

HRESULT LDAP_SOCKET::RecvIssue (void)
{
    WSABUF  BufferArray [1];
    DWORD   Status;
    DWORD   BytesRequested;

    if (RecvOverlapped.IsPending) {
        Debug (_T("LDAP_SOCKET::RecvIssue: a recv is already pending\n"));
        return S_OK;
    }

    if (!RecvPump -> CanIssueRecv()) {
        // we gate the rate at which we receive data from the network on the
        // rate at which the other network connection consumes it.
        // this is how we preserve flow control.

//      Debug (_T("LDAP_SOCKET::RecvIssue: pump does not want more data -- not requesting more data\n"));
        return S_OK;
    }

    if (!RecvBuffer) {

        RecvBuffer = new LDAP_BUFFER;

        if (!RecvBuffer) {

            Debug (_T("LDAP_SOCKET::RecvIssue: RecvBuffer allocation failure\n"));

            Terminate();

            return E_OUTOFMEMORY;
        }
    }

    BytesRequested = RecvBuffer -> Data.Length + BytesToReceive;

    if (!RecvBuffer -> Data.Grow (BytesRequested)) {

        DebugF (_T("LDAP: failed to expand recv buffer to %d bytes\n"), BytesRequested);

        Terminate();

        return E_OUTOFMEMORY;
    }

    BufferArray [0].len = BytesToReceive;
    BufferArray [0].buf = reinterpret_cast <char *>(RecvBuffer -> Data.Data) + RecvBuffer -> Data.Length;


    ZeroMemory (&RecvOverlapped.Overlapped, sizeof (OVERLAPPED));

    RecvFlags = 0;

    LdapConnection -> AddRef ();

    if (WSARecv (Socket, BufferArray, 1,
        &RecvOverlapped.BytesTransferred, &RecvFlags,
        &RecvOverlapped.Overlapped, NULL)) {

        Status = WSAGetLastError();

        if (Status != WSA_IO_PENDING) {
            // a true error, probably a transport failure
            
            LdapConnection -> Release ();

            DebugError (Status, _T("LDAP: failed to issue recv -- transport has failed.\n"));
            return HRESULT_FROM_WIN32 (Status);
        }
    }

    RecvOverlapped.IsPending = TRUE;

    return S_OK;
}

void LDAP_SOCKET::SendQueueBuffer (
    IN  LDAP_BUFFER *   Buffer)
{
    AssertLocked();

    assert (!IsInList (&SendBufferQueue, &Buffer -> ListEntry));
    InsertTailList (&SendBufferQueue, &Buffer -> ListEntry);

    SendNextBuffer();
}

BOOL LDAP_SOCKET::SendNextBuffer (void)
{
    WSABUF          BufferArray [1];
    LIST_ENTRY *    ListEntry;
    DWORD           Status;

    if (SendOverlapped.IsPending) {
        assert (SendBuffer);

//      Debug (_T("LDAP_SOCKET::SendNextMessage: already sending a message, must wait\n"));
        return FALSE;
    }

    assert (!SendBuffer);

    // remove the next buffer to be sent from the queue

    if (IsListEmpty (&SendBufferQueue))
        return FALSE;

    ListEntry = RemoveHeadList (&SendBufferQueue);
    SendBuffer = CONTAINING_RECORD (ListEntry, LDAP_BUFFER, ListEntry);

    BufferArray [0].buf = reinterpret_cast<char *> (SendBuffer -> Data.Data);
    BufferArray [0].len = SendBuffer -> Data.Length;

    ZeroMemory (&SendOverlapped.Overlapped, sizeof (OVERLAPPED));

    LdapConnection -> AddRef ();

    if (WSASend (Socket, BufferArray, 1,
        &SendOverlapped.BytesTransferred, 0,
        &SendOverlapped.Overlapped, NULL)) {

        Status = WSAGetLastError();

        if (Status != WSA_IO_PENDING) {

            LdapConnection -> Release ();

            DebugError (Status, _T("LDAP: failed to issue send -- transport has failed\n"));

            delete SendBuffer;
            SendBuffer = NULL;

            Terminate();

            // we return TRUE, because we did dequeue a buffer,
            // even if that buffer could not be transmitted.
            return TRUE;
        }
    }

//  DebugF (_T("LDAP: sending buffer, %d bytes\n"), SendBuffer -> Data.Length);

    SendOverlapped.IsPending = TRUE;

    return TRUE;
}

// LDAP_CONNECTION ---------------------------------------------------

LDAP_CONNECTION::LDAP_CONNECTION (void) 
: LIFETIME_CONTROLLER (&LdapSyncCounter) ,
    ClientSocket (this, &PumpClientToServer, &PumpServerToClient),
    ServerSocket   (this, &PumpServerToClient, &PumpClientToServer),

    PumpClientToServer  (this, &ClientSocket, &ServerSocket),
    PumpServerToClient  (this, &ServerSocket, &ClientSocket)
{
    DebugF (_T("LDAP_CONNECTION::Create -- %x\n"), this);

    State = STATE_NONE;
}

LDAP_CONNECTION::~LDAP_CONNECTION (void)
{   
    DebugF (_T("LDAP_CONNECTION::Destroy -- %x\n"), this);
}

void LDAP_CONNECTION::StartIo (void)
{
    PumpClientToServer.Start();
    PumpServerToClient.Start();
}

BOOL LDAP_CONNECTION::GetExternalLocalAddress (
    OUT SOCKADDR_IN *   ReturnAddress)
{
    INT         AddressLength;

    AssertLocked();

    if (ServerSocket.State == LDAP_SOCKET::STATE_CONNECTED) {
        AddressLength = sizeof (SOCKADDR_IN);

        if (getsockname (ServerSocket.Socket, (SOCKADDR *) ReturnAddress, &AddressLength)) {
            DebugLastError (_T("LDAP: failed to retrieve socket address\n"));
            return FALSE;
        }

        return TRUE;
    }
    else {
        return FALSE;
    }
}

HRESULT LDAP_CONNECTION::AcceptSocket (
    IN    SOCKET           Socket,
    IN    SOCKADDR_IN *    LocalAddress,
    IN    SOCKADDR_IN *    RemoteAddress,
    IN    SOCKADDR_IN *    ArgActualDestinationAddress)
{
    HRESULT     Result;

    Lock();

    if (State == STATE_NONE) {

        Result = ClientSocket.AcceptSocket (Socket);

        if (Result == S_OK) {

            Result = ServerSocket.IssueConnect (ArgActualDestinationAddress);

            if (Result != S_OK) {

                DebugErrorF (Result, _T("LDAP: failed to issue async connect to dest %08X:%04X.\n"),
                    SOCKADDR_IN_PRINTF (RemoteAddress));

                Terminate ();
            }
        }
        else {

            DebugError (Result, _T("LDAP_CONNECTION::AcceptSocket: could not successfully complete accept\n"));

            Terminate ();
        }           
    }
    else {

        Debug (_T("LDAP_CONNECTION::AcceptSocket: not in a valid state for accept (state != STATE_NONE)\n"));

        Result = E_UNEXPECTED;
    }

    Unlock();
        
    return Result;
}
    
HRESULT LDAP_CONNECTION::CreateOperation (
    IN  LDAP_OPERATION_TYPE     Type,
    IN  LDAP_MESSAGE_ID         MessageID,
    IN  ANSI_STRING *           DirectoryPath,
    IN  ANSI_STRING *           Alias,
    IN  IN_ADDR                 ClientAddress,
    IN  SOCKADDR_IN *           ServerAddress)
{
    LDAP_OPERATION *    Operation;
    DWORD               Index;
    HRESULT             Result;

    if (FindOperationIndexByMessageID (MessageID, &Index)) {
        DebugF (_T("LDAP_CONNECTION::CreateOperation: an operation with message ID (%u) is already pending\n"),
            MessageID);
        return E_FAIL;
    }

    Operation = OperationArray.AllocAtPos (Index);
    if (!Operation) {
        Debug (_T("LDAP_CONNECTION::CreateOperation: allocation failure #1\n"));
        return E_OUTOFMEMORY;
    }

    Operation -> Type = Type;
    Operation -> MessageID = MessageID;
    Operation -> ClientAddress = ClientAddress;
    Operation -> ServerAddress = *ServerAddress;

    CopyAnsiString (DirectoryPath, &Operation -> DirectoryPath);
    CopyAnsiString (Alias, &Operation -> Alias);

    if ((Operation -> DirectoryPath.Buffer
        && Operation -> Alias.Buffer)) {
        // all is well

        Result = S_OK;
    }
    else {
        Debug (_T("LDAP_CONNECTION::CreateOperation: allocation failure #2\n"));

        FreeAnsiString (&Operation -> DirectoryPath);
        FreeAnsiString (&Operation -> Alias);

        Result = E_OUTOFMEMORY;
    }

    return Result;
}


// ------------------------------------

BOOL LDAP_CONNECTION::ProcessAddRequest (
    IN  LDAPMessage *   Message)
{
    AddRequest *        Request;
    ANSI_STRING         DirectoryPath;
    LDAP_PATH_ELEMENTS  PathElements;
    ANSI_STRING         AttributeTag;
    IN_ADDR             OldClientAddress;       // the address the client submitted in AddRequest
    IN_ADDR             NewClientAddress;       // the address we are replacing it with
    LDAP_OPERATION *    Operation;
    DWORD               OperationInsertionIndex;
    ASN1octetstring_t   IPAddressOldValue;
    SOCKADDR_IN         ExternalAddress;
    SOCKADDR_IN         ServerAddress;
    INT                 AddressLength;
    BOOL                NeedObjectClass;
    ANSI_STRING         ClientAlias;

    AddRequest_attrs *              Iter;
    AddRequest_attrs_Seq *          Attribute;
    AddRequest_attrs_Seq_values *   ValueSequence;
    AttributeValue *                Attribute_Alias;
    AttributeValue *                Attribute_IPAddress;
    AttributeValue *                Attribute_ObjectClass;
    AttributeValue *                Attribute_Comment;
    AttributeValue                  Attribute_Comment_Old;
    ANSI_STRING         String;
                
    CHAR    IPAddressText   [0x20];
    USHORT  IPAddressTextLength;

    Request = &Message -> protocolOp.u.addRequest;

    // check to see if an existing operation with the same message id is pending.
    // if so, the client is in violation of the LDAP spec.
    // we'll just ignore the packet in this case.
    // at the same time, compute the insertion position for the new operation (for use later).

    if (FindOperationIndexByMessageID (Message -> messageID, &OperationInsertionIndex)) {
        DebugF (_T("LDAP: client has issued two requests with the same message ID (%u), LDAP protocol violation, packet will not be processed\n"),
            Message -> messageID);

        return FALSE;
    }

    // NetMeeting supplies the objectClass in the directory path.
    // TAPI supplies the objectClass in the attribute set.
    // Don't you just love standards?

    InitializeAnsiString (&DirectoryPath, &Request -> entry);
    ParseDirectoryPath (&DirectoryPath, &PathElements);

    if (PathElements.ObjectClass.Buffer) {
        if (RtlEqualStringConst (&PathElements.ObjectClass, &LdapText_RTPerson, TRUE)) {
            NeedObjectClass = FALSE;
        }
        else {
            DebugF (_T("LDAP: AddRequest: objectClass (%.*S) is not RTPerson -- ignoring pdu\n"),
                ANSI_STRING_PRINTF (&PathElements.ObjectClass));

            return FALSE;
        }
    }
    else {
        DebugF (_T("LDAP: AddRequest: directory path (%.*S) does not contain objectClass -- will search attribute set\n"),
            ANSI_STRING_PRINTF (&DirectoryPath));

        NeedObjectClass = TRUE;
    }

    // first, determine if the attributes of this object
    // match the set of objects we wish to modify.

    DebugF (_T("LDAP: AddRequest, entry (%.*S), attributes:\n"),
        Request -> entry.length,
        Request -> entry.value);

    // scan through the set of attributes
    // find interesting data

    Attribute_Alias = NULL;
    Attribute_IPAddress = NULL;
    Attribute_ObjectClass = NULL;
    Attribute_Comment = NULL;

    for (Iter = Request -> attrs; Iter; Iter = Iter -> next) {
        Attribute = &Iter -> value;

        InitializeAnsiString (&AttributeTag, &Attribute -> type);

        if (Attribute -> values) {
            // we are only concerned with single-value attributes
            // if it's one of the attributes that we want,
            // then store in local variable

            if (RtlEqualStringConst (&AttributeTag, &LdapText_Attribute_sipaddress, TRUE)
                || RtlEqualStringConst (&AttributeTag, &LdapText_Attribute_ipAddress, TRUE))
                Attribute_IPAddress = &Attribute -> values -> value;
            else if (RtlEqualStringConst (&AttributeTag, &LdapText_Attribute_rfc822mailbox, TRUE))
                Attribute_Alias = &Attribute -> values -> value;
            else if (RtlEqualStringConst (&AttributeTag, &LdapText_ObjectClass, TRUE))
                Attribute_ObjectClass = &Attribute -> values -> value;
            else if (RtlEqualStringConst (&AttributeTag, &LdapText_Attribute_comment, TRUE))
                Attribute_Comment = &Attribute -> values -> value;
            // else, we aren't interested in the attribute
        }
        else {
            // else, the attribute has no values
        }

        DebugF (_T("\ttype (%.*S) values: "),
            Attribute -> type.length,
            Attribute -> type.value);

        for (ValueSequence = Attribute -> values; ValueSequence; ValueSequence = ValueSequence -> next)
            DebugF (_T(" (%.*S)"),
                ValueSequence -> value.length,
                ValueSequence -> value.value);      // *wow*

        Debug (_T("\n"));
    }

    // make sure that we found an objectClass value.
    // make sure that the objectClass = RTPerson

    if (NeedObjectClass) {

        if (!Attribute_ObjectClass) {
            Debug (_T("LDAP: AddRequest did not contain objectClass in attribute set -- ignoring pdu\n"));
            return FALSE;
        }

        InitializeAnsiString (&String, Attribute_ObjectClass);
        if (!RtlEqualStringConst (&String, &LdapText_RTPerson, TRUE)) {
            DebugF (_T("LDAP: AddRequest: objectClass (%.*S) is not RTPerson -- ignoring pdu\n"),
                ANSI_STRING_PRINTF (&String));

            return FALSE;
        }
    }

    // make sure that the alias is present
    // store in local string for use later

    if (!Attribute_Alias) {
        DebugF (_T("LDAP: AddRequest: request did not contain e-mail alias -- ignoring\n"));
        return FALSE;
    }

    InitializeAnsiString (&ClientAlias, Attribute_Alias);

    // if a comment field is present, and the comment is "Generated by TAPI3"
    // (which is so lame), modify it so that it says "Generated by TAPI3, modified by ICS"

    if (Attribute_Comment) {
        Attribute_Comment_Old = *Attribute_Comment;

        InitializeAnsiString (&String, Attribute_Comment);
        if (RtlEqualStringConst (&String, &LdapText_GeneratedByTAPI, TRUE)) {
            Debug (_T("LDAP: replacing comment text\n"));

            Attribute_Comment -> value = (PUCHAR) LdapText_ModifiedByICS.Buffer;
            Attribute_Comment -> length = LdapText_ModifiedByICS.Length * sizeof (CHAR);
        }
        else {
            Debug (_T("LDAP: not replacing comment text\n"));
        }
    }

    // make sure ip address attribute is present
    // parse the address, build replacement address

    if (!Attribute_IPAddress) {
        Debug (_T("LDAP: AddRequest: request did not contain IP address field -- ignoring\n"));
        return FALSE;
    }

    IPAddressTextLength = min (0x1F, (USHORT) Attribute_IPAddress -> length);
    IPAddressText [IPAddressTextLength] = 0;
    memcpy (IPAddressText, Attribute_IPAddress -> value, IPAddressTextLength * sizeof (CHAR));

    if (RtlCharToInteger (IPAddressText, 10, &OldClientAddress.s_addr) != STATUS_SUCCESS) {
        DebugF (_T("LDAP: AddRequest: bogus IP address value (%.*S)\n"),
            Attribute_IPAddress -> length,
            Attribute_IPAddress -> value);

        return FALSE;
    }

    // Workaround Alert!
    // NetMeeting stores its IP address as an attribute on an LDAP object on an ILS server.
    // Makes sense. The attribute is encoded as a textual string, so they had to convert
    // the IP address to text.  Any sane person would have chosen the standard dotted-quad
    // format, but they chose to interpret the IP address as a 32-bit unsigned integer,
    // which is fair enough, and then to convert that integer to a single decimal text string.

    // That's all great, that's just fine.  But NetMeeting stores the attribute byte-swapped
    // -- they used ntohl one too many times.  Grrrrrrrr....  The value should have been stored
    // without swapping the bytes, since the interpretation was "unsigned integer" and not "octet sequence".

    OldClientAddress.s_addr = htonl (ByteSwap (OldClientAddress.s_addr));

    // get the address that we want to substitute (our external interface address)

    if (!GetExternalLocalAddress (&ExternalAddress)) {
        Debug (_T("LDAP: failed to get external local address -- internal error\n"));
        return FALSE;
    }
    NewClientAddress = ExternalAddress.sin_addr;

    // believe me, this IS CORRECT.
    // see the long note above for more info. -- arlied

    if (RtlIntegerToChar (ByteSwap (ntohl (NewClientAddress.s_addr)),
        10, 0x1F, IPAddressText) != STATUS_SUCCESS) {
        Debug (_T("LDAP: failed to convert IP address to text -- internal error\n"));
        return FALSE;
    }

    // extract address of LDAP server for translation object
    AddressLength = sizeof (SOCKADDR_IN);
    if (getpeername (ServerSocket.Socket, (SOCKADDR *) &ServerAddress, &AddressLength)) {
        Debug (_T("LDAP: failed to get server address\n"));
        ZeroMemory (&ServerAddress, sizeof (SOCKADDR_IN));
    }

    // allocate and build an LDAP_OPERATION structure.

    CreateOperation (
        LDAP_OPERATION_ADD,
        Message -> messageID,
        &DirectoryPath,
        &ClientAlias,
        OldClientAddress,
        &ServerAddress);

    DebugF (_T("LDAP: AddRequest: replacing client address (%08X) with my address (%08X), alias (%.*S)\n"),
        ntohl (OldClientAddress.s_addr),
        ntohl (NewClientAddress.s_addr),
        ANSI_STRING_PRINTF (&ClientAlias));

    // the entry is now in the operation array
    // later, when the server sends the AddResponse,
    // we'll match the response with the request,
    // and modify the LDAP_TRANSLATION_TABLE

    // now, in-place, we modify the PDU structure,
    // reencode it, send it, undo the modification
    // (so ASN1Free_AddRequest doesn't freak out)

    assert (Attribute_IPAddress);
    IPAddressOldValue = *Attribute_IPAddress;

    Attribute_IPAddress -> value = (PUCHAR) IPAddressText;
    Attribute_IPAddress -> length = strlen (IPAddressText);

    PumpClientToServer.EncodeSendMessage (Message);

    // switch back so we don't a/v when decoder frees pdu
    *Attribute_IPAddress = IPAddressOldValue;
    if (Attribute_Comment)
        *Attribute_Comment = Attribute_Comment_Old;

    return TRUE;
}

BOOL LDAP_CONNECTION::ProcessModifyRequest (
    IN  LDAP_MESSAGE_ID MessageID,
    IN  ModifyRequest * Request)
{
    ModifyRequest_modifications *   ModIter;
    ModifyRequest_modifications_Seq *   Mod;
    LPCTSTR     Op;
    ModifyRequest_modifications_Seq_modification_values *   ValueIter;

    DebugF (_T("LDAP: ModifyRequest, object (%.*S), modifications:\n"),
        Request -> object.length,
        Request -> object.value);


    for (ModIter = Request -> modifications; ModIter; ModIter = ModIter -> next) {

        Mod = &ModIter -> value;

        switch (Mod -> operation) {
        case    add:
            Op = _T("add");
            break;

        case    operation_delete:
            Op = _T("delete");
            break;

        case    replace:
            Op = _T("replace");
            break;

        default:
            Op = _T("???");
            break;
        }

        DebugF (_T("\toperation (%s) type (%.*S) values"), Op,
            Mod -> modification.type.length,
            Mod -> modification.type.value);

        for (ValueIter = Mod -> modification.values; ValueIter; ValueIter = ValueIter -> next) {

            DebugF (_T(" (%.*S)"),
                ValueIter -> value.length,
                ValueIter -> value.value);
        }

        Debug (_T("\n"));
    }

    return FALSE;
}

BOOL LDAP_CONNECTION::ProcessDeleteRequest (
    IN  LDAP_MESSAGE_ID MessageID,
    IN  DelRequest *    Request)
{
    ANSI_STRING  DirectoryPath;
    HRESULT Result = S_FALSE;
    LDAP_PATH_ELEMENTS  PathElements;

    assert (Request);

    DirectoryPath.Buffer = (PCHAR) Request -> value;
    DirectoryPath.Length = (USHORT) Request -> length;
    DirectoryPath.MaximumLength = (USHORT) Request -> length;

    ParseDirectoryPath (&DirectoryPath, &PathElements);

    Result = LdapTranslationTable.RemoveEntryByAlias (&PathElements.CN);

    if (Result == S_OK) {

        DebugF (_T("LDAP: DeleteRequest: Removed entry (%.*S) from LDAP table.\n"),
            ANSI_STRING_PRINTF (&DirectoryPath));

    } else {
        
        DebugF (_T("LDAP: DeleteRequest: Attempted to remove entry (%.*S) from LDAP table, but it was not there.\n"),
            ANSI_STRING_PRINTF (&DirectoryPath));
    
    }

    return FALSE;
}

BOOL LDAP_CONNECTION::ProcessSearchRequest (
    IN  LDAPMessage *   Message)
{
    SearchRequest *     Request;
    ANSI_STRING         DirectoryPath;
    LDAP_PATH_ELEMENTS  PathElements;
    ANSI_STRING         AttributeTag;
    LDAP_OPERATION *    Operation;
    DWORD               OperationInsertionIndex;
    BOOL                NeedObjectClass;
    SOCKADDR_IN         DummyServerAddress = { 0 };
    IN_ADDR             DummyClientAddress = { 0 };

    SearchRequest_attributes *      Iter;
    AttributeType *             Attribute_ObjectClass;
    ANSI_STRING                 String;
    AttributeType *             Attribute_IPAddress;
    AttributeType *             Attribute;        
    BOOL                        Attribute_IPAddress_Present = FALSE;
                
    Request = &Message -> protocolOp.u.searchRequest;

    // check to see if an existing operation with the same message id is pending.
    // if so, the client is in violation of the LDAP spec.
    // we'll just ignore the packet in this case.
    // at the same time, compute the insertion position for the new operation (for use later).

    if (FindOperationIndexByMessageID (Message -> messageID, &OperationInsertionIndex)) {
        DebugF (_T("LDAP: client has issued two requests with the same message ID (%u), LDAP protocol violation, packet will not be processed\n"),
            Message -> messageID);

        return FALSE;
    }

    // Cover the case when SearchRequest does not supply baseObject 
    if (Request -> baseObject.value == NULL || Request -> baseObject.length == 0) {
            return FALSE;
    }

    // NetMeeting supplies the objectClass in the directory path.
    // TAPI supplies the objectClass in the attribute set.
    // Don't you just love standards?

    InitializeAnsiString (&DirectoryPath, &Request -> baseObject);
    ParseDirectoryPath (&DirectoryPath, &PathElements);

    if (PathElements.ObjectClass.Buffer) {
        if (RtlEqualStringConst (&PathElements.ObjectClass, &LdapText_RTPerson, TRUE)) {
            NeedObjectClass = FALSE;
        }
        else {
            DebugF (_T("LDAP: SearchRequest: objectClass (%.*S) is not RTPerson -- ignoring pdu\n"),
                ANSI_STRING_PRINTF (&PathElements.ObjectClass));

            return FALSE;
        }
    }
    else {
        DebugF (_T("LDAP: SearchRequest: object class (%.*S) does not contain objectClass -- will search attribute set\n"),
            ANSI_STRING_PRINTF (&DirectoryPath));

        NeedObjectClass = TRUE;
    }

/*  // first, determine if the attributes of this object
    // contain IP address request and supply alias 
    // for which resolution is being requested

    //__DebugF (_T("LDAP: SearchRequest, entry (%.*S)\n"),
        Request -> baseObject.length,
        Request -> baseObject.value);

    // scan through the set of attributes
    // find interesting data

    Attribute_ObjectClass = NULL;
    DummyClientAddress.S_un.S_addr = 0;

    for (Iter = Request -> attributes; Iter; Iter = Iter -> next) {
        Attribute = &Iter -> value;

        InitializeAnsiString (&AttributeTag, Attribute);

    //__DebugF (_T("(%.*S)\n"),
        ANSI_STRING_PRINTF (&AttributeTag));

        if (Attribute -> value) {
            // we are only concerned with single-value attributes
            // if it's one of the attributes that we want,
            // then store in local variable

            if (RtlEqualStringConst (&AttributeTag, &LdapText_ObjectClass, TRUE))
                Attribute_ObjectClass = Attribute;
            // else, we aren't interested in the attribute
        }
        else {
            // else, the attribute has no values
        }
    }

    // Alias is stored in SearchRequest->Filter->FilterTypeAnd->FilterEqualityMatch->AttributeTypeCN
    //  ObjectClass is stored in SearchRequest->Filter->FilterTypeAnd->FilterEqualityMatch
    //                                                                      ->AttributeTypeObjectClass
    
    if (Request -> filter.choice == and_choice) {
        PFilter_and Filter_and = Request.u.and;
        
        if (Filter_and) {

        while (SetOf3) {
            if (SetOf3->value.choice == equalityMatch_chosen) {
                

    // make sure that we found an objectClass value.
    // make sure that the objectClass = RTPerson

    if (NeedObjectClass) {

        if (!Attribute_ObjectClass) {
            //__Debug (_T("LDAP: SearchRequest did not contain objectClass in attribute set -- ignoring pdu\n"));
            return FALSE;
        }

        InitializeAnsiString (&String, Attribute_ObjectClass);

        if (!RtlEqualStringConst (&String, &LdapText_RTPerson, TRUE)) {
            //__DebugF (_T("LDAP: SearchRequest: objectClass (%.*S) is not RTPerson -- ignoring pdu\n"),
                ANSI_STRING_PRINTF (&String));

            return FALSE;
        }
    }

    // make sure that the alias is present
    // store in local string for use later

    if (!Attribute_Alias) {
        //__DebugF (_T("LDAP: SearchRequest: request did not contain alias -- ignoring\n"));
        return FALSE;
    }

    InitializeAnsiString (&ClientAlias, Attribute_Alias);

    // make sure ip address attribute is present
    if (!Attribute_IPAddress_Present) {
        //__Debug (_T("LDAP: SearchRequest: request did not contain IP address field -- ignoring\n"));
        return FALSE;
    }
*/

    // -XXX- if we found objectClass in the search path or in the attribute set,
    // -XXX- verify that it is RTPerson.  if it is not, do not create an operation
    // -XXX- record, so that we do not modify the return set of the query later.
    // -XXX- if we did not find it in either place, assume RTPerson objects may
    // -XXX- be in the return set.

    // allocate and build an LDAP_OPERATION structure.

    CreateOperation (
        LDAP_OPERATION_SEARCH,
        Message -> messageID,
        &DirectoryPath,
        NULL,
        DummyClientAddress,
        &DummyServerAddress);

    DebugF (_T("LDAP: SearchRequest: inserting request into operation table.\n"));

    // the entry is now in the operation array
    // later, when the server sends the SearchResponse,
    // we'll match the response with the request,
    // and modify the IP address if an entry with
    // the matching alias happens to be in the 
    // LDAP_TRANSLATION_TABLE. This would mean that 
    // the client running on the proxy machine itself
    // wishes to connect to a private subnet client.

    PumpClientToServer.EncodeSendMessage (Message);

    return TRUE;
}

// server to client messages

void LDAP_CONNECTION::ProcessAddResponse (
    IN  LDAPMessage *   Message)
{
    AddResponse *       Response;
    LDAP_OPERATION *    Operation;

    Response = &Message -> protocolOp.u.addResponse;

    AssertLocked();

    Debug (_T("LDAP: server sent AddResponse\n"));

    if (!FindOperationByMessageID (Message -> messageID, &Operation)) {
        DebugF (_T("LDAP: received AddResponse, but message ID (%u) does not match any outstanding request -- ignoring\n"),
            Message -> messageID);

        return;
    }

    if (Operation -> Type == LDAP_OPERATION_ADD) {

        if (Response -> resultCode == success) {
            Debug (_T("LDAP: server has approved AddRequest -- will now populate the translation table\n"));

            assert (Operation -> Alias.Buffer);
            assert (Operation -> DirectoryPath.Buffer);

            LdapTranslationTable.InsertEntry (
                &Operation -> Alias,
                &Operation -> DirectoryPath,
                Operation -> ClientAddress,
                &Operation -> ServerAddress);
        }
        else {
            DebugF (_T("LDAP: received AddResponse, server has rejected request, result code (%u)\n"),
                Response -> resultCode);
        }
    }
    else {
        DebugF (_T("LDAP: received AddResponse with message ID (%u), and found matching pending request, but the type of the request does not match (%d)\n"),
            Message -> messageID,
            Operation -> Type);
    }

    Operation -> FreeContents();
                
    OperationArray.DeleteEntry (Operation);
}

void LDAP_CONNECTION::ProcessModifyResponse (
    IN  LDAP_MESSAGE_ID     MessageID,
    IN  ModifyResponse *    Response)
{
}

void LDAP_CONNECTION::ProcessDeleteResponse (
    IN  LDAP_MESSAGE_ID     MessageID,
    IN  DelResponse *       Response)
{
}

BOOL LDAP_CONNECTION::ProcessSearchResponse (
    IN  LDAPMessage *   Message)
{
    SearchResponse *    Response;
    ANSI_STRING         ObjectName;
    LDAP_OBJECT_NAME_ELEMENTS   ObjectNameElements = { 0 };
    ANSI_STRING         AttributeTag;
    ASN1octetstring_t   IPAddressOldValue;
    ANSI_STRING         ClientAlias;
    ANSI_STRING         String;
    HRESULT             TranslationTableLookupResult;
    IN_ADDR             LookupIPAddr;

    SearchResponse_entry_attributes             * Iter;
    SearchResponse_entry_attributes_Seq_values  * ValueSequence;
    SearchResponse_entry_attributes_Seq         * Attribute;
    AttributeValue *    Attribute_IPAddress;
                
    CHAR                IPAddressText   [0x20];
    BOOL                Result = FALSE;
    LDAP_OPERATION *    Operation;

    assert (Message);

    Response = &Message -> protocolOp.u.searchResponse;

    AssertLocked();

    if (!FindOperationByMessageID (Message -> messageID, &Operation)) {

        Result = FALSE;

    } else {
        
        if(Response -> choice == entry_choice) {

            if (Operation -> Type == LDAP_OPERATION_SEARCH) {
                // Parse this object's name to get alias and IP address
                InitializeAnsiString (&ObjectName, &Response -> u.entry.objectName);
                ParseObjectName (&ObjectName, &ObjectNameElements);

                DebugF (_T("LDAP: SearchResponse, entry (%.*S), attributes:\n"),
                    Response -> u.entry.objectName.length,
                    Response -> u.entry.objectName.value);

                /**********************************************************/
                //
                // HACKHACK:: Replace the DN with a standard string
                //

                #define REPLACEMENT_DN "o=Motorola,c=US"
                #define MAX_NEW_DN_SIZE 1000
                
                LDAPDN trueObjectName = Response -> u.entry.objectName;

                //
                // Find out if there is a pattern of DC=foo,DC=bar at the end.
                // If we find such a match, we will replace it with our replacement string.
                //

                int i;
                int dcmatches = 0;
                UCHAR savedChar;

                for (i=trueObjectName.length-3; i>0, dcmatches != 2; i--) {

                    if (trueObjectName.value[i]   == 'D' &&
                        trueObjectName.value[i+1] == 'C' &&
                        trueObjectName.value[i+2] == '=') {
                          dcmatches++;
                    }
                }


                if (dcmatches == 2) {

                    savedChar = trueObjectName.value[i+1];
                    trueObjectName.value[i+1] = '\0';

                    Response -> u.entry.objectName.value = (PUCHAR) LocalAlloc( LPTR, MAX_NEW_DN_SIZE );
        
                    if (Response -> u.entry.objectName.value) {
        
                        strcpy( (PCHAR)Response -> u.entry.objectName.value, (const PCHAR) trueObjectName.value );
                        strcpy( (PCHAR)Response -> u.entry.objectName.value + i + 1, REPLACEMENT_DN );
                        Response -> u.entry.objectName.length = strlen( (const PCHAR) trueObjectName.value) + strlen (REPLACEMENT_DN);
                        printf("New DN is %s\n", Response -> u.entry.objectName.value);
                        PumpServerToClient.EncodeSendMessage (Message);
                        Result = TRUE;
                        LocalFree( Response -> u.entry.objectName.value );
                    }
                    
                    trueObjectName.value[i] = savedChar;
                }

                //
                // switch back so we don't a/v when decoder frees pdu
                //
                
                Response -> u.entry.objectName = trueObjectName;


                /**********************************************************/

                /*
                // scan through the set of attributes
                // find the ones of interest

                Attribute_IPAddress = NULL;

                for (Iter = Response -> u.entry.attributes; Iter; Iter = Iter -> next) {
                    Attribute = &Iter -> value;

                    InitializeAnsiString (&AttributeTag, &Attribute -> type);

                    if (Attribute -> values) {
                        if (RtlEqualStringConst (&AttributeTag, &LdapText_Attribute_sipaddress, TRUE)
                            || RtlEqualStringConst (&AttributeTag, &LdapText_Attribute_ipAddress, TRUE))
                            Attribute_IPAddress = &Attribute -> values -> value;
                        // else, we aren't interested in the attribute
                    }
                    else {
                        // else, the attribute has no values
                    }

                    DebugF (_T("\ttype (%.*S) values: "),
                        Attribute -> type.length,
                        Attribute -> type.value);

                    for (ValueSequence = Attribute -> values; ValueSequence; ValueSequence = ValueSequence -> next)
                        DebugF (_T(" (%.*S)"),
                            ValueSequence -> value.length,
                            ValueSequence -> value.value);  

                    Debug (_T("\n"));
                }

                // make sure that the alias is present
                ClientAlias = ObjectNameElements.CN;

                if (ClientAlias.Length == 0) {
                    DebugF (_T("LDAP: SearchResponse: response did not contain e-mail alias -- ignoring\n"));
                    Result = FALSE;
                } else {
                    // make sure ip address attribute is present
                    if (!Attribute_IPAddress) {
                        Debug (_T("LDAP: AddRequest: request did not contain IP address field -- ignoring\n"));
                        Result = FALSE;
                    } else {
                        // see whether there is a registration entry in the translation table
                        // with the same alias -- if so, it must be a private client
                        TranslationTableLookupResult = LdapQueryTable (&ClientAlias, &LookupIPAddr);

                    #if DBG
                        LdapPrintTable ();
                    #endif                      

                        if (S_OK != TranslationTableLookupResult) {

                            Result = FALSE;
                        
                        } else {

                            // We get here when the ILS query returned an entry
                            // registered by a private subnet client. In this case
                            // we sneak into the LDAP pdu structure and substitute
                            // the IP address of the client by the value read from
                            // LDAP connection mapping table. This is how we make 
                            // possible calls by alias from the client on the proxy machine to   
                            // a private subnet client.
                            // We then forward the PDU to the intended destination.

                            assert (Attribute_IPAddress);

                            if (RtlIntegerToChar (LookupIPAddr.s_addr,
                                10, 0x1F, IPAddressText) != STATUS_SUCCESS) {
                                Debug (_T("LDAP: failed to convert IP address to text -- internal error\n"));
                                Result = FALSE;
                            } else {
                                // Save the old value of the IP address, - we will need to restore
                                // the PDU structure later.
                                IPAddressOldValue = *Attribute_IPAddress;

                                // now, in-place, we modify the PDU structure,
                                // reencode it, send it, undo the modification
                                // (so ASN1Free_SearchResponse doesn't freak out)
                                Attribute_IPAddress -> value = (PUCHAR) IPAddressText;
                                Attribute_IPAddress -> length = strlen (IPAddressText);

                                PumpServerToClient.EncodeSendMessage (Message);

                                // switch back so we don't a/v when decoder frees pdu
                                *Attribute_IPAddress = IPAddressOldValue;

                                Result = TRUE;
                            }
                        }
                    }
                }

                */
            } else {
                DebugF (_T("LDAP: received SearchResponse with message ID (%u), and found matching pending request, but the type of the request does not match (%d)\n"),
                    Message -> messageID,
                    Operation -> Type);
                Result = FALSE;
            }
        } else {
            // We free the operation and associated memory on SearchResponses containing result
            // code, no matter whether the code indicated success or failure
            assert (Response -> choice == resultCode_choice);

            Operation -> FreeContents();
                    
            OperationArray.DeleteEntry (Operation);
        }
    }

    return Result;
}

// this method does not assume ownership of the LdapMessage structure,
// which has scope only of this call stack.

BOOL LDAP_CONNECTION::ProcessLdapMessage (
    IN  LDAP_PUMP *     Pump,
    IN  LDAPMessage *   LdapMessage)
{
    assert (Pump);
    assert (LdapMessage);

    if (Pump == &PumpClientToServer) {

        switch (LdapMessage -> protocolOp.choice) {
        case    addRequest_choice:
            return ProcessAddRequest (LdapMessage);

        case    modifyRequest_choice:
            return ProcessModifyRequest (LdapMessage -> messageID, &LdapMessage -> protocolOp.u.modifyRequest);

        case    delRequest_choice:
            return ProcessDeleteRequest (LdapMessage -> messageID, &LdapMessage -> protocolOp.u.delRequest);

        case searchRequest_choice:
            return ProcessSearchRequest (LdapMessage);

        default:
#if 0
            DebugF (_T("LDAP: client is sending a pdu that is not interesting (choice %d) -- forwarding unaltered\n"),
                LdapMessage -> protocolOp.choice);
#endif

            return FALSE;
        }

        return FALSE;
    }
    else if (Pump == &PumpServerToClient) {

        switch (LdapMessage -> protocolOp.choice) {
        case    addResponse_choice:
            ProcessAddResponse (LdapMessage);
            break;

        case    modifyResponse_choice:
            ProcessModifyResponse (LdapMessage -> messageID, &LdapMessage -> protocolOp.u.modifyResponse);
            break;

        case    delResponse_choice:
            ProcessDeleteResponse (LdapMessage -> messageID, &LdapMessage -> protocolOp.u.delResponse);
            break;

        case    searchResponse_choice:
            return ProcessSearchResponse (LdapMessage);
            break;

        default:
#if 0
            DebugF (_T("LDAP: server is sending a pdu that is not interesting (choice %d) -- forwarding unaltered\n"),
                LdapMessage -> protocolOp.choice);
#endif
            break;
        }

        return FALSE;

    }
    else {
        AssertNeverReached();
        return FALSE;
    }
}

void LDAP_CONNECTION::ProcessBuffer (
    IN  LDAP_PUMP *     Pump,
    IN  LDAP_BUFFER *   Buffer)
{
    ASN1error_e     Error;
    LDAPMessage *   PduStructure;
    ASN1decoding_t  Decoder;

    assert (Pump);
    assert (Buffer);
        
    // decode the PDU

    Error = ASN1_CreateDecoder (LDAP_Module, &Decoder, Buffer -> Data.Data, Buffer -> Data.Length, NULL);

    if (Error == ASN1_SUCCESS) {

        PduStructure = NULL;
        Error = ASN1_Decode (Decoder, (PVOID *) &PduStructure, LDAPMessage_ID, 0, NULL, 0);

        if (ASN1_SUCCEEDED (Error)) {
            if (ProcessLdapMessage (Pump, PduStructure)) {
                // a TRUE return value indicates that ProcessLdapMessage interpreted
                // and acted on the contents of PduStructure.  therefore, the
                // original PDU is no longer needed, and is destroyed.

                delete Buffer;
            }
            else {
                // a FALSE return value indicates that ProcessLdapMessage did NOT
                // interpret the contents of PduStructure, and that no data has been
                // sent to the other socket.  In this case, we forward the original PDU.

                Pump -> SendQueueBuffer (Buffer);
            }

            ASN1_FreeDecoded (Decoder, PduStructure, LDAPMessage_ID);
        }
        else {
            DebugF (_T("LDAP: failed to decode pdu, asn error %d, forwarding pdu without interpreting contents\n"),
                Error);

#if DBG
            DumpMemory (Buffer -> Data.Data, Buffer -> Data.Length);
            BerDump (Buffer -> Data.Data, Buffer -> Data.Length);
            ASN1_Decode (Decoder, (PVOID *) &PduStructure, LDAPMessage_ID, 0, Buffer -> Data.Data, Buffer -> Data.Length);
#endif

            Pump -> SendQueueBuffer (Buffer);
        }

        ASN1_CloseDecoder (Decoder);
    }
    else {
        DebugF (_T("LDAP: failed to create asn decoder, asn error %d, forwarding pdu without interpreting contents\n"),
            Error);

        Pump -> SendQueueBuffer (Buffer);
    }
}

// static
INT LDAP_CONNECTION::BinarySearchOperationByMessageID (
    IN  const   LDAP_MESSAGE_ID *   SearchKey,
    IN  const   LDAP_OPERATION *    Comparand)
{
    if (*SearchKey < Comparand -> MessageID) return -1;
    if (*SearchKey > Comparand -> MessageID) return 1;

    return 0;
}

BOOL LDAP_CONNECTION::FindOperationIndexByMessageID (
    IN  LDAP_MESSAGE_ID MessageID,
    OUT DWORD *         ReturnIndex)
{
    return OperationArray.BinarySearch ((SEARCH_FUNC_LDAP_OPERATION)BinarySearchOperationByMessageID, &MessageID, ReturnIndex);
}

BOOL LDAP_CONNECTION::FindOperationByMessageID (
    IN  LDAP_MESSAGE_ID MessageID,
    OUT LDAP_OPERATION **   ReturnOperation)
{
    DWORD   Index;

    if (OperationArray.BinarySearch ((SEARCH_FUNC_LDAP_OPERATION)BinarySearchOperationByMessageID, &MessageID, &Index)) {
        *ReturnOperation = &OperationArray[Index];
        return TRUE;
    }
    else {
        *ReturnOperation = NULL;
        return FALSE;
    }
}

void LDAP_CONNECTION::OnStateChange (
    LDAP_SOCKET *       ContainedSocket,
    LDAP_SOCKET::STATE  NewSocketState)
{
    assert (ContainedSocket == &ClientSocket || ContainedSocket == &ServerSocket);

    AssertLocked();

    switch (NewSocketState) {

    case    LDAP_SOCKET::STATE_CONNECT_PENDING:
        // Source socket transitions directly from
        // STATE_NONE to STATE_CONNECTED
        assert (ContainedSocket != &ClientSocket);

        State = STATE_CONNECT_PENDING;

        break;

    case    LDAP_SOCKET::STATE_CONNECTED:

        if (ClientSocket.GetState() == LDAP_SOCKET::STATE_CONNECTED
            && ServerSocket.GetState() == LDAP_SOCKET::STATE_CONNECTED) {
            
            State = STATE_CONNECTED;

            StartIo();
        }

        break;

    case    LDAP_SOCKET::STATE_TERMINATED:

        Terminate ();

        break;
    }
}


void LDAP_CONNECTION::Terminate (void)
{
    switch (State) {
        
    case    STATE_TERMINATED:
        // nothing to do
        break;

    default:
        State = STATE_TERMINATED;

        ClientSocket.Terminate();
        ServerSocket.Terminate();
        PumpClientToServer.Terminate();
        PumpServerToClient.Terminate();

        LdapConnectionArray.RemoveConnection (this);
        
        break;
    }
}

void LDAP_CONNECTION::TerminateExternal (void) 
{
    Lock ();
    
    Terminate ();

    Unlock ();
}

// LDAP_CONNECTION_ARRAY ----------------------------------------------
LDAP_CONNECTION_ARRAY::LDAP_CONNECTION_ARRAY (void) {       
    IsEnabled = FALSE;
}

void LDAP_CONNECTION_ARRAY::RemoveConnection (
    LDAP_CONNECTION *   LdapConnection)
{
    LDAP_CONNECTION **  Pos;
    LDAP_CONNECTION **  End;
    BOOL                DoRelease;

    Lock();

    // linear scan, yick

    DoRelease = FALSE;

    ConnectionArray.GetExtents (&Pos, &End);

    for (; Pos < End; Pos++) {
        if (*Pos == LdapConnection) {

            // swap with last entry
            // quick way to delete entry from table
            *Pos = *(End - 1);
            ConnectionArray.Length--;

            DoRelease = TRUE;
            break;
        }
    }

    Unlock();

    if (DoRelease) {
//      DebugF (_T("LDAP: removed connection %p from table, releasing\n"), LdapConnection);

        LdapConnection -> Release();
    }
    else {
        // when could this happen?
        // perhaps a harmless race condition?

        DebugF (_T("LDAP: LDAP_CONNECTION %p could not be removed from table -- was not in table to begin with\n"), LdapConnection);
    }
}

void LDAP_CONNECTION_ARRAY::Start (void)
{       
    Lock ();

    IsEnabled = TRUE;

    Unlock ();
}

void LDAP_CONNECTION_ARRAY::Stop (void)
{
    LDAP_CONNECTION * LdapConnection;

    Lock ();

    IsEnabled = FALSE;

    while (ConnectionArray.GetLength()) {

        LdapConnection = ConnectionArray[0];

        LdapConnection -> AddRef ();

        Unlock ();

        LdapConnection -> TerminateExternal ();

        Lock ();

        LdapConnection -> Release ();
    }

    ConnectionArray.Free ();

    Unlock ();
}
    
HRESULT LDAP_CONNECTION_ARRAY::InsertConnection (
                                LDAP_CONNECTION * LdapConnection)
{
    LDAP_CONNECTION ** ConnectionHolder = NULL;
    HRESULT Result;

    Lock ();

    if (IsEnabled) {

        ConnectionHolder = ConnectionArray.AllocAtEnd ();

        if (NULL == ConnectionHolder) {

            Result = E_OUTOFMEMORY;

        } else {

            LdapConnection -> AddRef ();

            *ConnectionHolder = LdapConnection;

            Result = S_OK;
        }

    } else {
    
        Result = E_FAIL;
    }

    Unlock ();

    return Result;
}

// LDAP_ACCEPT ----------------------------------------------

LDAP_ACCEPT::LDAP_ACCEPT (void)
{
}

// static
void LDAP_ACCEPT::AsyncAcceptFunc (
    IN    PVOID             Context,
    IN    SOCKET            Socket,
    IN    SOCKADDR_IN *     LocalAddress,
    IN    SOCKADDR_IN *     RemoteAddress) {

    LDAP_CONNECTION *    LdapConnection;
    HRESULT            Result;
    NTSTATUS        Status;
    NAT_KEY_SESSION_MAPPING_INFORMATION        RedirectInformation;
    ULONG            Length;
    SOCKADDR_IN        DestinationAddress;

#if DBG
    ExposeTimingWindow ();
#endif

    DebugF (_T("LDAP: ----------------------------------------------------------------------\n")
        _T("LDAP: new connection accepted, local %08X:%04X remote %08X:%04X\n"),
        ntohl (LocalAddress -> sin_addr.s_addr),
        ntohs (LocalAddress -> sin_port),
        ntohl (RemoteAddress -> sin_addr.s_addr),
        ntohs (RemoteAddress -> sin_port));

    // a new LDAP connection has been accepted from the network.
    // first, we determine the original addresses of the transport connection.
    // if the connection was redirected to our socket (due to NAT),
    // then the query of the NAT redirect table will yield the original transport addresses.
    // if an errant client has connected to our service, well, we really didn't
    // intend for that to happen, so we just immediately close the socket.

    Length = sizeof RedirectInformation;

    Status = NatLookupAndQueryInformationSessionMapping (
        g_NatHandle,
        IPPROTO_TCP,
        LocalAddress -> sin_addr.s_addr,
        LocalAddress -> sin_port,
        RemoteAddress -> sin_addr.s_addr,
        RemoteAddress -> sin_port,
        &RedirectInformation,
        &Length,
        NatKeySessionMappingInformation);

    if (Status != STATUS_SUCCESS) {
        DebugErrorF (Status, _T("LDAP: new connection was accepted from (%08X:%04X), but it is not in the NAT redirect table -- rejecting connection.\n"),
            ntohl (RemoteAddress -> sin_addr.s_addr),
            ntohs (RemoteAddress -> sin_port));

        closesocket (Socket);
        Socket = INVALID_SOCKET;

        return;
    }

    DebugF (_T("LDAP: NatLookupAndQueryInformationSessionMapping results:\n")
        _T("\tDestination    -- %08X:%04X\n")
        _T("\tSource         -- %08X:%04X\n")
        _T("\tNewDestination -- %08X:%04X\n")
        _T("\tNewSource      -- %08X:%04X\n"),
        ntohl (RedirectInformation.DestinationAddress),
        ntohs (RedirectInformation.DestinationPort),
        ntohl (RedirectInformation.SourceAddress),
        ntohs (RedirectInformation.SourcePort),
        ntohl (RedirectInformation.NewDestinationAddress),
        ntohs (RedirectInformation.NewDestinationPort),
        ntohl (RedirectInformation.NewSourceAddress),
        ntohs (RedirectInformation.NewSourcePort));

    // based on the source address of the socket, we decide whether the connection
    // came from an internal or external client.  this will govern later decisions
    // on how the call is routed. 
    // Note that INBOUND calls are not supported 

    if (IsInternalCallSource (ntohl (RedirectInformation.SourceAddress)) || TRUE/*(ntohl(RedirectInformation.SourceAddress) == 0x7F000001)*/) {
        DebugF (_T("LDAP: new connection accepted, client (%08X:%04X) server (%08X:%04X)\n"),
            ntohl (RedirectInformation.SourceAddress),
            ntohs (RedirectInformation.SourcePort),
            ntohl (RedirectInformation.DestinationAddress),
            ntohs (RedirectInformation.DestinationPort));

        DestinationAddress.sin_family = AF_INET;
        DestinationAddress.sin_addr.s_addr = RedirectInformation.DestinationAddress;
        DestinationAddress.sin_port = RedirectInformation.DestinationPort;

    } else {

        Debug (_T("LDAP: *** ERROR, received INBOUND LDAP connection, cannot yet process\n"));

        closesocket (Socket);
        Socket = INVALID_SOCKET;

        return;
    }

    // Create new LDAP_CONNECTION object
    LdapConnection = new LDAP_CONNECTION;

    if (!LdapConnection) {
        DebugF(_T("LDAP: allocation failure\n"));

        closesocket (Socket);
        Socket = INVALID_SOCKET;

        return;
    }

    LdapConnection -> AddRef ();
        
    if (LdapConnectionArray.InsertConnection (LdapConnection) == S_OK) {

        Result = LdapConnection -> AcceptSocket (Socket,
          LocalAddress,
          RemoteAddress,
          &DestinationAddress);

        if (Result != S_OK) {

            DebugF(_T("LDAP: accepted new LDAP client, but failed to initialize LDAP_CONNECTION\n"));

            // Probably there was something wrong with just this
            // Accept failure. Continue to accept more LDAP connections.
        }
    }

    LdapConnection -> Release (); 
}


HRESULT LDAP_ACCEPT::StartNatRedirects (void) {

    NTSTATUS    Status;

    Status = NatCreateDynamicPortRedirect (
        0,
        IPPROTO_TCP,
        htons (LDAP_STANDARD_PORT),
        ListenSocketAddress.sin_addr.s_addr,
        ListenSocketAddress.sin_port,
        LDAP_MAX_CONNECTION_BACKLOG,
        &IoDynamicRedirectHandle1);

    if (Status != STATUS_SUCCESS) {
        IoDynamicRedirectHandle1 = NULL;

        DebugError (Status, _T("LDAP_ACCEPT::StartNatRedirects: failed to create dynamic redirect #1.\n"));

        return (HRESULT) Status;
    }

    Status = NatCreateDynamicPortRedirect (
        0,
        IPPROTO_TCP,
        htons (LDAP_ALTERNATE_PORT),
        ListenSocketAddress.sin_addr.s_addr,
        ListenSocketAddress.sin_port,
        LDAP_MAX_CONNECTION_BACKLOG,
        &IoDynamicRedirectHandle2);

    if (Status != STATUS_SUCCESS) {

        NatCancelDynamicRedirect (IoDynamicRedirectHandle1);

        IoDynamicRedirectHandle1 = NULL;
        IoDynamicRedirectHandle2 = NULL;

        DebugError (Status, _T("LDAP_ACCEPT::StartNatRedirects: failed to create dynamic redirect #2.\n"));
    }

    return (HRESULT) Status;
}


HRESULT LDAP_ACCEPT::CreateBindSocket (void) {

    SOCKADDR_IN        SocketAddress;
    HRESULT            Result;

    SocketAddress.sin_family = AF_INET;
    SocketAddress.sin_addr   = g_PrivateInterfaceAddress;
    SocketAddress.sin_port   = htons (0);                // request dynamic port

    Result = AsyncAcceptContext.StartIo (
        &SocketAddress,
        AsyncAcceptFunc,
        NULL);

    if (Result != S_OK) {

        DebugError (Result, _T("LDAP_ACCEPT::CreateBindSocket: failed to create and bind socket\n"));

        return Result;
    }

    Result = AsyncAcceptContext.GetListenSocketAddress (&ListenSocketAddress);

    if (Result != S_OK) {

        DebugError (Result, _T("LDAP_ACCEPT::CreateBindSocket: failed to get listen socket address\n"));

        return Result;
    }

    return S_OK;
}

HRESULT LDAP_ACCEPT::Start (void) {

    HRESULT        Result;

    Result = CreateBindSocket ();
    if (Result != S_OK) {
        return Result;
    }

    Result = StartNatRedirects ();
    if (Result != S_OK) {
        return Result;
    }

    return S_OK;
}

void LDAP_ACCEPT::Stop (void) {

    AsyncAcceptContext.StopWait ();

    if (IoDynamicRedirectHandle1) {
        NatCancelDynamicRedirect (IoDynamicRedirectHandle1);

        IoDynamicRedirectHandle1 = NULL;
    }

    if (IoDynamicRedirectHandle2) {
        NatCancelDynamicRedirect (IoDynamicRedirectHandle2);

        IoDynamicRedirectHandle2 = NULL;
    }
}

LDAP_BUFFER::LDAP_BUFFER (void)
{
}


LDAP_BUFFER::~LDAP_BUFFER()
{
}

// LDAP_CODER ---------------------------------------------------------------------

LDAP_CODER::LDAP_CODER (void)
{
    Encoder = NULL;
    Decoder = NULL;

    LDAP_Module_Startup();
}

LDAP_CODER::~LDAP_CODER (void)
{
    Encoder = NULL;
    Decoder = NULL;

    LDAP_Module_Cleanup();
}

DWORD LDAP_CODER::Start (void)
{
    DWORD   Status;
    ASN1error_e Error;

    Lock();

    Status = ERROR_SUCCESS;

    Error = ASN1_CreateEncoder (LDAP_Module, &Encoder, NULL, 0, NULL);

    if (ASN1_FAILED (Error)) {
        DebugF (_T("LDAP: failed to initialize LDAP ASN.1 BER encoder, %d\n"), Error);
        Encoder = NULL;
        Status = ERROR_GEN_FAILURE;
    }

    Error = ASN1_CreateDecoder (LDAP_Module, &Decoder, NULL, 0, NULL);

    if (ASN1_FAILED (Error)) {
        DebugF (_T("LDAP: failed to initialize LDAP ASN.1 BER decoder, %d\n"), Error);
        Decoder = NULL;
        Status = ERROR_GEN_FAILURE;
    }

    Unlock();

    return Status;
}

void LDAP_CODER::Stop (void)
{
    Lock();

    if (Encoder) {
        ASN1_CloseEncoder (Encoder);
        Encoder = NULL;
    }

    if (Decoder) {
        ASN1_CloseDecoder (Decoder);
        Decoder = NULL;
    }

    Unlock();
}

ASN1error_e LDAP_CODER::Decode (
    IN  LPBYTE  Data,
    IN  DWORD   Length,
    OUT LDAPMessage **  ReturnPduStructure,
    OUT DWORD * ReturnIndex)
{
    ASN1error_e     Error;

    assert (Data);
    assert (ReturnPduStructure);
    assert (ReturnIndex);

    Lock();

    if (Decoder) {

#if DBG
        BerDump (Data, Length);
#endif

        Error = ASN1_Decode (
            Decoder,
            (PVOID *) ReturnPduStructure,
            LDAPMessage_ID,
            ASN1DECODE_SETBUFFER,
            Data,
            Length);

        switch (Error) {
        case    ASN1_SUCCESS:
            // successfully decoded pdu

            *ReturnIndex = Decoder -> len;
            assert (*ReturnPduStructure);

            DebugF (_T("LDAP: successfully decoded pdu, submitted buffer length %d, used %d bytes\n"),
                Length,
                *ReturnIndex);

            break;

        case    ASN1_ERR_EOD:
            // not enough data has been accumulated yet

            *ReturnIndex = 0;
            *ReturnPduStructure = NULL;

            DebugF (_T("LDAP: cannot yet decode pdu, not enough data submitted (%d bytes in buffer)\n"),
                Length);
            break;

        default:
            if (ASN1_FAILED (Error)) {
                DebugF (_T("LDAP: failed to decode pdu, for unknown reasons, %d\n"),
                    Error);
            }
            else {
                DebugF (_T("LDAP: pdu decoded, but with warning code, %d\n"),
                    Error);
            
                *ReturnIndex = Decoder -> len;
            }
            break;
        }
    }
    else {
        Debug (_T("LDAP: cannot decode pdu, because decoder was not initialized\n"));

        Error = ASN1_ERR_INTERNAL;
    }

    Unlock();

    return Error;
} 

// LDAP_PUMP --------------------------------------------------------------

LDAP_PUMP::LDAP_PUMP (
    IN  LDAP_CONNECTION *   ArgConnection,
    IN  LDAP_SOCKET *       ArgSource,
    IN  LDAP_SOCKET *       ArgDest)
{
    assert (ArgConnection);
    assert (ArgSource);
    assert (ArgDest);

    Connection = ArgConnection;
    Source = ArgSource;
    Dest = ArgDest;
    IsPassiveDataTransfer = FALSE;
}

LDAP_PUMP::~LDAP_PUMP (void)
{
}

void LDAP_PUMP::Terminate (void)
{
}

void LDAP_PUMP::Start (void)
{
    Source -> RecvIssue();
}

void LDAP_PUMP::Stop (void)
{
}

// called only by source socket OnRecvComplete
void LDAP_PUMP::OnRecvBuffer (
    IN  LDAP_BUFFER * Buffer)
{
    if (IsActivelyPassingData ()) {

        Connection -> ProcessBuffer (this, Buffer);
    
    } else {
        
        // DebugF (_T("LDAP_PUMP::OnRecvBuffer -- passing buffer without decoding.\n"));

        SendQueueBuffer (Buffer);
    }
}

void LDAP_PUMP::OnSendDrain (void)
{
    Source -> RecvIssue();
}

BOOL LDAP_PUMP::CanIssueRecv (void)
{
    return !Dest -> SendOverlapped.IsPending;
}

void LDAP_PUMP::SendQueueBuffer (
    IN  LDAP_BUFFER *   Buffer)
{
    Dest -> SendQueueBuffer (Buffer);
}

void LDAP_PUMP::EncodeSendMessage (
   IN   LDAPMessage *   Message)
{
    LDAP_BUFFER *   Buffer;
    ASN1encoding_t  Encoder;
    ASN1error_e     Error;

    Buffer = new LDAP_BUFFER;
    if (!Buffer) {
        Debug (_T("LDAP_PUMP::EncodeSendMessage: allocation failure\n"));
        return;
    }

    Error = ASN1_CreateEncoder (LDAP_Module, &Encoder, NULL, 0, NULL);
    if (ASN1_FAILED (Error)) {
        DebugF (_T("LDAP_PUMP::EncodeSendMessage: failed to create ASN.1 encoder, error %d\n"),
            Error);

        delete Buffer;
        return;
    }

    Error = ASN1_Encode (Encoder, Message, LDAPMessage_ID, ASN1ENCODE_ALLOCATEBUFFER, NULL, 0);
    if (ASN1_FAILED (Error)) {
        DebugF (_T("LDAP: failed to encode LDAP message, error %d\n"), Error);

        ASN1_CloseEncoder (Encoder);
        delete Buffer;
        return;
    }

    if (Buffer -> Data.Grow (Encoder -> len)) {
//      Debug (_T("LDAP: successfully encoded replacement LDAP message:\n"));
//      DumpMemory (Encoder -> buf, Encoder -> len);

        memcpy (Buffer -> Data.Data, Encoder -> buf, Encoder -> len);
        Buffer -> Data.Length = Encoder -> len;

        ASN1_FreeEncoded (Encoder, Encoder -> buf);

        SendQueueBuffer (Buffer);
        Buffer = NULL;
    }
    else {

        delete Buffer;
    }

    ASN1_CloseEncoder (Encoder);
}

BOOL    LDAP_PUMP::IsActivelyPassingData (void) const {

    return !IsPassiveDataTransfer;

}

void LDAP_PUMP::StartPassiveDataTransfer (void) {

    IsPassiveDataTransfer = TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\ovioctx.h ===
/*
 * Copyright (c) 1998, Microsoft Corporation
 * File: timeout.cpp
 *
 * Purpose: 
 * 
 * Contains all the definitions
 * for the overlapped I/O context structures
 *
 * History:
 *
 *   1. created 
 *       Ajay Chitturi (ajaych)  26-Jun-1998
 *
 */

#ifndef _oviocontext_h_
#define _oviocontext_h_

/*
 * This file defines the structures used for overlapped I/O 
 */

#define ACCEPT_BUFFER_MAX       (sizeof (SOCKADDR_IN) * 2 + 0x20)
#define TPKT_HEADER_SIZE 4
#define TPKT_VERSION    3

// Types of overlapped I/O requests
enum EMGR_OV_IO_REQ_TYPE
{
     EMGR_OV_IO_REQ_ACCEPT = 0,
     EMGR_OV_IO_REQ_SEND,
     EMGR_OV_IO_REQ_RECV
};



// This structure stores the I/O context for each Overlapped I/O request
// OVERLAPPED should always be the first member of this struct. 
// A pointer to the overlapped member of this structure is passed 
// for all overlapped I/O calls.
// When we receive an I/O completion packet, the IOContext pointer is 
// obtained by casting the OVERLAPPED pointer. 

typedef struct _IOContext {
    OVERLAPPED ov;
    EMGR_OV_IO_REQ_TYPE reqType;        // ACCEPT/SEND/RECV
    OVERLAPPED_PROCESSOR *pOvProcessor;   // callback called on this member
                                          // this gives us the socket and 
                                          // the call type (Q931/H245) as well
} IOContext, *PIOContext;

// This structure stores the I/O context 
// for each Overlapped Send/Recv request
typedef struct _SendRecvContext {
    IOContext ioCtxt;
    SOCKET sock;
    BYTE pbTpktHdr[TPKT_HEADER_SIZE];
    DWORD dwTpktHdrBytesDone;
    PBYTE pbData;
    DWORD dwDataLen;
    DWORD dwDataBytesDone;
} SendRecvContext, *PSendRecvContext;

// This structure stores the I/O context 
// for each Overlapped accept request
typedef struct _AcceptContext {
    IOContext ioCtxt;
    SOCKET listenSock;
    SOCKET acceptSock;
    BYTE addrBuf[ACCEPT_BUFFER_MAX]; 
} AcceptContext, *PAcceptContext;

#include "sockinfo.h"

// the PDU decode logic depends upon whether its targeted for
// a Q931 or H245 channel. Since we want to keep that logic
// in the event manager, the overlapped processor needs to
// expose its type via this 
enum OVERLAPPED_PROCESSOR_TYPE
{
	OPT_Q931 = 0,
	OPT_H245
};

// Classes (Q931 src, dest and H245) inheriting
// from this make async overlapped operations
// this class provides the callback methods and
// some of the parameters needed by the event manager
// to make the overlapped calls
class OVERLAPPED_PROCESSOR
{
protected:

    OVERLAPPED_PROCESSOR_TYPE  m_OverlappedProcessorType;

	// it belongs to this call state
	H323_STATE *	m_pH323State;
    SOCKET_INFO		m_SocketInfo;			// socket handle and remote/local address/ports

public:

	OVERLAPPED_PROCESSOR::OVERLAPPED_PROCESSOR (void)
		: m_OverlappedProcessorType	(OPT_Q931),
		  m_pH323State	(NULL)
	{}


	void Init (
		IN OVERLAPPED_PROCESSOR_TYPE	OverlappedProcessorType,
		IN H323_STATE					&H323State)
	{
		// an assert is sufficient as this shouldn't happen
		_ASSERTE(NULL == m_pH323State);

		m_OverlappedProcessorType	= OverlappedProcessorType;

		m_pH323State				= &H323State;
	}

	BOOLEAN IsSocketValid (void) { return m_SocketInfo.IsSocketValid(); }

    inline OVERLAPPED_PROCESSOR_TYPE GetOverlappedProcessorType() { return m_OverlappedProcessorType; }

    inline SOCKET_INFO &GetSocketInfo() { return m_SocketInfo; }

    inline H323_STATE &GetH323State() { return *m_pH323State; }

    inline CALL_BRIDGE &GetCallBridge();

    virtual HRESULT AcceptCallback (
		IN	DWORD	Status,
		IN	SOCKET	Socket,
		IN	SOCKADDR_IN *	LocalAddress,
		IN	SOCKADDR_IN *	RemoteAddress) = 0;

    virtual HRESULT SendCallback(
        IN      HRESULT					  CallbackHResult
        ) = 0;

    virtual HRESULT ReceiveCallback(
        IN      HRESULT					 CallbackHResult,
        IN      BYTE                    *pBuffer,
        IN      DWORD                    BufLen
        ) = 0;
};

void
EventMgrFreeSendContext(
       IN PSendRecvContext			pSendCtxt
       );
void
EventMgrFreeRecvContext(
       IN PSendRecvContext			pRecvCtxt
       );
void
EventMgrFreeAcceptContext(
       IN PAcceptContext			pAcceptCtxt
       );

#endif //_oviocontext_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\main.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    main() function.

Environment:

    User Mode - Win32

History:
    
    1. created 
        Ajay Chitturi (ajaych)  31-Jul-1998
    
    2. Modified
        Anoop Anantha (anoopa)  20-Apr-2000
        
        Standalone EXE incorporating just the LDAP proxy.

--*/



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "cbridge.h"
#include "ovioctx.h"
#include "iocompl.h"
#include "portmgmt.h"
#include "crv.h"
#include "q931info.h"
#include "cblist.h"
#include "q931io.h"
#include "main.h"
#include "ldappx.h"

#include <iprtrmib.h>
#include <iphlpapi.h>

// Init values from Registry keys

#define DEFAULT_TRACE_FLAGS     LOG_TRCE
            
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD                   RasSharedScopeAddress;          // host order
DWORD                   RasSharedScopeMask;             // host order
SYNC_COUNTER            PxSyncCounter;

HANDLE                  g_NatHandle = NULL;
IN_ADDR                 g_PrivateInterfaceAddress;
ULONG                   g_PrivateInterfaceIndex = INVALID_INTERFACE_INDEX;

// heap management -------------------------------------------------------------------

#if DBG

HANDLE  g_hSendRecvCtxtHeap     = NULL;
HANDLE  g_hAcceptCtxtHeap       = NULL;
HANDLE  g_hCbridgeListEntryHeap = NULL;
HANDLE  g_hCallBridgeHeap       = NULL;
HANDLE  g_hEventMgrCtxtHeap     = NULL;
HANDLE  g_hDefaultEventMgrHeap  = NULL;

#endif

// ------------------------------------------------------------------------------------

// equivalent to DLL_PROCESS_ATTACH
EXTERN_C BOOLEAN H323ProxyInitializeModule (void)
{
//  DebugBreak();

    Debug (_T("H323: DLL_PROCESS_ATTACH\n"));

    //H323ASN1Initialize();

#if DBG
#define CREATE_HEAP(Heap) \
    Heap = HeapCreate (0, 0, 0); \
    if (!Heap) DebugLastError (_T("H323: failed to allocate heap ") _T(#Heap) _T("\n"));

    CREATE_HEAP (g_hSendRecvCtxtHeap)
    CREATE_HEAP (g_hAcceptCtxtHeap)
    CREATE_HEAP (g_hCbridgeListEntryHeap)
    CREATE_HEAP (g_hDefaultEventMgrHeap)
    CREATE_HEAP (g_hCallBridgeHeap)
    CREATE_HEAP (g_hEventMgrCtxtHeap)


#undef  CREATE_HEAP
#endif

    return TRUE;
}

// equivalent to DLL_PROCESS_DETACH
EXTERN_C void H323ProxyCleanupModule (void)
{
    Debug (_T("H323: DLL_PROCESS_DETACH\n"));

//    H323ASN1Shutdown();

#if DBG
#define DESTROY_HEAP(Heap) if (Heap) { HeapDestroy (Heap); Heap = NULL; }

    DESTROY_HEAP (g_hSendRecvCtxtHeap)
    DESTROY_HEAP (g_hAcceptCtxtHeap)
    DESTROY_HEAP (g_hCbridgeListEntryHeap)
    DESTROY_HEAP (g_hDefaultEventMgrHeap)
    DESTROY_HEAP (g_hCallBridgeHeap)
    DESTROY_HEAP (g_hEventMgrCtxtHeap)

#undef  DESTROY_HEAP
#endif

}

// The values from the registry are read into the
// following global varialbes.

DWORD   g_RegTraceFlags     = LOG_TRCE;         // default trace level until the registry keys are read

static void PxQueryRegistry (void)
{
    HKEY    Key;
    HRESULT Result;

    Result = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE, H323ICS_SERVICE_PARAMETERS_KEY_PATH,
        0, KEY_READ, &Key);

    if (Result == ERROR_SUCCESS) {
        // -XXX- maybe read something???

        Result = RegQueryValueDWORD (Key, H323ICS_REG_VAL_TRACE_FLAGS, &g_RegTraceFlags);

        if (Result != ERROR_SUCCESS) {
            g_RegTraceFlags = LOG_TRCE;
        }

        RegCloseKey (Key);
    }
    else {
        g_RegTraceFlags = DEFAULT_TRACE_FLAGS;
    }

    // dump loaded / default parameters
}

/*++

Routine Description:

    This function initializes all the components and starts
    the thread pool.
    This function is called by the main() function.

Arguments:
    
    None.

Return Values:

    Returns S_OK in case of success or an error in case of failure.

--*/

// internval version of DLL entry point
static HRESULT H323ProxyStartServiceInternal (void)
{
    WSADATA     WsaData;
    HRESULT     Result;
    DWORD       Status;

    // Initialize the heaps first
    // These heaps will be used by other initialization functions

#if DBG

    if (!(g_hSendRecvCtxtHeap
        && g_hAcceptCtxtHeap
        && g_hCbridgeListEntryHeap
        && g_hDefaultEventMgrHeap
        && g_hCallBridgeHeap
        && g_hEventMgrCtxtHeap)) {

        Debug (_T("H323: failed to create one or more heaps -- cannot start\n"));
        return E_OUTOFMEMORY;
    }

#endif

    PxQueryRegistry();
 
    // Initialize WinSock
    Status = WSAStartup (MAKEWORD (2, 0), &WsaData);
    if (Status != ERROR_SUCCESS)
    {
        DBGOUT((LOG_FAIL, "WSAStartup Failed error"));
        DumpError (Status);

        return HRESULT_FROM_WIN32 (Status);
    }
   
    /*
    Result = InitCrvAllocator();
    if (FAILED(Result)) {
        DBGOUT((LOG_FAIL, "InitCrvAllocator() failed, error: %x", Result));
        return Result;
    }
    */

    // initialize NAT
    Status = NatInitializeTranslator(&g_NatHandle);
    if (Status != STATUS_SUCCESS) {
        DebugError (Status, _T("H323: NatInitializeTranslator failed"));
        Result = (HRESULT) Status;
        return Result;
    }

    /*
    
    Result = H323ProxyStart ();
    if (FAILED (Result)) {
        DBGOUT((LOG_FAIL, "H323ProxyStart() failed, error %x", Result ));
        return Result;
    }

    */
    Result = LdapProxyStart ();
    if (FAILED (Result)) {
        DBGOUT((LOG_FAIL, "LdapProxyStart() failed, error %x", Result ));
        return Result;
    } 

    return S_OK;
}

// module entry point
EXTERN_C ULONG H323ProxyStartService (void)
{
    HRESULT     Result;

    Debug (_T("H323: starting...\n"));

    Result = H323ProxyStartServiceInternal();

    if (Result == S_OK) {
        DBGOUT ((LOG_INFO, "H323: ICS proxy has initialized successfully\n"));
    }
    else {
        DebugError (Result, _T("H323: ICS proxy has FAILED to initialize\n"));
        H323ProxyStopService();
    }

    return (ULONG) Result;
}


// module entry point
EXTERN_C ULONG H323ProxyActivateInterface (
    ULONG Index,
    PIP_ADAPTER_BINDING_INFO BindingInfo)
{
    ULONG Error;
    LONG InitialInterfaceIndex;

    DBGOUT ((LOG_TRCE, "H323: ActivateInterface called, index %d\n",
        Index));

    if (!BindingInfo->AddressCount ||
        !BindingInfo->Address[0].Address) {

        Error = ERROR_INVALID_PARAMETER;
    
    } else {
        
        InitialInterfaceIndex = InterlockedCompareExchange (
                                    (PLONG)&g_PrivateInterfaceIndex, 
                                    (LONG) Index,
                                    (LONG) INVALID_INTERFACE_INDEX);

        if (InitialInterfaceIndex == INVALID_INTERFACE_INDEX) {      
        
            HRESULT Result;

            RasSharedScopeAddress = ntohl (BindingInfo -> Address[0].Address);
            RasSharedScopeMask = ntohl (BindingInfo -> Address[0].Mask);
            g_PrivateInterfaceAddress.s_addr = BindingInfo -> Address[0].Address;
            
            DBGOUT ((LOG_TRCE, "H323: Private interface address %08X",
                ntohl (g_PrivateInterfaceAddress.s_addr)));

            Result = PortPoolStart();
        
            if (FAILED(Result)) {

                DebugError (Result, _T("H323: PortPoolStart failed.\n"));
                Error = ERROR_CAN_NOT_COMPLETE;
        
            } else {
                                      
                Result = ERROR_SUCCESS; /*H323Activate ();*/
            
                if (FAILED (Result)) {

                    DebugError (Result, _T("H323: H323Activate() failed.\n"));
                    Error = ERROR_CAN_NOT_COMPLETE;
            
                } else {
              
                    Result = LdapActivate ();
                
                    if (FAILED(Result)) {

                        DebugError (Result, _T("H323: LdapActivate() failed.\n"));
                        Error = ERROR_CAN_NOT_COMPLETE;
                
                    } else { 

                        Error = ERROR_SUCCESS;
                
                    }
                }
            }
        } else {

            Error = ERROR_INTERFACE_ALREADY_EXISTS;
        }
    }

    return Error;
}

// module entry point
EXTERN_C VOID H323ProxyDeactivateInterface (
    ULONG Index)
{
    DBGOUT ((LOG_TRCE, "H323: DeactivateInterface called, index %d\n",
        Index));
    
    if (g_PrivateInterfaceIndex == Index) {
            
//      H323Deactivate ();

        LdapDeactivate ();

        g_PrivateInterfaceIndex = INVALID_INTERFACE_INDEX;
    }
}

// module entry point
EXTERN_C void H323ProxyStopService (void)
{
    assert (g_PrivateInterfaceIndex == INVALID_INTERFACE_INDEX);

//  H323ProxyStop ();

    LdapProxyStop ();

    PortPoolStop ();

    if (g_NatHandle) {
        NatShutdownTranslator (g_NatHandle);
        g_NatHandle = NULL;
    }

//  CleanupCrvAllocator ();

    WSACleanup ();

    LdapSyncCounter.Stop ();

    PxSyncCounter.Stop ();
 
    Debug (_T("H323: service has stopped\n"));
}

static void WINAPI EventMgrIoCompletionCallback (
    IN  DWORD           Status,
    IN  DWORD           BytesTransferred,
    IN  LPOVERLAPPED    Overlapped)
{
    PIOContext  IoContext;
    
    IoContext = (PIOContext) Overlapped;

    CALL_BRIDGE& CallBridge = IoContext->pOvProcessor->GetCallBridge();

    switch (IoContext -> reqType) {

        case EMGR_OV_IO_REQ_ACCEPT:

            DBGOUT ((LOG_VERBOSE, "----- Completing Accept for 0x%x - 0x%x",
                &IoContext -> pOvProcessor->GetCallBridge(),
                IoContext));

            HandleAcceptCompletion ((PAcceptContext) IoContext, Status);
            
            break;

        case EMGR_OV_IO_REQ_SEND:
            
            DBGOUT ((LOG_VERBOSE, "----- Completing Send for 0x%x - 0x%x",
                &IoContext -> pOvProcessor->GetCallBridge(),
                IoContext));

            HandleSendCompletion ((PSendRecvContext) IoContext, BytesTransferred, Status);
            
            break;

        case EMGR_OV_IO_REQ_RECV:

            DBGOUT ((LOG_VERBOSE, "----- Completing Receive for 0x%x - 0x%x",
                &IoContext -> pOvProcessor->GetCallBridge(),
                IoContext));
            
            HandleRecvCompletion ((PSendRecvContext) IoContext, BytesTransferred, Status);
        
            break;

        default:
            // XXX This should never happen
            DBGOUT((LOG_FAIL, "Unknown I/O completed: %d\n", IoContext -> reqType));
            _ASSERTE(0);
            break;
    
    }

    CallBridge.Release ();
}


HRESULT EventMgrBindIoHandle (SOCKET sock)
{
    DWORD Result; 

    if (BindIoCompletionCallback ((HANDLE) sock, EventMgrIoCompletionCallback, 0))
        return S_OK;
    else {
        Result = GetLastError ();
        DBGOUT ((LOG_FAIL, "EventMgrBindIoHandle: failed to bind i/o completion callback"));
        return HRESULT_FROM_WIN32 (Result);
    }
}

// TIMER_PROCESSOR ------------------------------------------------------------------

/*
 * This function is passed as the callback in the 
 * CreateTimerQueueTimer() function
 */
// static
void WINAPI TimeoutCallback (
    IN  PVOID   Context,
    IN  BOOLEAN TimerFired)
{
 
    TIMER_PROCESSOR *pTimerProcessor = (TIMER_PROCESSOR *) Context;

    pTimerProcessor->TimerCallback();

    // At this point the timer would have been canceled because
    // this is a one shot timer (no period)
}

/*++

Routine Description:

    Create a timer.
    
Arguments:
    
Return Values:
    if Success the caller should increase the ref count.
    
--*/

DWORD TIMER_PROCESSOR::TimprocCreateTimer (
    IN  DWORD   TimeoutValue)
{
    HRESULT Result;

    if (m_TimerHandle) {
        
        DBGOUT ((LOG_FAIL, "TIMER_PROCESSOR::TimprocCreateTimer: timer is already pending, cannot create new timer\n"));
        
        return E_FAIL;
    }

    IncrementLifetimeCounter ();

    if (CreateTimerQueueTimer(&m_TimerHandle,
                               NATH323_TIMER_QUEUE,
                               TimeoutCallback,
                               this,
                               TimeoutValue,
                               0,                    // One shot timer
                               WT_EXECUTEINIOTHREAD)) {

        assert (m_TimerHandle);

        Result = S_OK;
    }
    else {

        Result = GetLastResult();

        DecrementLifetimeCounter ();

        DebugLastError (_T("TIMER_PROCESSOR::TimprocCreateTimer: failed to create timer queue timer\n"));
    }

    return Result;
}

/*++

Routine Description:

    Cancel the timer if there is one. Otherwise simply return.
    
Arguments:
    
Return Values:
  
--*/
// if (err == STATUS_PENDING)

// If Canceling the timer fails this means that the
// timer callback could be pending. In this scenario,
// the timer callback could execute later and so we
// should not release the refcount on the TIMER_CALLBACK
// The refcount will be released in the TimerCallback().

// Release the ref count if the error is anything other
// than that a callback is pending.
// BUGBUG: What is the exact error code ?
// if (err != STATUS_PENDING) m_pCallBridge->Release();
DWORD TIMER_PROCESSOR::TimprocCancelTimer (void) {

    HRESULT HResult = S_OK;

    if (m_TimerHandle != NULL) {

        if (DeleteTimerQueueTimer(NATH323_TIMER_QUEUE, m_TimerHandle, NULL)) {

            DBGOUT ((LOG_TRCE, "TIMER_PROCESSOR:: TimprocCancelTimer - Timer &%x is deleted.", this));

            DecrementLifetimeCounter ();
        }
        else {

            HResult = GetLastError ();
            
            DBGOUT ((LOG_TRCE, "TIMER_PROCESSOR::TimprocCancelTimer: Error %d deleting timer &%x.", HResult, this));
        }

        m_TimerHandle = NULL;  
    }

    return HResult;
}



int __cdecl
main(
    int argc,
    char* argv[]
    )
{
    #define JUNKBUFSIZE  5000
    
    HRESULT     Result;
    ULONG Error;
    PIP_ADAPTER_BINDING_INFO pAdapterInfo = NULL;
    char buf[JUNKBUFSIZE] = {0};
    char buf2[JUNKBUFSIZE] = {0};
    ULONG sizeofbuf = JUNKBUFSIZE;
    PMIB_IPADDRTABLE pMib;
    ULONG IpAddress;
    ULONG NetMask;


    H323ProxyInitializeModule();

    Result = H323ProxyStartService();

    if (FAILED (Result)) {
        printf("H323ProxyStartService() failed, error %x", Result );
        return Result;
    }

    //
    // Figure out the ip addr of interface on this machine.
    // BugBug: What if there are many interfaces/Ips?
    //

    Error = GetIpAddrTable( (PMIB_IPADDRTABLE ) buf,
                            &sizeofbuf,
                            TRUE
                            );

    if (Error != ERROR_SUCCESS) {
        printf("GetIpAddrTable failed, error %x", Error );
        return Error;
    }

    //    printf("IP buffer size is %d\n", sizeofbuf);

    if (!sizeofbuf) {

        printf("No IPs returned\n");
        return -1;
    }

    pMib = (PMIB_IPADDRTABLE) buf;
    
    printf("Number of IPs: %d\n", pMib->dwNumEntries); 

    pAdapterInfo = (PIP_ADAPTER_BINDING_INFO) buf2;
    pAdapterInfo->AddressCount = 1;
    pAdapterInfo->Address[0].Address = pMib->table[0].dwAddr;
    pAdapterInfo->Address[0].Mask = pMib->table[0].dwMask;

    struct in_addr junk;

    junk.S_un.S_addr = pAdapterInfo->Address[0].Address;
    printf("Selected IP to bind is %s\t\t",inet_ntoa( junk ));
    
    junk.S_un.S_addr = pAdapterInfo->Address[0].Mask;
    printf("Mask is %s\n",inet_ntoa( junk ));
    
    //
    // Activate the interface.
    //

    Error = H323ProxyActivateInterface( pMib->table[0].dwIndex, pAdapterInfo );

    if (Error != ERROR_SUCCESS) {
        printf("H323ProxyActivateInterface() failed, error %x", Error );
        return Result;
    }

    fprintf(stderr,"\nHit any key to stop LDAP proxy. . .\n");
    getchar();

    H323ProxyDeactivateInterface( pMib->table[0].dwIndex );

    H323ProxyStopService();
    H323ProxyCleanupModule();

    fprintf(stderr,"LDAP proxy stopped. . .\n");

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\portmgmt.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    portmgmt.h

Abstract:

    Port pool management functions

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _portmgmt_h_
#define _portmgmt_h_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT	PortPoolStart	(void);
void	PortPoolStop	(void);

HRESULT PortPoolAllocRTPPort (
	OUT	WORD *	ReturnPort);

HRESULT PortPoolFreeRTPPort (
	IN	WORD	RtpPort);

#endif //_portmgmt_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\portmgmt.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    portmgmt.cpp

Abstract:

    Functions for allocating and freeing ports from the Port pool

        PortPoolAllocRTPPort()
	PortPoolFreeRTPPort()

Environment:

    User Mode - Win32

--*/


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Functions dealing with the TCP device to reserve/unreserve port ranges.   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"


#define NUM_DWORD_BITS (sizeof(DWORD)*8)


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define NUM_PORTS_PER_RANGE 100

struct	PORT_RANGE
{
	LIST_ENTRY		ListEntry;

    // This is the actual lower port. In case, the range allocated
    // by TCP starts with an odd port, we ignore the first port in
    // which case (low == AllocatedLow + 1). But when we free the
    // port range we should pass in AllocatedLow and not low.
    WORD  AllocatedLow;
    WORD  low;

    // high is the last port we can use and not the allocated high.
    // In some cases high will be one less than the actual allocated high.
    WORD  high;

    //Each bit in this bitmap indicates the status of 2 consecutive ports 

    DWORD *AllocList;
    DWORD dwAllocListSize;
};




class	PORT_POOL :
public	SIMPLE_CRITICAL_SECTION_BASE
{
private:
	HANDLE		TcpDevice;
	LIST_ENTRY	PortRangeList;		// contains PORT_RANGE.ListEntry

private:
	HRESULT		OpenTcpDevice	(void);
	HRESULT		StartLocked		(void);
	void		FreeAll			(void);

	HRESULT	CreatePortRange (
		OUT	PORT_RANGE **	ReturnPortRange);

	HRESULT	ReservePortRange (
		IN  ULONG	RangeLength,
		OUT WORD *	ReturnStartPort);

	HRESULT	UnReservePortRange (
		IN	WORD	StartPort);


public:

	PORT_POOL	(void);
	~PORT_POOL	(void);

	HRESULT		Start	(void);
	void		Stop	(void);

	HRESULT		AllocPort (
		OUT	WORD *	ReturnPort);

	void		FreePort (
		IN	WORD	Port);
};

// global data -------------------------------------------------------------------------

static	PORT_POOL	PortPool;

// extern code -----------------------------------------------------------------------

HRESULT PortPoolStart (void)
{
	return PortPool.Start();
}

void PortPoolStop (void)
{
	PortPool.Stop();
}

HRESULT PortPoolAllocRTPPort (
	OUT	WORD *	ReturnPort)
{
	return PortPool.AllocPort (ReturnPort);
}

HRESULT PortPoolFreeRTPPort (
	IN	WORD	Port)
{
	PortPool.FreePort (Port);

	return S_OK;
}





HRESULT PORT_POOL::ReservePortRange (
	IN  ULONG	RangeLength,
    OUT WORD *	ReturnStartPort)
{
    TCP_BLOCKPORTS_REQUEST	PortRequest;
    DWORD	BytesTransferred;
    ULONG	StartPort;

	AssertLocked();

    *ReturnStartPort = 0;

	if (!TcpDevice) {
		Debug (_T("H323: cannot allocate port range, TCP device could not be opened\n"));
		return E_UNEXPECTED;
	}

	assert (TcpDevice != INVALID_HANDLE_VALUE);

    PortRequest.ReservePorts = TRUE;
    PortRequest.NumberofPorts = RangeLength;
    
    if (!DeviceIoControl (TcpDevice, IOCTL_TCP_BLOCK_PORTS,
		&PortRequest, sizeof PortRequest,
		&StartPort, sizeof StartPort, 
		&BytesTransferred, NULL)) {

		DebugLastError (_T("H323: failed to allocate TCP port range\n"));
        return GetLastError();
    }

	DebugF (_T("H323: reserved TCP port range: [%u - %u)\n"),
		StartPort, StartPort + PortRequest.NumberofPorts);

    *ReturnStartPort = (WORD) StartPort;
    return S_OK;
}



HRESULT PORT_POOL::UnReservePortRange (
	IN	WORD	StartPort)
{
	TCP_BLOCKPORTS_REQUEST	PortRequest;
	DWORD	BytesTransferred;
	DWORD	Status;

	AssertLocked();

	if (!TcpDevice) {
		Debug (_T("H323: cannot free TCP port range, TCP device is not open\n"));
		return E_UNEXPECTED;
	}

	assert (TcpDevice != INVALID_HANDLE_VALUE);

	PortRequest.ReservePorts = FALSE;
	PortRequest.StartHandle = (ULONG) StartPort;
    
	if (!DeviceIoControl(TcpDevice, IOCTL_TCP_BLOCK_PORTS,
		&PortRequest, sizeof PortRequest,
		&Status, sizeof Status,
		&BytesTransferred, NULL)) {

		DebugLastError (_T("H323: failed to free TCP port range\n"));

		return GetLastError();
    }

    return S_OK;
}




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Port Pool Functions.                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



// PORT_POOL -----------------------------------------------------------------------

PORT_POOL::PORT_POOL (void)
{
	TcpDevice = NULL;
	InitializeListHead (&PortRangeList);
}

PORT_POOL::~PORT_POOL (void)
{
	assert (!TcpDevice);
	assert (IsListEmpty (&PortRangeList));
}

HRESULT PORT_POOL::Start (void)
{
	HRESULT		Result;

	Lock();

	Result = OpenTcpDevice();

	Unlock();

	return Result;
}

HRESULT PORT_POOL::OpenTcpDevice (void)
{
    UNICODE_STRING		DeviceName;
    IO_STATUS_BLOCK		IoStatusBlock;
    OBJECT_ATTRIBUTES	ObjectAttributes;
    NTSTATUS			Status;

	if (TcpDevice)
		return S_OK;

    RtlInitUnicodeString (&DeviceName, (PCWSTR) DD_TCP_DEVICE_NAME);

	InitializeObjectAttributes (&ObjectAttributes, &DeviceName,
		OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = NtCreateFile (
		&TcpDevice,
		SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA ,
		&ObjectAttributes,
		&IoStatusBlock,
		NULL,
		FILE_ATTRIBUTE_NORMAL,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		FILE_OPEN_IF, 0, NULL, 0);

    if (Status != STATUS_SUCCESS) {
		TcpDevice = NULL;

		DebugError (Status, _T("H323: failed to open TCP device, cannot allocate port blocks\n"));

		return (HRESULT) Status;
    }

    return S_OK;
}

void PORT_POOL::Stop (void)
{
	Lock();

	FreeAll();

	if (TcpDevice) {
		assert (TcpDevice != INVALID_HANDLE_VALUE);

		CloseHandle (TcpDevice);
		TcpDevice = NULL;
	}
    
	Unlock();
}

void PORT_POOL::FreeAll (void)
{
	LIST_ENTRY *	ListEntry;
    PORT_RANGE *	PortRange;

	while (!IsListEmpty (&PortRangeList)) {
		ListEntry = RemoveHeadList (&PortRangeList);
		PortRange = CONTAINING_RECORD (ListEntry, PORT_RANGE, ListEntry);

        // Free the port range PortRange->AllocatedLow
        UnReservePortRange (PortRange -> AllocatedLow);
        EM_FREE (PortRange);
    }
}

/*++

Routine Description:

    This function allocates a pair of RTP/RTCP ports from the 
    port pool.

Arguments:
    
    rRTPport - This is an OUT parameter. If the function succeeds
        rRTPport will contain the RTP port (which is even).
        rRTPport+1 should be used as the RTCP port.
        
Return Values:

    This function returns S_OK on success and E_FAIL if it
    fails to allocate a port range.

--*/

HRESULT PORT_POOL::AllocPort (
	OUT	WORD *	ReturnPort)
{
    DWORD i, j;
    DWORD bitmap = 0x80000000;
	LIST_ENTRY *	ListEntry;
    PORT_RANGE *	PortRange;
	WORD			Port;
	HRESULT			Result;

    Lock();

	for (ListEntry = PortRangeList.Flink; ListEntry != &PortRangeList; ListEntry = ListEntry -> Flink) {
		PortRange = CONTAINING_RECORD (ListEntry, PORT_RANGE, ListEntry);

        for (i = 0; i < PortRange->dwAllocListSize; i++) {

            // traverse through AllocList of this portRange

            if ((PortRange->AllocList[i] & 0xffffffff) != 0xffffffff) {
				// at least one entry is free
				bitmap = 0x80000000;
            
				for (j = 0; j < NUM_DWORD_BITS; j++) {
					// traverse through each bit of the DWORD
					if ((PortRange->AllocList[i] & bitmap) == 0)
					{
						// found a free pair of ports
						Port = (WORD) (PortRange -> low + (i*NUM_DWORD_BITS*2) + (j*2));

						if (Port > PortRange -> high) {
							// This check is needed because the last DWORD
							// in the AllocList may contain bits which are
							// actually not included in the AllocList. 
							goto noports;
						}

						// set the bit to show the pair of ports is allocated
						PortRange -> AllocList[i] |= bitmap;
                    
						// Leave the global critical section for the Port pool 
						Unlock();

						DebugF (_T("H323: allocated RTP port pair (%u, %u)\n"), Port, Port + 1);

						*ReturnPort = Port;

						return S_OK;
					}

					bitmap = bitmap >> 1;
				}
            }
        }
    }
    
noports:
    // CODEWORK: Once we get the new ioctl() for dynamically reserving
    // port ranges, we need to allocate a new port range here. If the
    // ioctl() fails we need to return E_FAIL or another error which
    // says we have run out of ports.

    // Allocate a new port range
    Result = CreatePortRange (&PortRange);

	if (PortRange) {
		InsertHeadList (&PortRangeList, &PortRange -> ListEntry);

		// allocate the first port in the range and 
		Port = PortRange -> low;
		PortRange->AllocList[0] |= 0x80000000;

		DebugF (_T("H323: allocated RTP port pair (%u, %u)\n"),
			Port, Port + 1);

		*ReturnPort = Port;
		Result = S_OK;
	}
	else {
		Debug (_T("H323: failed to allocate port range, so cannot allocate RTP port\n"));

		*ReturnPort = 0;
		Result = E_FAIL;
    }

	Unlock();

	return Result;

}


/*++

Routine Description:

    This function frees a pair of RTP/RTCP ports.
    The data structure is changed to show that the pair of ports
    is now available.

    CODEWORK: If an entire port range becomes free, do we release
    the port range to the operating system ? We probably need a
    heuristic to do this because allocating a port range again
    could be an expensive operation.

Arguments:
    
    wRTPport - This gives the RTP port to be freed.
        (RTCP port is RTPport+1 which is implicitly freed because
	 we use one bit store the status of both these ports.)

Return Values:

    Returns S_OK on success or E_FAIL if the port is not found in
    the port pool list.

--*/

void PORT_POOL::FreePort (
	IN	WORD	Port)
{
	HRESULT		Result;

    // assert RTP port is even
    _ASSERTE ((Port & 1) == 0);

    DWORD	Index = 0;
    DWORD	Bitmap = 0x80000000;

	LIST_ENTRY *	ListEntry;
    PORT_RANGE *	PortRange;

	Lock();

	// find the port range that this port belongs to
	// simple linear scan -- suboptimal

	Result = E_FAIL;

	for (ListEntry = PortRangeList.Flink; ListEntry != &PortRangeList; ListEntry = ListEntry -> Flink) {
		PortRange = CONTAINING_RECORD (ListEntry, PORT_RANGE, ListEntry);

		if (PortRange -> low <= Port && PortRange -> high >= Port) {
			Result = S_OK;
			break;
		}
    }
    
	if (Result == S_OK) {
		Index = (Port - PortRange -> low) / (NUM_DWORD_BITS * 2);
    
		// assert index is less than the size of the array
		_ASSERTE (Index < PortRange -> dwAllocListSize);

		// CODEWORK: make sure that the bit is set i.e. the port has
		// been previously allocated. Otherwise return an error and print
		// a warning.
    
		// zero the bit to show the pair of ports is now free

		PortRange -> AllocList [Index] &=
			~(Bitmap >> (((Port - PortRange -> low) / 2) % NUM_DWORD_BITS));
	}
	else {
		DebugF (_T("H323: warning, attempted to free RTP port %u, but port did not belong to any port range\n"));
	}

	Unlock();
}

HRESULT PORT_POOL::CreatePortRange (
	OUT	PORT_RANGE **	ReturnPortRange)
{
    // CODEWORK: Once we get the new ioctl() for dynamically reserving
    // port ranges, we need to allocate a new port range here. If the
    // ioctl() fails we need to return E_FAIL or another error which
    // says we have run out of ports.

    // assert low is even and high is odd
    // _ASSERTE((low % 2) == 0);
    // _ASSERTE((high % 2) == 1);

    HRESULT			Result;
    WORD			AllocatedLowerPort;
    WORD			LowerPort;
    DWORD			NumPortsInRange;
    PORT_RANGE *	PortRange;
	DWORD			dwAllocListSize;

	assert (ReturnPortRange);
	*ReturnPortRange = NULL;

    Result = ReservePortRange (NUM_PORTS_PER_RANGE, &AllocatedLowerPort);
    if (FAILED (Result))
		return Result;

    // If the allocated lower port is odd we do not use the lower port
    // and the range we use starts with the next higher port.
    if ((AllocatedLowerPort & 1) == 1) {
		// the allocated region is ODD
		// don't use the first entry

        NumPortsInRange = NUM_PORTS_PER_RANGE - 1 - ((NUM_PORTS_PER_RANGE) & 1);
        LowerPort       = AllocatedLowerPort + 1;
    }
    else {
		// the allocated region is EVEN
		// don't use the last entry

        NumPortsInRange = NUM_PORTS_PER_RANGE;
        LowerPort       = AllocatedLowerPort;
    }

    // If NumPortsInRange is odd, we can not use the last port
    if ((NumPortsInRange & 1) == 1)
    {
        NumPortsInRange--;
    }
    
    // Each bit gives the status (free/allocated) of two consecutive
    // ports. So, each DWORD can store the status of NUM_DWORD_BITS*2
    // ports. We add (NUM_DWORD_BITS*2 - 1) to round up the number of
    // DWORDS required.
    dwAllocListSize = (NumPortsInRange + NUM_DWORD_BITS*2 - 1)
		/ (NUM_DWORD_BITS * 2);

    // allocate space for the AllocList also
    // Since we do not anticipate too many port ranges being allocated,
    // we do not require a separate heap for these structures.
	PortRange = (PORT_RANGE *) EM_MALLOC (
		sizeof (PORT_RANGE) + dwAllocListSize * sizeof (DWORD));

    if (PortRange == NULL) {
		Debug (_T("H323: allocation failure, cannot allocate PORT_RANGE and associated bit map\n"));

		UnReservePortRange (AllocatedLowerPort);
        return E_OUTOFMEMORY;
    }

    _ASSERTE((LowerPort + NumPortsInRange - 1) <= 0xFFFF);

    PortRange -> AllocatedLow = AllocatedLowerPort;
    PortRange -> low = LowerPort;
    PortRange -> high = (WORD) (LowerPort + NumPortsInRange - 1);
    PortRange -> dwAllocListSize = dwAllocListSize;
    PortRange -> AllocList = (DWORD *) (PortRange + 1);

	DebugF (_T("H323: allocated new port range, low %u, high %u, AllocListSize %u\n"),
		PortRange -> low,
		PortRange -> high,
		PortRange -> dwAllocListSize);
 
   // Initialize the AllocList to show all the ports are free
    ZeroMemory (PortRange -> AllocList, (PortRange -> dwAllocListSize) * sizeof (DWORD));

	*ReturnPortRange = PortRange;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\q931defs.h ===
#ifndef	__iptel_q931defs_h
#define	__iptel_q931defs_h

// This module contains constants and enumerated types for values used in the Q.931 protocol.
// It does not contain any structures, definitions, or APIs relevant to any implementation.



	// Q931_PROTOCOL_DISCRIMINATOR identifies Q.931 PDUs on links that may carry
	// PDUs from more than one protocol, such as LAPD D-channel links on PRI.
#define	Q931_PROTOCOL_DISCRIMINATOR					0x08

	// the well-known Q.931 TSAP for TCP on IP is TCP port 1720
#define	Q931_TSAP_IP_TCP							1720
#define	Q931_TSAP_IP_TCP_SECURE						1300


enum	Q931_MESSAGE_TYPE
{
	// Call Establishment Message (000-----)
	Q931_MESSAGE_TYPE_ALERTING				= 0x01,
	Q931_MESSAGE_TYPE_CALL_PROCEEDING		= 0x02,
	Q931_MESSAGE_TYPE_CONNECT				= 0x07,
	Q931_MESSAGE_TYPE_CONNECT_ACKNOWLEDGE	= 0x0F,
	Q931_MESSAGE_TYPE_PROGRESS				= 0x03,
	Q931_MESSAGE_TYPE_SETUP					= 0x05,
	Q931_MESSAGE_TYPE_SETUP_ACKNOWLEDGE		= 0x0E,
	Q931_MESSAGE_TYPE_FACILITY				= 0x1C,

	// Call Information Phase message (001-----)
	Q931_MESSAGE_TYPE_RESUME				= 0x26,
	Q931_MESSAGE_TYPE_RESUME_ACKNOWLEDGE	= 0x2E,
	Q931_MESSAGE_TYPE_RESUME_REJECT			= 0x22,
	Q931_MESSAGE_TYPE_SUSPEND				= 0x25,
	Q931_MESSAGE_TYPE_SUSPEND_ACKNOWLEDGE	= 0x2D,
	Q931_MESSAGE_TYPE_SUSPEND_REJECT		= 0x21,
	Q931_MESSAGE_TYPE_USER_INFORMATION		= 0x20,

	// Call Clearing Messages (010-----)
	Q931_MESSAGE_TYPE_DISCONNECT			= 0x45,
	Q931_MESSAGE_TYPE_RELEASE				= 0x4D,
	Q931_MESSAGE_TYPE_RELEASE_COMPLETE		= 0x5A,
	Q931_MESSAGE_TYPE_RESTART				= 0x46,
	Q931_MESSAGE_TYPE_RESTART_ACKNOWLEDGE	= 0x4E,
	
	// Miscellaneous Message (011-----)
	Q931_MESSAGE_TYPE_SEGMENT				= 0x60,
	Q931_MESSAGE_TYPE_CONGESTION_CONTROL	= 0x79,
	Q931_MESSAGE_TYPE_INFORMATION			= 0x7B,
	Q931_MESSAGE_TYPE_NOTIFY				= 0x6E,
	Q931_MESSAGE_TYPE_STATUS				= 0x7D,
	Q931_MESSAGE_TYPE_STATUS_ENQUIRY		= 0x75,
};


enum	Q931_IE_IDENTIFIER
{
	// Single-Octet Information Elements
	Q931_IE_SHIFT							= 0x90,		// 1001----
	Q931_IE_RESERVED						= 0x80,		// 1000----
	Q931_IE_MORE_DATA						= 0xA0,		// 11000000
	Q931_IE_SENDING_COMPLETE				= 0xA1,		// 11000001
	Q931_IE_CONGESTION_CONTROL				= 0xB0,		// 1011----
	Q931_IE_REPEAT_INDICATOR				= 0xD0,		// 1101----

	// Variable-Length Information Elements
	Q931_IE_SEGMENTED_MESSAGE				= 0x00,
	Q931_IE_BEARER_CAPABILITY				= 0x04,
	Q931_IE_CAUSE							= 0x08,
	Q931_IE_CALL_IDENTITIY					= 0x10,
	Q931_IE_CALL_STATE						= 0x14,
	Q931_IE_CHANNEL_IDENTIFICATION			= 0x18,
	Q931_IE_PROGRESS_INDICATOR				= 0x1E,
	Q931_IE_NETWORK_SPECIFIC_FACILITIES		= 0x20,
	Q931_IE_NOTIFICATION_INDICATOR			= 0x27,
	Q931_IE_DISPLAY							= 0x28,
	Q931_IE_DATE_TIME						= 0x29,
	Q931_IE_KEYPAD_FACILITY					= 0x2A,
	Q931_IE_SIGNAL							= 0x34,
	Q931_IE_INFORMATION_RATE				= 0x40,
	Q931_IE_END_TO_END_TRANSIT_DELAY		= 0x42,
	Q931_IE_TRANSIT_DELAY_SELECTION			= 0x43,
	Q931_IE_PACKET_LAYER_BINARY_PARAMETERS	= 0x44,
	Q931_IE_PACKET_LAYER_WINDOW_SIZE		= 0x45,
	Q931_IE_PACKET_SIZE						= 0x46,
	Q931_IE_CLOSED_USER_GROUP				= 0x47,
	Q931_IE_REVERSE_CHARGE_INDICATION		= 0x4A,
	Q931_IE_CALLING_PARTY_NUMBER			= 0x6A,
	Q931_IE_CALLING_PARTY_SUBADDRESS		= 0x6B,
	Q931_IE_CALLED_PARTY_NUMBER				= 0x70,
	Q931_IE_CALLED_PARTY_SUBADDRESS			= 0x71,
	Q931_IE_REDIRECTING_NUMBER				= 0x74,
	Q931_IE_TRANSIT_NETWORK_SELECTION		= 0x78,
	Q931_IE_RESTART_INDICATOR				= 0x79,
	Q931_IE_LOW_LAYER_COMPATIBILITY			= 0x7C,
	Q931_IE_HIGH_LAYER_COMPATIBILITY		= 0x7D,
	Q931_IE_USER_TO_USER					= 0x7E,
	Q931_IE_ESCAPE_FOR_EXTENSION			= 0x7F,
};

enum	Q931_UUIE_TYPE
{
	Q931_UUIE_USER_SPECIFIC					= 0x00,
	Q931_UUIE_OSI							= 0x01,
	Q931_UUIE_X244							= 0x02,
	Q931_UUIE_IA5_TEXT						= 0x04,
	Q931_UUIE_X208							= 0x05,
	Q931_UUIE_V120_RATE_ADAPTION			= 0x07,
	Q931_UUIE_UNI_CALL_CONTROL				= 0x08,
};

#endif // __iptel_q931defs_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\q931io.h ===
#ifndef	__h323ics_q931io_h
#define	__h323ics_q931io_h



// this module DOES make use of the global sync counter (PxSyncCounter)
// declared in main.h


HRESULT	H323ProxyStart		(void);
void	H323ProxyStop		(void);
HRESULT H323Activate        (void);
void    H323Deactivate      (void);

#endif // __h323ics_q931io_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\q931msg.h ===
#ifndef	__iptel_q931msg_h
#define	__iptel_q931msg_h

// To use the Q931_MESSAGE class:
//
// To decode Q.931 PDUs:
//
//		Create an instance of the Q931_MESSAGE class.
//		Call the AssignDecodePdu method, supplying the buffer and length of the PDU data.
//			If the AssignDecodePdu succeeds, then the buffer is now "bound" to the
//			Q931_MESSAGE instance.  You may then examine the elements of Q931_MESSAGE:
//
//				MessageType - The type of Q.931 PDU received (Setup, etc.)
//				CallReferenceValue
//				InfoElementArray - An ordered array of IEs that were in the PDU
//				UserInformation - If an ASN.1 UUIE was present, this field will be non-NULL
//
//			You may also use the FindInfoElement method to locate a specific IE (cause code, etc.)
//
//		When you are done using the contents of the Q931_MESSAGE instance, you must call the
//		FreeAll method.  This destroys the association between the buffer and the Q931_MESSAGE class.
//		This step MUST be performed before destroying the instance of the Q931_MESSAGE class.
//
//
// To encode Q.931 PDUs:
//
//		Create an instance of the Q931_MESSAGE class.
//		Set the MessageType and CallReferenceValue fields.
//		For each IE that should be encoded, call AppendInfoElement.
//		(This includes the UUIE.)
//		Call EncodePdu.  The buffer on return contains the fully encoded PDU.
//
//		If the buffer supplied to EncodePdu is not long enough, then the ReturnLength
//		parameter will contain the required length, and the method will return
//		HRESULT_FROM_WIN32 (ERROR_MORE_DATA).
//
// When calling InsertInfoElement, you must insure that the buffer supplied in the
// Q931_IE structure is still valid when the EncodePdu call is made.  All IE buffers
// should remain valid until the Q931_MESSAGE::FreeAll method is called.



#include "q931defs.h"
#include "dynarray.h"

struct	H323_UserInformation;

struct	Q931_ENCODE_CONTEXT;

struct	Q931_BEARER_CAPABILITY
{
};

// Q931_IE_DATA contains the decoded contents of those information elements whose
// interpretation is known and implemented in this module.
// Not all IEs are supported.

union	Q931_IE_DATA
{
	// Q931_IE_USER_TO_USER
	struct	{
		Q931_UUIE_TYPE			Type;
		H323_UserInformation *	PduStructure;
		BOOL					IsOwner;		// if true, delete PduStructure on deletion
	}	UserToUser;

	// Q931_IE_CAUSE
	DWORD	CauseCode;

	// Q931_BEARER_CAPABILITY
	Q931_BEARER_CAPABILITY	BearerCapability;

	// Q931_DISPLAY
	struct	{
		LPSTR		String;
	}	Display;

	// IEs that are not implemented here, and are of variable length
	struct	{
		LPBYTE	Data;
		DWORD	Length;
	}	UnknownVariable;

	// IEs that are not implemented here, and are of fixed length
	struct	{
		BYTE	Value;
	}	UnknownFixed;
};

struct	Q931_IE
{
	Q931_IE_IDENTIFIER		Identifier;
	Q931_IE_DATA			Data;
};

// it is the responsibility of the user of this object to synchronize access
// and object lifetime.
//
// The Decode method builds the InfoElementArray.  Elements in this array
// may refer to the original buffer passed to Encode.  Therefore, users of
// Q931_MESSAGE::Decode must insure that the original buffer remains accessible
// and does not change, until the user no longer requires the use of this Q931_MESSAGE
// object, or calls Q931_MESSAGE::FreeAll.

struct	Q931_MESSAGE
{
public:

	Q931_MESSAGE_TYPE				MessageType;
	WORD							CallReferenceValue;
	DYNAMIC_ARRAY <Q931_IE>			InfoElementArray;

	LPBYTE							Buffer;
	DWORD							BufferLength;
	BOOL							BufferIsOwner;

private:

	HRESULT	DecodeInfoElement (
		IN OUT	LPBYTE *	Pos,
		IN		LPBYTE		End,
		OUT		Q931_IE *	ReturnInfoElement);

	void	FreeInfoElementArray	(void);

	// ParseInfoElement examines the contents of an IE that has already been decoded
	// (type and length determined), and for known IE types, decodes their contents
	// and assigns to data structures

	HRESULT	ParseIE (
		IN	Q931_IE *		InfoElement);

	HRESULT	ParseIE_UUIE (
		IN	Q931_IE *		InfoElement);

	HRESULT	EncodeIE_UUIE (
		IN	Q931_ENCODE_CONTEXT *	Context,
		IN	Q931_IE *		InfoElement);

	// for those IEs that have attached allocated data, free it

	void	FreeInfoElement (
		IN	Q931_IE *		InfoElement);

	HRESULT	EncodeHeader (
		IN	Q931_ENCODE_CONTEXT *	Context);

	HRESULT	EncodeInfoElement (
		IN	Q931_ENCODE_CONTEXT *	Context,
		IN	Q931_IE *				InfoElement);

	static INT __cdecl CompareInfoElement (const Q931_IE *, const Q931_IE *);

	static INT InfoElementSearchFunc (
		IN	const Q931_IE_IDENTIFIER *	SearchKey,
		IN	const Q931_IE *		Comparand);

public:

	// initializes array and UserInformation
	Q931_MESSAGE	(void);

	// will free the UserInformation field if present
	~Q931_MESSAGE	(void);


	HRESULT	EncodePdu	(
		IN	OUT	LPBYTE		Data,
		IN	OUT	LPDWORD		Length);

	HRESULT	AttachDecodePdu	(
		IN	LPBYTE		Data,
		IN	DWORD		Length,
		IN	BOOL		IsDataOwner);		// if TRUE, Q931_MESSAGE will free on dtor

	void	FreeAll	(void);

	// if Q931_MESSAGE currently has a Buffer, and it owns the Buffer,
	// then it will free it here, using GkHeapFree
	void	Detach	(void);

	// if Q931_MESSAGE currently has a Buffer, regardless of whether it owns the buffer,
	// then it will be returned here
	// returns S_OK if a buffer was returned
	// returns S_FALSE if no buffer was returned, and ReturnBuffer set to null
	HRESULT	Detach	(
		OUT	LPBYTE *	ReturnBuffer,
		OUT	DWORD *		ReturnBufferLength);

	void	SetUserInformation	(
		IN	H323_UserInformation *,
		IN	BOOL	FreeOnDelete);

	// information element manipulation

	HRESULT	AppendInfoElement (
		IN	Q931_IE *		InfoElement);

	HRESULT	DeleteInfoElement (
		IN	Q931_IE_IDENTIFIER	Identifier);

	HRESULT	FindInfoElement	(
		IN	Q931_IE_IDENTIFIER		Identifier,
		OUT	Q931_IE **				ReturnInfoElement);

	void	SortInfoElementArray	(void);

};

DECLARE_SEARCH_FUNC_CAST(Q931_IE_IDENTIFIER, Q931_IE);

#if	DBG

	// in debug builds, this function will take a Q.931 PDU buffer,
	// decode it, re-encode it, verify that the contents match,
	// and attempt to decode the re-encoded PDU.
	// this is good for verifying the integrity of the Q931_MESSAGE class.
void Q931TestDecoder (
	IN	LPBYTE		PduData,
	IN	DWORD		PduLength);

#else

#define	Q931TestDecoder(x,y)		0

#endif


#endif // __iptel_q931msg_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\q931info.h ===
#ifndef __pxsvc_q931_h
#define __pxsvc_q931_h

#include "q931msg.h"
#include "ovioctx.h"
#include "crv.h"

/*---------------------------------------------------
Copyright (c) 1998, Microsoft Corporation
File: q931.h

Purpose: 

    Contains declarations specific to q931 processing that need
    not be present in cbridge.h.

History:

    1. created 
        Byrisetty Rajeev (rajeevb)  26-Aug-1998

---------------------------------------------------*/


// The H.225 spec calls for a 2 byte call reference value
typedef WORD    CALL_REF_TYPE;

// Q931 source side states
enum Q931_SOURCE_STATE
{
    Q931_SOURCE_STATE_NOT_INIT = 0,
    Q931_SOURCE_STATE_INIT,
    Q931_SOURCE_STATE_CON_ESTD,
    Q931_SOURCE_STATE_SETUP_RCVD,
    Q931_SOURCE_STATE_REL_COMP_RCVD
};

// Q931 destination side states
enum Q931_DEST_STATE
{
    Q931_DEST_STATE_NOT_INIT = 0,
    Q931_DEST_STATE_INIT,
    Q931_DEST_STATE_CON_ESTD,
    Q931_DEST_STATE_ARQ_SENT,
    Q931_DEST_STATE_ACF_RCVD,
    Q931_DEST_STATE_CALL_PROC_RCVD,
    Q931_DEST_STATE_ALERTING_RCVD,
    Q931_DEST_STATE_CONNECT_RCVD,
    Q931_DEST_STATE_REL_COMP_RCVD
};

#ifdef DBG
// CODEWORK: Define a static array of strings to use in dbg printfs
// where the array can be indexed by the state.

#endif DBG

// Q931_INFO


class Q931_INFO :
    public OVERLAPPED_PROCESSOR,
    public TIMER_PROCESSOR
{
public:

    inline Q931_INFO();

    inline void Init(
        IN H323_STATE   &H323State
        );

    inline CALL_REF_TYPE GetCallRefVal();

    virtual HRESULT SendCallback(
        IN      HRESULT                 CallbackHResult
        );

    virtual HRESULT ReceiveCallback(
        IN      HRESULT                 CallbackHResult,
        IN      BYTE                   *pBuf,
        IN      DWORD                   BufLen
        );

    // Implementation is provided by SOURCE_Q931_INFO and DEST_Q931_INFO
    virtual HRESULT ReceiveCallback(
        IN      Q931_MESSAGE            *pQ931Message,
        IN      H323_UserInformation     *pH323UserInfo
        ) = 0;
    
    HRESULT CreateTimer(DWORD TimeoutValue);
    
    virtual void TimerCallback();

    HRESULT SendReleaseCompletePdu();

    HRESULT QueueSend(
        IN  Q931_MESSAGE         *pQ931Message,
        IN  H323_UserInformation  *pH323UserInfo
        );
    
    // queue an asynchronous receive call back
    HRESULT QueueReceive();

	void IncrementLifetimeCounter  (void);
	void DecrementLifetimeCounter (void);

protected:

    // call reference value for this call (Q931 portion)
    // A Call Reference Value is generated for each outbound call.
    // The CRV in PDUs corresponding to outbound calls needs to be
    // replaced because the external H.323 endpoint sees the call
    // as coming from the proxy. No CRV replacement is required for inbound
    // calls. But we need to store the CRV so that we can send the
    // CallProceeding/ReleaseComplete PDUs.
    // This variable is initialized when we process the Setup PDU.
    // Note that the Call Reference Value also includes the Call Reference Flag
    // which indicates whether the PDU is sent by the originator (0) or
    // destination (1) of the call.
    // m_CallRefVal always stores the Call Reference Value that we send in
    // the PDUs. So, SOURCE_Q931_INFO CRV will have the CRV flag set (since
    // it sends to the source) and the DEST_Q931_INFO CRV will have this flag
    // zeroed (since it is the source from the destination's point of view.
    CALL_REF_TYPE       m_CallRefVal;
};

inline 
Q931_INFO::Q931_INFO(
    )
    : m_CallRefVal(0)
      //m_TimerHandle(NULL)
{
}

inline void
Q931_INFO::Init(
    IN H323_STATE   &H323State
    )
{
    // initialize the overlaped processor
    OVERLAPPED_PROCESSOR::Init(OPT_Q931, H323State);
}


class SOURCE_Q931_INFO :
    public Q931_INFO
{
public:

    inline SOURCE_Q931_INFO();

    inline void Init(
        IN SOURCE_H323_STATE   &SourceH323State
        );

    inline HRESULT SetIncomingSocket(
        IN	SOCKET			IncomingSocket,
		IN	SOCKADDR_IN *	LocalAddress,
		IN	SOCKADDR_IN *	RemoteAddress);

    inline DEST_Q931_INFO &GetDestQ931Info();

    inline SOURCE_H245_INFO &GetSourceH245Info();

    // TimerValue contains the timer value in seconds, for a timer event
    // to be created when a queued send completes
    HRESULT ProcessDestPDU(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    virtual ~SOURCE_Q931_INFO();

protected:

    Q931_SOURCE_STATE  m_Q931SourceState;

	// this should never be called
    virtual HRESULT AcceptCallback(
        IN	DWORD			Status,
        IN	SOCKET			Socket,
		IN	SOCKADDR_IN *	LocalAddress,
		IN	SOCKADDR_IN *	RemoteAddress);

    virtual HRESULT ReceiveCallback(
        IN      Q931_MESSAGE            *pQ931Message,
        IN      H323_UserInformation    *pH323UserInfo
        );

private:
    
    // processes PDUs when in Q931_SRC_CON_EST state
    HRESULT HandleStateSrcConEstd(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    // handles the release complete PDU - sends it to the
    // destination q931 instance, performs state transition and
    // initiates cleanup
    HRESULT HandleReleaseCompletePDU(
        IN  Q931_MESSAGE             *pQ931Message,
        IN  H323_UserInformation     *pH323UserInfo
        );

    // processes CONNECT PDU forwarded by the dest instance
    HRESULT ProcessConnectPDU(
        IN  Q931_MESSAGE             *pQ931Message,
        IN  H323_UserInformation     *pH323UserInfo
        );
};


inline 
SOURCE_Q931_INFO::SOURCE_Q931_INFO(
    )
    : m_Q931SourceState(Q931_SOURCE_STATE_NOT_INIT)
{
}

inline void
SOURCE_Q931_INFO::Init(
    IN SOURCE_H323_STATE   &SourceH323State
    )
{
    m_Q931SourceState = Q931_SOURCE_STATE_INIT;
    Q931_INFO::Init((H323_STATE &)SourceH323State);
}


// these const values are needed for CRV generation

// max number of random number generations needed to 
// get a low probability of failure. An assumption of max 10^3
// active calls at a time in a space of 2^15 crv values implies
// that we can reach 1 in 10^6 failure prob. in 4 generations
const BYTE MAX_CALL_REF_RAND_GEN = 4;

// number of different CRV values
const WORD TOTAL_CRVS = 0x8000; // 2^15;

// number of bits needed for the crv bit map
const WORD CRV_BIT_MAP_SIZE = (TOTAL_CRVS/8); // (2^15)/8;

class DEST_Q931_INFO :
    public Q931_INFO
{
public:

    inline DEST_Q931_INFO();

    inline HRESULT Init(
        IN DEST_H323_STATE   &DestH323State
        );

    inline SOURCE_Q931_INFO &GetSourceQ931Info();

    inline DEST_H245_INFO &GetDestH245Info();

    // processes PDUs received from the source Q931 instance
    // and directs them to the method for processing the
    // specific PDU
    HRESULT ProcessSourcePDU(
        IN  Q931_MESSAGE             *pQ931Message,
        IN  H323_UserInformation     *pH323UserInfo
        );

    virtual ~DEST_Q931_INFO();

    inline void StoreActualDestination(
		IN	SOCKADDR_IN *	ActualDestination);

	inline void GetActualDestination(
		OUT	SOCKADDR_IN *	ReturnActualDestination);

protected:

    // state for the dest instance
    Q931_DEST_STATE  m_Q931DestState;

	// Information that NAT redirects replace,
	// and we then restore by querying NAT about it
	SOCKADDR_IN		m_ActualDestinationAddress;

	// this method should never be called
    virtual HRESULT AcceptCallback(
        IN	DWORD			Status,
        IN	SOCKET			Socket,
		IN	SOCKADDR_IN *	LocalAddress,
		IN	SOCKADDR_IN *	RemoteAddress);

    virtual HRESULT ReceiveCallback (
        IN      Q931_MESSAGE             *pQ931Message,
        IN      H323_UserInformation     *pH323UserInfo
        );

private:

    // the following methods handle PDUs when the instance
    // is in a certain Q931 state

    HRESULT HandleStateDestConEstd(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    HRESULT HandleStateDestCallProcRcvd(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    HRESULT HandleStateDestAlertingRcvd(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    HRESULT HandleStateDestConnectRcvd(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );
        
    // the following methods handle a specific PDU for
    // any state of the Q931 instance. These are typically
    // called after the PDU has gone through one of the
    // HandleState* methods

    HRESULT HandleCallProceedingPDU(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    HRESULT HandleAlertingPDU(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    HRESULT HandleConnectPDU(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    // handles the release complete PDU - sends it to the
    // source q931 instance, performs state transition and
    // initiates cleanup
    HRESULT HandleReleaseCompletePDU(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    // the following methods process PDUs received from
    // the source Q931 instance

    // processes source Q.931 instance setup PDU
    HRESULT ProcessSourceSetupPDU(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    // other helper methods
    
    // modifies the passed in Q931 message and the setup user info
    HRESULT ModifySetupPDU(
        IN OUT  Q931_MESSAGE         *pQ931Message,
        IN OUT  H323_UserInformation *pH323UserInfo
        );

    HRESULT ConnectToH323Endpoint(
		IN	SOCKADDR_IN *	DestinationAddress);

	HRESULT LookupDefaultDestination (
		OUT	SOCKADDR_IN *	ReturnTranslatedAddress);

	// if necessary, bring up the demand-dial interface
	HRESULT	ConnectDemandDialInterface	(void);

};


inline 
DEST_Q931_INFO::DEST_Q931_INFO(
    )
    : m_Q931DestState(Q931_DEST_STATE_NOT_INIT)
{   
}

inline HRESULT
DEST_Q931_INFO::Init(
    IN DEST_H323_STATE   &DestH323State
    )
{
    m_Q931DestState = Q931_DEST_STATE_INIT;
    Q931_INFO::Init((H323_STATE &)DestH323State);

#if 0  // 0 ******* Region Commented Out Begins *******
    // This code has been moved to point where we process
    // the Setup PDU. The Call Ref Value needs to be
    // allocated only for outbound calls.
    // get a new CRV for the call (Q931 portion)
    if (!AllocCallRefVal(m_CallRefVal))
    {
        DBGOUT((LOG_CALLS,
            "DEST_Q931_INFO::Init, unable to allocate a CRV,"
            "returning E_UNEXPECTED"
            ));
        return E_UNEXPECTED;
    }
#endif // 0 ******* Region Commented Out Ends   *******

    DBGOUT((LOG_CALLS,"DEST_Q931_INFO::Init returning S_OK"));
    return S_OK;
}

#endif // __pxsvc_q931_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\sockinfo.cpp ===
#include "stdafx.h"
#include "sockinfo.h"

SOCKET_INFO::SOCKET_INFO (void)
	: Socket (INVALID_SOCKET)
{
	ZeroMemory (&LocalAddress, sizeof (SOCKADDR_IN));
	ZeroMemory (&RemoteAddress, sizeof (SOCKADDR_IN));
}

void 
SOCKET_INFO::Init (
	IN	SOCKET			ArgSocket,
	IN	SOCKADDR_IN *	ArgLocalAddress,
	IN	SOCKADDR_IN *	ArgRemoteAddress)
{
    assert (Socket == INVALID_SOCKET);
	assert (ArgSocket != INVALID_SOCKET);
	assert (ArgLocalAddress);
	assert (ArgRemoteAddress);

	Socket = ArgSocket;
	LocalAddress = *ArgLocalAddress;
	RemoteAddress = *ArgRemoteAddress;
}


int SOCKET_INFO::Init (
	IN	SOCKET			ArgSocket,
	IN	SOCKADDR_IN *	ArgRemoteAddress)
{
	INT		AddressLength;

	assert (Socket == INVALID_SOCKET);
	assert (ArgSocket != INVALID_SOCKET);

	AddressLength = sizeof (SOCKADDR_IN);

	if (getsockname (ArgSocket, (SOCKADDR *) &LocalAddress, &AddressLength)) {
		return WSAGetLastError();
	}

	Socket = ArgSocket;
	RemoteAddress = *ArgRemoteAddress;

    return ERROR_SUCCESS;
}

BOOLEAN
SOCKET_INFO::IsSocketValid (void) {
	return Socket != INVALID_SOCKET;
}

void
SOCKET_INFO::SetListenInfo (
	IN	SOCKET			ListenSocket,
	IN	SOCKADDR_IN *	ListenAddress)
{
	assert (Socket == INVALID_SOCKET);
	assert (ListenSocket != INVALID_SOCKET);
	assert (ListenAddress);

	Socket = ListenSocket;
	LocalAddress = *ListenAddress;
}


void SOCKET_INFO::Clear (void)
{
	if (Socket != INVALID_SOCKET) {
		closesocket (Socket);
		Socket = INVALID_SOCKET;
	}
}

SOCKET_INFO::~SOCKET_INFO (void)
{
    Clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\sockinfo.h ===
#ifndef __h323ics_sockinfo_h_
#define __h323ics_sockinfo_h_

// This class abstracts a winsock socket
// contains the socket descriptor, local and remote addresses and ports
// corresponding to a winsock socket
struct SOCKET_INFO
{
public:

    SOCKET			Socket;
	SOCKADDR_IN		LocalAddress;
	SOCKADDR_IN		RemoteAddress;

	SOCKET_INFO();

    void Init (
        IN	SOCKET			ArgSocket,
		IN	SOCKADDR_IN *	ArgLocalAddress,
		IN	SOCKADDR_IN *	ArgRemoteAddress);

    int Init (
        IN	SOCKET			ArgSocket,
        IN	SOCKADDR_IN *	ArgRemoteAddress);

	BOOLEAN IsSocketValid (void);

    void SetListenInfo (
        IN	SOCKET			ListenSocket,
        IN	SOCKADDR_IN *	ListenAddress);

	int Connect (
		IN	SOCKADDR_IN *	RemoteAddress);

    void Clear (void);

    ~SOCKET_INFO();
};


#endif __h323ics_sockinfo_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\util.h ===
#ifndef	__h323ics_util_h
#define	__h323ics_util_h

extern		DWORD	g_RegTraceFlags;

EXTERN_C	BOOL	IsInList		(LIST_ENTRY * ListHead, LIST_ENTRY * ListEntry);
EXTERN_C	void	ExtractList		(LIST_ENTRY * DestinationListHead, LIST_ENTRY * SourceListHead);
EXTERN_C	DWORD	CountListLength		(LIST_ENTRY * ListHead);
EXTERN_C	void 	MergeLists (PLIST_ENTRY Result, PLIST_ENTRY Source);
EXTERN_C	void	AssertListIntegrity	(LIST_ENTRY * ListHead);

typedef HANDLE TIMER_HANDLE;

__inline
LPWSTR AnsiToUnicode (LPCSTR string, LPWSTR buffer, DWORD buffer_len)
{
    int x;

    x = MultiByteToWideChar (CP_ACP, 0, string, -1, buffer, buffer_len);
    buffer [x] = 0;

    return buffer;
}

__inline
LPSTR UnicodeToAnsi (LPCWSTR string, LPSTR buffer, DWORD buffer_len)
{
    int x;

    x = WideCharToMultiByte (CP_ACP, 0, string, -1, buffer, buffer_len,
                             NULL, FALSE);
    buffer [x] = 0;

    return buffer;
}


// inline fns, macros

#define CLEANUP_ON_FAILURE(MacroHResult)            \
{                                                   \
    if (FAILED (MacroHResult)) goto error;  \
}


#define BAIL_ON_FAILURE(MacroHResult)       \
{                                           \
    HRESULT LocalHResult = MacroHResult ;   \
    if ( FAILED(LocalHResult) )    \
    {                                                           \
        DBGOUT((LOG_FAIL, "BAIL_ON_FAILURE - error %x", LocalHResult));   \
        return LocalHResult;                                                \
    }                                                                       \
}




struct  EVENT_MANAGER_CONTEXT;
class	TIMER_PROCESSOR;
class   OVERLAPPED_PROCESSOR;

class	Q931_INFO;
class	SOURCE_Q931_INFO;
class	DEST_Q931_INFO;

class	LOGICAL_CHANNEL;
class	H245_INFO;
class	SOURCE_H245_INFO;
class	DEST_H245_INFO;

class	H323_STATE;
class	SOURCE_H323_STATE;
class	DEST_H323_STATE;

class	CALL_BRIDGE;


#define LOG_FAIL	1
#define LOG_WARN	2
#define LOG_INFO	3
#define LOG_TRCE	4
#define LOG_ELSE	5
#define LOG_VERBOSE	6

// alternative names for the above
#define LOG_CALLS   4
#define LOG_ERRORS  1
#define LOG_REF     4

#define MAXDEBUGSTRINGLENTH 512

HRESULT	OpenTraceFile	(void);
void	CloseTraceFile	(void);

#ifdef __cplusplus
template <class T>
inline BOOL BadReadPtr(T* p, DWORD dwSize = 1)
{
    return IsBadReadPtr(p, dwSize * sizeof(T));
}

template <class T>
inline BOOL BadWritePtr(T* p, DWORD dwSize = 1)
{
    return IsBadWritePtr(p, dwSize * sizeof(T));
}
#endif


#if defined(DBG) && defined(ENABLE_DEBUG_OUTPUT)

void	Debug	(LPCTSTR);
void	DebugF	(LPCTSTR, ...);
void	DebugError	(DWORD, LPCTSTR);
void	DebugErrorF	(DWORD, LPCTSTR, ...);
void	DebugLastError	(LPCTSTR);
void	DebugLastErrorF	(LPCTSTR, ...);

void	DumpMemory (const UCHAR * Data, ULONG Length);
void	DumpError	(DWORD);

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

void DbgPrt(IN DWORD dwDbgLevel, IN LPCSTR DbgMessage, IN ...);

#ifdef __cplusplus
}
#endif // __cplusplus

#define DBGOUT(arg) DbgPrt arg

#else // !defined(DBG) || !defined(ENABLE_DEBUG_OUTPUT)

static	__inline	void	Debug	(LPCTSTR)					{}
static	__inline	void	DebugF	(LPCTSTR, ...)				{}
static	__inline	void	DebugError	(DWORD, LPCTSTR)		{}
static	__inline	void	DebugErrorF	(DWORD, LPCTSTR, ...)	{}
static	__inline	void	DebugLastError	(LPCTSTR)	{}
static	__inline	void	DebugLastErrorF	(LPCTSTR, ...)	{}

static	__inline	void	DumpMemory (const UCHAR * Data, ULONG Length)		{}
static	__inline	void	DumpError	(DWORD) {}

#define DBGOUT(arg)

#endif // defined(DBG) && defined(ENABLE_DEBUG_OUTPUT)


#ifdef _ASSERTE
#undef _ASSERTE
#endif // _ASSERTE

#ifdef	assert
#undef	assert
#endif

#if	DBG

// The latest and greatest Proxy assert
__inline void PxAssert(LPCTSTR file, DWORD line, LPCTSTR condition)
{
	DebugF (_T("%s(%d) : Assertion failed, condition: %s\n"),
            file, line, condition);
	DebugBreak();
}

#define	_ASSERTE(condition)	if(condition);else\
	{ PxAssert(_T(__FILE__), __LINE__, _T(#condition)); }

#define	assert	_ASSERTE

__inline void PxAssertNeverReached (LPCTSTR File, DWORD Line)
{
	DebugF (_T("%s(%d) : Assertion failure, code path should never be executed\n"),
		File, Line);
	DebugBreak();
}

#define	AssertNeverReached() PxAssertNeverReached (_T(__FILE__), __LINE__);

#else // !DBG

#define	_ASSERTE(condition)			NOP_FUNCTION
#define	assert						NOP_FUNCTION
#define	AssertNeverReached()		NOP_FUNCTION

#endif // DBG




// 0,1,2,3 : count of bytes from MSB to LSB in host order
#define BYTE0(l) ((BYTE)((DWORD)(l) >> 24))
#define BYTE1(l) ((BYTE)((DWORD)(l) >> 16))
#define BYTE2(l) ((BYTE)((DWORD)(l) >> 8))
#define BYTE3(l) ((BYTE)((DWORD)(l)))

// Handy macro to use in printf statements
#define BYTES0123(l) BYTE0(l), BYTE1(l), BYTE2(l), BYTE3(l)

// 0,1,2,3 : count of bytes from MSB to LSB in network order
#define NETORDER_BYTE0(l) ((BYTE)((BYTE *) &l)[0])
#define NETORDER_BYTE1(l) ((BYTE)((BYTE *) &l)[1])
#define NETORDER_BYTE2(l) ((BYTE)((BYTE *) &l)[2])
#define NETORDER_BYTE3(l) ((BYTE)((BYTE *) &l)[3])

#define	SOCKADDR_IN_PRINTF(SocketAddress) \
	ntohl ((SocketAddress) -> sin_addr.s_addr), \
	ntohs ((SocketAddress) -> sin_port)

// Handy macro to use in printf statements
#define NETORDER_BYTES0123(l) NETORDER_BYTE0(l), NETORDER_BYTE1(l), \
                             NETORDER_BYTE2(l), NETORDER_BYTE3(l)

static __inline LONG RegQueryValueString (
	IN	HKEY	Key,
	IN	LPCTSTR	ValueName,
	OUT	LPTSTR	ReturnString,
	IN	DWORD	StringMax)
{
	DWORD	ValueLength;
	DWORD	Type;
	LONG	Status;

	ValueLength = sizeof (TCHAR) * StringMax;
	Status = RegQueryValueEx (Key, ValueName, NULL, &Type, (LPBYTE) ReturnString, &ValueLength);

	if (Status != ERROR_SUCCESS)
		return Status;

	if (Type != REG_SZ)
		return ERROR_INVALID_PARAMETER;

	return ERROR_SUCCESS;
}

static __inline LONG RegQueryValueDWORD (
	IN	HKEY	Key,
	IN	LPCTSTR	ValueName,
	OUT	DWORD *	ReturnValue)
{
	DWORD	ValueLength;
	DWORD	Type;
	LONG	Status;

	ValueLength = sizeof (DWORD);
	Status = RegQueryValueEx (Key, ValueName, NULL, &Type, (LPBYTE) ReturnValue, &ValueLength);

	if (Status != ERROR_SUCCESS)
		return Status;

	if (Type != REG_DWORD)
		return ERROR_INVALID_PARAMETER;

	return ERROR_SUCCESS;
}


class	SIMPLE_CRITICAL_SECTION_BASE
{
protected:

	CRITICAL_SECTION		CriticalSection;

protected:

	void	Lock			(void)	{ EnterCriticalSection (&CriticalSection); }
	void	Unlock			(void)	{ LeaveCriticalSection (&CriticalSection); }
	void	AssertLocked	(void)	{ assert (PtrToUlong(CriticalSection.OwningThread) == GetCurrentThreadId()); }
	void	AssertNotLocked	(void)	{ assert (!CriticalSection.OwningThread); }
	void	AssertThreadNotLocked	(void)	{ assert (PtrToUlong(CriticalSection.OwningThread) != GetCurrentThreadId()); }

protected:

	SIMPLE_CRITICAL_SECTION_BASE	(void) {
		InitializeCriticalSection (&CriticalSection);
	}

	~SIMPLE_CRITICAL_SECTION_BASE	(void)	{
		if (CriticalSection.OwningThread) {
			DebugF (_T("SIMPLE_CRITICAL_SECTION_BASE::~SIMPLE_CRITICAL_SECTION_BASE: thread %08XH stills holds this critical section (this %p)\n"),
				PtrToUlong(CriticalSection.OwningThread), this);
		}

		AssertNotLocked();
		DeleteCriticalSection (&CriticalSection);
	}
};

#if ENABLE_REFERENCE_HISTORY
#include "dynarray.h"
#endif // ENABLE_REFERENCE_HISTORY

class SYNC_COUNTER;

class LIFETIME_CONTROLLER 
{
#if ENABLE_REFERENCE_HISTORY
public:
	LIST_ENTRY ListEntry;

	struct REFERENCE_HISTORY {
		LONG CurrentReferenceCount;
		PVOID CallersAddress;
	};

	DYNAMIC_ARRAY <REFERENCE_HISTORY> ReferenceHistory;
	CRITICAL_SECTION ReferenceHistoryLock;

#define MAKE_REFERENCE_HISTORY_ENTRY() {                                           \
		PVOID CallersAddress, CallersCallersAddress;							   \
		RtlGetCallersAddress (&CallersAddress, &CallersCallersAddress);            \
		EnterCriticalSection (&ReferenceHistoryLock);                              \
		REFERENCE_HISTORY * ReferenceHistoryNode = ReferenceHistory.AllocAtEnd (); \
		ReferenceHistoryNode -> CallersAddress = CallersAddress;                   \
		ReferenceHistoryNode -> CurrentReferenceCount = Count;                     \
		LeaveCriticalSection (&ReferenceHistoryLock);                              \
	}

#endif //ENABLE_REFERENCE_HISTORY

private:

	LONG ReferenceCount;
	SYNC_COUNTER * AssociatedSyncCounter;

protected: 

	LIFETIME_CONTROLLER (SYNC_COUNTER * AssocSyncCounter = NULL);
	virtual	~LIFETIME_CONTROLLER ();

public:

	void AddRef (void);

	void Release (void);
};


template <DWORD SampleHistorySize>
class SAMPLE_PREDICTOR {
public:

    SAMPLE_PREDICTOR (void) {
        
        ZeroMemory ((PVOID) &Samples[0],       sizeof (Samples));

        FirstSampleIndex    = 0;
        SamplesArraySize    = 0;
    }

    HRESULT AddSample (LONG Sample) {

        DWORD    ThisSampleIndex;

        if (0UL == SampleHistorySize)
            return E_ABORT;

        if (SamplesArraySize < SampleHistorySize) {

            ThisSampleIndex = SamplesArraySize;

            SamplesArraySize++;

        } else {

            ThisSampleIndex = FirstSampleIndex; // Overwrite the least recent sample

            FirstSampleIndex++;

            FirstSampleIndex %= SampleHistorySize;
        }
        
        Samples [ThisSampleIndex] = Sample; 

        return S_OK;
    }

    LONG PredictNextSample (void) {

        DWORD  Index;
        DWORD  CurrentSampleIndex;

        LONG   Coefficient = 0;
        LONG   Prediction  = 0;

        if (0 == SampleHistorySize)
            return 0;

        for (Index = 0; Index < SamplesArraySize; Index++) {

            if (0 == Index) {

               Coefficient = (LONG)((SamplesArraySize & 1) << 1) - 1; // 1 or -1

            } else {

               Coefficient *= (LONG) Index - (LONG) SamplesArraySize - 1;
               Coefficient /= (LONG) Index;
            }

            CurrentSampleIndex = (FirstSampleIndex + Index) % SamplesArraySize;

            Prediction += Coefficient * Samples [CurrentSampleIndex];

        }

        return Prediction;
    }

#if DBG
    void PrintSamples (void) {
        DWORD Index;

        if (SamplesArraySize) {
            DebugF (_T("Samples in predictor %p are: \n"), this);

            for (Index = 0; Index < SamplesArraySize; Index++) 
                DebugF (_T("\t@%d(%d)-- %d\n"), Index, Index < FirstSampleIndex ? SamplesArraySize - (FirstSampleIndex - Index) : Index - FirstSampleIndex, Samples[Index]);
        } else {
            DebugF (_T("There are no samples in predictor in predictor %p.\n"), this);
        }
    }
#endif 

    HRESULT RetrieveOldSample (
            IN DWORD StepsInThePast, // 0 -- most recent sample 
            OUT LONG * OldSample) {

        DWORD SampleIndex;

        if (0 == SampleHistorySize)
            return E_ABORT;

        if (StepsInThePast < SamplesArraySize) {
            // Valid request

            _ASSERTE (SamplesArraySize);

            SampleIndex = (SamplesArraySize + FirstSampleIndex - StepsInThePast - 1) % SamplesArraySize;

            *OldSample = Samples [SampleIndex];

            return S_OK;
        }

        return ERROR_INVALID_DATA;
    }

private:

    LONG    Samples       [SampleHistorySize];           // This is where samples are kept
    LONG    PositiveTerms [SampleHistorySize];  
    LONG    NegativeTerms [SampleHistorySize];  
    DWORD   SamplesArraySize;
    DWORD   FirstSampleIndex;                            // Index of the least recent sample
};

static __inline HRESULT GetLastErrorAsResult (void) {
	return GetLastError() == ERROR_SUCCESS ? S_OK : HRESULT_FROM_WIN32 (GetLastError());
}

static __inline HRESULT GetLastResult (void) {
	return GetLastError() == ERROR_SUCCESS ? S_OK : HRESULT_FROM_WIN32 (GetLastError());
}

// A sync counter is an integer counter.
// It is kind of the opposite of a semaphore.
// When the counter is zero, the sync counter is signaled.
// When the counter is nonzero, the sync counter is not signaled.

class	SYNC_COUNTER :
public	SIMPLE_CRITICAL_SECTION_BASE
{
	friend class LIFETIME_CONTROLLER;

private:

	LONG		CounterValue;			// the current value of the counter
	HANDLE		ZeroEvent;				// signaled when CounterValue = 0

public:
#if ENABLE_REFERENCE_HISTORY
	LIST_ENTRY ActiveLifetimeControllers;
#endif // ENABLE_REFERENCE_HISTORY


	SYNC_COUNTER ();
	~SYNC_COUNTER ();

	HRESULT	Start (void);
	void	Stop  (void);

	void	Increment	(void);
	void	Decrement	(void);

	DWORD	Wait		(DWORD Timeout);
};



#define	HRESULT_FROM_WIN32_ERROR_CODE		HRESULT_FROM_WIN32
#define	HRESULT_FROM_WINSOCK_ERROR_CODE		HRESULT_FROM_WINSOCK_ERROR_CODE

// ASN.1 utility functions

// Setup_UUIE&
// SetupMember(
//     IN H323_UserInformation *pH323UserInfo
//     );
#define SetupMember(pH323UserInfo)                          \
    (pH323UserInfo)->h323_uu_pdu.h323_message_body.u.setup

// Returns a non-zero value only. So don't try comparing it with TRUE/FALSE
// BOOL
// IsDestCallSignalAddressPresent(
//     IN H323_UserInformation *pH323UserInfo
//     );
#define IsDestCallSignalAddressPresent(pH323UserInfo) \
    (SetupMember(pH323UserInfo).bit_mask & Setup_UUIE_destCallSignalAddress_present)

// Get the destCallSignalAddress member
// TransportAddress&
// DCSAddrMember(
//     IN H323_UserInformation *pH323UserInfo
//     );
#define DCSAddrMember(pH323UserInfo) \
    SetupMember(pH323UserInfo).destCallSignalAddress

// Get the destCallSignalAddress member
// DESTINATION_ADDRESS *&
// DestAddrMember(
//     IN H323_UserInformation *pH323UserInfo
//     );
#define DestAddrMember(pH323UserInfo) \
    SetupMember(pH323UserInfo).destinationAddress
    
// BOOL
// IsTransportAddressTypeIP(
//     IN TransportAddress Addr
//     );
#define IsTransportAddressTypeIP(Addr) \
    (Addr.choice == ipAddress_chosen)
    
// BOOL
// IPAddrMember(
//     IN TransportAddress Addr
//     );
#define IPAddrMember(Addr) \
    Addr.u.ipAddress

typedef struct Setup_UUIE_destinationAddress DESTINATION_ADDRESS;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines for filling and extracting from structures used to               //
// store Transport addresses in Q.931 and H.245 ASN                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


// fills the TransportAddress port and address bytes with
// those specified. assumes that the passed in values are
// in host order
__inline void
FillTransportAddress(
    IN DWORD                IPv4Address,		// host order
    IN WORD                 Port,				// host order
    OUT TransportAddress    &TransportAddress
    )
{
	// we are filling in an IP address
    TransportAddress.choice = ipAddress_chosen;

    // fill in the port
    TransportAddress.u.ipAddress.port = Port;

	// value is a ptr to a struct, so it can't be null
	_ASSERTE(NULL != TransportAddress.u.ipAddress.ip.value);

    // 4 bytes in the IP address
    // copy the bytes into the transport address array
    TransportAddress.u.ipAddress.ip.length = 4;
	*((DWORD *)TransportAddress.u.ipAddress.ip.value) = 
		htonl(IPv4Address);
}

static __inline void FillTransportAddress (
	IN	const SOCKADDR_IN &	SocketAddress,
	OUT	TransportAddress &	ReturnTransportAddress)
{
	FillTransportAddress (
		ntohl (SocketAddress.sin_addr.s_addr),
		ntohs (SocketAddress.sin_port),
		ReturnTransportAddress);
}

// returns E_INVALIDARG for PDUs which can not be handled.
__inline HRESULT
GetTransportInfo(
    IN const TransportAddress	&TransportAddress,
    OUT DWORD			&IPv4Address,				// host order
    OUT WORD			&Port						// host order
    )
{
	// we proceed only if the transport address has the
    // IP address (v4) field filled
    if (!(ipAddress_chosen & TransportAddress.choice))
	{
		DBGOUT((LOG_FAIL, 
			"GetTransportInfo(&H245Address, &0x%x, &%u), "
            "non unicast address type = %d, returning E_INVALIDARG",
			IPv4Address, Port, TransportAddress.choice));
		return E_INVALIDARG;
	}

	// fill in the port
    Port = TransportAddress.u.ipAddress.port;

    // 4 bytes in the IP address
    // copy the bytes into the transport address array
    if (4 != TransportAddress.u.ipAddress.ip.length)
	{
		DBGOUT((LOG_FAIL, 
			"GetTransportInfo: bogus address length (%d) in TransportAddress",
			TransportAddress.u.ipAddress.ip.length));
		return E_INVALIDARG;
	}

	IPv4Address = ntohl(*((DWORD *)TransportAddress.u.ipAddress.ip.value));

	return S_OK;
}

static __inline HRESULT GetTransportInfo (
	IN	const TransportAddress &	TransportAddress,
	OUT	SOCKADDR_IN &		ReturnSocketAddress)
{
	HRESULT		Result;

	ReturnSocketAddress.sin_family = AF_INET;

	Result = GetTransportInfo (TransportAddress,
		ReturnSocketAddress.sin_addr.s_addr,
		ReturnSocketAddress.sin_port);

	ReturnSocketAddress.sin_addr.s_addr = htonl (ReturnSocketAddress.sin_addr.s_addr);
	ReturnSocketAddress.sin_port = htons (ReturnSocketAddress.sin_port);

	return Result;
}


// fills the H245TransportAddress port and address bytes with
// those specified. assumes that the passed in values are
// in host order
inline void
FillH245TransportAddress(
    IN DWORD					IPv4Address,
    IN WORD						Port,
    OUT H245TransportAddress	&H245Address
    )
{
	// we are filling in an unicast IP address
	H245Address.choice = unicastAddress_chosen;

	// alias for the unicast address
	UnicastAddress &UnicastIPAddress = H245Address.u.unicastAddress;

	// its an IP address
	UnicastIPAddress.choice = UnicastAddress_iPAddress_chosen;

    // fill in the port
    UnicastIPAddress.u.iPAddress.tsapIdentifier = Port;

	// value is a ptr to a struct, so it can't be null
	_ASSERTE(NULL != UnicastIPAddress.u.iPAddress.network.value);

    // 4 bytes in the IP address
    // copy the bytes into the transport address array
    UnicastIPAddress.u.iPAddress.network.length = 4;
	*((DWORD *)UnicastIPAddress.u.iPAddress.network.value) = 
		htonl(IPv4Address);
}

// Returned IPaddress and port are in host order
inline HRESULT
GetH245TransportInfo(
    IN const H245TransportAddress &H245Address,
    OUT DWORD			    &IPv4Address,
    OUT WORD			    &Port
    )
{
	// we proceed only if the transport address has a unicast address
    if (!(unicastAddress_chosen & H245Address.choice))
	{
		DBGOUT((LOG_FAIL, 
			"GetH245TransportInfo(&H245Address, &0x%x, &%u), "
            "non unicast address type = %d, returning E_INVALIDARG",
			IPv4Address, Port, H245Address.choice));
		return E_INVALIDARG;
	}
    
	// we proceed only if the transport address has the
    // IP address (v4) field filled
    if (!(UnicastAddress_iPAddress_chosen & 
            H245Address.u.unicastAddress.choice))
	{
		DBGOUT((LOG_FAIL, 
			"GetH245TransportInfo(&TransportAddress, &0x%x, &%u), "
            "non ip address type = %d, returning E_INVALIDARG",
			IPv4Address, Port, H245Address.u.unicastAddress.choice));
		return E_INVALIDARG;
	}

    const UnicastAddress & UnicastIPAddress = H245Address.u.unicastAddress;

	// fill in the port
    Port = UnicastIPAddress.u.iPAddress.tsapIdentifier;

    // 4 bytes in the IP address
    // copy the bytes into the transport address array
    if (4 != UnicastIPAddress.u.iPAddress.network.length)
	{
		DBGOUT((LOG_FAIL, 
			"GetH245TransportInfo: bogus ip address length (%d), failing",
			UnicastIPAddress.u.iPAddress.network.length));

		return E_INVALIDARG;
	}

	// value is a ptr to a struct, so it can't be null
	_ASSERTE(NULL != UnicastIPAddress.u.iPAddress.network.value);
	IPv4Address = ntohl(*((DWORD *)UnicastIPAddress.u.iPAddress.network.value));

	return S_OK;
}

static __inline HRESULT GetH245TransportInfo (
	IN	const H245TransportAddress & H245Address,
	OUT	SOCKADDR_IN *		ReturnSocketAddress)
{
	DWORD	IPAddress;
	WORD	Port;
	HRESULT	Result;

	Result = GetH245TransportInfo (H245Address, IPAddress, Port);
	if (Result == S_OK) {
		ReturnSocketAddress -> sin_family = AF_INET;
		ReturnSocketAddress -> sin_addr.s_addr = htonl (IPAddress);
		ReturnSocketAddress -> sin_port = htons (Port);
	}

	return Result;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines dealing with the T.120 Parameters in H.245 PDUs                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


// In case of failure the routine returns 
// INADDR_NONE for the T120ConnectToIPAddr
inline HRESULT
GetT120ConnectToAddress(
    IN  NetworkAccessParameters  separateStack,
    OUT DWORD                   &T120ConnectToIPAddr,
    OUT WORD                    &T120ConnectToPort
    )
{
    // These are the return values in case of a failure.
    T120ConnectToIPAddr = INADDR_NONE;
    T120ConnectToPort   = 0;
    
    // CODEWORK: should we require the distribution member
    // to be present always ?
    
    if ((separateStack.bit_mask & distribution_present) &&
        (separateStack.distribution.choice != unicast_chosen))
    {
        // We support Unicast only
        return E_INVALIDARG;
    }
    
    // Deal with t120SetupProcedure
    
    if (separateStack.networkAddress.choice != localAreaAddress_chosen)
    {
        // Support only local area addresses
        return E_INVALIDARG;
    }
    
    GetH245TransportInfo(
        separateStack.networkAddress.u.localAreaAddress,
        T120ConnectToIPAddr,
        T120ConnectToPort
        );
    
    DBGOUT((LOG_TRCE, 
            "H245_INFO::CheckT120OpenLogicalChannelPDU()"
            "has separate stack T.120 endpoint is listening on"
            "IPAddr: %d.%d.%d.%d port:%d",
            BYTES0123(T120ConnectToIPAddr),
            T120ConnectToPort
            ));
    return S_OK;
}



#define TPKT_HEADER_SIZE 4
#define TPKT_VERSION    3


inline DWORD GetPktLenFromTPKTHdr(BYTE *pbTpktHdr)
/*++

Routine Description:

	Compute the length of the packet from the TPKT header.
	The TPKT header is four bytes long. Byte 0 gives
	the TPKT version (defined by TPKT_VERSION). Byte 1
	is reserved and should not be interpreted. Bytes 2 and 3
	together give the size of the packet (Byte 2 is the MSB and
	Byte 3 is the LSB i.e. in network byte order). (This assumes
	that the size of the packet will always fit in 2 bytes).

Arguments:
    
    

Return Values:

    Returns the length of the PDU which follows the TPKT header.

--*/
{
	_ASSERTE(pbTpktHdr[0] == TPKT_VERSION);
    return ((pbTpktHdr[2] << 8) + pbTpktHdr[3]  - TPKT_HEADER_SIZE);
}

inline void SetupTPKTHeader(
     OUT BYTE *  pbTpktHdr,
     IN  DWORD   dwLength
     )
/*++

Routine Description:

	Setup the TPKT header based on the length.

	The TPKT header is four bytes long. Byte 0 gives
	the TPKT version (defined by TPKT_VERSION). Byte 1
	is reserved and should not be interpreted. Bytes 2 and 3
	together give the size of the packet (Byte 2 is the MSB and
	Byte 3 is the LSB i.e. in network byte order). (This assumes
	that the size of the packet will always fit in 2 bytes).

Arguments:
    
    

Return Values:

    Returns S_OK if the version is right and E_FAIL otherwise.

--*/
{
    _ASSERTE(pbTpktHdr);

    dwLength += TPKT_HEADER_SIZE;

    // TPKT requires that the packet size fit in two bytes.
    _ASSERTE(dwLength < (1L << 16));

    pbTpktHdr[0] = TPKT_VERSION;
    pbTpktHdr[1] = 0;
    pbTpktHdr[2] = HIBYTE(dwLength); //(BYTE)(dwLength >> 8);
    pbTpktHdr[3] = LOBYTE(dwLength); //(BYTE)dwLength;
}

static __inline BOOLEAN RtlEqualStringConst (
	IN	const STRING *	StringA,
	IN	const STRING *	StringB,
	IN	BOOLEAN			CaseInSensitive)
{
	return RtlEqualString (
		const_cast<STRING *> (StringA),
		const_cast<STRING *> (StringB),
		CaseInSensitive);
}

static __inline INT RtlCompareStringConst (
	IN	const STRING *	StringA,
	IN	const STRING *	StringB,
	IN	BOOLEAN			CaseInSensitive)
{
	return RtlCompareString (
		const_cast<STRING *> (StringA),
		const_cast<STRING *> (StringB),
		CaseInSensitive);
}

static __inline void InitializeAnsiString (
	OUT	ANSI_STRING *		AnsiString,
	IN	ASN1octetstring_t *	AsnString)
{
	assert (AnsiString);
	assert (AsnString);

	AnsiString -> Buffer = (PSTR) AsnString -> value;
	AnsiString -> Length = (USHORT) AsnString -> length / sizeof (CHAR);
}

static __inline void InitializeUnicodeString (
	OUT	UNICODE_STRING *		UnicodeString,
	IN	ASN1char16string_t *	AsnString)
{
	assert (UnicodeString);
	assert (AsnString);

	UnicodeString -> Buffer = AsnString -> value;
	UnicodeString -> Length = (USHORT) AsnString -> length / sizeof (WCHAR);
}

// use with "%.*s" or "%.*S"
#define	ANSI_STRING_PRINTF(AnsiString) (AnsiString) -> Length, (AnsiString) -> Buffer


// { Length, MaximumLength, Buffer }
#define	ANSI_STRING_INIT(Text) { sizeof (Text) - sizeof (CHAR), 0, (Text) } // account for NUL

void FreeAnsiString (
	IN	ANSI_STRING *	String);

NTSTATUS CopyAnsiString (
	IN	ANSI_STRING *	SourceString,
	OUT	ANSI_STRING *	DestString);

static __inline ULONG ByteSwap (
	IN	ULONG	Value)
{
	union	ULONG_SWAP	{
		BYTE	Bytes	[sizeof (ULONG)];
		ULONG	Integer;
	};
	
	ULONG_SWAP *	SwapValue;
	ULONG_SWAP		SwapResult;

	SwapValue = (ULONG_SWAP *) &Value;
	SwapResult.Bytes [0] = SwapValue -> Bytes [3];
	SwapResult.Bytes [1] = SwapValue -> Bytes [2];
	SwapResult.Bytes [2] = SwapValue -> Bytes [1];
	SwapResult.Bytes [3] = SwapValue -> Bytes [0];

	return SwapResult.Integer;
}

// does NOT convert to host order first
static __inline INT Compare_SOCKADDR_IN (
	IN	const	SOCKADDR_IN *	AddressA,
	IN	const	SOCKADDR_IN *	AddressB)
{
	assert (AddressA);
	assert (AddressB);

	if (AddressA -> sin_addr.s_addr < AddressB -> sin_addr.s_addr) return -1;
	if (AddressA -> sin_addr.s_addr > AddressB -> sin_addr.s_addr) return 1;

	return 0;
}

static __inline BOOL IsEqualSocketAddress (
	IN	const	SOCKADDR_IN *	AddressA,
	IN	const	SOCKADDR_IN *	AddressB)
{
	assert (AddressA);
	assert (AddressB);
	assert (AddressA -> sin_family == AF_INET);
	assert (AddressB -> sin_family == AF_INET);

	return AddressA -> sin_addr.s_addr == AddressB -> sin_addr.s_addr
		&& AddressA -> sin_port == AddressB -> sin_port;
}

// Determines whether the call source specified by dwIPAddress is external
// to the local subnet
BOOL IsInternalCallSource (ULONG dwIPAddress);

#if DBG

void ExposeTimingWindow (void);

#endif

#endif // __h323ics_util_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\stdafx.h ===
#define STRICT
#define UNICODE
#define _UNICODE

#pragma warning (disable : 4211)        // ASN.1 stubs have static/extern conflict
#pragma warning (disable : 4201)        // nameless struct/union
#pragma warning (disable : 4514)        // unreferenced inline function has been removed
#pragma warning (disable : 4100)        // unreferenced formal parameter
#pragma warning (disable : 4127)        // conditional expression is constant
#pragma warning (disable : 4355)        // use of "this" in constructor initializer list



// NT private files
// Need to be before the windows include files
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// Win32 SDK (public)
#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <tchar.h>
#include <winsvc.h>
#include <mswsock.h>

// ANSI
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

// Microsoft private
#include <msasn1.h>
#include <msper.h>
#include <ipnatapi.h>
extern "C" {
#include <sainfo.h>
#include <rasuip.h>
#include <raserror.h>
};
#include <ipexport.h>       // needed for interaction with TCP driver
#include <ipinfo.h>
#include <tcpinfo.h>
#include <ntddtcp.h>
#include <routprot.h>       // for struct IP_ADAPTER_BINDING_INFO
#include <mprerror.h>       // for RRAS error codes


#include "ldap.h"           // ASN.1 structures for LDAP

// Project

#include "h225pp.h"
#include "h245pp.h"
#include "util.h"
#include "h323asn1.h"
#include "q931msg.h"
#include "portmgmt.h"
#include "h323ics.h"
#include "main.h"


// interface to ipnathlp.dll
#include "h323icsp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\testprogs\bertest\bertest.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <winldap.h>
#include <winber.h>


void __cdecl main (int argc, char *argv[])
{

//
// We will BER encode the following ASN.1 data type
//
//
//   Example1Request ::= SEQUENCE {
//     s     OCTET STRING, -- must be printable
//     val1  INTEGER,
//     val2  [0] INTEGER DEFAULT 0
//     attrs SEQUENCE OF OCTET STRING
//   }
//


 BerElement *ber, *newelement;
 int rc;
 char s[]={'a', 'b', 'c', 'd', '\0'};
 int val1 = 3;
 int val2 = 9999;
 PBERVAL pNewberval;
 ULONG retval, len;
 char *str;
 int *first, i;
 int *second;
 char **ppchar;

 char* attrs[] = {"hello",
                 "mello",
                 "cello",
                 NULL };


 ber = ber_alloc_t(LBER_USE_DER);

 if (ber == NULL) {

    fprintf( stderr,"ber_alloc_t failed.");
    return;
 }

 rc = ber_printf( ber,"{si",s,val1 );

 if (rc == -1) {
    
    fprintf( stderr,"ber_printf failed.");
    return;
 }


 if (val2 != 0) {
    if (ber_printf(ber,"i",val2) == -1) {
       
       fprintf( stderr,"ber_printf failed.");
       ber_free(ber,1);
       return;
    }
 }


 if (ber_printf(ber, "{v}}", &attrs) == -1) {
    
    fprintf( stderr,"ber_printf failed.");
    ber_free(ber,1);
    return;
 }

 rc = ber_flatten(ber, &pNewberval);
 
 fprintf( stderr,"ber_flatten returned %d\n", rc);

 //
 // Now that we have put stuff into the BerElement, we will try to take it
 // out
 //

 newelement =  ber_init( pNewberval );

 if ( newelement == NULL) {

    fprintf( stderr,"ber_init fails\n");
    return;
 }

 retval = ber_peek_tag( newelement, &len );

if (retval != LBER_DEFAULT) {

   fprintf( stderr,"ber_peek_tag reports tag of 0x%x with len 0x%x\n", retval, len );

} else {

   fprintf( stderr,"ber_peek_tag reports no more data \n" );
   return;

}

 retval = ber_scanf( newelement, "{aii",  &str, &first, &second);

 printf("string is %s\n", str);
 printf("first int is %d\n", first);
 printf("second int is %d\n", second);

 //
 // Free the allocated string
 //

 ldap_memfree( str );

 retval = ber_peek_tag( newelement, &len );

if (retval != LBER_DEFAULT) {

   fprintf( stderr,"ber_peek_tag reports tag of 0x%x with len 0x%x\n", retval, len );

} else {

   fprintf( stderr,"ber_peek_tag reports no more data \n" );
   return;

}

 retval = ber_scanf( newelement, "v}", &ppchar);

 for (i = 0; ppchar != NULL && ppchar[i] != NULL; i++) {
        
    printf("string is %s\n", ppchar[i]);    
    ldap_memfree(ppchar[i]);
}

 ldap_memfree(*ppchar);


 //
 // Now that the BerElement holds the encoded data, we will have
 // ber_flatten allocate a new berval struct and return it to us
 //

 rc = ber_flatten(ber, &pNewberval);
 
 fprintf( stderr,"ber_flatten returned %d\n", rc);
 
 ber_free(ber,1);

 fprintf( stderr,"New berval address is %x\n", pNewberval);
 
 return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\test\testldap.c ===
/*****************************************************************************

    testldap.c

*****************************************************************************/

#include <windef.h>
#include <windows.h>
#include <winsock2.h>
#include <winldap.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

VOID
DisplayResults (
    LDAPMessage *results
    );

//
//  This is a quick and dirty test program that calls LDAP APIs to display
//  a directory tree.  It calls many of the LDAP functions to display the
//  entire tree.
//

LDAP *ldapConnection = NULL;


int __cdecl main( int   cArgs,
                   char  *pArgs[] );

int __cdecl main( int   cArgs,
                   char  *pArgs[] )
{
    PCHAR pHost = NULL;
    PCHAR userDN = NULL;
    PCHAR pw = NULL;
    INT err;
    LDAPMessage *results = NULL;
    UCHAR baseDN[250];
    PCHAR baseAttrList[2];
    LDAPMessage *message;
    PCHAR attribute;
    PVOID opaque;
    LONG msgId;
    struct l_timeval  TimeOut;
    ULONG version = LDAP_VERSION3;

    PCHAR result1;

    printf( "\n" );

    if (cArgs > 1) {

        pHost = pArgs[1];
    }
    if (cArgs > 2) {

        userDN = pArgs[2];
    }
    if (cArgs > 3) {

        pw = pArgs[3];
    }

    //
    //  Let's first connect to a server
    //

    printf( "Connecting to server %s....\n", pHost );

    ldapConnection = ldap_sslinit( pHost, 0, 0 );

    if ( ldapConnection == NULL ) {

        printf( "ldapConnection failed with 0x%x.\n", GetLastError() );
        goto FatalExit0;
    }

    ldapConnection->ld_lberoptions = 0;

    printf( "Connected to server %s.\n", ldapConnection->ld_host );

    ldap_set_option( ldapConnection, LDAP_OPT_VERSION, &version );

    //
    //  Now we'll bind with the credentials passed in.  Null is valid.
    //

    printf( "Binding with userName %s, password %s....\n", userDN, pw );
    err = ldap_simple_bind_s( ldapConnection, userDN, pw );

    printf( "simple bind returned 0x%x\n", err );

    //
    //  discover the base DN to search on.  Our DS guarentees (for now) that
    //  a) it's there and b) it's a singular value.  Now whether or now we
    //  have permissions to read it is another matter...
    //

    baseDN[0] = '\0';           // if it fails, we'll just search root

    baseAttrList[0] = "defaultNamingContext";
    baseAttrList[1] = NULL;

    printf( "getting tree name from directory... \n" );

    err = ldap_search_s(    ldapConnection,
                            "",
                            LDAP_SCOPE_BASE,
                            "(objectClass=*)",
                            &baseAttrList[0],
                            0,
                            &results
                            );

    if (results != NULL) {

        message = ldap_first_entry( ldapConnection, results );
        if (message != NULL) {

            attribute = ldap_first_attribute( ldapConnection,
                                              message,
                                              &opaque
                                              );

            if (attribute != NULL) {

                PCHAR *value = NULL;

                value = ldap_get_values(    ldapConnection,
                                            message,
                                            attribute
                                            );

                if (value != NULL) {

                    strcpy( &baseDN[0], *value );
                    printf( "Base DN for tree is %s\n", *value );
                }

                ldap_value_free( value );
            }
        }

        ldap_msgfree( results );
    }

    //
    //  We have our DN to search, now let's loop around a while and display it.
    //

    while (err != LDAP_SERVER_DOWN) {

        LDAPControlA tombControl;
        LDAPControlA simpleControl;
        PLDAPControlA controlArray[3];
        ULONG data = 1;
        PCHAR attributes[2];

        ldap_unbind( ldapConnection );

        ldapConnection = ldap_open( pHost, 0 );

        if ( ldapConnection == NULL ) {

            printf( "ldapConnection failed with 0x%x.\n", GetLastError() );
            goto FatalExit0;
        }

        ldapConnection->ld_lberoptions = 0;

        printf( "Connected to server %s.\n", ldapConnection->ld_host );

        //
        //  Now we'll bind with the credentials passed in.  Null is valid.
        //

        ldap_set_option( ldapConnection, LDAP_OPT_VERSION, &version );

        printf( "Binding with userName %s, password %s....\n", userDN, pw );
        err = ldap_simple_bind_s( ldapConnection, userDN, pw );

        printf( "simple bind returned 0x%x\n", err );

        controlArray[0] = &simpleControl;
        controlArray[1] = &tombControl;
        controlArray[2] = NULL;

        //
        //  this control tells the server to return only a
        //  portion of the security descriptor
        //

        tombControl.ldctl_oid = "1.2.840.113556.1.4.417";
        tombControl.ldctl_iscritical = TRUE;
        tombControl.ldctl_value.bv_len = 0;
        tombControl.ldctl_value.bv_val = (PCHAR) &data;

        //
        //  this control tells the server to include tombstones.
        //

        simpleControl.ldctl_oid = "1.2.840.113556.1.4.416";
        simpleControl.ldctl_iscritical = TRUE;
        simpleControl.ldctl_value.bv_len = 4;
        simpleControl.ldctl_value.bv_val = (PCHAR) &data;

        attributes[0] = "NtSecurityDescriptor";
        attributes[1] = NULL;

        //
        //  first we'll try a synchronous search
        //

        err = ldap_search_ext_s( ldapConnection,
                                 &baseDN[0],
                                 LDAP_SCOPE_SUBTREE,
                                 "objectClass=*",
                                 (PCHAR *) &attributes,
                                 0,
                                 (PLDAPControlA *) &controlArray,
                                 NULL,
                                 NULL,          // timeout
                                 10000,         // sizelimit
                                 &results
                                 );

        printf( "search tree returned 0x%x\n", err );

        DisplayResults( results );

        //
        //  next we'll try an asynchronous search picking up each entry as
        //  it comes in.
        //

        msgId = ldap_search(    ldapConnection,
                                &baseDN[0],
                                LDAP_SCOPE_SUBTREE,
                                "(objectClass=*)",
                                NULL,
                                0
                                );

        if (msgId == -1) {

            printf( " The asynch search #1 failed... 0x%x \n", GetLastError() );

        } else {

            err = 0;
            TimeOut.tv_sec = 0;
            TimeOut.tv_usec = 0;

            printf( "Displaying tree asynchronously... \n" );

            while (err == 0) {

                results = NULL;

                err = ldap_result(  ldapConnection,
                                    msgId,
                                    LDAP_MSG_ONE,
                                    &TimeOut,       // no wait
                                    &results
                                    );

                if ((err == (ULONG) -1) || (results) == NULL) {

                    err = ldapConnection->ld_errno;

                    if (err == LDAP_TIMEOUT) {

                        err = 0;

                    } else if (err != LDAP_LOCAL_ERROR ) {

                        printf( "Error of %s\n", ldapConnection->ld_error );
                    }

                } else {

                    DisplayResults( results );
                    err = 0;
                }
            }
        }

        //
        //  next we'll try an asynchronous search picking up all entries that
        //  have arrived to date.
        //

        msgId = ldap_search(    ldapConnection,
                                &baseDN[0],
                                LDAP_SCOPE_SUBTREE,
                                "(objectClass=*)",
                                NULL,
                                0
                                );

        if (msgId == -1) {

            printf( " The asynch search #2 failed... 0x%x \n", GetLastError() );

        } else {

            err = 0;
            TimeOut.tv_sec = 0;
            TimeOut.tv_usec = 10;

            printf( "Displaying tree asynchronously... \n" );

            while (err == 0) {

                results = NULL;

                err = ldap_result(  ldapConnection,
                                    msgId,
                                    LDAP_MSG_RECEIVED,
                                    &TimeOut,       // no wait
                                    &results
                                    );

                if ((err == (ULONG) -1) || (results) == NULL) {

                    err = ldapConnection->ld_errno;

                    if (err == LDAP_TIMEOUT) {

                        err = 0;

                    } else if (err != LDAP_LOCAL_ERROR ) {

                        printf( "Error of %s\n", ldapConnection->ld_error );
                    }

                } else {

                    DisplayResults( results );
                    err = 0;
                }
            }
        }

        //
        //  next we'll try an asynchronous search picking up all entries
        //

        msgId = ldap_search(    ldapConnection,
                                &baseDN[0],
                                LDAP_SCOPE_SUBTREE,
                                "(objectClass=*)",
                                NULL,
                                0
                                );

        if (msgId == -1) {

            printf( " The asynch search #2 failed... 0x%x \n", GetLastError() );

        } else {

            err = 0;
            TimeOut.tv_sec = 10;
            TimeOut.tv_usec = 0;

            printf( "Displaying tree asynchronously... \n" );

            while (err == 0) {

                results = NULL;

                err = ldap_result(  ldapConnection,
                                    msgId,
                                    LDAP_MSG_ALL,
                                    &TimeOut,       // no wait
                                    &results
                                    );

                if ((err == (ULONG) -1) || (results) == NULL) {

                    err = ldapConnection->ld_errno;

                    if (err == LDAP_TIMEOUT) {

                        err = 0;

                    } else if (err != LDAP_LOCAL_ERROR ) {

                        printf( "Error of %s\n", ldapConnection->ld_error );
                    }

                } else {

                    DisplayResults( results );
                    err = 0;
                }
            }
        }


        printf( "\n\nMade it.... let's do it again.\n\n" );

        break;
    }

FatalExit0:

    if (ldapConnection) {

        ldap_unbind( ldapConnection );
    }

    return 0;

}   // main

VOID
DisplayResults (
    LDAPMessage *results
    )
//
//  Display the results
//
{
    INT err;
    LDAPMessage *message;
    PCHAR attribute;
    PVOID opaque;

    if (results != NULL) {

        ULONG notypes = 0;

        message = ldap_first_entry( ldapConnection, results );

        while (message != NULL) {

            PCHAR dn = NULL;
            PCHAR *explodedDN = NULL;
            PCHAR friendlyDN = NULL;

            dn = ldap_get_dn( ldapConnection, message );

            printf( "Distinguished Name is : %s\n", dn );

            friendlyDN = ldap_dn2ufn( dn );

            printf( "Friendly DN is : %s\n", friendlyDN );

            explodedDN = ldap_explode_dn( dn, notypes );

            notypes = ( notypes ? 0 : 1 );      // reverse on every one

            ldap_memfree( dn );
            ldap_memfree( friendlyDN );

            if (ldap_count_values(explodedDN) > 1) {

                ULONG count, total;

                printf( "ExplodedDN is :\n" );

                total = ldap_count_values(explodedDN);

                for (count = 0; count < total; count++ ) {
                    printf( "\t%s\n", explodedDN[count] );
                }

            } else {

                if (explodedDN != NULL) {

                    printf( "ExplodedDN is %s\n", *explodedDN );

                } else {

                    printf( "ExplodedDN is null.\n" );
                }
            }

            ldap_value_free( explodedDN );

            attribute = ldap_first_attribute( ldapConnection,
                                              message,
                                              &opaque
                                              );

            while (attribute != NULL) {

                PCHAR *value = NULL;

                value = ldap_get_values(    ldapConnection,
                                            message,
                                            attribute
                                            );

                if (ldap_count_values(value) > 1) {

                    ULONG count, total;

                    printf( "Attribute %s is :\n", attribute );

                    total = ldap_count_values(value);

                    for (count = 0; count < total; count++ ) {
                        printf( "\t%s\n", value[count] );
                    }

                } else {

                    printf( "Attribute %s is %s\n", attribute, *value );
                }

                ldap_value_free( value );

                attribute = ldap_next_attribute(  ldapConnection,
                                                  message,
                                                  opaque
                                                  );
            }

            message = ldap_next_entry( ldapConnection, message );
        }

        ldap_msgfree( results );
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\dnfilter\util.cpp ===
#include "stdafx.h"

#if	defined(DBG) && defined(ENABLE_DEBUG_OUTPUT)

// it's faster to do a single alloc-and-convert rather than to do two
// (one inside DEBUG_LOG_FILE::WriteW and one inside OutputDebugStringW)

void Debug (LPCWSTR Text)
{
	UNICODE_STRING	UnicodeString;
	ANSI_STRING		AnsiString;
	NTSTATUS		Status;

	assert (Text);

	RtlInitUnicodeString (&UnicodeString, Text);

	Status = RtlUnicodeStringToAnsiString (&AnsiString, &UnicodeString, TRUE);
	
	if (NT_SUCCESS (Status)) {

		OutputDebugStringA (AnsiString.Buffer);
		RtlFreeAnsiString (&AnsiString);
	}
}

void DebugVa (LPCTSTR Format, va_list VaList)
{
	TCHAR	Text	[0x200];

	_vsntprintf (Text, 0x200, Format, VaList);
	Debug (Text);
}

void DebugF (LPCTSTR Format, ...)
{
	va_list	VaList;

	va_start (VaList, Format);
	DebugVa (Format, VaList);
	va_end (VaList);
}

void DumpError (DWORD ErrorCode)
{
	TCHAR	Text	[0x200];
	DWORD	TextLength;
	DWORD	MaxLength;
	LPTSTR	Pos;

	_tcscpy (Text, _T("\tError: "));
	Pos = Text + _tcslen (Text);

	MaxLength = 0x200 - (DWORD)(Pos - Text);

	TextLength = FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM, NULL, ErrorCode, LANG_NEUTRAL, Text, 0x200, NULL);
	if (!TextLength)
		_sntprintf (Pos, MaxLength, _T("Uknown error %08XH %u"), ErrorCode, ErrorCode);

	_tcsncat (Text, _T("\n"), MaxLength);
	Text [MaxLength - 1] = 0;

	Debug (Text);
}

void DebugError (DWORD ErrorCode, LPCTSTR Text)
{
	Debug (Text);
	DumpError (ErrorCode);
}

void DebugErrorF (DWORD ErrorCode, LPCTSTR Format, ...)
{
	va_list	VaList;

	va_start (VaList, Format);
	DebugVa (Format, VaList);
	va_end (VaList);

	DumpError (ErrorCode);
}

void DebugLastError (LPCTSTR Text)
{
	DebugError (GetLastError(), Text);
}

void DebugLastErrorF (LPCTSTR Format, ...)
{
	va_list	VaList;
	DWORD	ErrorCode;

	ErrorCode = GetLastError();

	va_start (VaList, Format);
	DebugVa (Format, VaList);
	va_end (VaList);

	DumpError (ErrorCode);
}

static __inline CHAR ToHexA (UCHAR x)
{
	x &= 0xF;
	if (x < 10) return x + '0';
	return (x - 10) + 'A';
}

void DumpMemory (const UCHAR * Data, ULONG Length)
{
	const UCHAR *	DataPos;		// position within data
	const UCHAR *	DataEnd;		// end of valid data
	const UCHAR *	RowPos;		// position within a row
	const UCHAR *	RowEnd;		// end of single row
	CHAR			Text	[0x100];
	LPSTR			TextPos;
	ULONG			RowWidth;

	assert (Data);

	DataPos = Data;
	DataEnd = Data + Length;

	while (DataPos < DataEnd) {
		RowWidth = (DWORD)(DataEnd - DataPos);

		if (RowWidth > 16)
			RowWidth = 16;

		RowEnd = DataPos + RowWidth;

		TextPos = Text;
		*TextPos++ = '\t';

		for (RowPos = DataPos; RowPos < RowEnd; RowPos++) {
			*TextPos++ = ToHexA ((*RowPos >> 4) & 0xF);
			*TextPos++ = ToHexA (*RowPos & 0xF);
			*TextPos++ = ' ';
		}

		*TextPos++ = '\r';
		*TextPos++ = '\n';
		*TextPos = 0;

		OutputDebugStringA (Text);

		assert (RowEnd > DataPos);		// make sure we are walking forward

		DataPos = RowEnd;
	}
}

#endif // defined(DBG) && defined(ENABLE_DEBUG_OUTPUT)



EXTERN_C void DbgPrt(IN DWORD dwDbgLevel, IN LPCSTR Format, IN ...)

{
	CHAR	Text	[0x200];
	va_list	Va;

	if (dwDbgLevel <= g_RegTraceFlags) {
		va_start (Va, Format);
		_vsnprintf (Text, 0x1FF, Format, Va);
		va_end (Va);

		if (Text [strlen (Text) - 1] != '\n')
			strcat (Text, "\n");

		OutputDebugStringA (Text);
	}
}

// LIFETIME_CONTROLLER  -------------------------------------------------------------------------

LIFETIME_CONTROLLER::LIFETIME_CONTROLLER (SYNC_COUNTER * AssocSyncCounter) {

	ReferenceCount = 0L;

	AssociatedSyncCounter = AssocSyncCounter;

	if (AssociatedSyncCounter)
		AssociatedSyncCounter -> Increment ();

#if ENABLE_REFERENCE_HISTORY
	InitializeCriticalSection (&ReferenceHistoryLock);

	if (AssociatedSyncCounter) {
		
		AssociatedSyncCounter -> Lock ();
		
		InsertTailList (&AssociatedSyncCounter -> ActiveLifetimeControllers, &ListEntry);

		AssociatedSyncCounter -> Unlock ();
	
	}
#endif // ENABLE_REFERENCE_HISTORY
}

LIFETIME_CONTROLLER::~LIFETIME_CONTROLLER () {

#if ENABLE_REFERENCE_HISTORY

	if (AssociatedSyncCounter) {
		
		AssociatedSyncCounter -> Lock ();

		RemoveEntryList(&ListEntry);

		AssociatedSyncCounter -> Unlock ();
	}

	DeleteCriticalSection(&ReferenceHistoryLock);
#endif // ENABLE_REFERENCE_HISTORY

	_ASSERTE (ReferenceCount == 0L);
}

void LIFETIME_CONTROLLER::AddRef (void) {

	LONG Count;

	_ASSERTE (ReferenceCount >= 0L);

	Count = InterlockedIncrement (&ReferenceCount);

#if ENABLE_REFERENCE_HISTORY
	MAKE_REFERENCE_HISTORY_ENTRY ();
#endif //ENABLE_REFERENCE_HISTORY

}

void LIFETIME_CONTROLLER::Release (void) {

	LONG	Count;

	Count = InterlockedDecrement (&ReferenceCount);

#if ENABLE_REFERENCE_HISTORY
	MAKE_REFERENCE_HISTORY_ENTRY ();
#endif // ENABLE_REFERENCE_HISTORY
	
	_ASSERTE (Count >= 0);

	if (Count == 0) {

		SYNC_COUNTER * LocalAssociatedSyncCounter;

		DBGOUT ((LOG_INFO, "LIFETIME_CONTROLLER::Release: *** DELETING SELF (I am %x) ***\n", this));

		LocalAssociatedSyncCounter = AssociatedSyncCounter;

		delete this;	

		if (LocalAssociatedSyncCounter)
			LocalAssociatedSyncCounter -> Decrement ();
	}
}


// SYNC_COUNTER -------------------------------------------------------------------------

SYNC_COUNTER::SYNC_COUNTER () {

	CounterValue = 0;
	ZeroEvent =  NULL;
}

SYNC_COUNTER::~SYNC_COUNTER () {

	assert (ZeroEvent == NULL);
}

HRESULT SYNC_COUNTER::Start (void)
{
	HRESULT Result = S_OK;

	assert (ZeroEvent == NULL);

	CounterValue = 1;

	ZeroEvent = CreateEvent (NULL, TRUE, FALSE, NULL);

	if (!ZeroEvent) {

		Result = GetLastError ();

		DebugLastError (_T("SYNC_COUNTER::SYNC_COUNTER: failed to create zero event\n"));
	}

#if ENABLE_REFERENCE_HISTORY
	Lock ();

	InitializeListHead (&ActiveLifetimeControllers);

	Unlock ();
#endif // ENABLE_REFERENCE_HISTORY

	return Result;
}

void SYNC_COUNTER::Stop (void)
{
	if (ZeroEvent) {
		ZeroEvent = NULL;
		CloseHandle (ZeroEvent);
	}
}


DWORD SYNC_COUNTER::Wait (DWORD Timeout)
{
	if (!ZeroEvent) {
		Debug (_T("SYNC_COUNTER::Wait: cannot wait because zero event could not be created\n"));
		return ERROR_GEN_FAILURE;
	}

	Lock();

	assert (CounterValue > 0);

	if (--CounterValue == 0) {
		if (ZeroEvent)
			SetEvent (ZeroEvent);
	}

	Unlock ();

#if	DBG

	if (Timeout == INFINITE) {

		DWORD	Status;

		for (;;) {

			Status = WaitForSingleObject (ZeroEvent, 5000);

			if (Status == WAIT_OBJECT_0)
				return ERROR_SUCCESS;

            assert (Status == WAIT_TIMEOUT);

			DebugF (_T("SYNC_COUNTER::Wait: thread %08XH is taking a long time to wait for sync counter, counter value (%d)\n"),
				GetCurrentThreadId(), CounterValue);
		}
	}
	else
		return WaitForSingleObject (ZeroEvent, Timeout);


#else

	return WaitForSingleObject (ZeroEvent, Timeout);

#endif
}

void SYNC_COUNTER::Increment (void)
{
	Lock();

/*	if (!CounterValue) {
		if (ZeroEvent)
			ResetEvent (ZeroEvent);
	} */

	CounterValue++;

	Unlock();
}

void SYNC_COUNTER::Decrement (void)
{
	Lock();

	assert (CounterValue > 0);

	if (--CounterValue == 0) {
		if (ZeroEvent)
			SetEvent (ZeroEvent);
	} 

	Unlock();
}



EXTERN_C void MergeLists (PLIST_ENTRY Result, PLIST_ENTRY Source)
{
	PLIST_ENTRY		Entry;

	// for now, we do a really sucky algorithm -- remove and insert every single object

	AssertListIntegrity (Source);
	AssertListIntegrity (Result);

	while (!IsListEmpty (Source)) {
		Entry = RemoveHeadList (Source);
		assert (!IsInList (Result, Entry));
		InsertTailList (Result, Entry);
	}
}

// check to see if entry is in list
EXTERN_C BOOL IsInList (LIST_ENTRY * List, LIST_ENTRY * Entry)
{
	LIST_ENTRY *	Pos;

	AssertListIntegrity (List);

	for (Pos = List -> Flink; Pos != List; Pos = Pos -> Flink)
		if (Pos == Entry)
			return TRUE;

	return FALSE;
}

EXTERN_C void ExtractList (LIST_ENTRY * Destination, LIST_ENTRY * Source)
{
	AssertListIntegrity (Source);

	InsertTailList (Source, Destination);
	RemoveEntryList (Source);
	InitializeListHead (Source);
}

EXTERN_C DWORD CountListLength (LIST_ENTRY * ListHead)
{
	LIST_ENTRY *	ListEntry;
	DWORD			Count;

	assert (ListHead);
	AssertListIntegrity (ListHead);

	Count = 0;

	for (ListEntry = ListHead -> Flink; ListEntry != ListHead; ListEntry++)
		Count++;

	return Count;
}

void AssertListIntegrity (LIST_ENTRY * list)
{
	LIST_ENTRY *	entry;

	assert (list);
	assert (list -> Flink -> Blink == list);
	assert (list -> Blink -> Flink == list);

	for (entry = list -> Flink; entry != list; entry = entry -> Flink) {
		assert (entry);
		assert (entry -> Flink -> Blink == entry);
		assert (entry -> Blink -> Flink == entry);
	}
}

NTSTATUS CopyAnsiString (
	IN	ANSI_STRING *	SourceString,
	OUT	ANSI_STRING *	DestString)
{
//	assert (SourceString);
//	assert (SourceString -> Buffer);
	assert (DestString);

	if (SourceString) {

		// it's really SourceString -> Length, not * sizeof (CHAR), so don't change it
		DestString -> Buffer = (LPSTR) HeapAlloc (GetProcessHeap(), 0, SourceString -> Length);

		if (DestString) {

			memcpy (DestString -> Buffer, SourceString -> Buffer, SourceString -> Length);

			// yes, maxlen = len, not maxlen = maxlen
			DestString -> MaximumLength = SourceString -> Length;
			DestString -> Length = SourceString -> Length;

			return STATUS_SUCCESS;
		}
		else {
			ZeroMemory (DestString, sizeof (ANSI_STRING));

			return STATUS_NO_MEMORY;
		}
	}
	else {
		DestString -> Buffer = NULL;
		DestString -> MaximumLength = 0;
		DestString -> Length = 0;
		
		return STATUS_SUCCESS;
	}
}

void FreeAnsiString (
	IN	ANSI_STRING *	String)
{
	assert (String);

	if (String -> Buffer) {
		HeapFree (GetProcessHeap(), 0, String -> Buffer);
		String -> Buffer = NULL;
	}
}

/*++

Routine Description:

    This function determines whether the IPv4 address passed to
	it belongs to an entity internal to the local subnet.

Arguments:
    
    sourceIPv4Address - IP address (in network order) of an entity, 
				for which the determination is to be made of whether it
				belongs to the local subnet.

Return Values:

    TRUE  - if the address specifies an entity internal to the local
		   subnet
	FALSE - if the address specifies an entity external to the local
		   subnet

--*/

BOOL IsInternalCallSource (
	IN	DWORD	IPAddress)			// HOST order
{
	return (IPAddress & RasSharedScopeMask) == (RasSharedScopeAddress & RasSharedScopeMask);
}

#if DBG

void ExposeTimingWindow (void) 
{
#if 0
	// this is here mostly to catch bug #393393, a/v on shutdown (race condition) -- arlied

	Debug (_T("H323: waiting for 10s to expose race condition... (expect assertion failure on g_NatHandle)\n"));

	DWORD Count;

	for (Count = 0; Count < 10; Count++) {
		assert (g_NatHandle);
		Sleep (1000);

	}

	Debug (_T("H323: finished waiting for race condition, looks normal...\n"));
#endif
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\testprogs\bindtest\bindtest.c ===
#define SECURITY_WIN32

#include <windows.h>
#include <stdio.h>
#include <winldap.h>

#include <rpc.h>
#include <rpcdce.h>


#include <security.h>



void __cdecl main (int argc, char* argv[])
{

   LDAP *ld;
   ULONG ldaperr, NumPkgs, i;
   SEC_WINNT_AUTH_IDENTITY_EXA newstruct;
   SEC_WINNT_AUTH_IDENTITY oldstruct;
   PSecPkgInfo pPkgInfo, index;

   ld = ldap_open("anoopa_srv", 389);

   if (ld) {

      printf("open succeeded\n");

   } else {

      printf("open failed\n");
      return;
   }


   EnumerateSecurityPackages( &NumPkgs, &pPkgInfo );


   for (i = 0; i<NumPkgs ; i++) {

      printf("%s, %s\n", pPkgInfo[i].Name, pPkgInfo[i].Comment);

   }

   printf("\n\n Trying bind with new style structure - ->");
   newstruct.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
   newstruct.Length = sizeof (SEC_WINNT_AUTH_IDENTITY_EXA);
   newstruct.User = NULL;
   newstruct.UserLength = 0;
   newstruct.Domain = NULL;
   newstruct.DomainLength = 0;
   newstruct.Password = NULL;
   newstruct.PasswordLength = 0;
   newstruct.PackageList = "NTLM";
   newstruct.PackageListLength = strlen("NTLM") ;
   newstruct.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

   ldaperr = ldap_bind_s(ld, NULL, (PCHAR) &newstruct, LDAP_AUTH_NEGOTIATE);

   if (ldaperr == LDAP_SUCCESS) {

      printf("bind succeeded\n");
   } else {

      printf("bind failed with 0x%x  0x%x\n", ldaperr, GetLastError);
//      return;
   }


   printf("Trying bind with old style struct - ->");

   oldstruct.User = "administrator";
   oldstruct.UserLength = strlen("administrator");
   oldstruct.Domain = "POLARIS";
   oldstruct.DomainLength = strlen("POLARIS");
   oldstruct.Password = "test";
   oldstruct.PasswordLength = strlen("test");
   oldstruct.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;


   ldaperr = ldap_bind_s(ld, NULL, NULL /*(PCHAR) &oldstruct*/, LDAP_AUTH_NEGOTIATE);

   if (ldaperr == LDAP_SUCCESS) {

      printf("bind succeeded\n");
   } else {

      printf("bind failed with 0x%x  0x%x\n", ldaperr, GetLastError);
      return;
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\test\ldapsrch.c ===
/*****************************************************************************

    ldapsrch.c

    This sample program was written to demonstrate how to traverse a tree
    using the LDAP API.  This is written to the LDAP API as specified in
    RFC 1823.

    Usage is :

        LDAPSRCH  HostName BaseDN UserName Password

     HostName is name of server to connect to.

     BaseDN is portion of tree to search.

     UserName is used during simple bind operation to login to DS.

     Password is used during simple bind operation... note this goes across
                as clear text.

*****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <winldap.h>

int __cdecl main( int   cArgs,
                   char  *pArgs[] )
{
    PCHAR pHost = NULL;
    PCHAR userDN = NULL;
    PCHAR password = NULL;
    PCHAR baseDN = NULL;

    LDAP *ldapConnection = NULL;
    INT err;
    LDAPMessage *results = NULL;
    PCHAR attributeList[3];
    LDAPMessage *message;
    PCHAR attribute;
    PVOID opaque;
    LONG msgId;
    struct l_timeval  TimeOut;
    PCHAR result1;
    PCHAR dn;

    //
    //  It's just a test program, so we won't do any checking or interesting
    //  parsing for the arguments, just grab them.
    //

    if (cArgs <= 1) {

        printf( "Usage : LdapSrch HostName [ BaseDN [ UserName [Password]]]\n");
        return 0;
    }

    pHost = pArgs[1];

    if (cArgs > 2) {

        baseDN = pArgs[2];
    }
    if (cArgs > 3) {

        userDN = pArgs[3];
    }
    if (cArgs > 4) {

        password = pArgs[4];
    }


    printf( "\nConnecting to server %s....\n", pHost );

    ldapConnection = ldap_open( pHost, 0 );

    if ( ldapConnection == NULL ) {

        printf( "ldapConnection failed with 0x%x.\n", GetLastError() );
        return 0;
    }



    //
    //  Now we'll bind with the credentials passed in.  Null is valid.
    //

    printf( "Binding with userName %s, password %s....\n", userDN, password );
    err = ldap_simple_bind_s( ldapConnection, userDN, password );

    printf( "simple bind returned 0x%x\n", err );



    //
    //  we'll try a synchronous search for attributes CN and OBJECTCLASS
    //
    //  if you want to get all attributes, send in NULL for attributeList.
    //

    attributeList[0] = "cn";
    attributeList[1] = "objectClass";
    attributeList[2] = NULL;

    err = ldap_search_s(    ldapConnection,
                            baseDN,
                            LDAP_SCOPE_SUBTREE,     // whole tree
                            "(objectClass=*)",      // filter is all objects
                            &attributeList[0],      // list of attributes
                            0,
                            &results                // gets results
                            );

    printf( "search tree returned 0x%x\n", err );



    if (results != NULL) {

        //
        //  Display the results of the LDAP search.  This prints out all
        //  attributes for each entry.
        //

        message = ldap_first_entry( ldapConnection, results );

        while (message != NULL) {

            dn = ldap_get_dn( ldapConnection, message );

            printf( "Distinguished Name is : %s\n", dn );

            ldap_memfree( dn );

            attribute = ldap_first_attribute( ldapConnection,
                                              message,
                                              &opaque
                                              );

            while (attribute != NULL) {

                PCHAR *value = NULL;

                value = ldap_get_values(    ldapConnection,
                                            message,
                                            attribute
                                            );

                if (ldap_count_values(value) > 1) {

                    ULONG count, total;

                    printf( "Attribute %s is :\n", attribute );

                    total = ldap_count_values(value);

                    for (count = 0; count < total; count++ ) {
                        printf( "\t%s\n", value[count] );
                    }

                } else {

                    printf( "Attribute %s is %s\n", attribute, *value );
                }

                ldap_value_free( value );

                attribute = ldap_next_attribute(  ldapConnection,
                                                  message,
                                                  opaque
                                                  );
            }

            message = ldap_next_entry( ldapConnection, message );
        }

        ldap_msgfree( results );
    }

    if (ldapConnection) {

        ldap_unbind( ldapConnection );
    }

    return 0;

}   // LdapSrch main
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\testprogs\bertest\repl.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <winldap.h>
#include <winber.h>


void __cdecl main (int argc, char* argv[])
{

/*

replControl ::= SEQUENCE {
		controlType		1.2.840.113556.1.4.7000.74,
		criticality		BOOLEAN DEFAULT FALSE,
		controlValue	replControlValue
}

The replControlValue is an OCTET STRING wrapping the BER-encoded version 
of the following SEQUENCE:

realReplControlValue ::= SEQUENCE {
		flags			int,
		cookie			OCTET STRING
}

The client may regard the cookie as opaque. Currently, the cookie is an 
OCTET STRING wrapping the binary buffer equivalent to the content of the 
following C structure (with 8 byte alignment).

struct {
		ULONG			ulVersion;			
		USN_VECTOR		usnVec;
		UPTODATE_VECTOR	upToDateVecSrc;
}	

*/

   LDAPControl *preplControl;

   err = ldap_create_repl_control(
                                  1,      // flags
                                  NULL,   // Cookie
                                  0,      // Cookie size
                                  TRUE,   // Criticality
                                  &preplControl  // New control
                                  );


}

ULONG
ldap_create_repl_control (
     ULONG           flags,
     BYTE           *Cookie,
     ULONG           CookieSize,
     UCHAR           IsCritical,
     PLDAPControl   *Control,
     )
{

    ULONG err;
    BOOLEAN criticality = ( (IsCritical > 0) ? TRUE : FALSE );
    PLDAPControl  control = NULL;
    CLdapBer *lber = NULL;
    PLDAP_CONN connection = NULL;
    BerElement berE;
    BERVAL *pBerval;

    if (Control == NULL) {

        return LDAP_PARAM_ERROR;
    }

    control = (PLDAPControl) malloc( sizeof( LDAPControlW ) );

    if (control == NULL) {

        *Control = NULL;
        return LDAP_NO_MEMORY;
    }

    control->ldctl_iscritical = criticality;

    control->ldctl_oid = "1.2.840.113556.1.4.7000.74";
    
    err = ber_printf( berE, "{i", flags);

    if (err != LDAP_SUCCESS) {

        goto exitEncodeReplControl;
    }

    if ((Cookie != NULL) &&
        (CookieSize > 0)  {

       //
       // Encode the cookie and end the sequence
       //

       err = ber_printf( berE, "o}", &Cookie, CookieSize );
    
    } else {

       //
       // Put in a null value and end the sequnce
       //

       err = ber_printf( berE, "n}" );
    }

    if (err != LDAP_SUCCESS) {

        goto exitEncodePagedControl;
    }

    //
    // Pull data from the BerElement into a berval
    //

    err = ber_flatten(ber, &pBerval);
    
exitEncodeReplControl:

    if (err != LDAP_SUCCESS) {

        free( control );
        control = NULL;
    }

    *Control = control;
    return err;
}


ULONG
LdapParseReplControl (
                      PLDAPControlW  *ServerControls,
                      ULONG          *TotalCount,
                      struct berval  **Cookie,
)
{


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\testprogs\cisco\ibm.c ===
#define SECURITY_WIN32

#include <windows.h>
#include <stdio.h>
#include <winldap.h>
#include <rpc.h>
#include <rpcdce.h>
#include <security.h>

//
// Sample code to allow binding to non Active Directory servers
// which support Kerberos v5. 
// 
//

void __cdecl main (int argc, char* argv[])
{

   LDAP *ld;
   ULONG ldaperr;
   SEC_WINNT_AUTH_IDENTITY oldstruct;
   PCHAR option = "GSSAPI";

   if (argc != 2) {
      printf("Usage: %s <hostname>\n", argv[0]);
      return;
   }

   ld = ldap_open(argv[1], 389);

   if (ld) {

      printf("open succeeded\n");

   } else {

      printf("open failed\n");
      return;
   }


   //
   // Fill in the appropriate credentials here.
   //

   oldstruct.User = "administrator";
   oldstruct.UserLength = strlen("administrator");
   oldstruct.Domain = "michratst2dom";
   oldstruct.DomainLength = strlen("michratst2dom");
   oldstruct.Password = "secret";
   oldstruct.PasswordLength = strlen("secret");
   oldstruct.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

   ldaperr = ldap_set_option(ld, LDAP_OPT_SASL_METHOD, &option);

   if (ldaperr == LDAP_SUCCESS) {

      printf("sasl opt succeeded\n");
   } else {

      printf("sasl opt failed with 0x%x  0x%x\n", ldaperr, GetLastError);
      return;
   }

   ldaperr = ldap_bind_s(ld, NULL, /*NULL*/ (PCHAR) &oldstruct, LDAP_AUTH_NEGOTIATE);

   if (ldaperr == LDAP_SUCCESS) {

      printf("bind succeeded\n");
   } else {

      printf("bind failed with 0x%x  0x%x\n", ldaperr, GetLastError);
      return;
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\testprogs\crossforest\crossforest.c ===
#define SECURITY_WIN32

#include <windows.h>
#include <stdio.h>
#include <winldap.h>

#include <rpc.h>
#include <rpcdce.h>


#include <security.h>



void __cdecl main (int argc, char* argv[])
{

   LDAP *ld;
   ULONG ldaperr;
   PCHAR DnsDomainName = "ntdev.microsoft.com";

   ld = ldap_open("ntdsdcb.ntdev.microsoft.com", 389);

   if (ld) {

      printf("open succeeded\n");

   } else {

      printf("open failed, gle is 0x%x, ldapgle is 0x%x\n", GetLastError(), LdapGetLastError());
      return;
   }

   ldaperr = ldap_set_option( ld, LDAP_OPT_DNSDOMAIN_NAME, &DnsDomainName );

   if (ldaperr == LDAP_SUCCESS) {

      printf("ldap_set_option succeeded\n");
   } else {

      printf("ldap_set_option failed with 0x%x,  0x%x\n", ldaperr, GetLastError());
      return;
   }
   
   ldaperr = ldap_bind_s(ld, NULL, NULL, LDAP_AUTH_NEGOTIATE);

   if (ldaperr == LDAP_SUCCESS) {

      printf("bind succeeded\n");
   } else {

      printf("bind failed with 0x%x,  0x%x\n", ldaperr, GetLastError());
      return;
   }

   ldap_unbind( ld );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\testprogs\explode\explode.c ===
#define UNICODE

#include <stdio.h>
#include <windows.h>
#include <winldap.h>

void __cdecl 
   main (int argc, char* argv[])
{
   WCHAR **ppchar = NULL;
   int i;

   ppchar = ldap_explode_dn( L"fred= ", 0);

   if (ppchar != NULL) {

      fprintf(stderr, "Exploded value -->\n");
      
      for (i= 0; ppchar[i] != NULL; i++) {
         
         fprintf(stderr, "%S\n", ppchar[i]);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\testprogs\digest\digest.c ===
#define SECURITY_WIN32

#include <windows.h>
#include <stdio.h>
#include <winldap.h>

#include <rpc.h>
#include <rpcdce.h>


#include <security.h>



void __cdecl main (int argc, char* argv[])
{

   LDAP *ld;
   ULONG ldaperr, NumPkgs, i;
   SEC_WINNT_AUTH_IDENTITY_EXA newstruct;
   SEC_WINNT_AUTH_IDENTITY oldstruct;
   PSecPkgInfo pPkgInfo, index;
   DWORD option = (DWORD) LDAP_OPT_ON;
   LDAPMessage* presult = NULL; 

   ld = ldap_open("rrandall-t2", 389);

   if (ld) {

      printf("open succeeded\n");

   } else {

      printf("open failed\n");
      return;
   }

   EnumerateSecurityPackages( &NumPkgs, &pPkgInfo );

   for (i = 0; i<NumPkgs ; i++) {

      printf("%s, %s\n", pPkgInfo[i].Name, pPkgInfo[i].Comment);

   }

   printf("Trying bind with current creds - ->");


   oldstruct.User = "testdigest";
   oldstruct.UserLength = strlen("testdigest");
   oldstruct.Domain = "rrandall2.nttest.microsoft.com";
   oldstruct.DomainLength = strlen("rrandall2.nttest.microsoft.com");
   oldstruct.Password = "";
   oldstruct.PasswordLength = 0;
   oldstruct.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

//#if 0

   ldaperr = ldap_set_option(ld, LDAP_OPT_ENCRYPT, &option);

   if (ldaperr == LDAP_SUCCESS) {

       printf("seal opt succeeded\n");
   
   } else {

       printf("seal opt failed with 0x%x \n", ldaperr);
       return;
   }

//#endif

   ldaperr = ldap_bind_s(ld, NULL, (PCHAR) &oldstruct, LDAP_AUTH_DIGEST);

   if (ldaperr == LDAP_SUCCESS) {

      printf("bind succeeded\n");
   } else {

      printf("bind failed with 0x%x  0x%x\n", ldaperr, GetLastError);
      return;
   }

   ldaperr = ldap_search_s( ld,
                            NULL,      // dn
                            LDAP_SCOPE_BASE,
                            NULL,       // filter
                            NULL,       // attrlist
                            0,          // attrs only
                            &presult);

   if (ldaperr == LDAP_SUCCESS) {

      printf("RootDSE search succeeded\n");
   } else {

      printf("RootDSE search failed with 0x%x  0x%x\n", ldaperr, GetLastError);
      return;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\testprogs\cisco\gss.c ===
#define SECURITY_WIN32

#include <windows.h>
#include <stdio.h>
#include <winldap.h>

#include <rpc.h>
#include <rpcdce.h>


#include <security.h>



void __cdecl main (int argc, char* argv[])
{

   LDAP *ld;
   ULONG ldaperr, NumPkgs, i;
   SEC_WINNT_AUTH_IDENTITY_EXA newstruct;
   SEC_WINNT_AUTH_IDENTITY oldstruct;
   PSecPkgInfo pPkgInfo, index;
   PCHAR option = "GSSAPI";
   LDAPMessage message;

   if (argc != 2) {
      printf("Usage: %s <hostname>\n", argv[0]);
      return;
   }

   ld = ldap_open(argv[1], 389);

   if (ld) {

      printf("open succeeded\n");

   } else {

      printf("open failed\n");
      return;
   }

/*
   EnumerateSecurityPackages( &NumPkgs, &pPkgInfo );


   for (i = 0; i<NumPkgs ; i++) {

      printf("%s, %s\n", pPkgInfo[i].Name, pPkgInfo[i].Comment);

   }
   
   printf("\n\n Trying bind with old style structure - ->");

oldstruct.User = "administrator";
oldstruct.UserLength = strlen("administrator");
oldstruct.Domain = "michratst2dom";
oldstruct.DomainLength = strlen("michratst2dom");
oldstruct.Password = "";
oldstruct.PasswordLength = strlen("");
oldstruct.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

*/

   ldaperr = ldap_set_option(ld, LDAP_OPT_SASL_METHOD, &option);

   if (ldaperr == LDAP_SUCCESS) {

      printf("sasl opt succeeded\n");
   } else {

      printf("sasl opt failed with 0x%x  0x%x\n", ldaperr, GetLastError);
      return;
   }

   ldaperr = ldap_bind_s(ld, NULL, NULL /*(PCHAR) &oldstruct*/, LDAP_AUTH_PREFERRED);

   if (ldaperr == LDAP_SUCCESS) {

      printf("bind succeeded\n");
   } else {

      printf("bind failed with 0x%x  0x%x\n", ldaperr, GetLastError);
      return;
   }

   ldaperr = ldap_search_s(ld,
                           NULL,
                           LDAP_SCOPE_BASE,
                           NULL,
                           NULL,
                           0,
                           &message
                           );

   if (ldaperr == LDAP_SUCCESS) {

      printf("RootDSE search succeeded\n");
   } else {

      printf("RootDSE search failed with 0x%x  0x%x\n", ldaperr, GetLastError);
      return;
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\testprogs\certtest\certtest.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <winldap.h>

#define SECURITY_WIN32 1
#include <sspi.h>
#include <schnlsp.h>


QUERYCLIENTCERT CertCallback;

PCCERT_CONTEXT  pCertContext = NULL;

void __cdecl main (
                   int argc,
                   char *argv[] )
{
   int retval;
   PLDAP pldap;
   SecPkgContext_ConnectionInfo  sslattr;

   //
   // Register the callbacks with wldap32.dll
   //

   if (argc != 2) {

      printf("Usage: %s <hostname> \n", argv[0]);
      return;
   }

   pldap = ldap_sslinit(argv[1], LDAP_SSL_PORT, 1 );

   if (pldap == NULL) {

      fprintf(stderr, "ldapsslinit failed with %d\n", GetLastError() );
      return;
   }

   retval = ldap_set_option( pldap, LDAP_OPT_CLIENT_CERTIFICATE, CertCallback );

   fprintf( stderr, "ldap_set_option client cert returned %x\n", retval );

   retval = ldap_connect( pldap, NULL );

   //
   // Free the cert context.
   //

   if (pCertContext) {
       CertFreeCertificateContext( pCertContext );
   }

   fprintf( stderr, "\nldap_connect returned %d\n", retval );

   retval = ldap_get_option( pldap, LDAP_OPT_SSL_INFO, &sslattr );

   if (retval != LDAP_SUCCESS) {

      fprintf( stderr, "ldap_get_option with SSL info failed %x\n", retval );
   } else {

      fprintf(stderr, "\nSSL Cipher strength is : %d\n", sslattr.dwCipherStrength);
   }

   fprintf(stderr, "\nHit any key to break connection\n");
   getchar();
   ldap_unbind( pldap );
}



//
// In our callback function, we dig up a client certificate and give it back.
//
BOOLEAN
_cdecl CertCallback (
              PLDAP Connection,
              PSecPkgContext_IssuerListInfoEx trusted_CAs,
              PCCERT_CONTEXT *ppCertificate
              )
{
   UINT i;
   PCERT_NAME_BLOB temp;
   PCCERT_CHAIN_CONTEXT pChainContext = NULL;
   char   arr[500];
   CERT_CHAIN_FIND_BY_ISSUER_PARA FindByIssuerPara = {0};
   HCERTSTORE      hMyCertStore = NULL;

   
   fprintf( stderr, "Server is demanding a client cert issued by:\n");
   
   for (i=0, temp = trusted_CAs->aIssuers; i<trusted_CAs->cIssuers ; i++) {

        if (trusted_CAs->aIssuers == NULL) {
            fprintf(stderr, "Bug in John Banes code \n");
            return FALSE;
        }

        CertNameToStr( X509_ASN_ENCODING,
                       &temp[i],
                       CERT_SIMPLE_NAME_STR,
                       arr,
                       500
                       );

        fprintf(stderr, "%d. %s\n", i+1, arr);
    }

    
    hMyCertStore = CertOpenSystemStore(0, "MY");

    if(!hMyCertStore)
    {
        printf("**** Error 0x%x returned by CertOpenSystemStore\n", GetLastError());
        return FALSE;
    }

      
    //
    // Enumerate the available client certificates.
    //

    FindByIssuerPara.cbSize = sizeof(FindByIssuerPara);
    FindByIssuerPara.pszUsageIdentifier = szOID_PKIX_KP_CLIENT_AUTH;
    FindByIssuerPara.dwKeySpec = 0;
    FindByIssuerPara.cIssuer   = trusted_CAs->cIssuers;
    FindByIssuerPara.rgIssuer  = trusted_CAs->aIssuers;

    // Find a certificate chain.
    pChainContext = CertFindChainInStore(hMyCertStore,
                                         X509_ASN_ENCODING,
                                         0,
                                         CERT_CHAIN_FIND_BY_ISSUER,
                                         &FindByIssuerPara,
                                         pChainContext);
    if(pChainContext == NULL)
    {
        printf("Error 0x%x finding cert chain\n", GetLastError());
        return FALSE;
    }
    
    printf("\n Client certificate chain found\n");

    // Get pointer to leaf certificate context.
    pCertContext = pChainContext->rgpChain[0]->rgpElement[0]->pCertContext;

    *ppCertificate = pCertContext;

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\testprogs\certtest\new.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <winldap.h>

#define SECURITY_WIN32 1
#include <sspi.h>
#include <schnlsp.h>


#define CHAIN_BUFFER_SIZE           0x10000
#define CB_SSL3_ISSUER_LENGTH           2


//QUERYCLIENTCERT CertCallback;

//VERIFYSERVERCERT ServerCertCallback;

BOOLEAN
_cdecl CertCallback (
              PLDAP Connection,
              PSecPkgContext_IssuerListInfoEx trusted_CAs,
              HCERTSTORE hCertStore,
//              PCCERT_CONTEXT **pppaCred,
              DWORD *pcCreds
              );


BOOLEAN
_cdecl NewCertCallback (
              PLDAP Connection,
              PSecPkgContext_IssuerListInfo trusted_CAs,
              PCERT_CONTEXT **pppaCred,
              DWORD *pcCreds
              );

BOOLEAN
_cdecl ServerCertCallback (
                    PLDAP Connection,
                    PCCERT_CONTEXT pServerCert
                    );


void __cdecl main (
                   int argc,
                   char *argv[] )
{
   int retval;
   PLDAP pldap;
   SecPkgContext_ConnectionInfo  sslattr;

   //
   // Register the callbacks with wldap32.dll
   //

   if (argc != 3) {

      printf("Usage: %s <hostname> <port#> \n", argv[0]);
      return;
   }

   pldap = ldap_sslinit(argv[1], atoi( argv[2] ), 1 );

   if (pldap == NULL) {

      fprintf(stderr, "ldapsslinit failed with %d\n", GetLastError() );
      return;
   }

   retval = ldap_set_option( pldap, LDAP_OPT_CLIENT_CERTIFICATE, CertCallback );

//   fprintf( stderr, "ldap_set_option client cert returned %x\n", retval );

//   retval = ldap_set_option( pldap, LDAP_OPT_SERVER_CERTIFICATE, ServerCertCallback );

//   fprintf( stderr, "ldap_set_option server cert returned %x\n", retval );

   retval = ldap_connect( pldap, NULL );

   fprintf( stderr, "ldap_connect returned %d\n", retval );

   retval = ldap_get_option( pldap, LDAP_OPT_SSL_INFO, &sslattr );

   if (retval != LDAP_SUCCESS) {

      fprintf( stderr, "ldap_get_option with SSL info failed %x\n", retval );
   } else {

      fprintf(stderr, "SSL Cipher strength is : %d\n", sslattr.dwCipherStrength);
      fprintf(stderr, "SSL Key exchange strength is : %d\n", sslattr.dwExchStrength);

   }

   fprintf(stderr, "Hit ENTER to break connection\n");
   getchar();
}



//
// In our callback function, we dig up a client certificate and give it back.
//
BOOLEAN
_cdecl CertCallback (
              PLDAP Connection,
              PSecPkgContext_IssuerListInfoEx trusted_CAs,
              HCERTSTORE hCertStore,              
              DWORD *pcCreds
              )
{

   UINT i, j, k;
   DWORD cCerts = 0; 
   DWORD cbCertChain = CHAIN_BUFFER_SIZE;
   BYTE   mine[5000];     
   PCERT_CHAIN  pCertChain = (PCERT_CHAIN) mine;
   PCCERT_CONTEXT  pCert_Context;
   DWORD cCertContexts = 0;
   HRESULT  result;
   PCERT_NAME_BLOB temp;
   DWORD           cbIssuer;
   PBYTE           pbIssuer;
   char   arr[500];
   HCERTSTORE hMyCertStore;
   
   fprintf( stderr, "Server is demanding a client cert \n");
   fprintf( stderr, "List of %d server-trusted CAs - - ->\n\n", trusted_CAs->cIssuers );

   *pcCreds = 0;

   for (i=0, temp = trusted_CAs->aIssuers; i<trusted_CAs->cIssuers ; i++) {

      if (trusted_CAs->aIssuers == NULL) {
         fprintf(stderr, "Bug in John Banes code \n");
         return FALSE;
      }
      CertNameToStr( X509_ASN_ENCODING,
                     &temp[i],
                     CERT_SIMPLE_NAME_STR,
                     arr,
                     500
                     );

      fprintf(stderr, "%d. %s\n", i+1, arr);

   }


   k = 0;

   // Create personal in-memory certificate store.


   hMyCertStore = CertOpenStore(CERT_STORE_PROV_MEMORY,
                              X509_ASN_ENCODING,
                              0,
                              0, //CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG
                              NULL);
   if(hMyCertStore == NULL)
   {
      fprintf( stderr, "certopenstore failed: %x\n", GetLastError() );
      return FALSE;

   }

   do
   {
       //
       // Get name of first issuer.
       //
 
       temp = trusted_CAs->aIssuers;
       pbIssuer = temp[k].pbData;
       cbIssuer = temp[k].cbData;

       k++;
       //
       // Search the MY store for one or more certificate chains matching
       // this issuer.
       //
 
       cbCertChain = CHAIN_BUFFER_SIZE;
       if(FindCertsByIssuer(pCertChain,
                               &cbCertChain,
                               &cCerts,
                               pbIssuer,
                               cbIssuer,
                               L"ClientAuth", // alternative is L"CodeSigning"
                               AT_KEYEXCHANGE))
       {
 
          fprintf( stderr, "FindCertsByIssuer failed : %x\n", GetLastError() );
          continue;
       } else {
 
          fprintf( stderr, "FOUND %d MATCHING CERT CHAIN WITH %d BYTES...\n", cCerts, cbCertChain );
 
       }
 
       if (!pCertChain) {

          fprintf( stderr, "Certchain is null\n");
          return FALSE;
       }
 if(cCerts == 0 || cbCertChain == 0)
 {
     // No matching cert chains found.
     continue;
 }
 
 //
 // Add each cert chain to the list.
 //
 
 for(i = 0; i < cCerts; i++)
 {
     for(j = 0; j < pCertChain[i].cCerts; j++)
     {
         // Add certificate to store.
 
        fprintf( stderr, " Adding cert to in-memory store\n");
 
         if(!CertAddEncodedCertificateToStore(
                                 hMyCertStore,
                                 X509_ASN_ENCODING,
                                 pCertChain[i].certs[j].pbData,
                                 pCertChain[i].certs[j].cbData,
                                 CERT_STORE_ADD_REPLACE_EXISTING,
                                 &pCert_Context))
         {
            fprintf( stderr, "certaddencodedcerttostore failed: %x\n", GetLastError() );
             goto done;
         }

         if(j == 0)
         {
             // Set KeyProvInfo property.
             if(!CertSetCertificateContextProperty(
                                 pCert_Context,
                                 CERT_KEY_PROV_INFO_PROP_ID,
                                 0,
                                 &pCertChain[i].keyLocatorInfo))
                     {
                           fprintf( stderr, "certsetcertificateContextproperty failed: %x\n", GetLastError() );
                           continue;
                     }
         //
         // Add the certcontext to the certstore
         //
         if(!CertAddCertificateContextToStore(
                                          hCertStore,
                                          pCert_Context,
                                          CERT_STORE_ADD_REPLACE_EXISTING,
                                          NULL))
                  {
                     fprintf( stderr, "certaddcontexttostore failed: %x\n", GetLastError() );
                     return FALSE;
                  }
                  (*pcCreds)++;
     }
   }
 }
} while(k<trusted_CAs->cIssuers);


      if (*pcCreds == 0) {
      
         fprintf (stderr, "\nDid not find an appropriate cert\n" );
         return FALSE;
      }
      
      fprintf(stderr, "Returning %d  CREDS\n", *pcCreds);
      
      return TRUE; 
      
      done:
      
          // Free WinTrust cert chain list memory.
          LocalFree(pCertChain);
      
          if(hCertStore) CertCloseStore(hCertStore, 0);
      
          fprintf (stderr, "\nDid not find an appropriate cert\n");
      
         return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\testprogs\ibm\ibm.c ===
#define SECURITY_WIN32

#include <windows.h>
#include <stdio.h>
#include <winldap.h>
#include <rpc.h>
#include <rpcdce.h>
#include <security.h>

//
// Sample code to allow binding to non Active Directory servers
// which support Kerberos v5. 
// 
//

void __cdecl main (int argc, char* argv[])
{

   LDAP *ld;
   ULONG ldaperr;
   SEC_WINNT_AUTH_IDENTITY oldstruct;
   PCHAR option = "GSSAPI";

   if (argc != 2) {
      printf("Usage: %s <hostname>\n", argv[0]);
      return;
   }

   ld = ldap_open(argv[1], 389);

   if (ld) {

      printf("open succeeded\n");

   } else {

      printf("open failed\n");
      return;
   }


   //
   // Fill in the appropriate credentials here.
   //

   oldstruct.User = "administrator";
   oldstruct.UserLength = strlen("administrator");
   oldstruct.Domain = "michratst2dom";
   oldstruct.DomainLength = strlen("michratst2dom");
   oldstruct.Password = "secret";
   oldstruct.PasswordLength = strlen("secret");
   oldstruct.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

   ldaperr = ldap_set_option(ld, LDAP_OPT_SASL_METHOD, &option);

   if (ldaperr == LDAP_SUCCESS) {

      printf("sasl opt succeeded\n");
   } else {

      printf("sasl opt failed with 0x%x  0x%x\n", ldaperr, GetLastError);
      return;
   }

   ldaperr = ldap_bind_s(ld, NULL, /*NULL*/ (PCHAR) &oldstruct, LDAP_AUTH_NEGOTIATE);

   if (ldaperr == LDAP_SUCCESS) {

      printf("bind succeeded\n");
   } else {

      printf("bind failed with 0x%x  0x%x\n", ldaperr, GetLastError);
      return;
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\testprogs\dns\dns.cpp ===
#define UNICODE
#define _UNICODE

#define SECURITY_WIN32

#include <windows.h>
#include <windns.h>
#include <stdio.h>
#include <rpc.h>
#include <rpcdce.h>
#include <security.h>
#include <winsock.h>

void __cdecl main(int argc, char* argv[])
{ 
    LPWSTR   wDomain = TEXT("pss-netapi"), wName = TEXT("test"), wPassword = TEXT("testpuffer");
    DNS_STATUS status;
    SEC_WINNT_AUTH_IDENTITY_W credentials;
    HANDLE      secHandle = NULL;
    PDNS_RECORD pmyDnsRecord = {0};
    PIP4_ARRAY pSrvList = {0};
  
        
        credentials.User = wName;
        credentials.Domain =wDomain;
        credentials.Password = wPassword;
        credentials.UserLength = wcslen(wName);
        credentials.DomainLength = wcslen(wDomain);
        credentials.PasswordLength = wcslen(wPassword);
        credentials.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        status = DnsAcquireContextHandle_W(
                        0,  // credential flags
                        &credentials,
                        &secHandle);
        if(status) 
        {
            printf("Could not aquire credentials %d \n", 
                    status);
            return;
        
        } else if(!secHandle) {

                printf("DnsAcquireContextHandle returned success but handle is NULL\n");
                return;
                
            }

            else 
            {
                printf("DnsAcquireContextHandle returned successful \n");
            }

            WCHAR buf[] = L"w2kplain.argali.pss-netapi.microsoft.com";
            printf("starting the function \n");


            pmyDnsRecord = (PDNS_RECORD) LocalAlloc( LPTR, sizeof( DNS_RECORD ) );
            pSrvList = (PIP4_ARRAY) LocalAlloc(LPTR,sizeof(IP4_ARRAY));
            pmyDnsRecord->pName = LPTSTR(buf); 
            pmyDnsRecord->wType = DNS_TYPE_A;
            pmyDnsRecord->wDataLength = sizeof(DNS_A_DATA);
        //  myDnsRecord.Flags.DW DNSREC_UPDATE;
            pmyDnsRecord->dwTtl = 360;
            pmyDnsRecord->Data.A.IpAddress = inet_addr("157.239.61.54");
            pSrvList->AddrCount = 1;
            pSrvList->AddrArray[0] = inet_addr("157.239.61.58");

            printf("done\n");

        
        status = DnsModifyRecordsInSet_W(pmyDnsRecord,
                                    NULL,
                                    DNS_UPDATE_SECURITY_OFF,
                                    secHandle,
                                    pSrvList,
                                    NULL);

            if (status)
            {
                printf("Couldn't add records %d \n",status);
            }

            else 
            {
                printf("Added records successfully \n");
            }

            LocalFree(pmyDnsRecord);
            LocalFree(pSrvList);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\testprogs\filtertest\filter.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <winldap.h>


void __cdecl main (int argc, char *argv[])
{
  LDAP *pldap;
  ULONG retval;
  LDAPMessage *msg;
  PCHAR attrs[] = {'cn', NULL };


  pldap = ldap_init( argv[1], 389);

  if ( pldap == NULL) {

     fprintf( stderr, "ldap_init failed with %d\n", GetLastError());
     return;
  }

  retval = ldap_check_filterA( pldap, argv[2]);

  if (retval != LDAP_SUCCESS) {

     fprintf( stderr, "Bad filter\n" );
  } else {
     
     fprintf( stderr, "Good filter\n" );

     retval = ldap_search_s( pldap,
                             NULL,
                             LDAP_SCOPE_BASE,
                             argv[1],
                             NULL,
                             0,
                             &msg
                             );
     if (retval != LDAP_SUCCESS) {

        fprintf( stderr, "search failed with retval of 0x%x\n", retval );
        return;
     }

     fprintf( stderr, "search succeeded\n");

  }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\testprogs\tls\tls.c ===
#include <windows.h>
#include <stdio.h>
#include <winldap.h>

//
// Sample code to illustrate StartTLS operations.
//

void __cdecl main (int argc, char* argv[])
{

   LDAP *ld;
   ULONG ldaperr;
   ULONG retval;
   ULONG ttl;
   PLDAPControl txcontrol;
   LDAPAPIInfo info;
   PCHAR *temp;
   PLDAPMessage presult;
   int i = 0;
   PCHAR attrList[2] = { "cn", NULL };
   PLDAPControl controlArray[2];
   PLDAPControl *servercontrols;
   ULONG ServerError;

/*
   if (argc != 2) {
      printf("Usage: %s <hostname>\n", argv[0]);
      return;
   }
*/
   ld = ldap_open(argv[1]? argv[1] : "rrandall-t1.rrandall.nttest.microsoft.com",
                   389);

   if (ld) {

      printf("open succeeded\n");

   } else {

      printf("open failed\n");
      return;
   }


   info.ldapai_info_version = LDAP_API_INFO_VERSION;

   ldaperr = ldap_get_option( ld, LDAP_OPT_API_INFO, &info );
   
   if (ldaperr == LDAP_SUCCESS) {

      printf("api   version: %d\n", info.ldapai_api_version );
      printf("info  version: %d\n", info.ldapai_info_version );
      printf("vendor   name: %s\n", info.ldapai_vendor_name );
      printf("vendor    ver: %d\n", info.ldapai_vendor_version );
      printf("protocol  ver: %d\n", info.ldapai_protocol_version );
      temp = info.ldapai_extensions;
      
      while (temp[i]) {
          LDAPAPIFeatureInfo extrainfo;

          printf("\tExtn name: %s\n", temp[i]);
          extrainfo.ldapaif_info_version = LDAP_FEATURE_INFO_VERSION;
          extrainfo.ldapaif_name = temp[i];
          extrainfo.ldapaif_version = 0;
          ldaperr = ldap_get_option(ld, LDAP_OPT_API_FEATURE_INFO, &extrainfo);
          if (ldaperr != LDAP_SUCCESS) {
              printf("Error in extra info option 0x%x\n", ldaperr);
              return;
          }
          printf("\tExtn ver: %d\n\n", extrainfo.ldapaif_version );
          i++;
      }

      ldap_memfree( info.ldapai_vendor_name );
      ldap_value_free( info.ldapai_extensions );
   } else {

      printf("info failed with 0x%x  0x%x\n", ldaperr, GetLastError());
      return;
   }

   //
   // Set the connection option to v3
   //

   ldaperr = ldap_set_option( ld, LDAP_OPT_VERSION, (PVOID) LDAP_VERSION3 );

   if (ldaperr == LDAP_SUCCESS) {

       printf("Set version to v3\n");
   
   } else {

       printf("Failed to set version to v3 with 0x%x  0x%x\n", ldaperr, GetLastError());
       return;
   }

   //
   // Initiate TLS on the connection.
   //

   ldaperr = ldap_start_tls_s( ld,
                               &retval,
                               NULL,     //res
                               NULL,     // server ctrls
                               NULL      // client ctrls
                               );


   if (ldaperr == LDAP_SUCCESS) {

       printf("Start TLS succeeded\n");
   
   } else {

       printf("Start TLS failed with 0x%x, server returns 0x%x\n", ldaperr, retval);
       return;
   }

/*
   //
   // Perform an EXTERNAL bind.
   //

   ldaperr = ldap_bind_s(ld,
                         "dn:cn=administrator,cn=users,dc=rrandall-t1,dc=rrandall,dc=nttest,dc=microsoft,dc=com",
                         NULL,              // credentials
                         LDAP_AUTH_EXTERNAL // auth type
                         );

   if (ldaperr == LDAP_SUCCESS) {

      printf("external bind succeeded\n\n");
   } else {

      printf("external bind failed with 0x%x  0x%x\n", ldaperr, LdapGetLastError());
      return;
   }
   
 */ 
   //
   // Perform an encrypted simple search
   //

   ldaperr = ldap_search_ext_s( ld,
                                "DC=rrandall,DC=nttest,DC=microsoft,DC=com",
                                LDAP_SCOPE_ONELEVEL,
                                NULL,
                                attrList,
                                FALSE,
                                NULL,
                                NULL,    // client control
                                NULL,
                                0,
                                &presult
                                );

   if (ldaperr == LDAP_SUCCESS) {

      printf("Search succeeded\n\n");
   } else {

      printf("Search failed with 0x%x  0x%x\n", ldaperr, LdapGetLastError());
      return;
   }

   printf("Got back %d entries\t", ldap_count_entries(ld, presult));
   
   ldaperr = ldap_result2error( ld,
                                presult,
                                TRUE  // free the message
                                );

   printf("search result is 0x%x\n\n", ldaperr);
   
   //
   //  Stop TLS.
   //

   if (ldap_stop_tls_s( ld )) {

       printf("Stop TLS succeeded\n\n");
   
   } else {

       printf("stop TLS failed with 0x%x\n", LdapGetLastError());
       return;
   }

   //
   // Perform a plain text simple search
   //

   ldaperr = ldap_search_ext_s( ld,
                                "DC=rrandall,DC=nttest,DC=microsoft,DC=com",
                                LDAP_SCOPE_ONELEVEL,
                                NULL,
                                attrList,
                                FALSE,
                                NULL,
                                NULL,    // client control
                                NULL,
                                0,
                                &presult
                                );

   if (ldaperr == LDAP_SUCCESS) {

      printf("Search succeeded\n\n");
   } else {

      printf("Search failed with 0x%x  0x%x\n", ldaperr, GetLastError());
      return;
   }

   printf("Got back %d entries\n\n", ldap_count_entries(ld, presult));
   
   ldaperr = ldap_result2error( ld,
                                presult,
                                TRUE  // free the message
                                );

   printf("search result is 0x%x\n\n", ldaperr);

   ldap_unbind(ld);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\testprogs\extended\extend.c ===
#define SECURITY_WIN32

#include <windows.h>
#include <stdio.h>
#include <winldap.h>

#include <rpc.h>
#include <rpcdce.h>


#include <security.h>



void __cdecl main (int argc, char* argv[])
{

   LDAP *ld;
   ULONG ldaperr, NumPkgs, i;
   SEC_WINNT_AUTH_IDENTITY_EXA newstruct;
   SEC_WINNT_AUTH_IDENTITY oldstruct;
   PSecPkgInfo pPkgInfo, index;
   DWORD option = (DWORD) LDAP_OPT_ON;
   LDAPMessage* presult = NULL; 

   ld = ldap_open("rrandall-t2.rrandall2.nttest.microsoft.com", 389);

   if (ld) {

      printf("open succeeded\n");

   } else {

      printf("open failed\n");
      return;
   }

   ldaperr = ldap_extended_operation_s( ld,
                                       "1.2.3.4.5.6.7",
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL
                                       );

   printf("server returned 0x%x\n", ldaperr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\testprogs\pipes\pipe.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#define BUFFER_SIZE 10000000

void __cdecl main( int argc, char* argv[] )
{
    BOOL bSuccess = TRUE;
    SECURITY_ATTRIBUTES sa;
    HANDLE hReadPipe;
    HANDLE hWritePipe;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    char *cBuffer;
    DWORD dwBytesRead;
    DWORD dwTotalRead = 0;
    DWORD StartTime;
    DWORD EndTime;

    sa.nLength=sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor=NULL; //default security
    sa.bInheritHandle=TRUE;

    cBuffer = (char*) malloc( BUFFER_SIZE );

    if (!cBuffer) {
        printf("Buffer allocation failed\n");
        return;
    }
    bSuccess=CreatePipe(
        &hReadPipe, // address of variable for read handle 
        &hWritePipe,    // address of variable for write handle  
        &sa,    // pointer to security attributes 
        0   // number of bytes reserved for pipe 
    );
    if(bSuccess==TRUE)printf("CreatePipe success.\n");
    else printf("CreatePipe failed.\n");

    ZeroMemory(
        &si,    // address of block to fill with zeros 
        sizeof(STARTUPINFO) // size, in bytes, of block to fill with zeros  
    );

    si.cb=sizeof(STARTUPINFO);
    si.dwFlags=STARTF_USESTDHANDLES;
    si.hStdOutput=hWritePipe;

    bSuccess=CreateProcess(
        NULL,   // pointer to name of executable module 
        "console.exe",  // pointer to command line string
        &sa,    // pointer to process security attributes 
        &sa,    // pointer to thread security attributes 
        TRUE,   // handle inheritance flag 
        0,  // creation flags 
        NULL,   // pointer to new environment block 
        NULL,   // pointer to current directory name 
        &si,    // pointer to STARTUPINFO 
        &pi // pointer to PROCESS_INFORMATION  
        );

    if(bSuccess==TRUE) {
        printf("CreateProcess success.\n");
    } else {
        printf("CreateProcess failed. Error: %u\n", GetLastError());
    }

    printf("\nAbout to ReadFile...\n");

    StartTime = GetTickCount();

    do {
        bSuccess=ReadFile(
            hReadPipe,  // handle of file to read 
            &cBuffer[0],    // address of buffer that receives data  
            BUFFER_SIZE,    // number of bytes to read 
            &dwBytesRead,   // address of number of bytes read 
            NULL // address of structure for data 
        );
        
        dwTotalRead += dwBytesRead;
        
    } while ( bSuccess && (dwTotalRead < BUFFER_SIZE-1));
    
    EndTime = GetTickCount();

    printf("Transfer time is %d millisecond\n", (EndTime-StartTime));
    printf("Bytes read = %d\n", dwTotalRead);

//    cBuffer[(dwBytesRead < BUFFER_SIZE) ? (dwBytesRead - 2) : BUFFER_SIZE]='\0'; //Null terminate to protect against printf overrun.
//    printf("Read \"%s\"\n", &cBuffer[0]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\testprogs\unsolicited\unsol.c ===
#include <windows.h>
#include <stdio.h>
#include <winldap.h>

//
// Sample code to illustrate receipt of unsolicted notifications.
//


void NotificationCallback(


void __cdecl main (int argc, char* argv[])
{

   LDAP *ld;
   ULONG ldaperr;
   ULONG retval;
   LDAPAPIInfo info;
   PCHAR *temp;
   PLDAPMessage presult;
   int i = 0;
   PCHAR attrList[2] = { "cn", NULL };
   PLDAPControl controlArray[2];
   PLDAPControl *servercontrols;
   ULONG ServerError;

/*
   if (argc != 2) {
      printf("Usage: %s <hostname>\n", argv[0]);
      return;
   }
*/
   ld = ldap_open(argv[1]? argv[1] : "rrandall-t1.rrandall.nttest.microsoft.com",
                   389);

   if (ld) {

      printf("open succeeded\n");

   } else {

      printf("open failed\n");
      return;
   }

   //
   // Set the connection option to v3
   //

   ldaperr = ldap_set_option( ld, LDAP_OPT_VERSION, (PVOID) LDAP_VERSION3 );

   if (ldaperr == LDAP_SUCCESS) {

       printf("Set version to v3\n");
   
   } else {

       printf("Failed to set version to v3 with 0x%x  0x%x\n", ldaperr, GetLastError());
       return;
   }

   //
   // Perform a simple bind.
   //

   ldaperr = ldap_bind_s(ld,
                         "dn:cn=administrator,cn=users,dc=rrandall-t1,dc=rrandall,dc=nttest,dc=microsoft,dc=com",
                         NULL,              // credentials
                         LDAP_AUTH_SIMPLE   // auth type
                         );

   if (ldaperr == LDAP_SUCCESS) {

      printf("bind succeeded\n\n");
   } else {

      printf("bind failed with 0x%x  0x%x\n", ldaperr, LdapGetLastError());
      return;
   }

   //
   // Register a callback for unsolicited notifications.
   //
   
   ldaperr = ldap_set_option( ld, LDAP_OPT_UNSOLICITED_CALLBACK, NotificationCallback );

   //
   // Perform simple search in a loop
   //

   i=0;

   while (i++ < 100) {

       ldaperr = ldap_search_ext_s( ld,
                                    "DC=ntdev,DC=microsoft,DC=com",
                                    LDAP_SCOPE_BASE,
                                    NULL,
                                    attrList,
                                    FALSE,
                                    NULL,
                                    NULL,    // client control
                                    NULL,
                                    0,
                                    &presult
                                    );
    
       if (ldaperr == LDAP_SUCCESS) {
    
          printf("Search succeeded\n\n");
       } else {
    
          printf("Search failed with 0x%x  0x%x\n", ldaperr, LdapGetLastError());
          return;
       }
    
       printf("Got back %d entries\t", ldap_count_entries(ld, presult));
       
       ldaperr = ldap_result2error( ld,
                                    presult,
                                    TRUE  // free the message
                                    );
    
       printf("search result is 0x%x\n\n", ldaperr);
   
   }

   ldap_unbind(ld);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\netmon_parser\ldap.c ===
//==========================================================================================================================
//  MODULE: LDAP.c
//
//  Description: Lightweight Directory Access Protocol (LDAP) Parser
//
//  Bloodhound parser for LDAP, in the xxxx DLL
//                                                                                                                 
//  Note: info for this parser was gleaned from:
//  rfc 1777, March 1995
//  recommendation x.209 BER for ASN.1
//  recommendation x.208 ASN.1
//  draft-ietf-asid-ladpv3-protocol-05    <06/05/97>
//
//  Modification History                                                                                           
//                                                                                                                 
//  Arthur Brooking     05/08/96        Created from GRE Parser
//  Peter  Oakley       06/29/97        Updated for LDAP version 3
//==========================================================================================================================
                    
#include "LDAP.h"
#include <netmon.h>

//======== Globals
HPROTOCOL hLDAP = NULL;

// Define the entry points that we will pass back at dll entry time...
ENTRYPOINTS LDAPEntryPoints =
{
    // LDAP Entry Points
    LDAPRegister,
    LDAPDeregister,
    LDAPRecognizeFrame,
    LDAPAttachProperties,
    LDAPFormatProperties
};

//==========================================================================================================================
//  FUNCTION: LDAPRegister()
//
//  Modification History
//
//  Arthur Brooking     03/05/94        Created from GRE Parser
//==========================================================================================================================
void BHAPI LDAPRegister(HPROTOCOL hLDAP)
{
    WORD i;
    DWORD_PTR   res;

    res = CreatePropertyDatabase(hLDAP, nNumLDAPProps);

    #ifdef DEBUG
    if (res != NMERR_SUCCESS)
    {
        dprintf("LDAP Parser failed CreateProperty");
        BreakPoint();
    }
    #endif

    for (i = 0; i < nNumLDAPProps; i++)
    {
        res = AddProperty(hLDAP,&LDAPPropertyTable[i]);

        #ifdef DEBUG
        if (res == NULL)
        {
            dprintf("LDAP Parser failed AddProperty %d", i);
            BreakPoint();
        }
        #endif
    }
}



//==========================================================================================================================
//  FUNCTION: LDAPDeregister()
//
//  Modification History
//
//  Arthur Brooking     03/05/94        Created from GRE Parser
//==========================================================================================================================

VOID WINAPI LDAPDeregister(HPROTOCOL hLDAP)
{
    DestroyPropertyDatabase(hLDAP);
}


//==========================================================================================================================
//  FUNCTION: LDAPRecognizeFrame()
//
//  Modification History
//
//  Arthur Brooking     03/05/94        Created from GRE Parser
//==========================================================================================================================

LPBYTE BHAPI LDAPRecognizeFrame(  HFRAME      hFrame,                //... frame handle.
                                 ULPBYTE     lpMacFrame,              //... frame pointer.
                                 ULPBYTE     lpLDAPFrame,              //... relative pointer.
                                 DWORD       MacType,               //... MAC type.
                                 DWORD       BytesLeft,             //... Bytes left.
                                 HPROTOCOL   hPrevProtocol,         //... Handle of Previous Protocol
                                 DWORD       nPrevProtOffset,       //... Offset of Previous protocol
                                 LPDWORD     lpProtocolStatus,      //... Recognized/Not/Next Protocol
                                 LPHPROTOCOL lphNextProtocol,       //... Pointer to next offset to be called
                                 PDWORD_PTR  InstData)              //... Instance data to be passed to next
                                                                    //... Protocol
{
   
    DWORD DataLength;
    DWORD HeaderLength = 0;
    // make sure that the initial tag and length are good
    // and make sure that the identifier is 0x30 (universal, constructed, tag=0x10)
    if( GetTag(lpLDAPFrame) != 0x30 )
    {
        // the identifier or length did not check out
        *lpProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
        return NULL;
    }
    lpLDAPFrame++;
    DataLength = GetLength(lpLDAPFrame,&HeaderLength);
    lpLDAPFrame += HeaderLength;
   
    //make sure that the message ID is good
    // and make sure that the identifier is 0x02 (univeral, primative, tag=0x02=integer)
    if( GetTag(lpLDAPFrame) != 0x02 )
    {
        // the message ID did not check out
        *lpProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
        return NULL;
    }

    *lpProtocolStatus = PROTOCOL_STATUS_CLAIMED;
    return NULL;
}

//==========================================================================================================================
//  FUNCTION: LDAPAttachProperties()
//
//  Modification History
//
//  Arthur Brooking     03/05/94        Created from GRE Parser
//==========================================================================================================================

LPBYTE BHAPI LDAPAttachProperties(  HFRAME      hFrame,                //... frame handle.
                                   ULPBYTE     lpMacFrame,              //... frame pointer.
                                   ULPBYTE     lpLDAPFrame,          //... relative pointer.
                                   DWORD       MacType,               //... MAC type.
                                   DWORD       BytesLeft,             //... Bytes left.
                                   HPROTOCOL   hPrevProtocol,         //... Handle of Previous Protocol
                                   DWORD       nPrevProtOffset,       //... Offset of Previous protocol
                                   DWORD_PTR       InstData)              //... Instance data to be passed to next

{
    ULPBYTE pCurrent = lpLDAPFrame;
    DWORD  HeaderLength;
    DWORD  DataLength;
    BYTE   Tag;

    
    // attach summary
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_SUMMARY].hProperty,
                            (WORD)BytesLeft,
                            pCurrent,
                            0, 0, 0);

    while( (long)BytesLeft > 0 )
    {
        // starting sequence
        Tag = GetTag(pCurrent);
        pCurrent += TAG_LENGTH;
        DataLength = GetLength(pCurrent,&HeaderLength);
        pCurrent += HeaderLength;
        BytesLeft -= HeaderLength+TAG_LENGTH;
       
        // MessageID
        // integer
        Tag = GetTag(pCurrent);
        pCurrent += TAG_LENGTH;
        DataLength = GetLength(pCurrent,&HeaderLength);
        pCurrent += HeaderLength;
        BytesLeft -= HeaderLength+TAG_LENGTH;

        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_MESSAGE_ID].hProperty,
                                DataLength,
                                pCurrent,
                                0, 1, IFLAG_SWAPPED);
        pCurrent += DataLength;
        BytesLeft -= DataLength;

        // protocolOp
        Tag = GetTag(pCurrent);
        // we don't care what class or type this tag is, only its value
        Tag = Tag & TAG_MASK;
        
        // the tag will be 0x30 if this is a SearchResponseFull
        if( Tag == 0x30 )
        {
            // hack the data so that we look normal later
            Tag = LDAPP_PROTOCOL_OP_SEARCH_RESPONSE_FULL;
            
        }
        AttachPropertyInstanceEx( hFrame,
                                  LDAPPropertyTable[LDAPP_PROTOCOL_OP].hProperty,
                                  sizeof( BYTE ),
                                  pCurrent,
                                  sizeof(BYTE),
                                  &Tag,
                                  0, 1, 0);

        pCurrent += TAG_LENGTH;
        DataLength = GetLength(pCurrent, &HeaderLength);
        BytesLeft -= (HeaderLength + TAG_LENGTH);
        pCurrent += HeaderLength;
        // attach properties according to message type
        // the current position is the data portion of the 
        // main sequence.
      
        switch( Tag )
        {
            default:
            case LDAPP_PROTOCOL_OP_UNBIND_REQUEST:
                // no further properties
                break;

            case LDAPP_PROTOCOL_OP_BIND_RESPONSE:
                AttachLDAPBindResponse( hFrame,&pCurrent,&BytesLeft );
                break;

            case LDAPP_PROTOCOL_OP_SEARCH_RES_DONE:
            case LDAPP_PROTOCOL_OP_MODIFY_RESPONSE:
            case LDAPP_PROTOCOL_OP_ADD_RESPONSE:
            case LDAPP_PROTOCOL_OP_DEL_RESPONSE:
            case LDAPP_PROTOCOL_OP_MODIFY_RDN_RESPONSE:
            case LDAPP_PROTOCOL_OP_COMPARE_RESPONSE:
                AttachLDAPResult( hFrame, &pCurrent, &BytesLeft, 2);
                break;

            case LDAPP_PROTOCOL_OP_BIND_REQUEST:
                
                AttachLDAPBindRequest( hFrame, &pCurrent, &BytesLeft );
                break;

            case LDAPP_PROTOCOL_OP_SEARCH_REQUEST:
                AttachLDAPSearchRequest( hFrame, &pCurrent, &BytesLeft );
                break;

            case LDAPP_PROTOCOL_OP_SEARCH_RES_ENTRY:
            case LDAPP_PROTOCOL_OP_ADD_REQUEST:
                AttachLDAPSearchResponse( hFrame, &pCurrent, &BytesLeft, 2);
                break;

            case LDAPP_PROTOCOL_OP_MODIFY_REQUEST:
                AttachLDAPModifyRequest( hFrame, &pCurrent, &BytesLeft );
                break;
            
            case LDAPP_PROTOCOL_OP_DEL_REQUEST:
                pCurrent -= 2;
                BytesLeft += (HeaderLength);
                AttachLDAPDelRequest( hFrame, &pCurrent, &BytesLeft );
                break;

            case LDAPP_PROTOCOL_OP_MODIFY_RDN_REQUEST:
                AttachLDAPModifyRDNRequest( hFrame, &pCurrent, &BytesLeft );
                break;

            case LDAPP_PROTOCOL_OP_COMPARE_REQUEST:
                AttachLDAPCompareRequest( hFrame, &pCurrent, &BytesLeft );
                break;

            case LDAPP_PROTOCOL_OP_ABANDON_REQUEST:
                AttachLDAPAbandonRequest( hFrame, &pCurrent, &BytesLeft );
        
                break;

            case LDAPP_PROTOCOL_OP_SEARCH_RES_REFERENCE:
                AttachLDAPSearchResponseReference( hFrame, &pCurrent, &BytesLeft, 2);
                break;

            case LDAPP_PROTOCOL_OP_SEARCH_RESPONSE_FULL:
                AttachLDAPSearchResponseFull( hFrame, &pCurrent, &BytesLeft );
                break;

            case LDAPP_PROTOCOL_OP_EXTENDED_REQUEST:
                AttachLDAPExtendedRequest( hFrame, &pCurrent, &BytesLeft, DataLength );
                break;
            case LDAPP_PROTOCOL_OP_EXTENDED_RESPONSE:
                AttachLDAPExtendedResponse( hFrame, &pCurrent, &BytesLeft, DataLength );
                break;
        }
        // look for optional controls
        AttachLDAPOptionalControls( hFrame, &pCurrent, &BytesLeft );
    };

    return NULL;
};

//==========================================================================================================================
//  FUNCTION: FormatLDAPSum()
//
//  Modification History
//
//  Arthur Brooking     03/05/94        Created from GRE Parser
//==========================================================================================================================
VOID WINAPIV FormatLDAPSum(LPPROPERTYINST lpProp )
{
    ULPBYTE  pCurrent;
    LPBYTE   s;

    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;
    LPBYTE szProtOp;

    // I like to fill in variables seperate from their declaration 
    pCurrent = lpProp->lpByte;
    s        = lpProp->szPropertyText;

    // dig in and grab the ProtocolOp...
    // skip the sequence
    Tag = GetTag(pCurrent);
    pCurrent += TAG_LENGTH;
    DataLength = GetLength(pCurrent, &HeaderLength);
    pCurrent += HeaderLength;
    
    
    // skip the 
    Tag = GetTag(pCurrent);
    pCurrent += TAG_LENGTH;
    DataLength = GetLength(pCurrent, &HeaderLength);
    pCurrent += (HeaderLength + DataLength);
    

    // grab the ProtocolOp
    Tag = GetTag(pCurrent) & TAG_MASK;
    pCurrent += TAG_LENGTH;
    DataLength = GetLength(pCurrent, &HeaderLength);
    pCurrent += (HeaderLength + DataLength);
   
    
    if( Tag == 0x30 )
    {
        szProtOp  = LookupByteSetString( &LDAPProtocolOPsSET, 
                        LDAPP_PROTOCOL_OP_SEARCH_RESPONSE_FULL );
        wsprintf( s, "ProtocolOp: %s", szProtOp);
        return;
    }
    szProtOp  = LookupByteSetString( &LDAPProtocolOPsSET, Tag );

    // fill in the string
    wsprintf( s, "ProtocolOp: %s (%d)",
              szProtOp, Tag );
}

//==========================================================================================================================
//  FUNCTION: LDAPFormatProperties()
//
//  Modification History
//
//  Arthur Brooking     03/05/94        Created from GRE Parser
//==========================================================================================================================
typedef VOID (WINAPIV *FORMATPROC)(LPPROPERTYINST);

DWORD BHAPI LDAPFormatProperties( HFRAME          hFrame,
                                  ULPBYTE         MacFrame,
                                  ULPBYTE         ProtocolFrame,
                                  DWORD           nPropertyInsts,
                                  LPPROPERTYINST  p)
{
    while(nPropertyInsts--)
    {
        ((FORMATPROC)p->lpPropertyInfo->InstanceData)(p);
        p++;
    }

    return(NMERR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\testprogs\transact\transact.c ===
#include <windows.h>
#include <stdio.h>
#include <winldap.h>

//
// Sample code to illustrate transaction operations.
//

void __cdecl main (int argc, char* argv[])
{

   LDAP *ld;
   ULONG ldaperr;
   ULONG retval;
   ULONG ttl;
   PLDAPControl txcontrol;
   LDAPAPIInfo info;
   PCHAR *temp;
   PLDAPMessage presult;
   int i = 0;
   PCHAR attrList[2] = { "cn", NULL };
   PLDAPControl controlArray[2];
   PLDAPControl *servercontrols;
   ULONG ServerError;

   if (argc != 2) {
      printf("Usage: %s <hostname>\n", argv[0]);
      return;
   }

   ld = ldap_open(argv[1], 389);

   if (ld) {

      printf("open succeeded\n");

   } else {

      printf("open failed\n");
      return;
   }

   info.ldapai_info_version = LDAP_API_INFO_VERSION;

   ldaperr = ldap_get_option( ld, LDAP_OPT_API_INFO, &info );
   
   if (ldaperr == LDAP_SUCCESS) {

      printf("api   version: %d\n", info.ldapai_api_version );
      printf("info  version: %d\n", info.ldapai_info_version );
      printf("vendor   name: %s\n", info.ldapai_vendor_name );
      printf("vendor    ver: %d\n", info.ldapai_vendor_version );
      printf("protocol  ver: %d\n", info.ldapai_protocol_version );
      temp = info.ldapai_extensions;
      
      while (temp[i]) {
          LDAPAPIFeatureInfo extrainfo;

          printf("\tExtn name: %s\n", temp[i]);
          extrainfo.ldapaif_info_version = LDAP_FEATURE_INFO_VERSION;
          extrainfo.ldapaif_name = temp[i];
          extrainfo.ldapaif_version = 0;
          ldaperr = ldap_get_option(ld, LDAP_OPT_API_FEATURE_INFO, &extrainfo);
          if (ldaperr != LDAP_SUCCESS) {
              printf("Error in extra info option 0x%x\n", ldaperr);
              return;
          }
          printf("\tExtn ver: %d\n\n", extrainfo.ldapaif_version );
          i++;
      }

      ldap_memfree( info.ldapai_vendor_name );
      ldap_value_free( info.ldapai_extensions );
   } else {

      printf("info failed with 0x%x  0x%x\n", ldaperr, GetLastError());
      return;
   }

   //
   // Set the connection option to v3
   //

   ldaperr = ldap_set_option( ld, LDAP_OPT_VERSION, (PVOID) LDAP_VERSION3 );

   if (ldaperr == LDAP_SUCCESS) {

       printf("Set version to v3\n");
   
   } else {

       printf("Failed to set version to v3 with 0x%x  0x%x\n", ldaperr, GetLastError());
       return;
   }
   
   ldaperr = ldap_simple_bind_s(ld, "cn=administrator,cn=users,dc=cheenl,dc=nttest,dc=microsoft,dc=com", "password");

   if (ldaperr == LDAP_SUCCESS) {

      printf("bind succeeded\n\n");
   } else {

      printf("bind failed with 0x%x  0x%x\n", ldaperr, GetLastError());
      return;
   }

   ldaperr = ldap_start_transaction_s( ld,
                                       &retval,
                                       &ttl,
                                       NULL,
                                       &txcontrol,
                                       NULL,
                                       NULL,
                                       NULL
                                       );


   if (ldaperr == LDAP_SUCCESS) {

       printf("Start Transaction succeeded\n");
       printf("Server returned 0x%x\n", retval);
       printf("Transaction Timelimit is 0x%x\n\n", ttl);
   
   } else {

       printf("Transaction failed with 0x%x  0x%x\n", ldaperr, GetLastError());
       return;
   }

   //
   // Perform a simple search
   //

   controlArray[0] = txcontrol;
   controlArray[1] = NULL;

   ldaperr = ldap_search_ext_s( ld,
                            "cn=administrator,cn=users,dc=cheenl,dc=nttest,dc=microsoft,dc=com",
                                LDAP_SCOPE_BASE,
                                NULL,
                                attrList,
                                FALSE,
                                controlArray,
                                NULL,    // client control
                                NULL,
                                0,
                                &presult
                                );

   if (ldaperr == LDAP_SUCCESS) {

      printf("Search succeeded\n\n");
   } else {

      printf("Search failed with 0x%x  0x%x\n", ldaperr, GetLastError());
      return;
   }

   //
   // Parse the return value in the server control.
   //
   
   ldaperr = ldap_parse_result( ld,
                                presult,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                &servercontrols,
                                TRUE             // Free the message
                                );

   if (ldaperr == LDAP_SUCCESS) {

      printf("Parse result succeeded\n");
   } else {

      printf("Parse result failed with 0x%x  0x%x\n", ldaperr, GetLastError());
      return;
   }
   
   ldaperr = ldap_parse_transaction_control( ld,
                                             servercontrols,
                                             &ServerError
                                             );

   ldap_free_controls( servercontrols );
   
   if (ldaperr == LDAP_SUCCESS) {

       printf("Parse Tx succeeded server returned 0x%x\n", ServerError);
   
   } else {

       printf("Parse Tx failed with 0x%x  0x%x\n", ldaperr, GetLastError());
       return;
   }

   ldaperr = ldap_end_transaction_s( ld,
                                     txcontrol,
                                     &retval,
                                     FALSE,   //abandon
                                     NULL,
                                     NULL,
                                     NULL
                                     );

   ldap_control_free( txcontrol );

   if (ldaperr == LDAP_SUCCESS) {

       printf("End Transaction succeeded\n\n");
   
   } else {

       printf("Transaction failed with 0x%x  0x%x\n", ldaperr, GetLastError());
       return;
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\client\testprogs\kdamour\test.cpp ===
// Test.cpp : Defines the entry point for the console application. This code uses SASL calling convention
//

// #include "stdafx.h"
//#include "global.h"

// #include <windows.h>

//  #include <time.h>

#define SECURITY_WIN32

#include <stdio.h>      // printf
//
// Common include files.
//
/*
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>     // Needed for service controller APIs
#include <lmcons.h>
#include <lmerr.h>
#include <lmsname.h>
#include <rpc.h>
#include <stdlib.h>     // strtoul
// #include <tstring.h>    // NetpAllocWStrFromWStr
*/

#include <security.h>   // General definition of a Security Support Provider

#define DNS_DOMAIN_NAME  L"company.com"
#define DNS_NAME         L"machineABC"

#define TEST_MESSAGE "This is a test"


#define ISC_REQ_HTTP         0x10000000
#define ISC_RET_HTTP         0x10000000

#define ASC_REQ_HTTP         0x10000000
#define ASC_RET_HTTP         0x10000000


#define AUTH_USERNAME "digest"
#define AUTH_USERNAME_W L"digest"
#define AUTH_REALM   "simple_digest"
#define AUTH_REALM_W L"simple_digest"
#define AUTH_NONCE "9b38dce631309cc25a653ebaad5b18ee01c8bf385260b26db0574a302be4c11367"
#define AUTH_METHOD "GET"
#define AUTH_ALGORITHM "md5-sess"
#define AUTH_QOP "auth"
#define AUTH_PASSWD "secret"
#define AUTH_CNONCE "34c52218425a779f41d5075931fe6c93"
#define AUTH_URI "/simple_digest/success.html"
#define AUTH_URI_W L"/simple_digest/success.html"
#define AUTH_NC  "0000000b"
#define AUTH_NC1  "00000001"
#define AUTH_NC2  "00000002"
#define AUTH_NC3  "00000003"
#define AUTH_NC4  "00000004"
#define AUTH_REQDIGEST "60cac55049f9887c9fb853f485128368"

#define AUTHDATA_USERNAME L"AuthUserName"
#define AUTHDATA_DOMAIN   L"AuthDomainName"
#define AUTHDATA_PASSWORD L"AuthSecret"

// used to test out repeated call to hash
#define AUTH_NAMES "digest:digest:digest:digest:digest:digest"

#define STR_BUF_SIZE   4000

char g_czTestPasswd[257];


BOOLEAN QuietMode = FALSE; // Don't be verbose


// Handle into the CryptoAPI
HCRYPTPROV g_hCryptProv;

PLSA_SECPKG_FUNCTION_TABLE g_LsaFunctions;   // unused just define
NTDIGEST_STATE g_NtDigestState = NtDigestUserMode;  // set for memory allocation

char *pbSeparator = COLONSTR;

BOOL g_bParameter_Delegation = TRUE;

// Prototypes
void PrintStatus(SECURITY_STATUS NetStatus);
void PrintTime(LPSTR Comment,TimeStamp ConvertTime);
NTSTATUS CryptInitialize(void);

int __cdecl
main(int argc, char* argv[])
{
    BOOL bPass = TRUE;
    SECURITY_STATUS Status = STATUS_SUCCESS;

    char cTemp[4000];  // temp buffer for scratch data
    char cOutputTemp[4000];
    char szOutSecBuf[4000];
    char szChallenge[4000];
    char szISCChallengeResponse[4000];   // Output buffer from ISC
    char szASCChallengeResponse[4000];   // Output buffer from ASC

    // SSPI Interface tests

    ULONG PackageCount = 0;
    ULONG i = 0;
    PSecPkgInfo pPackageInfo = NULL;
    PSecPkgInfo pPackageTmp = NULL;
    SECURITY_STATUS TmpStatus = STATUS_SUCCESS;
    CredHandle ServerCred;
    CredHandle ClientCred;
    TimeStamp Lifetime;
    BOOL bServerCred = FALSE;
    BOOL bClientCred = FALSE;


    ULONG ContextReqFlags = 0;
    ULONG ContextFlagsUtilized = 0;
    ULONG TargetDataRep = 0;
    ULONG ContextAttributes = 0;


    CtxtHandle OldContextHandle;
    CtxtHandle ServerCtxtHandle;
    CtxtHandle ClientCtxtHandle;

    SecBufferDesc InputBuffers;
    SecBufferDesc OutputBuffers;
    SecBuffer TempTokensIn[6];
    SecBuffer TempTokensOut[6];

    STRING strChallenge;
    STRING strMethod;
    STRING strURL;
    STRING strHEntity;
    STRING strOutBuffer;

    ULONG ulMessSeqNo = 0;
    ULONG ulQOP = 0;

    SEC_WINNT_AUTH_IDENTITY_W AuthData;

    printf("Begining TESTB...\n");


    ZeroMemory(&ClientCred, sizeof(CredHandle));
    ZeroMemory(&ServerCred, sizeof(CredHandle));
    ZeroMemory(&OldContextHandle, sizeof(CtxtHandle));
    ZeroMemory(&ServerCtxtHandle, sizeof(CtxtHandle));
    ZeroMemory(&ClientCtxtHandle, sizeof(CtxtHandle));


    // This will initiaialize the security package
    CryptInitialize();

    //
    // Get info about the security packages.
    //

    Status = EnumerateSecurityPackages( &PackageCount, &pPackageInfo );
    TmpStatus = GetLastError();

    if (!NT_SUCCESS(Status)) {
        printf( "EnumerateSecurityPackages failed: 0x%x", Status);
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    if ( !QuietMode ) {
      printf( "PackageCount: %ld\n", PackageCount );
      for ( i= 0; i< PackageCount; i++)
      {
        pPackageTmp = (pPackageInfo + i);
        printf( "Name: %ws Comment: %ws\n", pPackageTmp->Name, pPackageTmp->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                pPackageTmp->fCapabilities,
                pPackageTmp->wVersion,
                pPackageTmp->wRPCID,
                pPackageTmp->cbMaxToken );
      }
    }

    //
    // Get info about the security packages.
    //

    Status = QuerySecurityPackageInfo( NTDIGEST_SP_NAME, &pPackageInfo );
    TmpStatus = GetLastError();

    if (!NT_SUCCESS(Status)) {
        printf( "QuerySecurityPackageInfo failed: " );
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    if ( !QuietMode ) {
        printf( "Name: %ws Comment: %ws\n", pPackageInfo->Name, pPackageInfo->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                pPackageInfo->fCapabilities,
                pPackageInfo->wVersion,
                pPackageInfo->wRPCID,
                pPackageInfo->cbMaxToken );
    }


    //
    // Acquire a credential handle for the server side
    //

    printf("Server  AcquireCredentialHandle\n");
    Status = AcquireCredentialsHandle(
                    NULL,           // New principal
                    NTDIGEST_SP_NAME, // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &ServerCred,
                    &Lifetime );

    if (!NT_SUCCESS(Status)) {
        printf( "AcquireCredentialsHandle failed: ");
        // TmpStatus = GetLastError();
        PrintStatus( Status );
        bPass = FALSE;
        ZeroMemory(&ServerCred, sizeof(CredHandle));
        goto CleanUp;
    }
    bServerCred = TRUE;


    //
    // Acquire a credential handle for the client side
    //
    printf("Client  AcquireCredentialHandle\n");

    ZeroMemory(&AuthData, sizeof(SEC_WINNT_AUTH_IDENTITY_W));
    AuthData.Domain = AUTHDATA_DOMAIN;
    AuthData.DomainLength = wcslen(AuthData.Domain);
    AuthData.Password = AUTHDATA_PASSWORD;
    AuthData.PasswordLength = wcslen(AuthData.Password);
    AuthData.User = AUTHDATA_USERNAME;
    AuthData.UserLength = wcslen(AuthData.User);
    AuthData.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    Status = AcquireCredentialsHandle(
                    AUTH_USERNAME_W,           // get the creds for user digest
                    NTDIGEST_SP_NAME, // Package Name
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    NULL,   // &AuthData,    // Make NULL not to use any AuthData for cred
                    NULL,
                    NULL,
                    &ClientCred,
                    &Lifetime );

    if (!NT_SUCCESS(Status)) {
        printf( "AcquireCredentialsHandle failed: for user %s: ", AUTH_USERNAME);
        // TmpStatus = GetLastError();
        PrintStatus( Status );
        // bPass = FALSE;
        // ZeroMemory(&ClientCred, sizeof(CredHandle));
        // goto CleanUp;
    }
    else
        bClientCred = TRUE;


    if ( !QuietMode ) {
        printf( "ClientCred: 0x%lx 0x%lx   ",
                ClientCred.dwLower, ClientCred.dwUpper );
        printf( "ServerCred: 0x%lx 0x%lx   ",
                ServerCred.dwLower, ServerCred.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }


    // Big time - call Accept with no parameters to get a challenge


    StringAllocate(&strChallenge, 0);

    StringCharDuplicate(&strMethod, "GET");
    StringCharDuplicate(&strURL, AUTH_URI);
    StringAllocate(&strHEntity, 0);

    StringAllocate(&strOutBuffer, 4000);


    ZeroMemory(TempTokensIn, sizeof(TempTokensIn));
    ZeroMemory(TempTokensOut, sizeof(TempTokensOut));
    ZeroMemory(&InputBuffers, sizeof(SecBufferDesc));
    ZeroMemory(&OutputBuffers, sizeof(SecBufferDesc));


           // SASL first calls ISC with no-input
    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 1;
    InputBuffers.pBuffers = TempTokensIn;

    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = 0;                         // no data passed in
    TempTokensIn[0].pvBuffer = cTemp;

    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers = 1;
    OutputBuffers.pBuffers = TempTokensOut;

    TempTokensOut[0].BufferType = SECBUFFER_TOKEN;
    TempTokensOut[0].cbBuffer = strOutBuffer.MaximumLength;  // use any space here
    TempTokensOut[0].pvBuffer = strOutBuffer.Buffer;

    ContextReqFlags = ISC_REQ_REPLAY_DETECT;

    Status = InitializeSecurityContext(&ClientCred,
                                       NULL,
                                       AUTH_URI_W,
                                       ContextReqFlags,
                                       NULL,
                                       SECURITY_NATIVE_DREP,
                                       &InputBuffers,
                                       NULL,
                                       &ClientCtxtHandle,
                                       &OutputBuffers,
                                       &ContextFlagsUtilized,
                                       &Lifetime);


    if (!NT_SUCCESS(Status))
    {
        printf("InitializeSecurityContext  SASL 1st call returned: ");
        TmpStatus = GetLastError();
        PrintStatus( Status );
        //  bPass = FALSE;
        // goto CleanUp;
    }

    printf("InitializeSecurityContext SASL 1st call  Output buffer size %d\n",
           TempTokensOut[0].cbBuffer );


    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 1;
    InputBuffers.pBuffers = TempTokensIn;

    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = strChallenge.Length + 1;  // for NULL
    TempTokensIn[0].pvBuffer = strChallenge.Buffer;

    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers = 1;
    OutputBuffers.pBuffers = TempTokensOut;

    TempTokensOut[0].BufferType = SECBUFFER_TOKEN;
    TempTokensOut[0].cbBuffer = strOutBuffer.MaximumLength;  // use any space here
    TempTokensOut[0].pvBuffer = strOutBuffer.Buffer;

    ContextReqFlags = ASC_REQ_REPLAY_DETECT;

    Status = AcceptSecurityContext(
                                   &ServerCred,
                                   NULL,
                                   &InputBuffers,
                                   ContextReqFlags,
                                   TargetDataRep,
                                   &ServerCtxtHandle,
                                   &OutputBuffers,
                                   &ContextAttributes,
                                   &Lifetime);

    if (!NT_SUCCESS(Status))
    {
        printf("SpAcceptLsaModeContext FAILED 0x%x\n", Status);
        // TmpStatus = GetLastError();
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    strcpy(cOutputTemp, (char *)OutputBuffers.pBuffers[0].pvBuffer);
    strcpy(szChallenge, (char *)OutputBuffers.pBuffers[0].pvBuffer);

    printf("Context Flags  Req  0x%lx    Ret 0x%lx\n", ContextReqFlags, ContextAttributes); 

    printf("Challenge Output Buffer is:\n%s\n\n", cOutputTemp);

    printf("Now call the SSPI InitializeSecCtxt to generate the ChallengeResponse\n");


    sprintf(cTemp, "username=\"%s\",%s,uri=\"%s\",nc=%0.8x",
              AUTH_USERNAME,
              szChallenge,
              AUTH_URI,
              1);


    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 1;
    InputBuffers.pBuffers = TempTokensIn;

    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = strlen(cTemp) + 1;  // for NULL
    TempTokensIn[0].pvBuffer = cTemp;

    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers = 1;
    OutputBuffers.pBuffers = TempTokensOut;

    TempTokensOut[0].BufferType = SECBUFFER_TOKEN;
    TempTokensOut[0].cbBuffer = strOutBuffer.MaximumLength;  // use any space here
    TempTokensOut[0].pvBuffer = strOutBuffer.Buffer;

    ContextReqFlags = ISC_REQ_REPLAY_DETECT;

    Status = InitializeSecurityContext(&ClientCred,
                                       &ClientCtxtHandle,
                                       AUTH_URI_W,
                                       ContextReqFlags,
                                       NULL,
                                       SECURITY_NATIVE_DREP,
                                       &InputBuffers,
                                       NULL,
                                       &ClientCtxtHandle,
                                       &OutputBuffers,
                                       &ContextFlagsUtilized,
                                       &Lifetime);


    if (!NT_SUCCESS(Status))
    {
        printf("InitializeSecurityContext FAILED: ");
        TmpStatus = GetLastError();
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    printf("InitializeSecurityContext SUCCEEDED with Context Handle (0x%x,0x%x)\n",
           ClientCtxtHandle.dwLower, ClientCtxtHandle.dwUpper );


    printf("Context Flags  Req  0x%lx    Ret 0x%lx\n", ContextReqFlags, ContextFlagsUtilized); 


    strcpy(cOutputTemp, (char *)OutputBuffers.pBuffers[0].pvBuffer);
    strcpy(szISCChallengeResponse, (char *)OutputBuffers.pBuffers[0].pvBuffer);

    printf("\nISC: Challenge Response Output Buffer is\n%s\n\n", szISCChallengeResponse);

    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 1;
    InputBuffers.pBuffers = TempTokensIn;

    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = strlen(cOutputTemp) + 1;  // for NULL
    TempTokensIn[0].pvBuffer = cOutputTemp;

    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers = 1;
    OutputBuffers.pBuffers = TempTokensOut;

    TempTokensOut[0].BufferType = SECBUFFER_TOKEN;
    TempTokensOut[0].cbBuffer = strOutBuffer.MaximumLength;  // use any space here
    TempTokensOut[0].pvBuffer = strOutBuffer.Buffer;

    ContextReqFlags = ASC_REQ_REPLAY_DETECT;


    printf("Calling the AcceptSC with a ChallengeResponse (should talk to the DC)!\n");
    Status = AcceptSecurityContext(
                                   &ServerCred,
                                   &ServerCtxtHandle,
                                   &InputBuffers,
                                   ContextReqFlags,
                                   TargetDataRep,
                                   &ServerCtxtHandle,
                                   &OutputBuffers,
                                   &ContextAttributes,
                                   &Lifetime);
                                   
    if (!NT_SUCCESS(Status))
    {
        printf("AcceptSecurityContext 2nd Call: ");
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    strcpy(szASCChallengeResponse, (char *)InputBuffers.pBuffers[0].pvBuffer);

    printf("ASC has accepted the Challenge Resposne\n");

    printf("Now have a valid Security Context handle from ISC and ASC\n\n");

    printf("Context Flags  Req  0x%lx    Ret 0x%lx\n", ContextReqFlags, ContextAttributes);



    goto CleanUp;




    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 5;
    InputBuffers.pBuffers = TempTokensIn;

        // The first call to MakeSignature this represents the SECOND request on this Nonce!
    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = 0;     // strlen(szISCChallengeResponse) + 1;  // for NULL
    TempTokensIn[0].pvBuffer = NULL;  //  szISCChallengeResponse;
    TempTokensIn[1].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[1].cbBuffer = strMethod.Length + 1;  // for NULL
    TempTokensIn[1].pvBuffer = strMethod.Buffer;
    TempTokensIn[2].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[2].cbBuffer = strURL.Length + 1;  // for NULL
    TempTokensIn[2].pvBuffer = strURL.Buffer;
    TempTokensIn[3].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[3].cbBuffer = 0;   // strHEntity.Length + 1;  // for NULL
    TempTokensIn[3].pvBuffer = NULL;  //  strHEntity.Buffer;
    TempTokensIn[4].BufferType = SECBUFFER_PKG_PARAMS;             // There is no OutputBuffers
    TempTokensIn[4].cbBuffer = 4000;                               // So tack on another bufffer on end for output
    TempTokensIn[4].pvBuffer = szOutSecBuf;

    Status = MakeSignature(&ClientCtxtHandle,
                           ulQOP,
                           &InputBuffers,
                           0);
    if (!NT_SUCCESS(Status))
    {
        printf("TestCredAPI: MakeSignature FAILED: ");
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    printf("\nMakeSig: Challenge Response Output Buffer for 2nd message is\n%s\n", szOutSecBuf);


    // You now send Output buffer to Server - in this case the buffer is szOutSecBuf

    printf("Now verify that the 2nd message is Authenticate\n");

            // The First message to VerifySignature is the Input to the final call of ASC
    strcpy(cOutputTemp, szOutSecBuf);
    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = strlen(cOutputTemp) + 1;  // for NULL
    TempTokensIn[0].pvBuffer = cOutputTemp;

    Status = VerifySignature(&ServerCtxtHandle,
                             &InputBuffers,
                             ulMessSeqNo,
                             &ulQOP);                                   
    if (!NT_SUCCESS(Status))
    {
        printf("TestCredAPI: VerifySignature 1st Call  FAILED :");
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }
    printf("Now have a authenticated 1st message under context 0x%x\n", ServerCtxtHandle);

    printf("VerifySig: Check if still OK: Output Buffer (Verify should not have modified it) is\n%s\n\n", cOutputTemp);

    Status = VerifySignature(&ServerCtxtHandle,
                             &InputBuffers,
                             ulMessSeqNo,
                             &ulQOP);                                   
    if (NT_SUCCESS(Status))
    {
        printf("TestCredAPI: VerifySignature 2nd Call  should not have succeeded\n");
        bPass = FALSE;
        goto CleanUp;
    }
    printf("Verified that replay does not work\n");


    printf("Calling Impersonation\n");

    Status = ImpersonateSecurityContext(&ServerCtxtHandle);
    if (!NT_SUCCESS(Status))
    {
        printf("TestCredAPI: ImpersonateSecurityContext FAILED: ");
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    printf("I am now another user!!!!!!!!!!!!!\n");

    Status = RevertSecurityContext(&ServerCtxtHandle);

    if (!NT_SUCCESS(Status))
    {
        printf("TestCredAPI: RevertSecurityContext FAILED: ");
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    printf("I have returned.\n");

    goto CleanUp;



CleanUp:

    printf("Leaving NT Digest testb\n\n\n");

    if (pPackageInfo)
    {
        FreeContextBuffer(pPackageInfo);
    }

    printf("About to call deletesecuritycontext\n");

    //
    // Free the security context handle
    //
    if (ServerCtxtHandle.dwLower || ServerCtxtHandle.dwUpper)
    {
        Status = DeleteSecurityContext(&ServerCtxtHandle);
        if (!NT_SUCCESS(Status))
        {
            printf("ERROR:  DeleteSecurityContext ServerCtxtHandle failed: ");
            PrintStatus(Status);
        }
    }

    if (ClientCtxtHandle.dwLower || ClientCtxtHandle.dwUpper)
    {
        Status = DeleteSecurityContext(&ClientCtxtHandle);
        if (!NT_SUCCESS(Status))
        {
            printf("ERROR:  DeleteSecurityContext ClientCtxtHandle failed: ");
            PrintStatus(Status);
        }
    }
    //
    // Free the credential handles
    //

    printf("Now calling to Free the ServerCred\n");
    if (bServerCred)
    {
        Status = FreeCredentialsHandle( &ServerCred );

        if (!NT_SUCCESS(Status))
        {
            printf( "FreeCredentialsHandle failed for ServerCred: " );
            PrintStatus(Status);
        }
    }

    printf("Now calling to Free the ServerCred\n");
    if (bClientCred)
    {
        Status = FreeCredentialsHandle(&ClientCred);

        if (!NT_SUCCESS(Status))
        {
            printf( "FreeCredentialsHandle failed for ClientCred: " );
            PrintStatus( Status );
        }
    }

    StringFree(&strChallenge);
    StringFree(&strMethod);
    StringFree(&strURL);
    StringFree(&strHEntity);
    StringFree(&strOutBuffer);


    if (bPass != TRUE)
        printf("FAILED test run with one or more tests failing.\n");
    else
        printf("All tests passed.\n");

    return 0;
}


void
PrintStatus(
    SECURITY_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = 0x%lx",NetStatus );

    switch (NetStatus) {

    case ERROR_LOGON_FAILURE:
        printf( " ERROR_LOGON_FAILURE" );
        break;

    case ERROR_ACCESS_DENIED:
        printf( " ERROR_ACCESS_DENIED" );
        break;

    case ERROR_NOT_SUPPORTED:
        printf( " ERROR_NOT_SUPPORTED" );
        break;

    case ERROR_NO_LOGON_SERVERS:
        printf( " ERROR_NO_LOGON_SERVERS" );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        printf( " ERROR_NO_SUCH_DOMAIN" );
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        printf( " ERROR_NO_TRUST_LSA_SECRET" );
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        printf( " ERROR_NO_TRUST_SAM_ACCOUNT" );
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        printf( " ERROR_DOMAIN_TRUST_INCONSISTENT" );
        break;

    case ERROR_BAD_NETPATH:
        printf( " ERROR_BAD_NETPATH" );
        break;

    case ERROR_FILE_NOT_FOUND:
        printf( " ERROR_FILE_NOT_FOUND" );
        break;
    case SEC_E_NO_SPM:
        printf( " SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        printf( " SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        printf( " SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        printf( " SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        printf( " SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        printf( " SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        printf( " SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        printf( " SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        printf( " SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        printf( " SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        printf( " SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        printf( " SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        printf( " SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        printf( " SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        printf( " SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        printf( " SEC_E_NOT_SUPPORTED" ); break;

    case SEC_I_CONTINUE_NEEDED:
        printf( " SEC_I_CONTINUE_NEEDED" ); break;
    }

    printf( "\n" );
}



void
PrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    LARGE_INTEGER LocalTime;
    NTSTATUS Status;

    LocalTime.HighPart = ConvertTime.HighPart;
    LocalTime.LowPart = ConvertTime.LowPart;

    Status = RtlSystemTimeToLocalTime( &ConvertTime, &LocalTime );
    if (!NT_SUCCESS( Status )) {
        printf( "Can't convert time from GMT to Local time\n" );
        LocalTime = ConvertTime;
    }

    printf( "%s", Comment );

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( LocalTime.HighPart == 0x7FFFFFFF && LocalTime.LowPart == 0xFFFFFFFF ) {
        printf( "Infinite\n" );

    //
    // Otherwise print it more clearly
    //

    } else {

        TIME_FIELDS TimeFields;

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }

}


//+--------------------------------------------------------------------
//
//  Function:   CryptInitialize
//
//  Synopsis:   Initialize crypt routines for local digest calculations
//
//  Arguments:  None
//
//  Returns:    
//
//  Notes:
//      CryptReleaseContext( g_hCryptProv, 0 ) to release the cypt context
//
//---------------------------------------------------------------------

NTSTATUS NTAPI
CryptInitialize(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BYTE abTemp[NONCE_PRIVATE_KEY_BYTESIZE];


    if (g_hCryptProv)
    {         // Catch cases where LSA and Usermode running in same addr space
        printf("Already Inited Leaving CryptInitialize\n");
        return STATUS_SUCCESS;
    }

    //
    // Get a handle to the CSP we'll use for all our hash functions etc
    //
    if ( !CryptAcquireContext( &g_hCryptProv,
                               NULL,
                               NULL,
                               PROV_RSA_FULL,
                               CRYPT_VERIFYCONTEXT ) )
    {
        printf("CryptInitialize:CryptCreateHash() failed : 0x%x\n", GetLastError());
        Status = STATUS_INTERNAL_ERROR;
        return(Status);
    }

    
    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\netmon_parser\ldap.h ===
//=================================================================================================================
//  MODULE: ldap.h
//                                                                                                                 
//  Description: Lightweight Directory Access Protocol (LDAP) Parser
//
//  Bloodhound parser for LDAP, in the xxxx DLL
//                                                                                                                 
//  Note: info for this parser was gleaned from:
//  rfc 1777, March 1995
//  recommendation x.209 BER for ASN.1
//  recommendation x.208 ASN.1
//  draft-ietf-asid-ladpv3-protocol-05    <06/05/97>
//
//  Modification History                                                                                           
//                                                                                                                 
//  Arthur Brooking     05/08/96        Created from GRE Parser
//  Peter  Oakley       06/29/97        Updated for LDAP version 3
//=================================================================================================================
#ifndef _LDAP_H_
#define _LDAP_H_

#include <windows.h>
#include <ctype.h>
#include <netmon.h>
#include <stdlib.h>
#include <string.h>
#include <winldap.h>
#include <ntldap.h>
#include <winber.h>

typedef struct LDAPOID {
    unsigned int    length;
    unsigned char   *value;
} LDAPOID;
    
typedef
void
(* PATTACHFUNC)(
    IN     HFRAME hFrame,
    IN OUT ULPBYTE * ppCurrent,
    IN OUT LPDWORD pBytesLeft,
    IN     DWORD cbCtrlValue
    );

typedef struct OIDATTACHENTRY {
    LDAPOID      Oid;
    DWORD        LabelId;
    PATTACHFUNC  pAttachFunction;
} OIDATTACHENTRY;

// macro
#define LEVEL(level) ((level<14)?level:14)
#define DEFINE_LDAP_STRING(x)  {(sizeof(x)-1),(PUCHAR)x}


//=================================================================================================================
// Globals
//=================================================================================================================
// in LDAP.C
extern HPROTOCOL   hLDAP;
extern ENTRYPOINTS LDAPEntryPoints;

// in LDAPDATA.C
extern SET          LDAPProtocolOPsSET;
extern SET          LDAPResultCodesSET;
extern SET          LDAPAuthenticationTypesSET;
extern SET          LDAPOperationsSET;
extern SET          LDAPScopesSET;
extern SET          LDAPDerefAliasesSET;
extern SET          LDAPLimitsSET;
extern SET          LDAPFilterTypesSET;
extern SET          LDAPSDControlValsSET;
extern SET          LDAPDirSyncFlagsSET;
extern SET          LDAPSearchOptsSET;
extern PROPERTYINFO LDAPPropertyTable[];
extern DWORD        nNumLDAPProps;
extern OIDATTACHENTRY  KnownControls[];
extern DWORD        nNumKnownControls;
extern OIDATTACHENTRY  KnownExtendedRequests[];
extern DWORD        nNumKnownExtendedRequests;
extern OIDATTACHENTRY  KnownExtendedResponses[];
extern DWORD        nNumKnownExtendedResponses;
extern OIDATTACHENTRY  KnownMatchingRules[];
extern DWORD        nNumKnownMatchingRules;


//=================================================================================================================
// Constants
//=================================================================================================================
// PROPERTY ORDINALS                
#define LDAPP_SUMMARY                           0
#define LDAPP_MESSAGE_ID                        1
#define LDAPP_PROTOCOL_OP                       2
#define LDAPP_RESULT_CODE                       3
#define LDAPP_MATCHED_DN                        4
#define LDAPP_ERROR_MESSAGE                     5
#define LDAPP_VERSION                           6
#define LDAPP_NAME                              7
#define LDAPP_AUTHENTICATION_TYPE               8
#define LDAPP_AUTHENTICATION                    9
#define LDAPP_OBJECT_NAME                      10
#define LDAPP_ATTRIBUTE_TYPE                   11
#define LDAPP_ATTRIBUTE_VALUE                  12
#define LDAPP_OPERATION                        13
#define LDAPP_NEW_RDN                          14
#define LDAPP_BASE_OBJECT                      15
#define LDAPP_SCOPE                            16
#define LDAPP_DEREF_ALIASES                    17
#define LDAPP_SIZE_LIMIT                       18
#define LDAPP_TIME_LIMIT                       19
#define LDAPP_ATTRS_ONLY                       20
#define LDAPP_FILTER_TYPE                      21
#define LDAPP_SUBSTRING_INITIAL                22
#define LDAPP_SUBSTRING_ANY                    23
#define LDAPP_SUBSTRING_FINAL                  24
#define LDAPP_REFERRAL_SERVER                  25   
#define LDAPP_SASL_MECHANISM                   26
#define LDAPP_SASL_CREDENTIALS                 27 
#define LDAPP_DELETE_OLD_RDN                   28
#define LDAPP_NEW_SUPERIOR                     29
#define LDAPP_REQUEST_NAME                     30
#define LDAPP_REQUEST_VALUE                    31
#define LDAPP_RESPONSE_NAME                    32
#define LDAPP_RESPONSE_VALUE                   33
#define LDAPP_DN_ATTRIBUTES                    34
#define LDAPP_CONTROL_TYPE                     35
#define LDAPP_CRITICALITY                      36
#define LDAPP_CONTROL_VALUE                    37
#define LDAPP_CONTROL_PAGED                    38
#define LDAPP_CONTROL_PAGED_SIZE               39
#define LDAPP_CONTROL_PAGED_COOKIE             40
#define LDAPP_ATTR_DESCR_LIST                  41
#define LDAPP_FILTER                           42
#define LDAPP_CONTROLS                         43
#define LDAPP_CONTROL_VLVREQ                   44
#define LDAPP_CONTROL_VLVREQ_BCOUNT            45
#define LDAPP_CONTROL_VLVREQ_ACOUNT            46
#define LDAPP_CONTROL_VLVREQ_OFFSET            47
#define LDAPP_CONTROL_VLV_CONTENTCOUNT         48
#define LDAPP_CONTROL_VLVREQ_GE                49
#define LDAPP_CONTROL_VLV_CONTEXT              50
#define LDAPP_CONTROL_VLVRESP_TARGETPOS        51
#define LDAPP_CONTROL_VLVRESP_RESCODE          52
#define LDAPP_CONTROL_VLVRESP                  53
#define LDAPP_CONTROL_SORTREQ                  54
#define LDAPP_CONTROL_SORTREQ_ATTRTYPE         55
#define LDAPP_CONTROL_SORTREQ_MATCHINGRULE     56
#define LDAPP_CONTROL_SORTREQ_REVERSE          57
#define LDAPP_CONTROL_SORTRESP                 58
#define LDAPP_CONTROL_SORTRESP_RESCODE         59
#define LDAPP_CONTROL_SORTRESP_ATTRTYPE        60
#define LDAPP_CONTROL_SD                       61
#define LDAPP_CONTROL_SD_VAL                   62
#define LDAPP_CONTROL_SHOWDELETED              63
#define LDAPP_CONTROL_TREEDELETE               64
#define LDAPP_CONTROL_EXTENDEDDN               65
#define LDAPP_CONTROL_LAZYCOMMIT               66
#define LDAPP_CONTROL_NOTIFY                   67
#define LDAPP_CONTROL_DOMAINSCOPE              68
#define LDAPP_CONTROL_PERMISSIVEMOD            69
#define LDAPP_CONTROL_ASQ                      70
#define LDAPP_CONTROL_ASQ_SRCATTR              71
#define LDAPP_CONTROL_ASQ_RESCODE              72
#define LDAPP_CONTROL_DIRSYNC                  73
#define LDAPP_CONTROL_DIRSYNC_FLAGS            74
#define LDAPP_CONTROL_DIRSYNC_SIZE             75
#define LDAPP_CONTROL_DIRSYNC_COOKIE           76
#define LDAPP_CONTROL_CROSSDOM                 77
#define LDAPP_CONTROL_CROSSDOM_NAME            78
#define LDAPP_CONTROL_STAT                     79
#define LDAPP_CONTROL_STAT_FLAG                80
#define LDAPP_CONTROL_STAT_THREADCOUNT         81
#define LDAPP_CONTROL_STAT_CORETIME            82
#define LDAPP_CONTROL_STAT_CALLTIME            83
#define LDAPP_CONTROL_STAT_SUBSEARCHOPS        84
#define LDAPP_CONTROL_STAT_ENTRIES_RETURNED    85
#define LDAPP_CONTROL_STAT_ENTRIES_VISITED     86
#define LDAPP_CONTROL_STAT_FILTER              87
#define LDAPP_CONTROL_STAT_INDEXES             88
#define LDAPP_CONTROL_GCVERIFYNAME             89
#define LDAPP_CONTROL_GCVERIFYNAME_FLAGS       90
#define LDAPP_CONTROL_GCVERIFYNAME_NAME        91
#define LDAPP_CONTROL_SEARCHOPTS               92
#define LDAPP_CONTROL_SEARCHOPTS_OPTION        93
#define LDAPP_EXT_RESP_NOTICE_OF_DISCONNECT    94
#define LDAPP_EXT_RESP_TLS                     95
#define LDAPP_EXT_RESP_TTL                     96
#define LDAPP_EXT_RESP_TTL_TIME                97
#define LDAPP_EXT_REQ_TLS                      98
#define LDAPP_EXT_REQ_TTL                      99
#define LDAPP_EXT_REQ_TTL_ENTRYNAME           100
#define LDAPP_EXT_REQ_TTL_TIME                101
#define LDAPP_MATCHING_RULE                   102
#define LDAPP_MATCHINGRULE_BIT_AND            103
#define LDAPP_MATCHINGRULE_BIT_OR             104

// Operation defines
#define LDAPP_PROTOCOL_OP_BIND_REQUEST             0
#define LDAPP_PROTOCOL_OP_BIND_RESPONSE            1
#define LDAPP_PROTOCOL_OP_UNBIND_REQUEST           2
#define LDAPP_PROTOCOL_OP_SEARCH_REQUEST           3
#define LDAPP_PROTOCOL_OP_SEARCH_RES_ENTRY         4
#define LDAPP_PROTOCOL_OP_SEARCH_RES_DONE          5
#define LDAPP_PROTOCOL_OP_MODIFY_REQUEST           6
#define LDAPP_PROTOCOL_OP_MODIFY_RESPONSE          7
#define LDAPP_PROTOCOL_OP_ADD_REQUEST              8
#define LDAPP_PROTOCOL_OP_ADD_RESPONSE             9
#define LDAPP_PROTOCOL_OP_DEL_REQUEST             10
#define LDAPP_PROTOCOL_OP_DEL_RESPONSE            11
#define LDAPP_PROTOCOL_OP_MODIFY_RDN_REQUEST      12
#define LDAPP_PROTOCOL_OP_MODIFY_RDN_RESPONSE     13
#define LDAPP_PROTOCOL_OP_COMPARE_REQUEST         14
#define LDAPP_PROTOCOL_OP_COMPARE_RESPONSE        15
#define LDAPP_PROTOCOL_OP_ABANDON_REQUEST         16
#define LDAPP_PROTOCOL_OP_EXTENDED_REQUEST        23
#define LDAPP_PROTOCOL_OP_EXTENDED_RESPONSE       24
#define LDAPP_PROTOCOL_OP_SEARCH_RES_REFERENCE    19
#define LDAPP_PROTOCOL_OP_SEARCH_RESPONSE_FULL    ((BYTE)-1)

// result code defines                             
#define LDAPP_RESULT_CODE_SUCCESS                         0
#define LDAPP_RESULT_CODE_OPERATIONS_ERROR                1
#define LDAPP_RESULT_CODE_PROTOCOL_ERROR                  2
#define LDAPP_RESULT_CODE_TIME_LIMIT_EXCEEDED             3
#define LDAPP_RESULT_CODE_SIZE_LIMIT_EXCEEDED             4
#define LDAPP_RESULT_CODE_COMPARE_FALSE                   5
#define LDAPP_RESULT_CODE_COMPARE_TRUE                    6
#define LDAPP_RESULT_CODE_AUTH_METHOD_NOT_SUPPORTED       7
#define LDAPP_RESULT_CODE_STRONG_AUTH_REQUIRED            8
#define LDAPP_RESULT_CODE_REFERRAL                       10
#define LDAPP_RESULT_CODE_ADMIN_LIMIT_EXCEEDED           11
#define LDAPP_RESULT_CODE_UNAVAILABLE_CRITICAL_EXTENSION 12
#define LDAPP_RESULT_CODE_CONFIDENTIALITY_REQUIRED       13
#define LDAPP_RESULT_CODE_SASL_BIND_IN_PROGRESS          14
#define LDAPP_RESULT_CODE_NO_SUCH_ATTRIBUTE              16
#define LDAPP_RESULT_CODE_UNDEFINED_ATTRIBUTE_TYPE       17
#define LDAPP_RESULT_CODE_INAPPROPRIATE_MATCHING         18
#define LDAPP_RESULT_CODE_CONSTRAINT_VIOLATION           19
#define LDAPP_RESULT_CODE_ATTRIBUTE_OR_VALUE_EXISTS      20
#define LDAPP_RESULT_CODE_INVALID_ATTRIBUTE_SYNTAX       21
#define LDAPP_RESULT_CODE_NO_SUCH_OBJECT                 32
#define LDAPP_RESULT_CODE_ALIAS_PROBLEM                  33
#define LDAPP_RESULT_CODE_INVALID_DN_SYNTAX              34
#define LDAPP_RESULT_CODE_IS_LEAF                        35
#define LDAPP_RESULT_CODE_ALIAS_DEREFERENCING_PROBLEM    36
#define LDAPP_RESULT_CODE_INAPPROPRIATE_AUTHENTICATION   48
#define LDAPP_RESULT_CODE_INVALID_CREDENTIALS            49
#define LDAPP_RESULT_CODE_INSUFFICIENT_ACCESS_RIGHTS     50
#define LDAPP_RESULT_CODE_BUSY                           51
#define LDAPP_RESULT_CODE_UNAVAILABLE                    52
#define LDAPP_RESULT_CODE_UNWILLING_TO_PERFORM           53
#define LDAPP_RESULT_CODE_LOOP_DETECT                    54

#define LDAPP_RESULT_CODE_SORT_CONTROL_MISSING           60
#define LDAPP_RESULT_CODE_INDEX_RANGE_ERROR              61
#define LDAPP_RESULT_CODE_NAMING_VIOLATION               64
#define LDAPP_RESULT_CODE_OBJECT_CLASS_VIOLATION         65

#define LDAPP_RESULT_CODE_NOT_ALLOWED_ON_LEAF            66
#define LDAPP_RESULT_CODE_NOT_ALLOWED_ON_RDN             67
#define LDAPP_RESULT_CODE_ENTRY_ALREADY_EXISTS           68
#define LDAPP_RESULT_CODE_OBJECT_CLASS_MODS_PROHIBITED   69
#define LDAPP_RESULT_CODE_RESULTS_TOO_LARGE              70
#define LDAPP_RESULT_CODE_AFFECTS_MULTIPLE_DSAS          71
#define LDAPP_RESULT_CODE_OTHER                          80

// authentication types
#define LDAPP_AUTHENTICATION_TYPE_SIMPLE      0
#define LDAPP_AUTHENTICATION_TYPE_KRBV42LDAP  1
#define LDAPP_AUTHENTICATION_TYPE_KRBV42DSA   2
#define LDAPP_AUTHENTICATION_TYPE_SASL        3

// Operations
#define LDAPP_OPERATION_ADD     0
#define LDAPP_OPERATION_DELETE  1
#define LDAPP_OPERATION_REPLACE 2
 
// Scopes
#define LDAPP_SCOPE_BASE_OBJECT      0
#define LDAPP_SCOPE_SINGLE_LEVEL     1
#define LDAPP_SCOPE_WHOLE_SUBTREE    2

// Deref Aliases
#define LDAPP_DEREF_ALIASES_NEVER            0
#define LDAPP_DEREF_ALIASES_IN_SEARCHING     1
#define LDAPP_DEREF_ALIASES_FINDING_BASE_OBJ 2
#define LDAPP_DEREF_ALIASES_ALWAYS           3

// size and time limits
#define LDAPP_LIMITS_NONE 0

// Request optional fields
#define LDAPP_EX_REQ_NAME   0
#define LDAPP_EX_REQ_VALUE  1

// Result optional fields
#define LDAPP_RESULT_REFERRAL       3
#define LDAPP_RESULT_SASL_CRED      7
#define LDAPP_RESULT_EX_RES_NAME    10
#define LDAPP_RESULT_EX_RES_VALUE   11

// filter types
#define LDAPP_FILTER_TYPE_AND                0
#define LDAPP_FILTER_TYPE_OR                 1
#define LDAPP_FILTER_TYPE_NOT                2
#define LDAPP_FILTER_TYPE_EQUALITY_MATCH     3
#define LDAPP_FILTER_TYPE_SUBSTRINGS         4
#define LDAPP_FILTER_TYPE_GREATER_OR_EQUAL   5
#define LDAPP_FILTER_TYPE_LESS_OR_EQUAL      6
#define LDAPP_FILTER_TYPE_PRESENT            7
#define LDAPP_FILTER_TYPE_APPROX_MATCH       8
#define LDAPP_FILTER_TYPE_EXTENSIBLE_MATCH   9

// extended filter types
#define LDAPP_FILTER_EX_MATCHING_RULE    1
#define LDAPP_FILTER_EX_TYPE             2
#define LDAPP_FILTER_EX_VALUE            3
#define LDAPP_FILTER_EX_ATTRIBUTES       4

// substring types
#define LDAPP_SUBSTRING_CHOICE_INITIAL  0
#define LDAPP_SUBSTRING_CHOICE_ANY      1
#define LDAPP_SUBSTRING_CHOICE_FINAL    2

// controls type
#define LDAPP_CONTROLS_TAG     0

// Boolean Values
#define LDAPP_BOOLEAN_TRUE  0xFF
#define LDAPP_BOOLEAN_FALSE 0

// some BER imports --------------------

#define TAG_MASK        0x1f
#define BER_FORM_MASK       0x20
#define BER_CLASS_MASK      0xc0

// forms
#define BER_FORM_PRIMATIVE          0x00
#define BER_FORM_CONSTRUCTED        0x20

// classes
#define BER_CLASS_UNIVERSAL         0x00
#define BER_CLASS_APPLICATION       0x40    
#define BER_CLASS_CONTEXT_SPECIFIC  0x80

// Standard BER tags    
#define BER_TAG_INVALID         0x00
#define BER_TAG_BOOLEAN         0x01
#define BER_TAG_INTEGER         0x02
#define BER_TAG_BITSTRING       0x03
#define BER_TAG_OCTETSTRING     0x04
#define BER_TAG_NULL            0x05
#define BER_TAG_ENUMERATED      0x0a
#define BER_TAG_SEQUENCE        0x30
#define BER_TAG_SET             0x31

#define TAG_LENGTH              1

// ---------------------------------------

// control special extensions
#define LDAPP_CTRL_NONE      0
#define LDAPP_CTRL_PAGED     1

// vlv control related
#define LDAPP_VLV_REQ_BYOFFSET_TAG 0

// sort control related
#define LDAPP_SORT_REQ_ORDERINGRULE_TAG 0
#define LDAPP_SORT_REQ_REVERSEORDER_TAG 1

#define LDAPP_SORT_RESP_ATTRTYPE_TAG    0

// stat control related
#define LDAPP_SO_NORMAL        0
#define LDAPP_SO_STATS         1
#define LDAPP_SO_ONLY_OPTIMIZE 2

enum LDAPP_STAT_TYPE {
    STAT_THREADCOUNT = 1,
    STAT_CORETIME = 2,
    STAT_CALLTIME = 3,
    STAT_SUBSRCHOP = 4,
    STAT_ENTRIES_RETURNED = 5,
    STAT_ENTRIES_VISITED = 6,
    STAT_FILTER = 7,
    STAT_INDEXES = 8,
    STAT_NUM_STATS = 8
};

//
// Private controls
//

#define LDAPP_SERVER_GET_STATS_OID           "1.2.840.113556.1.4.970"


//
// Extended Request/Response related
//

#define LDAPP_EXT_REQ_TTL_DN_TAG        0
#define LDAPP_EXT_REQ_TTL_TIME_TAG      1

#define LDAPP_EXT_RESP_TTL_TIME_TAG     1

//=================================================================================================================
// Functions
//=================================================================================================================
// in LDAP-Tags.c
extern BYTE GetTag( ULPBYTE pCurrent );
extern DWORD GetLength( ULPBYTE pInitialPointer, DWORD * LenLen);
extern LONG GetInt(ULPBYTE pCurrent, DWORD Length);
extern BOOL AreOidsEqual(IN LDAPOID *String1, IN LDAPOID *String2);

// in LDAP.C
extern VOID   WINAPI LDAPRegister(HPROTOCOL hLDAP);
extern VOID   WINAPI LDAPDeregister(HPROTOCOL hLDAP);
extern LPBYTE WINAPI LDAPRecognizeFrame(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, LPDWORD, LPHPROTOCOL, PDWORD_PTR);
extern LPBYTE WINAPI LDAPAttachProperties(HFRAME, LPVOID, ULPBYTE, DWORD, DWORD, HPROTOCOL, DWORD, DWORD_PTR);
extern DWORD  WINAPI LDAPFormatProperties(HFRAME hFrame, ULPBYTE MacFrame, ULPBYTE ProtocolFrame, DWORD nPropertyInsts, LPPROPERTYINST p);
extern VOID WINAPIV FormatLDAPSum(LPPROPERTYINST lpProp );

// in LDAPP_ATT.C
extern void AttachLDAPResult( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD Level);
extern void AttachLDAPBindRequest( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft);
extern void AttachLDAPBindResponse( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft);
extern void AttachLDAPSearchRequest( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft);
extern void AttachLDAPSearchResponse( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD Level);
extern void AttachLDAPModifyRequest( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft);
extern void AttachLDAPDelRequest( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft);
extern void AttachLDAPModifyRDNRequest( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft);
extern void AttachLDAPCompareRequest( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft);
extern void AttachLDAPAbandonRequest( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft);
extern void AttachLDAPFilter( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD Level);
extern void AttachLDAPSearchResponseReference( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD Level);
extern void AttachLDAPSearchResponseFull( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft);
extern void AttachLDAPExtendedRequest( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD ReqSize);
extern void AttachLDAPExtendedReqValTTL( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbReqValue);
extern void AttachLDAPExtendedResponse( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD RespSize);
extern void AttachLDAPExtendedRespValTTL( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbRespValue);
extern void AttachLDAPOptionalControls( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft);
extern void AttachLDAPControl( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft);
extern void AttachLDAPControlValPaged( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValVLVReq( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValVLVResp( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValSortReq( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValSortResp( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValSD( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValASQ( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValDirSync( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValCrossDomMove( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValStats( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValGCVerify( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValSearchOpts( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\netmon_parser\ldapdata.c ===
//=================================================================================================================
//  MODULE: ldapdata.c
//                                                                                                                 
//  Description: Data structures for the Lightweight Directory Access Protocol (LDAP) Parser
//
//  Bloodhound parser for LDAP
//                                                                                                                 
//  Note: info for this parser was gleaned from:
//  rfc 1777, March 1995
//  recommendation x.209 BER for ASN.1
//  recommendation x.208 ASN.1
//  draft-ietf-asid-ladpv3-protocol-05    <06/05/97>
//
//  Modification History                                                                                           
//                                                                                                                 
//  Arthur Brooking     05/08/96        Created from GRE Parser
//  Peter  Oakley       06/29/97        Added datatypes for LDAP version 3
//=================================================================================================================
#include "ldap.h"
#include "draatt.h"
    
// text for protocol types
LABELED_BYTE LDAPProtocolOPs[] =
{
    { LDAPP_PROTOCOL_OP_BIND_REQUEST,          "BindRequest"},      
    { LDAPP_PROTOCOL_OP_BIND_RESPONSE,         "BindResponse"},     
    { LDAPP_PROTOCOL_OP_UNBIND_REQUEST,        "UnbindRequest"},    
    { LDAPP_PROTOCOL_OP_SEARCH_REQUEST,        "SearchRequest"},    
    { LDAPP_PROTOCOL_OP_SEARCH_RES_ENTRY,      "SearchResponse"},   
    { LDAPP_PROTOCOL_OP_SEARCH_RES_DONE,       "SearchResponse (simple)"}, 
    { LDAPP_PROTOCOL_OP_SEARCH_RES_REFERENCE,  "SearchResponse Reference"},
    { LDAPP_PROTOCOL_OP_MODIFY_REQUEST,        "ModifyRequest"},    
    { LDAPP_PROTOCOL_OP_MODIFY_RESPONSE,       "ModifyResponse"},   
    { LDAPP_PROTOCOL_OP_ADD_REQUEST,           "AddRequest"},       
    { LDAPP_PROTOCOL_OP_ADD_RESPONSE,          "AddResponse"},      
    { LDAPP_PROTOCOL_OP_DEL_REQUEST,           "DelRequest"},       
    { LDAPP_PROTOCOL_OP_DEL_RESPONSE,          "DelResponse"},      
    { LDAPP_PROTOCOL_OP_MODIFY_RDN_REQUEST,    "ModifyDNRequest"}, 
    { LDAPP_PROTOCOL_OP_MODIFY_RDN_RESPONSE,   "ModifyDNResponse"},
    { LDAPP_PROTOCOL_OP_COMPARE_REQUEST,       "CompareRequest"},   
    { LDAPP_PROTOCOL_OP_COMPARE_RESPONSE,      "CompareResponse"},  
    { LDAPP_PROTOCOL_OP_ABANDON_REQUEST,       "AbandonRequest"},
    { LDAPP_PROTOCOL_OP_EXTENDED_REQUEST,      "ExtendedRequest"},
    { LDAPP_PROTOCOL_OP_EXTENDED_RESPONSE,     "ExtendedResponse"},
    { LDAPP_PROTOCOL_OP_SEARCH_RESPONSE_FULL,  "SearchResponseFull"}
};
SET LDAPProtocolOPsSET = {(sizeof(LDAPProtocolOPs)/sizeof(LABELED_BYTE)), LDAPProtocolOPs };

// text for result codes
LABELED_DWORD LDAPResultCodes[] =
{
    { LDAPP_RESULT_CODE_SUCCESS                          ,"Success"},      
    { LDAPP_RESULT_CODE_OPERATIONS_ERROR                 ,"Operations Error"},      
    { LDAPP_RESULT_CODE_PROTOCOL_ERROR                   ,"Protocol Error"},      
    { LDAPP_RESULT_CODE_TIME_LIMIT_EXCEEDED              ,"Time Limit Exceeded"},      
    { LDAPP_RESULT_CODE_SIZE_LIMIT_EXCEEDED              ,"Size Limit Exceeded"},      
    { LDAPP_RESULT_CODE_COMPARE_FALSE                    ,"Compare False"},      
    { LDAPP_RESULT_CODE_COMPARE_TRUE                     ,"Compare True"},      
    { LDAPP_RESULT_CODE_AUTH_METHOD_NOT_SUPPORTED        ,"Auth Method Not Supported"},      
    { LDAPP_RESULT_CODE_STRONG_AUTH_REQUIRED             ,"Strong Auth Required"},
    { LDAPP_RESULT_CODE_REFERRAL                         ,"Referral"},
    { LDAPP_RESULT_CODE_ADMIN_LIMIT_EXCEEDED             ,"Admin Limit Exceeded"},
    { LDAPP_RESULT_CODE_UNAVAILABLE_CRITICAL_EXTENSION   ,"Unavailable Critical Extension"},
    { LDAPP_RESULT_CODE_CONFIDENTIALITY_REQUIRED         ,"Confidentiality Required"},
    { LDAPP_RESULT_CODE_SASL_BIND_IN_PROGRESS            ,"Sasl Bind In Progress"},
    { LDAPP_RESULT_CODE_NO_SUCH_ATTRIBUTE                ,"No Such Attribute"},      
    { LDAPP_RESULT_CODE_UNDEFINED_ATTRIBUTE_TYPE         ,"Undefined Attribute Type"},      
    { LDAPP_RESULT_CODE_INAPPROPRIATE_MATCHING           ,"Inappropriate Matching"},      
    { LDAPP_RESULT_CODE_CONSTRAINT_VIOLATION             ,"Constraint Violation"},      
    { LDAPP_RESULT_CODE_ATTRIBUTE_OR_VALUE_EXISTS        ,"Attribute Or Value Exists"},      
    { LDAPP_RESULT_CODE_INVALID_ATTRIBUTE_SYNTAX         ,"Invalid Attribute Syntax"},      
    { LDAPP_RESULT_CODE_NO_SUCH_OBJECT                   ,"No Such Object"},      
    { LDAPP_RESULT_CODE_ALIAS_PROBLEM                    ,"Alias Problem"},      
    { LDAPP_RESULT_CODE_INVALID_DN_SYNTAX                ,"Invalid Dn Syntax"},      
    { LDAPP_RESULT_CODE_IS_LEAF                          ,"Is Leaf"},      
    { LDAPP_RESULT_CODE_ALIAS_DEREFERENCING_PROBLEM      ,"Alias Dereferencing Problem"},      
    { LDAPP_RESULT_CODE_INAPPROPRIATE_AUTHENTICATION     ,"Inappropriate Authentication"},      
    { LDAPP_RESULT_CODE_INVALID_CREDENTIALS              ,"Invalid Credentials"},      
    { LDAPP_RESULT_CODE_INSUFFICIENT_ACCESS_RIGHTS       ,"Insufficient Access Rights"},      
    { LDAPP_RESULT_CODE_BUSY                             ,"Busy"},    
    { LDAPP_RESULT_CODE_UNAVAILABLE                      ,"Unavailable"},
    { LDAPP_RESULT_CODE_UNWILLING_TO_PERFORM             ,"Unwilling to Perform"},
    { LDAPP_RESULT_CODE_SORT_CONTROL_MISSING             ,"Sort Control Missing"},
    { LDAPP_RESULT_CODE_INDEX_RANGE_ERROR                ,"Index Range Error"},
    { LDAPP_RESULT_CODE_NAMING_VIOLATION                 ,"Naming Violation"},
    { LDAPP_RESULT_CODE_OBJECT_CLASS_VIOLATION           ,"Object Class Violation"},
    { LDAPP_RESULT_CODE_LOOP_DETECT                      ,"Loop Detect"},
    { LDAPP_RESULT_CODE_NOT_ALLOWED_ON_LEAF              ,"Not Allowed on Leaf"},
    { LDAPP_RESULT_CODE_NOT_ALLOWED_ON_RDN               ,"Not Allowed on RDN"},
    { LDAPP_RESULT_CODE_ENTRY_ALREADY_EXISTS             ,"Entry Already Exists"},
    { LDAPP_RESULT_CODE_OBJECT_CLASS_MODS_PROHIBITED     ,"Object Class Mods Prohibited"},
    { LDAPP_RESULT_CODE_RESULTS_TOO_LARGE                ,"Results Too Large"},
    { LDAPP_RESULT_CODE_AFFECTS_MULTIPLE_DSAS            ,"Affects Multiple DSAs"},
    { LDAPP_RESULT_CODE_OTHER                            ,"Other"},
};
SET LDAPResultCodesSET = {(sizeof(LDAPResultCodes)/sizeof(LABELED_DWORD)), LDAPResultCodes };

LABELED_BYTE LDAPAuthenticationTypes[] =
{
    { LDAPP_AUTHENTICATION_TYPE_SIMPLE    ,"Simple"},      
    { LDAPP_AUTHENTICATION_TYPE_KRBV42LDAP,"krbv42LDAP"},      
    { LDAPP_AUTHENTICATION_TYPE_KRBV42DSA ,"krbv42DSA"}, 
    { LDAPP_AUTHENTICATION_TYPE_SASL      ,"Sasl"},
};
SET LDAPAuthenticationTypesSET = {(sizeof(LDAPAuthenticationTypes)/sizeof(LABELED_BYTE)), LDAPAuthenticationTypes };

LABELED_DWORD LDAPOperations[] =
{
    { LDAPP_OPERATION_ADD    ,"Add"},      
    { LDAPP_OPERATION_DELETE ,"Delete"},      
    { LDAPP_OPERATION_REPLACE,"Replace"},      
};
SET LDAPOperationsSET = {(sizeof(LDAPOperations)/sizeof(LABELED_DWORD)), LDAPOperations };

LABELED_DWORD LDAPScopes[] =
{
    { LDAPP_SCOPE_BASE_OBJECT  ,"Base Object"},      
    { LDAPP_SCOPE_SINGLE_LEVEL ,"Single Level"},      
    { LDAPP_SCOPE_WHOLE_SUBTREE,"Whole Subtree"},      
};
SET LDAPScopesSET = {(sizeof(LDAPScopes)/sizeof(LABELED_DWORD)), LDAPScopes };

LABELED_DWORD LDAPDerefAliases[] =
{
    { LDAPP_DEREF_ALIASES_NEVER           ,"Never Deref Aliases"},      
    { LDAPP_DEREF_ALIASES_IN_SEARCHING    ,"Deref In Searching"},      
    { LDAPP_DEREF_ALIASES_FINDING_BASE_OBJ,"Deref Finding Base Objects"},      
    { LDAPP_DEREF_ALIASES_ALWAYS          ,"Always Deref Aliases"},      
};
SET LDAPDerefAliasesSET = {(sizeof(LDAPDerefAliases)/sizeof(LABELED_DWORD)), LDAPDerefAliases };

LABELED_DWORD LDAPLimits[] =
{
    { LDAPP_LIMITS_NONE ,"No Limit"},      
};
SET LDAPLimitsSET = {(sizeof(LDAPLimits)/sizeof(LABELED_DWORD)), LDAPLimits };

LABELED_BYTE LDAPFilterTypes[] =
{
    { LDAPP_FILTER_TYPE_AND             ,"And"},      
    { LDAPP_FILTER_TYPE_OR              ,"Or"},      
    { LDAPP_FILTER_TYPE_NOT             ,"Not"},      
    { LDAPP_FILTER_TYPE_EQUALITY_MATCH  ,"Equality Match"},      
    { LDAPP_FILTER_TYPE_SUBSTRINGS      ,"Substrings"},      
    { LDAPP_FILTER_TYPE_GREATER_OR_EQUAL,"Greater Or Equal"},      
    { LDAPP_FILTER_TYPE_LESS_OR_EQUAL   ,"Less Or Equal"},      
    { LDAPP_FILTER_TYPE_PRESENT         ,"Present"},      
    { LDAPP_FILTER_TYPE_APPROX_MATCH    ,"Approximate Match"},
    { LDAPP_FILTER_TYPE_EXTENSIBLE_MATCH ,"Extensible Match"},
};
SET LDAPFilterTypesSET = {(sizeof(LDAPFilterTypes)/sizeof(LABELED_BYTE)), LDAPFilterTypes };

LABELED_BYTE LDAPBoolean[] =
{
    { LDAPP_BOOLEAN_TRUE             ,"True"},      
    { LDAPP_BOOLEAN_FALSE            ,"False"},      
   
};
SET LDAPBooleanSET = {(sizeof(LDAPBoolean)/sizeof(LABELED_BYTE)), LDAPBoolean };

LABELED_DWORD LDAPSDControlVals[] =
{
    { OWNER_SECURITY_INFORMATION           ,"Owner"},      
    { GROUP_SECURITY_INFORMATION           ,"Group"},      
    { DACL_SECURITY_INFORMATION            ,"DACL"},      
    { SACL_SECURITY_INFORMATION            ,"SACL"},      
    { PROTECTED_DACL_SECURITY_INFORMATION  ,"Protected DACL"},      
    { PROTECTED_SACL_SECURITY_INFORMATION  ,"Protected SACL"},      
    { UNPROTECTED_DACL_SECURITY_INFORMATION,"Unprotected DACL"},      
    { UNPROTECTED_SACL_SECURITY_INFORMATION,"Unprotected SACL"},      
};
SET LDAPSDControlValsSET = {(sizeof(LDAPSDControlVals)/sizeof(LABELED_DWORD)), LDAPSDControlVals };

LABELED_DWORD LDAPStatFlags[] =
{
    { LDAPP_SO_NORMAL        ,"LDAPP_SO_NORMAL"},      
    { LDAPP_SO_STATS         ,"LDAPP_SO_STATS"},
    { LDAPP_SO_ONLY_OPTIMIZE ,"LDAPP_SO_ONLY_OPTIMIZE"},
};
SET LDAPStatFlagsSET = {(sizeof(LDAPStatFlags)/sizeof(LABELED_DWORD)), LDAPStatFlags };

LABELED_DWORD LDAPSearchOpts[] =
{
    { SERVER_SEARCH_FLAG_DOMAIN_SCOPE  ,"Domain Scope"},      
    { SERVER_SEARCH_FLAG_PHANTOM_ROOT  ,"Phantom Root"},
};
SET LDAPSearchOptsSET = {(sizeof(LDAPSearchOpts)/sizeof(LABELED_DWORD)), LDAPSearchOpts };

LABELED_DWORD LDAPDirSyncFlags[] =
{
    { DRS_DIRSYNC_PUBLIC_DATA_ONLY, "Public Data" },
    { DRS_DIRSYNC_INCREMENTAL_VALUES, "Incremental Values"},
    { DRS_DIRSYNC_OBJECT_SECURITY, "Object-level Security"},
    { DRS_DIRSYNC_ANCESTORS_FIRST_ORDER, "Include Ancestors"},
};
SET LDAPDirSyncFlagsSET = {(sizeof(LDAPDirSyncFlags)/sizeof(LABELED_DWORD)), LDAPDirSyncFlags };

// Properties
PROPERTYINFO    LDAPPropertyTable[] = 
{
    // LDAPP_SUMMARY 0
    { 0, 0,
      "Summary",
      "Summary of the LDAP Packet",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatLDAPSum
    },

    // LDAPP_MESSAGE_ID 1
    { 0, 0,
      "MessageID",
      "Message ID",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_PROTOCOL_OP 2
    { 0, 0,
      "ProtocolOp",
      "Gives the frame type",
      PROP_TYPE_BYTE,
      PROP_QUAL_LABELED_SET,
      &LDAPProtocolOPsSET,
      80,
      FormatPropertyInstance
    },

    // LDAPP_RESULT_CODE 3
    { 0, 0,
      "Result Code",
      "Status of the response",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPResultCodesSET,
      80,
      FormatPropertyInstance
    },

    // LDAPP_MATCHED_DN 4
    { 0, 0,
      "Matched DN",
      "Matched DN",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_ERROR_MESSAGE 5
    { 0, 0,
      "Error Message",
      "Error Message",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_VERSION 6
    { 0, 0,
      "Version",
      "Version",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_NAME 7
    { 0, 0,
      "Name",
      "null name implies anonymous bind",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_AUTHENTICATION_TYPE 8
    { 0, 0,
      "Authentication Type",
      "Authentication Type",
      PROP_TYPE_BYTE,
      PROP_QUAL_LABELED_SET,
      &LDAPAuthenticationTypesSET,
      80,
      FormatPropertyInstance
    },

    // LDAPP_AUTHENTICATION 9
    { 0, 0,
      "Authentication",
      "Authentication",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_OBJECT_NAME 10
    { 0, 0,
      "Object Name",
      "Object Name",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_ATTRIBUTE_TYPE 11
    { 0, 0,
      "Attribute Type",
      "Attribute Type",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_ATTRIBUTE_VALUE 12
    { 0, 0,
      "Attribute Value",
      "Attribute Value",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_OPERATION 13
    { 0, 0,
      "Operation",
      "Operation",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPOperationsSET,
      80,
      FormatPropertyInstance
    },

    // LDAPP_NEW_RDN 14
    { 0, 0,
      "New RDN",
      "New RDN",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_BASE_OBJECT 15
    { 0, 0,
      "Base Object",
      "Base Object",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_SCOPE 16
    { 0, 0,
      "Scope",
      "Scope",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPScopesSET,
      80,
      FormatPropertyInstance
    },

    // LDAPP_DEREF_ALIASES 17
    { 0, 0,
      "Deref Aliases",
      "Deref Aliases",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPDerefAliasesSET,
      80,
      FormatPropertyInstance
    },

    // LDAPP_SIZE_LIMIT 18
    { 0, 0,
      "Size Limit",
      "Size Limit",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPLimitsSET,
      80,
      FormatPropertyInstance
    },

    // Time Limit 19
    { 0, 0,
      "Time Limit",
      "Time Limit",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPLimitsSET,
      80,
      FormatPropertyInstance
    },

    // LDAPP_ATTRS_ONLY 20
    { 0, 0,
      "Attrs Only",
      "Attrs Only",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

    // LDAPP_FILTER_TYPE 21
    { 0, 0,
      "Filter Type",
      "Filter Type",
      PROP_TYPE_BYTE,
      PROP_QUAL_LABELED_SET,
      &LDAPFilterTypesSET,
      80,
      FormatPropertyInstance
    },

    // LDAPP_SUBSTRING_INITIAL 22
    { 0, 0,
      "Substring (Initial)",
      "Substring (Initial)",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_SUBSTRING_ANY 23
    { 0, 0,
      "Substring (Any)",
      "Substring (Any)",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_SUBSTRING_FINAL 24
    { 0, 0,
      "Substring (Final)",
      "Substring (Final)",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_REFERRAL_SERVER 25
    { 0, 0,
      "Referral Server",
      "Server",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_SASL_MECHANISM 26
    { 0, 0,
      "Sasl Mechanism",
      "Mechanism",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },
     
      // LDAPP_SASL_CREDENTIALS 27
    { 0, 0,
      "Sasl Credentials",
      "Credentials",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

      // LDAPP_DELETE_OLD_RDN 28
    { 0, 0,
      "Delete Old RDN",
      "Delete Old RDN",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

       // LDAPP_NEW_SUPERIOR 29
    { 0, 0,
      "New Superior",
      "New Superior",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },
       
       // LDAPP_REQUEST_NAME  30
    { 0, 0,
      "Request Name",
      "Request",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

       // LDAPP_REQUEST_VALUE  31
    { 0, 0,
      "Request Value",
      "Value",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

        // LDAPP_RESPONSE_NAME  32
    { 0, 0,
      "Response Name",
      "Name",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

       // LDAPP_RESPONSE_VALUE  33
    { 0, 0,
      "Response Value",
      "Value",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

        // LDAPP_DN_ATTRIBUTES 34
    { 0, 0,
      "dnAttributes",
      "dnAttributes",
      PROP_TYPE_BYTE,
      PROP_QUAL_LABELED_SET,
      &LDAPBooleanSET,
      80,
      FormatPropertyInstance
      },

        // LDAPP_CONTROL_TYPE 35
    { 0, 0,
      "Control Type",
      "Control Type",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

        // LDAPP_CRITICALITY 36
    { 0, 0,
      "Criticality",
      "Criticality",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

        // LDAPP_CONTROL_VALUE 37
    { 0, 0,
      "Control Value",
      "Control Value",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

            // LDAPP_CONTROL_PAGED 38
     { 0, 0,
      "Paged Control",
      "Paged Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },


            // LDAPP_CONTROL_PAGED_SIZE 39
    { 0, 0,
      "Page Size",
      "Size",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

            // LDAPP_CONTROL_PAGED_COOKIE 40
    { 0, 0,
      "Paged Cookie",
      "Paged Control Cookie",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },
       
            // LDAPP_ATTR_DESCR_LIST 41
    { 0, 0,
      "Attribute Description List",
      "Attribute Description List",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

            // LDAPP_FILTER 42
    { 0, 0,
      "Filter",
      "Filter",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

            // LDAPP_CONTROLS 43
    { 0, 0,
      "Controls",
      "Controls",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

            // LDAPP_CONTROL_VLVREQ 44
     { 0, 0,
      "VLV Request Control",
      "VLV Request Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },
    
     // LDAPP_CONTROL_VLVREQ_BCOUNT 45
    { 0, 0,
      "VLV Before Count",
      "VLV Request Before Count",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },
    
    // LDAPP_CONTROL_VLVREQ_ACOUNT 46
    { 0, 0,
      "VLV After Count",
      "VLV Request After Count",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

        // LDAPP_CONTROL_VLVREQ_OFFSET 47
    { 0, 0,
      "VLV Offset",
      "VLV Request Offset",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

        // LDAPP_CONTROL_VLV_CONTENTCOUNT 48
    { 0, 0,
      "VLV Content Count",
      "VLV ContentCount",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

        // LDAPP_CONTROL_VLVREQ_GE 49
    { 0, 0,
      "VLV Greater Than Or Equal To",
      "VLV Request greaterThanOrEqual",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

        // LDAPP_CONTROL_VLV_CONTEXT 50
    { 0, 0,
      "VLV ContextID",
      "VLV ContextID",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_VLVRESP_TARGETPOS 51
    { 0, 0,
      "VLV Target Position",
      "VLV Response Target Position",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

        // LDAPP_CONTROL_VLVRESP_RESCODE 52
    { 0, 0,
      "VLV Result Code",
      "VLV Response Result Code",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPResultCodesSET,
      80,
      FormatPropertyInstance
    },
            
        // LDAPP_CONTROL_VLVRESP 53
     { 0, 0,
      "VLV Response Control",
      "VLV Response Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

        // LDAPP_CONTROL_SORTREQ 54
     { 0, 0,
      "Sort Request Control",
      "Sort Request Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },
    
        // LDAPP_CONTROL_SORTREQ_ATTRTYPE 55
    { 0, 0,
      "Sort Request Attribute Type",
      "Sort Request Attribute Type",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },
        // LDAPP_CONTROL_SORTREQ_MATCHINGRULE 56
     { 0, 0,
      "Sort Matching Rule ID",
      "Sort Request Matching Rule ID",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

        // LDAPP_CONTROL_SORTREQ_REVERSE 57
    { 0, 0,
      "Sort Reverse Order",
      "Sort Request Reverse Order",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

        // LDAPP_CONTROL_SORTRESP 58
     { 0, 0,
      "Sort Response Control",
      "Sort Response Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

        // LDAPP_CONTROL_SORTRESP_RESCODE 59
    { 0, 0,
      "Sort Result Code",
      "Sort Response Result Code",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPResultCodesSET,
      80,
      FormatPropertyInstance
    },

        // LDAPP_CONTROL_SORTRESP_ATTRTYPE 60
    { 0, 0,
      "Sort Response Attribute Type",
      "Sort Response Attribute Type",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_SD 61
    { 0, 0,
      "Security Descriptor Control",
      "Security Descriptor Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_SD_VAL 62
    { 0, 0,
      "SD Val",
      "Security Descriptor Control Values",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPSDControlValsSET,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_SHOWDELETED 63
    { 0, 0,
      "Show Deleted Objects Control",
      "Show Deleted Objects Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_TREEDELETE 64
    { 0, 0,
      "Tree Delete Control",
      "Tree Delete Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_EXTENDEDDN 65
    { 0, 0,
      "Extended DN Control",
      "Extended DN Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_LAZYCOMMIT 66
    { 0, 0,
      "Lazy Commit Control",
      "Lazy Commit Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_NOTIFY 67
    { 0, 0,
      "Notification Control",
      "Notification Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_DOMAINSCOPE 68
    { 0, 0,
      "Domain Scope Control",
      "Domain Scope Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_PERMISSIVEMOD 69
    { 0, 0,
      "Permissive Modify Control",
      "Permissive Modify Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_ASQ 70
    { 0, 0,
      "Attribute Scoped Query Control",
      "ASQ Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_ASQ_SRCATTR 71
    { 0, 0,
      "ASQ Source Attribute",
      "ASQ Source Attribute",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

        // LDAPP_CONTROL_ASQ_RESCODE 72
    { 0, 0,
      "ASQ Result Code",
      "ASQ Response Result Code",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPResultCodesSET,
      80,
      FormatPropertyInstance
    },
            
            // LDAPP_CONTROL_DIRSYNC 73
    { 0, 0,
      "DirSync Control",
      "DirSync Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

        // LDAPP_CONTROL_DIRSYNC_FLAGS 74
    { 0, 0,
      "DirSync Flags",
      "DirSync Flags",
      PROP_TYPE_DWORD,
      PROP_QUAL_LABELED_SET,
      &LDAPDirSyncFlagsSET,
      80,
      FormatPropertyInstance
    },
            
        // LDAPP_CONTROL_DIRSYNC_SIZE 75
    { 0, 0,
      "DirSync Size",
      "DirSync Size",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },
            
            // LDAPP_CONTROL_DIRSYNC_COOKIE 76
    { 0, 0,
      "DirSync Cookie",
      "DirSync Cookie",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_CROSSDOM 77
    { 0, 0,
      "Cross Domain Move Control",
      "Cross Domain Move Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_CROSSDOM_NAME 78
    { 0, 0,
      "CDM Target",
      "Cross Domain Move Control Target Server Field",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_STAT 79
    { 0, 0,
      "Server Stats Control",
      "Server Stats Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_STAT_FLAG 80
    { 0, 0,
      "Stat Flags",
      "Stat Flags",
      PROP_TYPE_DWORD,
      PROP_QUAL_LABELED_SET,
      &LDAPStatFlagsSET,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_STAT_THREADCOUNT 81
    { 0, 0,
      "Stat Threadcount",
      "Stat Threadcount",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_STAT_CORETIME 82
    { 0, 0,
      "Stat Core Time (ms)",
      "Stat Core Time in milliseconds",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_STAT_CALLTIME 83
    { 0, 0,
      "Stat Call Time (ms)",
      "Stat Call Time in milliseconds",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_STAT_SUBSEARCHOPS 84
    { 0, 0,
      "Stat Subsearch Ops",
      "Stat Subsearch Ops",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_STAT_ENTRIES_RETURNED 85
    { 0, 0,
      "Stat Entries Returned",
      "Stat Entries Returned",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_STAT_ENTRIES_VISITED 86
    { 0, 0,
      "Stat Entries Visited",
      "Stat Entries Visited",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_STAT_FILTER 87
    { 0, 0,
      "Stat Filter Used",
      "Stat Filter Used",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_STAT_INDEXES 88
    { 0, 0,
      "Stat Indexes Used",
      "Stat Indexes Used",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_GCVERIFYNAME 89
    { 0, 0,
      "GC Verify Name Control",
      "GC Verify Name Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_GCVERIFYNAME_FLAGS 90
    { 0, 0,
      "GCVerify Flags",
      "GC Verify Name Control Flags",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_GCVERIFYNAME_NAME 91
    { 0, 0,
      "GCVerify Server Name",
      "GC Verify Name Control Name",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_SEARCHOPTS 92
    { 0, 0,
      "Search Options Control",
      "Search Options Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_SEARCHOPTS_OPTION 93
    { 0, 0,
      "Search Option",
      "Search Option",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPSearchOptsSET,
      80,
      FormatPropertyInstance
    },

            // LDAPP_EXT_RESP_NOTICE_OF_DISCONNECT 94
    { 0, 0,
      "Notice Of Disconnect",
      "Notice Of Disconnect",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_EXT_RESP_TLS 95
    { 0, 0,
      "TLS Response",
      "TLS Response",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_EXT_RESP_TTL 96
    { 0, 0,
      "TTL Response",
      "TTL Response",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_EXT_RESP_TTL_TIME 97
    { 0, 0,
      "TTL Response Time",
      "TTL Response Time",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_EXT_REQ_TLS 98
    { 0, 0,
      "TLS Request",
      "TLS Request",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_EXT_REQ_TTL 99
    { 0, 0,
      "TTL Request",
      "TTL Request",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_EXT_REQ_TTL_ENTRYNAME 100
    { 0, 0,
      "TTL Request Entry Name",
      "TTL Request Entry Name",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_EXT_REQ_TTL_TIME 101
    { 0, 0,
      "TTL Request Time",
      "TTL Request Time",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_MATCHING_RULE 102
    { 0, 0,
      "Matching Rule",
      "Matching Rule",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_MATCHINGRULE_BIT_AND 103
    { 0, 0,
      "Bitwise AND",
      "Bitwise AND",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },
            
            // LDAPP_MATCHINGRULE_BIT_OR 104
    { 0, 0,
      "Bitwise OR",
      "Bitwise OR",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },
            
};
DWORD   nNumLDAPProps = (sizeof(LDAPPropertyTable)/sizeof(PROPERTYINFO));

#define LDAP_SERVER_GET_STATS_OID           "1.2.840.113556.1.4.970"

OIDATTACHENTRY KnownControls[] = {
    // Paged
    {
        DEFINE_LDAP_STRING(LDAP_PAGED_RESULT_OID_STRING),   // 319
        LDAPP_CONTROL_PAGED,
        AttachLDAPControlValPaged
    },

    // Security Descriptor
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_SD_FLAGS_OID),       // 801
        LDAPP_CONTROL_SD,
        AttachLDAPControlValSD
    },

    // Sort request
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_SORT_OID),           // 473
        LDAPP_CONTROL_SORTREQ,
        AttachLDAPControlValSortReq
    },
    
    // Sort response
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_RESP_SORT_OID),      // 474
        LDAPP_CONTROL_SORTRESP,
        AttachLDAPControlValSortResp
    },
    
    // Notification
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_NOTIFICATION_OID),   // 528
        LDAPP_CONTROL_NOTIFY,
        NULL
    },
    
    // Show Deleted
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_SHOW_DELETED_OID),   // 417
        LDAPP_CONTROL_SHOWDELETED,
        NULL
    },
    
    // Lazy Commit
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_LAZY_COMMIT_OID),    // 619
        LDAPP_CONTROL_LAZYCOMMIT,
        NULL
    },
    
    // DirSync
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_DIRSYNC_OID),        // 841
        LDAPP_CONTROL_DIRSYNC,
        AttachLDAPControlValDirSync
    },
    
    // Extended DN
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_EXTENDED_DN_OID),    // 529
        LDAPP_CONTROL_EXTENDEDDN,
        NULL
    },
    
    // Tree Delete
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_TREE_DELETE_OID),    // 805
        LDAPP_CONTROL_TREEDELETE,
        NULL
    },
    
    // Cross Domain Move
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_CROSSDOM_MOVE_TARGET_OID),   // 521
        LDAPP_CONTROL_CROSSDOM,
        AttachLDAPControlValCrossDomMove
    },
    
    // Stats
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_GET_STATS_OID),      // 970
        LDAPP_CONTROL_STAT,
        AttachLDAPControlValStats
    },
    
    // GC Verify Name
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_VERIFY_NAME_OID),    // 1338
        LDAPP_CONTROL_GCVERIFYNAME,
        AttachLDAPControlValGCVerify
    },
    
    // Domain Scope
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_DOMAIN_SCOPE_OID),   // 1339
        LDAPP_CONTROL_DOMAINSCOPE,
        NULL
    },
    
    // Search Options
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_SEARCH_OPTIONS_OID), // 1340 
        LDAPP_CONTROL_SEARCHOPTS,
        AttachLDAPControlValSearchOpts
    },
    
    // Permissive Modify
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_PERMISSIVE_MODIFY_OID),//1413
        LDAPP_CONTROL_PERMISSIVEMOD,
        NULL
    },
    
    // VLV request
    {
        DEFINE_LDAP_STRING(LDAP_CONTROL_VLVREQUEST),         // 9
        LDAPP_CONTROL_VLVREQ,
        AttachLDAPControlValVLVReq
    },
    
    // VLV response
    {
        DEFINE_LDAP_STRING(LDAP_CONTROL_VLVRESPONSE),        // 10
        LDAPP_CONTROL_VLVRESP,
        AttachLDAPControlValVLVResp
    },
    
    // ASQ 
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_ASQ_OID),             // 1504
        LDAPP_CONTROL_ASQ,
        AttachLDAPControlValASQ
    },
};
DWORD nNumKnownControls = (sizeof(KnownControls)/sizeof(OIDATTACHENTRY));

OIDATTACHENTRY KnownExtendedRequests [] = {
    
    // TLS
    {
        DEFINE_LDAP_STRING(LDAP_START_TLS_OID),
        LDAPP_EXT_REQ_TLS,
        NULL
    },

    // TTL
    {
        DEFINE_LDAP_STRING(LDAP_TTL_EXTENDED_OP_OID),
        LDAPP_EXT_REQ_TTL,
        AttachLDAPExtendedReqValTTL
    },
};
DWORD nNumKnownExtendedRequests = (sizeof(KnownExtendedRequests)/sizeof(OIDATTACHENTRY));

OIDATTACHENTRY KnownExtendedResponses [] = {
    
    // Notice of Disconnect
    {
        DEFINE_LDAP_STRING("1.3.6.1.4.1.1466.20036"),
        LDAPP_EXT_RESP_NOTICE_OF_DISCONNECT,
        NULL
    },
    
    // TLS
    {
        DEFINE_LDAP_STRING(LDAP_START_TLS_OID),        // 20037
        LDAPP_EXT_RESP_TLS,
        NULL
    },

    // TTL
    {
        DEFINE_LDAP_STRING(LDAP_TTL_EXTENDED_OP_OID),   // 119.1  
        LDAPP_EXT_RESP_TTL,
        AttachLDAPExtendedRespValTTL
    },
};
DWORD nNumKnownExtendedResponses = (sizeof(KnownExtendedResponses)/sizeof(OIDATTACHENTRY));

OIDATTACHENTRY KnownMatchingRules[] = {

    // Bitwise AND
    {
        DEFINE_LDAP_STRING("1.2.840.113556.1.4.803"),
        LDAPP_MATCHINGRULE_BIT_AND,
        NULL
    },

    // Bitwise OR
    {
        DEFINE_LDAP_STRING("1.2.840.113556.1.4.804"),
        LDAPP_MATCHINGRULE_BIT_OR,
        NULL
    },

};
DWORD nNumKnownMatchingRules = (sizeof(KnownMatchingRules)/sizeof(OIDATTACHENTRY));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\netmon_parser\ldap_att.c ===
//=================================================================================================================
//  MODULE: ldap_att.h
//                                                                                                                 
//  Description: Attachment functions for the Lightweight Directory Access Protocol (LDAP) Parser
//
//  Bloodhound parser for LDAP
//                                                                                                                 
//  Note: info for this parser was gleaned from:
//  rfc 1777, March 1995
//  recommendation x.209 BER for ASN.1
//  recommendation x.208 ASN.1
//  draft-ietf-asid-ladpv3-protocol-05    <06/05/97>
//  
//  Modification History                                                                                           
//                                                                                                                 
//  Arthur Brooking     05/08/96        Created from GRE Parser
//  Peter  Oakley       06/29/97        Updated for LDAP version 3
//=================================================================================================================
#include "ldap.h"
#include <netmon.h>
    
//==========================================================================================================================
//  FUNCTION: AttachLDAPResult()
//==========================================================================================================================
void AttachLDAPResult( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD Level)
{
    
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    DWORD  SeqLength;
    BYTE   Tag;

    // result code ---------------------------
    Tag = GetTag(*ppCurrent);
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
   
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_RESULT_CODE].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LEVEL(Level), IFLAG_SWAPPED);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // matched DN -----------------------------
    Tag = GetTag(*ppCurrent);
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    if(DataLength > 0)
    {
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_MATCHED_DN].hProperty,
                                DataLength,
                                ((DataLength > 0)?*ppCurrent:*ppCurrent-1),
                                0, LEVEL(Level), 0);
    }

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // error message --------------------------
    Tag = GetTag(*ppCurrent);
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    if(DataLength > 0)
    {
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_ERROR_MESSAGE].hProperty,
                                DataLength,
                                ((DataLength > 0)?*ppCurrent:*ppCurrent-1),
                                0, LEVEL(Level), 0);
    }
        *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // now look for optional referral strings
    if((long) *pBytesLeft > 0)
    {
        // try to get a header and see what it is
        // if it's not ours, we have to put everything back
        Tag = GetTag(*ppCurrent);
        *ppCurrent += TAG_LENGTH;
        SeqLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        
        if((Tag & TAG_MASK) == LDAPP_RESULT_REFERRAL)
        {
           
            while( SeqLength > 0 )
            {
                
                Tag = GetTag(*ppCurrent);
                *ppCurrent += TAG_LENGTH;
                DataLength = GetLength(*ppCurrent, &HeaderLength);
                *ppCurrent += HeaderLength;
                *pBytesLeft -= (HeaderLength + TAG_LENGTH);

                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LDAPP_REFERRAL_SERVER].hProperty,
                                        DataLength,
                                        *ppCurrent,
                                        0, LEVEL(Level), 0);
                *ppCurrent += DataLength;
                *pBytesLeft -= DataLength;

                SeqLength -= (HeaderLength + DataLength + TAG_LENGTH);
            } 
        } 
        else
        {
            // put everything back the way it was
            *pBytesLeft += (HeaderLength + TAG_LENGTH);
            *ppCurrent -= (HeaderLength + TAG_LENGTH);
        }
    }
                      
}

//==========================================================================================================================
//  FUNCTION: AttachLDAPBindRequest()
//==========================================================================================================================
void AttachLDAPBindRequest( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)
{
   
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    DWORD  SeqLength;
    BYTE   Tag;

    // version
    Tag = GetTag(*ppCurrent);
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_VERSION].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, IFLAG_SWAPPED);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;


    // name
    Tag = GetTag(*ppCurrent);
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    // if length is 0, then no name
    if(DataLength > 0)
    {
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_NAME].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, 2, 0);
    }

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;


    // authentication type
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    // if length is 0, done
    if(DataLength == 0)
    {
        return;
    }
    
    AttachPropertyInstanceEx( hFrame,
                              LDAPPropertyTable[LDAPP_AUTHENTICATION_TYPE].hProperty,
                              sizeof(BYTE),
                              *ppCurrent,
                              sizeof(BYTE),
                              &Tag,
                              0, 2, 0); 
    
  
    switch( Tag ) 
    {
    default:
    case LDAPP_AUTHENTICATION_TYPE_SIMPLE:
            
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_AUTHENTICATION].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, 3, 0);
        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
     break;

    case LDAPP_AUTHENTICATION_TYPE_SASL:
        // we've already got the header of the sequence
        SeqLength = DataLength;
        while( (long)SeqLength > 0)
        {
            // sasl mechanism
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            
            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_SASL_MECHANISM].hProperty,
                                    DataLength,
                                    ((DataLength > 0)?*ppCurrent:*ppCurrent-1),
                                    0, 4, 0);
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;
            SeqLength -= (HeaderLength + DataLength + TAG_LENGTH);

            // look for the optional credentials 
            if((long)SeqLength > 0) 
            {
                Tag = GetTag(*ppCurrent) & TAG_MASK;
                *ppCurrent += TAG_LENGTH;
                DataLength = GetLength(*ppCurrent, &HeaderLength);
                *ppCurrent += HeaderLength;
                *pBytesLeft -= (HeaderLength + TAG_LENGTH);
                      
                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LDAPP_SASL_CREDENTIALS].hProperty,
                                        DataLength,
                                        ((DataLength > 0)?*ppCurrent:*ppCurrent-1),
                                        0, 4, 0);
                *ppCurrent += DataLength;
                *pBytesLeft -= DataLength;
                SeqLength -= (HeaderLength + DataLength + TAG_LENGTH);
            }
        } // end while
    break; 
    }
    
}
 
//==========================================================================================================================
//  FUNCTION: AttachLDAPBindResponse()
//==========================================================================================================================
void AttachLDAPBindResponse( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)
{
   
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;

    // COMPONENTS of LDAPP_RESULT
    AttachLDAPResult( hFrame, ppCurrent, pBytesLeft, 2);
    
    if( (long) *pBytesLeft > 0 ) 
    {
        // now look for the optional serverSaslCredentials
     
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        
        if(Tag == 5)
        {
            // I have no idea what a tag of 5 is for
            // so we'll just get another one
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;
            
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        }    
        
        if(Tag == LDAPP_RESULT_SASL_CRED && DataLength)
        {


            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_SASL_CREDENTIALS].hProperty,
                                    DataLength,
                                    ((DataLength > 0)?*ppCurrent:*ppCurrent-1),
                                    0, 2, 0);
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;
                 
        }
    }
}

//==========================================================================================================================
//  FUNCTION: AttachLDAPSearchRequest()
//==========================================================================================================================
void AttachLDAPSearchRequest( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)
{
   
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    DWORD  SeqLength;
    DWORD  BytesLeftTemp;
    BYTE   Tag;


    // base object
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_BASE_OBJECT].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, 0);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // scope
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_SCOPE].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, IFLAG_SWAPPED);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // deref aliases
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_DEREF_ALIASES].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, IFLAG_SWAPPED);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // size limit
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_SIZE_LIMIT].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, IFLAG_SWAPPED);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // time limit
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_TIME_LIMIT].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, IFLAG_SWAPPED);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // Attrs Only
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_ATTRS_ONLY].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, IFLAG_SWAPPED);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // filter
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_FILTER].hProperty,
                            0,
                            *ppCurrent,
                            0, 2, IFLAG_SWAPPED);
    
    AttachLDAPFilter( hFrame, ppCurrent, pBytesLeft, 3);
    
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    SeqLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    // if the attribute description list exists then label it.
    if (SeqLength > 0) {

        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_ATTR_DESCR_LIST].hProperty,
                                SeqLength,
                                *ppCurrent,
                                0, 2, IFLAG_SWAPPED);

        // walk thru the attributes
        while ( (long)SeqLength > 0)
        {

            // attribute type
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);

            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_ATTRIBUTE_TYPE].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    0, 3, 0);   
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;

            SeqLength -= (HeaderLength + DataLength + TAG_LENGTH);
        }
    }
}

//==========================================================================================================================
//  FUNCTION: AttachLDAPSearchResponse()
//==========================================================================================================================
void AttachLDAPSearchResponse( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft, DWORD Level)
{
    
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;
    DWORD  OverallSequenceLength;
    DWORD  SetLength;

    // object name
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_OBJECT_NAME].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LEVEL(Level), 0);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // grab the overall sequence header
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    OverallSequenceLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
   
    // step thru all of the sequences
    while( OverallSequenceLength > 0 )
    {
        // grab the next inner sequence
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        // account for this inner sequence in the overall one
        OverallSequenceLength -= (HeaderLength + DataLength + TAG_LENGTH);

        // attribute type
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_ATTRIBUTE_TYPE].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LEVEL(Level), 0);
        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;

        // grab the set header
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        *ppCurrent += TAG_LENGTH;
        SetLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

       while( SetLength > 0 )
        {
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            
            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_ATTRIBUTE_VALUE].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    0, LEVEL(Level+1), 0);
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;
        
            // account for this attribute out of this set
            SetLength -= (HeaderLength + DataLength + TAG_LENGTH);
        }
    }
}

//==========================================================================================================================
//  FUNCTION: AttachLDAPModifyRequest()
//==========================================================================================================================
void AttachLDAPModifyRequest( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)
{
    
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;
    DWORD  SetLength;
    DWORD  OverallSequenceLength;
    
    // object name
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_OBJECT_NAME].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, 0);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;
    
    // grab the overall sequence header
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    OverallSequenceLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    while( OverallSequenceLength > 0 )
    {
        
         // grab the next inner sequence
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        // account for this inner sequence in the overall one
        OverallSequenceLength -= (HeaderLength + DataLength + TAG_LENGTH);

        // operation
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_OPERATION].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, 2, IFLAG_SWAPPED);
        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;


        // skip modification sequence
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        // attribute type
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_ATTRIBUTE_TYPE].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, 3, 0);
        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;

        // grab the set header
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        *ppCurrent += TAG_LENGTH;
        SetLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        // loop thru attribute values
        while( SetLength > 0 )
        {
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            
            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_ATTRIBUTE_VALUE].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    0, 4, 0);
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;

            SetLength -= (HeaderLength + DataLength + TAG_LENGTH);
        }
    }
}

//==========================================================================================================================
//  FUNCTION: AttachLDAPDelRequest()
//==========================================================================================================================
void AttachLDAPDelRequest( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)
{
  
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;

    // object name
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_OBJECT_NAME].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, 0);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

}

//==========================================================================================================================
//  FUNCTION: AttachLDAPModifyRDNRequest()
//==========================================================================================================================
void AttachLDAPModifyRDNRequest( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)
{
    
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;

    // object name
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_OBJECT_NAME].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, 0);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // new RDN
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_NEW_RDN].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, 0);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    if((long) *pBytesLeft > 0) 
    {
        // get the stuff for v3
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_DELETE_OLD_RDN].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, 2, 0);
        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;

        if((long) *pBytesLeft > 0)
        {
            // now try for the optional string
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            
            AttachPropertyInstance( hFrame,
                           LDAPPropertyTable[LDAPP_NEW_SUPERIOR].hProperty,
                           DataLength,
                           *ppCurrent,
                           0, 2, 0);
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;
        }
    }
}

//==========================================================================================================================
//  FUNCTION: AttachLDAPCompareRequest()
//==========================================================================================================================
void AttachLDAPCompareRequest( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)
{
  
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;

    // object name
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_OBJECT_NAME].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, 0);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // skip the sequence header
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    // attribute type
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_ATTRIBUTE_TYPE].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, 0);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // attribute value
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_ATTRIBUTE_VALUE].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 3, 0);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;
}


//==========================================================================================================================
//  FUNCTION: AttachLDAPAbandonRequest()
//==========================================================================================================================
void AttachLDAPAbandonRequest( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)
{
  
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;

    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    if(Tag == BER_TAG_INTEGER)
    {
       
         // MessageID
        
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_MESSAGE_ID].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, 2, IFLAG_SWAPPED);
        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
    }
    else
    {
        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
    }

}


//==========================================================================================================================
//  FUNCTION: AttachLDAPFilter()
//==========================================================================================================================
void AttachLDAPFilter( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft, DWORD Level)
{
    DWORD  BytesLeftTemp;
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    DWORD  SeqLength;
    BYTE   Tag;
    BYTE   BoolVal;
    LDAPOID OID;
    BOOLEAN fRuleRecognized;
    DWORD  dwRule;
    DWORD  LabelId;

    // grab our choice
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    
    AttachPropertyInstanceEx( hFrame,
                              LDAPPropertyTable[LDAPP_FILTER_TYPE].hProperty,
                              sizeof(BYTE),
                              *ppCurrent,
                              sizeof(BYTE),
                              &Tag,
                              0, LEVEL(Level), 0);
   

    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    // what type of filter is this
    
    switch( Tag )
    {
        case LDAPP_FILTER_TYPE_AND:
        case LDAPP_FILTER_TYPE_OR:
            // walk thru component filters
            while( (long)DataLength > 0 )
            {
                BytesLeftTemp = *pBytesLeft;
                AttachLDAPFilter( hFrame, ppCurrent, pBytesLeft, Level+1);
                DataLength -= (BytesLeftTemp - *pBytesLeft);
            }
            break;   

        case LDAPP_FILTER_TYPE_NOT:
            // a single filter
            AttachLDAPFilter( hFrame, ppCurrent, pBytesLeft, Level+1);
            break;
    
        case LDAPP_FILTER_TYPE_EQUALITY_MATCH:
        case LDAPP_FILTER_TYPE_GREATER_OR_EQUAL:
        case LDAPP_FILTER_TYPE_LESS_OR_EQUAL:
        case LDAPP_FILTER_TYPE_APPROX_MATCH:
            // attribute type
            
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            
            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_ATTRIBUTE_TYPE].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    0, LEVEL(Level+1), 0);
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;

            // attribute value
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            
            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_ATTRIBUTE_VALUE].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    0, LEVEL(Level+2), 0);
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;
            break;

        case LDAPP_FILTER_TYPE_PRESENT:
            // attribute type
            // we already have the header and DataLength
            // and are at the correct position to attach
            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_ATTRIBUTE_TYPE].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    0, LEVEL(Level+1), 0);
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;
            break;

        case LDAPP_FILTER_TYPE_EXTENSIBLE_MATCH:
            // Extensible match
            SeqLength = DataLength;

            // get the sequence header
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            SeqLength -= (HeaderLength + TAG_LENGTH);

            if (LDAPP_FILTER_EX_MATCHING_RULE == Tag) {
                fRuleRecognized = FALSE;
                OID.value = *ppCurrent;
                OID.length = DataLength;
                for (dwRule = 0; dwRule < nNumKnownMatchingRules; dwRule++) {
                    if (AreOidsEqual(&OID, &(KnownMatchingRules[dwRule].Oid))) {
                        fRuleRecognized = TRUE;
                        break;
                    }
                }

                if (fRuleRecognized) {
                    LabelId = KnownMatchingRules[dwRule].LabelId;
                } else {
                    LabelId = LDAPP_MATCHING_RULE;
                }

                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LabelId].hProperty,
                                        DataLength,
                                        *ppCurrent,
                                        0, LEVEL(Level+1), 0);

                *ppCurrent += DataLength;
                *pBytesLeft -= DataLength;
                SeqLength -= DataLength;
                if (SeqLength > 0) {
                    Tag = GetTag(*ppCurrent) & TAG_MASK;
                    *ppCurrent += TAG_LENGTH;
                    DataLength = GetLength(*ppCurrent, &HeaderLength);
                    *ppCurrent += HeaderLength;
                    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
                    SeqLength -= (HeaderLength + TAG_LENGTH);
                } else {
                    Tag = 0;
                }

            }

            if (LDAPP_FILTER_EX_TYPE == Tag) {
                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LDAPP_ATTRIBUTE_TYPE].hProperty,
                                        DataLength,
                                        *ppCurrent,
                                        0, LEVEL(Level+1), 0);

                *ppCurrent += DataLength;
                *pBytesLeft -= DataLength;
                SeqLength -= DataLength;
                if (SeqLength > 0) {
                    Tag = GetTag(*ppCurrent) & TAG_MASK;
                    *ppCurrent += TAG_LENGTH;
                    DataLength = GetLength(*ppCurrent, &HeaderLength);
                    *ppCurrent += HeaderLength;
                    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
                    SeqLength -= (HeaderLength + TAG_LENGTH);
                } else {
                    Tag = 0;
                }

            }

            if (LDAPP_FILTER_EX_VALUE == Tag) {
                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LDAPP_ATTRIBUTE_VALUE].hProperty,
                                        DataLength,
                                        *ppCurrent,
                                        0, LEVEL(Level+1), 0);

                *ppCurrent += DataLength;
                *pBytesLeft -= DataLength;
                SeqLength -= DataLength;
                if (SeqLength > 0) {
                    Tag = GetTag(*ppCurrent) & TAG_MASK;
                    *ppCurrent += TAG_LENGTH;
                    DataLength = GetLength(*ppCurrent, &HeaderLength);
                    *ppCurrent += HeaderLength;
                    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
                    SeqLength -= (HeaderLength + TAG_LENGTH);
                } else {
                    Tag = 0;
                }

            }

            if (LDAPP_FILTER_EX_ATTRIBUTES == Tag) {
                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LDAPP_DN_ATTRIBUTES].hProperty,
                                        DataLength,
                                        *ppCurrent,
                                        0, LEVEL(Level+1), 0);

                *ppCurrent += DataLength;
                *pBytesLeft -= DataLength;
            } else {
                BoolVal = 0;
                
                AttachPropertyInstanceEx( hFrame,
                                          LDAPPropertyTable[LDAPP_DN_ATTRIBUTES].hProperty,
                                          DataLength,
                                          *ppCurrent,
                                          sizeof(BYTE),
                                          &BoolVal,
                                          0, LEVEL(Level+1), 0);
                
            }            
            
            break;

        case LDAPP_FILTER_TYPE_SUBSTRINGS:
            // substring filter
            
            // attribute type
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            
            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_ATTRIBUTE_TYPE].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    0, LEVEL(Level+1), 0);
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;

            // grab the sequence header
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            SeqLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);

            // loop thru the choices
            while( SeqLength > 0 )
            {
                // grab this choice
                Tag = GetTag(*ppCurrent) & TAG_MASK;
                *ppCurrent += TAG_LENGTH;
                DataLength = GetLength(*ppCurrent, &HeaderLength);
                *ppCurrent += HeaderLength;
                *pBytesLeft -= (HeaderLength + TAG_LENGTH);
                
                SeqLength -= (HeaderLength + DataLength + TAG_LENGTH);

                switch( Tag )
                {
                    case LDAPP_SUBSTRING_CHOICE_INITIAL:
                        
                        AttachPropertyInstance( hFrame,
                                                LDAPPropertyTable[LDAPP_SUBSTRING_INITIAL].hProperty,
                                                DataLength,
                                                *ppCurrent,
                                                0, LEVEL(Level+1), 0);
                        *ppCurrent += DataLength;
                        *pBytesLeft -= DataLength;
                        break;

                    case LDAPP_SUBSTRING_CHOICE_ANY:
                        
                        AttachPropertyInstance( hFrame,
                                                LDAPPropertyTable[LDAPP_SUBSTRING_ANY].hProperty,
                                                DataLength,
                                                *ppCurrent,
                                                0, LEVEL(Level+1), 0);
                        *ppCurrent += DataLength;
                        *pBytesLeft -= DataLength;
                        break;

                    case LDAPP_SUBSTRING_CHOICE_FINAL:
                        
                        AttachPropertyInstance( hFrame,
                                                LDAPPropertyTable[LDAPP_SUBSTRING_FINAL].hProperty,
                                                DataLength,
                                                *ppCurrent,
                                                0, LEVEL(Level+1), 0);
                        *ppCurrent += DataLength;
                        *pBytesLeft -= DataLength;
                        break;
                }
            } // while
            break;
         }
    
}

//==========================================================================================================================
//  FUNCTION: AttachLDAPSearchResponseReference()
//==========================================================================================================================
void AttachLDAPSearchResponseReference( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft, DWORD Level)
{
    
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;
  
    // get the reference string
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_REFERRAL_SERVER].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LEVEL(Level+1), 0);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

   
}

//==========================================================================================================================
//  FUNCTION: AttachLDAPSearchResponseFull()
//==========================================================================================================================
void AttachLDAPSearchResponseFull( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)
{
  
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;
    DWORD  OverallSequenceLength;

    
    // grab the overall sequence header
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    OverallSequenceLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    // step thru all of the entries
    while( OverallSequenceLength > 0 )
    {
        // grab the indicator for the entry
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        
       
        AttachPropertyInstanceEx( hFrame,
                                  LDAPPropertyTable[LDAPP_PROTOCOL_OP].hProperty,
                                  sizeof( BYTE ),
                                  *ppCurrent,
                                  sizeof(BYTE),
                                  &Tag,
                                  0, 2, 0);
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        // account for this entry in the overall sequence
        OverallSequenceLength -= (HeaderLength + DataLength + TAG_LENGTH);

        // call the proper worker for the body of this entry
        switch( Tag )
        {
            case LDAPP_PROTOCOL_OP_SEARCH_RES_DONE:
                AttachLDAPResult( hFrame, ppCurrent, pBytesLeft, 3);
                break;

            case LDAPP_PROTOCOL_OP_SEARCH_RES_ENTRY:
                AttachLDAPSearchResponse( hFrame, ppCurrent, pBytesLeft, 3);
                break;

            case LDAPP_PROTOCOL_OP_SEARCH_RES_REFERENCE:
                AttachLDAPSearchResponseReference( hFrame, ppCurrent, pBytesLeft, 3);
                break;
        }
    }
}

#define LDAPP_EXT_VAL_LEVEL  3

//==========================================================================================================================
//  FUNCTION: AttachLDAPExtendedRequest()
//==========================================================================================================================
void AttachLDAPExtendedRequest( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft, DWORD ReqSize)
{
    
    DWORD   HeaderLength = 0;
    DWORD   DataLength;
    BYTE    Tag;
    LDAPOID OID;
    BOOL    fReqFound = FALSE;
    DWORD   LabelId;
    DWORD   ReqType;

    // get the name of the request and attach it
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    OID.value = *ppCurrent;
    OID.length = DataLength;
    for (ReqType = 0; ReqType < nNumKnownExtendedRequests; ReqType++) {
        if (AreOidsEqual(&OID, &(KnownExtendedRequests[ReqType].Oid))) {
            fReqFound = TRUE;
            break;
        }
    }

    if (fReqFound) {
        LabelId = KnownExtendedRequests[ReqType].LabelId;

        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LabelId].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, 2, 0);
    } else {
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_REQUEST_NAME].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, 2, 0);
    }
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // optionals, if there is data left, get it
    if((long) *pBytesLeft > 0)
    {
        // Request value
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        
        
        if(Tag == LDAPP_EX_REQ_VALUE)
        {
            // get the string and attach it
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);

            if (fReqFound &&
                KnownExtendedRequests[ReqType].pAttachFunction) {
                // We know how to break this one open some more.
                KnownExtendedRequests[ReqType].pAttachFunction(hFrame,
                                                               ppCurrent,
                                                               pBytesLeft,
                                                               DataLength);
            } else {
                // Don't know this one so just mark the value.
                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LDAPP_REQUEST_VALUE].hProperty,
                                        DataLength,
                                        *ppCurrent,
                                        0, 2, 0);
                *ppCurrent += DataLength;
                *pBytesLeft -= DataLength;
            }
        }
    }
    
}
 
void AttachLDAPExtendedReqValTTL( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbReqValue)
{
    DWORD   HeaderLength = 0;
    DWORD   DataLength;
    BYTE    Tag;

    if (*pBytesLeft >= cbReqValue) {
        // Skip the sequence tag.
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        // Get the entryName
        Tag = GetTag(*ppCurrent) & TAG_MASK;

        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_EXT_REQ_TTL_ENTRYNAME].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_EXT_VAL_LEVEL, 0);

        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;

        // Get the time.
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_EXT_REQ_TTL_TIME].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_EXT_VAL_LEVEL, IFLAG_SWAPPED);

        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
    }
}

//==========================================================================================================================
//  FUNCTION: AttachLDAPExtendedResponse()
//==========================================================================================================================
void AttachLDAPExtendedResponse( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft, DWORD RespSize)
{
  
    DWORD   HeaderLength = 0;
    DWORD   DataLength;
    BYTE    Tag;
    LDAPOID OID;
    BOOL    fRespFound = FALSE;
    DWORD   LabelId;
    DWORD   RespType;

    // COMPONENTS of LDAPP_RESULT as defined in the draft
    AttachLDAPResult( hFrame, ppCurrent, pBytesLeft, 2);
    
    // now get the extras if there is something left
    if((long) *pBytesLeft > 0)
    {
        // we want to get the Response Name, it is optional
        // but it is defined to come first. We decide if it is there by
        // its custom tag.
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        
        if(Tag == LDAPP_RESULT_EX_RES_NAME)
        {
            
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            
            OID.value = *ppCurrent;
            OID.length = DataLength;
            for (RespType = 0; RespType < nNumKnownExtendedResponses; RespType++) {
                if (AreOidsEqual(&OID, &(KnownExtendedResponses[RespType].Oid))) {
                    fRespFound = TRUE;
                    break;
                }
            }

            if (fRespFound) {
                LabelId = KnownExtendedResponses[RespType].LabelId;

                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LabelId].hProperty,
                                        DataLength,
                                        *ppCurrent,
                                        0, 2, 0);
            } else {
                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LDAPP_RESPONSE_NAME].hProperty,
                                        DataLength,
                                        *ppCurrent,
                                        0, 2, 0);
            }
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;
        }
    }

    if((long) *pBytesLeft > 0)
    {    

        // response value or else nothing (optional)
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        
        if(Tag == LDAPP_RESULT_EX_RES_VALUE)
        {
            // get the actual string
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            
            if (fRespFound &&
                KnownExtendedResponses[RespType].pAttachFunction) {
                // We known this one so break it open.
                KnownExtendedResponses[RespType].pAttachFunction(hFrame,
                                                                 ppCurrent,
                                                                 pBytesLeft,
                                                                 DataLength);
            } else {
                // Didn't find this one just mark at the response value.
                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LDAPP_RESPONSE_VALUE].hProperty,
                                        DataLength,
                                        *ppCurrent,
                                        0, 2, 0);
                *ppCurrent += DataLength;
                *pBytesLeft -= DataLength;
            }
        }
    }
} 

void AttachLDAPExtendedRespValTTL( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbRespValue)
{
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;

    if (*pBytesLeft >= cbRespValue) {
        // First skip the sequence header
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        
        Tag = GetTag(*ppCurrent) & TAG_MASK; 
            
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_EXT_RESP_TTL_TIME].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_EXT_VAL_LEVEL, IFLAG_SWAPPED);

        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;

    }
}

void AttachLDAPOptionalControls( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)      
{
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    DWORD  RemainingCtrlsLength;
    DWORD  TmpBytesLeft;
    BYTE   Tag;

    if ((long)*pBytesLeft > 0)
    {
        
        // try to get the tag from the sequence header, it is optional but something
        // is here if there are bytes left in the frame
        Tag = GetTag(*ppCurrent) & TAG_MASK; 
            
        // controls is a sequence of individual controls
        if(Tag == LDAPP_CONTROLS_TAG)
        {
            *ppCurrent += TAG_LENGTH;
            RemainingCtrlsLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);

            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_CONTROLS].hProperty,
                                    RemainingCtrlsLength,
                                    *ppCurrent,
                                    0, 2, 0);

            while (RemainingCtrlsLength != 0 && *pBytesLeft > 0) {            
                // get the next control
                TmpBytesLeft = *pBytesLeft;
                AttachLDAPControl( hFrame, ppCurrent, pBytesLeft );
                RemainingCtrlsLength -= TmpBytesLeft - *pBytesLeft;
            }
        }  // if Tag == LDAPP_CONTROLS_TAG ...
    } // if *pBytesLeft > 0 ...
}

void AttachLDAPControl( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)
{
    DWORD   HeaderLength = 0;
    DWORD   DataLength;
    DWORD   ControlType;
    DWORD   LabelId = LDAPP_CONTROL_TYPE;
    BOOL    ControlRecognized = FALSE;
    LDAPOID OID;
    BYTE    Tag;
    BYTE    Temp_Data = 0;
    BYTE    SpecialFlag = LDAPP_CTRL_NONE;

    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        // control type
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    OID.value = *ppCurrent;
    OID.length = DataLength;
    for (ControlType = 0; ControlType < nNumKnownControls; ControlType++) {
        if (AreOidsEqual(&OID, &(KnownControls[ControlType].Oid))) {
            ControlRecognized = TRUE;
            break;
        }
    }

    if (ControlRecognized) {
        LabelId = KnownControls[ControlType].LabelId;
    }
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LabelId].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 3, 0);


    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // look for an optional boolean
    if((long) *pBytesLeft > 0) 
    {
        Tag = GetTag(*ppCurrent) & TAG_MASK;

        if(Tag == BER_TAG_BOOLEAN) // boolean
        {

                *ppCurrent += TAG_LENGTH;
                DataLength = GetLength(*ppCurrent, &HeaderLength);
                *ppCurrent += HeaderLength;
                *pBytesLeft -= (HeaderLength + TAG_LENGTH);  

                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LDAPP_CRITICALITY].hProperty,
                                        DataLength,
                                        *ppCurrent,
                                        0, 4, 0);
                *ppCurrent += DataLength;
                *pBytesLeft -= DataLength;

                Tag = GetTag(*ppCurrent) & TAG_MASK;
        }
        else
        {

                // fill in the default boolean value
                AttachPropertyInstanceEx( hFrame,
                          LDAPPropertyTable[LDAPP_CRITICALITY].hProperty,
                          sizeof( BYTE ),
                          NULL,
                          sizeof(BYTE),
                          &Temp_Data,
                          0, 4, 0);
        }

        // if we are a string and there is data left, then process it
        if(Tag == BER_TAG_OCTETSTRING && (long)*pBytesLeft > 0) 
        {
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH); 

            if (DataLength > 0) {

                // can we crack the control value open?                
                if (ControlRecognized &&
                    NULL != KnownControls[ControlType].pAttachFunction) {

    