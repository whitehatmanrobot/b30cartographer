            RealizePalette(hdc);
            }
            
            SetMapMode(hdc, MM_TEXT);
            
            Rectangle(hdc, 0, 0, prgSize->cx, prgSize->cy);
            
            int iDstHt = rect.bottom - rect.top;
            int iDstTop = rect.top, iSrcTop = 0;
            if (pbih->biHeight < 0)
            {
                iDstHt *= -1;
                iDstTop = rect.bottom;
                iSrcTop = abs(pbih->biHeight);
            }
            
            iRetVal = StretchDIBits(hdc, rect.left, iDstTop, rect.right - rect.left, iDstHt, 
                0, iSrcTop, pbih->biWidth, pbih->biHeight, 
                pScaledBits, pbiScaled, DIB_RGB_COLORS,  SRCCOPY);
            
            SelectObject(hdc, hOldBrush);
            DeleteObject(hBrush);
            SelectObject(hdc, hOldPen);
            if (hpal)
            {
                SelectPalette(hdc, hpalOld, TRUE);
                RealizePalette(hdc);
            }
            
            SelectObject(hdc, hBmpOld);
        }
        
        DeleteDC(hdc);
    }
    
    if (hbmpDithered)
    {
        DeleteObject(hbmpDithered);
    }
    if (pDitheredInfo)
    {
        LocalFree(pDitheredInfo);
    }
    
    return (iRetVal != GDI_ERROR);
}


STDAPI_(BOOL) CreateSizedDIBSECTION(const SIZE *prgSize, DWORD dwClrDepth, HPALETTE hpal, 
                                    const BITMAPINFO *pCurInfo, HBITMAP *phBmp, BITMAPINFO **ppBMI, void **ppBits)
{
    *phBmp = NULL;
    
    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        HDC hdcBmp = CreateCompatibleDC(hdc);
        if (hdcBmp)
        {
            struct {
                BITMAPINFOHEADER bi;
                DWORD            ct[256];
            } dib;

            dib.bi.biSize            = sizeof(dib.bi);
            dib.bi.biWidth           = prgSize->cx;
            dib.bi.biHeight          = prgSize->cy;
            dib.bi.biPlanes          = 1;
            dib.bi.biBitCount        = (WORD) dwClrDepth;
            dib.bi.biCompression     = BI_RGB;
            dib.bi.biSizeImage       = CalcImageSize(prgSize, dwClrDepth);
            dib.bi.biXPelsPerMeter   = 0;
            dib.bi.biYPelsPerMeter   = 0;
            dib.bi.biClrUsed         = (dwClrDepth <= 8) ? (1 << dwClrDepth) : 0;
            dib.bi.biClrImportant    = 0;

            HPALETTE hpalOld = NULL;
        
            if (dwClrDepth <= 8)
            {
                // if they passed us the old structure with colour info, and we are the same bit depth, then copy it...
                if (pCurInfo && pCurInfo->bmiHeader.biBitCount == dwClrDepth)
                {
                    // use the passed in colour info to generate the DIBSECTION
                    int iColours = pCurInfo->bmiHeader.biClrUsed;

                    if (!iColours)
                    {
                        iColours = dib.bi.biClrUsed;
                    }

                    // copy the data accross...
                    CopyMemory(dib.ct, pCurInfo->bmiColors, sizeof(RGBQUAD) * iColours);
                }
                else
                {
                    // need to get the right palette....
                    hpalOld = SelectPalette(hdcBmp, hpal, TRUE);
                    RealizePalette(hdcBmp);
            
                    int n = GetPaletteEntries(hpal, 0, 256, (LPPALETTEENTRY)&dib.ct[0]);

                    ASSERT(n >= (int) dib.bi.biClrUsed);

                    // now convert the PALETTEENTRY to RGBQUAD
                    for (int i = 0; i < (int)dib.bi.biClrUsed; i ++)
                    {
                        dib.ct[i] = RGB(GetBValue(dib.ct[i]),GetGValue(dib.ct[i]),GetRValue(dib.ct[i]));
                    }
                }
            }
 
            void *pbits;
            *phBmp = CreateDIBSection(hdcBmp, (LPBITMAPINFO)&dib, DIB_RGB_COLORS, &pbits, NULL, 0);
            if (*phBmp)
            {
                if (ppBMI)
                {
                    *ppBMI = (BITMAPINFO *)LocalAlloc(LPTR, sizeof(dib));
                    if (*ppBMI)
                    {
                        CopyMemory(*ppBMI, &dib, sizeof(dib));
                    }
                }
                if (ppBits)
                {
                    *ppBits = pbits;
                }
            }
            DeleteDC(hdcBmp);
        }
        ReleaseDC(NULL, hdc);
    }
    return (*phBmp != NULL);
}

STDAPI_(void *) CalcBitsOffsetInDIB(BITMAPINFO *pBMI)
{
    int ncolors = pBMI->bmiHeader.biClrUsed;
    if (ncolors == 0 && pBMI->bmiHeader.biBitCount <= 8)
        ncolors = 1 << pBMI->bmiHeader.biBitCount;
        
    if (pBMI->bmiHeader.biBitCount == 16 ||
        pBMI->bmiHeader.biBitCount == 32)
    {
        if (pBMI->bmiHeader.biCompression == BI_BITFIELDS)
        {
            ncolors = 3;
        }
    }
    return (void *)((UCHAR *)&pBMI->bmiColors[0] + ncolors * sizeof(RGBQUAD));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shscrap\debug.c ===
//
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include <windows.h>
#include <ccstock.h>

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "shscrap"
#define SZ_MODULE           "SHSCRAP"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shscrap\sccls.cpp ===
#include "shole.h"
#include "ids.h"
#include "scguid.h"
#define DECL_CRTFREE
#include <crtfree.h>

LONG g_cRefThisDll = 0;         // per-instance

STDAPI_(void) DllAddRef(void)
{
    InterlockedIncrement(&g_cRefThisDll);
}

STDAPI_(void) DllRelease(void)
{
    InterlockedDecrement(&g_cRefThisDll);
}

class CMyClassFactory : public IClassFactory
{
public:
    CMyClassFactory(REFCLSID rclsid);
    ~CMyClassFactory() { DllRelease(); }

    // IUnKnown
    virtual HRESULT __stdcall QueryInterface(REFIID,void **);
    virtual ULONG __stdcall AddRef(void);
    virtual ULONG __stdcall Release(void);

    // IClassFactory
    virtual HRESULT __stdcall CreateInstance(
            IUnknown *pUnkOuter, REFIID riid, void **ppvObject);
    virtual HRESULT __stdcall LockServer(BOOL fLock);

protected:
    UINT   _cRef;
    CLSID  _clsid;
};

CMyClassFactory::CMyClassFactory(REFCLSID rclsid) : _cRef(1), _clsid(rclsid)
{
    DllAddRef();
}

HRESULT CMyClassFactory::QueryInterface(REFIID riid, void **ppvObject)
{
    HRESULT hres;
    if (IsEqualGUID(riid, IID_IClassFactory) || IsEqualGUID(riid, IID_IUnknown)) {
        _cRef++;
        *ppvObject = (LPCLASSFACTORY)this;
        hres = NOERROR;
    }
    else
    {
        *ppvObject = NULL;
        hres = ResultFromScode(E_NOINTERFACE);
    }

    return hres;
}

ULONG CMyClassFactory::AddRef(void)
{
    return ++_cRef;
}

ULONG CMyClassFactory::Release(void)
{
    if (--_cRef>0) {
        return _cRef;
    }

    delete this;
    return 0;
}

HRESULT CMyClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject)
{
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    LPUNKNOWN punk;
    HRESULT hres;
    if (IsEqualGUID(_clsid, CLSID_CScrapData))
    {
        hres = CScrapData_CreateInstance(&punk);
    }
#ifdef FEATURE_SHELLEXTENSION
    else if (IsEqualGUID(_clsid, CLSID_CTemplateFolder))
    {
	hres = CTemplateFolder_CreateInstance(&punk);
    }
    else if (IsEqualGUID(_clsid, CLSID_CScrapExt))
    {
	hres = CScrapExt_CreateInstance(&punk);
    }
#endif
    else
    {
        return E_UNEXPECTED;
    }

    if (SUCCEEDED(hres))
    {
        hres = punk->QueryInterface(riid, ppvObject);
        punk->Release();
    }
    return hres;
}

HRESULT CMyClassFactory::LockServer(BOOL fLock)
{
    return S_OK;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppvOut)
{
    if (IsEqualGUID(rclsid,CLSID_CScrapData)
#ifdef FEATURE_SHELLEXTENSION
	|| IsEqualGUID(rclsid,CLSID_CTemplateFolder)
	|| IsEqualGUID(rclsid,CLSID_CScrapExt)
#endif
	)
    {
        CMyClassFactory *pmycls = new CMyClassFactory(rclsid);
        if (pmycls)
        {
            HRESULT hres = pmycls->QueryInterface(riid, ppvOut);
            pmycls->Release();
            return hres;
        }
        return E_OUTOFMEMORY;
    }
    return CLASS_E_CLASSNOTAVAILABLE;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_cRefThisDll)
    {
        return S_FALSE;
    }

    DebugMsg(DM_TRACE, TEXT("sc TR - DllCanUnloadNow returning S_OK (bye, bye...)"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\zoomwnd.cpp ===
#include "precomp.h"
#include <uxtheme.h>
#include <shstyle.h>

#include "prevwnd.h"
#include "guids.h"
#include "resource.h"

#define COLOR_PREVIEWBKGND COLOR_WINDOW

#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))
#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))

/////////////////////////////////////////////////////////////////////////////
// CZoomWnd

CZoomWnd::CZoomWnd(CPreviewWnd *pPreview)
{
    m_modeDefault = MODE_NOACTION;
    m_fPanning = FALSE;
    m_fCtrlDown = FALSE;
    m_fShiftDown = FALSE;
    
    m_fBestFit = TRUE;

    m_cxImage = 1;
    m_cyImage = 1;
    m_cxCenter = 1;
    m_cyCenter = 1;
    m_pImageData = NULL;

    m_cyHScroll = GetSystemMetrics(SM_CYHSCROLL);
    m_cxVScroll = GetSystemMetrics(SM_CXVSCROLL);

    m_iStrID = IDS_NOPREVIEW;

    m_hpal = NULL;
    m_pPreview = pPreview;

    m_pFront = NULL;
    m_pBack = NULL;

    m_pTaskScheduler = NULL;

    m_fTimerReady = FALSE;

    m_fFoundBackgroundColor = FALSE;
    m_iIndex = -1;
}

CZoomWnd::~CZoomWnd()
{
    if (m_pImageData)
        m_pImageData->Release();

    if (m_pTaskScheduler)
    {
        // wait for any pending draw tasks since we're about to delete the buffers
        DWORD dwMode;
        m_pPreview->GetMode(&dwMode);

        TASKOWNERID toid;
        GetTaskIDFromMode(GTIDFM_DRAW, dwMode, &toid);

        m_pTaskScheduler->RemoveTasks(toid, ITSAT_DEFAULT_LPARAM, TRUE);
        m_pTaskScheduler->Release();
    }

    if (m_pBack)
    {
        DeleteBuffer(m_pBack);
        m_pBack = NULL;
    }

    // DeleteBuffer is going to check for NULL anyway
    DeleteBuffer(m_pFront);
}


LRESULT CZoomWnd::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&)
{
    // turn off The RTL layout extended style in GWL_EXSTYLE
    SHSetWindowBits(m_hWnd, GWL_EXSTYLE, WS_EX_LAYOUTRTL, 0);
    HDC hdc = GetDC();
    m_winDPIx = (float)(GetDeviceCaps(hdc,LOGPIXELSX));
    m_winDPIy = (float)(GetDeviceCaps(hdc,LOGPIXELSY));
    ReleaseDC(hdc);
    return 0;
}


DWORD CZoomWnd::GetBackgroundColor()
{
    if (!m_fFoundBackgroundColor)
    {
        // First try the theme file
        HINSTANCE hinstTheme = SHGetShellStyleHInstance();

        if (hinstTheme)
        {
            WCHAR sz[20];
            if (LoadString(hinstTheme, IDS_PREVIEW_BACKGROUND_COLOR, sz, ARRAYSIZE(sz)))
            {
                int nColor;
                if (StrToIntEx(sz, STIF_SUPPORT_HEX, &nColor))
                {
                    m_dwBackgroundColor = (DWORD)nColor;
                    m_fFoundBackgroundColor = TRUE;
                }
            }
            FreeLibrary(hinstTheme);
        }


        if (!m_fFoundBackgroundColor)
        {
            m_dwBackgroundColor = GetSysColor(COLOR_PREVIEWBKGND);
            m_fFoundBackgroundColor = TRUE;
        }
    }

    return m_dwBackgroundColor;
}

LRESULT CZoomWnd::OnEraseBkgnd(UINT , WPARAM wParam, LPARAM , BOOL&)
{
    RECT rcFill;                            // rect to fill with background color
    HDC hdc = (HDC)wParam;

    if (!m_pPreview->OnSetColor(hdc))
        SetBkColor(hdc, GetBackgroundColor());

    // There are four possible regions that might need to be erased:
    //      +-----------------------+
    //      |       Erase Top       |
    //      +-------+-------+-------+
    //      |       |       |       |
    //      | Erase | Image | Erase |
    //      | Left  |       | Right |
    //      +-------+-------+-------+
    //      |     Erase Bottom      |
    //      +-----------------------+

    if (m_pFront && m_pFront->hdc)
    {
        RECT rcImage = m_pFront->rc;
        HPALETTE hPalOld = NULL;
        if (m_pFront->hPal)
        {
            hPalOld = SelectPalette(hdc, m_pFront->hPal, FALSE);
            RealizePalette(hdc);
        }
        BitBlt(hdc, rcImage.left, rcImage.top, RECTWIDTH(rcImage), RECTHEIGHT(rcImage),
                   m_pFront->hdc, 0,0, SRCCOPY);
        
        
        // erase the left region

        rcFill.left = 0;
        rcFill.top = rcImage.top;
        rcFill.right = rcImage.left;
        rcFill.bottom = rcImage.bottom;
        if (rcFill.right > rcFill.left)
        {
            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcFill, NULL, 0, NULL);
        }

        // erase the right region
        rcFill.left = rcImage.right;
        rcFill.right = m_cxWindow;
        if (rcFill.right > rcFill.left)
        {
            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcFill, NULL, 0, NULL);        
        }

        // erase the top region
        rcFill.left = 0;
        rcFill.top = 0;
        rcFill.right = m_cxWindow;
        rcFill.bottom = rcImage.top;
        if (rcFill.bottom > rcFill.top)
        {
            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcFill, NULL, 0, NULL);
        }

        // erase the bottom region
        rcFill.top = rcImage.bottom;
        rcFill.bottom = m_cyWindow;
        if (rcFill.bottom > rcFill.top)
        {
            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcFill, NULL, 0, NULL);
        }

        HBRUSH hbr = GetSysColorBrush(COLOR_WINDOWTEXT);
        FrameRect(hdc, &rcImage, hbr);
        if (hPalOld)
        {
            SelectPalette(hdc, hPalOld, FALSE);
        }
    }

    return TRUE;
}


void CZoomWnd::FlushDrawMessages()
{
    // first, remove any pending draw tasks
    DWORD dwMode;
    m_pPreview->GetMode(&dwMode);

    TASKOWNERID toid;
    GetTaskIDFromMode(GTIDFM_DRAW, dwMode, &toid);

    m_pTaskScheduler->RemoveTasks(toid, ITSAT_DEFAULT_LPARAM, TRUE);

    // make sure any posted messages get flushed and we free the associated data
    MSG msg;
    while (PeekMessage(&msg, m_hWnd, ZW_DRAWCOMPLETE, ZW_DRAWCOMPLETE, PM_REMOVE))
    {
        // NTRAID#NTBUG9-359356-2001/04/05-seank
        // If the queue is empty when PeekMessage is called and we have already 
        // Posted a quit message then PeekMessage will return a WM_QUIT message 
        // regardless of the filter min and max and subsequent calls to 
        // GetMessage will hang indefinitely see SEANK or JASONSCH for more 
        // info.
        if (msg.message == WM_QUIT)
        {
            PostQuitMessage(0);
            return;
        }
        
        Buffer * pBuf = (Buffer *)msg.wParam;
        DeleteBuffer(pBuf);
    }
}

HRESULT CZoomWnd::PrepareDraw()
{
    // first, remove any pending draw tasks
    FlushDrawMessages();

    // we are now waiting for the "next task", even if we don't create a task with this ID.
    HRESULT hr = S_OK;
    BOOL bInvalidate = FALSE;
    if (m_pImageData)
    {
        if (m_pImageData->_iItem == m_iIndex)
        {
            SwitchBuffers(m_iIndex);
            bInvalidate = TRUE;
        }
        else
        {
            COLORREF clr;
            if (!m_pPreview->GetColor(&clr))
                clr = GetBackgroundColor();

            m_iStrID = IDS_DRAWFAILED;
            IRunnableTask * pTask;
            hr = CDrawTask::Create(m_pImageData, clr, m_rcCut, m_rcBleed, m_hWnd, ZW_DRAWCOMPLETE, &pTask);
            if (SUCCEEDED(hr))
            {
                DWORD dwMode;
                m_pPreview->GetMode(&dwMode);

                TASKOWNERID toid;
                GetTaskIDFromMode(GTIDFM_DRAW, dwMode, &toid);

                hr = m_pTaskScheduler->AddTask(pTask, toid, ITSAT_DEFAULT_LPARAM, ITSAT_DEFAULT_PRIORITY);
                if (SUCCEEDED(hr))
                {
                    m_iStrID = IDS_DRAWING;
                }
                pTask->Release();
            }
            else
            {
                bInvalidate = TRUE;
            }
        }
    }
    else
    {
        bInvalidate = TRUE;
    }
    
    if (m_hWnd && bInvalidate)
        InvalidateRect(NULL);

    return hr;
}

HRESULT CZoomWnd::PrepareImageData(CDecodeTask *pImageData)
{
    HRESULT hr = E_FAIL;
    if (pImageData)
    {
        SIZE sz;
        ULONG dpiX, dpiY;
        int cxImgPix, cyImgPix;
        float cxImgPhys, cyImgPhys;
        PTSZ ptszDest;

        pImageData->GetSize(&sz);
        pImageData->GetResolution(&dpiX, &dpiY);
        cxImgPhys = sz.cx/(float)dpiX;
        cyImgPhys = sz.cy/(float)dpiY;
        cxImgPix = (int)(cxImgPhys*m_winDPIx);
        cyImgPix = (int)(cyImgPhys*m_winDPIy);

        GetPTSZForBestFit(cxImgPix, cyImgPix, cxImgPhys, cyImgPhys, ptszDest);

        RECT rcCut, rcBleed;
        CalcCut(ptszDest, sz.cx, sz.cy, rcCut, rcBleed);

        COLORREF clr;
        if (!m_pPreview->GetColor(&clr))
            clr = GetBackgroundColor();

        IRunnableTask * pTask;
        hr = CDrawTask::Create(pImageData, clr, rcCut, rcBleed, m_hWnd, ZW_BACKDRAWCOMPLETE, &pTask);
        if (SUCCEEDED(hr))
        {
            DWORD dwMode;
            m_pPreview->GetMode(&dwMode);

            TASKOWNERID toid;
            GetTaskIDFromMode(GTIDFM_DRAW, dwMode, &toid);

            hr = m_pTaskScheduler->AddTask(pTask, toid, ITSAT_DEFAULT_LPARAM, ITSAT_DEFAULT_PRIORITY);
            pTask->Release();
        }
    }

    return hr;
}


BOOL CZoomWnd::SwitchBuffers(UINT iIndex)
{
    BOOL fRet = FALSE;
    if (m_pBack && m_iIndex == iIndex)
    {
        // DeleteBuffer is going to check for NULL anyway
        DeleteBuffer(m_pFront);

        m_pFront = m_pBack;
        m_pBack = NULL;
        m_iIndex = -1;
        
        InvalidateRect(NULL);
        UpdateWindow();

        if (m_fTimerReady)
        {
            m_pPreview->OnDrawComplete();
            m_fTimerReady = FALSE;
        }

        fRet = TRUE;
    }

    return fRet;
}

LRESULT CZoomWnd::OnBackDrawComplete(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    Buffer * pBuf = (Buffer *)wParam;

    if (m_pBack)
    {
        DeleteBuffer(m_pBack);
        m_pBack = NULL;
    }

    if (pBuf)
    {
        m_pBack = pBuf;
    }
    m_iIndex = PtrToInt((void *)lParam);

    return 0;
}


LRESULT CZoomWnd::OnDrawComplete(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    Buffer * pBuf = (Buffer *)wParam;

    if (m_pFront)
    {
        DeleteBuffer(m_pFront);
        m_pFront = NULL;
    }

    if (pBuf)
    {
        m_pFront = pBuf;
    }
    else
    {
        m_iStrID = IDS_DRAWFAILED;
    }

    InvalidateRect(NULL);
    UpdateWindow();

    if (m_fTimerReady)
    {
        m_pPreview->OnDrawComplete();
        m_fTimerReady = FALSE;
    }

    return 0;
}

// OnPaint
//
// Handles WM_PAINT messages sent to the window

LRESULT CZoomWnd::OnPaint(UINT , WPARAM , LPARAM , BOOL&)
{
    PAINTSTRUCT ps;
    HDC hdcDraw = BeginPaint(&ps);

    // setup the destination DC:
    SetMapMode(hdcDraw, MM_TEXT);
    SetStretchBltMode(hdcDraw, COLORONCOLOR);

    if (m_hpal)
    {
        SelectPalette(hdcDraw, m_hpal, TRUE);
        RealizePalette(hdcDraw);
    }

    if (m_pFront)
    {
        if (m_Annotations.GetCount() > 0)
        {
            CPoint ptDeviceOrigin;

            ptDeviceOrigin.x = m_rcBleed.left - MulDiv(m_rcCut.left, RECTWIDTH(m_rcBleed), RECTWIDTH(m_rcCut));
            ptDeviceOrigin.y = m_rcBleed.top - MulDiv(m_rcCut.top, RECTHEIGHT(m_rcBleed), RECTHEIGHT(m_rcCut));

            SetMapMode(hdcDraw, MM_ANISOTROPIC);
            SetWindowOrgEx(hdcDraw, 0, 0, NULL);
            SetWindowExtEx(hdcDraw, RECTWIDTH(m_rcCut), RECTHEIGHT(m_rcCut), NULL);
            SetViewportOrgEx(hdcDraw, ptDeviceOrigin.x, ptDeviceOrigin.y, NULL);
            SetViewportExtEx(hdcDraw, RECTWIDTH(m_rcBleed), RECTHEIGHT(m_rcBleed), NULL);

            HRGN hrgn = CreateRectRgnIndirect(&m_rcBleed);
            if (hrgn != NULL)
                SelectClipRgn(hdcDraw, hrgn);

            m_Annotations.RenderAllMarks(hdcDraw);

            SelectClipRgn(hdcDraw, NULL);

            if (hrgn != NULL)
                DeleteObject(hrgn);

            SetMapMode(hdcDraw, MM_TEXT);
            SetViewportOrgEx(hdcDraw, 0, 0, NULL);
            SetWindowOrgEx(hdcDraw, 0, 0, NULL);
        }

        m_pPreview->OnDraw(hdcDraw);
    }
    else 
    {
        TCHAR szBuf[80];
        LoadString(_Module.GetModuleInstance(), m_iStrID, szBuf, ARRAYSIZE(szBuf) );

        LOGFONT lf;
        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, 0);
        HFONT hFont = CreateFontIndirect(&lf);
        HFONT hFontOld;

        if (hFont)
            hFontOld = (HFONT)SelectObject(hdcDraw, hFont);

        if (!m_pPreview->OnSetColor(hdcDraw))
        {
            SetTextColor(hdcDraw, GetSysColor(COLOR_WINDOWTEXT));
            SetBkColor(hdcDraw, GetBackgroundColor());
        }

        RECT rc = { 0,0,m_cxWindow,m_cyWindow };
        ExtTextOut(hdcDraw, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
        DrawText(hdcDraw, szBuf, -1, &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

        if (hFont)
        {
            SelectObject(hdcDraw, hFontOld);
            DeleteObject(hFont);
        }
    }

    EndPaint(&ps);
    return 0;
}


// OnSetCursor
//
// Handles WM_SETCURSOR messages sent to the window.
//
// This function is a total HackMaster job.  I have overloaded its functionality to the point
// of absurdity.  Here's what the parameters mean:
//
// uMsg == WM_SETCURSOR
//      wParam  Standard value sent during a WM_SETCURSOR messge.
//      lParam  Standard value sent during a WM_SETCURSOR messge.
//
// uMsg == 0
//      wParam  0
//      lParam  If this value is non-zero then it is a packed x,y cursor location.
//              If it's zero then we need to query the cursor location

LRESULT CZoomWnd::OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{

    // if this is a legitimate message but isn't intended for the client area, we ignore it.
    // we also ignore set cursor when we have no valid bitmap
    
    if (((WM_SETCURSOR == uMsg) && (HTCLIENT != LOWORD(lParam))) || (m_iStrID != IDS_LOADING && !m_pImageData))
    {
        bHandled = FALSE;
        return 0;
    }
    else if (0 == uMsg)
    {
        // Since this is one of our fake messages we need to do our own check to test for HTCLIENT.
        // we need to find the cursor location
        POINT pt;
        GetCursorPos(&pt);
        lParam = MAKELONG(pt.x, pt.y);
        if (HTCLIENT != SendMessage(WM_NCHITTEST, 0, lParam))
        {
            bHandled = FALSE;
            return 0;
        }
    }

    if (m_pPreview->OnSetCursor(uMsg, wParam, lParam))
    {
        bHandled = TRUE;
        return TRUE;
    }
    
    
    HINSTANCE hinst = _Module.GetModuleInstance();
    LPTSTR idCur;
    if (m_iStrID == IDS_LOADING && !m_pImageData)
    {
        idCur = IDC_WAIT;
        hinst = NULL;
    }
    else if (m_fPanning)
    {
        idCur = MAKEINTRESOURCE(IDC_CLOSEDHAND);
    }
    else if (m_fCtrlDown)
    {
        idCur = MAKEINTRESOURCE(IDC_OPENHAND);
    }
    else if (m_modeDefault == MODE_NOACTION)
    {
        hinst = NULL;
        idCur = IDC_ARROW;
    }
    else if ((m_modeDefault == MODE_ZOOMIN && m_fShiftDown == FALSE) || (m_modeDefault == MODE_ZOOMOUT && m_fShiftDown == TRUE))
    {
        idCur = MAKEINTRESOURCE(IDC_ZOOMIN);
    }
    else
    {
        idCur = MAKEINTRESOURCE(IDC_ZOOMOUT);
    }

    SetCursor(LoadCursor(hinst, idCur));
    return TRUE;
}

// OnKeyUp
//
// Handles WM_KEYUP messages sent to the window
LRESULT CZoomWnd::OnKeyUp(UINT , WPARAM wParam, LPARAM , BOOL& bHandled)
{
    if (VK_CONTROL == wParam)
    {
        m_fCtrlDown = FALSE;
        OnSetCursor(0,0,0, bHandled);
    }
    else if (VK_SHIFT == wParam)
    {
        m_fShiftDown = FALSE;
        OnSetCursor(0,0,0, bHandled);
    }
    
    bHandled = FALSE;
    return 0;
}
  
// OnKeyDown
//
// Handles WM_KEYDOWN messages sent to the window
LRESULT CZoomWnd::OnKeyDown(UINT , WPARAM wParam, LPARAM , BOOL& bHandled)
{
    // when we return, we want to call the DefWindowProc
    bHandled = FALSE;

    switch (wParam)
    {
    case VK_PRIOR:
        OnScroll(WM_VSCROLL, m_fCtrlDown?SB_TOP:SB_PAGEUP, 0, bHandled);
        break;

    case VK_NEXT:
        OnScroll(WM_VSCROLL, m_fCtrlDown?SB_BOTTOM:SB_PAGEDOWN, 0, bHandled);
        break;

    case VK_END:
        OnScroll(WM_HSCROLL, m_fCtrlDown?SB_BOTTOM:SB_PAGEDOWN, 0, bHandled);
        break;

    case VK_HOME:
        OnScroll(WM_HSCROLL, m_fCtrlDown?SB_TOP:SB_PAGEUP, 0, bHandled);
        break;

    case VK_CONTROL:
    case VK_SHIFT:
        // if m_fPanning is TRUE then we are already in the middle of an operation so we
        // should maintain the cursor for that operation
        if (!m_fPanning)
        {
            if (VK_CONTROL == wParam)
            {
                m_fCtrlDown = TRUE;
            }
            if (VK_SHIFT == wParam)
            {
                m_fShiftDown = TRUE;
            }

            // Update the cursor based on the key states set above only if we are over our window
            OnSetCursor(0,0,0, bHandled);
        }
        break;

    default:
        // if in run screen preview mode any key other than Shift and Control will dismiss the window
        if (NULL == GetParent())
        {
            DestroyWindow();
        }
        return 1;   // return non-zero to indicate unprocessed message
    }

    return 0;
}


// OnMouseUp
//
// Handles WM_LBUTTONUP messages sent to the window

LRESULT CZoomWnd::OnMouseUp(UINT , WPARAM , LPARAM , BOOL& bHandled)
{
    if (m_fPanning)
        ReleaseCapture();
    m_fPanning = FALSE;
    bHandled = FALSE;
    return 0;
}

// OnMouseDown
//
// Handles WM_LBUTTONDOWN and WM_MBUTTONDOWN messages sent to the window
LRESULT CZoomWnd::OnMouseDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (m_pPreview->OnMouseDown(uMsg, wParam, lParam))
        return 0;

    // This stuff should be avoided if m_pImage is NULL.
    if (!m_pImageData)
        return 0;

    m_xPosMouse = GET_X_LPARAM(lParam);
    m_yPosMouse = GET_Y_LPARAM(lParam);

    ASSERT(m_fPanning == FALSE);

    // Holding the CTRL key makes a pan into a zoom and vise-versa.
    // The middle mouse button always pans regardless of default mode and key state.
    if ((wParam & MK_CONTROL) || (uMsg == WM_MBUTTONDOWN))
    {
        // REVIEW: check for pan being valid here?  Should be more efficient than all the checks
        // I have to do in OnMouseMove.
        m_fPanning = TRUE;

        OnSetCursor(0,0,0,bHandled);
        SetCapture();
    }
    else if (m_modeDefault != MODE_NOACTION)
    {
        // Holding down the shift key turns a zoomin into a zoomout and vise-versa.
        // The "default" zoom mode is zoom in (if mode = pan and ctrl key is down we zoom in).
        BOOL bZoomIn = (m_modeDefault != MODE_ZOOMOUT) ^ ((wParam & MK_SHIFT)?1:0);

        // Find the point we want to stay centered on:
        m_cxCenter = MulDiv(m_xPosMouse-m_ptszDest.x, m_cxImgPix, m_ptszDest.cx);
        m_cyCenter = MulDiv(m_yPosMouse-m_ptszDest.y, m_cyImgPix, m_ptszDest.cy);

        bZoomIn?ZoomIn():ZoomOut();
    }
    bHandled = FALSE;
    return 0;
}

void CZoomWnd::Zoom(WPARAM wParam, LPARAM lParam)
{
    switch (wParam&0xFF)
    {
    case IVZ_CENTER:
        break;
    case IVZ_POINT:
        {
            int x = GET_X_LPARAM(lParam);
            int y = GET_Y_LPARAM(lParam);

            if (x<0) x=0;
            else if (x>=m_cxImgPix) x = m_cxImgPix-1;
            if (y<0) y=0;
            else if (y>=m_cyImgPix) y = m_cyImgPix-1;

            m_cxCenter = x;
            m_cyCenter = y;
        }
        break;
    case IVZ_RECT:
        {
            LPRECT prc = (LPRECT)lParam;
            int x = (prc->left+prc->right)/2;
            int y = (prc->top+prc->bottom)/2;

            if (x<0) x=0;
            else if (x>=m_cxImgPix) x = m_cxImgPix-1;
            if (y<0) y=0;
            else if (y>=m_cyImgPix) y = m_cyImgPix-1;

            m_cxCenter = x;
            m_cyCenter = y;
            // TODO: This should really completely adjust the dest rect but I have to
            // check for any assumptions about aspect ratio before I allow this absolute
            // aspect ignoring zoom mode.
        }
        break;
    }
    if (wParam&IVZ_ZOOMOUT)
    {
        ZoomOut();
        SetMode(MODE_ZOOMOUT);
    }
    else
    {
        ZoomIn();
        SetMode(MODE_ZOOMIN);
    }
}

void CZoomWnd::ZoomIn()
{
    DWORD dwMode;
    m_pPreview->GetMode(&dwMode);
    if (m_pImageData && (SLIDESHOW_MODE != dwMode))
    {
        m_fBestFit = FALSE;

        // first, the height is adjusted by the amount the mouse cursor moved.
        m_ptszDest.cy = (LONG)/*ceil*/(m_ptszDest.cy*1.200);  // ceil is required in order to zoom in
                                                                // on 4px high or less image

        // FEATURE: allow zooming beyond 16x the full size of the image
        // The use of the Cut and Bleed rectangles should eliminate the need for this
        // arbitrary zoom limit.  The limit was originally added because GDI on win9x isn't ver good and
        // can't handle large images.  Even on NT you would eventually zoom to the point where
        // it would take many seconds to blt the bitmap.  Now we only blt the minimum required
        // area.
        if (m_ptszDest.cy >= m_cyImgPix*16)
        {
            m_ptszDest.cy = m_cyImgPix*16;
        }

        // next, a new width is calculated based on the original image dimensions and the new height
        m_ptszDest.cx = (LONG)(m_ptszDest.cy* (m_cxImgPhys*m_winDPIx)/(m_cyImgPhys*m_winDPIy));
        AdjustRectPlacement();
    }
}

void CZoomWnd::ZoomOut()
{
    DWORD dwMode;
    m_pPreview->GetMode(&dwMode);
    if (m_pImageData && (SLIDESHOW_MODE != dwMode))
    {
        // if the destination rect already fits within the window, don't allow a zoom out.
        // This check is to prevent a redraw that would occur otherwise 
        if ((m_ptszDest.cx <= MIN(m_cxWindow,m_cxImgPix)) &&
            (m_ptszDest.cy <= MIN(m_cyWindow,m_cyImgPix)))
        {
            m_fBestFit = TRUE;
            return;
        }

        // first, the height is adjusted by the amount the mouse cursor moved.
        m_ptszDest.cy = (LONG)/*floor*/(m_ptszDest.cy*0.833); // floor is default behavior
        // next, a new width is calculated based on the original image dimensions and the new height
        m_ptszDest.cx = (LONG)(m_ptszDest.cy* (m_cxImgPhys*m_winDPIx)/(m_cyImgPhys*m_winDPIy));
        AdjustRectPlacement();
    }
}

// OnMouseMove
//
// Handles WM_MOUSEMOVE messages sent to the control

LRESULT CZoomWnd::OnMouseMove(UINT , WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // This is something of a hack since I never recieve the keyboard focus
    m_fCtrlDown = (BOOL)(wParam & MK_CONTROL);
    m_fShiftDown = (BOOL)(wParam & MK_SHIFT); 
    
    // we only care about mouse move when the middle or left button is down
    // and we have a valid bitmap handle and we are panning
    if (!(wParam & (MK_LBUTTON|MK_MBUTTON)) || !m_fPanning || !m_pImageData)
    {
        m_pPreview->OnMouseMove(WM_MOUSEMOVE, wParam, lParam);
        bHandled = FALSE;
        return TRUE;
    }

    // we know we are panning when we reach this point
    ASSERT(m_fPanning);

    POINTS pt = MAKEPOINTS(lParam);
    PTSZ ptszDest;

    ptszDest.cx = m_ptszDest.cx;
    ptszDest.cy = m_ptszDest.cy;

    // only allow side-to-side panning if it's needed
    if (m_ptszDest.cx > m_cxWindow)
    {
        ptszDest.x = m_ptszDest.x + pt.x - m_xPosMouse;
    }
    else
    {
        ptszDest.x = m_ptszDest.x;
    }

    // only allow up-and-down panning if it's needed
    if (m_ptszDest.cy > m_cyWindow)
    {
        ptszDest.y = m_ptszDest.y + pt.y - m_yPosMouse;
    }
    else
    {
        ptszDest.y = m_ptszDest.y;
    }

    // if the image is now smaller than the window, center it
    // if the image is now panned when it shouldn't be, adjust the possition
    if (ptszDest.cx < m_cxWindow)
        ptszDest.x = (m_cxWindow-ptszDest.cx)/2;
    else
    {
        if (ptszDest.x < (m_cxWindow - ptszDest.cx))
            ptszDest.x = m_cxWindow - ptszDest.cx;
        if (ptszDest.x > 0)
            ptszDest.x = 0;
    }
    if (ptszDest.cy < m_cyWindow)
        ptszDest.y = (m_cyWindow-ptszDest.cy)/2;
    else
    {
        if (ptszDest.y < (m_cyWindow - ptszDest.cy))
            ptszDest.y = m_cyWindow - ptszDest.cy;
        if (ptszDest.y > 0)
            ptszDest.y = 0;
    }

    m_xPosMouse = pt.x;
    m_yPosMouse = pt.y;

    // ensure the scroll bars are correct
    SetScrollBars();

    // if anything has changed, we must invalidate the window to force a repaint
    if ((ptszDest.x != m_ptszDest.x) || (ptszDest.y != m_ptszDest.y) ||
         (ptszDest.cx != m_ptszDest.cx) || (ptszDest.y != m_ptszDest.y))
    {
        m_ptszDest = ptszDest;
        CalcCut();
        PrepareDraw();
    }

    // Update m_cxCenter and m_cyCenter so that a zoom after a pan will zoom in
    // on the correct area.  This is majorly annoying otherwise.  We want the
    // new center to be whatever is in the center of the window after we pan.
    m_cxCenter = MulDiv(m_cxWindow/2-m_ptszDest.x, m_cxImgPix, m_ptszDest.cx);
    m_cyCenter = MulDiv(m_cyWindow/2-m_ptszDest.y, m_cyImgPix, m_ptszDest.cy);

    return TRUE;
}

// OnSize
//
// Handles WM_SIZE messages set to the window

LRESULT CZoomWnd::OnSize(UINT , WPARAM , LPARAM lParam, BOOL&)
{
    m_cxWindow = GET_X_LPARAM(lParam);
    m_cyWindow = GET_Y_LPARAM(lParam);
    _UpdatePhysicalSize();
    if (m_fBestFit)
    {
        BestFit();
    }
    else
    {
        // The size of the rect doesn't change in this case, so just reposition
        AdjustRectPlacement();
    }

    return TRUE;
}

BOOL CZoomWnd::SetScheduler(IShellTaskScheduler * pTaskScheduler)
{
    if (!m_pTaskScheduler)
    {
        m_pTaskScheduler = pTaskScheduler;
        m_pTaskScheduler->AddRef();
        return TRUE;
    }
    return FALSE;
}

// SetMode
//
// Sets the current mouse mode to one of the values specified in the MODE enumeration.
// Currently there are two important modes, pan and zoom.  The mode effects the default mouse
// cursor when moving over the zoom window and the behavior of a click-and-drag with the
// left mouse button.  Holding the shift key effects the result of a click-and-drag but
// does not effect m_mode, which is the default when the shift key isn't down.

BOOL CZoomWnd::SetMode(MODE modeNew)
{
    if (m_modeDefault == modeNew)
        return FALSE;
    m_modeDefault = modeNew;
    BOOL bDummy;
    OnSetCursor(0,0,0, bDummy);
    return TRUE;
}

// ActualSize
//
// Displays image zoomed to its full size
void CZoomWnd::ActualSize()
{
    m_fBestFit = FALSE;

    if (m_pImageData)
    {
        // actual size means same size as the image
        m_ptszDest.cx = (LONG)(m_cxImgPix);
        m_ptszDest.cy = (LONG)(m_cyImgPix);

        // we center the image in the window
        m_ptszDest.x = (LONG)((m_cxWinPhys-m_cxImgPhys)*m_winDPIx/2.0);
        m_ptszDest.y = (LONG)((m_cyWinPhys-m_cyImgPhys)*m_winDPIy/2.0);

        CalcCut();

        // Setting actual size is a zoom operation.  Whenever we zoom we update our centerpoint.
        m_cxCenter = m_cxImgPix/2;
        m_cyCenter = m_cyImgPix/2;

        // turn scoll bars on/off as needed
        SetScrollBars();

        PrepareDraw();
    }
}


void CZoomWnd::GetPTSZForBestFit(int cxImgPix, int cyImgPix, float cxImgPhys, float cyImgPhys, PTSZ &ptszDest)
{
    // Determine the limiting axis, if any.
    if (cxImgPhys <= m_cxWinPhys && cyImgPhys <= m_cyWinPhys)
    {
        // item fits centered within window
        ptszDest.x = (LONG)((m_cxWinPhys-cxImgPhys)*m_winDPIx/2.0);
        ptszDest.y = (LONG)((m_cyWinPhys-cyImgPhys)*m_winDPIy/2.0);
        ptszDest.cx = (LONG)(cxImgPix);
        ptszDest.cy = (LONG)(cyImgPix);
    }
    else if (cxImgPhys * m_cyWinPhys < m_cxWinPhys * cyImgPhys)
    {
        // height is the limiting factor
        int iNewWidth = (int)((m_cyWinPhys*cxImgPhys/cyImgPhys) * m_winDPIx);
        ptszDest.x = (m_cxWindow-iNewWidth)/2;
        ptszDest.y = 0;
        ptszDest.cx = iNewWidth;
        ptszDest.cy = m_cyWindow;
    }
    else
    {
        // width is the limiting factor
        int iNewHeight = (int)((m_cxWinPhys*cyImgPhys/cxImgPhys) * m_winDPIy);
        ptszDest.x = 0;
        ptszDest.y = (m_cyWindow-iNewHeight)/2;
        ptszDest.cx = m_cxWindow;
        ptszDest.cy = iNewHeight;
    }
}

// BestFit
//
// Computes the default location for the destination rectangle.  This rectangle is a
// best fit while maintaining aspect ratio within a window of the given width and height.
// If the window is larger than the image, the image is centered, otherwise it is scaled
// to fit within the window.  The destination rectange is computed in the client coordinates
// of the window whose width and height are passed as arguments (ie we assume the point 0,0
// is the upper left corner of the window).
//
void CZoomWnd::BestFit()
{
    m_fBestFit = TRUE;

    if (m_pImageData)
    {
        // if scroll bars are on, adjust the client size to what it will be once they are off
        DWORD dwStyle = GetWindowLong(GWL_STYLE);
        if (dwStyle & (WS_VSCROLL|WS_HSCROLL))
        {
            m_cxWindow += (dwStyle&WS_VSCROLL)?m_cxVScroll:0;
            m_cyWindow += (dwStyle&WS_HSCROLL)?m_cyHScroll:0;
            _UpdatePhysicalSize();
        }

        GetPTSZForBestFit(m_cxImgPix, m_cyImgPix, m_cxImgPhys, m_cyImgPhys, m_ptszDest);

        // this should turn off the scroll bars if they are on
        if (dwStyle & (WS_VSCROLL|WS_HSCROLL))
        {
            SetScrollBars();
        }

        CalcCut();

        // ensure the scroll bars are now off
        ASSERT(0 == (GetWindowLong(GWL_STYLE)&(WS_VSCROLL|WS_HSCROLL)));

        PrepareDraw();
    }
}

// AdjustRectPlacement
//
// This function determines the optimal placement of the destination rectangle.  This may
// include resizing the destination rectangle if it is smaller than the "best fit" rectangle
// but it is primarily intended for repositioning the rectange due to a change in the window
// size or destination rectangle size.  The window is repositioned so that the centered point
// remains in the center of the window.
//
void CZoomWnd::AdjustRectPlacement()
{
    // if we have scroll bars ...
    DWORD dwStyle = GetWindowLong(GWL_STYLE);
    if (dwStyle&(WS_VSCROLL|WS_HSCROLL))
    {
        // .. and if removing scroll bars would allow the image to fit ...
        if ((m_ptszDest.cx < (m_cxWindow + ((dwStyle&WS_VSCROLL)?m_cxVScroll:0))) &&
             (m_ptszDest.cy < (m_cyWindow + ((dwStyle&WS_HSCROLL)?m_cyHScroll:0))))
        {
            // ... remove the scroll bars
            m_cxWindow += (dwStyle&WS_VSCROLL)?m_cxVScroll:0;
            m_cyWindow += (dwStyle&WS_HSCROLL)?m_cyHScroll:0;
            SetScrollBars();
            _UpdatePhysicalSize();
        }
    }

    // If the dest rect is smaller than the window ...
    if ((m_ptszDest.cx < m_cxWindow) && (m_ptszDest.cy < m_cyWindow))
    {
        // ... then it must be larger than the image.  Otherwise we switch
        // to "best fit" mode.
        if ((m_ptszDest.cx < (LONG)m_cxImgPix) && (m_ptszDest.cy < (LONG)m_cyImgPix))
        {
            BestFit();
            return;
        }
    }

    // given the window size, client area size, and dest rect size calculate the 
    // dest rect position.  This position is then restrained by the limits below.
    m_ptszDest.x = (m_cxWindow/2) - MulDiv(m_cxCenter, m_ptszDest.cx, m_cxImgPix);
    m_ptszDest.y = (m_cyWindow/2) - MulDiv(m_cyCenter, m_ptszDest.cy, m_cyImgPix);

    // if the image is now narrower than the window ...
    if (m_ptszDest.cx < m_cxWindow)
    {
        // ... center the image
        m_ptszDest.x = (m_cxWindow-m_ptszDest.cx)/2;
    }
    else
    {
        // if the image is now panned when it shouldn't be, adjust the position
        if (m_ptszDest.x < (m_cxWindow - m_ptszDest.cx))
            m_ptszDest.x = m_cxWindow - m_ptszDest.cx;
        if (m_ptszDest.x > 0)
            m_ptszDest.x = 0;
    }
    // if the image is now shorter than the window ...
    if (m_ptszDest.cy < m_cyWindow)
    {
        // ... center the image
        m_ptszDest.y = (m_cyWindow-m_ptszDest.cy)/2;
    }
    else
    {
        // if the image is now panned when it shouldn't be, adjust the position
        if (m_ptszDest.y < (m_cyWindow - m_ptszDest.cy))
            m_ptszDest.y = m_cyWindow - m_ptszDest.cy;
        if (m_ptszDest.y > 0)
            m_ptszDest.y = 0;
    }

    CalcCut();

    SetScrollBars();
    PrepareDraw();
}

// CalcCut
//
// This function should be called anytime the Destination rectangle changes.
// Based on the destination rectangle it determines what part of the image
// will be visible, ptszCut, and where on the window to place the stretched 
// cut rectangle, ptszBleed.
// 
void CZoomWnd::CalcCut()
{
    if (m_pImageData)
    {
        CalcCut(m_ptszDest, m_cxImage, m_cyImage, m_rcCut, m_rcBleed);
    }
}

void CZoomWnd::CalcCut(PTSZ ptszDest, int cxImage, int cyImage, RECT &rcCut, RECT &rcBleed)
{
    // If the expanded image doesn't occupy the entire window ...
    if ((ptszDest.cy <= m_cyWindow) || (ptszDest.cx <= m_cxWindow))
    {
        // draw the entire destination rectangle
        rcBleed.left   = ptszDest.x;
        rcBleed.top    = ptszDest.y;
        rcBleed.right  = ptszDest.x + ptszDest.cx;
        rcBleed.bottom = ptszDest.y + ptszDest.cy;

        // cut the entire image
        rcCut.left   = 0;
        rcCut.top    = 0;
        rcCut.right  = cxImage;
        rcCut.bottom = cyImage;
    }
    else
    {
        // NOTE: These calculations are written to retain as much
        // precision as possible. Loss of precision will result in
        // undesirable drawing artifacts in the destination window.
        // MulDiv is not used because it rounds the result when we
        // really want the result to be floored. 

        // Given destination rectangle calculate the rectangle 
        // of the original image that will be visible.

        // To do this we need to convert 2 points from window coordinates to image
        // coordinates, those two points are (0,0) and (cxWindow, cyWindow).  The
        // (0,0) point needs to be floored and the (cxWindow, cyWindow) point needs
        // to be ceilinged to handle partially visible pixels.  Since we don't have
        // a good way to do ceiling we just always add one.
        rcCut.left   = LONG(Int32x32To64(-ptszDest.x, cxImage) / ptszDest.cx);
        rcCut.top    = LONG(Int32x32To64(-ptszDest.y, cyImage) / ptszDest.cy);
        rcCut.right  = LONG(Int32x32To64(m_cxWindow-ptszDest.x, cxImage) / ptszDest.cx) + 1;
        rcCut.bottom = LONG(Int32x32To64(m_cyWindow-ptszDest.y, cyImage) / ptszDest.cy) + 1;

        // Make sure the +1 does extend past the image border or GDI+ will choke.
        // If we were doing a TRUE "ceiling" this wouldn't be needed.
        if (rcCut.right  > cxImage) rcCut.right  = cxImage;
        if (rcCut.bottom > cyImage) rcCut.bottom = cyImage;

        // Calculate where on the window to place the cut rectangle.
        // Only a fraction of a zoomed pixel may be visible, hence the bleed factor.
        // Basically we converted from window coordinates to image coordinates to find
        // the Cut rectangle (what we need to draw), now we convert that Cut rectangle
        // back to window coordinates so that we know exactly where we need to draw it.
        rcBleed.left   = ptszDest.x + LONG(Int32x32To64(rcCut.left,   ptszDest.cx) / cxImage);
        rcBleed.top    = ptszDest.y + LONG(Int32x32To64(rcCut.top,    ptszDest.cy) / cyImage);
        rcBleed.right  = ptszDest.x + LONG(Int32x32To64(rcCut.right,  ptszDest.cx) / cxImage);
        rcBleed.bottom = ptszDest.y + LONG(Int32x32To64(rcCut.bottom, ptszDest.cy) / cyImage);
    }
}

void CZoomWnd::GetVisibleImageWindowRect(LPRECT prectImage)
{ 
    CopyRect(prectImage, &m_rcBleed); 
}

void  CZoomWnd::GetImageFromWindow(LPPOINT ppoint, int cSize)
{
    for(int i=0;i<cSize;i++)
    {
        ppoint[i].x -= m_ptszDest.x;
        ppoint[i].y -= m_ptszDest.y;
        ppoint[i].x = MulDiv(ppoint[i].x, m_cxImage, m_ptszDest.cx);
        ppoint[i].y = MulDiv(ppoint[i].y, m_cyImage, m_ptszDest.cy);
    }
}

void CZoomWnd::GetWindowFromImage(LPPOINT ppoint, int cSize)
{
    for(int i=0;i<cSize;i++)
    {
        ppoint[i].x = MulDiv(ppoint[i].x, m_ptszDest.cx, m_cxImage);
        ppoint[i].y = MulDiv(ppoint[i].y, m_ptszDest.cy, m_cyImage);
        ppoint[i].x += m_ptszDest.x;
        ppoint[i].y += m_ptszDest.y;
    }
}

// StatusUpdate
//
// Sent when the image generation status has changed, once when the image is first
// being created and again if there is an error of any kind.
void CZoomWnd::StatusUpdate(int iStatus)
{
    if (m_pImageData)
    {
        m_pImageData->Release();
        m_pImageData = 0;
    }

    if (m_pFront)
    {
        DWORD dwMode;
        m_pPreview->GetMode(&dwMode);
        if (SLIDESHOW_MODE != dwMode)
        {
            DeleteBuffer(m_pFront);
            m_pFront = NULL;
        }
    }
    
    m_iStrID = iStatus;

    // m_cxImage and m_cyImage should be reset to their initial values so that we don't
    // accidentally draw scroll bars or something like that
    m_cxImage = 1;
    m_cyImage = 1;

    // The dest rect should be reset too so that we don't allow some zoom
    // or pan that isn't actually valid.
    m_ptszDest.y = 0;
    m_ptszDest.x = 0;
    m_ptszDest.cx = m_cxWindow;
    m_ptszDest.cy = m_cyWindow;

    SetScrollBars();

    if (m_hWnd)
    {
        PrepareDraw();
    }
}

// SetImageData
//
// Called to pass in the pointer to the IShellImageData we draw.  We hold a reference to this
// object so that we can use it to paint.
//
void CZoomWnd::SetImageData(CDecodeTask * pImageData, BOOL bUpdate)
{
    if (bUpdate)
    {
        m_fTimerReady = TRUE;

        if (m_pFront)
        {
            DWORD dwMode;
            m_pPreview->GetMode(&dwMode);

            if (SLIDESHOW_MODE != dwMode)
            {
                DeleteBuffer(m_pFront);
                m_pFront = NULL;
            }
        }
    }

    if (m_pImageData)
    {
        m_pImageData->Release();
    }

    m_pImageData = pImageData;

    if (m_pImageData)
    {
        m_pImageData->AddRef();

        m_pImageData->ChangePage(m_Annotations);

        SIZE sz;
        ULONG dpiX;
        ULONG dpiY;
        pImageData->GetSize(&sz);
        pImageData->GetResolution(&dpiX, &dpiY);
        if (m_cxImage != sz.cx || m_cyImage != sz.cy || dpiX != m_imgDPIx || dpiY != m_imgDPIy)
        {
            bUpdate = TRUE;
        }

        if (bUpdate)
        {
            // cache the image dimensions to avoid checking m_pImageData against NULL all over the place
            m_cxImage = sz.cx;
            m_cyImage = sz.cy;
            m_imgDPIx = (float)dpiX;
            m_imgDPIy = (float)dpiY;
            m_cxImgPhys = m_cxImage/m_imgDPIx;
            m_cyImgPhys = m_cyImage/m_imgDPIy;
            m_cxImgPix = (int)(m_cxImgPhys*m_winDPIx);
            m_cyImgPix = (int)(m_cyImgPhys*m_winDPIy);
            m_cxCenter = m_cxImgPix/2;
            m_cyCenter = m_cyImgPix/2;             
        }

        if (m_hWnd)
        {
            // REVIEW: should we keep the previous Actual Size/Best Fit setting? 
            if (bUpdate)
            {
                BestFit();
            }
            else
            {
                PrepareDraw();
            }
        }

        return;
    }

    m_iStrID = IDS_LOADFAILED;
}

void CZoomWnd::SetPalette(HPALETTE hpal)
{
    m_hpal = hpal;
}

void CZoomWnd::SetScrollBars()
{
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;
    si.nMin = 0;
    si.nMax = m_ptszDest.cx;
    si.nPage = m_cxWindow+1;
    si.nPos = 0-m_ptszDest.x;
    si.nTrackPos = 0;

    SetScrollInfo(SB_HORZ, &si, TRUE);

    si.nMax = m_ptszDest.cy;
    si.nPage = m_cyWindow+1;
    si.nPos = 0-m_ptszDest.y;

    SetScrollInfo(SB_VERT, &si, TRUE);
}

LRESULT CZoomWnd::OnScroll(UINT uMsg, WPARAM wParam, LPARAM , BOOL&)
{
    int iScrollBar;
    int iWindow;     // width or height of the window
    LONG * piTL;     // pointer to top or left point
    LONG   iWH;      // the width or height of the dest rect

    if (!m_pImageData)
        return 0;

    // handle both which direction we're scrolling
    if (WM_HSCROLL==uMsg)
    {
        iScrollBar = SB_HORZ;
        iWindow = m_cxWindow;
        piTL = &m_ptszDest.x;
        iWH = m_ptszDest.cx;
    }
    else
    {
        iScrollBar = SB_VERT;
        iWindow = m_cyWindow;
        piTL = &m_ptszDest.y;
        iWH = m_ptszDest.cy;
    }

    // Using the keyboard we can get scroll messages when we don't have scroll bars.
    // Ignore these messages.
    if (iWindow >= iWH)
    {
        // window is larger than the image, don't allow scrolling
        return 0;
    }

    // handle all possible scroll cases
    switch (LOWORD(wParam))
    {
    case SB_TOP:
        *piTL = 0;
        break;
    case SB_PAGEUP:
        *piTL += iWindow;
        break;
    case SB_LINEUP:
        (*piTL)++;
        break;
    case SB_LINEDOWN:
        (*piTL)--;
        break;
    case SB_PAGEDOWN:
        *piTL -= iWindow;
        break;
    case SB_BOTTOM:
        *piTL = iWindow-iWH;
        break;
    case SB_THUMBPOSITION:
    case SB_THUMBTRACK:
        *piTL = -HIWORD(wParam);
        break;
    case SB_ENDSCROLL:
        return 0;
    }

    // apply limits
    if (0 < *piTL)
        *piTL = 0;
    else if ((iWindow-iWH) > *piTL)
        *piTL = iWindow-iWH;

    CalcCut();

    // adjust scrollbars 
    SetScrollPos(iScrollBar, -(*piTL), TRUE);

    // calculate new center point relative to image
    if (WM_HSCROLL==uMsg)
    {
        m_cxCenter = MulDiv((m_cxWindow/2)-m_ptszDest.x, m_cxImage, m_ptszDest.cx);
    }
    else
    {
        m_cyCenter = MulDiv((m_cyWindow/2)-m_ptszDest.y, m_cyImage, m_ptszDest.cy);
    }

    PrepareDraw();
    return 0;
}

// OnWheelTurn
//
// Respondes to WM_MOUSEWHEEL messages sent to the parent window (then redirected here)

LRESULT CZoomWnd::OnWheelTurn(UINT , WPARAM wParam, LPARAM , BOOL&)
{
    BOOL bZoomIn = ((short)HIWORD(wParam) > 0);

    bZoomIn?ZoomIn():ZoomOut();

    return TRUE;
}

LRESULT CZoomWnd::OnSetFocus(UINT , WPARAM , LPARAM , BOOL&)
{
    HWND hwndParent = GetParent();
    ::SetFocus(hwndParent);
    return 0;
}

void CZoomWnd::CommitAnnotations()
{ 
    if (m_pImageData)
    {
        IShellImageData * pSID;
        if (SUCCEEDED(m_pImageData->Lock(&pSID)))
        {
            m_Annotations.CommitAnnotations(pSID);
            m_pImageData->Unlock();
        }
    }
}

BOOL CZoomWnd::ScrollBarsPresent()
{
    SCROLLINFO si = {0};
    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;
    if ((GetScrollInfo(SB_HORZ, &si) && si.nPos) || (GetScrollInfo(SB_VERT, &si) && si.nPos) )
    {
        return TRUE;
    }
    return FALSE;
}

void CZoomWnd::_UpdatePhysicalSize()
{
    m_cxWinPhys = (float)(m_cxWindow)/m_winDPIx;
    m_cyWinPhys = (float)(m_cyWindow)/m_winDPIy;
}

LRESULT CZoomWnd::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    FlushDrawMessages();
    
    if (m_pFront)
    {
        DeleteBuffer(m_pFront);
        m_pFront = NULL;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shscrap\scguid.h ===
// for .reg file 56117100-C0CD-101B-81E2-00AA004AE837
DEFINE_GUID(CLSID_CScrapData, 0x56117100L, 0xC0CD, 0x101B, 0x81, 0xE2, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

#ifdef FEATURE_SHELLEXTENSION

// for C6EDCDC0-8F67-11CE-A9BA-00AA004AE837
DEFINE_GUID(CLSID_CTemplateFolder, 0xC6EDCDC0L, 0x8F67, 0x11CE, 0xA9, 0xBA, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// for 6FF4A4E0-DBC4-11CE-A9BB-00AA004AE837
DEFINE_GUID(CLSID_CScrapExt, 0x6FF4A4E0L, 0xDBC4, 0x11CE, 0xA9, 0xBB, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

#endif

// 54BC7DC0-DC95-11CE-A9BB-00AA004AE837
DEFINE_GUID(CLSID_CShClientSite, 0x54BC7DC0L, 0xDC95, 0x11CE, 0xA9, 0xBB, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shscrap\sccreate.cpp ===
#include "shole.h"
#include "ids.h"

#ifdef SAVE_OBJECTDESCRIPTOR
extern "C" const WCHAR c_wszDescriptor[] = WSTR_SCRAPITEM L"ODS";

HRESULT Scrap_SaveODToStream(IStorage *pstgDoc, OBJECTDESCRIPTOR * pods)
{
    //
    // According to Anthony Kitowicz, we must clear this flag.
    //
    pods->dwStatus &= ~OLEMISC_CANLINKBYOLE1;

    IStream *pstm;
    HRESULT hres = pstgDoc->CreateStream(c_wszDescriptor, STGM_CREATE|STGM_WRITE|STGM_SHARE_EXCLUSIVE, 0, 0, &pstm);
    if (SUCCEEDED(hres))
    {
        ULONG cbWritten;
        hres = pstm->Write(pods, pods->cbSize, &cbWritten);
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_SOD descriptor written (%x, %d, %d)"),
                 hres, pods->cbSize, cbWritten);
        pstm->Release();

        if (FAILED(hres) || cbWritten<pods->cbSize) {
            pstgDoc->DestroyElement(c_wszDescriptor);
        }
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_SOD pstg->CreateStream failed (%x)"), hres);
    }

    return hres;
}

HRESULT Scrap_SaveObjectDescriptor(IStorage *pstgDoc, IDataObject *pdtobj, IPersistStorage *pps, BOOL fLink)
{
    STGMEDIUM medium;
    FORMATETC fmte = {fLink ? CF_LINKSRCDESCRIPTOR : CF_OBJECTDESCRIPTOR, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hres = pdtobj->GetData(&fmte, &medium);
    if (hres == S_OK)
    {
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_SOD found CF_OBJECTDESCRIPTOR (%x)"), medium.hGlobal);
        LPOBJECTDESCRIPTOR pods = (LPOBJECTDESCRIPTOR)GlobalLock(medium.hGlobal);
        if (pods)
        {
            hres = Scrap_SaveODToStream(pstgDoc, pods);
            GlobalUnlock(medium.hGlobal);
        }
        ReleaseStgMedium(&medium);
    }
//
// Attempt to create object descriptor
//
#if 0
    else
    {
        hres = E_FAIL;
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_SOD CAN'T find CF_OBJECTDESCRIPTOR (%x)"), hres);
        LPOLEOBJECT pole;
        if (SUCCEEDED(pps->QueryInterface(IID_IOleObject, (LPVOID*)&pole)))
        {
            IMalloc *pmem;
            if (SUCCEEDED(CoGetMalloc(MEMCTX_TASK, &pmem)))
            {
                LPWSTR pwsz;
                if (SUCCEEDED(pole->GetUserType(USERCLASSTYPE_FULL, &pwsz)))
                {
                    UINT cbStr = pmem->GetSize(pwsz) + 1;
                    UINT cb = SIZEOF(OBJECTDESCRIPTOR) + cbStr;
                    LPOBJECTDESCRIPTOR pods=(LPOBJECTDESCRIPTOR)LocalAlloc(LPTR, cb);
                    if (pods)
                    {
                        pods->cbSize = cb;
                        pole->GetUserClassID(&pods->clsid);
                        pole->GetMiscStatus(DVASPECT_CONTENT, &pods->dwStatus);
                        pole->GetExtent(DVASPECT_CONTENT, &pods->sizel);
                        pods->dwFullUserTypeName = SIZEOF(OBJECTDESCRIPTOR);
                        CopyMemory(pods+1, pwsz, cbStr);
                        hres = Scrap_SaveODToStream(pstgDoc, pods);
                    }
                    pmem->Free(pwsz);
                }
                pmem->Release();
            }
            pole->Release();
        }
    }
#endif

    return hres;
}
#else
#define Scrap_SaveObjectDescriptor(pstgDoc, pdtobj, fLink) (0)
#endif // SAVE_OBJECTDESCRIPTOR

#ifdef FIX_ROUNDTRIP
extern "C" const TCHAR c_szCLSID[] = TEXT("CLSID");

//
//  This function opens the HKEY for the specified CLSID or its sub-key.
//
// Parameters:
//  rclsid    -- Specifies the CLSID
//  pszSubKey -- Specifies the subkey name, may be NULL
//
// Returns:
//  non-NULL, if succeeded; the caller must RegCloseKey it.
//  NULL, if failed.
//
HKEY _OpenCLSIDKey(REFCLSID rclsid, LPCTSTR pszSubKey)
{
#ifdef UNICODE
    WCHAR szCLSID[256];
    if (StringFromGUID2(rclsid, szCLSID, ARRAYSIZE(szCLSID)))
    {
#else
    WCHAR wszCLSID[256];
    if (StringFromGUID2(rclsid, wszCLSID, ARRAYSIZE(wszCLSID)))
    {
        TCHAR szCLSID[80];
        WideCharToMultiByte(CP_ACP, 0, wszCLSID, -1, szCLSID, ARRAYSIZE(szCLSID), NULL, NULL);
#endif

        TCHAR szKey[256];
        if (pszSubKey) {
            wsprintf(szKey, TEXT("%s\\%s\\%s"), c_szCLSID, szCLSID, pszSubKey);
        } else {
            wsprintf(szKey, TEXT("%s\\%s"), c_szCLSID, szCLSID);
        }
        DebugMsg(DM_TRACE, TEXT("sc TR - _OpelCLSIDKey RegOpenKey(%s)"), szKey);

        HKEY hkey;
        if (RegOpenKey(HKEY_CLASSES_ROOT, szKey, &hkey)==ERROR_SUCCESS)
        {
            return hkey;
        }
    }
    return NULL;
}

extern "C" const WCHAR c_wszFormatNames[] = WSTR_SCRAPITEM L"FMT";
#define CCH_FORMATNAMES (ARRAYSIZE(c_wszFormatNames)-1)

//
//  This function generates the stream name (UNICODE) for the spcified
// clipboard format.
//
// Parameters:
//  pszFormat -- Specifies the clipboard format ("#0"-"#15" for predefined ones)
//  wszStreamName -- Specifies the UNICODE buffer.
//  cchmax -- Specifies the size of buffer.
//
void _GetCacheStreamName(LPCTSTR pszFormat, LPWSTR wszStreamName, UINT cchMax)
{
    CopyMemory(wszStreamName, c_wszFormatNames, SIZEOF(c_wszFormatNames));
#ifdef UNICODE
    lstrcpyn(wszStreamName+CCH_FORMATNAMES,pszFormat,cchMax-CCH_FORMATNAMES);
#ifdef DEBUG
    DebugMsg(DM_TRACE, TEXT("sc TR _GetCacheStreamName returning %s"), wszStreamName);
#endif
#else
    MultiByteToWideChar(CP_ACP, 0, pszFormat, -1,
                        wszStreamName+CCH_FORMATNAMES,
                        cchMax-CCH_FORMATNAMES);
#ifdef DEBUG
    TCHAR szT[256];
    WideCharToMultiByte(CP_ACP, 0, wszStreamName, -1, szT, ARRAYSIZE(szT), NULL, NULL);
    DebugMsg(DM_TRACE, TEXT("sc TR _GetCacheStreamName returning %s"), szT);
#endif
#endif
}

HRESULT Scrap_CacheOnePictureFormat(LPCTSTR pszFormat, FORMATETC * pfmte, STGMEDIUM * pmedium, REFCLSID rclsid, LPSTORAGE pstgDoc, LPDATAOBJECT pdtobj)
{
    LPPERSISTSTORAGE ppstg;
    HRESULT hres = OleCreateDefaultHandler(rclsid, NULL, IID_IPersistStorage, (LPVOID *)&ppstg);
    DebugMsg(DM_TRACE, TEXT("sc TR Scrap_CacheOPF OleCreteDefHandler returned %x"), hres);
    if (SUCCEEDED(hres))
    {
        //
        // Generate the stream name based on the clipboard format name.
        //
        WCHAR wszStorageName[256];
        _GetCacheStreamName(pszFormat, wszStorageName, ARRAYSIZE(wszStorageName));

        LPSTORAGE pstgPicture;
        hres = pstgDoc->CreateStorage(wszStorageName, STGM_DIRECT | STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                    0, 0, &pstgPicture);
        if (SUCCEEDED(hres))
        {
            ppstg->InitNew(pstgPicture);

            LPOLECACHE pcache;
            hres = ppstg->QueryInterface(IID_IOleCache, (LPVOID*)&pcache);
            DebugMsg(DM_TRACE, TEXT("sc TR Scrap_CacheOPF QI returned %x"), hres);
            if (SUCCEEDED(hres))
            {
                hres = pcache->Cache(pfmte, ADVF_PRIMEFIRST, NULL);
                DebugMsg(DM_TRACE, TEXT("sc TR pcache->Cache returned %x"), hres);
                hres = pcache->SetData(pfmte, pmedium, FALSE);
                DebugMsg(DM_TRACE, TEXT("sc TR pcache->SetData returned %x"), hres);
                pcache->Release();

                if (SUCCEEDED(hres))
                {
                    hres = OleSave(ppstg, pstgPicture, TRUE);
                    DebugMsg(DM_TRACE, TEXT("sc TR Scrap_CacheOnePictureFormat OleSave returned (%x)"), hres);
                    ppstg->HandsOffStorage();

                    if (SUCCEEDED(hres))
                    {
                        hres = pstgPicture->Commit(STGC_OVERWRITE);
                        DebugMsg(DM_TRACE, TEXT("sc TR Scrap_CacheOnePictureFormat Commit() returned (%x)"), hres);
                    }
                }
            }

            pstgPicture->Release();

            if (FAILED(hres))
            {
                pstgDoc->DestroyElement(wszStorageName);
            }
        }

        ppstg->Release();
    }

    return hres;
}

//
//  This function stores the specified format of clipboard data.
//
// Parameters:
//  pszFormat -- Specifies the clipboard format ("#0"-"#15" for predefined ones)
//  pstgDoc -- Specifies the top level IStorage.
//  pdtobj -- Sepcified the data object we should get the data from.
//
HRESULT Scrap_CacheOneFormat(LPCTSTR pszFormat, LPSTORAGE pstgDoc, LPDATAOBJECT pdtobj)
{
    UINT cf = RegisterClipboardFormat(pszFormat);
    STGMEDIUM medium;
    FORMATETC fmte = {(CLIPFORMAT)cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    const CLSID * pclsid = NULL;
    switch(cf)
    {
    case CF_METAFILEPICT:
        pclsid = &CLSID_Picture_Metafile;
        fmte.tymed = TYMED_MFPICT;
        break;

    case CF_ENHMETAFILE:
        pclsid = &CLSID_Picture_EnhMetafile;
        fmte.tymed = TYMED_ENHMF;
        break;

    case CF_PALETTE:
    case CF_BITMAP:
        pclsid = &CLSID_Picture_Dib;
        fmte.tymed = TYMED_GDI;
        break;
    }

    //
    // Get the specified format of data (TYMED_GLOBAL only)
    //
    HRESULT hres = pdtobj->GetData(&fmte, &medium);
    if (hres == S_OK)
    {
        if (medium.tymed != TYMED_HGLOBAL)
        {
            hres = Scrap_CacheOnePictureFormat(pszFormat, &fmte, &medium, *pclsid, pstgDoc, pdtobj);
        }
        else
        {
            //
            // Global lock the data.
            //
            UINT cbData = (UINT)GlobalSize(medium.hGlobal);
            const BYTE * pbData = (const BYTE*)GlobalLock(medium.hGlobal);
            if (pbData)
            {
                //
                // Generate the stream name based on the clipboard format name.
                //
                WCHAR wszStreamName[256];
                _GetCacheStreamName(pszFormat, wszStreamName, ARRAYSIZE(wszStreamName));

                //
                // Create the stream.
                //
                LPSTREAM pstm;
                hres = pstgDoc->CreateStream(wszStreamName, STGM_CREATE|STGM_WRITE|STGM_SHARE_EXCLUSIVE, 0, 0, &pstm);
                if (SUCCEEDED(hres))
                {
                    //
                    // Save the size of data.
                    //
                    ULONG cbWritten;
                    hres = pstm->Write(&cbData, SIZEOF(cbData), &cbWritten);
                    if (SUCCEEDED(hres) && cbWritten==SIZEOF(cbData))
                    {
                        //
                        // Save the data itself.
                        //
                        hres = pstm->Write(pbData, cbData, &cbWritten);
                        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_Save %s written (%x, %d, %d)"),
                             pszFormat, hres, cbData, cbWritten);
                    }
                    pstm->Release();

                    //
                    // If anything goes wrong, destroy the stream.
                    //
                    if (FAILED(hres) || cbWritten<cbData)
                    {
                        pstgDoc->DestroyElement(wszStreamName);
                        hres = E_FAIL;
                    }
                }
                GlobalUnlock(medium.hGlobal);
            }
            else
            {
                hres = E_FAIL;
            }
        }
        ReleaseStgMedium(&medium);
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CacheOneFormat IDO::GetData(cf=%x,tm=%x) failed (%x)"),
                 fmte.cfFormat, fmte.tymed, hres);
    }

    return hres;
}

//
//  This function caches the specified format of data if the data object
// support that format.
//
// Parameters:
//  szFormat -- Specifies the format to be cahced
//  pstgDoc  -- Specifies the top level IStorage
//  pdtobj   -- Specifies the data object from where we get data
//  pstm     -- Specifies the stream we should write cached format name.
//
// Returns:
//  TRUE if the data object support it.
//
BOOL Scrap_MayCacheOneFormat(LPCTSTR szFormat, LPSTORAGE pstgDoc, LPDATAOBJECT pdtobj, LPSTREAM pstm)
{
    //
    // Try to cache the format.
    //
    HRESULT hres = Scrap_CacheOneFormat(szFormat, pstgDoc, pdtobj);
    if (SUCCEEDED(hres))
    {
        //
        //  Store the name of format only if we actually
        // succeeded to cache the data.
        //
#ifdef UNICODE
        CHAR szAnsiFormat[128];
        WideCharToMultiByte(CP_ACP, 0,
                            szFormat, -1,
                            szAnsiFormat, ARRAYSIZE(szAnsiFormat),
                            NULL, NULL );
        USHORT cb = (USHORT)lstrlenA(szAnsiFormat);
#else
        USHORT cb = (USHORT)lstrlen(szFormat);
#endif
        pstm->Write(&cb, SIZEOF(cb), NULL);
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_MayCacheOneFormat writing %s, %d"), szFormat, cb);
#ifdef UNICODE
        pstm->Write(szAnsiFormat, cb, NULL);
#else
        pstm->Write(szFormat, cb, NULL);
#endif

        return TRUE;
    }

    return FALSE;
}

//
// Returns:
//  TRUE, if the specified format is already cached (from Global list).
//
BOOL Scrap_IsAlreadyCached(UINT acf[], UINT ccf, LPCTSTR szFormat)
{
    if (ccf)
    {
        UINT cf = RegisterClipboardFormat(szFormat);
        for (UINT icf=0; icf<ccf; icf++) {
            if (acf[icf]==cf) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

extern "C" const TCHAR c_szCacheFMT[] = TEXT("DataFormats\\PriorityCacheFormats");
#define REGSTR_PATH_SCRAP TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ShellScrap")
extern "C" const TCHAR c_szGlobalCachedFormats[] = REGSTR_PATH_SCRAP TEXT("\\PriorityCacheFormats");

//
//  This function enumerate the list of to-be-cached clipboard data and
// calls Scrap_CacheOneFormat for each of them.
//
// Parameters:
//  pstgDoc -- Specifies the top level IStorage.
//  pdtobj  -- Specifies the data object we'll get the data from.
//  pps     -- Specifies the "embedded object" (to get CLSID from)
//
void Scrap_CacheClipboardData(LPSTORAGE pstgDoc, LPDATAOBJECT pdtobj, LPPERSIST pps)
{
    //
    //  Create the stream where we'll store the list of actually
    // cached formats, which might be just a subset of to-be-cached
    // format specified in the registry.
    //
    LPSTREAM pstm;
    HRESULT hres = pstgDoc->CreateStream(c_wszFormatNames, STGM_CREATE|STGM_WRITE|STGM_SHARE_EXCLUSIVE, 0, 0, &pstm);

    DebugMsg(DM_TRACE, TEXT("sc TR S_CCD CreateStream returned %x"), hres);

    if (SUCCEEDED(hres))
    {
        USHORT cb;
        HKEY hkey;
        TCHAR szFormatName[128];
        DWORD cchValueName;
        DWORD dwType;
        UINT  acf[CCF_CACHE_GLOBAL];
        UINT  ccf = 0;

        //
        // First, try the formats in the global list.
        //
        if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szGlobalCachedFormats, &hkey)==ERROR_SUCCESS)
        {
            //
            // For each global to-be-cached format...
            //
            for(int iValue=0; iValue<CCF_CACHE_GLOBAL ;iValue++)
            {
                //
                //  Get the value name of the iValue'th value. The value
                // name specifies the clipboard format.
                // ("#0"-"#15" for predefined formats).
                //
                cchValueName = ARRAYSIZE(szFormatName);
                if (RegEnumValue(hkey, iValue, szFormatName, &cchValueName, NULL,
                                 &dwType, NULL, NULL)==ERROR_SUCCESS)
                {
                    DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CacheClipboardData found with %s, %x (Global)"), szFormatName, dwType);
                    if (Scrap_MayCacheOneFormat(szFormatName, pstgDoc, pdtobj, pstm))
                    {
                        acf[ccf++] = RegisterClipboardFormat(szFormatName);
                    }
                }
                else
                {
                    break;
                }
            }

            RegCloseKey(hkey);
        }

        //
        // Then, try the CLSID specific formats.
        //
        // Get the CLSID of the "embedded object" (the body of scrap)
        //
        CLSID clsid;
        hres = pps->GetClassID(&clsid);
        if (SUCCEEDED(hres))
        {
            //
            // Open the key for the list of to-be-cached formats.
            //
            hkey = _OpenCLSIDKey(clsid, c_szCacheFMT);
            if (hkey)
            {
                //
                // For each class specific to-be-cached format...
                //
                for(int iValue=0; iValue<CCF_CACHE_CLSID ;iValue++)
                {
                    //
                    //  Get the value name of the iValue'th value. The value
                    // name specifies the clipboard format.
                    // ("#0"-"#15" for predefined formats).
                    //
                    cchValueName = ARRAYSIZE(szFormatName);

                    if (RegEnumValue(hkey, iValue, szFormatName, &cchValueName, NULL,
                                     &dwType, NULL, NULL)==ERROR_SUCCESS)
                    {
                        if (!Scrap_IsAlreadyCached(acf, ccf, szFormatName))
                        {
                            DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CacheClipboardData found with %s, %x (CLSID specific)"), szFormatName, dwType);
                            Scrap_MayCacheOneFormat(szFormatName, pstgDoc, pdtobj, pstm);
                        }
                        else
                        {
                            DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CacheClipboardData skipping %s (already cached)"), szFormatName);
                        }
                    }
                    else
                    {
                        break;
                    }
                }

                //
                // HACK: NT 3.5's RegEdit does not support named values...
                //
                for(iValue=0; iValue<CCF_CACHE_CLSID ;iValue++)
                {
                    TCHAR szKeyName[128];
                    if (RegEnumKey(hkey, iValue, szKeyName, ARRAYSIZE(szKeyName))==ERROR_SUCCESS)
                    {
                        LONG cbValue = ARRAYSIZE(szFormatName);
                        if ((RegQueryValue(hkey, szKeyName, szFormatName, &cbValue)==ERROR_SUCCESS) && cbValue)
                        {
                            if (!Scrap_IsAlreadyCached(acf, ccf, szFormatName))
                            {
                                DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CacheClipboardData found with %s, %x (CLSID specific)"), szFormatName, dwType);
                                Scrap_MayCacheOneFormat(szFormatName, pstgDoc, pdtobj, pstm);
                            }
                            else
                            {
                                DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CacheClipboardData skipping %s (already cached)"), szFormatName);
                            }
                        }
                    }
                    else
                    {
                        break;
                    }
                }

                RegCloseKey(hkey);
            }
        }

        //
        // Put the terminator.
        //
        cb = 0;
        pstm->Write(&cb, SIZEOF(cb), NULL);
        pstm->Release();

    }

}
#endif // FIX_ROUNDTRIP

// out:
//      pszName - short name for object type ("Worksheet", "Word Document", etc)
//
// returns:
//

HRESULT Scrap_Save(IStorage *pstg, IStorage *pstgDoc, IDataObject *pdtobj, BOOL fLink, LPTSTR pszName)
{
    IPersistStorage *pps;
    HRESULT hres;

    if (fLink)
    {
        FORMATETC fmte = {CF_METAFILEPICT, NULL, DVASPECT_ICON, -1, TYMED_MFPICT};
        hres = OleCreateLinkFromData(pdtobj, IID_IPersistStorage, OLERENDER_FORMAT,
                                     &fmte, NULL, pstg, (LPVOID*)&pps);
        DebugMsg(DM_TRACE, TEXT("sc Scrap_Save OleCreateLinkFromData(FMT) returned (%x)"), hres);
    }
    else
    {
        hres = OleCreateFromData(pdtobj, IID_IPersistStorage, OLERENDER_DRAW,
                                 NULL, NULL, pstg, (LPVOID*)&pps);
        DebugMsg(DM_TRACE, TEXT("sc Scrap_Save OleCreateFromData(FMT) returned (%x)"), hres);
    }

    if (SUCCEEDED(hres))
    {
        hres = OleSave(pps, pstg, TRUE);        // fSameStorage=TRUE

        DebugMsg(DM_TRACE, TEXT("sc Scrap_Save OleSave returned (%x)"), hres);

        if (SUCCEEDED(hres) && pszName)
        {
            LPOLEOBJECT pole;
            if (SUCCEEDED(pps->QueryInterface(IID_IOleObject, (LPVOID*)&pole)))
            {
                IMalloc *pmem;
                if (SUCCEEDED(CoGetMalloc(MEMCTX_TASK, &pmem)))
                {
                    LPWSTR pwsz;
                    if (SUCCEEDED(pole->GetUserType(USERCLASSTYPE_SHORT, &pwsz)))
                    {
#ifdef UNICODE
                        lstrcpyn(pszName, pwsz, 64);    // What is 64?
#else
                        WideCharToMultiByte(CP_ACP, 0, pwsz, -1, pszName, 64, NULL, NULL);
#endif

                        DebugMsg(DM_TRACE, TEXT("sc Scrap_Save short name (%s)"), pszName);

                        // Assert(lstrlen(pszName) < 15); // USERCLASSTYPE_SHORT docs say so
                        pmem->Free(pwsz);
                    }
                    pmem->Release();
                }
                pole->Release();
            }
        }

        // This is no-op if SAVE_OBJECTDESCRIPTOR is not defined.
        Scrap_SaveObjectDescriptor(pstgDoc, pdtobj, pps, fLink);

#ifdef FIX_ROUNDTRIP
        if (!fLink)
        {
            Scrap_CacheClipboardData(pstgDoc, pdtobj, pps);
        }
#endif // FIX_ROUNDTRIP

        hres = pps->HandsOffStorage();

        pps->Release();
    }

    return hres;

}

//
//  We have ANSI text but no UNICODE Text.  Look for RTF in order to
//  see if we can find a language id so that we can use the correct
//  code page for the Ansi to Unicode translation.
//
UINT Scrap_SniffCodePage(IDataObject *pdtobj)
{
    UINT CodePage = CP_ACP;
    FORMATETC fmte = { CF_RTF, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL | TYMED_ISTREAM };
    STGMEDIUM medium;

    if (SUCCEEDED(pdtobj->GetData(&fmte, &medium)))
    {
        CHAR szBuf[MAX_PATH * 8] = { 0 };
        LPSTR pszRTF = NULL;

        if (medium.tymed == TYMED_ISTREAM)
        {
            // Read one less byte to ensure proper null termination
            if (SUCCEEDED(medium.pstm->Read((LPVOID)szBuf, sizeof(szBuf) - 1, NULL)))
            {
                pszRTF = szBuf;
            }
        }
        else
        {
            pszRTF = (LPSTR)GlobalLock(medium.hGlobal);
        }

        if (pszRTF)
        {
            LPSTR pTmp;

            //
            //  Find the language id used for this text.
            //
            //  Ugly way to search, but can't use c-runtimes in the
            //  shell.
            //
            CHAR szLang[5];
            UINT LangID = 0;

            pTmp = pszRTF;
            while (*pTmp)
            {
                if ((*pTmp == '\\') &&
                    *(pTmp + 1)    && (*(pTmp + 1) == 'l') &&
                    *(pTmp + 2)    && (*(pTmp + 2) == 'a') &&
                    *(pTmp + 3)    && (*(pTmp + 3) == 'n') &&
                    *(pTmp + 4)    && (*(pTmp + 4) == 'g'))
                {
                    //
                    //  Get number following the \lang identifier.
                    //
                    int ctr;

                    pTmp += 5;
                    for (ctr = 0;
                         (ctr < 4) && (*(pTmp + ctr)) &&
                         ((*(pTmp + ctr)) >= '0') && ((*(pTmp + ctr)) <= '9');
                         ctr++)
                    {
                        szLang[ctr] = *(pTmp + ctr);
                    }
                    szLang[ctr] = 0;

                    for (pTmp = szLang; *pTmp; pTmp++)
                    {
                        LangID *= 10;
                        LangID += (*pTmp - '0');
                    }

                    break;
                }
                pTmp++;
            }
            if (LangID)
            {
                if (!GetLocaleInfo( LangID,
                                    LOCALE_IDEFAULTANSICODEPAGE |
                                      LOCALE_RETURN_NUMBER,
                                    (LPTSTR)&CodePage,
                                    sizeof(UINT) / sizeof(TCHAR) ))
                {
                    CodePage = CP_ACP;
                }
            }

            if (medium.tymed == TYMED_HGLOBAL)
            {
                GlobalUnlock(medium.hGlobal);
            }
        }
        ReleaseStgMedium(&medium);
    }

    return CodePage;
}

// get some text from the data object
//
// out:
//      pszOut  filled in with text
//

HRESULT Scrap_GetText(IDataObject *pdtobj, LPTSTR pszOut, UINT cchMax)
{
    ASSERT(cchMax > 1);

    UINT cbMac = (cchMax-1)*SIZEOF(pszOut[0]);
    ZeroMemory(pszOut, cchMax * SIZEOF(pszOut[0]));

    STGMEDIUM medium;
    HRESULT hres;
#ifdef UNICODE
    FORMATETC fmte = { CF_UNICODETEXT, NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM|TYMED_HGLOBAL };
    hres = pdtobj->QueryGetData( &fmte );
    if (hres != S_OK)           // S_FALSE means no.
    {
        fmte.cfFormat = CF_TEXT;
    }
    hres = pdtobj->GetData(&fmte, &medium);

#else
    FORMATETC fmte = { CF_TEXT, NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM|TYMED_HGLOBAL };
    hres = pdtobj->GetData(&fmte, &medium);
#endif

    if (SUCCEEDED(hres))
    {
        DebugMsg(DM_TRACE, TEXT("sh TR - Scrap_GetText found CF_TEXT/CF_UNICODETEXT in %d"), medium.tymed);
        if (medium.tymed == TYMED_ISTREAM)
        {
#ifdef UNICODE
            if (fmte.cfFormat == CF_TEXT)
            {
                // Stream is ansi but we are unicode - yuck
                LPSTR pAnsi = (LPSTR)LocalAlloc(LPTR, cchMax * sizeof(CHAR));
                if (pAnsi)
                {
                    // Read one short so we are guaranteed a null terminator
                    hres = medium.pstm->Read(pAnsi, cchMax - 1, NULL);
                    if (SUCCEEDED(hres)) {
                        SHAnsiToUnicodeCP(Scrap_SniffCodePage(pdtobj), pAnsi, pszOut, cchMax);
                    }
                    LocalFree(pAnsi);
                }
                else
                    hres = E_OUTOFMEMORY;
            }
            else
#endif
                hres = medium.pstm->Read(pszOut, cbMac, NULL);
        }
        else if (medium.tymed == TYMED_HGLOBAL)
        {
            DebugMsg(DM_TRACE, TEXT("sh TR - Scrap_GetText found CF_TEXT/CF_UNICODETEXT in global"));
            LPTSTR pszSrc = (LPTSTR)GlobalLock(medium.hGlobal);
            if (pszSrc)
            {
#ifdef UNICODE
                if ( fmte.cfFormat == CF_TEXT )
                {
                    SHAnsiToUnicodeCP(Scrap_SniffCodePage(pdtobj), (LPSTR)pszSrc, pszOut, cchMax);
                }
                else
#endif
                {
                    lstrcpyn(pszOut, pszSrc, cchMax);
                }
                GlobalUnlock(medium.hGlobal);
            }
        }
        ReleaseStgMedium(&medium);
    }

    return hres;
}


// Avoid linking lots of CRuntime stuff.
#undef isdigit
#undef isalpha
#define isdigit(ch) (ch>=TEXT('0') && ch<=TEXT('9'))
#define isalpha(ch) ((ch&0xdf)>=TEXT('A') && (ch&0xdf)<=TEXT('Z'))

#define CCH_MAXLEADINGSPACE     256
#define CCH_COPY                16

//
// create a fancy name for a scrap/doc shortcut given the data object to get some
// text from
//
// out:
//      pszNewName      - assumed to be 64 chars at least
//

BOOL Scrap_GetFancyName(IDataObject *pdtobj, UINT idTemplate, LPCTSTR pszPath, LPCTSTR pszTypeName, LPTSTR pszNewName)
{
    TCHAR szText[CCH_MAXLEADINGSPACE + CCH_COPY + 1];
    HRESULT hres = Scrap_GetText(pdtobj, szText, ARRAYSIZE(szText));

    if (SUCCEEDED(hres))
    {
#ifdef UNICODE
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_GetFancyName CF_UNICODETEXT has (%s)"), szText);
#else
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_GetFancyName CF_TEXT has (%s)"), szText);
#endif
        LPTSTR pszStart;
        //
        // skip leading space/non-printing characters
        //
        for (pszStart = szText; (TBYTE)*pszStart <= TEXT(' '); pszStart++)
        {
            if (*pszStart == TEXT('\0'))
                return FALSE;   // empty string

            if (pszStart - szText >= CCH_MAXLEADINGSPACE)
                return FALSE;   // too many leading space
        }
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_GetFancyName pszStart (%s)"), pszStart);

        //
        // Chacter conversion
        //  (1) non-printing characters -> ' '
        //  (2) invalid characters -> '_'
        //
        for (LPTSTR pszT = pszStart; *pszT && ((pszT-pszStart) < CCH_COPY); pszT = CharNext(pszT))
        {
            TBYTE ch = (TBYTE)*pszT;
            if (ch <= TEXT(' '))
            {
                *pszT = TEXT(' ');
            }
            else if (ch < 127 && !isdigit(ch) && !isalpha(ch))
            {
                switch(ch)
                {
                case TEXT('$'):
                case TEXT('%'):
                case TEXT('\''):
                case TEXT('-'):
                case TEXT('_'):
                case TEXT('@'):
                case TEXT('~'):
                case TEXT('`'):
                case TEXT('!'):
                case TEXT('('):
                case TEXT(')'):
                case TEXT('{'):
                case TEXT('}'):
                case TEXT('^'):
                case TEXT('#'):
                case TEXT('&'):
                    break;

                default:
                    *pszT = TEXT('_');
                    break;
                }
            }
        }
        *pszT = 0;

        TCHAR szTemplate[MAX_PATH];
        TCHAR szName[MAX_PATH];

        LoadString(HINST_THISDLL, idTemplate, szTemplate, ARRAYSIZE(szTemplate));
        wsprintf(szName, szTemplate, pszTypeName, pszStart);

        if (PathYetAnotherMakeUniqueName(szName, pszPath, szName, szName))
        {
            DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_GetFancyName (%s)"), szName);
            lstrcpy(pszNewName, szName);
            return TRUE;
        }
    }
    return FALSE;
}

// *** WARNING ***
//
// Scrap_CreateFromDataObject is a TCHAR export from SHSCRAP.DLL that is used by SHELL32.DLL. If you
// change its calling convention, you must modify shell32's wrapper as well as well.
//
// *** WARNING ***
HRESULT WINAPI Scrap_CreateFromDataObject(LPCTSTR pszPath, IDataObject *pdtobj, BOOL fLink, LPTSTR pszNewFile)
{
    HRESULT hres;
    TCHAR szTemplateS[32];
    TCHAR szTemplateL[128];
    TCHAR szTypeName[64];
#ifndef UNICODE
    WCHAR wszNewFile[MAX_PATH];
#endif
    IStorage *pstg;
    UINT idErr = 0;

    DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CreateFromDataObject called at %s"), pszPath);

    LoadString(HINST_THISDLL, fLink ? IDS_BOOKMARK_S : IDS_SCRAP_S, szTemplateS, ARRAYSIZE(szTemplateS));
    LoadString(HINST_THISDLL, fLink ? IDS_BOOKMARK_L : IDS_SCRAP_L, szTemplateL, ARRAYSIZE(szTemplateL));

    PathYetAnotherMakeUniqueName(pszNewFile, pszPath, szTemplateS, szTemplateL);

    DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CreateFromDataObject creating %s"), pszNewFile);

#ifdef UNICODE
    hres = StgCreateDocfile(pszNewFile,
                    STGM_DIRECT | STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                    0, &pstg);
#else
    MultiByteToWideChar(CP_ACP, 0, pszNewFile, -1, wszNewFile, ARRAYSIZE(wszNewFile));

    hres = StgCreateDocfile(wszNewFile,
                    STGM_DIRECT | STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                    0, &pstg);
#endif

    if (SUCCEEDED(hres))
    {
        IStorage *pstgContents;

        hres = pstg->CreateStorage(c_wszContents, STGM_DIRECT | STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                    0, 0, &pstgContents);

        if (SUCCEEDED(hres))
        {
            hres = Scrap_Save(pstgContents, pstg, pdtobj, fLink, szTypeName);
            if (SUCCEEDED(hres))
            {
                hres = pstgContents->Commit(STGC_OVERWRITE);
                if (FAILED(hres))
                    idErr = IDS_ERR_COMMIT;
            }
            else
            {
                idErr = IDS_ERR_SCRAPSAVE;
            }
            pstgContents->Release();
        }
        else
        {
            idErr = IDS_ERR_CREATESTORAGE;
        }

        //
        // We need to delete the file, if failed to save/commit.
        //
        if (SUCCEEDED(hres))
        {
            hres = pstg->Commit(STGC_OVERWRITE);
            if (FAILED(hres))
                idErr = IDS_ERR_COMMIT;
        }

        pstg->Release();

        if (FAILED(hres))
            DeleteFile(pszNewFile);
    }
    else
    {
        idErr = IDS_ERR_CREATEDOCFILE;
    }

    if (SUCCEEDED(hres))
    {
        if (IsLFNDrive(pszPath))
        {
            TCHAR szFancyName[MAX_PATH];

            if (Scrap_GetFancyName(pdtobj, fLink ? IDS_TEMPLINK : IDS_TEMPSCRAP, pszPath, szTypeName, szFancyName))
            {
                if (MoveFile(pszNewFile, szFancyName))
                    lstrcpy(pszNewFile, szFancyName);
            }
        }
    }
    else
    {
        DisplayError((HWND)NULL, hres, idErr, pszNewFile);
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shscrap\scdata.cpp ===
#include "shole.h"
#include "ids.h"

#define INITGUID
#include <initguid.h>
#include "scguid.h"

// #define SAVE_OBJECTDESCRIPTOR

extern "C" const WCHAR c_wszDescriptor[];

CLIPFORMAT _GetClipboardFormat(UINT id)
{
    static UINT s_acf[CFID_MAX] = { 0 };
    static const TCHAR * const c_aszFormat[CFID_MAX] = {
            TEXT("Embedded Object"),
            TEXT("Object Descriptor"),
            TEXT("Link Source Descriptor"),
            TEXT("Rich Text Format"),
            TEXT("Shell Scrap Object"),
            TEXT("TargetCLSID"),
            TEXT("Rich Text Format"),
            };
    if (!s_acf[id])
    {
        s_acf[id] = RegisterClipboardFormat(c_aszFormat[id]);
    }
    return (CLIPFORMAT)s_acf[id];
}

//===========================================================================
// CScrapData : Class definition
//===========================================================================

class CScrapData : public IDataObject, public IPersistFile
#ifdef FEATURE_SHELLEXTENSION
    , public IExtractIcon
#ifdef UNICODE
    , public IExtractIconA
#endif // UNICODE
#endif // FEATURE_SHELLEXTENSION
{
public:
    CScrapData();
    ~CScrapData();

    // IUnKnown
    virtual HRESULT __stdcall QueryInterface(REFIID,void **);
    virtual ULONG   __stdcall AddRef(void);
    virtual ULONG   __stdcall Release(void);

    // IDataObject
    virtual HRESULT __stdcall GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
    virtual HRESULT __stdcall GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium);
    virtual HRESULT __stdcall QueryGetData(FORMATETC *pformatetc);
    virtual HRESULT __stdcall GetCanonicalFormatEtc(FORMATETC *pformatectIn, FORMATETC *pformatetcOut);
    virtual HRESULT __stdcall SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease);
    virtual HRESULT __stdcall EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc);
    virtual HRESULT __stdcall DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection);
    virtual HRESULT __stdcall DUnadvise(DWORD dwConnection);
    virtual HRESULT __stdcall EnumDAdvise(IEnumSTATDATA **ppenumAdvise);
    virtual HRESULT __stdcall IsDirty(void);

#ifdef FEATURE_SHELLEXTENSION
    // IExtractIcon
    virtual HRESULT __stdcall GetIconLocation(
                         UINT   uFlags, LPTSTR  szIconFile,
                         UINT   cchMax, int *piIndex, UINT *pwFlags);

    virtual HRESULT __stdcall Extract(
                           LPCTSTR pszFile, UINT nIconIndex,
			   HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);

#ifdef UNICODE
    // IExtractIconA
    virtual HRESULT __stdcall GetIconLocation(
                         UINT   uFlags, LPSTR  szIconFile,
                         UINT   cchMax, int *piIndex, UINT *pwFlags);

    virtual HRESULT __stdcall Extract(
                           LPCSTR pszFile, UINT nIconIndex,
                           HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);
#endif // UNICODE
#endif // FEATURE_SHELLEXTENSION

    // IPersistFile
    virtual HRESULT __stdcall GetClassID(CLSID *pClassID);
    virtual HRESULT __stdcall Load(LPCOLESTR pszFileName, DWORD dwMode);
    virtual HRESULT __stdcall Save(LPCOLESTR pszFileName, BOOL fRemember);
    virtual HRESULT __stdcall SaveCompleted(LPCOLESTR pszFileName);
    virtual HRESULT __stdcall GetCurFile(LPOLESTR *ppszFileName);

protected:
    HRESULT _OpenStorage(void);
    void    _CloseStorage(BOOL fResetFlags);
    INT     _GetFormatIndex(UINT cf);
    void    _FillCFArray(void);
#ifdef FIX_ROUNDTRIP
    HRESULT _RunObject(void);
#endif // FIX_ROUNDTRIP

#ifdef SAVE_OBJECTDESCRIPTOR
    HRESULT _GetObjectDescriptor(LPSTGMEDIUM pmedium, BOOL fGetHere);
#endif // SAVE_OBJECTDESCRIPTOR

    UINT         _cRef;
    BOOL         _fDoc:1;
    BOOL         _fItem:1;
    BOOL         _fObjDesc:1;
    BOOL         _fClsidTarget:1;
#ifdef FIX_ROUNDTRIP
    BOOL         _fRunObjectAlreadyCalled:1;
    LPDATAOBJECT _pdtobjItem;
#endif // FIX_ROUNDTRIP
    LPSTORAGE    _pstgDoc;
    LPSTORAGE    _pstgItem;
    LPSTREAM     _pstmObjDesc;
    TCHAR        _szPath[MAX_PATH];
    CLSID        _clsidTarget;
    INT          _ccf;          // number of clipboard format.
    INT          _icfCacheMax;  // Max cache format index
    DWORD        _acf[64];      // 64 must be enough!
};

//===========================================================================
// CScrapData : Constructor
//===========================================================================
CScrapData::CScrapData(void) : _cRef(1)
{
    ASSERT(_pstgDoc == NULL);
    ASSERT(_pstgItem == NULL);
    ASSERT(_fDoc == FALSE);
    ASSERT(_fItem == FALSE);
    ASSERT(_fObjDesc == FALSE);
    ASSERT(_ccf == 0);
    ASSERT(_fClsidTarget == FALSE);
#ifdef FIX_ROUNDTRIP
    ASSERT(_pdtobjItem == NULL);
    ASSERT(_fRunObjectAlreadyCalled == FALSE);
#endif // FIX_ROUNDTRIP
    ASSERT(_pstmObjDesc == NULL);

    _szPath[0] = TEXT('\0');
    g_cRefThisDll++;
}

CScrapData::~CScrapData()
{
#ifdef FIX_ROUNDTRIP
    if (_pdtobjItem) {
        _pdtobjItem->Release();
    }
#endif // FIX_ROUNDTRIP
    _CloseStorage(FALSE);
    g_cRefThisDll--;
}
//===========================================================================
// CScrapData : Member functions (private)
//===========================================================================
//
// private member CScrapData::_OpenStorage
//
HRESULT CScrapData::_OpenStorage(void)
{
    if (_pstgItem) {
        return S_OK;
    }

    HRESULT hres;
    WCHAR wszFile[MAX_PATH];

#ifdef UNICODE
    lstrcpyn(wszFile, _szPath, ARRAYSIZE(wszFile));
#ifdef DEBUG
    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetStorage is called (%s)"), wszFile);
#endif
#else
    MultiByteToWideChar(CP_ACP, 0, _szPath, -1, wszFile, ARRAYSIZE(wszFile));

#ifdef DEBUG
    TCHAR szFile[MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0, wszFile, -1, szFile, ARRAYSIZE(szFile), NULL, NULL);
    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetStorage is called (%s)"), szFile);
#endif
#endif

    hres = StgOpenStorage(wszFile, NULL,
                          STGM_READ | STGM_SHARE_DENY_WRITE,
                          NULL, 0, &_pstgDoc);
    if (SUCCEEDED(hres))
    {
        _fDoc = TRUE;
        hres = _pstgDoc->OpenStorage(c_wszContents, NULL,
                            STGM_READ | STGM_SHARE_EXCLUSIVE,
                            NULL, 0, &_pstgItem);
        if (SUCCEEDED(hres))
        {
            HRESULT hresT;
            _fItem = TRUE;
#ifdef SAVE_OBJECTDESCRIPTOR
            hresT = _pstgDoc->OpenStream(c_wszDescriptor, 0,
                                STGM_READ | STGM_SHARE_EXCLUSIVE,
                                0, &_pstmObjDesc);
            _fObjDesc = SUCCEEDED(hresT);
#endif // SAVE_OBJECTDESCRIPTOR
        }
        else
        {
            DebugMsg(DM_TRACE, TEXT("sc TR - CSD::_OpenStorage _pstgDoc->OpenStorage failed (%x)"), hres);
            _pstgDoc->Release();
            _pstgDoc = NULL;
        }
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::_OpenStorage StgOpenStorage failed (%x)"), hres);
    }

    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::_OpenStorage _pstgDoc->OpenStorage returning (%x) %x"),
                hres, _pstmObjDesc);
    return hres;
}

void CScrapData::_CloseStorage(BOOL fResetFlags)
{
#ifdef DEBUG
    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::CloseStorage"));
#endif

    if (_pstgItem) {
        _pstgItem->Release();
        _pstgItem = NULL;
    }
    if (_pstmObjDesc) {
        _pstmObjDesc->Release();
        _pstmObjDesc = NULL;
    }
    if (_pstgDoc) {
        _pstgDoc->Release();
        _pstgDoc = NULL;
    }

    if (fResetFlags) {
        _fItem = FALSE;
        _fObjDesc = FALSE;
        _fDoc = FALSE;
    }
}

INT CScrapData::_GetFormatIndex(UINT cf)
{
    for (INT i=0; i<_ccf; i++)
    {
        if (_acf[i] == cf)
        {
            return i;
        }
    }
    return -1;
}

#ifdef FIX_ROUNDTRIP
extern "C" const TCHAR c_szRenderFMT[] = TEXT("DataFormats\\DelayRenderFormats");
#endif // FIX_ROUNDTRIP

extern "C" const WCHAR c_wszFormatNames[];

//
//  This function filles the clipboard format array (_acf). Following
// clipboard format may be added.
//
// Step 1. CF_EMBEEDEDOBJECT
// Step 2. CF_OBJECTDESCRIPTOR
// Step 3. CF_SCRAPOBJECT
// Step 4. Cached clipboard formats (from a stream).
// Step 5. Delay Rendered clipbaord formats (from registry).
//
void CScrapData::_FillCFArray(void)
{
    _ccf=0;
    //
    // Step 1.
    //
    if (_fItem) {
        _acf[_ccf++] = CF_EMBEDDEDOBJECT;
    }

    //
    // Step 2.
    //
    if (_fObjDesc) {
        _acf[_ccf++] = CF_OBJECTDESCRIPTOR;
    }

    //
    // Step 3.
    //
    if (_fDoc)
    {
        _acf[_ccf++] = CF_SCRAPOBJECT;
    }

#ifdef FIX_ROUNDTRIP

    HRESULT hres = _OpenStorage();

    if (SUCCEEDED(hres) && _pstgItem)
    {
        //
        // Step 3. Cached clipboard formats
        //
        //
        // Open the stream which contains the names of cached formats.
        //
        LPSTREAM pstm;
        HRESULT hres = _pstgDoc->OpenStream(c_wszFormatNames, NULL,
                                STGM_READ | STGM_SHARE_EXCLUSIVE,
                                NULL, &pstm);

        if (SUCCEEDED(hres))
        {
            //
            // For each cached format...
            //
            USHORT cb;
            DWORD cbRead;
            while(SUCCEEDED(pstm->Read(&cb, SIZEOF(cb), &cbRead)) && cbRead==SIZEOF(cb)
                  && cb && cb<128)
            {
                UINT cf = 0;

                //
                // Get the cached clipboard format name
                //
                CHAR szFormat[128];
                szFormat[cb] = '\0';
                hres = pstm->Read(szFormat, cb, &cbRead);
                if (SUCCEEDED(hres) && cbRead==cb && lstrlenA(szFormat)==cb)
                {
                    //
                    // Append it to the array.
                    //
#ifdef UNICODE
                    TCHAR wszFormat[128];
                    MultiByteToWideChar(CP_ACP, 0,
                                        szFormat, -1,
                                        wszFormat, ARRAYSIZE(wszFormat));
                    DebugMsg(DM_TRACE, TEXT("sc TR _FillCFA Found Cached Format %s"), wszFormat);
#else
                    DebugMsg(DM_TRACE, TEXT("sc TR _FillCFA Found Cached Format %s"), szFormat);
#endif
                    cf = RegisterClipboardFormatA(szFormat);

                    if (cf)
                    {
                        _acf[_ccf++] = cf;
                    }
                }
                else
                {
                    break;
                }
            }
            pstm->Release();
        }

        _icfCacheMax = _ccf;

        //
        // Step 4. Get the list of delay-rendered clipboard formats
        //
        LPPERSISTSTORAGE pps;
        hres = OleLoad(_pstgItem, IID_IPersistStorage, NULL, (LPVOID *)&pps);
        if (SUCCEEDED(hres))
        {
            //
            // Get the CLSID of embedding.
            //
            CLSID clsid;
            hres = pps->GetClassID(&clsid);
            if (SUCCEEDED(hres))
            {
                //
                // Open the key for delay-rendered format names.
                //
                extern HKEY _OpenCLSIDKey(REFCLSID rclsid, LPCTSTR pszSubKey);
                HKEY hkey = _OpenCLSIDKey(clsid, c_szRenderFMT);
                if (hkey)
                {
                    TCHAR szValueName[128];
                    //
                    // For each delay-rendered clipboard format...
                    //
                    for(int iValue=0; ;iValue++)
                    {
                        //
                        // Get the value name, which is the format name.
                        //
                        DWORD cchValueName = ARRAYSIZE(szValueName);
                        DWORD dwType;
                        if (RegEnumValue(hkey, iValue, szValueName, &cchValueName, NULL,
                                         &dwType, NULL, NULL)==ERROR_SUCCESS)
                        {
                            DebugMsg(DM_TRACE, TEXT("sc TR - CSD::_FillCFA RegEnumValue found %s, %x"), szValueName, dwType);
                            UINT cf = RegisterClipboardFormat(szValueName);

                            if (cf)
                            {
                                _acf[_ccf++] = cf;
                            }
                        }
                        else
                        {
                            break;
                        }
                    }

                    //
                    // HACK: NT 3.5's regedit does not support named value...
                    //
                    for(iValue=0; ;iValue++)
                    {
                        TCHAR szKeyName[128];
                        //
                        // Get the value name, which is the format name.
                        //
                        if (RegEnumKey(hkey, iValue, szKeyName, ARRAYSIZE(szKeyName))==ERROR_SUCCESS)
                        {
                            DebugMsg(DM_TRACE, TEXT("sc TR - CSD::_FillCFA RegEnumValue found %s"), szValueName);
                            LONG cbValue = ARRAYSIZE(szValueName);
                            if ((RegQueryValue(hkey, szKeyName, szValueName, &cbValue)==ERROR_SUCCESS) && cbValue)
                            {
                                UINT cf = RegisterClipboardFormat(szValueName);

                                if (cf)
                                {
                                    _acf[_ccf++] = cf;
                                }
                            }
                        }
                        else
                        {
                            break;
                        }
                    }
                    RegCloseKey(hkey);
                }
            }
            pps->Release();
        }
    }
#endif // FIX_ROUNDTRIP
}

#ifdef FIX_ROUNDTRIP
//
// private member CScrapData::_RunObject
//
HRESULT CScrapData::_RunObject(void)
{
    if (_pdtobjItem) {
        return S_OK;
    }

    if (_fRunObjectAlreadyCalled) {
        DebugMsg(DM_TRACE, TEXT("sc TR CSD::_RunObject returning E_FAIL"));
        return E_FAIL;
    }
    _fRunObjectAlreadyCalled = TRUE;

    HRESULT hres = _OpenStorage();

    DebugMsg(DM_TRACE, TEXT("sc TR CSD::_RunObject _OpenStorage returned %x"), hres);

    if (SUCCEEDED(hres) && _pstgItem)
    {
        LPOLEOBJECT pole;
        hres = OleLoad(_pstgItem, IID_IOleObject, NULL, (LPVOID *)&pole);
        DebugMsg(DM_TRACE, TEXT("sc TR CSD::_RunObject OleLoad returned %x"), hres);
        if (SUCCEEDED(hres))
        {
            DWORD dw=GetCurrentTime();
            hres = OleRun(pole);
            dw = GetCurrentTime()-dw;
            DebugMsg(DM_TRACE, TEXT("sc TR CSD::_RunObject OleRun returned %x (%d msec)"), hres, dw);
            if (SUCCEEDED(hres))
            {
                hres = pole->GetClipboardData(0, &_pdtobjItem);
                DebugMsg(DM_TRACE, TEXT("sc TR CSD::_RunObject GetClipboardData returned %x"), hres);
                if (FAILED(hres))
                {
                    hres = pole->QueryInterface(IID_IDataObject, (LPVOID*)&_pdtobjItem);
                    DebugMsg(DM_TRACE, TEXT("sc TR CSD::_RunObject QI(IID_IDataIbject) returned %x"), hres);
                }
            }
            pole->Release();
        }
    }

    return hres;
}
#endif // FIX_ROUNDTRIP

//===========================================================================
// CScrapData : Member functions (virtual IDataObject)
//===========================================================================
HRESULT CScrapData::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IDataObject) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (LPDATAOBJECT)this;
        _cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtractIcon))
    {
        *ppvObj = (IExtractIcon*)this;
        _cRef++;
        return S_OK;
    }
#ifdef UNICODE
    else if (IsEqualIID(riid, IID_IExtractIconA))
    {
        *ppvObj = (IExtractIconA*)this;
        _cRef++;
        return S_OK;
    }
#endif
    else if (IsEqualIID(riid, IID_IPersistFile))
    {
        *ppvObj = (LPPERSISTFILE)this;
        _cRef++;
        return S_OK;
    }
    *ppvObj = NULL;

    return E_NOINTERFACE;
}

ULONG CScrapData::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CScrapData::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::Release deleting this object"));
    delete this;
    return 0;
}


#ifdef SAVE_OBJECTDESCRIPTOR
HRESULT CScrapData::_GetObjectDescriptor(LPSTGMEDIUM pmedium, BOOL fGetHere)
{
    if (!_pstmObjDesc)
        return DATA_E_FORMATETC;

    LARGE_INTEGER dlib = { 0, 0 };
    HRESULT hres = _pstmObjDesc->Seek(dlib, STREAM_SEEK_SET, NULL);
    if (FAILED(hres))
        return hres;

    OBJECTDESCRIPTOR ods;
    ULONG cbRead;
    hres = _pstmObjDesc->Read(&ods.cbSize, SIZEOF(ods.cbSize), &cbRead);
    if (SUCCEEDED(hres) && cbRead == SIZEOF(ods.cbSize))
    {
        if (fGetHere)
        {
            if (GlobalSize(pmedium->hGlobal)<ods.cbSize) {
                hres = STG_E_MEDIUMFULL;
            }
        }
        else
        {
            pmedium->tymed = TYMED_HGLOBAL;
            pmedium->hGlobal = GlobalAlloc(GMEM_MOVEABLE, ods.cbSize);
            hres = pmedium->hGlobal ? S_OK : E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hres))
        {
            LPOBJECTDESCRIPTOR pods = (LPOBJECTDESCRIPTOR)GlobalLock(pmedium->hGlobal);
            if (pods)
            {
                pods->cbSize = ods.cbSize;
                hres = _pstmObjDesc->Read(&pods->clsid, ods.cbSize-SIZEOF(ods.cbSize), NULL);
                GlobalUnlock(pmedium->hGlobal);
            }
            else
            {
                if (!fGetHere) {
                    GlobalFree(pmedium->hGlobal);
                    pmedium->hGlobal = NULL;
                }
                hres = E_OUTOFMEMORY;
            }
        }
    }

    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::_GetObjectDescriptor returning (%x)"), hres);
    return hres;
}
#endif // SAVE_OBJECTDESCRIPTOR


HRESULT CScrapData::GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
#ifdef DEBUG
    if (pformatetcIn->cfFormat<CF_MAX) {
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetData called with %x,%x,%x"),
                             pformatetcIn->cfFormat, pformatetcIn->tymed, pmedium->tymed);
    } else {
        TCHAR szName[256];
        GetClipboardFormatName(pformatetcIn->cfFormat, szName, ARRAYSIZE(szName));
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetData called with %s,%x,%x"),
                             szName, pformatetcIn->tymed, pmedium->tymed);
    }
#endif

    HRESULT hres;

    pmedium->pUnkForRelease = NULL;
    pmedium->pstg = NULL;

    //
    // NOTES: We should avoid calling _OpenStorage if we don't support
    //  the format.
    //

    //
    //  APP COMPAT!  Win95/NT4's shscrap.dll had a bug in that it checked
    //  the pformatetcIn->tymed's wrong.  The old scrap code accidentally
    //  used an equality test instead of a bit test.  YOU CANNOT FIX THIS
    //  BUG!  Micrografx Designer relies on it!
    //

    if (pformatetcIn->cfFormat == CF_EMBEDDEDOBJECT
        && (pformatetcIn->tymed == TYMED_ISTORAGE) && _fItem) // INTENTIONAL BUG! (see above)
    {
        hres = _OpenStorage();
        if (SUCCEEDED(hres))
        {
            pmedium->tymed = TYMED_ISTORAGE;
            _pstgItem->AddRef();
            pmedium->pstg = _pstgItem;
        }
    }
    else if (pformatetcIn->cfFormat == CF_SCRAPOBJECT
        && (pformatetcIn->tymed == TYMED_ISTORAGE) && _fItem) // INTENTIONAL BUG! (see above)
    {
        hres = _OpenStorage();
        if (SUCCEEDED(hres))
        {
            pmedium->tymed = TYMED_ISTORAGE;
            _pstgDoc->AddRef();
            pmedium->pstg = _pstgDoc;
        }
    }
#ifdef SAVE_OBJECTDESCRIPTOR
    else if (pformatetcIn->cfFormat == CF_OBJECTDESCRIPTOR
        && (pformatetcIn->tymed == TYMED_HGLOBAL) && _fObjDesc) // INTENTIONAL BUG! (see above)
    {
        hres = _OpenStorage();
        if (SUCCEEDED(hres))
        {
            hres = _GetObjectDescriptor(pmedium, FALSE);
        }
    }
#endif // SAVE_OBJECTDESCRIPTOR
    else if (pformatetcIn->cfFormat == CF_TARGETCLSID
        && (pformatetcIn->tymed & TYMED_HGLOBAL) && _fClsidTarget)
    {
        pmedium->hGlobal = GlobalAlloc(GPTR, sizeof(_clsidTarget));
        if (pmedium->hGlobal)
        {
            CopyMemory(pmedium->hGlobal, &_clsidTarget, sizeof(_clsidTarget));
            pmedium->tymed = TYMED_HGLOBAL;
            hres = S_OK;
        }
        else
            hres = E_OUTOFMEMORY;
    }
    else
    {
#ifdef FIX_ROUNDTRIP
        INT iFmt = _GetFormatIndex(pformatetcIn->cfFormat);

        if (iFmt != -1)
        {
            hres = _OpenStorage();
            if (FAILED(hres))
            {
                goto exit;
            }
        }

        if (iFmt>=_icfCacheMax)
        {
            //
            // Delayed Rendered format
            //
            if (SUCCEEDED(_RunObject()))
            {
                hres = _pdtobjItem->GetData(pformatetcIn, pmedium);
                DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetData called _pdtobjItem->GetData %x"), hres);
                return hres;
            }
        }
        else if (iFmt >= 0)
        {
            //
            // Cached Format
            //
            extern void _GetCacheStreamName(LPCTSTR pszFormat, LPWSTR wszStreamName, UINT cchMax);
            TCHAR szFormat[128];
            if (pformatetcIn->cfFormat<CF_MAX) {
                wsprintf(szFormat, TEXT("#%d"), pformatetcIn->cfFormat);
            } else {
                GetClipboardFormatName(pformatetcIn->cfFormat, szFormat, ARRAYSIZE(szFormat));
            }

            WCHAR wszStreamName[256];
            _GetCacheStreamName(szFormat, wszStreamName, ARRAYSIZE(wszStreamName));

            if (pformatetcIn->cfFormat==CF_METAFILEPICT
                || pformatetcIn->cfFormat==CF_ENHMETAFILE
                || pformatetcIn->cfFormat==CF_BITMAP
                || pformatetcIn->cfFormat==CF_PALETTE
                )
            {
                LPSTORAGE pstg;
                hres = _pstgDoc->OpenStorage(wszStreamName, NULL,
                                    STGM_READ | STGM_SHARE_EXCLUSIVE,
                                    NULL, 0, &pstg);
                DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetData OpenStorage returned (%x)"), hres);
                if (SUCCEEDED(hres))
                {
                    LPDATAOBJECT pdtobj;
#if 0
                    hres = OleLoad(pstg, IID_IDataObject, NULL, (LPVOID*)&pdtobj);
                    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetData OleLoad returned (%x)"), hres);
#else
                    const CLSID* pclsid = NULL;
                    switch(pformatetcIn->cfFormat)
                    {
                    case CF_METAFILEPICT:
                        pclsid = &CLSID_Picture_Metafile;
                        break;

                    case CF_ENHMETAFILE:
                        pclsid = &CLSID_Picture_EnhMetafile;
                        break;

                    case CF_PALETTE:
                    case CF_BITMAP:
                        pclsid = &CLSID_Picture_Dib;
                        break;
                    }

                    LPPERSISTSTORAGE ppstg;
                    hres = OleCreateDefaultHandler(*pclsid, NULL, IID_IPersistStorage, (LPVOID *)&ppstg);
                    DebugMsg(DM_TRACE, TEXT("sc TR Scrap_CacheOPF OleCreteDefHandler returned %x"), hres);
                    if (SUCCEEDED(hres))
                    {
                        hres = ppstg->Load(pstg);
                        DebugMsg(DM_TRACE, TEXT("sc TR Scrap_CacheOPF ppstg->Load returned %x"), hres);
                        if (SUCCEEDED(hres))
                        {
                            hres = ppstg->QueryInterface(IID_IDataObject, (LPVOID*)&pdtobj);
                        }
                    }
#endif
                    if (SUCCEEDED(hres))
                    {
                        hres = pdtobj->GetData(pformatetcIn, pmedium);
                        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetData pobj->GetData returned (%x)"), hres);
                        pdtobj->Release();
                    }

                    // Must defer HandsOffStorage until after GetData
                    // or the GetData will fail!  And in fact, even if we defer
                    // it, the GetData *still* fails.  And if we don't call
                    // HandsOffStorage at all, THE GETDATA STILL FAILS.
                    // Bug 314308, OLE regression.
                    // I'm checking in at least this part of the fix so the OLE
                    // folks can debug it on their side.
                    if (ppstg)
                    {
                        ppstg->HandsOffStorage();
                        ppstg->Release();
                    }

                    pstg->Release();
                    return hres;
                }
                // fall through
            }
            else // if (pformatetcIn->cfFormat==CF_...)
            {
                LPSTREAM pstm;
                hres = _pstgDoc->OpenStream(wszStreamName, NULL,
                                        STGM_READ | STGM_SHARE_EXCLUSIVE,
                                        0, &pstm);
                if (SUCCEEDED(hres))
                {
                    UINT cbData;
                    DWORD cbRead;
                    hres = pstm->Read(&cbData, SIZEOF(cbData), &cbRead);
                    if (SUCCEEDED(hres) && cbRead==SIZEOF(cbData))
                    {
                        LPBYTE pData = (LPBYTE)GlobalAlloc(GPTR, cbData);
                        if (pData)
                        {
                            hres = pstm->Read(pData, cbData, &cbRead);
                            if (SUCCEEDED(hres) && cbData==cbRead)
                            {
                                pmedium->tymed = TYMED_HGLOBAL;
                                pmedium->hGlobal = (HGLOBAL)pData;
                            }
                            else
                            {
                                hres = E_UNEXPECTED;
                                GlobalFree((HGLOBAL)pData);
                            }
                        }
                        else
                        {
                            hres = E_OUTOFMEMORY;
                        }
                    }
                    pstm->Release();

                    DebugMsg(DM_TRACE, TEXT("CSD::GetData(%s) returning %x"), szFormat, hres);
                    return hres;
                }
            }
        } // if (iFmt >= 0)
#endif // FIX_ROUNDTRIP
        hres = DATA_E_FORMATETC;
    }

exit:

#ifdef DEBUG
    TCHAR szFormat[256];
    GetClipboardFormatName(pformatetcIn->cfFormat,
                           szFormat, ARRAYSIZE(szFormat));

    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetData called with %x,%x,%s and returning %x"),
                             pformatetcIn->cfFormat,
                             pformatetcIn->tymed,
                             szFormat, hres);
#endif

    return hres;
}

HRESULT CScrapData::GetDataHere(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium )
{
    HRESULT hres;

#ifdef DEBUG
    if (pformatetcIn->cfFormat<CF_MAX) {
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetDataHere called with %x,%x,%x"),
                             pformatetcIn->cfFormat, pformatetcIn->tymed, pmedium->tymed);
    } else {
        TCHAR szName[256];
        GetClipboardFormatName(pformatetcIn->cfFormat, szName, ARRAYSIZE(szName));
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetDataHere called with %s,%x,%x"),
                             szName, pformatetcIn->tymed, pmedium->tymed);
    }
#endif

    hres = _OpenStorage();
    if (FAILED(hres)) {
        return hres;
    }

    if (pformatetcIn->cfFormat == CF_EMBEDDEDOBJECT
        && pformatetcIn->tymed == TYMED_ISTORAGE && pmedium->tymed == TYMED_ISTORAGE)
    {
        hres = _pstgItem->CopyTo(0, NULL, NULL, pmedium->pstg);
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetDataHere _pstgItem->CopyTo returned %x"), hres);
    }
    else if (pformatetcIn->cfFormat == CF_SCRAPOBJECT
        && pformatetcIn->tymed == TYMED_ISTORAGE && pmedium->tymed == TYMED_ISTORAGE)
    {
        hres = _pstgDoc->CopyTo(0, NULL, NULL, pmedium->pstg);
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetDataHere _pstgItem->CopyTo returned %x"), hres);
    }
#ifdef SAVE_OBJECTDESCRIPTOR
    else if ((pformatetcIn->cfFormat == CF_OBJECTDESCRIPTOR)
        && (pformatetcIn->tymed == TYMED_HGLOBAL) && _pstmObjDesc)
    {
        hres = _GetObjectDescriptor(pmedium, TRUE);
    }
#endif // SAVE_OBJECTDESCRIPTOR
    else
    {
#ifdef FIX_ROUNDTRIP
        if (_GetFormatIndex(pformatetcIn->cfFormat) >= 0 && SUCCEEDED(_RunObject()))
        {
            DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetDataHere calling _pdtobjItem->GetDataHere"));
            return _pdtobjItem->GetDataHere(pformatetcIn, pmedium);
        }
#endif // FIX_ROUNDTRIP
        hres = DATA_E_FORMATETC;
    }

    return hres;
}

HRESULT CScrapData::QueryGetData(LPFORMATETC pformatetcIn)
{
    HRESULT hres;
    if (_GetFormatIndex(pformatetcIn->cfFormat) >= 0) {
        hres = S_OK;
    } else {
        hres = DATA_E_FORMATETC;
    }

#ifdef DEBUG
    TCHAR szFormat[256] = TEXT("");
    GetClipboardFormatName(pformatetcIn->cfFormat, szFormat, ARRAYSIZE(szFormat));
    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::QueryGetData(%x,%s,%x) returning %x"),
                    pformatetcIn->cfFormat, szFormat, pformatetcIn->tymed, hres);
#endif

    return hres;
}

HRESULT CScrapData::GetCanonicalFormatEtc(LPFORMATETC pformatetc, LPFORMATETC pformatetcOut)
{
    //
    //  This is the simplest implemtation. It means we always return
    // the data in the format requested.
    //
    return ResultFromScode(DATA_S_SAMEFORMATETC);
}

HRESULT CScrapData::SetData(LPFORMATETC pformatetc, STGMEDIUM  * pmedium, BOOL fRelease)
{
    if (pformatetc->cfFormat == CF_TARGETCLSID && pmedium->tymed == TYMED_HGLOBAL)
    {
        CLSID *pclsid = (CLSID *)GlobalLock(pmedium->hGlobal);
        if (pclsid)
        {
            _clsidTarget = *pclsid;
            _fClsidTarget = TRUE;
            GlobalUnlock(pclsid);
            if (fRelease) {
                ReleaseStgMedium(pmedium);
            }

            /*
             *  Whenever anybody sets a drop target, close our storage handles
             *  so the drop target can move/delete us.  All our methods will
             *  reopen the storage as needed.
             */
            _CloseStorage(FALSE);
            return S_OK;
        }
    }

    return E_FAIL;
}

HRESULT CScrapData::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC * ppenumFormatEtc)
{
    if (dwDirection!=DATADIR_GET) {
        return E_NOTIMPL; // Not supported (as documented)
    }

    if (_ccf==0) {
        return E_UNEXPECTED;
    }

    FORMATETC * pfmt = (FORMATETC*)LocalAlloc(LPTR, SIZEOF(FORMATETC)*_ccf);
    if (!pfmt) {
        return E_OUTOFMEMORY;
    }

    static const FORMATETC s_fmteInit =
    {
          0,
          (DVTARGETDEVICE __RPC_FAR *)NULL,
          DVASPECT_CONTENT,
          -1,
          TYMED_HGLOBAL         // HGLOBAL except CF_EMBEDDEDOBJECT/SCRAPOBJECT
     };

    //
    // Fills FORMATETC for each clipboard format.
    //
    for (INT i=0; i<_ccf; i++)
    {
        pfmt[i] = s_fmteInit;
        pfmt[i].cfFormat = (CLIPFORMAT)_acf[i];

        if (_acf[i]==CF_EMBEDDEDOBJECT || _acf[i]==CF_SCRAPOBJECT) {
            pfmt[i].tymed = TYMED_ISTORAGE;
        } else {
            switch(_acf[i])
            {
            case CF_METAFILEPICT:
                pfmt[i].tymed = TYMED_MFPICT;
                break;

            case CF_ENHMETAFILE:
                pfmt[i].tymed = TYMED_ENHMF;
                break;

            case CF_BITMAP:
            case CF_PALETTE:
                pfmt[i].tymed = TYMED_GDI;
                break;
            }
        }
    }

    HRESULT hres = SHCreateStdEnumFmtEtc(_ccf, pfmt, ppenumFormatEtc);
    LocalFree((HLOCAL)pfmt);

    return hres;
}

HRESULT CScrapData::DAdvise(FORMATETC * pFormatetc, DWORD advf, LPADVISESINK pAdvSink, DWORD * pdwConnection)
{
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

HRESULT CScrapData::DUnadvise(DWORD dwConnection)
{
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

HRESULT CScrapData::EnumDAdvise(LPENUMSTATDATA * ppenumAdvise)
{
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}


//===========================================================================
// CScrapData : Member functions (virtual IPersistFile)
//===========================================================================

HRESULT CScrapData::GetClassID(LPCLSID lpClassID)
{
    *lpClassID = CLSID_CScrapData;
    return S_OK;
}

HRESULT CScrapData::IsDirty(void)
{
    return S_FALSE;     // meaningless (read only)
}

HRESULT CScrapData::Load(LPCOLESTR pwszFile, DWORD grfMode)
{
    //
    // Close all the storage (if there is any) and reset flags.
    //
    _CloseStorage(TRUE);

    //
    // Copy the new file name and open storage to update the flags.
    //
#ifdef UNICODE
    lstrcpyn(_szPath, pwszFile, ARRAYSIZE(_szPath));
#else
    WideCharToMultiByte(CP_ACP, 0, pwszFile, -1, _szPath, ARRAYSIZE(_szPath), NULL, NULL);
#endif
    HRESULT hres = _OpenStorage();
    _FillCFArray();

    //
    // Close all the storage, so that we can move/delete.
    //
    _CloseStorage(FALSE);

    return hres;
}

HRESULT CScrapData::Save(LPCOLESTR pwszFile, BOOL fRemember)
{
    return E_FAIL;      // read only
}

HRESULT CScrapData::SaveCompleted(LPCOLESTR pwszFile)
{
    return S_OK;
}

HRESULT CScrapData::GetCurFile(LPOLESTR *lplpszFileName)
{
    return E_NOTIMPL;   // nobody needs it
}

#ifdef FEATURE_SHELLEXTENSION

HRESULT CScrapData::GetIconLocation(
                         UINT   uFlags, LPTSTR szIconFile,
                         UINT   cchMax, int   * piIndex,
                         UINT  * pwFlags)
{
    HRESULT hres = _OpenStorage();
    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GIL OpenStorage returned %x"), hres);

    if (SUCCEEDED(hres))
    {
	STGMEDIUM medium;
	hres = _GetObjectDescriptor(&medium, FALSE);
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GIL _GetOD returned %x"), hres);
	if (SUCCEEDED(hres))
	{
            LPOBJECTDESCRIPTOR pods = (LPOBJECTDESCRIPTOR)GlobalLock(medium.hGlobal);
	    TCHAR szKey[128];
	    hres = _KeyNameFromCLSID(pods->clsid, szKey, ARRAYSIZE(szKey));
            DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GIL _KNFC returned %x"), hres);
	    if (SUCCEEDED(hres))
	    {
		lstrcatn(szKey, TEXT("\\DefaultIcon"), ARRAYSIZE(szKey));
		TCHAR szValue[MAX_PATH+40];
		LONG dwSize = sizeof(szValue);
		if (RegQueryValue(HKEY_CLASSES_ROOT, szKey, szValue, &dwSize) == ERROR_SUCCESS)
		{
		    *pwFlags = GIL_PERINSTANCE | GIL_NOTFILENAME;
		    *piIndex = _ParseIconLocation(szValue);
		    TCHAR szT[MAX_PATH];
		    wsprintf(szT, TEXT("shscrap.dll,%s"), szValue);
		    lstrcpyn(szIconFile, szT, cchMax);
                    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GIL Found Icon Location %s,%d"), szIconFile, *piIndex);
		    hres = S_OK;
		}
		else
		{
                    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GIL RegQueryValue for CLSID failed (%s)"), szKey);
		    hres = E_FAIL;
		}
	    }
            GlobalUnlock(medium.hGlobal);
	    ReleaseStgMedium(&medium);
	}
    }

    //
    // If Getting CLSID failed, return a generic scrap icon as per-instance
    // icon to avoid re-opening this file again.
    //
    if (FAILED(hres))
    {
	GetModuleFileName(HINST_THISDLL, szIconFile, cchMax);
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GIL Returning default icon (%s)"), szIconFile);
	*piIndex = -IDI_ICON;
	*pwFlags = GIL_PERINSTANCE;
	hres = S_OK;
    }

    return hres;	// This value is always S_OK
}


#ifdef UNICODE
HRESULT CScrapData::GetIconLocation(
                         UINT   uFlags, LPSTR szIconFile,
                         UINT   cchMax, int   * piIndex,
                         UINT  * pwFlags)
{
    WCHAR szPath[MAX_PATH];
    HRESULT hr = GetIconLocation(uFlags, szPath, ARRAYSIZE(szPath), piIndex, pwFlags);
    if (SUCCEEDED(hr)) {
        SHUnicodeToAnsi(szPath, szIconFile, cchMax);
    }
    return hr;
}
#endif
#endif // FEATURE_SHELLEXTENSION

HICON _SimulateScrapIcon(HICON hiconClass, UINT cxIcon)
{
    //
    // First load the template image.
    //
    HICON hiconTemplate = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_SCRAP),
				    IMAGE_ICON, cxIcon, cxIcon, LR_DEFAULTCOLOR);
    if (!hiconTemplate) {
	return NULL;
    }
    ICONINFO ii;
    GetIconInfo(hiconTemplate, &ii);


    HDC hdc = GetDC(NULL);
    HDC hdcMem = CreateCompatibleDC(hdc);
    ReleaseDC(NULL, hdc);

    HBITMAP hbmT = (HBITMAP)SelectObject(hdcMem, ii.hbmColor);

    // This assumes the generic icon is white
    PatBlt(hdcMem, cxIcon/4-1, cxIcon/4-1, cxIcon/2+2, cxIcon/2+2, WHITENESS);
    DrawIconEx(hdcMem, cxIcon/4, cxIcon/4, hiconClass, cxIcon/2, cxIcon/2, 0, NULL, DI_NORMAL);

    SelectObject(hdcMem, hbmT);
    DeleteDC(hdcMem);

    //
    // Create the icon image to return
    //
    ii.fIcon    = TRUE;
    ii.xHotspot = 0;
    ii.yHotspot = 0;
    HICON hicon = CreateIconIndirect(&ii);

    DeleteObject(ii.hbmColor);
    DeleteObject(ii.hbmMask);

    return hicon;
}

#ifdef FEATURE_SHELLEXTENSION

HRESULT CScrapData::Extract(
                           LPCTSTR pszFile, UINT	  nIconIndex,
			   HICON   *phiconLarge, HICON   *phiconSmall,
                           UINT    nIconSize)
{
    LPCTSTR pszComma = StrChr(pszFile, ',');

    if (pszComma++)
    {
#if 1
	HICON hiconSmall;
	UINT i = ExtractIconEx(pszComma, nIconIndex, NULL, &hiconSmall, 1);
	if (i != -1)
	{
	    if (phiconLarge) {
    		*phiconLarge = _SimulateScrapIcon(hiconSmall, LOWORD(nIconSize));
	    }
	    if (phiconSmall) {
    		*phiconSmall = _SimulateScrapIcon(hiconSmall, HIWORD(nIconSize));
	    }

	    DestroyIcon(hiconSmall);
	}
#else
    	UINT i;
	// Assumes shell icon sizes are def icon sizes
	i = ExtractIconEx(pszComma, nIconIndex, phiconLarge, phiconSmall, 1);
	DebugMsg(DM_TRACE, TEXT("sc TR - CSD::Ext ExtractIconEx(%s) returns %d)"), pszComma, i);
	return S_OK;
#endif
    }

    return E_INVALIDARG;
}

#ifdef UNICODE
HRESULT CScrapData::Extract(
                           LPCSTR pszFile, UINT   nIconIndex,
                           HICON   *phiconLarge, HICON   *phiconSmall,
                           UINT    nIconSize)
{
    WCHAR szPath[MAX_PATH];
    SHAnsiToUnicode(pszFile, szPath, ARRAYSIZE(szPath));
    return Extract(szPath, nIconIndex, phiconLarge, phiconSmall, nIconSize);
}
#endif
#endif // FEATURE_SHELLEXTENSION

HRESULT CScrapData_CreateInstance(LPUNKNOWN * ppunk)
{
//
//  This test code is unrelated to the scrap itself. It just verifies that
// CLSID_ShellLink is correctly registered.
//
#ifdef DEBUG
    LPUNKNOWN punk = NULL;
    HRESULT hres = CoCreateInstance(CLSID_ShellLink, NULL,
                    CLSCTX_INPROC, IID_IShellLink, (LPVOID*)&punk);
    DebugMsg(DM_TRACE, TEXT("###############################################"));
    DebugMsg(DM_TRACE, TEXT("CoCreateInstance returned %x"), hres);
    DebugMsg(DM_TRACE, TEXT("###############################################"));
    if (SUCCEEDED(hres)) {
        punk->Release();
    }
#endif

    CScrapData* pscd = new CScrapData();
    if (pscd) {
        *ppunk = (LPDATAOBJECT)pscd;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shscrap\scext.cpp ===
#include "shole.h"
#include "ids.h"

//===========================================================================
// CScrapExt : Class definition
//===========================================================================



class CScrapExt : public IShellExtInit, public IShellPropSheetExt
{
public:
    CScrapExt();
    ~CScrapExt();

    HRESULT GetFileName(LPTSTR pszPath);

    // IUnKnown
    virtual HRESULT __stdcall QueryInterface(REFIID,void **);
    virtual ULONG   __stdcall AddRef(void);
    virtual ULONG   __stdcall Release(void);

    // IShellExtInit
    virtual HRESULT __stdcall Initialize(LPCITEMIDLIST pidlFolder,
		          LPDATAOBJECT lpdobj, HKEY hkeyProgID);

    // IShellPropSheetExt
    virtual HRESULT __stdcall AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    virtual HRESULT __stdcall ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);


protected:
    UINT         _cRef;
    IDataObject* _pdtobj;
};

HRESULT CScrapExt::GetFileName(LPTSTR pszPath)
{
    STGMEDIUM medium;
    FORMATETC fmte = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hres = E_FAIL;
    if (_pdtobj)
    {
	hres = _pdtobj->GetData(&fmte, &medium);
	if (hres == S_OK)
	{
	    if (!DragQueryFile((HDROP)medium.hGlobal,0,pszPath,MAX_PATH))
		hres = E_FAIL;
	    ReleaseStgMedium(&medium);
	}
    }
    return hres;
}

HRESULT CScrapExt::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IShellExtInit) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IShellExtInit*)this;
        _cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IShellPropSheetExt))
    {
        *ppvObj = (IShellPropSheetExt *)this;
        _cRef++;
        return S_OK;
    }
    *ppvObj = NULL;

    return E_NOINTERFACE;
}

ULONG CScrapExt::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CScrapExt::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

CScrapExt::CScrapExt() : _cRef(1), _pdtobj(NULL)
{
    g_cRefThisDll++;
    OleInitialize(NULL);
}

CScrapExt::~CScrapExt()
{
    if (_pdtobj) {
	_pdtobj->Release();
    }

    OleUninitialize();
    g_cRefThisDll--;
}

HRESULT CScrapExt::Initialize(LPCITEMIDLIST pidlFolder,
              LPDATAOBJECT pdtobj, HKEY hkeyProgID)
{
    DebugMsg(DM_TRACE, TEXT("sc TR - CScrapExt::Initialize called"));

    if (pdtobj) {
	_pdtobj = pdtobj;
	pdtobj->AddRef();
	return S_OK;
    }
    return E_FAIL;
}

//===========================================================================
// CScrapPropSheetPage: Class definition
//
// Notes: Notice that this class has no destructor. It has no destructor
//  because the lifetime of the object itself does not mean anything
//  -- full contents will be copied by the property sheet code.
//  Instead, it has a _Release function which is explicitly called
//  when the property sheet handle is destroyed.
//===========================================================================

class CScrapPropSheetPage : public PROPSHEETPAGE // spsp
{
public:
    CScrapPropSheetPage(CScrapExt* psext);
protected:
    static INT_PTR CALLBACK _DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static UINT CALLBACK _CallBack(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
    void _Release();

    CScrapExt*      _psext;
    HWND            _hdlg;
    IOleClientSite* _pcli;
};


CScrapPropSheetPage::CScrapPropSheetPage(CScrapExt* psext)
		: _psext(psext), _hdlg(NULL), _pcli(NULL)
{
    dwSize = sizeof(CScrapPropSheetPage);
    dwFlags = PSP_DEFAULT|PSP_USECALLBACK;
    hInstance = HINST_THISDLL;
    pszTemplate = MAKEINTRESOURCE(IDD_VIEW);
    // hIcon = NULL; // unused (PSP_USEICON is not set)
    // pszTitle = NULL; // unused (PSP_USETITLE is not set)
    pfnDlgProc = _DlgProc;
    // lParam   = 0;     // unused
    pfnCallback = _CallBack;
    // pcRefParent = NULL;
    _psext->AddRef();
    CShClientSite_RegisterClass();
}

void CScrapPropSheetPage::_Release()
{
    if (_psext) {
	_psext->Release();
    }

    if (_pcli) {
	CShClientSite_Release(_pcli);
    }
};
INT_PTR CALLBACK CScrapPropSheetPage::_DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hwndView;
    CScrapPropSheetPage* pspsp;
    switch(uMsg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hdlg, DWLP_USER, lParam);
        pspsp = (CScrapPropSheetPage *)lParam;
        pspsp->_hdlg = hdlg;
	hwndView = GetDlgItem(hdlg, IDI_SCRAPVIEW);
	if (hwndView) {
	    SetWindowText(hwndView, TEXT("Not Implemented Yet"));
	    // SetWindowLongPtr(hwndView, sizeof(LPVOID), (LPARAM)pspsp);
	    TCHAR szPath[MAX_PATH];
	    if (SUCCEEDED(pspsp->_psext->GetFileName(szPath)))
	    {
		pspsp->_pcli = CShClientSite_Create(hwndView, szPath);
	    }
	}
	break;
    }
    return FALSE;
}

UINT CALLBACK CScrapPropSheetPage::_CallBack(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    CScrapPropSheetPage * pspsp = (CScrapPropSheetPage*)ppsp;
    switch(uMsg)
    {
    case PSPCB_RELEASE:
	DebugMsg(DM_TRACE, TEXT("sc - TR: _ScrapPageCallBack is releasing _psext"));
	pspsp->_Release();
	break;
    }
    return TRUE;
}


HRESULT CScrapExt::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    DebugMsg(DM_TRACE, TEXT("sc TR - CScrapExt::AddPage called"));

    HPROPSHEETPAGE hpage;
    HRESULT hres = S_OK;
    CScrapPropSheetPage spsp(this);

    hpage = CreatePropertySheetPage(&spsp);
    if (hpage)
    {
	BOOL bResult = lpfnAddPage(hpage, lParam);
	if (!bResult)
	{
	   DestroyPropertySheetPage(hpage);
	   hres = E_FAIL;
	}
    }

    return hres;
}

HRESULT CScrapExt::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
    return S_FALSE;
}

HRESULT CScrapExt_CreateInstance(LPUNKNOWN * ppunk)
{
    DebugMsg(DM_TRACE, TEXT("sc TR - CScrapExt_CreateInstance called"));

    CScrapExt* pscd = new CScrapExt();
    if (pscd) {
        *ppunk = (LPDATAOBJECT)pscd;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shscrap\sources.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

USE_NT_PRODUCT_VER=1

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

C_DEFINES = $(C_DEFINES) -DNOWINRES

TARGETNAME      = shscrap
TARGETPATH      = obj
TARGETTYPE      = DYNLINK

#VERIFY_LC       = 1
LC_PATH         = $(PROJECT_ROOT)\lcinf

TARGETLIBS      = $(SDK_LIB_PATH)\kernel32.lib      \
                  $(WINDOWS_LIB_PATH)\gdi32p.lib    \
                  $(WINDOWS_LIB_PATH)\user32p.lib   \
                  $(SDK_LIB_PATH)\advapi32.lib      \
                  $(SHELL_LIB_PATH)\shlwapip.lib    \
                  $(SDK_LIB_PATH)\comdlg32.lib      \
                  $(SHELL_LIB_PATH)\comctlp.lib     \
                  $(SDK_LIB_PATH)\mpr.lib           \
                  $(SHELL_LIB_PATH)\shell32p.lib    \
                  $(SDK_LIB_PATH)\ole32.lib         \
                  $(SDK_LIB_PATH)\uuid.lib          \
!if defined(TARGET_WIN95)
                  $(CCSHELL_DIR)\lib\$O\stock4.lib
!else
                  $(CCSHELL_DIR)\lib\$O\stock.lib
!endif

DLLENTRY        = LibMain
DLLDEF          = ..\shole.def

USE_MSVCRT      = 1

SOURCES         = \
                  ..\shole.rc     \
                  ..\debug.c      \
                  ..\sccls.cpp    \
                  ..\sccreate.cpp \
                  ..\scdata.cpp   \
                  ..\shole.cpp    \
                  ..\scext.cpp    \
                  ..\template.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shscrap\template.cpp ===
#include "shole.h"
#include "ids.h"
#include "scguid.h"

#ifdef FEATURE_SHELLEXTENSION

extern "C" const TCHAR c_szCLSID[];

class CTemplateFolder : public IShellFolder, public IPersistFolder
{
public:
    CTemplateFolder();
    ~CTemplateFolder();
    inline BOOL ConstructedSuccessfully() { return _hdpaMap != NULL; }

    // IUnKnown
    virtual HRESULT __stdcall QueryInterface(REFIID,void **);
    virtual ULONG   __stdcall AddRef(void);
    virtual ULONG   __stdcall Release(void);

    // IShellFolder
    virtual HRESULT __stdcall ParseDisplayName(HWND hwndOwner,
        LPBC pbcReserved, LPOLESTR lpszDisplayName,
        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);

    virtual HRESULT __stdcall EnumObjects( THIS_ HWND hwndOwner, DWORD grfFlags, LPENUMIDLIST * ppenumIDList);

    virtual HRESULT __stdcall BindToObject(LPCITEMIDLIST pidl, LPBC pbcReserved,
                                 REFIID riid, LPVOID * ppvOut);
    virtual HRESULT __stdcall BindToStorage(LPCITEMIDLIST pidl, LPBC pbcReserved,
                                 REFIID riid, LPVOID * ppvObj);
    virtual HRESULT __stdcall CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual HRESULT __stdcall CreateViewObject (HWND hwndOwner, REFIID riid, LPVOID * ppvOut);
    virtual HRESULT __stdcall GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl,
                                    ULONG * rgfInOut);
    virtual HRESULT __stdcall GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, LPVOID * ppvOut);
    virtual HRESULT __stdcall GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    virtual HRESULT __stdcall SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl,
                                 LPCOLESTR lpszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut);

    // IPersistFolder
    virtual HRESULT __stdcall GetClassID(LPCLSID lpClassID);
    virtual HRESULT __stdcall Initialize(LPCITEMIDLIST pidl);

protected:
    // Defview callback
    friend HRESULT CALLBACK DefViewCallback(
                                LPSHELLVIEW psvOuter, LPSHELLFOLDER psf,
                                HWND hwndOwner, UINT uMsg,
                                WPARAM wParam, LPARAM lParam);
    HRESULT GetDetailsOfDVM(UINT ici, DETAILSINFO *pdi);

    BOOL IsMyPidl(LPCITEMIDLIST pidl)
	{ return (pidl->mkid.abID[0] == 'S' && pidl->mkid.abID[1] == 'N'); }

    UINT _cRef;

    //
    //  To speed up name lookups, we cache the mapping between CLSIDs and
    //  display names.  We cannot persist this mapping because it won't
    //  survive localization or ANSI/UNICODE interop.
    //
    typedef struct {
        CLSID clsid;
        TCHAR achName[MAX_PATH];
    } CLSIDMAP, *PCLSIDMAP;

    HDPA _hdpaMap;

    HRESULT GetNameOf(LPCITEMIDLIST pidl, LPCTSTR *ppsz);
};

class CEnumTemplate : public IEnumIDList
{
public:
    CEnumTemplate(DWORD grfFlags);
    ~CEnumTemplate();

protected:
    // IUnKnown
    virtual HRESULT __stdcall QueryInterface(REFIID,void **);
    virtual ULONG   __stdcall AddRef(void);
    virtual ULONG   __stdcall Release(void);

    virtual HRESULT __stdcall Next(ULONG celt,
                      LPITEMIDLIST *rgelt,
                      ULONG *pceltFetched);
    virtual HRESULT __stdcall Skip(ULONG celt);
    virtual HRESULT __stdcall Reset();
    virtual HRESULT __stdcall Clone(IEnumIDList **ppenum);

    UINT	_cRef;
    const DWORD	_grfFlags;
    UINT	_iCur;
    HKEY	_hkeyCLSID;
};

//
//  For Win95/NT interop, our PIDLs are always UNICODE.
//  Use explicit packing for Win32/64 interop.
#include <pshpack1.h>
typedef struct _TIDL {
    USHORT          cb;             // This matches SHITEMID
    BYTE            abID[2];        // This matches SHITEMID
    CLSID	    clsid;
} TIDL;
typedef const UNALIGNED TIDL *PTIDL;

//
//  This is the TIDL constructor -- it has the cbZero at the end.
//
typedef struct _TIDLCONS {
    TIDL            tidl;
    USHORT          cbZero;
} TIDLCONS;

#include <poppack.h>

class CTemplateUIObj : public IExtractIcon, public IDataObject, public IContextMenu
{
public:
    static HRESULT Create(REFCLSID, REFIID, LPVOID*);
protected:
    CTemplateUIObj(REFCLSID rclsid)
                    : _clsid(rclsid), _cRef(1)
                                { DllAddRef(); }
    ~CTemplateUIObj()           { DllRelease(); }
    HRESULT _CreateInstance(IStorage* pstg);

    // IUnKnown
    virtual HRESULT __stdcall QueryInterface(REFIID,void **);
    virtual ULONG   __stdcall AddRef(void);
    virtual ULONG   __stdcall Release(void);

    // *** IExtractIcon methods ***
    virtual HRESULT __stdcall GetIconLocation(
                         UINT   uFlags, LPTSTR  szIconFile,
                         UINT   cchMax, int   * piIndex,
                         UINT  * pwFlags);

    virtual HRESULT __stdcall Extract(
                           LPCTSTR pszFile, UINT          nIconIndex,
                           HICON   *phiconLarge, HICON   *phiconSmall,
                           UINT    nIconSize);

    // IDataObject
    virtual HRESULT __stdcall GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
    virtual HRESULT __stdcall GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium);
    virtual HRESULT __stdcall QueryGetData(FORMATETC *pformatetc);
    virtual HRESULT __stdcall GetCanonicalFormatEtc(FORMATETC *pformatectIn, FORMATETC *pformatetcOut);
    virtual HRESULT __stdcall SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease);
    virtual HRESULT __stdcall EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc);
    virtual HRESULT __stdcall DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection);
    virtual HRESULT __stdcall DUnadvise(DWORD dwConnection);
    virtual HRESULT __stdcall EnumDAdvise(IEnumSTATDATA **ppenumAdvise);

    // IContextMenu
    virtual HRESULT __stdcall QueryContextMenu(
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags);

    virtual HRESULT __stdcall InvokeCommand(
                             LPCMINVOKECOMMANDINFO lpici);

    virtual HRESULT __stdcall GetCommandString(
                                UINT        idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax);

    UINT	_cRef;
    CLSID	_clsid;
};


CTemplateFolder::CTemplateFolder() : _cRef(1)
{
    _hdpaMap = DPA_Create(10);
    OleInitialize(NULL);
    DllAddRef();
}

CTemplateFolder::~CTemplateFolder()
{
    if (_hdpaMap) {
        for (int i = DPA_GetPtrCount(_hdpaMap) - 1; i >= 0; i--) {
            PCLSIDMAP pmap = (PCLSIDMAP)DPA_FastGetPtr(_hdpaMap, i);
            LocalFree(pmap);
        }
        DPA_Destroy(_hdpaMap);
    }

    OleUninitialize();
    DllRelease();
}

HRESULT CTemplateFolder::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IShellFolder) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IShellFolder*)this;
        _cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IPersistFolder))
    {
        *ppvObj = (IPersistFolder*)this;
        _cRef++;
        return S_OK;
    }
    *ppvObj = NULL;

    return E_NOINTERFACE;
}

ULONG CTemplateFolder::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CTemplateFolder::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CTemplateFolder_CreateInstance(LPUNKNOWN * ppunk)
{
    *ppunk = NULL;

    CTemplateFolder* ptfld = new CTemplateFolder();
    if (ptfld) {
        if (ptfld->ConstructedSuccessfully()) {
            *ppunk = (IShellFolder *)ptfld;
            return S_OK;
        }
        ptfld->Release();
    }
    return E_OUTOFMEMORY;
}

HRESULT CTemplateFolder::ParseDisplayName(HWND hwndOwner,
        LPBC pbcReserved, LPOLESTR lpszDisplayName,
        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes)
{
    return E_NOTIMPL;
}

HRESULT CTemplateFolder::EnumObjects(HWND hwndOwner, DWORD grfFlags, LPENUMIDLIST * ppenumIDList)
{
    *ppenumIDList = new CEnumTemplate(grfFlags);
    return *ppenumIDList ? S_OK : E_OUTOFMEMORY;
}

HRESULT CTemplateFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbcReserved,
                                 REFIID riid, LPVOID * ppvOut)
{
    return E_NOTIMPL;
}

HRESULT CTemplateFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbcReserved,
                                 REFIID riid, LPVOID * ppvObj)
{
    return E_NOTIMPL;
}

//
//  If the name is in the cache, celebrate our good fortune and return it.
//  Else, go get the name from the registry and cache it for later.
//
HRESULT CTemplateFolder::GetNameOf(LPCITEMIDLIST pidl, LPCTSTR *ppsz)
{
    if (!IsMyPidl(pidl))
        return E_INVALIDARG;

    HRESULT hres;
    PTIDL ptidl = (PTIDL)pidl;
    CLSIDMAP map;
    map.clsid = ptidl->clsid;           // Align the CLSID
    PCLSIDMAP pmap;
    for (int i = DPA_GetPtrCount(_hdpaMap) - 1; i >= 0; i--) {
        pmap = (PCLSIDMAP)DPA_FastGetPtr(_hdpaMap, i);
        if (IsEqualGUID(pmap->clsid, map.clsid)) {
            *ppsz = pmap->achName;
            return S_OK;
        }
    }

    //
    //  Not in cache -- go find it in the registry
    //
    TCHAR szKey[GUIDSTR_MAX + 6];
    _KeyNameFromCLSID(map.clsid, szKey, ARRAYSIZE(szKey));
    LONG dwSize = ARRAYSIZE(map.achName);
    LONG lError = RegQueryValue(HKEY_CLASSES_ROOT, szKey, map.achName, &dwSize);
    if (lError == ERROR_SUCCESS)
    {
        UINT cb = FIELD_OFFSET(CLSIDMAP, achName[lstrlen(map.achName)+1]);
        pmap = (PCLSIDMAP)LocalAlloc(LMEM_FIXED, cb);
        if (pmap) {
            CopyMemory(pmap, &map, cb);
            if (DPA_AppendPtr(_hdpaMap, pmap) >= 0) {
                *ppsz = pmap->achName;
                hres = S_OK;
            } else {
                LocalFree(pmap);
                hres = E_OUTOFMEMORY;
            }
        } else {
            hres = E_OUTOFMEMORY;
        }
    }
    else
    {
        hres = HRESULT_FROM_WIN32(lError);
    }

    return hres;

}

HRESULT CTemplateFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPCTSTR psz1, psz2;
    HRESULT hres;

    hres = GetNameOf(pidl1, &psz1);
    if (SUCCEEDED(hres)) {
        hres = GetNameOf(pidl2, &psz2);
        if (SUCCEEDED(hres)) {
            hres = ResultFromShort(lstrcmpi(psz1, psz2));
        }
    }
    return hres;
}


HRESULT CTemplateFolder::GetDetailsOfDVM(UINT ici, DETAILSINFO *pdi)
{
    HRESULT hres;

    switch (ici) {
    case 0:
        if (pdi->pidl) {
            hres = GetDisplayNameOf(pdi->pidl, SHGDN_NORMAL, &pdi->str);
        } else {
            pdi->fmt = LVCFMT_LEFT;
            pdi->cxChar = 30;
            pdi->str.uType = STRRET_CSTR;
            lstrcpyA(pdi->str.cStr, "Name"); 
            hres = S_OK;
        }
        break;

    default:
        hres = E_NOTIMPL;
        break;
    }
    return hres;
}

HRESULT CALLBACK DefViewCallback(LPSHELLVIEW psvOuter, LPSHELLFOLDER psf,
                                HWND hwndOwner, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // DefView GPF if I don't pass the callback function!
    // DebugMsg(DM_TRACE, "sc TR - DefViewCallBack %d,%x,%x", uMsg, wParam, lParam);
    switch(uMsg)
    {
    case DVM_WINDOWDESTROY:
	DebugMsg(DM_TRACE, TEXT("sc TR - DefViewCallBack Calling OleFlushClipboard"));
	OleFlushClipboard();
	return S_OK;
    case DVM_GETDETAILSOF:
        return ((CTemplateFolder*)psf)->GetDetailsOfDVM((UINT)wParam, (DETAILSINFO*)lParam);
    }
    // DefView GPF if it returns S_FALSE as the default!
    return E_FAIL; // S_FALSE;
}


HRESULT CTemplateFolder::CreateViewObject (HWND hwndOwner, REFIID riid, LPVOID * ppvOut)
{
    if (IsEqualIID(riid, IID_IShellView))
    {
        CSFV csfv = {
            SIZEOF(CSFV),       // cbSize
            this,               // pshf
            NULL,               // psvOuter
            NULL,               // pidl
            0,
            DefViewCallback,    // pfnCallback
            FVM_ICON,
        };
        return SHCreateShellFolderViewEx(&csfv, (LPSHELLVIEW *)ppvOut);
    }
    return E_NOINTERFACE;
}

HRESULT CTemplateFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl,
                                    ULONG * rgfInOut)
{
    if (cidl==1)
    {
	UINT rgfOut = SFGAO_CANCOPY /* | SFGAO_HASPROPSHEET */;
	*rgfInOut &= rgfOut;
    }
    else
    {
	*rgfInOut = 0;
    }
    return S_OK;
}

HRESULT CTemplateFolder::GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, LPVOID * ppvOut)
{
    HRESULT hres = E_INVALIDARG;
    if (cidl==1 && IsMyPidl(apidl[0]))
    {
	PTIDL ptidl = (PTIDL)apidl[0];
	hres = CTemplateUIObj::Create(ptidl->clsid, riid, ppvOut);
    }

    return hres;
}

HRESULT _KeyNameFromCLSID(REFCLSID rclsid, LPTSTR pszKey, UINT cchMax)
{
    ASSERT(cchMax - 6 >= GUIDSTR_MAX);
    lstrcpyn(pszKey, TEXT("CLSID\\"), cchMax);
    SHStringFromGUID(rclsid, pszKey + 6, cchMax - 6);
    return S_OK;
}

HRESULT CTemplateFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName)
{
    LPCTSTR psz;
    HRESULT hres;

    hres = GetNameOf(pidl, &psz);
    if (SUCCEEDED(hres)) {
#ifdef UNICODE
        lpName->uType = STRRET_WSTR;
        hres = SHStrDupW(psz, &lpName->pOleStr);
#else
        lstrcpyn(lpName->cStr, psz, ARRAYSIZE(lpName->cStr));
        hres = S_OK;
#endif
    }
    return hres;
}

HRESULT CTemplateFolder::SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl,
                                 LPCOLESTR lpszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut)
{
    return E_NOTIMPL;
}

HRESULT __stdcall CTemplateFolder::GetClassID(LPCLSID lpClassID)
{
    *lpClassID = CLSID_CTemplateFolder;
    return S_OK;
}

HRESULT __stdcall CTemplateFolder::Initialize(LPCITEMIDLIST pidl)
{
    return S_OK;
}

CEnumTemplate::CEnumTemplate(DWORD grfFlags)
    : _cRef(1), _grfFlags(grfFlags), _iCur(0), _hkeyCLSID(NULL)
{
    DllAddRef();
}

CEnumTemplate::~CEnumTemplate()
{
    if (_hkeyCLSID) {
        RegCloseKey(_hkeyCLSID);
    }
    DllRelease();
}

HRESULT CEnumTemplate::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IEnumIDList) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IEnumIDList*)this;
        _cRef++;
        return S_OK;
    }
    *ppvObj = NULL;

    return E_NOINTERFACE;
}

ULONG CEnumTemplate::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CEnumTemplate::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CEnumTemplate::Next(ULONG celt,
                      LPITEMIDLIST *rgelt,
                      ULONG *pceltFetched)
{
    // Assume error
    if (pceltFetched) {
        *pceltFetched = 0;
    }

    if (!(_grfFlags & SHCONTF_NONFOLDERS)) {
	return S_FALSE;
    }

    if (!_hkeyCLSID)
    {
        if (RegOpenKey(HKEY_CLASSES_ROOT, c_szCLSID, &_hkeyCLSID) != ERROR_SUCCESS)
        {
            return E_FAIL;
        }
    }

    TCHAR szKeyBuf[128];    // enough for {CLSID} or "ProgId/XXX"

    //  Subtract 64 to allow room for the goo we append later on
    while (RegEnumKey(HKEY_CLASSES_ROOT, _iCur++, szKeyBuf, ARRAYSIZE(szKeyBuf) - 64) == ERROR_SUCCESS)
    {
	TCHAR szT[128];
	LONG dwRead;
	int cchKey = lstrlen(szKeyBuf);

	// Check for \NotInsertable.
	lstrcpy(szKeyBuf+cchKey, TEXT("\\NotInsertable"));
	dwRead = ARRAYSIZE(szT);
	if (RegQueryValue(HKEY_CLASSES_ROOT, szKeyBuf, szT, &dwRead) == ERROR_SUCCESS) {
	    continue;
	}

	BOOL fInsertable = FALSE;
//
// Let's stop supporting OLE1 servers anymore.
//
#if 0
	lstrcpy(szKeyBuf+cchKey, TEXT("\\protocol\\StdFileEditing\\server"));
	dwRead = ARRAYSIZE(szT);
	if (RegQueryValue(HKEY_CLASSES_ROOT, szKeyBuf, szT, &dwRead) == ERROR_SUCCESS)
	{
	    fInsertable = TRUE;
	}
	else
#endif
	{
	    lstrcpy(szKeyBuf+cchKey, TEXT("\\Insertable"));
	    dwRead = ARRAYSIZE(szT);
	    if (RegQueryValue(HKEY_CLASSES_ROOT, szKeyBuf, szT, &dwRead) == ERROR_SUCCESS)
	    {
		fInsertable = TRUE;
	    }
	}

	if (fInsertable)
	{
	    lstrcpy(szKeyBuf+cchKey, TEXT("\\CLSID"));
	    dwRead = ARRAYSIZE(szT);
	    if (RegQueryValue(HKEY_CLASSES_ROOT, szKeyBuf, szT, &dwRead) == ERROR_SUCCESS)
	    {
		TIDLCONS tidlCons;
                CLSID clsid;            // Aligned version
		tidlCons.tidl.cb = sizeof(TIDL);
		tidlCons.tidl.abID[0] = 'S';
		tidlCons.tidl.abID[1] = 'N';

		if (GUIDFromString(szT, &clsid))
		{
                    tidlCons.tidl.clsid = clsid;
                    tidlCons.cbZero = 0;
		    rgelt[0] = ILClone((LPITEMIDLIST)&tidlCons);
		    *pceltFetched = 1;
		    return S_OK;
		}
	    }
	}
    }

    return S_FALSE;     // no more element
}

HRESULT CEnumTemplate::Skip(ULONG celt)
{
    return E_NOTIMPL;
}

HRESULT CEnumTemplate::Reset()
{
    return E_NOTIMPL;
}

HRESULT CEnumTemplate::Clone(IEnumIDList **ppenum)
{
    return E_NOTIMPL;
}


//==========================================================================
// CTemplateUIObj members (IUnknown override)
//==========================================================================

HRESULT CTemplateUIObj::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IExtractIcon) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IExtractIcon*)this;
        _cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IDataObject))
    {
        *ppvObj = (IDataObject*)this;
        _cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        *ppvObj = (IContextMenu*)this;
        _cRef++;
        return S_OK;
    }
    *ppvObj = NULL;

    return E_NOINTERFACE;
}

ULONG CTemplateUIObj::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CTemplateUIObj::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

//
// NOTES: This logic MUST be identical to the one in the shell.
//
int _ParseIconLocation(LPTSTR pszIconFile)
{
    int iIndex = 0;
    LPTSTR pszComma = StrChr(pszIconFile, TEXT(','));

    if (pszComma) {
        *pszComma++ = 0;            // terminate the icon file name.
        iIndex = StrToInt(pszComma);
    }
    PathRemoveBlanks(pszIconFile);
    return iIndex;
}


//==========================================================================
// CTemplateUIObj members (IExtractIcon override)
//==========================================================================

//
// szClass -- Specifies either CLSID\{CLSID} or ProgID
//
HRESULT _GetDefaultIcon(LPCTSTR szClass, LPTSTR szIconFile, UINT cchMax, int *piIndex)
{
    TCHAR szKey[256];
    wsprintf(szKey, TEXT("%s\\DefaultIcon"), szClass);
    TCHAR szValue[MAX_PATH+40];
    LONG dwSize = ARRAYSIZE(szValue);
    if (RegQueryValue(HKEY_CLASSES_ROOT, szKey, szValue, &dwSize) == ERROR_SUCCESS)
    {
	*piIndex = _ParseIconLocation(szValue);
	lstrcpyn(szIconFile, szValue, cchMax);
	return S_OK;
    }
    return E_FAIL;
}

HRESULT CTemplateUIObj::GetIconLocation(
                         UINT   uFlags, LPTSTR  szIconFile,
                         UINT   cchMax, int   * piIndex,
                         UINT  * pwFlags)
{
    *pwFlags = GIL_PERCLASS;	// Always per-class

    TCHAR szKey[128];
    HRESULT hres = _KeyNameFromCLSID(_clsid, szKey, ARRAYSIZE(szKey));
    if (SUCCEEDED(hres))
    {
	//
	// First, look at "CLSID\{CLSID}\DefautlIcon"
	//
	hres = _GetDefaultIcon(szKey, szIconFile, cchMax, piIndex);
	if (FAILED(hres))
	{
	    //
	    // Then, look at "ProgID\DefaultIcon" to work-around a bug
	    //  of "Wave Sound".
	    //
    	    lstrcat(szKey, TEXT("\\ProgID"));
	    TCHAR szValue[MAX_PATH+40];
	    LONG dwSize = ARRAYSIZE(szValue);
	    if (RegQueryValue(HKEY_CLASSES_ROOT, szKey, szValue, &dwSize) == ERROR_SUCCESS)
	    {
		hres = _GetDefaultIcon(szValue, szIconFile, cchMax, piIndex);
	    }
	}
    }
    return hres;
}

HRESULT CTemplateUIObj::Extract(
                           LPCTSTR pszFile, UINT          nIconIndex,
                           HICON   *phiconLarge, HICON   *phiconSmall,
                           UINT    nIconSize)
{
    return S_FALSE;
}

HRESULT CTemplateUIObj::Create(REFCLSID rclsid, REFIID riid, LPVOID* ppvOut)
{
    CTemplateUIObj *pti = new CTemplateUIObj(rclsid);
    HRESULT hres;
    if (pti) {
        hres = pti->QueryInterface(riid, ppvOut);
        pti->Release();
        return hres;
    }

    *ppvOut=NULL;
    return E_OUTOFMEMORY;
}

//==========================================================================
// CTemplateUIObj members (IDataObject override)
//==========================================================================

HRESULT CTemplateUIObj::_CreateInstance(IStorage* pstg)
{
    HRESULT hres;
    IPersistStorage* pps = NULL;
    hres = OleCreate(_clsid, IID_IPersistStorage, OLERENDER_DRAW,
                     NULL, NULL, pstg, (LPVOID*)&pps);
    DebugMsg(DM_TRACE, TEXT("so TR - TUO:CI OleCreate returned (%x)"), hres);

    if (SUCCEEDED(hres))
    {
        hres = OleSave(pps, pstg, TRUE);
        DebugMsg(DM_TRACE, TEXT("so TR - TUO:CI OleSave returned (%x)"), hres);
        pps->HandsOffStorage();
        pps->Release();

        if (SUCCEEDED(hres))
        {
            hres = pstg->Commit(STGC_OVERWRITE);
            DebugMsg(DM_TRACE, TEXT("so TR - TUO:CI pstg->Commit returned (%x)"), hres);
        }
    }

    return hres;
}

HRESULT CTemplateUIObj::GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
    HRESULT hres = DATA_E_FORMATETC;

    pmedium->pUnkForRelease = NULL;
    pmedium->pstg = NULL;

    //
    // NOTES: We should avoid calling _OpenStorage if we don't support
    //  the format.
    //

    if (pformatetcIn->cfFormat == CF_EMBEDDEDOBJECT
        && pformatetcIn->tymed == TYMED_ISTORAGE)
    {
        IStorage* pstg = NULL;
        hres = StgCreateDocfile(NULL, STGM_DIRECT | STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &pstg);
        DebugMsg(DM_TRACE, TEXT("so TR - TUO:GD StgCreateDocfile returned (%x)"), hres);
        if (SUCCEEDED(hres))
        {
            hres = _CreateInstance(pstg);
            if (SUCCEEDED(hres)) {
                pmedium->tymed = TYMED_ISTORAGE;
                pmedium->pstg = pstg;
            } else {
                pstg->Release();
            }
        }
    }
    else if (pformatetcIn->cfFormat == CF_OBJECTDESCRIPTOR
	&& pformatetcIn->tymed == TYMED_HGLOBAL)
    {
	DebugMsg(DM_TRACE, TEXT("so TR - TUO:GD cfFormat==CF_OBJECTDESCRIPTOR"));

	static WCHAR szUserTypeName[] = L"Foo";	// REARCHITECT: this code is really miss, and might end up returning Foo
	static WCHAR szSrcOfCopy[] = L"Bar";
	UINT cbUserTypeName = sizeof(szUserTypeName);
	UINT cbSrcOfCopy = sizeof(szSrcOfCopy);
	pmedium->hGlobal = GlobalAlloc(GPTR, sizeof(OBJECTDESCRIPTOR)+cbUserTypeName+cbSrcOfCopy);
	if (pmedium->hGlobal)
	{
	    OBJECTDESCRIPTOR* podsc = (OBJECTDESCRIPTOR*)pmedium->hGlobal;
	    podsc->cbSize = sizeof(OBJECTDESCRIPTOR);
	    podsc->clsid = _clsid;
	    podsc->dwDrawAspect = 0; // The source does not draw the object
	    // podsc->sizel = { 0, 0 }; // The source does not draw the object
	    // podsc->pointl = { 0, 0 };
	    podsc->dwStatus = 0; // FEATURE: read it from registry! CLSID/MiscStatus
	    podsc->dwFullUserTypeName = sizeof(OBJECTDESCRIPTOR);
	    podsc->dwSrcOfCopy = sizeof(OBJECTDESCRIPTOR)+cbUserTypeName;
	    LPBYTE pbT = (LPBYTE)(podsc+1);
            lstrcpyW((LPWSTR)pbT, szUserTypeName);
            lstrcpyW((LPWSTR)(pbT+cbUserTypeName), szSrcOfCopy);
	    Assert(pbT == ((LPBYTE)podsc)+podsc->dwFullUserTypeName);
	    Assert(pbT+cbUserTypeName == ((LPBYTE)podsc)+podsc->dwSrcOfCopy);

	    pmedium->tymed = TYMED_HGLOBAL;
	    hres = S_OK;
	}
	else
	{
	    hres = E_OUTOFMEMORY;
	}
    }
    return hres;
}

HRESULT CTemplateUIObj::GetDataHere(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
    HRESULT hres = DATA_E_FORMATETC;

    if (pformatetcIn->cfFormat == CF_EMBEDDEDOBJECT
        && pformatetcIn->tymed == TYMED_ISTORAGE && pmedium->tymed == TYMED_ISTORAGE)
    {
        hres = _CreateInstance(pmedium->pstg);
    }

    return hres;
}

HRESULT CTemplateUIObj::QueryGetData(LPFORMATETC pformatetcIn)
{
    if (pformatetcIn->cfFormat == CF_EMBEDDEDOBJECT
        && pformatetcIn->tymed == TYMED_ISTORAGE)
    {
        return S_OK;
    }
    else if (pformatetcIn->cfFormat == CF_OBJECTDESCRIPTOR
	&& pformatetcIn->tymed == TYMED_HGLOBAL)
    {
	return S_OK;
    }
    return DATA_E_FORMATETC;
}

HRESULT CTemplateUIObj::GetCanonicalFormatEtc(LPFORMATETC pformatetc, LPFORMATETC pformatetcOut)
{
    //
    //  This is the simplest implemtation. It means we always return
    // the data in the format requested.
    //
    return ResultFromScode(DATA_S_SAMEFORMATETC);
}

HRESULT CTemplateUIObj::SetData(LPFORMATETC pformatetc, STGMEDIUM  * pmedium, BOOL fRelease)
{
    return E_FAIL;
}

HRESULT CTemplateUIObj::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC * ppenumFormatEtc)
{
    static FORMATETC s_afmt[] = { { (CLIPFORMAT)CF_EMBEDDEDOBJECT }, {(CLIPFORMAT)CF_OBJECTDESCRIPTOR} };
    return SHCreateStdEnumFmtEtc(ARRAYSIZE(s_afmt), s_afmt, ppenumFormatEtc);
}

HRESULT CTemplateUIObj::DAdvise(FORMATETC * pFormatetc, DWORD advf, LPADVISESINK pAdvSink, DWORD * pdwConnection)
{
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

HRESULT CTemplateUIObj::DUnadvise(DWORD dwConnection)
{
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

HRESULT CTemplateUIObj::EnumDAdvise(LPENUMSTATDATA * ppenumAdvise)
{
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

#define TIDC_INVALID    -1
#define TIDC_COPY	0
#define TIDC_MAX	1

HRESULT CTemplateUIObj::QueryContextMenu(
                    HMENU hmenu,
                    UINT indexMenu,
                    UINT idCmdFirst,
                    UINT idCmdLast,
                    UINT uFlags)
{
    DebugMsg(DM_TRACE, TEXT("sc TR - CTUI::QCM called (uFlags=%x)"), uFlags);

    //
    // REVIEW: Checking CMF_DVFILE is subtle, need to be documented clearly!
    //
    if (!(uFlags & (CMF_VERBSONLY|CMF_DVFILE)))
    {
	MENUITEMINFO mii = {
	    sizeof(MENUITEMINFO),
	    MIIM_STATE|MIIM_ID|MIIM_TYPE,
	    MFT_STRING,
	    MFS_DEFAULT,
	    idCmdFirst+TIDC_COPY,
	    NULL, NULL, NULL, 0,
	    TEXT("&Copy"),	// FEATURE: Support NLS, the Copy operation might have a different name in other languages
	    5
	};
	InsertMenuItem(hmenu, indexMenu++, TRUE, &mii);
    }
    return ResultFromShort(TIDC_MAX);
}

HRESULT CTemplateUIObj::InvokeCommand(
                 LPCMINVOKECOMMANDINFO lpici)
{
    HRESULT hres;
    DebugMsg(DM_TRACE, TEXT("sc TR - CTUI::IC called (%x)"), lpici->lpVerb);
    int idCmd = TIDC_INVALID;

    if (HIWORD(lpici->lpVerb))
    {
	if (lstrcmpiA(lpici->lpVerb, "copy") == 0) {
	    idCmd = TIDC_COPY;
	}
    }
    else
    {
	idCmd = LOWORD(lpici->lpVerb);
    }

    switch(idCmd)
    {
    case TIDC_COPY:
	hres = OleSetClipboard(this);
	break;

    default:
	hres = E_INVALIDARG;
	break;
    }

    return hres;
}

HRESULT CTemplateUIObj::GetCommandString(
                                UINT        idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax)
{
    DebugMsg(DM_TRACE, TEXT("sc TR - CTUI::GCS called (%d, %x)"), idCmd, uType);
    return E_NOTIMPL;
}

#endif // FEATURE_SHELLEXTENSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shscrap\shole.cpp ===
#include "shole.h"
#include "ids.h"
#include "scguid.h"

#define CLONE_IT_IF_READONLY

class CShClientSite : public IOleClientSite, public IAdviseSink2
{
public:
    CShClientSite(HWND hwndOwner, LPCTSTR pszCmdLine);
    LPCTSTR  ParseCmdLine(LPCTSTR pszCmdLine);
    HRESULT Load();
    HRESULT DoVerb(LONG iVerb);
    void    CloseOleObject();
    void    ReleaseOleObject();
    void    ReleaseStorage(void);
    void    MaySaveAs(void);
    void    Draw(HWND hwnd, HDC hdc);
    void    GetFileName(LPTSTR szFile, UINT cchMax);
    void    Quit(void) { _hwndOwner = NULL ; _fQuit = TRUE; }
    BOOL    FContinue(void) { return !_fQuit; }

    // IUnKnown
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID,void **);
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // IOleClientSite
    virtual HRESULT STDMETHODCALLTYPE SaveObject(void);
    virtual HRESULT STDMETHODCALLTYPE GetMoniker(DWORD, DWORD, IMoniker **);
    virtual HRESULT STDMETHODCALLTYPE GetContainer(IOleContainer **);
    virtual HRESULT STDMETHODCALLTYPE ShowObject(void);
    virtual HRESULT STDMETHODCALLTYPE OnShowWindow(BOOL fShow);
    virtual HRESULT STDMETHODCALLTYPE RequestNewObjectLayout(void);

    // IAdviseSink2
    virtual void STDMETHODCALLTYPE OnDataChange(FORMATETC *,STGMEDIUM *);
    virtual void STDMETHODCALLTYPE OnViewChange(DWORD dwAspect,LONG lindex);
    virtual void STDMETHODCALLTYPE OnRename(IMoniker *pmk);
    virtual void STDMETHODCALLTYPE OnSave(void);
    virtual void STDMETHODCALLTYPE OnClose(void);
    virtual void STDMETHODCALLTYPE OnLinkSrcChange(IMoniker *pmk);

protected:
    ~CShClientSite();

    UINT                _cRef;
    HWND                _hwndOwner;
    LPSTORAGE           _pstgDoc;       // document
    LPSTORAGE           _pstg;          // the embedding (only one)
    LPPERSISTSTORAGE    _ppstg;
    LPOLEOBJECT         _pole;
    BOOL                _fDirty:1;
    BOOL                _fNeedToSave:1;
    BOOL                _fReadOnly:1;
    BOOL                _fCloned:1;
    BOOL                _fQuit:1;
    BOOL                _fCloseImmediately:1;
    DWORD               _dwConnection;  // non-zero, if valid
    WCHAR               _wszFileName[MAX_PATH];
};
typedef CShClientSite * LPSHCLIENTSITE;

const TCHAR c_szAppName[] = TEXT("ShellOleViewer");
LRESULT CALLBACK ShWndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam);
void DisplayError(HWND hwndOwner, HRESULT hres, UINT idsMsg, LPCTSTR szFileName);

HINSTANCE g_hinst = NULL;

extern "C"
BOOL APIENTRY LibMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    switch(dwReason) {
    case DLL_PROCESS_ATTACH:
        g_hinst = (HINSTANCE)hDll;
        DisableThreadLibraryCalls(g_hinst);
        break;

    default:
        break;
    }

    return TRUE;
}

void WINAPI
OpenScrap_RunDLL_Common(HWND hwndStub, HINSTANCE hInstApp, LPTSTR pszCmdLine, int nCmdShow)
{
    CShClientSite_RegisterClass();

    HWND hwndClientSite = CreateWindowEx(WS_EX_TOOLWINDOW | WS_EX_OVERLAPPEDWINDOW,
                                   c_szAppName,
#ifdef DEBUG
                                   TEXT("(Debug only) SHOLE.EXE"),
                                   WS_VISIBLE | WS_OVERLAPPEDWINDOW,
#else
                                   TEXT(""),
                                   WS_OVERLAPPEDWINDOW,
#endif
                                   CW_USEDEFAULT, CW_USEDEFAULT,
                                   128, 128, NULL, NULL, g_hinst, NULL);
    if (hwndClientSite)
    {
        HRESULT hres;

        hres = OleInitialize(NULL);
        if (SUCCEEDED(hres))
        {
            DWORD dwTick;
            LPSHCLIENTSITE pscs= new CShClientSite(hwndClientSite, pszCmdLine);

            if (pscs)
            {
                UINT cRef;

        hres = pscs->Load();
        if (SUCCEEDED(hres)) {
            hres = pscs->DoVerb(OLEIVERB_OPEN);
        }

                if (hres == S_OK)
                {
                    MSG msg;
                    while (pscs->FContinue() && GetMessage(&msg, NULL, 0, 0))
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }
                else
                {
                    // DoVerb failed.

                    if (FAILED(hres) || (hres>=IDS_HRES_MIN && hres<IDS_HRES_MAX))
                    {
                        TCHAR szFile[MAX_PATH];
                        pscs->GetFileName(szFile, ARRAYSIZE(szFile));
                        DisplayError(hwndClientSite, hres, IDS_ERR_DOVERB, szFile);
                    }
                    DestroyWindow(hwndClientSite);
                }

                //
                //  We call them just in case, the following Release
                // does not release the object.
                //
                pscs->ReleaseOleObject();
                pscs->ReleaseStorage();
                pscs->MaySaveAs();

                cRef = pscs->Release();
                Assert(cRef==0);
            }

            DebugMsg(DM_TRACE, TEXT("so TR - WinMain About to call OleUninitialize"));
            dwTick = GetCurrentTime();
            OleUninitialize();
            DebugMsg(DM_TRACE, TEXT("so TR - WinMain OleUninitialize took %d ticks"), GetCurrentTime()-dwTick);
        }

        if (IsWindow(hwndClientSite)) {
            DebugMsg(DM_WARNING, TEXT("so WA - WinMain IsWindow(hwndClientSite) is still TRUE"));
            DestroyWindow(hwndClientSite);
        }
    }
}

extern "C" void WINAPI
OpenScrap_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow)
{
#ifdef UNICODE
    UINT iLen = lstrlenA(lpszCmdLine)+1;
    LPWSTR  lpwszCmdLine;

    lpwszCmdLine = (LPWSTR)LocalAlloc(LPTR,iLen*sizeof(WCHAR));
    if (lpwszCmdLine)
    {
        MultiByteToWideChar(CP_ACP, 0,
                            lpszCmdLine, -1,
                            lpwszCmdLine, iLen);
        OpenScrap_RunDLL_Common( hwndStub,
                                 hAppInstance,
                                 lpwszCmdLine,
                                 nCmdShow );
        LocalFree(lpwszCmdLine);
    }
#else
    OpenScrap_RunDLL_Common( hwndStub,
                             hAppInstance,
                             lpszCmdLine,
                             nCmdShow );
#endif
}

extern "C" void WINAPI
OpenScrap_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow)
{
#ifdef UNICODE
    OpenScrap_RunDLL_Common( hwndStub,
                             hAppInstance,
                             lpwszCmdLine,
                             nCmdShow );
#else
    UINT iLen = WideCharToMultiByte(CP_ACP, 0,
                                    lpwszCmdLine, -1,
                                    NULL, 0, NULL, NULL)+1;
    LPSTR  lpszCmdLine;

    lpszCmdLine = (LPSTR)LocalAlloc(LPTR,iLen);
    if (lpszCmdLine)
    {
        WideCharToMultiByte(CP_ACP, 0,
                            lpwszCmdLine, -1,
                            lpszCmdLine, iLen,
                            NULL, NULL);
        OpenScrap_RunDLL_Common( hwndStub,
                                 hAppInstance,
                                 lpszCmdLine,
                                 nCmdShow );
        LocalFree(lpszCmdLine);
    }
#endif
}
#ifdef DEBUG
//
// Type checking
//
static RUNDLLPROCA lpfnRunDLLA=OpenScrap_RunDLL;
static RUNDLLPROCW lpfnRunDLLW=OpenScrap_RunDLLW;
#endif

void DisplayError(HWND hwndOwner, HRESULT hres, UINT idsMsg, LPCTSTR pszFileName)
{
    TCHAR szErrMsg[MAX_PATH*2];
    TCHAR szFancyErr[MAX_PATH*2];
    HRSRC hrsrc;

    if (HIWORD(hres))
    {
        BOOL fSuccess = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                  NULL,
                  hres,
                  0,
                  szErrMsg,
                  ARRAYSIZE(szErrMsg),
                  (va_list *)&pszFileName);
        if (!fSuccess) {
            idsMsg++;   // map IDS_ERR_DOVERB to IDS_ERR_DOVERB_F
        }
    } else {
        LoadString(g_hinst, LOWORD(hres), szErrMsg, ARRAYSIZE(szErrMsg));
    }

    szFancyErr[0] = TEXT('\0');
    hrsrc = FindResource(g_hinst, MAKEINTRESOURCE(IDR_FANCYERR), RT_RCDATA);
    if (hrsrc)
    {
        HGLOBAL hmem = LoadResource(g_hinst, hrsrc);
        if (hmem)
        {
            HRESULT* phres = (HRESULT*)LockResource(hmem);
            if (phres)
            {
                UINT i;
                LPTSTR pszLoad = szFancyErr;
                int cchLeft = ARRAYSIZE(szFancyErr);
                for (i=0; phres[i] && cchLeft>0; i++) {
                    if (phres[i] == hres)
                    {
                        int cchRead;
                        cchRead = LoadString(g_hinst, IDS_FANCYERR+i, pszLoad, cchLeft);
                        pszLoad += cchRead;
                        cchLeft -= cchRead;
                    }
                }

                //
                // If we have a fancy error message, hide ugly message
                // from FormatMessage.
                //
                if (szFancyErr[0]) {
                    szErrMsg[0] = TEXT('\0');
                }
            }
        }
    }

    ShellMessageBox(g_hinst,
                    hwndOwner,
                    MAKEINTRESOURCE(idsMsg),
                    MAKEINTRESOURCE(IDS_TITLE_ERR),
                    MB_OK | MB_ICONWARNING | MB_SETFOREGROUND,
                    pszFileName,
                    szErrMsg,
                    szFancyErr,
                    hres);
}


void CShClientSite::CloseOleObject()
{
    if (_pole)
        _pole->Close(OLECLOSE_NOSAVE);
}

void CShClientSite::ReleaseOleObject()
{
    UINT cRef;
    if (_pole)
    {
        if (_dwConnection) {
            _pole->Unadvise(_dwConnection);
            _dwConnection = 0;
        }
        _pole->SetClientSite(NULL);
        cRef = _pole->Release();
        DebugMsg(DM_TRACE, TEXT("so - TR SCS::ReleaseOleObject IOleObj::Rel returned (%d)"), cRef);
        _pole=NULL;
    }

    if (_ppstg)
    {
        cRef=_ppstg->Release();
        _ppstg=NULL;
        DebugMsg(DM_TRACE, TEXT("so TR - SCS::ReleaseOleObject IPSTG::Release returned (%x)"), cRef);
    }
}

void CShClientSite::ReleaseStorage(void)
{
    UINT cRef;

    if (_pstg)
    {
        cRef=_pstg->Release();
        _pstg=NULL;
        DebugMsg(DM_TRACE, TEXT("so TR - SCS::ReleaseStorage _pstg->Release returned (%x)"), cRef);
    }

    if (_pstgDoc)
    {
        cRef=_pstgDoc->Release();
        _pstgDoc=NULL;
        DebugMsg(DM_TRACE, TEXT("so TR - SCS::ReleaseStorage _pstgDoc->Release returned (%x)"), cRef);
    }
}

void CShClientSite::MaySaveAs()
{
    DebugMsg(DM_TRACE, TEXT("so TR - SCS::MaySaveAs called (%d,%d)"), _fCloned, _fNeedToSave);
    if (_fCloned)
    {
        TCHAR szTempFile[MAX_PATH];
#ifdef UNICODE
        lstrcpyn(szTempFile,_wszFileName,ARRAYSIZE(szTempFile));
#else
        WideCharToMultiByte(CP_ACP, 0, _wszFileName, -1, szTempFile, ARRAYSIZE(szTempFile), NULL, NULL);
#endif

        UINT id = IDNO;
        if (_fNeedToSave)
        {
            id= ShellMessageBox(g_hinst,
                        _hwndOwner,
                        MAKEINTRESOURCE(IDS_WOULDYOUSAVEAS),
                        MAKEINTRESOURCE(IDS_TITLE),
                        MB_YESNO | MB_ICONQUESTION | MB_SETFOREGROUND,
                        NULL);
        }

        DebugMsg(DM_TRACE, TEXT("so TR - SCS::MaySaveAs id==%d"), id);

        if (id==IDYES)
        {
            TCHAR szDesktop[MAX_PATH];
            SHGetSpecialFolderPath(NULL, szDesktop, CSIDL_DESKTOP, FALSE);

            BOOL fContinue;
            do
            {
                fContinue = FALSE;

                TCHAR szFile[MAX_PATH];
                TCHAR szFilter[64];
                szFile[0] = TEXT('\0');
                LoadString(g_hinst, IDS_SCRAPFILTER, szFilter, ARRAYSIZE(szFilter));

                OPENFILENAME of = {
                    SIZEOF(OPENFILENAME), // DWORD        lStructSize;
                    _hwndOwner,               // HWND         hwndOwner;
                    NULL,                     // HINSTANCE    hInstance;
                    szFilter,         // LPCSTR       lpstrFilter;
                    NULL,                     // LPSTR        lpstrCustomFilter;
                    0,                // DWORD        nMaxCustFilter;
                    1,                // DWORD        nFilterIndex;
                    szFile,           // LPSTR        lpstrFile;
                    ARRAYSIZE(szFile),    // DWORD        nMaxFile;
                    NULL,                     // LPSTR        lpstrFileTitle;
                    0,                // DWORD        nMaxFileTitle;
                    szDesktop,        // LPCSTR       lpstrInitialDir;
                    NULL,                     // LPCSTR       lpstrTitle;
                    OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT
                     | OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST,
                                          // DWORD        Flags;
                    0,                // WORD         nFileOffset;
                    0,                // WORD         nFileExtension;
                    TEXT("shs"),                      // LPCSTR       lpstrDefExt;
                    NULL,                     // LPARAM       lCustData;
                    NULL,                     // LPOFNHOOKPROC lpfnHook;
                    NULL,                     // LPCSTR       lpTemplateName;
                };

                if (GetSaveFileName(&of))
                {
                    DeleteFile(szFile);
                    BOOL fRet = MoveFile(szTempFile, szFile);
                    if (fRet)
                    {
                        // Indicated that the temp file is moved
                        szTempFile[0] = TEXT('\0');
                    }
                    else
                    {
                        id = ShellMessageBox(g_hinst,
                                _hwndOwner,
                                MAKEINTRESOURCE(IDS_MOVEFAILED),
                                MAKEINTRESOURCE(IDS_TITLE),
                                MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND);
                        if (id==IDYES)
                        {
                            fContinue = TRUE;
                        }
                    }
                }
            } while (fContinue);
        }

        // If the temp file is not moved, delete it.
        if (szTempFile[0])
        {
            DeleteFile(szTempFile);
        }
    }
}

void CShClientSite::Draw(HWND hwnd, HDC hdc)
{
    if (_ppstg)
    {
        HRESULT hres;
        RECT rc;

        GetClientRect(hwnd, &rc);

        hres = OleDraw(_ppstg, DVASPECT_ICON, hdc, &rc);
        DebugMsg(DM_TRACE, TEXT("so TR - SCS::Draw OleDraw(DVASPECT_ICON) returned %x"), hres);

        if (FAILED(hres))
        {
            LPVIEWOBJECT2 pview;
            hres = _ppstg->QueryInterface(IID_IViewObject2, (LPVOID*)&pview);
            if (SUCCEEDED(hres))
            {
                SIZE size;
                hres = pview->GetExtent(DVASPECT_CONTENT, (DWORD)-1,
                                        (DVTARGETDEVICE*)NULL, &size);
                DebugMsg(DM_TRACE, TEXT("so TR - SCS::Draw IVO2::GetExtent returned %x"), hres);
                if (SUCCEEDED(hres))
                {
                    int mmOld = SetMapMode(hdc, MM_HIMETRIC);
                    LPtoDP(hdc, (LPPOINT)&size, 1);
                    rc.right = size.cx;
                    rc.bottom = -size.cy;
                    SetMapMode(hdc, mmOld);
                }
                pview->Release();
            }
            hres = OleDraw(_ppstg, DVASPECT_CONTENT, hdc, &rc);
            DebugMsg(DM_TRACE, TEXT("so TR - SCS::Draw OleDraw(DVASPECT_CONTENT,%d,%d) returned %x"),
                        hres, rc.right, rc.bottom);
        }

        LPOLELINK plink;
        if (SUCCEEDED(hres = _ppstg->QueryInterface(IID_IOleLink, (LPVOID *)&plink)))
        {
            LPOLESTR pwsz;
            hres = plink->GetSourceDisplayName(&pwsz);
            if (SUCCEEDED(hres))
            {
#ifdef UNICODE
                TextOut(hdc, 0, 0, pwsz, lstrlen(pwsz));
#else
                TCHAR szDisplayName[256] = TEXT("##ERROR##");
                WideCharToMultiByte(CP_ACP, 0, pwsz, -1, szDisplayName, ARRAYSIZE(szDisplayName), NULL, NULL);
                TextOut(hdc, 0, 0, szDisplayName, lstrlen(szDisplayName));
#endif
                CoTaskMemFree(pwsz);
            }
            else
            {
                DebugMsg(DM_TRACE, TEXT("so TR SCS:Draw IMK:GetSDN failed %x"), hres);
            }
            plink->Release();
        }
        else
        {
            DebugMsg(DM_TRACE, TEXT("so TR SCS:Draw IPSTG:QI failed %x"), hres);
        }
    }
}

STDMETHODIMP CShClientSite::QueryInterface(REFIID riid,
        void **ppvObject)
{
    HRESULT hres;
    if (IsEqualGUID(riid, CLSID_CShClientSite)) {
        _cRef++;
        *ppvObject = this;
        hres = NOERROR;
    }
    else if (IsEqualGUID(riid, IID_IOleClientSite) || IsEqualGUID(riid, IID_IUnknown)) {
        _cRef++;
        *ppvObject = (LPOLECLIENTSITE)this;
        hres = NOERROR;
    }
    else if (IsEqualGUID(riid, IID_IAdviseSink) || IsEqualGUID(riid, IID_IAdviseSink2)) {
        _cRef++;
        *ppvObject = (LPADVISESINK2)this;
        hres = NOERROR;
    }
    else
    {
        *ppvObject = NULL;
        hres = ResultFromScode(E_NOINTERFACE);
    }
    return hres;
}

STDMETHODIMP_(ULONG) CShClientSite::AddRef(void)
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CShClientSite::Release(void)
{
    if (--_cRef>0) {
        return _cRef;
    }

    delete this;
    return 0;
}


void Scrap_UpdateCachedData(LPSTORAGE pstgDoc, LPOLEOBJECT pole, LPPERSIST pps)
{
    extern void Scrap_CacheClipboardData(LPSTORAGE pstgDoc, LPDATAOBJECT pdtobj, LPPERSIST pps);
    DebugMsg(DM_TRACE, TEXT("so TR - S_UCD called"));
    if (pstgDoc && pole && pps)
    {
        IDataObject *pdtobj = NULL;
        HRESULT hres = pole->QueryInterface(IID_IDataObject, (LPVOID*)&pdtobj);
        if (SUCCEEDED(hres)) {
            DebugMsg(DM_TRACE, TEXT("so TR - S_UCD QI succeeded"));
            Scrap_CacheClipboardData(pstgDoc, pdtobj, pps);
            pdtobj->Release();
        }
    }
}

STDMETHODIMP CShClientSite::SaveObject(void)
{
    DebugMsg(DM_TRACE, TEXT("sc TR - CSCS::SaveObject called"));
    //
    // NOTES: We need to update the cache here.
    //  Doing so on ::OnSave does not work (async)
    //  Doing so on ::OnClose is too late.
    //
    Scrap_UpdateCachedData(_pstgDoc, _pole, _ppstg);

    HRESULT hres;
    if (_pstg && _ppstg)
    {
        hres = OleSave(_ppstg, _pstg, TRUE);
        if (SUCCEEDED(hres))
        {
            hres = _ppstg->SaveCompleted(NULL);
        }
    }
    else
    {
        hres = ResultFromScode(E_FAIL);
    }
    return hres;
}

STDMETHODIMP CShClientSite::GetMoniker(DWORD dwAssign,
    DWORD dwWhichMoniker,
    IMoniker **ppmk)
{
    HRESULT hres;

    *ppmk = NULL;

    switch(dwWhichMoniker)
    {
    case OLEWHICHMK_CONTAINER:
        hres = CreateFileMoniker(_wszFileName, ppmk);
        break;

    case OLEWHICHMK_OBJREL:
        hres = CreateItemMoniker(L"\\", L"Object", ppmk);
        break;

    case OLEWHICHMK_OBJFULL:
        {
            LPMONIKER pmkItem;
            hres = CreateItemMoniker(L"\\", L"Object", &pmkItem);
            if (SUCCEEDED(hres))
            {
                LPMONIKER pmkDoc;
                hres = CreateFileMoniker(_wszFileName, &pmkDoc);
                if (SUCCEEDED(hres))
                {
                    hres = CreateGenericComposite(pmkDoc, pmkItem, ppmk);
                    pmkDoc->Release();
                }
                pmkItem->Release();
            }
        }
        break;

    default:
        hres = ResultFromScode(E_INVALIDARG);
    }

    return hres;
}

STDMETHODIMP CShClientSite::GetContainer(
    IOleContainer **ppContainer)
{
    *ppContainer = NULL;
    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP CShClientSite::ShowObject(void)
{
    return NOERROR;
}

STDMETHODIMP CShClientSite::OnShowWindow(BOOL fShow)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnShowWindow called with %d"), fShow);
    return NOERROR;
}

STDMETHODIMP CShClientSite::RequestNewObjectLayout(void)
{
    return ResultFromScode(E_NOTIMPL);
}

//
// _cRef <- 2 because _hwndOwner has a reference count as well.
//
CShClientSite::CShClientSite(HWND hwndOwner, LPCTSTR pszCmdLine)
                : _cRef(2), _hwndOwner(hwndOwner),
                  _pstgDoc(NULL), _pstg(NULL), _ppstg(NULL), _pole(NULL),
                  _fDirty(FALSE), _fNeedToSave(FALSE),
                  _fReadOnly(FALSE), _fCloned(FALSE), _fCloseImmediately(FALSE),
                  _fQuit(FALSE)
{
    LPCTSTR pszFileName = ParseCmdLine(pszCmdLine);

//
// We'd better deal with quoted LFN name.
//
#ifdef NASHVILLE
    //
    // Strip out quotes if exists.
    //
    TCHAR szT[MAX_PATH];
    if (*pszFileName==TEXT('"'))
    {
        lstrcpy(szT, pszFileName+1);
        LPTSTR pszT = CharPrev(szT, szT+lstrlen(szT));
        if (*pszT==TEXT('"')) {
            *pszT=TEXT('\0');
        }
        pszFileName = szT;
    }
#endif // NASHVILLE

#ifdef UNICODE
    lstrcpyn(_wszFileName, pszFileName, ARRAYSIZE(_wszFileName));
#else
    MultiByteToWideChar(CP_ACP, 0, pszFileName, lstrlen(pszFileName)+1,
                        _wszFileName, ARRAYSIZE(_wszFileName));
#endif

    Assert(_hwndOwner)
    SetWindowLongPtr(_hwndOwner, GWLP_USERDATA, (LPARAM)this);
}

CShClientSite::~CShClientSite()
{
    ReleaseOleObject();
    ReleaseStorage();
    DebugMsg(DM_TRACE, TEXT("sc - CShClientSite is being deleted"));
}

LPCTSTR _SkipSpace(LPCTSTR psz)
{
    while(*psz==TEXT(' '))
        psz++;
    return psz;
}

LPCTSTR CShClientSite::ParseCmdLine(LPCTSTR pszCmdLine)
{
    for (LPCTSTR psz = _SkipSpace(pszCmdLine);
         (*psz == TEXT('/') || *psz == TEXT('-')) && *++psz;
         psz = _SkipSpace(psz))
    {
        switch(*psz++)
        {
        case TEXT('r'):
        case TEXT('R'):
            _fReadOnly = TRUE;
            break;

        case TEXT('x'):
        case TEXT('X'):
            _fCloseImmediately = TRUE;
            break;
        }
    }

    return psz;
}

void CShClientSite::GetFileName(LPTSTR szFile, UINT cchMax)
{
#ifdef UNICODE
    lstrcpyn(szFile, _wszFileName, cchMax);
#else
    WideCharToMultiByte(CP_ACP, 0, _wszFileName, -1, szFile, cchMax, NULL, NULL);
#endif
}
const WCHAR c_wszContents[] = WSTR_SCRAPITEM;

//
// Returns:
//      S_OK, succeeded. Start the message loop.
//      S_FALSE, succeeded. Release the object.
//      Others, failed.
//
HRESULT CShClientSite::Load()
{
    HRESULT hres;
    DWORD wStgm;

    // Must be called only once.
    if (_pstgDoc) {
        return ResultFromScode(E_UNEXPECTED);
    }

    wStgm = _fReadOnly ?
                (STGM_READ | STGM_SHARE_DENY_WRITE) :
                (STGM_TRANSACTED | STGM_READWRITE | STGM_SHARE_EXCLUSIVE);
    hres = StgIsStorageFile(_wszFileName);
    if (hres != S_OK)
    {
        if (hres==S_FALSE) {
            hres = IDS_HRES_INVALID_SCRAPFILE;
        }
        return hres;
    }

    hres = StgOpenStorage(_wszFileName, NULL, wStgm, NULL, 0, &_pstgDoc);

#ifndef CLONE_IT_IF_READONLY
    //
    //  If we are opening without read-only flag and StgOpenStorage failed
    // with STG_E_ACCESSDENIED, retry it with read-only mode.
    //
    if ((hres==STG_E_ACCESSDENIED) && !_fReadOnly)
    {
        DebugMsg(DM_TRACE, TEXT("so TR - CSCS::DoVerb first StgOpenStorage failed, retrying it in read-only mode"));
        _fReadOnly = TRUE;
        wStgm = (STGM_READ | STGM_SHARE_DENY_WRITE);
        hres = StgOpenStorage(_wszFileName, NULL, wStgm, NULL, 0, &_pstgDoc);
    }
#else // CLONE_IT_IF_READONLY
    //
    //  If we are opening without read-only flag and StgOpenStorage failed
    // with STG_E_ACCESSDENIED, retry it with read-only mode.
    //
    if ((hres==STG_E_ACCESSDENIED) && !_fReadOnly)
    {
        LPSTORAGE pstgRead;
        DebugMsg(DM_TRACE, TEXT("so TR - CSCS::DoVerb first StgOpenStorage failed, retrying it in read-only mode"));
        hres = StgOpenStorage(_wszFileName, NULL, STGM_READ | STGM_SHARE_DENY_WRITE, NULL, 0, &pstgRead);
        if (SUCCEEDED(hres))
        {
            TCHAR szDesktop[MAX_PATH];
            TCHAR szTempFile[MAX_PATH];
            SHGetSpecialFolderPath(_hwndOwner, szDesktop, CSIDL_DESKTOP, FALSE);
            GetTempFileName(szDesktop, TEXT("Sh"), 0, szTempFile);
#ifdef UNICODE
            lstrcpyn(_wszFileName,szTempFile,ARRAYSIZE(szTempFile));
#else
            MultiByteToWideChar(CP_ACP, 0, szTempFile, -1, _wszFileName, ARRAYSIZE(_wszFileName));
#endif

            hres = StgCreateDocfile(_wszFileName,
                            STGM_DIRECT | STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                            0, &_pstgDoc);
            if (SUCCEEDED(hres))
            {
                hres = pstgRead->CopyTo(0, NULL, NULL, _pstgDoc);
                _pstgDoc->Release();
                _pstgDoc = NULL;

                if (SUCCEEDED(hres))
                {
                    hres = StgOpenStorage(_wszFileName, NULL, wStgm, NULL, 0, &_pstgDoc);
                    if (SUCCEEDED(hres))
                    {
                        _fCloned = TRUE;
                    }
                }
                else
                {
                    DeleteFile(szTempFile);
                }
            }
            pstgRead->Release();
        }
    }
#endif // CLONE_IT_IF_READONLY

    if (SUCCEEDED(hres))
    {
        if (_fReadOnly) {
            wStgm = STGM_READ|STGM_SHARE_EXCLUSIVE;
        }
        hres = _pstgDoc->OpenStorage(c_wszContents, NULL, wStgm, NULL, 0, &_pstg);
        if (SUCCEEDED(hres))
        {
            hres = OleLoad(_pstg, IID_IPersistStorage, this, (LPVOID *)&_ppstg);
        }
        else
        {
            DebugMsg(DM_TRACE, TEXT("so ER - CSCS::DoVerb _pstgDoc->OpenStorage failed %x"), hres);

            //
            // Notes: If we just return this hres as is, the user will see
            //  "Can't open file, FOO.SHS", which is bogus. We need to
            //  translate it into a much informative message.
            //
            hres = IDS_HRES_INVALID_SCRAPFILE;
        }
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("so ER - CSCS::DoVerb StgOpenStg failed %x"), hres);
    }

    return hres;
}



HRESULT CShClientSite::DoVerb(LONG iVerb)
{
    HRESULT hres;
    hres = _ppstg->QueryInterface(IID_IOleObject, (LPVOID *)&_pole);

    if (SUCCEEDED(hres))
    {
    hres = _pole->Advise(this, &_dwConnection);
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::DoVerb IOleObject::Advise returned %x"), hres);
    if (SUCCEEDED(hres))
    {
        TCHAR szTitle[MAX_PATH];
        WCHAR wszTitle[MAX_PATH];
        LoadString(g_hinst, IDS_TITLE, szTitle, ARRAYSIZE(szTitle));
#ifdef UNICODE
        lstrcpyn(wszTitle,szTitle,ARRAYSIZE(wszTitle));
#else
        MultiByteToWideChar(CP_ACP, 0, szTitle, lstrlen(szTitle)+1,
            wszTitle, ARRAYSIZE(wszTitle));
#endif

        GetFileName(szTitle, ARRAYSIZE(szTitle));
        LPCWSTR pwszDisplayName = _wszFileName;
#ifndef UNICODE
        WCHAR wszDisplayName[MAX_PATH];
#endif
        SHFILEINFO info;
        DWORD_PTR result = SHGetFileInfo(szTitle, 0,
        &info, SIZEOF(info), SHGFI_DISPLAYNAME);

        if(result && *info.szDisplayName)
        {
#ifdef UNICODE
        pwszDisplayName = info.szDisplayName;
#else
        MultiByteToWideChar(CP_ACP, 0,
            info.szDisplayName, -1,
            wszDisplayName, ARRAYSIZE(wszDisplayName));
        pwszDisplayName = wszDisplayName;
#endif
        }

        _pole->SetHostNames(wszTitle, pwszDisplayName);

        //
        // OLEBUG? Unless _hwndOwner has the input focus, 16-bit
        //  server won't get the input focus.
        //
        SetFocus(_hwndOwner);

        hres = _pole->DoVerb(iVerb, NULL, this, 0, _hwndOwner, NULL);
        DebugMsg(DM_TRACE, TEXT("so TR - CSCS::DoVerb IOleObject::DoVerb returned %x"), hres);
        if (SUCCEEDED(hres) && _fCloseImmediately) {
        hres = S_FALSE;
        }
    }
    }
    else
    {
    DebugMsg(DM_TRACE, TEXT("so ER - CSCS::DoVerb IPSTG::QI failed %x"), hres);
    }
    return hres;
}

STDMETHODIMP_(void) CShClientSite::OnDataChange(FORMATETC *pFormatetc, STGMEDIUM *pStgmed)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnDataChange called"));
    _fDirty = TRUE;
}

STDMETHODIMP_(void) CShClientSite::OnViewChange(DWORD dwAspect, LONG lindex)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnViewChange called"));
    _fDirty = TRUE;
}

STDMETHODIMP_(void) CShClientSite::OnRename(IMoniker *pmk)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnRename called"));
    _fDirty = TRUE;
}

STDMETHODIMP_(void) CShClientSite::OnSave(void)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnSave called"));
    _fNeedToSave = TRUE;
}

STDMETHODIMP_(void) CShClientSite::OnClose(void)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnClose called"));
    if (_fNeedToSave /* && _fDirty */)
    {
        HRESULT hres;
        hres=OleSave(_ppstg, _pstg, TRUE);      // fSameStorage=TRUE
        DebugMsg(DM_TRACE, TEXT("so TR - CSCS:OnClose OleSave returned (%x)"), hres);
        hres=_ppstg->HandsOffStorage();
        DebugMsg(DM_TRACE, TEXT("so TR - CSCS:OnClose IPS:HandsOffStorage returned (%x)"), hres);
        if (SUCCEEDED(hres))
        {
            hres = _pstg->Commit(STGC_OVERWRITE);
            DebugMsg(DM_TRACE, TEXT("so TR - CSCS:OnClose _psg->Commit returned (%x)"), hres);
            hres = _pstgDoc->Commit(STGC_OVERWRITE);
            DebugMsg(DM_TRACE, TEXT("so TR - CSCS:OnClose _psgDoc->Commit returned (%x)"), hres);
        }
    }

    //
    // WARNING:
    //
    //  OLE1 server pukes if we release object here. However, we need to
    // call IOleObject::UnAdvice and IOleObject::SetClientSite(NULL) here
    // to avoid memory leak (RPC keeps 3 reference counts to IOleClientSite
    // if we delay it as well).
    //
    // ReleaseOleObject();
    //
    if (_dwConnection) {
        _pole->Unadvise(_dwConnection);
        _dwConnection = 0;
    }
    _pole->SetClientSite(NULL);

    PostMessage(_hwndOwner, WM_USER, 0, 0);
}

STDMETHODIMP_(void) CShClientSite::OnLinkSrcChange
(
    IMoniker *pmk
)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnLinkSrcChange called"));
    _fDirty = TRUE;
}

LRESULT CALLBACK ShWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT ps;
    HDC hdc;
    LPSHCLIENTSITE pscs = (LPSHCLIENTSITE)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        if (pscs && IsWindowVisible(hwnd))
        {
            pscs->Draw(hwnd, hdc);
        }
        EndPaint(hwnd, &ps);
        break;

    case WM_CLOSE:
        if (pscs)
        {
            pscs->CloseOleObject();
            DestroyWindow(hwnd);
        }
        break;

    case WM_USER:
        if (pscs)
        {
            pscs->ReleaseOleObject();
            PostMessage(hwnd, WM_CLOSE, 0, 0);
        }
        break;

    case WM_DESTROY:
        DebugMsg(DM_WARNING, TEXT("so WA - ShWndProc processing WM_DESTROY"));
        if (pscs)
        {
            pscs->Quit();
            pscs->Release();
            SetWindowLongPtr(hwnd, GWLP_USERDATA, 0);
        }
        else
        {
            DebugMsg(DM_WARNING, TEXT("so WA - ShWndProc pscs==NULL on WM_DESTROY"));
        }

#if 0
        //
        // Process all the pending messages, before we post WM_QUIT message.
        //
        MSG msg;
        while (PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
#endif

        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}

//===========================================================================
// Global functions
//===========================================================================

void CShClientSite_RegisterClass()
{
    WNDCLASS wc;

    // wc.cbSize     = SIZEOF(WNDCLASSEX);
    wc.style         = CS_DBLCLKS|CS_VREDRAW|CS_HREDRAW ;
    wc.lpfnWndProc   = ShWndProc ;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = SIZEOF(LPSHCLIENTSITE) + SIZEOF(LPVOID);
    wc.hInstance     = g_hinst ;
    wc.hIcon         = NULL ;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
    wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH) ;
    wc.lpszMenuName  = NULL ;
    wc.lpszClassName = c_szAppName ;
    // wc.hIconSm    = NULL;

    RegisterClass(&wc);
}

IOleClientSite* CShClientSite_Create(HWND hwndOwner, LPCTSTR pszFileName)
{
    DebugMsg(DM_TRACE, TEXT("sc TR:CShClientSite_Create called with %s"), pszFileName);
    CShClientSite* that = new CShClientSite(hwndOwner, pszFileName);
    if (that)
    {
        HRESULT hres = that->Load();
        DebugMsg(DM_TRACE, TEXT("sc TRACE: CShClientSite::Load returned %x"), hres);
    }
    return that;
}

void CShClientSite_Release(IOleClientSite* pcli)
{
    CShClientSite* pscs;
    if (SUCCEEDED(pcli->QueryInterface(CLSID_CShClientSite, (void**)&pscs)))
    {
        pscs->ReleaseOleObject();
        pscs->ReleaseStorage();
        pscs->MaySaveAs();
        pscs->Release();
    }
    UINT cRef = pcli->Release();
    Assert(cRef==0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shscrap\shole.h ===
//Prevent windows.h from pulling in OLE 1
#define _INC_OLE

#include <windows.h>
#include <stdlib.h>
#include <shlwapi.h>        // must be before commctrl.h and shlobj.h
#include <shlobj.h>         // ;Internal
#include <shellapi.h>       // ;Internal
#include <shsemip.h>

#include <ole2ver.h>
#include <shellp.h>     // in shell\inc
#include <debug.h>      // in shell\inc
#include <shguidp.h>    // in shell\inc
#include <shlwapip.h>   // for string helper functions

#ifndef WINNT
#include <w95wraps.h>
#define lstrcmpiW       StrCmpIW
#define lstrcpyW        StrCpyW
#else

#endif

#define SAVE_OBJECTDESCRIPTOR
#define FIX_ROUNDTRIP

#define CCF_CACHE_GLOBAL        32
#define CCF_CACHE_CLSID         32
#define CCF_RENDER_CLSID        32
#define CCFCACHE_TOTAL  (CC_FCACHE_GLOBAL+CCF_CACHE_CLSID+CCF_RENDER_CLSID)


HRESULT CScrapData_CreateInstance(LPUNKNOWN * ppunk);
HRESULT CTemplateFolder_CreateInstance(LPUNKNOWN * ppunk);
HRESULT CScrapExt_CreateInstance(LPUNKNOWN * ppunk);

//
// global variables
//
extern LONG g_cRefThisDll;              // per-instance
extern HINSTANCE g_hinst;
STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);

#ifdef __cplusplus
extern "C" {
#endif

extern const WCHAR c_wszContents[];
extern const WCHAR c_wszDescriptor[];

#ifdef __cplusplus
};

#endif

#define HINST_THISDLL g_hinst



#define CFID_EMBEDDEDOBJECT     0
#define CFID_OBJECTDESCRIPTOR   1
#define CFID_LINKSRCDESCRIPTOR  2
#define CFID_RICHTEXT           3
#define CFID_SCRAPOBJECT        4
#define CFID_TARGETCLSID        5
#define CFID_RTF                6
#define CFID_MAX                7

#define CF_EMBEDDEDOBJECT       _GetClipboardFormat(CFID_EMBEDDEDOBJECT)
#define CF_OBJECTDESCRIPTOR     _GetClipboardFormat(CFID_OBJECTDESCRIPTOR)
#define CF_LINKSRCDESCRIPTOR    _GetClipboardFormat(CFID_LINKSRCDESCRIPTOR)
#define CF_RICHTEXT             _GetClipboardFormat(CFID_RICHTEXT)
#define CF_SCRAPOBJECT          _GetClipboardFormat(CFID_SCRAPOBJECT)
#define CF_TARGETCLSID          _GetClipboardFormat(CFID_TARGETCLSID)
#define CF_RTF                  _GetClipboardFormat(CFID_RTF)

CLIPFORMAT _GetClipboardFormat(UINT id);
void DisplayError(HWND hwndOwner, HRESULT hres, UINT idsMsg, LPCTSTR szFileName);

// From shole.c
void CShClientSite_RegisterClass();
IOleClientSite* CShClientSite_Create(HWND hwnd, LPCTSTR pszFileName);
void CShClientSite_Release(IOleClientSite* pcli);

// From template.cpp
HRESULT _KeyNameFromCLSID(REFCLSID rclsid, LPTSTR pszKey, UINT cchMax);
int _ParseIconLocation(LPTSTR pszIconFile);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shtl\autoptr.cpp ===
#include "shtl.h"
#include "autoptr.h"


//*************************************************************
//
//  AutoFindHandle non-inline member functions.
//
//*************************************************************
__DATL_INLINE AutoFindHandle& 
AutoFindHandle::operator = (
    const AutoFindHandle& rhs
    )
{
    if (this != &rhs)
    {
        Attach(rhs.Detach());
    }
    return *this;
}


__DATL_INLINE void 
AutoFindHandle::Close(
    void
    )
{ 
    if (m_bOwns && INVALID_HANDLE_VALUE != m_handle)
    { 
        FindClose(m_handle);
    }
    m_bOwns  = false;
    m_handle = INVALID_HANDLE_VALUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shtl\autoptr.h ===
#pragma once
#include <atlbase.h>
#include <utility>
#include <assert.h>
#include "dexception.h"


// AutoPtrBase
//
// Safe pointer class that knows to delete the referrent object when
// the pointer goes out of scope or is replaced, etc.

template<class _TYPE> class AutoPtrBase 
{
protected:

    mutable BOOL m_bOwns;
    _TYPE * m_pRaw;

public:

    // Create from raw pointer.  This auto pointer now owns the data.

    AutoPtrBase(_TYPE * pRaw = NULL)
    {
        m_bOwns = (pRaw != NULL);
        m_pRaw  = pRaw;

        assert( !m_bOwns || m_pRaw );
    }

    // Create from other auto pointer.  Other auto pointer disowns the data.

    AutoPtrBase(const AutoPtrBase<_TYPE> & ptrOther) 
    {
        m_bOwns = ptrOther.m_bOwns;
        m_pRaw  = (_TYPE *) const_cast<AutoPtrBase<_TYPE> &>(ptrOther)._disownptr();
    }

    AutoPtrBase<_TYPE> & take(_TYPE * pRawIn)
    {
        if (m_pRaw != pRawIn)
        {
            if (m_bOwns)
                nukeit();
        }            
        m_bOwns = (pRawIn != NULL);
        m_pRaw  = pRawIn;

        assert( !m_bOwns || m_pRaw );
        
        return *this;
    }

    virtual ~AutoPtrBase()
    {
    }

    virtual void nukeit()
    {
        delete m_pRaw;
    }

    AutoPtrBase<_TYPE> & operator=(_TYPE * pRawIn)
    {
        take(pRawIn);
        return *this;
    }

    // Assignment of other auto pointer to ourselves.  If we are not the
    // same object, we take ownership of the data, first releasing any
    // we already own.

    AutoPtrBase<_TYPE> & operator=(const AutoPtrBase<_TYPE> & ptrOther)
    {
        if ((void *)this != (void *)&ptrOther)
        {
            _TYPE * pRaw = const_cast<AutoPtrBase<_TYPE>&>(ptrOther)._disownptr();
            take(pRaw);
        }
        return *this; 
    }

    AutoPtrBase<_TYPE> & replace(const AutoPtrBase<_TYPE>& ptrOtherIn)
    {
        return *this = ptrOtherIn;
    }

    virtual operator _TYPE*() 
    { 
        return get(); 
    }

    virtual operator const _TYPE*() const 
    { 
        return get(); 
    }

/*  Not allowed, since void * wouldn't worl            
    _TYPE& operator*() const
    {
        return (*get()); 
    }
*/

    _TYPE ** operator&()
    {
        return _getoutptr();
    }

    // Will produce errors if applied using infix notation
    //#pragma warning(disable:4284)
//    _TYPE *operator->() const
//    {
//        return (get()); 
//    }
    //#pragma warning(default:4284)

    _TYPE *get() const
    {
        return (m_pRaw); 
    }

    _TYPE * _disownptr()
    {
        m_bOwns = FALSE;
        return m_pRaw; 
    }

    _TYPE ** _getoutptr() 
    { 
        if (m_bOwns)
            nukeit();
        m_bOwns = TRUE;
        return (&m_pRaw); 
    }
};

// AutoHLOCK
//

template<class _TYPE>
class AutoHLOCK : public AutoPtrBase<_TYPE>
{
private:

protected:

    HGLOBAL m_hGlobal;

    virtual void nukeit()
    {
        // If the memory object is still locked after decrementing the lock count, 
        // the return value is a nonzero value.  If the function fails, the return 
        // value is zero. To get extended error information, we call GetLastError. 
        // If GetLastError returns NO_ERROR, the memory object is unlocked.

        if (0 == GlobalUnlock( m_hGlobal) )
            assert(NO_ERROR == GetLastError());
    }

public:

    AutoHLOCK<_TYPE>& operator=(HGLOBAL _H)
    {
        if (m_hGlobal != _H)
        {
            if (m_bOwns)
                nukeit();
            m_pRaw = _H ? ((_TYPE*) GlobalLock(_H)) : NULL;
            m_bOwns = (NULL != m_pRaw);

            m_hGlobal = _H;

            assert( !m_bOwns || m_pRaw );
        }
        return *this;    
    }

    ~AutoHLOCK()
    {
        if (m_bOwns)
            this->nukeit();
    }

    AutoHLOCK(HGLOBAL _H = 0)
        : m_hGlobal(NULL)
    {
        *this = _H;
    }
};

// AutoHPALETTE (HPALETTE)
//

class AutoHPALETTE : public AutoPtrBase<struct HPALETTE__>
{
    virtual void nukeit()
    {
        DeleteObject((HPALETTE)m_pRaw);
    }

public:

    ~AutoHPALETTE()
    {
        if (m_bOwns)
            this->nukeit();
    }

    AutoHPALETTE(HPALETTE pRawIn = 0)
        : AutoPtrBase<struct HPALETTE__>(pRawIn)
    {
    }

};

/*
// AutoHPROPSHEETPAGE 
//

class AutoHPROPSHEETPAGE : public AutoPtrBase<struct _PSP>
{
    virtual void nukeit()
    {
        DestroyPropertySheetPage((HPROPSHEETPAGE)m_pRaw);
    }

public:

    ~AutoHPROPSHEETPAGE()
    {
        if (m_bOwns)
            this->nukeit();
    }

    AutoHPROPSHEETPAGE(HPROPSHEETPAGE pRawIn = 0)
        : AutoPtrBase<struct _PSP>(pRawIn)
    {
    }

};
*/

//
// AutoHKEY (HKEY)
//

class AutoHKEY : public AutoPtrBase<struct HKEY__>
{
    virtual void nukeit()
    {
        RegCloseKey((HKEY)m_pRaw);
    }

public:

    ~AutoHKEY()
    {
        if (m_bOwns)
            this->nukeit();
    }

    AutoHKEY(HKEY pRawIn = 0)
        : AutoPtrBase<struct HKEY__>(pRawIn)
    {
    }

};

// AutoHICON (HICON)
//

class AutoHICON : public AutoPtrBase<struct HICON__>
{
    virtual void nukeit()
    {
        DestroyIcon((HICON)m_pRaw);
    }

public:

    ~AutoHICON()
    {
        if (m_bOwns)
            this->nukeit();
    }

    AutoHICON& operator=(struct HICON__ * pRawIn)
    {
        take(pRawIn);
        return *this;
    }

    
    AutoHICON(HICON pRawIn = 0)
        : AutoPtrBase<struct HICON__>(pRawIn)
    {
    }

};

// AutoHBITMAP (HBITMAP)
//

class AutoHBITMAP : public AutoPtrBase<struct HBITMAP__>
{
    virtual void nukeit()
    {
        DeleteObject((HBITMAP)m_pRaw);
    }

public:

    ~AutoHBITMAP()
    {
        if (m_bOwns)
            this->nukeit();
    }

    AutoHBITMAP& operator=(struct HBITMAP__ * pRawIn)
    {
        take(pRawIn);
        return *this;
    }

    
    AutoHBITMAP(HBITMAP pRawIn = 0)
        : AutoPtrBase<struct HBITMAP__>(pRawIn)
    {
    }

};

// AutoHDC (HDC)
//

typedef pair<HDC, HWND> WindowDCPair;

class AutoHDC : public AutoPtrBase<WindowDCPair>
{
    // If this was from GetDC() call, we'll have the handle of the
    // window against which we will need to release it.  If not,
    // we assume we need to actually DeleteDC() on it.

    virtual void nukeit()
    {
        
        if (get()->second)
            ReleaseDC(get()->second, get()->first);
        else
            DeleteDC(get()->first);
    }

protected:

    HDC m_hDC;

public:

    ~AutoHDC()
    {
        if (m_bOwns)
            this->nukeit();
    }

    AutoHDC& operator=(HDC pRawIn)
    {
        take( &WindowDCPair(pRawIn, NULL) );
        return *this;
    }

    AutoHDC& operator=( WindowDCPair in)
    {
        take(&in);
        return *this;
    }
    
    AutoHDC(HDC hdc = NULL, HWND hwndFrom = NULL)
        : AutoPtrBase<WindowDCPair>( &WindowDCPair(hdc, hwndFrom) )
    {
    }

    AutoHDC(HWND hwndFrom)
        : AutoPtrBase<WindowDCPair>( &WindowDCPair(GetDC(hwndFrom), hwndFrom) )
    {
        if (NULL == get()->first)
            throw new win32error;
    }

    operator HDC() 
    { 
        return get()->first; 
    }

    operator const HDC() const 
    { 
        return get()->first; 
    }

};

// AutoHGLOBAL (HGLOBAL)
//

class AutoHGLOBAL : public AutoPtrBase<void>
{
    virtual void nukeit()
    {
        GlobalFree((HGLOBAL)m_pRaw);
    }

public:

    ~AutoHGLOBAL()
    {
        if (m_bOwns)
            this->nukeit();
    }

    AutoHGLOBAL(HGLOBAL pRawIn = 0)
        : AutoPtrBase<void>(pRawIn)
    {
    }

};


class AutoFindHandle
{
    public:
        AutoFindHandle(HANDLE handle = INVALID_HANDLE_VALUE)
            : m_handle(handle), m_bOwns(INVALID_HANDLE_VALUE != handle) { }

        AutoFindHandle(const AutoFindHandle& rhs)
            : m_handle(INVALID_HANDLE_VALUE), m_bOwns(false)
            { *this = rhs; }

        ~AutoFindHandle(void)
            { Close(); }

        void Close(void);

        HANDLE Detach(void) const
            { m_bOwns = false; return m_handle; }

        void Attach(HANDLE handle)
            { Close(); m_handle = handle; m_bOwns = true; }

        operator HANDLE() const
            { return m_handle; }

        bool IsValid(void) const
            { return INVALID_HANDLE_VALUE != m_handle; }

        AutoFindHandle& operator = (HANDLE handle)
            { Attach(handle); return *this; }

        AutoFindHandle& operator = (const AutoFindHandle& rhs);

    private:
        mutable HANDLE m_handle;
        mutable bool   m_bOwns;
};

// AutoPtr
//

template<class _TYPE>
class AutoPtr : public AutoPtrBase<_TYPE>
{
    virtual void nukeit()
    {
        delete m_pRaw;
    }

public:

    ~AutoPtr()
    {
        if (m_bOwns)
            this->nukeit();
    }

    AutoPtr(_TYPE *pRawIn = 0)
        : AutoPtrBase<_TYPE>(pRawIn)
    {
    }

    AutoPtr<_TYPE> & operator=(const AutoPtr<_TYPE> & ptrOther)
    {
        if (this != &ptrOther)
        {
            AutoPtr<_TYPE> * pptrOther = const_cast<AutoPtr<_TYPE> *>(&ptrOther);
            m_bOwns = pptrOther->m_bOwns;
            m_pRaw  = (_TYPE *) (pptrOther->_disownptr());
        }
        return *this;
    }

    AutoPtr(const AutoPtr<_TYPE> & ptrOther) 
    {
        *this = ptrOther;
    }

	// AutoPtr<_TYPE> & operator=(_TYPE * pRawIn)
    AutoPtr<_TYPE> & operator=(_TYPE * pRawIn)
    {
        take(pRawIn);
        return *this;
    }
};

// AutoComPtr
//
// Smart pointer that calls _disownptr() on the referent when the pointer itself
// goes out of scope

template <class _TYPE>
class AutoComPtr : public CComPtr<_TYPE>
{
    public:
        AutoComPtr(void) { }

        AutoComPtr(_TYPE *p)
            : CComPtr<_TYPE>(p) { }

        AutoComPtr(const AutoComPtr<_TYPE>& rhs)
            : CComPtr<_TYPE>(rhs.p) { }

        AutoComPtr& operator = (const AutoComPtr& rhs)
        {
            if (this != &rhs)
            {
                CComPtr<_TYPE>::operator = (rhs);
            }
            return *this;
        }

        //
        // Retrieve the address of the contained interface ptr.
        // ptr._getoutptr() is equivalent to &ptr.p
        //
        _TYPE **_getoutptr(void)
        {
            return &p;
        }

        _TYPE * _disownptr(void)
        {
            return Detach();
        }

        //
        // WARNING:  This hides the CComPtr implementation of operator&().
        //           It's intentional.  Otherwise you can't pass the address
        //           of an AutoComPtr to a function and get the expected semantics.
        //           CComPtr's implementation returns the address of the contained
        //           pointer.  If this is what you want, use AutoComtPtr::_getoutptr().
        //
        AutoComPtr *operator& (void)
        {
            return this;
        }
};




#ifdef USE_SHELL_AUTOPTR

#include <cshalloc.h>

// App must declare a global instance of this class

extern CSHAlloc g_SHAlloc;

// AutoShellPtr
//
// Smart pointer that manually runs the referent's destructor and then
// calls the shell's task allocator to free the object's memory footprint

template<class _TYPE>
class AutoShellPtr : virtual public AutoPtrBase<_TYPE>
{
    virtual void nukeit()
    {
        if (m_pRaw)
        {
            m_pRaw->~_TYPE();
            g_SHAlloc.Free(m_pRaw);
        }
    }

public:

    ~AutoShellPtr()
    {
        if (m_bOwns)
            this->nukeit();
    }

    AutoShellPtr(_TYPE *pRawIn = 0)
        : AutoPtrBase<_TYPE>(pRawIn)
    {
    }

    AutoShellPtr<_TYPE> & operator=(_TYPE * pRawIn)
    {
        take(pRawIn);
        return *this;
    }

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shtl\cidl.h ===
//+-------------------------------------------------------------------------
//
//  File:       cidl.h
//
//  Contents:   CIDList
//
//  History:    Sep-26-96  Davepl  Created (from old VZip code)
//
//--------------------------------------------------------------------------

#ifndef __PIDL_H__
#define __PIDL_H__

#include <shlobj.h>
#include "autoptr.h"
#include "tstring.h"
#include "cshalloc.h"

#define CB_IDLIST_TERMINATOR (sizeof(USHORT))

//
// CIDList - ITEMIDLIST wrapper class
//

class CIDList : public ITEMIDLIST
{
public:
    tstring GetPath() const;

    //
    // (LPITEMIDLIST) operator - allows silent casting of CIDlist to ITEMIDLIST
    //

    operator ITEMIDLIST() 
    {
        return *this;    
    }

    operator LPITEMIDLIST() 
    {
        return this;
    }

    //
    //  CombineWith - Adds another idlist to this one, result to a new idlist
    //

    HRESULT CombineWith(const CIDList * pidlwith, CIDList * * ppidlto);

    //
    // IsEmpty - returns TRUE if this is an empty (cb == 0) pidl
    //

    BOOL IsEmpty() const
    {
        return mkid.cb == 0 ? TRUE : FALSE;
    }

    //
    // IsDesktop - Checks to see if the pidl is empty, meaning desktop
    //

    BOOL IsDesktop() const
    {
        return IsEmpty();
    }

    //
    //  Skip - advance this pidl pointer by 'cb' bytes
    //

    CIDList * Skip(const UINT cb) const
    {
        return (CIDList *) (((BYTE *)this) + cb);
    }

    //
    //  Next - returns this next entry in this idlist
    //

    CIDList * Next() const
    {
        return  Skip(mkid.cb);
    }

    //
    //  FindChild -	Given _this_ as a parent pidl, and some pidlchild which is
    //                  a child of it, returns the portion of the child not found
    //                  in the parent.
    //

    const CIDList * FindChild (const CIDList * pidlchild) const;

    //
    //  IsParentOf - Tests whether or not _this_ pidl is a parent of some
    //               other pidl
    //

    BOOL IsParentOf(const CIDList * pidlother, BOOL fImmediate) const;

    //
    //  GetSize - returns the size, in bytes, of the IDList starting
    //            at this pidl
    //

    UINT GetSize() const
    {
        UINT cbTotal = 0;
        
        const CIDList * pidl = this;
        {
            // We need a NULL entry at the end, so adjust size accordingly

            cbTotal += CB_IDLIST_TERMINATOR;
            while (pidl->mkid.cb)
            {
                cbTotal += pidl->mkid.cb;
                pidl = pidl->Next();
            }   
        }
        return cbTotal;
    }

    //
    //  Clone - uses the shell's task allocator to allocate memory for
    //          a clone of this pidl (the _entire_ pidl starting here)
    //          and copies this pidl into that buffer
    //

    HRESULT CloneTo(CIDList * * ppidlclone) const
    {
        if (ppidlclone)
        {
            const UINT cb = GetSize();
            *ppidlclone = (CIDList *) g_SHAlloc.Alloc(cb);
            if (*ppidlclone)
            {
                memcpy(*ppidlclone, this, cb);
            }
        }
        return *ppidlclone ? S_OK : E_OUTOFMEMORY;
    }

    //
    // AppendPath - Append a text filesystem path to the idlist
    //

    HRESULT AppendPath(LPCTSTR pszPath, CIDList * * ppidlResult);

    //
    // GetIShellFolder - returns the IShellFolder interface for this idlist,
    //                   which assumes it is a folder pidl
    //

    HRESULT GetIShellFolder(IShellFolder ** pFolder);

    // FindLastID - Finds the last itemid at the end of this id list
    //

    CIDList * FindLastID()
    {
        CIDList * pidlLast = this;
        CIDList * pidlNext = this;

        // Scan to the end and return the last pidl

        while (pidlNext->mkid.cb)
        {
            pidlLast = pidlNext;
            pidlNext = pidlLast->Next();
        }
    
        return pidlLast;
    }

    //
    // RemoveLastID - chops the last child idlist off the end of
    //                this chain
    //

    void RemoveLastID()
    {
        if (FALSE == IsEmpty())
        {
            CIDList * pidlLast = FindLastID();
            
            // Remove the last one

            pidlLast->mkid.cb = 0; 
        }
    }
};

// void StrRetToTString(CIDList * pidl, LPSTRRET lpStr, tstring &str);

#endif // __PIDL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shtl\cidl.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Silicon Prairie Software, 1996
//
//  File:       pidl.cpp
//
//  Contents:   CIDList
//
//  History:    9-26-95  Davepl  Created
//
//--------------------------------------------------------------------------


#include "shtl.h"
#include "cidl.h"
#include "shellapi.h"


//
// CombineWith - Adds another pidl with this one, puts the result at
// a new pidl ptr passed in
//

__DATL_INLINE HRESULT CIDList::CombineWith(const CIDList * pidlwith, CIDList ** ppidlto)
{
    UINT cb1 = this->GetSize() - CB_IDLIST_TERMINATOR;
    UINT cb2 = pidlwith->GetSize();

    *ppidlto = (CIDList *) g_SHAlloc.Alloc(cb1 + cb2);
    if (NULL == *ppidlto)
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory(*ppidlto, this, cb1);
    CopyMemory((((LPBYTE)*ppidlto) + cb1), pidlwith, cb2);
    
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     CIDList::IsParent
//
//  Synopsis:   Tests whether or not _this_ pidl is a parent of some
//              other pidl
//
//  Returns:    BOOL - TRUE if we are a child of the other pidl
//
//  History:    5-15-95 DavePl  Created
//
//--------------------------------------------------------------------------

__DATL_INLINE BOOL CIDList::IsParentOf(const CIDList * pidlother, BOOL fImmediate) const
{
    ptrdiff_t cb;

    if (NULL == pidlother)
    {
        return FALSE;
    }

    const CIDList * pidlthisT  = this;
    const CIDList * pidlotherT = pidlother;

    //
    // Walk to the end of _this_ pidl.  If we run out of hops on the other
    // pidl, its shorter than us so we can't be its parent

    while(FALSE == pidlthisT->IsEmpty())
    {
        if (pidlotherT->IsEmpty())
        {
            return FALSE;
        }
        pidlthisT  = pidlthisT->Next();
        pidlotherT = pidlotherT->Next();
    }

    //
    // If caller wants to know if we're the _immediate_ parent, we should
    // be empty at this point and the other pidl should have exactly
    // one entry left
    //
       
    if (fImmediate)
    {
        if (pidlotherT->IsEmpty() || FALSE == pidlotherT->Next()->IsEmpty())
        {
            return FALSE;
        }
    }

    //
    // Create a new IDList from a portion of pidl2, which contains the
    // same number of IDs as pidl1.
    //

    cb = pidlotherT - pidlother;

    //
    // BUGBUG It's probably not valid to binary compare the pidls up to this point,
    // but since the shell doesn't expose a better mechanism for us to use...
    //

    if (0 == memcmp(pidlother, this, cb))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CIDList::FindChild
//
//  Synopsis:   Given _this_ as a parent pidl, and some pidlchild which is
//              a child of it, returns the portion of the child not found
//              in the parent.
//
//              ie: this    == c:\foo\bar
//                  child   == c:\foo\bar\etc
//                  return  == \etc
//
//  Returns:    Uncommon child portion.  NULL if child is not really our child.
//
//  History:    5-15-95 DavePl  Created
//
//  Notes:      Does _not_ allocate a new pidl, just returns a ptr into the 
//              child.
//
//--------------------------------------------------------------------------

__DATL_INLINE const CIDList * CIDList::FindChild(const CIDList * pidlchild) const
{
    const CIDList * pidlparent = this;

    if (IsParentOf(pidlchild, FALSE))
    {
        while (FALSE == pidlparent->IsEmpty())
        {
            pidlchild  = pidlchild->Next();
            pidlparent = pidlparent->Next();
        }
        return pidlchild;
    }
    return NULL;
}

// CIDList::GetIShellFolder
//
// Returns the IShellFolder implementation for this idlist

__DATL_INLINE HRESULT CIDList::GetIShellFolder(IShellFolder ** ppFolder)
{
    IShellFolder * pDesktop = NULL;
    HRESULT hr = SHGetDesktopFolder(&pDesktop);
    if (SUCCEEDED(hr))
        hr = pDesktop->BindToObject(this, NULL, IID_IShellFolder, (void **)ppFolder);
    
    if (pDesktop)
        pDesktop->Release();

    return hr;
}

// CIDList::AppendPath
//
// Given an idlist, which must be a folder, adds a text path to it

__DATL_INLINE HRESULT CIDList::AppendPath(LPCTSTR pszPath, CIDList ** ppidlResult)
{
    IShellFolder * pFolder = NULL;
    HRESULT hr = GetIShellFolder(&pFolder);
    if (SUCCEEDED(hr))
    {
        CIDList * pidlNew = NULL;

        #if defined(UNICODE) || defined(_UNICODE)
            LPCWSTR pwszPath = pszPath;
        #else
            WCHAR pwszPath[MAX_PATH];
            VERIFY( MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszPath, -1, pwszPath, MAX_PATH) );
        #endif
        
        ULONG chEaten;
        hr = pFolder->ParseDisplayName(NULL, NULL, const_cast<LPWSTR>(pwszPath), &chEaten, (LPITEMIDLIST *)&pidlNew, NULL);
        if (SUCCEEDED(hr))
        {
            CIDList * pidlResult = NULL;
            hr = CombineWith(pidlNew, ppidlResult);
        }
        g_SHAlloc.Free(pidlNew);
    }
    if (pFolder)
        pFolder->Release();

    return hr;
}

//
// StrRetToTString - Gets a TString from a strret structure
//
// PrintStrRet - prints the contents of a STRRET structure.  
// pidl - PIDL containing the display name if STRRET_OFFSET  
// lpStr - address of the STRRET structure 
//

/*
__DATL_INLINE void StrRetToCString(CIDList * pCidl, LPSTRRET lpStr, tstring &str) 
{ 
    LPSTR lpsz; 
    int cch; 
 
    switch (lpStr->uType) 
    { 
 
        case STRRET_WSTR: 
    
            cch = WideCharToMultiByte(CP_ACP, 0, 
                lpStr->pOleStr, -1, NULL, 0, NULL, NULL); 

            lpsz = new char[cch];
            if (lpsz != NULL) { 
                WideCharToMultiByte(CP_ACP, 0, 
                    lpStr->pOleStr, -1, lpsz, cch, NULL, NULL); 
                str = lpsz; 
                delete [] lpsz;
            } 
            break; 
 
        case STRRET_OFFSET: 
            str = (((char *) pCidl) + lpStr->uOffset); 
            break; 
 
        case STRRET_CSTR: 
            str = lpStr->cStr; 
            break; 
    } 
} 
*/

__DATL_INLINE tstring CIDList::GetPath() const
{
    tstring strPath;

    if (FALSE == SHGetPathFromIDList(this, strPath.GetBuffer(MAX_PATH)))
        throw new dexception(E_OUTOFMEMORY);
    
    strPath.ReleaseBuffer(-1);

    return strPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shtl\cshalloc.h ===
//+-------------------------------------------------------------------------
//
//  File:       shalloc.h
//
//  Contents:   CSHAlloc
//
//  Purpose:    A wrapper class for the shell's task allocator.  Loads the
//              shell's allocator on first contstruction, and if that fails,
//              subsequent uses of this allocator will fail as appropriate.
//
//--------------------------------------------------------------------------

#ifndef __SHALLOC_H__
#define __SHALLOC_H__

#include <shlobj.h>

class CSHAlloc : public IMalloc
{
    IMalloc * m_pMalloc;
    DWORD     m_cRefs;

public:

    CSHAlloc(BOOL bInitOle = TRUE);
    ~CSHAlloc();

    // IUnknown methods

    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, void * * ppvObj);
    STDMETHOD_(ULONG,  AddRef)      (THIS_);
    STDMETHOD_(ULONG,  Release)     (THIS_);

    // IMalloc methods

    STDMETHOD_(void *, Alloc)       (THIS_ SIZE_T cb);
    STDMETHOD_(void,   Free)        (THIS_ void * pv);
    STDMETHOD_(void *, Realloc)     (THIS_ void * pv, SIZE_T cb);
    STDMETHOD_(SIZE_T,  GetSize)     (THIS_ void * pv);
    STDMETHOD_(int,    DidAlloc)    (THIS_ void * pv);
    STDMETHOD_(void,   HeapMinimize)(THIS_);
};

// App must declare a global instance of this class

extern CSHAlloc g_SHAlloc;

#endif // __SHALLOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shtl\cshalloc.cpp ===
//+-------------------------------------------------------------------------
//
//  File:       cshalloc.cpp
//
//  Contents:   CSHAlloc
//
//--------------------------------------------------------------------------

#include "shtl.h"
#include <cshalloc.h>

// CSHAlloc::QueryInterface

__DATL_INLINE HRESULT CSHAlloc::QueryInterface(REFIID riid, void ** ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IMalloc))
        *ppvObj = (IMalloc *) this;

    return (*ppvObj) ? S_OK : E_NOINTERFACE;
}

// CSHAlloc::AddRef

__DATL_INLINE ULONG CSHAlloc::AddRef()
{
    return ++m_cRefs;
}

// CSHAlloc::Release

__DATL_INLINE ULONG CSHAlloc::Release()
{
    if (InterlockedDecrement((LONG *) &m_cRefs))
    {
        return 1;
    }
    else
    {
        delete this;
        return 0;
    }
}

// CSHAlloc Constructor
//
// Load the shell's allocator.  Failure will cause subsequent allocs to fail.

__DATL_INLINE CSHAlloc::CSHAlloc(BOOL bInitOle) : m_pMalloc(NULL)
{
    // If you pass FALSE for this, you can't use it (you likely did so
    // just to avoid link errors)

    if (bInitOle)
        SHGetMalloc(&m_pMalloc);
}

__DATL_INLINE CSHAlloc::~CSHAlloc()
{
    if (m_pMalloc)
        m_pMalloc->Release();
}

// CSHAlloc::Alloc

__DATL_INLINE void * CSHAlloc::Alloc(SIZE_T cb)
{
    return (m_pMalloc) ? m_pMalloc->Alloc(cb) : NULL;
}

// CSHAlloc::Free

__DATL_INLINE void CSHAlloc::Free(void * pv)
{
    if (m_pMalloc)
        m_pMalloc->Free(pv);
}

// CSHAlloc::Realloc

__DATL_INLINE void * CSHAlloc::Realloc(void * pv, SIZE_T cb)
{
    return (m_pMalloc) ? m_pMalloc->Realloc(pv, cb) : NULL;
}

// CSHAlloc::GetSize

__DATL_INLINE SIZE_T CSHAlloc::GetSize(void * pv)
{
    return (m_pMalloc) ? m_pMalloc->GetSize(pv) : 0;
}

// CSHAlloc::DidAlloc

__DATL_INLINE int CSHAlloc::DidAlloc(void * pv)
{
    return (m_pMalloc) ? m_pMalloc->DidAlloc(pv) : FALSE;
}

__DATL_INLINE void CSHAlloc::HeapMinimize()
{
    if (m_pMalloc)
        m_pMalloc->HeapMinimize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shtl\dexception.h ===
// dexception
//
// Exception class

#pragma once

#include "shtl.h"
#include "tstring.h"

using namespace std;

class dexception
{
protected:

    enum
    {
        hresult, text, unknown
    } m_type;

    tstring m_text;
    HRESULT m_hr;

public:

    virtual ~dexception()
    {}

    dexception() :
        m_type(unknown)
    {}

    dexception(const char * psz) :
        m_type(text),
        m_text(psz)
    {}

    dexception(const tstring& xs) :
        m_type(text),
        m_text(xs)
    {}

    dexception(const DWORD& dwError) :
        m_type(hresult),
        m_hr(HRESULT_FROM_WIN32(dwError))
    {}

    dexception(const HRESULT& hr) :
        m_type(hresult),
        m_hr(hr)
    {}

    operator const HRESULT() const
    {
        return (m_type == hresult) ? m_hr : E_UNEXPECTED;                
    }

    tstring GetErrorText()
    {
        if (m_type == text)
            return m_text;

        if (m_text.length())
            return m_text;

        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
              NULL,
              m_hr,
              LANG_USER_DEFAULT,
              m_text.GetBuffer(255),
              255,
              NULL);
        m_text.ReleaseBuffer(-1);
        return m_text;
    }
};

// errorinfo_exception
//
// Exception class that knows how to set the last error for this
// thread using the IErrorInfo object

class errorinfo_exception : public dexception
{
  private:
    
    CLSID    m_clsid;
    IID      m_iid;
    tstring  m_str;
 
  public:

    errorinfo_exception(const tstring & str, 
                        const HRESULT & hr, 
                        const CLSID   & clsid, 
                        const IID     & iid)
        : dexception(hr),
          m_clsid(clsid),
          m_iid(iid),
          m_str(str)
    {
        ASSERT(FAILED(hr));
    }

    HRESULT ReportError() const
    {
        return AtlReportError(m_clsid, m_str, m_iid, m_hr);
    }

};

// win32error
//
// Exception class that looks at GetLastError.  By default, will
// use E_UNEXPECTED if GetLastError was not actually set by failing API.

class win32error : public dexception
{
public:

    win32error(bool bEnsureFailure = true) 
    {   
        DWORD dwError = GetLastError();
        m_type = hresult;
        m_hr = (dwError || !bEnsureFailure) ? HRESULT_FROM_WIN32(dwError) : E_UNEXPECTED;
    }   
};

// CATCH_AND_RETURN_AS_HRESULT
//
// Protects a block of code (such as an interface implementation) that can throw
// our exceptions, and if it catches any, converts to an HRESULT and returns it
// to the caller

#define CATCH_AND_RETURN_AS_HRESULT     \
    catch(const errorinfo_exception & e)\
    {                                   \
        return e.ReportError();         \
    }                                   \
    catch(const dexception & d)         \
    {                                   \
        return (HRESULT) d;             \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shtl\dvariant.h ===
//+-------------------------------------------------------------------------
//
//  File:       dvariant.h
//
//  Contents:   dvariant
//
//  History:    Sep-09-99  Davepl  Like dvariant, but with type operators
//
//--------------------------------------------------------------------------

#ifndef __DVARIANT_H__
#define __DVARIANT_H__

#include "dexception.h"

class dvariant : public tagVARIANT
{
// Constructors
public:
	dvariant()
	{
		vt = VT_EMPTY;
	}
	~dvariant()
	{
		Clear();
	}

	dvariant(const VARIANT& varSrc)
	{
		vt = VT_EMPTY;
		InternalCopy(&varSrc);
	}

	dvariant(const dvariant& varSrc)
	{
		vt = VT_EMPTY;
		InternalCopy(&varSrc);
	}

	dvariant(BSTR bstrSrc)
	{
		vt = VT_EMPTY;
		*this = bstrSrc;
	}
	dvariant(LPCOLESTR lpszSrc)
	{
		vt = VT_EMPTY;
		*this = lpszSrc;
	}

#ifndef OLE2ANSI
	dvariant(LPCSTR lpszSrc)
	{
		vt = VT_EMPTY;
		*this = lpszSrc;
	}
#endif

	dvariant(bool bSrc)
	{
		vt = VT_BOOL;
#pragma warning(disable: 4310) // cast truncates constant value
		boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	}

	dvariant(int nSrc)
	{
		vt = VT_I4;
		lVal = nSrc;
	}
	dvariant(BYTE nSrc)
	{
		vt = VT_UI1;
		bVal = nSrc;
	}
	dvariant(short nSrc)
	{
		vt = VT_I2;
		iVal = nSrc;
	}
	dvariant(long nSrc, VARTYPE vtSrc = VT_I4)
	{
		ATLASSERT(vtSrc == VT_I4 || vtSrc == VT_ERROR);
		vt = vtSrc;
		lVal = nSrc;
	}
	dvariant(float fltSrc)
	{
		vt = VT_R4;
		fltVal = fltSrc;
	}
	dvariant(double dblSrc)
	{
		vt = VT_R8;
		dblVal = dblSrc;
	}
	dvariant(CY cySrc)
	{
		vt = VT_CY;
		cyVal.Hi = cySrc.Hi;
		cyVal.Lo = cySrc.Lo;
	}
	dvariant(IDispatch* pSrc)
	{
		vt = VT_DISPATCH;
		pdispVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (pdispVal != NULL)
			pdispVal->AddRef();
	}
	dvariant(IUnknown* pSrc)
	{
		vt = VT_UNKNOWN;
		punkVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (punkVal != NULL)
			punkVal->AddRef();
	}

// Assignment Operators
public:
	dvariant& operator=(const dvariant& varSrc)
	{
		InternalCopy(&varSrc);
		return *this;
	}
	dvariant& operator=(const VARIANT& varSrc)
	{
		InternalCopy(&varSrc);
		return *this;
	}

	dvariant& operator=(BSTR bstrSrc)
	{
		InternalClear();
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(bstrSrc);
		if (bstrVal == NULL && bstrSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
		}
		return *this;
	}

	dvariant& operator=(LPCOLESTR lpszSrc)
	{
		InternalClear();
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(lpszSrc);

		if (bstrVal == NULL && lpszSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
		}
		return *this;
	}

	#ifndef OLE2ANSI
	dvariant& operator=(LPCSTR lpszSrc)
	{
		USES_CONVERSION;
		InternalClear();
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(A2COLE(lpszSrc));

		if (bstrVal == NULL && lpszSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
		}
		return *this;
	}
	#endif

	dvariant& operator=(bool bSrc)
	{
		if (vt != VT_BOOL)
		{
			InternalClear();
			vt = VT_BOOL;
		}
	#pragma warning(disable: 4310) // cast truncates constant value
		boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
	#pragma warning(default: 4310) // cast truncates constant value
		return *this;
	}

	dvariant& operator=(int nSrc)
	{
		if (vt != VT_I4)
		{
			InternalClear();
			vt = VT_I4;
		}
		lVal = nSrc;

		return *this;
	}

	dvariant& operator=(BYTE nSrc)
	{
		if (vt != VT_UI1)
		{
			InternalClear();
			vt = VT_UI1;
		}
		bVal = nSrc;
		return *this;
	}

	dvariant& operator=(short nSrc)
	{
		if (vt != VT_I2)
		{
			InternalClear();
			vt = VT_I2;
		}
		iVal = nSrc;
		return *this;
	}

	dvariant& operator=(long nSrc)
	{
		if (vt != VT_I4)
		{
			InternalClear();
			vt = VT_I4;
		}
		lVal = nSrc;
		return *this;
	}

	dvariant& operator=(float fltSrc)
	{
		if (vt != VT_R4)
		{
			InternalClear();
			vt = VT_R4;
		}
		fltVal = fltSrc;
		return *this;
	}

	dvariant& operator=(double dblSrc)
	{
		if (vt != VT_R8)
		{
			InternalClear();
			vt = VT_R8;
		}
		dblVal = dblSrc;
		return *this;
	}

	dvariant& operator=(CY cySrc)
	{
		if (vt != VT_CY)
		{
			InternalClear();
			vt = VT_CY;
		}
		cyVal.Hi = cySrc.Hi;
		cyVal.Lo = cySrc.Lo;
		return *this;
	}

	dvariant& operator=(IDispatch* pSrc)
	{
		InternalClear();
		vt = VT_DISPATCH;
		pdispVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (pdispVal != NULL)
			pdispVal->AddRef();
		return *this;
	}

	dvariant& operator=(IUnknown* pSrc)
	{
		InternalClear();
		vt = VT_UNKNOWN;
		punkVal = pSrc;

		// Need to AddRef as VariantClear will Release
		if (punkVal != NULL)
			punkVal->AddRef();
		return *this;
	}


// Comparison Operators
public:
	bool operator==(const VARIANT& varSrc) const
	{
		if (this == &varSrc)
			return true;

		// Variants not equal if types don't match
		if (vt != varSrc.vt)
			return false;

		// Check type specific values
		switch (vt)
		{
			case VT_EMPTY:
			case VT_NULL:
				return true;

			case VT_BOOL:
				return boolVal == varSrc.boolVal;

			case VT_UI1:
				return bVal == varSrc.bVal;

			case VT_I2:
				return iVal == varSrc.iVal;

			case VT_I4:
				return lVal == varSrc.lVal;

			case VT_R4:
				return fltVal == varSrc.fltVal;

			case VT_R8:
				return dblVal == varSrc.dblVal;

			case VT_BSTR:
				return (::SysStringByteLen(bstrVal) == ::SysStringByteLen(varSrc.bstrVal)) &&
						(::memcmp(bstrVal, varSrc.bstrVal, ::SysStringByteLen(bstrVal)) == 0);

			case VT_ERROR:
				return scode == varSrc.scode;

			case VT_DISPATCH:
				return pdispVal == varSrc.pdispVal;

			case VT_UNKNOWN:
				return punkVal == varSrc.punkVal;

			default:
				ATLASSERT(false);
				// fall through
		}

		return false;
	}
	bool operator!=(const VARIANT& varSrc) const {return !operator==(varSrc);}
	bool operator<(const VARIANT& varSrc) const {return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT)==VARCMP_LT;}
	bool operator>(const VARIANT& varSrc) const {return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT)==VARCMP_GT;}

// Operations
public:
	HRESULT Clear() { return ::VariantClear(this); }
	HRESULT Copy(const VARIANT* pSrc) { return ::VariantCopy(this, const_cast<VARIANT*>(pSrc)); }
	HRESULT Attach(VARIANT* pSrc)
	{
		// Clear out the variant
		HRESULT hr = Clear();
		if (!FAILED(hr))
		{
			// Copy the contents and give control to dvariant
			memcpy(this, pSrc, sizeof(VARIANT));
			pSrc->vt = VT_EMPTY;
			hr = S_OK;
		}
		return hr;
	}

	HRESULT Detach(VARIANT* pDest)
	{
		// Clear out the variant
		HRESULT hr = ::VariantClear(pDest);
		if (!FAILED(hr))
		{
			// Copy the contents and remove control from dvariant
			memcpy(pDest, this, sizeof(VARIANT));
			vt = VT_EMPTY;
			hr = S_OK;
		}
		return hr;
	}

	HRESULT ChangeType(VARTYPE vtNew, const VARIANT* pSrc = NULL)
	{
		VARIANT* pVar = const_cast<VARIANT*>(pSrc);
		// Convert in place if pSrc is NULL
		if (pVar == NULL)
			pVar = this;
		// Do nothing if doing in place convert and vts not different
		return ::VariantChangeType(this, pVar, 0, vtNew);
	}

	HRESULT WriteToStream(IStream* pStream);
	HRESULT ReadFromStream(IStream* pStream);

// Implementation
public:
	HRESULT InternalClear()
	{
		HRESULT hr = Clear();
		ATLASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
		{
			vt = VT_ERROR;
			scode = hr;
		}
		return hr;
	}

	void InternalCopy(const VARIANT* pSrc)
	{
		HRESULT hr = Copy(pSrc);
		if (FAILED(hr))
		{
			vt = VT_ERROR;
			scode = hr;
		}
	}

    // Need other operators?  Add them...

    operator BSTR()
    {
        if (vt != VT_BSTR)
            THROW_IF_FAILS( ChangeType(VT_BSTR) );
        return bstrVal;
    }

    operator tstring()
    {
        return tstring( (BSTR)*this );
    }

    operator long()
    {
        if (vt != VT_I4)
            THROW_IF_FAILS( ChangeType(VT_I4) );
        return lVal;
    }

    operator FILETIME()
    {
        if (vt != VT_FILETIME)
            THROW_IF_FAILS( ChangeType(VT_DATE) );
        
        SYSTEMTIME st;
        if (!VariantTimeToSystemTime( date, &st))
            throw win32error();

        FILETIME ft;
        if (!SystemTimeToFileTime(&st, &ft))
            throw win32error();

        return ft;
    }
};

#endif // __DVARIANT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shtl\invsemaphore.h ===
// CResGuard
// CSysGlobalType
// CSysGlobalScalar
// CInterlockedType
// CInverseSemaphore

#ifndef __SYSGLOB_H__
#define __SYSGLOB_H__

#include <assert.h>

// Instances of this class will be accessed by mutiple threads. So, 
// all members of this class (except the constructor and destructor) 
// must be thread-safe.

class CResGuard 
{
private:
    
    HANDLE m_hMutex;
    long   m_lGrdCnt;   // # of C calls

public:

    CResGuard(void * pObjectAddr)  
    { 
        TCHAR szObjectName[32];
        wsprintf(szObjectName, TEXT("CResGuard :: %08X"), (DWORD) pObjectAddr);
        m_lGrdCnt = 0; 
        m_hMutex = CreateMutex(NULL, FALSE, szObjectName);
        assert(m_hMutex);
    }
    
    ~CResGuard() 
    { 
        CloseHandle(m_hMutex); 
    }

    // IsGuarded is used for debugging
    
    BOOL IsGuarded() const 
    { 
        return(m_lGrdCnt > 0); 
    }

public:
	
    class CGuard 
    {
    private:

	CResGuard& m_rg;

    public:

        CGuard(CResGuard& rg) : m_rg(rg) 
        { 
            m_rg.Guard(); 
        };

        ~CGuard() 
        { 
            m_rg.Unguard(); 
        }

    };

private:

    void Guard()   
    { 
        assert(WAIT_OBJECT_0 == WaitForSingleObject(m_hMutex, INFINITE));
        m_lGrdCnt++; 
    }
    
    void Unguard() 
    { 
        m_lGrdCnt--; 
        ReleaseMutex(m_hMutex);
    }

    // Guard/Unguard can only be accessed by the nested CGuard class.
    friend class CResGuard::CGuard;
};


// Instances of this class will be accessed by mutiple threads. So, 
// all members of this class (except the constructor and destructor) 
// must be thread-safe.

template <class TYPE>
class CInterlockedType 
{
private:  

    TYPE * m_pTVal;

protected:  
   
    mutable CResGuard m_rg;

public:     

    // Public member functions
    // Note: Constructors & destructors are always thread safe
   
    CInterlockedType(TYPE * const pTVal) : m_rg( pTVal )
    { 
        m_pTVal = pTVal; 
    }

    virtual ~CInterlockedType()  
    { 
    }

    // Cast operator to make writing code that uses 
    // thread-safe data type easier
   
    operator TYPE() const 
    { 
        CResGuard::CGuard x(m_rg); 
        return(GetVal()); 
    }

protected:  // Protected function to be called by derived class
   
    TYPE& GetVal() 
    { 
        assert(m_rg.IsGuarded()); 
        return(*m_pTVal); 
    }

    const TYPE& GetVal() const 
    { 
        assert(m_rg.IsGuarded()); 
        return(*m_pTVal); 
    }

    TYPE SetVal(const TYPE& TNewVal) 
    { 
        assert(m_rg.IsGuarded()); 
        TYPE& TVal = GetVal();
        if (TVal != TNewVal) 
        {
            TYPE TPrevVal = TVal;
            TVal = TNewVal;
            OnValChanged(TNewVal, TPrevVal);
        }
        return(TVal); 
    }

protected:  // Overridable functions
   
    virtual void OnValChanged(const TYPE& TNewVal, const TYPE& TPrevVal) const 
    { 
        // Nothing to do here
    }

};


// Instances of this class will be accessed by mutiple threads. So, 
// all members of this class (except the constructor and destructor) 
// must be thread-safe.

template <class TYPE> 
class CSysGlobalScalar : protected CInterlockedType<TYPE> 
{
public:
    
    CSysGlobalScalar(TYPE * pTVal) : CInterlockedType<TYPE>(pTVal) 
    { 
    }

    ~CSysGlobalScalar() 
    {
    }

   // C++ does not allow operator cast to be inherited.

    operator TYPE() const 
    { 
        return(CInterlockedType<TYPE>::operator TYPE()); 
    }

    TYPE operator=(TYPE TVal) 
    { 
        CResGuard::CGuard x(m_rg); 
        return(SetVal(TVal)); 
    }

    TYPE operator++(int)                    // Postfix increment operator
    {    
        CResGuard::CGuard x(m_rg);
        TYPE TPrevVal = GetVal();
        SetVal(TPrevVal + 1);
        return(TPrevVal);                   // Return value BEFORE increment
    }

    TYPE operator--(int)                    // Postfix decrement operator.
    {    
        CResGuard::CGuard x(m_rg);
        TYPE TPrevVal = GetVal();
        SetVal(TPrevVal - 1);
        return(TPrevVal);                   // Return value BEFORE decrement
    }

   TYPE operator += (TYPE op)   
      { CResGuard::CGuard x(m_rg); return(SetVal(GetVal() +  op)); }

   TYPE operator++()            
      { CResGuard::CGuard x(m_rg); return(SetVal(GetVal() +   1)); }

   TYPE operator -= (TYPE op)   
      { CResGuard::CGuard x(m_rg); return(SetVal(GetVal() -  op)); }

   TYPE operator--()            
      { CResGuard::CGuard x(m_rg); return(SetVal(GetVal() -   1)); }

   TYPE operator *= (TYPE op)   
      { CResGuard::CGuard x(m_rg); return(SetVal(GetVal() *  op)); }

   TYPE operator /= (TYPE op)   
      { CResGuard::CGuard x(m_rg); return(SetVal(GetVal() /  op)); }

   TYPE operator %= (TYPE op)   
      { CResGuard::CGuard x(m_rg); return(SetVal(GetVal() %  op)); }

   TYPE operator ^= (TYPE op)   
      { CResGuard::CGuard x(m_rg); return(SetVal(GetVal() ^  op)); }

   TYPE operator &= (TYPE op)   
      { CResGuard::CGuard x(m_rg); return(SetVal(GetVal() &  op)); }

   TYPE operator |= (TYPE op)   
      { CResGuard::CGuard x(m_rg); return(SetVal(GetVal() |  op)); }

   TYPE operator <<=(TYPE op)   
      { CResGuard::CGuard x(m_rg); return(SetVal(GetVal() << op)); }

   TYPE operator >>=(TYPE op)   
      { CResGuard::CGuard x(m_rg); return(SetVal(GetVal() >> op)); }
};

// CSysGlobalHandle
//
// Same as CSysGlobalScalar, but without all the operators that would
// work on only scalars

template <class TYPE> 
class CSysGlobalHandle : protected CInterlockedType<TYPE> 
{
public:
    
    CSysGlobalHandle(TYPE * pTVal) : CInterlockedType<TYPE>(pTVal) 
    { 
    }

    ~CSysGlobalHandle() 
    {
    }

   // C++ does not allow operator cast to be inherited.

    operator TYPE() const 
    { 
        return(CInterlockedType<TYPE>::operator TYPE()); 
    }

    TYPE operator=(TYPE TVal) 
    { 
        CResGuard::CGuard x(m_rg); 
        return(SetVal(TVal)); 
    }

};

// Instances of this class will be accessed by mutiple threads. So, 
// all members of this class (except the constructor and destructor) 
// must be thread-safe.

template <class TYPE> class CInverseSemaphore : 
    public CSysGlobalScalar<TYPE> 
{
public:

    CInverseSemaphore(TYPE * pTVal, BOOL fManualReset = TRUE) : CSysGlobalScalar<TYPE>(pTVal) 
    {
        // The event should be signaled if TVal is 0
        m_hevtZero = CreateEvent(NULL, fManualReset, (*pTVal == 0), NULL);

        // The event should be signaled if TVal is NOT 0
        m_hevtNotZero = CreateEvent(NULL, fManualReset, (*pTVal != 0), NULL);
    }

    ~CInverseSemaphore() 
    {
        CloseHandle(m_hevtZero);
        CloseHandle(m_hevtNotZero);
    }

    // C++ does not allow operator= to be inherited.
    TYPE operator=(TYPE x) 
    { 
        return(CSysGlobalScalar<TYPE>::operator=(x)); 
    }

    // Return handle to event signaled when value is zero
    
    operator HANDLE() const 
    { 
        return(m_hevtZero); 
    }

    // Return handle to event signaled when value is not zero
    
    HANDLE GetNotZeroHandle() const 
    { 
        return(m_hevtNotZero); 
    }

    // C++ does not allow operator cast to be inherited.
    
    operator TYPE() const 
    { 
        return(CSysGlobalScalar<TYPE>::operator TYPE()); 
    }

protected:
   
    void OnValChanged(const TYPE& TNewVal, const TYPE& TPrevVal) const 
    { 
        // For best performance, avoid jumping to 
        // kernel mode if we don't have to
      
        if ((TNewVal == 0) && (TPrevVal != 0)) 
        {
            SetEvent(m_hevtZero);
            ResetEvent(m_hevtNotZero);
        }
      
        if ((TNewVal != 0) && (TPrevVal == 0)) 
        {
            ResetEvent(m_hevtZero);
            SetEvent(m_hevtNotZero);
        }
    }

private:
   
    HANDLE m_hevtZero;      // Signaled when data value is 0
    HANDLE m_hevtNotZero;   // Signaled when data value is not 0
};

#endif   // __SYSGLOB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shtl\misc.h ===
class DSize;
class DPoint;
class DRect;

inline bool boolify(BOOL b) 
{ 
    #pragma warning(disable:4800)
    return static_cast<bool>(b); 
    #pragma warning(default:4800)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shtl\shtl.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	datl.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "shtl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shtl\tpath.cpp ===
//  FILE:  tpath.h
//  AUTHOR: BrianAu
//  REMARKS:

#include "shtl.h"
#include "tpath.h"
#include <xutility>

using namespace std;

__DATL_INLINE tpath::tpath(
    LPCTSTR pszRoot, 
    LPCTSTR pszDir, 
    LPCTSTR pszFile, 
    LPCTSTR pszExt
    )
{
    if (pszDir)
        SetPath(pszDir);
    if (pszRoot)
        SetRoot(pszRoot);
    if (pszFile)
        SetFileSpec(pszFile);
    if (pszExt)
        SetExtension(pszExt);
}


__DATL_INLINE tpath::tpath(
    const tpath& rhs
    ) : tstring(rhs)
{

}

    
__DATL_INLINE tpath& 
tpath::operator = (
    const tpath& rhs
    )
{
    if (this != &rhs)
    {
        tstring::operator = (rhs);
    }
    return *this;
}


__DATL_INLINE tpath& 
tpath::operator = (
    LPCTSTR rhs
    )
{
    tstring::operator = (rhs);
    return *this;
}


__DATL_INLINE void
tpath::AddBackslash(
    void
    )
{
    ::PathAddBackslash(GetBuffer(max(MAX_PATH, length() + 2)));
    ReleaseBuffer();
}

__DATL_INLINE void
tpath::RemoveBackslash(
    void
    )
{
    ::PathRemoveBackslash(GetBuffer());
    ReleaseBuffer();
}

__DATL_INLINE bool 
tpath::GetRoot(
    tpath *pOut
    ) const
{
    tpath temp(*this);
    temp.StripToRoot();
    *pOut = temp;
    return 0 < pOut->length();
}

__DATL_INLINE bool 
tpath::GetPath(
    tpath *pOut
    ) const
{
    tpath temp(*this);
    temp.RemoveFileSpec();
    *pOut = temp;
    return 0 < pOut->length();
}

__DATL_INLINE bool
tpath::GetDirectory(
    tpath *pOut
    ) const
{
    if (GetPath(pOut))
        pOut->RemoveRoot();

    return 0 < pOut->length();
}

__DATL_INLINE bool 
tpath::GetExtension(
    tpath *pOut
    ) const
{
    *pOut = ::PathFindExtension(*this);
    return 0 < pOut->length();
}


__DATL_INLINE bool 
tpath::GetFileSpec(
    tpath *pOut
    ) const
{
    *pOut = ::PathFindFileName(*this);
    return 0 < pOut->length();
}
    

__DATL_INLINE bool 
tpath::Append(
    LPCTSTR psz
    )
{
    bool bResult = boolify(::PathAppend(GetBuffer(max(MAX_PATH, length() + lstrlen(psz) + 3)), psz));
    ReleaseBuffer();
    return bResult;
}

__DATL_INLINE bool 
tpath::BuildRoot(
    int iDrive
    )
{
    empty();
    bool bResult = NULL != ::PathBuildRoot(GetBuffer(5), iDrive);
    ReleaseBuffer();
    return bResult;
}


__DATL_INLINE bool 
tpath::Canonicalize(
    void
    )
{
    tstring strTemp(*this);
    bool bResult = boolify(::PathCanonicalize(GetBuffer(max(MAX_PATH, length())), strTemp));
    ReleaseBuffer();
    return bResult;
}



__DATL_INLINE bool 
tpath::Compact(
    HDC hdc, 
    int cxPixels
    )
{
    bool bResult = boolify(::PathCompactPath(hdc, GetBuffer(), cxPixels));
    ReleaseBuffer();
    return bResult;
}


__DATL_INLINE bool 
tpath::CommonPrefix(
    LPCTSTR pszPath1, 
    LPCTSTR pszPath2
    )
{
    empty();
    ::PathCommonPrefix(pszPath1, 
                       pszPath2, 
                       GetBuffer(max(MAX_PATH, (max(lstrlen(pszPath1), lstrlen(pszPath2)) + 1))));
    ReleaseBuffer();
    return 0 < length();
}


__DATL_INLINE void
tpath::QuoteSpaces(
    void
    )
{
    ::PathQuoteSpaces(GetBuffer(max(MAX_PATH, length() + 3)));
    ReleaseBuffer();
}

__DATL_INLINE void 
tpath::UnquoteSpaces(
    void
    )
{
    ::PathUnquoteSpaces(GetBuffer());
    ReleaseBuffer();
}

__DATL_INLINE void 
tpath::RemoveBlanks(
    void
    )
{
    ::PathRemoveBlanks(GetBuffer());
    ReleaseBuffer();
}

__DATL_INLINE void
tpath::RemoveExtension(
    void
    )
{
    PathRemoveExtension(GetBuffer());
    ReleaseBuffer();
}

__DATL_INLINE void
tpath::RemoveFileSpec(
    void
    )
{
    ::PathRemoveFileSpec(GetBuffer());
    ReleaseBuffer();
}

__DATL_INLINE void
tpath::RemoveRoot(
    void
    )
{
    LPTSTR psz = ::PathSkipRoot(*this);
    if (psz)
    {
        tpath temp(psz);
        *this = temp; 
    }
}

__DATL_INLINE void
tpath::RemovePath(
    void
    )
{
    tpath temp;
    GetFileSpec(&temp);
    *this = temp;
}


__DATL_INLINE void
tpath::StripToRoot(
    void
    )
{
    ::PathStripToRoot(GetBuffer());
    ReleaseBuffer();
}


__DATL_INLINE void 
tpath::SetRoot(
    LPCTSTR pszRoot
    )
{
    tpath strTemp(*this);
    strTemp.RemoveRoot();
    *this = pszRoot;
    Append(strTemp);
}

__DATL_INLINE void
tpath::SetPath(
    LPCTSTR pszPath
    )
{
    tpath strTemp(*this);
    *this = pszPath;

    strTemp.RemovePath();
    Append(strTemp);
}

__DATL_INLINE void
tpath::SetDirectory(
    LPCTSTR pszDir
    )
{
    tpath path;
    GetPath(&path);
    path.StripToRoot();
    path.AddBackslash();
    path.Append(pszDir);
    SetPath(path);
}


__DATL_INLINE void
tpath::SetFileSpec(
    LPCTSTR pszFileSpec
    )
{
    RemoveFileSpec();
    Append(pszFileSpec);
}

__DATL_INLINE void
tpath::SetExtension(
    LPCTSTR pszExt
    )
{
    ::PathRenameExtension(GetBuffer(max(MAX_PATH, length() + lstrlen(pszExt) + 2)), pszExt);
    ReleaseBuffer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shtl\simreg.cpp ===
//+-------------------------------------------------------------------------
//
//  File:       simreg.h
//
//  Contents:   CRegFile
//
//              Simple Win32/Win16 registry manipulation class        
//              Copyright (c)1996, Shaun Ivory                        
//              All rights reserved                                   
//              Used with permission from Shaun hisself (shauniv)
//
//  History:    Sep-26-96  Davepl  Created 
//
//--------------------------------------------------------------------------

#include "shtl.h"
#include "simreg.h"

#if defined(SIMREG_WIN32)
#include <winreg.h>
#endif

#ifndef HKEY_CURRENT_USER
#define HKEY_CURRENT_USER           (( HKEY ) 0x80000001 )
#endif

#ifndef HKEY_LOCAL_MACHINE
#define HKEY_LOCAL_MACHINE          (( HKEY ) 0x80000002 )
#endif

#ifndef HKEY_USERS
#define HKEY_USERS                  (( HKEY ) 0x80000003 )
#endif

#ifndef HKEY_PERFORMANCE_DATA
#define HKEY_PERFORMANCE_DATA       (( HKEY ) 0x80000004 )
#endif

#ifndef HKEY_CURRENT_CONFIG
#define HKEY_CURRENT_CONFIG         (( HKEY ) 0x80000005 )
#endif

#ifndef HKEY_DYN_DATA
#define HKEY_DYN_DATA               (( HKEY ) 0x80000006 )
#endif


#if defined(SIMREG_WIN32)
__DATL_INLINE CSimpleReg::CSimpleReg( HKEY keyRoot, const tstring &szRoot, unsigned char forceCreate, LPSECURITY_ATTRIBUTES lpsa)
: m_hSubKey(0), m_hKeyRoot(0), m_bCreate(forceCreate != 0),m_lpsaSecurityAttributes(lpsa), m_bOpenSuccess(FALSE)
{   // Normal constructor
    SetRoot( keyRoot, szRoot );    
}
#else
__DATL_INLINE CSimpleReg::CSimpleReg( HKEY keyRoot, const tstring &szRoot, unsigned char forceCreate)
: m_hSubKey(0), m_hKeyRoot(0), m_bCreate(forceCreate != 0)
{   // Normal constructor
    SetRoot( keyRoot, szRoot );    
}
#endif

__DATL_INLINE unsigned char CSimpleReg::Assign( const CSimpleReg &other )
{
#if defined(SIMREG_WIN32)
    SecurityAttributes(other.SecurityAttributes());
#endif
    m_bCreate = other.ForceCreate();
    SetRoot( other.GetRootKey(), other.SubKeyName() );
    return m_bOpenSuccess;
}

__DATL_INLINE CSimpleReg::CSimpleReg( const CSimpleReg &other )
: m_hSubKey(0), m_hKeyRoot(0), m_bOpenSuccess(FALSE)
{
    Assign( other );
}

__DATL_INLINE CSimpleReg::CSimpleReg(void)
: m_bOpenSuccess(0), m_hSubKey(0), m_hKeyRoot(0)
{
#if defined(SIMREG_WIN32)
    m_lpsaSecurityAttributes = NULL;
#endif
}     

__DATL_INLINE CSimpleReg& CSimpleReg::operator=(const CSimpleReg& other)
{  // Assignment operator
    Assign(other);
    return (*this);
}

__DATL_INLINE CSimpleReg::~CSimpleReg(void)
{   // Destructor
    Close();
}


__DATL_INLINE unsigned char CSimpleReg::ForceCreate( unsigned char create )
{   // Force creation of a key, if it doesn't exist
    unsigned char Old = m_bCreate;
    m_bCreate = (create != 0);
    Open();
    return (Old);
}

__DATL_INLINE unsigned long CSimpleReg::Size( const tstring &key )
{
    if (!*this)
        return (0);
    DWORD dwType = REG_SZ;
    DWORD dwSize = 0;
    LONG Ret;
#if defined(SIMREG_WIN32)
    Ret = RegQueryValueEx( m_hSubKey, Totstring(key), NULL, &dwType, NULL, &dwSize);
#else
    Ret = RegQueryValue( m_hSubKey, Totstring(key), NULL, (LONG FAR *)&dwSize);
#endif
    if (Ret==ERROR_SUCCESS)
    {
#if defined(UNICODE) || defined(_UNICODE)
        if (dwType == REG_SZ || dwType == REG_EXPAND_SZ || dwType == REG_MULTI_SZ || dwType == REG_LINK || dwType == REG_RESOURCE_LIST)
            return (dwSize / 2);
#else
        return (dwSize);
#endif
    }
    return (0);
}

__DATL_INLINE unsigned long CSimpleReg::Type( const tstring &key )
{
    if (!*this)
        return (0);
    DWORD dwType = REG_SZ;
    DWORD dwSize = 0;
    LONG Ret;
#if defined(SIMREG_WIN32)
    Ret = RegQueryValueEx( m_hSubKey, Totstring(key), NULL, &dwType, NULL, &dwSize);
#else
    Ret = RegQueryValue( m_hSubKey, Totstring(key), NULL, (LONG FAR *)&dwSize);
#endif
    if (Ret==ERROR_SUCCESS)
    {
        return (dwType);
    }
    return (0);
}

__DATL_INLINE unsigned char CSimpleReg::Query( const tstring &key, LPTSTR szValue, unsigned short maxLen )
{
    if (!*this)
        return (0);
    DWORD dwType = REG_SZ;
    DWORD dwSize = maxLen;
    LONG Ret;
#if defined(SIMREG_WIN32)
    Ret = RegQueryValueEx( m_hSubKey, Totstring(key), NULL, &dwType, (LPBYTE)szValue, &dwSize);
#else
    Ret = RegQueryValue( m_hSubKey, Totstring(key), szValue, (LONG FAR *)&dwSize);
#endif
    return (Ret==ERROR_SUCCESS);
}

__DATL_INLINE unsigned char CSimpleReg::Query( const tstring &key, tstring &value, unsigned short maxLen )
{   // Get a REG_SZ (string) from the specified sub-key
    if (!*this)
        return (0);
    if (!maxLen)
        maxLen = (unsigned short)(Size( key ) + 1);
    if (!maxLen)
        maxLen = 1;
    LPTSTR Buffer = new TCHAR[maxLen];
    DWORD dwType = REG_SZ;
    DWORD dwSize = maxLen;
    LONG Ret;
#if defined(SIMREG_WIN32)
    Ret = RegQueryValueEx( m_hSubKey, Totstring(key), NULL, &dwType, (LPBYTE)Buffer, &dwSize);
#else
    Ret = RegQueryValue( m_hSubKey, Totstring(key), Buffer, (LONG FAR *)&dwSize);
#endif
    if (Ret==ERROR_SUCCESS)
    {
        value = tstring(Buffer);
    }
    delete[] Buffer;
    return (Ret==ERROR_SUCCESS);
}


__DATL_INLINE unsigned char CSimpleReg::Query( const tstring &key, DWORD &value )
{   // Get a REG_DWORD (unsigned long int) from the specified sub-key
    if (!*this)
        return (0);
#if defined(SIMREG_WIN32)
    DWORD Value;                        
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);
    LONG Ret;
    Ret = RegQueryValueEx( m_hSubKey, Totstring(key), NULL, &dwType, (LPBYTE)&Value, &dwSize);
    if (Ret==ERROR_SUCCESS)
    {
        value = Value;
    }
    return (Ret==ERROR_SUCCESS);
#else
    DWORD temp = value;
    if (QueryBin( key, &temp, sizeof(temp)))
    {
        value = temp;
        return (TRUE);
    }
    return (FALSE);
#endif
}

__DATL_INLINE unsigned char CSimpleReg::Query( const tstring &key, int &value )
{   // Get a REG_DWORD (unsigned long int) from the specified sub-key
    DWORD Temp;
    if (Query(key,Temp))
    {
        value = (int)Temp;
        return (TRUE);
    }
    return (FALSE);
}


__DATL_INLINE unsigned char CSimpleReg::Query( const tstring &key, LONG &value )
{   // Get a REG_DWORD (unsigned long int) from the specified sub-key
    DWORD Temp;
    if (Query(key,Temp))
    {
        value = (LONG)Temp;
        return (TRUE);
    }
    return (FALSE);
}

__DATL_INLINE unsigned char CSimpleReg::Query( const tstring &key, WORD &value )
{   // Get a REG_DWORD (unsigned long int) from the specified sub-key
    DWORD Temp;
    if (Query(key,Temp))
    {
        value = (WORD)Temp;
        return (TRUE);
    }
    return (FALSE);
}

__DATL_INLINE unsigned char CSimpleReg::Query( const tstring &key, BYTE &value )
{   // Get a REG_DWORD (unsigned long int) from the specified sub-key
    DWORD Temp;
    if (Query(key,Temp))
    {
        value = (BYTE)Temp;
        return (TRUE);
    }
    return (FALSE);
}


#ifdef SIMREG_WIN32

__DATL_INLINE unsigned char CSimpleReg::SetBin( const tstring &key, void *value, DWORD size )
{
    if (!*this)
        return (0);
    LONG Ret;
    Ret = RegSetValueEx( m_hSubKey, Totstring(key), 0, REG_BINARY, (LPBYTE)value, size );
    return (Ret==ERROR_SUCCESS);
}


__DATL_INLINE unsigned char CSimpleReg::QueryBin( const tstring &key, void *value, DWORD size )
{
    if (!*this)
        return (0);
    DWORD dwType = REG_BINARY;
    DWORD dwSize = size;
    LONG Ret;
    char *Value = new char[size];
    Ret = RegQueryValueEx( m_hSubKey, Totstring(key), NULL, &dwType, (LPBYTE)Value, &dwSize);
    if (dwType != REG_BINARY)
    {
        delete[] Value;
        return (0);
    }
    if (dwSize != size)
    {
        delete[] Value;
        return (0);
    }
    if (Ret==ERROR_SUCCESS)
    {
        memcpy( value, Value, size );
    }
    delete[] Value;
    return (Ret==ERROR_SUCCESS);
}


#else

__DATL_INLINE unsigned char CSimpleReg::SetBin( const tstring &key, void *value, DWORD size )
{
    if (!*this)
        return (0);
    unsigned char *Value = (unsigned char*)value;
    tstring Str;
    char Byte[4];
    for (DWORD i=0;i<size;i++)
    {
        wsprintf( Byte, "%02X ", Value[i] );
        Str = Str + Byte;
    }    
    return (Set( key, Str ));
}


__DATL_INLINE unsigned char CSimpleReg::QueryBin( const tstring &key, void *value, DWORD size )
{
    if (!*this)
        return (0);
    unsigned char *Value = (unsigned char *)value;
    tstring Str;
    if ((unsigned char)Query( key, Str, (unsigned short)(size * 3 + 1))==0)
    {
        return (FALSE);
    }
    if (strlen((const char *)Str) != size * 3)
    {
        return (FALSE);
    }
    tstring Temp;
    while (Str.length())
    {
        Temp = Str.Left( 3 );
        Str = Str.Right( strlen((const char *)Str) - 3 );
        *Value = (unsigned char)strtoul((const char *)Temp,NULL,16);
        Value++;
    }
    return (TRUE);
}


#endif

__DATL_INLINE unsigned char CSimpleReg::Set( const tstring &key, const tstring &value )
{  // Set a REG_SZ value for the specified key.
    if (!*this)
        return (0);
    LONG Ret;
#if defined(SIMREG_WIN32)
    Ret = RegSetValueEx( m_hSubKey, Totstring(key), 0, REG_SZ, (LPBYTE)Totstring(value), value.length()+1 );
#else                                                                                                                       
    Ret = RegSetValue( m_hSubKey, (LPCSTR)Totstring(key), REG_SZ, (LPCSTR)Totstring(value), value.length()+1 );
#endif    
    return (Ret==ERROR_SUCCESS);
}


__DATL_INLINE unsigned char CSimpleReg::Set( const tstring &key, DWORD value )
{  // Set a REG_SZ value for the specified key.
    if (!*this)
        return (0);
#if defined(SIMREG_WIN32)
    LONG Ret;
    Ret = RegSetValueEx( m_hSubKey, Totstring(key), 0, REG_DWORD, (LPBYTE)&value, sizeof(DWORD) );
    return (Ret==ERROR_SUCCESS);
#else
    return (SetBin( key, &value, sizeof(DWORD)));
#endif
}


__DATL_INLINE unsigned char CSimpleReg::Open(void)
{  // Open the specified sub key of the open root.
    HKEY hKey;
    LONG Ret;
    Close();
    if (m_bCreate)
    {
#if defined(SIMREG_WIN32)
        DWORD CreatedNewKey;
        if ((Ret = RegCreateKeyEx( m_hKeyRoot, Totstring(m_SubKeyName), 0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, SecurityAttributes(), &hKey, &CreatedNewKey )) == ERROR_SUCCESS)
#else
        if ((Ret = RegCreateKey( m_hKeyRoot, Totstring(m_SubKeyName), &hKey )) == ERROR_SUCCESS)
#endif
        {
            m_hSubKey = hKey;
            m_bOpenSuccess = 1;       
        }
    }
    else
    {
#if defined(SIMREG_WIN32)
        if ((Ret = RegOpenKeyEx( m_hKeyRoot, Totstring(m_SubKeyName), 0, KEY_ALL_ACCESS, &hKey )) == ERROR_SUCCESS)
#else
        if ((Ret = RegOpenKey( m_hKeyRoot, Totstring(m_SubKeyName), &hKey )) == ERROR_SUCCESS)
#endif
        {
            m_hSubKey = hKey;
            m_bOpenSuccess = 1;       
        }
    }
    return (m_bOpenSuccess);
}

__DATL_INLINE unsigned char CSimpleReg::Close(void)
{   // If open, close key.
    if (m_bOpenSuccess)
        RegCloseKey(m_hSubKey);
    m_bOpenSuccess = 0;
    return (1);   
}

__DATL_INLINE unsigned char CSimpleReg::SetRoot( HKEY keyClass, const tstring &newRoot )
{   // Set the root class and key, open.
    m_hKeyRoot = GetWin16HKey(keyClass);
    m_SubKeyName = newRoot;
    return (Open());
}


__DATL_INLINE unsigned char CSimpleReg::Delete( HKEY root, const tstring &key )
{
    return (RegDeleteKey(GetWin16HKey(root), Totstring(key)) == ERROR_SUCCESS);
}


__DATL_INLINE DWORD CSimpleReg::CountKeys(void)
{
#if defined(SIMREG_WIN32)
    TCHAR Class[256]=TEXT("");
    DWORD ClassSize = sizeof(Class)/sizeof(Class[0]);
    DWORD subKeyCount=0;
    RegQueryInfoKey(GetSubKey(),Class,&ClassSize,NULL,&subKeyCount,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
    return (subKeyCount);
#else
    char Name[256];
    DWORD NameSize;
    DWORD subKeyCount=0;    
    for (int i=0;;i++)
    {
        NameSize = sizeof(Name) / sizeof(Name[0]);
        if (RegEnumKey(GetSubKey(),i,Name,NameSize) != ERROR_SUCCESS)
            break;
        subKeyCount++;
    }
    return (subKeyCount);
#endif
}

__DATL_INLINE int CSimpleReg::DoRecurseKeys( HKEY key, const tstring &root, SimRegKeyEnumProc enumProc, void *extraInfo, int level, int recurseOrder, int failOnOpenError )
{
    TCHAR Name[256]=TEXT("");
    DWORD NameSize;
#if defined(SIMREG_WIN32)    
    TCHAR Class[256]=TEXT("");
    DWORD ClassSize;
    FILETIME FileTime;
#endif    
    CSimpleReg reg(key,root);
    LONG res;
    if (!reg.OK())
    {
        return (failOnOpenError ? 0 : 1);
    }
    DWORD subKeyCount = reg.CountKeys();
    for (DWORD i=subKeyCount;i>0;i--)
    {
        NameSize = sizeof(Name)/sizeof(Name[0]);
#if defined(SIMREG_WIN32)        
        ClassSize = sizeof(Class)/sizeof(Class[0]);
        if ((res=RegEnumKeyEx(reg.GetSubKey(),i-1,Name,&NameSize,NULL,Class,&ClassSize,&FileTime)) != ERROR_SUCCESS)
#else
        if ((res=RegEnumKey(reg.GetSubKey(),i-1,Name,NameSize)) != ERROR_SUCCESS)
#endif        
        {
            break;
        }
        CKeyEnumInfo EnumInfo;
        EnumInfo.Name = Name;
        EnumInfo.Root = reg.GetSubKey();
        EnumInfo.Level = level;
        EnumInfo.ExtraData = extraInfo;
        if (enumProc && recurseOrder==PreOrder)
            if (!enumProc(EnumInfo))
                return (0);
        if (!DoRecurseKeys(reg.GetSubKey(),Name,enumProc,extraInfo,level+1,recurseOrder, failOnOpenError))
            return (0);
        if (enumProc && recurseOrder==PostOrder)
            if (!enumProc(EnumInfo))
                return (0);
    }
    return (1);
}

__DATL_INLINE int CSimpleReg::DoEnumKeys( HKEY key, const tstring &root, SimRegKeyEnumProc enumProc, void *extraInfo, int failOnOpenError )
{
    TCHAR Name[256]=TEXT("");    
    DWORD NameSize;
#if defined(SIMREG_WIN32)    
    TCHAR Class[256]=TEXT("");
    DWORD ClassSize;
    FILETIME FileTime;
#endif    
    CSimpleReg reg(key,root);
    LONG res;
    if (!reg.OK())
    {
        return (failOnOpenError ? 0 : 1);
    }
    DWORD subKeyCount = reg.CountKeys();
    for (DWORD i=subKeyCount;i>0;i--)
    {
        NameSize = sizeof(Name)/sizeof(Name[0]);
#if defined(SIMREG_WIN32)        
        ClassSize = sizeof(Class)/sizeof(Class[0]);
        if ((res=RegEnumKeyEx(reg.GetSubKey(),i-1,Name,&NameSize,NULL,Class,&ClassSize,&FileTime)) != ERROR_SUCCESS)
#else
        if ((res=RegEnumKey(reg.GetSubKey(),i-1,Name,NameSize)) != ERROR_SUCCESS)
#endif        
        {
            break;
        }
        CKeyEnumInfo EnumInfo;
        EnumInfo.Name = Name;
        EnumInfo.Root = reg.GetSubKey();
        EnumInfo.Level = 0;
        EnumInfo.ExtraData = extraInfo;
        if (!enumProc(EnumInfo))
            return (0);
    }
    return (1);
}



__DATL_INLINE int CSimpleReg::RecurseKeys( SimRegKeyEnumProc enumProc, void *extraInfo, int recurseOrder, int failOnOpenError )
{
    return (DoRecurseKeys(GetSubKey(), TEXT(""), enumProc, extraInfo, 0, recurseOrder, failOnOpenError ));
}

__DATL_INLINE int CSimpleReg::EnumKeys( SimRegKeyEnumProc enumProc, void *extraInfo, int failOnOpenError )
{
    return (DoEnumKeys(GetSubKey(), TEXT(""), enumProc, extraInfo, failOnOpenError ));
}


__DATL_INLINE HKEY CSimpleReg::GetHkeyFromName( const tstring &Name )
{
    static struct 
    {
        LPCTSTR Name;
        HKEY Key;
    } KeyNames[] =
    {
        { TEXT("HKEY_CLASSES_ROOT"),   HKEY_CLASSES_ROOT},
        { TEXT("HKEY_CURRENT_USER"),   HKEY_CURRENT_USER},
        { TEXT("HKEY_LOCAL_MACHINE"),  HKEY_LOCAL_MACHINE},
        { TEXT("HKEY_USERS"),          HKEY_USERS},
        { TEXT("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG},
        { TEXT("HKEY_DYN_DATA"),       HKEY_DYN_DATA},
        { TEXT("HKCR"),                HKEY_CLASSES_ROOT},
        { TEXT("HKCU"),                HKEY_CURRENT_USER},
        { TEXT("HKLM"),                HKEY_LOCAL_MACHINE},
        { TEXT("HKU"),                 HKEY_USERS},
        { TEXT("HKCC"),                HKEY_CURRENT_CONFIG},
        { TEXT("HKDD"),                HKEY_DYN_DATA},
        { NULL, NULL}
    };
    for (int i=0;KeyNames[i].Name;i++)
    {
        if (!lstrcmpi(Totstring(Name),KeyNames[i].Name))
            return (KeyNames[i].Key);
    }
    return (INVALID_HKEY);
}


__DATL_INLINE int CSimpleReg::DeleteEnumKeyProc( CSimpleReg::CKeyEnumInfo &enumInfo )
{
    return (CSimpleReg::Delete( enumInfo.Root, enumInfo.Name ));
}

__DATL_INLINE int CSimpleReg::DeleteRecursively( HKEY root, const tstring &name )
{
    if (CSimpleReg( root, name ).RecurseKeys( DeleteEnumKeyProc, NULL, CSimpleReg::PostOrder ))
        return (CSimpleReg::Delete( root, name ));
    return (0);
}

__DATL_INLINE HKEY CSimpleReg::GetWin16HKey( HKEY key )
{
#if !defined(SIMREG_WIN32)
    if (key == HKEY_CURRENT_USER ||
        key == HKEY_LOCAL_MACHINE ||
        key == HKEY_USERS ||
        key == HKEY_CURRENT_CONFIG ||
        key == HKEY_DYN_DATA)
        return (HKEY_CLASSES_ROOT);
#endif
    return (key);
}


__DATL_INLINE int CSimpleReg::EnumValues( SimRegValueEnumProc enumProc, void *extraInfo )
{
    TCHAR Name[256];
    DWORD Size;
    DWORD Type;
    int Result = 1;
    for (int i=0;;i++)
    {
        Size = sizeof(Name) / sizeof(Name[0]);
        if (RegEnumValue(GetSubKey(),i,Name,&Size,NULL,&Type,NULL,NULL) != ERROR_SUCCESS)
            break;
        CValueEnumInfo info;
        info.Name = Name;
        info.Type = Type;
        info.Size = Size;
        info.ExtraData = extraInfo;
        if (enumProc)
        {
            if (!enumProc(info))
            {
                Result = 0;
                break;
            }
        }
    }
    return (Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shtl\shtl.h ===
#ifndef __DATL_H__
#define __DATL_H__

#ifndef DUMMYUNIONNAME
#define DUMMYUNIONNAME
#endif

#include "warnings.h"
#include <windows.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <stdio.h>
#include <malloc.h>

#if _MSC_VER >= 1200
#    pragma warning(push)
#endif

    #include <iostream>
    #include <string>
    #include <map>
    #include <vector>
    #include <algorithm>
    #include <exception>

#if _MSC_VER >= 1200
#    pragma warning(pop)
#endif

// ARRAYSIZE
//
// Returns the number of elements in an array

#ifndef ARRAYSIZE
#define ARRAYSIZE(_A) (sizeof(_A) / sizeof(_A[0]))
#endif

// THROW_IF_FAILS
//
// Throws an exception if the HRESULT-returning function fails

#define THROW_IF_FAILS(x) { HRESULT _hr = x; if (FAILED(_hr)) throw dexception(_hr); }

// DECLARE_XXXXX_HANDLER
//
// Message declaration macros to make it easier to declare 
// handlers for ATL window classes

#define DECLARE_WM_HANDLER( handler ) LRESULT handler( UINT, WPARAM, LPARAM, BOOL& )
#define DECLARE_CM_HANDLER( handler ) LRESULT handler( WORD, WORD, HWND, BOOL& ) ;
#define DECLARE_NM_HANDLER( handler ) LRESULT handler( int, LPNMHDR, BOOL& );

#ifdef INCLUDE_SHTL_SOURCE
  #define __DATL_INLINE inline
  #include "cidl.cpp"
  #include "cshalloc.cpp"
  #include "shtl.cpp"
  #include "simreg.cpp"
  #include "tpath.cpp"
  #include "tstring.cpp"
  #include "autoptr.cpp"
#else
  #define __DATL_INLINE
#endif


#endif // __DATL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shtl\simreg.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Silicon Prairie Software, 1996
//
//  File:       simreg.h
//
//  Contents:   CRegFile
//
//              Simple Win32/Win16 registry manipulation class        
//              Copyright (c)1996, Shaun Ivory                        
//              All rights reserved                                   
//              Used with permission
//
//  History:    Sep-26-96  Davepl  Created 
//
//--------------------------------------------------------------------------

#pragma once
#include "shtl.h"
#include "tstring.h"
#include <winreg.h>

#if defined(WIN32) || defined(_WIN32)
#define SIMREG_WIN32
#else
#define SIMREG_WIN16
#endif

#define INVALID_HKEY ((HKEY)-1)

class CSimpleReg 
{
private:
    tstring         m_SubKeyName;
    HKEY            m_hKeyRoot;
    HKEY            m_hSubKey;
    unsigned char   m_bOpenSuccess;
    unsigned char   m_bCreate;
#if defined(SIMREG_WIN32)
    LPSECURITY_ATTRIBUTES m_lpsaSecurityAttributes;
#endif
private:
    // Some of the Reg... functions inexplicably require non const strings
    static LPTSTR Totstring( const tstring &s ) { return (LPTSTR)(LPCTSTR)s; }    
    unsigned char Assign( const CSimpleReg &other );
public:    
    enum 
    {
        PreOrder=0, 
        PostOrder=1
    };    
    struct CKeyEnumInfo
    {
        tstring Name;
        HKEY    Root;
        int     Level;
        void   *ExtraData;
    };    
    struct CValueEnumInfo
    {
        tstring Name;
        DWORD   Type;
        DWORD   Size;
        void   *ExtraData;
    };

    typedef int (*SimRegKeyEnumProc)( CKeyEnumInfo &enumInfo );
    typedef int (*SimRegValueEnumProc)( CValueEnumInfo &enumInfo );

    // Constructors, destructor
#if defined(SIMREG_WIN32)
    CSimpleReg( HKEY, const tstring&, unsigned char forceCreate=0, LPSECURITY_ATTRIBUTES lpsa=NULL );
#else
    CSimpleReg( HKEY, const tstring&, unsigned char forceCreate=0 );
#endif
    CSimpleReg(void);
    CSimpleReg(const CSimpleReg &other);
    ~CSimpleReg(void);
    CSimpleReg &operator=(const CSimpleReg& );

    // Query functions
    unsigned long Size( const tstring &key );
    unsigned long Type( const tstring &key );
    unsigned char Query( const tstring &key, LPTSTR szValue, unsigned short maxLen );
    unsigned char Query( const tstring &key, tstring &value, unsigned short maxLen=0 );
    unsigned char Query( const tstring &key, DWORD &value );
    unsigned char Query( const tstring &key, int &value );
    unsigned char Query( const tstring &key, LONG &value );
    unsigned char Query( const tstring &key, BYTE &value );
    unsigned char Query( const tstring &key, WORD &value );
    unsigned char QueryBin( const tstring &key, void *value, DWORD size );

    void Query( const tstring &key, DWORD &value, const DWORD &defaultvalue );

    template<class _TYPE> _TYPE Query( const tstring &key, const _TYPE &defaultvalue )
    {
        _TYPE result;
        if (Query(key, result))
            return result;
        else
            return defaultvalue;
    }

    // Set functions
    unsigned char SetBin( const tstring &key, void *value, DWORD size );
    unsigned char Set( const tstring &key, const tstring &value );
    unsigned char Set( const tstring &key, DWORD value );

    unsigned char Open(void);
    unsigned char Close(void);
    unsigned char ForceCreate( unsigned char create = TRUE );
    unsigned char SetRoot( HKEY keyClass, const tstring &newRoot );

#if defined(SIMREG_WIN32)
    void SecurityAttributes( const LPSECURITY_ATTRIBUTES lpsa ) { m_lpsaSecurityAttributes = lpsa; }
    const LPSECURITY_ATTRIBUTES SecurityAttributes(void) const { return m_lpsaSecurityAttributes; }
#endif

    DWORD CountKeys(void);
    static HKEY GetHkeyFromName( const tstring &Name );
    static unsigned char Delete( HKEY, const tstring &key );
    static int DeleteRecursively( HKEY root, const tstring &name );

    // Inlines
    tstring SubKeyName(void) const   {return (m_SubKeyName);}
    unsigned char ForceCreate(void) const  {return (m_bCreate);}
    unsigned char OK(void) const           {return (m_bOpenSuccess);}        
    HKEY GetRootKey(void) const            {return (m_hKeyRoot);}
    HKEY GetSubKey(void) const             {return (m_hSubKey);}
    int operator!(void) const              {return (!m_bOpenSuccess);}

    static HKEY GetWin16HKey( HKEY key );
    int EnumValues( SimRegValueEnumProc enumProc, void *extraInfo = NULL );
    int RecurseKeys( SimRegKeyEnumProc enumProc, void *extraInfo = NULL, int recurseOrder = CSimpleReg::PostOrder, int failOnOpenError = 1 );
    int EnumKeys( SimRegKeyEnumProc enumProc, void *extraInfo = NULL, int failOnOpenError = 1 );
private:
    static int DoRecurseKeys( HKEY key, const tstring &root, SimRegKeyEnumProc enumProc, void *extraInfo, int level, int recurseOrder, int failOnOpenError );
    static int DoEnumKeys( HKEY key, const tstring &root, SimRegKeyEnumProc enumProc, void *extraInfo, int failOnOpenError );
    static int DeleteEnumKeyProc( CSimpleReg::CKeyEnumInfo &enumInfo );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shtl\tpath.h ===
//  FILE:  tpath.h
//  AUTHOR: BrianAu
//  REMARKS:

#ifndef _INC_CSCVIEW_PATHSTR_H
#define _INC_CSCVIEW_PATHSTR_H

#include "tstring.h"
#include "misc.h"
#include <utility>

#ifndef _INC_SHLWAPI
#   include "shlwapi.h"
#endif

class tpath : public tstring
{
    public:
        tpath(void) { }
        explicit tpath(LPCTSTR pszRoot, LPCTSTR pszDir = NULL, LPCTSTR pszFile = NULL, LPCTSTR pszExt = NULL);
        tpath(const tpath& rhs);
        tpath& operator = (const tpath& rhs);
        tpath& operator = (LPCTSTR rhs);

        //
        // Component replacement.
        //
        void SetRoot(LPCTSTR pszRoot);
        void SetPath(LPCTSTR pszPath);
        void SetDirectory(LPCTSTR pszDir);
        void SetFileSpec(LPCTSTR pszFileSpec);
        void SetExtension(LPCTSTR pszExt);
        //
        // Component query
        //
        bool GetRoot(tpath *pOut) const;
        bool GetPath(tpath *pOut) const;
        bool GetDirectory(tpath *pOut) const;
        bool GetFileSpec(tpath *pOut) const;
        bool GetExtension(tpath *pOut) const;
        //
        // Component removal
        //
        void RemoveRoot(void);
        void RemovePath(void);
        void RemoveFileSpec(void);
        void RemoveExtension(void);
        void StripToRoot(void);

        bool Append(LPCTSTR psz);

        //
        // DOS drive letter support.
        //
        bool BuildRoot(int iDrive);
        int GetDriveNumber(void) const;

        //
        // Type identification.
        //
        bool IsDirectory(void) const;
        bool IsFileSpec(void) const;
        bool IsPrefix(LPCTSTR pszPrefix) const;
        bool IsRelative(void) const;
        bool IsRoot(void) const;
        bool IsSameRoot(LPCTSTR pszPath) const;
        bool IsUNC(void) const;
        bool IsUNCServer(void) const;
        bool IsUNCServerShare(void) const;
        bool IsURL(void) const;

        //
        // Miscellaneous formatting.
        //
        bool MakePretty(void);
        void QuoteSpaces(void);
        void UnquoteSpaces(void);
        void RemoveBlanks(void);
        void AddBackslash(void);
        void RemoveBackslash(void);
        bool Canonicalize(void);
        bool Compact(HDC hdc, int cxPixels);
        bool CommonPrefix(LPCTSTR pszPath1, LPCTSTR pszPath2);
        bool Exists(void) const;

    private:
        template <class T>
        T& MAX(const T& a, const T& b)
            { return a > b ? a : b; }

};

using namespace std;

inline bool 
tpath::Exists(
    void
    ) const
{
    return boolify(::PathFileExists((LPCTSTR)*this));
}


inline bool 
tpath::IsDirectory(
    void
    ) const
{
    return boolify(::PathIsDirectory((LPCTSTR)*this));
}

inline bool 
tpath::IsFileSpec(
    void
    ) const
{
    return boolify(::PathIsFileSpec((LPCTSTR)*this));
}

inline bool 
tpath::IsPrefix(
    LPCTSTR pszPrefix
    ) const
{
    return boolify(::PathIsPrefix(pszPrefix, (LPCTSTR)*this));
}


inline bool 
tpath::IsRelative(
    void
    ) const
{
    return boolify(::PathIsRelative((LPCTSTR)*this));
}

inline bool 
tpath::IsRoot(
    void
    ) const
{
    return boolify(::PathIsRoot((LPCTSTR)*this));
}


inline bool 
tpath::IsSameRoot(
    LPCTSTR pszPath
    ) const
{
    return boolify(::PathIsSameRoot(pszPath, (LPCTSTR)*this));
}


inline bool 
tpath::IsUNC(
    void
    ) const
{
    return boolify(::PathIsUNC((LPCTSTR)*this));
}

inline bool 
tpath::IsUNCServer(
    void
    ) const
{
    return boolify(::PathIsUNCServer((LPCTSTR)*this));
}


inline bool 
tpath::IsUNCServerShare(
    void
    ) const
{
    return boolify(::PathIsUNCServerShare((LPCTSTR)*this));
}

inline bool 
tpath::IsURL(
    void
    ) const
{
    return boolify(::PathIsURL((LPCTSTR)*this));
}

inline bool 
tpath::MakePretty(
    void
    )
{
    bool bRes = boolify(::PathMakePretty(GetBuffer()));
    ReleaseBuffer(-1);
    return bRes;
}

inline int
tpath::GetDriveNumber(
    void
    ) const
{
    return ::PathGetDriveNumber(*this);
}


#endif // _INC_CSCVIEW_PATHSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shtl\warnings.h ===
// Warnings that we disable so that we can compile at a higher warning level, yet
// not be inundated with things we don't really care about

#pragma once
#pragma warning(disable:4100) // unreferenced formal parameter
#pragma warning(disable:4663) // C++ language change
#pragma warning(disable:4238) // nonstandard extension used : class rvalue used as lvalue
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\extimer.cpp ===
#include "precomp.h"
#include "extimer.h"

CExclusiveTimer::CExclusiveTimer(void)
: m_nTimerId(0),
  m_hWnd(NULL)
{
}

CExclusiveTimer::~CExclusiveTimer(void)
{
    Kill();
}

void CExclusiveTimer::Kill(void)
{
    if (m_hWnd && m_nTimerId)
    {
        ::KillTimer( m_hWnd, m_nTimerId );
        m_hWnd = NULL;
        m_nTimerId = 0;
    }
}

void CExclusiveTimer::Set( HWND hWnd, UINT nTimerId, UINT nMilliseconds )
{
    Kill();
    m_hWnd = hWnd;
    m_nTimerId = nTimerId;
    if (m_hWnd && m_nTimerId)
    {
        ::SetTimer( m_hWnd, m_nTimerId, nMilliseconds, NULL );
    }
}

UINT CExclusiveTimer::TimerId(void) const
{
    return m_nTimerId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\extimer.h ===
#ifndef __13a60c52_c07c_4fee_ac18_fa66152e54a3__
#define __13a60c52_c07c_4fee_ac18_fa66152e54a3__

#include <windows.h>

class CExclusiveTimer
{
private:
    UINT m_nTimerId;
    HWND m_hWnd;

private:
    // No implementation
    CExclusiveTimer( const CExclusiveTimer & );
    CExclusiveTimer &operator=( const CExclusiveTimer & );

public:
    CExclusiveTimer(void);
    ~CExclusiveTimer(void);
    void Kill(void);
    void Set(HWND hWnd, UINT nTimerId, UINT nMilliseconds);
    UINT TimerId(void) const;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\findfile.h ===
#ifndef __108bdde2_7034_4391_95d5_cb8fc17a0413__
#define __108bdde2_7034_4391_95d5_cb8fc17a0413__

#include <windows.h>
#include "simstr.h"

typedef bool (*FindFilesCallback)( bool bIsFile, LPCTSTR pszFilename, const WIN32_FIND_DATA *pFindData, PVOID pvParam );

bool RecursiveFindFiles( CSimpleString strDirectory, const CSimpleString &strMask, FindFilesCallback pfnFindFilesCallback, PVOID pvParam );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shtl\tstring.h ===
//  FILE:  tstring.h
//  AUTHOR: Davepl
//  REMARKS:
//
//          
//      This header file declares the tstring class.  This string class is
//      derived from the Standard C++ Libarary string classes (one of them)
//      and adds to them the MFC CString conveniences of
//
//          - UNICODE support and
//          - implicit casts to PCTSTR
//          - loading from resource files
//          - formatting (via Format()) function.
//          - writing to/reading from COM IStream interfaces
//          - Functional objects for use in STL algorithms
//
//      This header also declares our own version of the MFC/ATL UNICODE-MBCS
//      conversion macros.  Our version looks exactly like the originals in order
//      facilitate portability.
//
//      (c) 1999 Dave Plummer.  Portions of this code derived from source 
//      produced by Joe O'Leary with the following license:
//        > This code is free.  Use it anywhere you want.  Rewrite
//        > it, restructure it, whatever you want.  


#ifndef _STDSTRING_H_
#define _STDSTRING_H_

// Turn off browser references

#ifdef _MSC_VER
    #pragma component(browser, off, references, "tstring")
#endif

// Avoid legacy code mess up -- if _UNICODE is defined, then UNICODE must be as well
#if defined (_UNICODE) && !defined (UNICODE)
    #define UNICODE
#endif

#include <locale>
#include <TCHAR.H>
#ifndef STRICT
    #define STRICT
#endif
#include <windows.h>

// In non-MFC builds, ASSERT and VERIFY probably won't be defined, so
// check to see if they are defined and, if not, define them ourself.

#ifndef ASSERT
    #include <crtdbg.h> // probably already included but do it just in case
    #define ASSERT(f) _ASSERTE((f))
#endif
#ifndef VERIFY
    #ifdef _DEBUG
        #define VERIFY(x) ASSERT((x))
    #else
        #define VERIFY(x) x
    #endif
#endif

#ifndef TRACE
    #define TRACE
#endif

#include <functional>       // needed for tstring_lessnocase, et al

// If this is a recent enough version of VC include comdef.h, we can write many tstring
// functions to deal with COM types and compiler support classes like _bstr_t

#if defined (_MSC_VER) && (_MSC_VER >= 1100)
    #include <comdef.h>
    #define STDSTRING_INC_COMDEF        // signal that we #included MS comdef.h file
#endif

#ifndef PCTSTR_DEFINED
    typedef const TCHAR* PCTSTR;
    #define PCTSTR_DEFINED
#endif

#ifndef PCOLESTR
    #define PCOLESTR    LPCOLESTR
#endif
#ifndef POLESTR
    #define POLESTR     LPOLESTR
#endif

// UNICODE/MBCS conversion macros.  These are made to work just like the MFC/ATL ones.  We
// will not define them if
//      _NO_STDCONVERSION   - the developer explicitly turned them off
//      USES_CONVERSION     - this is an ATL/MFC build and they are already defined

#ifndef _NO_STDCONVERSION

    #if defined (USES_CONVERSION)
        #define _NO_STDCONVERSION   // Let StdString.cpp know it should not compile functions
    #else

        // In MFC builds we can just use the MFC UNICODE conversion macros.
        // In NON-MFC builds will have to define them ourselves

        #include <malloc.h>

        #ifdef _MFC_VER

            #include <afxconv.h>
            #define _NO_STDCONVERSION   // Let StdString.cpp know it should not compile functions

        #else

            // Define our conversion macros to look exactly like the originals
            // using this stuff both with and without MFC/ATL.  Avert your eyes,
            // its not pretty

            #ifndef _DEBUG
                #define USES_CONVERSION int _convert; _convert
            #else
                #define USES_CONVERSION int _convert = 0
            #endif

            PWSTR  StdA2WHelper(PWSTR pw, PCSTR pa, int nChars);
            PSTR   StdW2AHelper(PSTR pa, PCWSTR pw, int nChars);

            #define A2W(pa) (\
                ((PCSTR)(pa) == NULL) ? NULL : (\
                    _convert = (strlen((pa))+1),\
                    StdA2WHelper((LPWSTR) alloca(_convert*2), (pa), _convert)))

            #define W2A(pw) (\
                ((PCWSTR)(pw) == NULL) ? NULL : (\
                    _convert = (wcslen((pw))+1)*2,\
                    StdW2AHelper((PSTR) alloca(_convert), (pw), _convert)))

            #define A2CW(pa) ((PCWSTR)A2W((pa)))
            #define W2CA(pw) ((PCSTR)W2A((pw)))

            #ifdef _UNICODE
                #define T2A W2A
                #define A2T A2W
                inline PWSTR T2W(PTSTR p) { return p; }
                inline PTSTR W2T(PWSTR p) { return p; }
                #define T2CA W2CA
                #define A2CT A2CW
                inline PCWSTR T2CW(PCTSTR p) { return p; }
                inline PCTSTR W2CT(PCWSTR p) { return p; }
            #else
                #define T2W A2W
                #define W2T W2A
                inline PSTR T2A(PTSTR p) { return p; }
                inline PTSTR A2T(PSTR p) { return p; }
                #define T2CW A2CW
                #define W2CT W2CA
                inline PCSTR T2CA(PCTSTR p) { return p; }
                inline PCTSTR A2CT(PCSTR p) { return p; }
            #endif // #ifdef _UNICODE

            #if defined(_UNICODE)
                // in these cases the default (TCHAR) is the same as OLECHAR
                inline size_t ocslen(PCOLESTR x) { return wcslen(x); }
                inline OLECHAR* ocscpy(POLESTR dest, PCOLESTR src) { return wcscpy(dest, src); }
                inline PCOLESTR T2COLE(PCTSTR p) { return p; }
                inline PCTSTR OLE2CT(PCOLESTR p) { return p; }
                inline POLESTR T2OLE(PTSTR p) { return p; }
                inline PTSTR OLE2T(POLESTR p) { return p; }
            #elif defined(OLE2ANSI)
                // in these cases the default (TCHAR) is the same as OLECHAR
                inline size_t ocslen(PCOLESTR x) { return strlen(x); }
                inline OLECHAR* ocscpy(POLESTR dest, LPCOLESTR src) { return strcpy(dest, src); }
                inline PCOLESTR T2COLE(PCTSTR p) { return p; }
                inline PCTSTR OLE2CT(PCOLESTR p) { return p; }
                inline POLESTR T2OLE(PTSTR p) { return p; }
                inline PTSTR OLE2T(POLESTR p) { return p; }
            #else
                inline size_t ocslen(PCOLESTR x) { return wcslen(x); }
                inline OLECHAR* ocscpy(POLESTR dest, PCOLESTR src)
                {return (POLESTR) memcpy(dest, src, (wcslen(src)+1)*sizeof(WCHAR));}
                //CharNextW doesn't work on Win95 so we use this
                #define T2COLE(pa)  A2CW((pa))
                #define T2OLE(pa)   A2W((pa))
                #define OLE2CT(po)  W2CA((po))
                #define OLE2T(po)   W2A((po))
            #endif

            #ifdef OLE2ANSI
                inline POLESTR A2OLE(PSTR p) { return p;}
                inline PSTR OLE2A(POLESTR p) { return p;}
                #define W2OLE W2A
                #define OLE2W A2W
                inline PCOLESTR A2COLE(PCSTR p) { return p;}
                inline PCSTR OLE2CA(PCOLESTR p) { return p;}
                #define W2COLE W2CA
                #define OLE2CW A2CW
            #else
                inline POLESTR W2OLE(PWSTR p) { return p; }
                inline PWSTR OLE2W(POLESTR p) { return p; }
                #define A2OLE A2W
                #define OLE2A W2A
                inline PCOLESTR W2COLE(PCWSTR p) { return p; }
                inline PCWSTR OLE2CW(PCOLESTR p) { return p; }
                #define A2COLE A2CW
                #define OLE2CA W2CA
            #endif

            inline BSTR OLE2BSTR(PCOLESTR p) {return ::SysAllocString(p);}
            #if defined(_UNICODE)
                // in these cases the default (TCHAR) is the same as OLECHAR
                inline BSTR T2BSTR(PCTSTR p) {return ::SysAllocString(p);}
                inline BSTR A2BSTR(PCSTR p) {USES_CONVERSION; return ::SysAllocString(A2COLE(p));}
                inline BSTR W2BSTR(PCWSTR p) {return ::SysAllocString(p);}
            #elif defined(OLE2ANSI)
                // in these cases the default (TCHAR) is the same as OLECHAR
                inline BSTR T2BSTR(PCTSTR p) {return ::SysAllocString(p);}
                inline BSTR A2BSTR(PCSTR p) {return ::SysAllocString(p);}
                inline BSTR W2BSTR(PCWSTR p) {USES_CONVERSION; return ::SysAllocString(W2COLE(p));}
            #else
                inline BSTR T2BSTR(PCTSTR p) {USES_CONVERSION; return ::SysAllocString(T2COLE(p));}
                inline BSTR A2BSTR(PCSTR p) {USES_CONVERSION; return ::SysAllocString(A2COLE(p));}
                inline BSTR W2BSTR(PCWSTR p) {return ::SysAllocString(p);}
            #endif

        #endif // #ifdef _MFC_VER

    #endif // #ifndef USES_CONVERSION
#endif // #ifndef _NO_STDCONVERSION

// Define our own macros for "other" type to TCHAR type conversion
// i.e. in a UNICODE build "other" would be char.  In a non-UNICODE
// build, "other" would be wchar_t  These macros make the declaration
// of the tstring class a lot cleaner

#ifdef _UNICODE
    #define O2T  A2T            // "other" type string to generic text type string
    #define O2CT A2CT           // constant "other" type string to generic text type string
    #define T2O  T2A            // generic text type string to "other" type string.
    #define T2CO T2CA           // generic text type string to constant "other type string.
#else
    #define O2T  W2T
    #define O2CT W2CT
    #define T2O  T2W
    #define T2CO T2CW
#endif

// Define some short names for types that we will refer to in our definition of
// the tstring class.

#ifdef _UNICODE
    #define TOTHER  char        // the "other" char type            (opposite of TCHAR)
    #define POSTR PSTR          // the "other" string type          (opposite of PTSTR)
    #define PCOSTR PCSTR        // the "other" const string type    (oppsite of PCTSTR)
    const PCOSTR szONull = "";  // an empty string of the "other" type.
#else
    #define TOTHER wchar_t      
    #define POSTR PWSTR     
    #define PCOSTR PCWSTR       
    const PCOSTR szONull = L"";
#endif

const PCTSTR szTNull = _T("");  // an empty string of the TCHAR type

typedef std::basic_string<TCHAR>  STRBASE;   // our base class
typedef std::basic_string<TOTHER> STROTHER; // opposite of our base

// Define TSTRING -- this is a basic_string built around the TCHAR type, kind of like MFC CString
// It is also our base class.

#ifndef _TSTRING_DEFINED_
#define _TSTRING_DEFINED_
    typedef std::basic_string<TCHAR> TSTRING;
#endif

// tstring class
//
//      This class is a simplified version of the Standard C++ Library string or basic string class.  It
//      is derived from basic_string<TCHAR> and adds some MFC CString-like functionality

class tstring : public STRBASE
{
public:

    typedef std::allocator<TCHAR> MYALLOC;
    // constructors
    tstring();
    tstring(const tstring& str);
    tstring(const STRBASE& str);
    tstring(const STROTHER& str);
    tstring(PCTSTR pT);
    tstring(PCOSTR pO);
    tstring(const_iterator first, const_iterator last);
    tstring(size_type nSize, value_type ch, const allocator_type& al=std::allocator<TCHAR>());
    tstring(UINT nId);

#ifdef STDSTRING_INC_COMDEF
    tstring(const _bstr_t& bstr);                            // takes the _bstr_t MS compiler COM support class
#endif

    // assignment operators
    tstring&         operator=(const tstring& str);     // copy constructor
    tstring&         operator=(const STRBASE& str);     // takes a base std string type (string or wstring)
    tstring&         operator=(const STROTHER& str);    // takes the other std string type (string or wstring)
    tstring&         operator=(PCTSTR pT);              // takes const TCHAR pointer
    tstring&         operator=(PCOSTR pO);              // takes const pointer to "other" type (opposite of PCTSTR)
    tstring&         operator=(TCHAR);                  // takes single character of TCHAR type
    tstring&         operator=(TOTHER);                 // takes single character of the "other" type
#ifdef STDSTRING_INC_COMDEF
    tstring&         operator=(const _bstr_t& bstr);    // takes the _bstr_t MS compiler COM support class
#endif

    // These overloads are also needed to fix the MSVC assignment bug (only for our STL - See KB: Q172398)

    tstring&         assign(const tstring& str, tstring::size_type nStart, tstring::size_type nChars);
    tstring&         assign(PCTSTR pT, tstring::size_type nChars);
    tstring&         assign(tstring::size_type nChars, tstring::value_type val);
    tstring&         assign(const tstring& str);
    tstring&         assign(PCTSTR pT);
    tstring&         assign(tstring::const_iterator iterFirst, tstring::const_iterator iterLast);

    // comparison (equality)  

    bool                operator==(const tstring& str) const;
    bool                operator==(const STRBASE& str) const;
    bool                operator==(const STROTHER& str) const;
    bool                operator==(PCTSTR pT) const;
    bool                operator==(PCOSTR pO) const;
    bool                operator==(TCHAR t) const;
    bool                operator==(TOTHER t) const;
    
                        // Note the default here is case INsensitive 
    bool                Equals(PCTSTR pT, bool bUseCase=false) const;   

    // comparison operators (inequality)  

    bool                operator!=(const tstring& str) const;
    bool                operator!=(const STRBASE& str) const;
    bool                operator!=(const STROTHER& str) const;
    bool                operator!=(PCTSTR pT) const;
    bool                operator!=(PCOSTR pO) const;
    bool                operator!=(TCHAR t) const;
    bool                operator!=(TOTHER t) const;

    // comparison operator (less than)

    bool operator<(const tstring& str) const;
    bool operator<(PCTSTR str) const;

    // concatenation.

    const tstring&   operator+=(const tstring& str);
    const tstring&   operator+=(const STRBASE& str);
    const tstring&   operator+=(const STROTHER& str);
    const tstring&   operator+=(PCTSTR pT);
    const tstring&   operator+=(PCOSTR pO);
    const tstring&   operator+=(TCHAR t);
    const tstring&   operator+=(TOTHER t);

#ifdef STDSTRING_INC_COMDEF
    const tstring&   operator+=(const _bstr_t& bstr);
#endif

    // addition operators -- global friend functions.
    friend tstring   operator+(const tstring& str1, const tstring& str2);
    friend tstring   operator+(const tstring& str, TCHAR ch);
    friend tstring   operator+(TCHAR ch, const tstring& str);
    friend tstring   operator+(const tstring& str, TOTHER ch);
    friend tstring   operator+(TOTHER ch, const tstring& str);
    friend tstring   operator+(const tstring& str, PCTSTR sz);
    friend tstring   operator+(PCTSTR sz, const tstring& str);
    friend tstring   operator+(const tstring& str, PCOSTR sz);
    friend tstring   operator+(PCOSTR sz, const tstring& str);

#ifdef STDSTRING_INC_COMDEF
    friend tstring   operator+(const _bstr_t& bstr, const tstring& str);
    friend tstring   operator+(const tstring& str, const _bstr_t& bstr);
#endif

    // Conversion to "other" type of string (i.e. to string if we're a wstring, to wstring if we're a string)

    STROTHER Other() const 
    { 
        USES_CONVERSION; 
        return T2CO(c_str()); 
    };

    
    // General utility stuff

    LPTSTR          GetBuffer(int n = -1)
    {
        if ( (-1 != n) && (n > (int)length()) )
            resize(n);
        return (LPTSTR) data();
    }

    void            ReleaseBuffer( int n = -1 )
    {
        if (-1 == n)
            n = _tcslen( data() );
        resize(n);
    }

    operator CComBSTR() const
    {
        PCTSTR pFoo = *this;
        return CComBSTR( pFoo );
    }
                    operator PCTSTR() const;                // implicit cast to const TCHAR*
    bool            Load(UINT nId);                         // load using resource id
    tstring&        Format(PCTSTR szFormat, ...);           // format using literal string
    tstring&        Format(UINT nId, ...);                  // format using resource string identifier
    tstring&        FormatV(PCTSTR szFormat, va_list argList);  // format using a va_list instead of ...
    tstring&        TrimRight();                            // chop off all whitespace characters on right
    tstring&        TrimLeft();                             // chop off all whitespace characters on left
    tstring&        ToUpper();                              // make uppercase
    tstring&        ToLower();                              // make lowercase
    bool            IsEmpty() const { return empty(); };
    
    TCHAR&          operator[](int nIdx);
    const TCHAR&    operator[](int nIdx) const; 

#ifdef STDSTRING_INC_COMDEF
    HRESULT                 StreamSave(IStream* pStream) const;     // write to an IStream
    HRESULT                 StreamLoad(IStream* pStream);           // read from an IStream;
    ULONG                   StreamSize() const;                     // how many bytes needed to write to an IStream?
#endif

    // These static functions simplify copying one C-style string to another, either one or two byte.

    static  void            CopyString(PCTSTR p_szSource, PTSTR p_szDest, int p_nMaxChars=0);
    static  void            CopyString(PCOSTR p_szSource, POSTR p_szDest, int p_nMaxChars=0);
    static  void            CopyString(PCSTR p_szSource, PWSTR p_szDest, int p_nMaxChars=0);
    static  void            CopyString(PCWSTR p_szSource, PSTR, int p_nMaxChars=0);

    // If this is NOT an MFC build, provide a SetResourceHandle function so that those who call
    // the versions of Load(), Format(), or the constructor that take resource IDs can provide
    // an alternate HINST of a DLL to search.  This is not exactly the list of link libraries
    // that MFC provides but it's better than nothing.    

    static  void            SetResourceHandle(HINSTANCE hNew);
    static  HINSTANCE       GetResourceHandle();

protected:

#if !defined(_MFC_VER)
    static      HINSTANCE   hInstResource;                      // implementation of Get/SetResourceHandle in non-MFC builds
#endif
};

#define _TRES(pctstr) (LOWORD((pctstr)))                 // shorthand conversion from PCTSTR to string resource ID

// tstring inline constructors

inline tstring::tstring() {}
inline tstring::tstring(const STRBASE& str) { *this = str; };

//inline tstring::tstring(PCTSTR pT) { *this = (pT == NULL ? szTNull : pT); };

inline tstring::tstring(PCOSTR pO) { *this = (pO == NULL ? szONull : pO); };
inline tstring::tstring(const tstring& str) { *this = str; };
inline tstring::tstring(const STROTHER& str) { *this = str; };
inline tstring::tstring(const_iterator first, const_iterator last) : STRBASE(first, last) {};
inline tstring::tstring(size_type nSize, value_type ch, const allocator_type& al) : STRBASE(nSize, ch, al) { }
#ifdef STDSTRING_INC_COMDEF
    inline tstring::tstring(const _bstr_t& bstr) { *this = static_cast<PCTSTR>(bstr); }
#endif

// tstring inline assignment operators -- the erase() function
// call fixes the MSVC assignment bug (see knowledge base article Q172398).

inline tstring& tstring::operator=(const tstring& str)
{ if ( str.data() != data() ) { erase(); STRBASE::assign(str.data());} return *this; };
inline tstring& tstring::operator=(const STRBASE& str)
{ if ( str.data() != data() ) { erase(); STRBASE::assign(str.data());} return *this; };
inline tstring& tstring::operator=(const STROTHER& str)
{  erase(); USES_CONVERSION; STRBASE::assign(O2CT(str.data())); return *this; };
inline tstring& tstring::operator=(PCTSTR pT)
{ if ( pT != data() ) { erase(); if ( pT != NULL ) STRBASE::assign(pT); } return *this; };
inline tstring& tstring::operator=(PCOSTR pO)
{ erase(); if ( pO != NULL ) { USES_CONVERSION; STRBASE::assign(O2CT(pO)); } return *this; };
inline tstring& tstring::operator=(TOTHER t)
{ erase(); USES_CONVERSION; STRBASE::assign(O2CT(&t)); return *this; };
inline tstring& tstring::operator=(TCHAR t) 
{ erase(); STRBASE::assign(1,t); return *this; };
#ifdef STDSTRING_INC_COMDEF
    inline tstring& tstring::operator=(const _bstr_t& bstr)
    { return operator=(static_cast<PCTSTR>(bstr)); }
#endif

// These overloads are also needed to fix the MSVC assignment bug (KB: Q172398)
//  *** Thanks to Pete The Plumber for catching this one ***

inline tstring& tstring::assign(const tstring& str, tstring::size_type nStart, tstring::size_type nChars)
{ if( str.data() != data() ) erase(); STRBASE::assign(str, nStart, nChars); return *this; }
inline tstring& tstring::assign(PCTSTR pT, tstring::size_type nChars)
{ if( pT != data() ) erase(); STRBASE::assign(pT, nChars); return *this; }
inline tstring& tstring::assign(tstring::size_type nChars, tstring::value_type val)
{ erase(); STRBASE::assign(nChars, val); return *this; }
inline tstring& tstring::assign(const tstring& str)
{ return assign(str, 0, npos); }
inline tstring& tstring::assign(PCTSTR pT)
{ return assign(pT, tstring::traits_type::length(pT)); }
inline tstring& tstring::assign(tstring::const_iterator iterFirst, tstring::const_iterator iterLast)
{ replace(begin(), end(), iterFirst, iterLast); return *this; }


// tstring inline comparison (equality) 
 
inline bool tstring::operator==(const tstring& str) const
{ return compare(str.c_str()) == 0; };
inline bool tstring::operator==(const STRBASE& str) const
{ return compare(str.data()) == 0; };
inline bool tstring::operator==(const STROTHER& str) const
{ USES_CONVERSION; return compare(O2CT(str.data())) == 0; };
inline bool tstring::operator==(PCTSTR pT) const
{ return compare(pT) == 0; };
inline bool tstring::operator==(PCOSTR pO) const
{ USES_CONVERSION; return compare(O2CT(pO)) == 0; };
inline bool tstring::operator==(TCHAR t) const
{ return operator==(STRBASE(1,t)); };
inline bool tstring::operator==(TOTHER t) const
{ USES_CONVERSION; return operator==(tstring(O2CT(&t))); };
inline bool tstring::Equals(PCTSTR pT, bool bUseCase/*=false*/) const       // defaults to case insensitive
{ return  bUseCase ? compare(pT) == 0 : _tcsicmp(tstring(*this), pT) == 0; } // get copy, THEN compare (thread safe)
//inline bool tstring::WildcardEquals(PCTSTR pT, bool bUseCase/*=false*/) const       // defaults to case insensitive
//{ tstring me(*this), mask(pT); if( !bUseCase ) { me.ToUpper(); mask.ToUpper(); } return Wildstrcmp(me, mask); } // get copy, THEN compare (thread safe)


// tstring inline comparison operators (inequality) 
 
inline bool tstring::operator!=(const tstring& str) const
{ return compare(str.c_str()) != 0; };
inline bool tstring::operator!=(const STRBASE& str) const
{ return compare(str.data()) != 0; };
inline bool tstring::operator!=(const STROTHER& str) const
{ USES_CONVERSION; return compare(O2CT(str.data())) != 0; };
inline bool tstring::operator!=(PCTSTR pT) const
{ return compare(pT) != 0; };
inline bool tstring::operator!=(PCOSTR pO) const
{ USES_CONVERSION; return compare(O2CT(pO)) != 0; };
inline bool tstring::operator!=(TCHAR t) const
{ return operator!=(STRBASE(1,t)); };
inline bool tstring::operator!=(TOTHER t) const
{ USES_CONVERSION; return operator!=(tstring(O2CT(&t))); };


// tstring comparison operator (less than)

inline bool tstring::operator<(const tstring& str) const
{ return compare(str) < 0; };
inline bool tstring::operator<(PCTSTR str) const
{ return compare(str) < 0; };

// tstring inline concatenation.

inline const tstring& tstring::operator+=(const tstring& str)
{ append(str); return *this; };
inline const tstring& tstring::operator+=(const STRBASE& str)
{ append(str); return *this; };
inline const tstring& tstring::operator+=(const STROTHER& str)
{ USES_CONVERSION; *this += O2CT(str.c_str()); return *this; };
inline const tstring& tstring::operator+=(PCTSTR pT)
{ if ( pT != NULL ) append(pT); return *this; };
inline const tstring& tstring::operator+=(PCOSTR pO)
{ USES_CONVERSION; if ( pO != NULL ) append(O2CT(pO)); return *this; };
inline const tstring& tstring::operator+=(TCHAR t)
{ append(1, t); return *this; };
inline const tstring& tstring::operator+=(TOTHER t)
{ USES_CONVERSION; append(O2CT(&t)); return *this; };
#ifdef STDSTRING_INC_COMDEF
    inline const tstring& tstring::operator+=(const _bstr_t& bstr)
    { return operator+=(static_cast<PCTSTR>(bstr)); }
#endif

// tstring friend addition functions defined as inline

inline tstring operator+(const tstring& str1, const tstring& str2)
{ tstring strRet(str1); return strRet.append(str2); }
inline tstring operator+(const tstring& str, TCHAR ch)
{ tstring strRet(str); return strRet.append(1, ch); }
inline tstring operator+(TCHAR ch, const tstring& str)
{ tstring strRet(1, ch); return strRet.append(str); }
inline tstring operator+(const tstring& str, TOTHER ch)
{ return str + STROTHER(1, ch).data(); }
inline tstring operator+(TOTHER ch, const tstring& str)
{ tstring strRet; strRet = ch; return strRet.append(str); }
inline tstring operator+(const tstring& str, PCTSTR sz)
{ tstring strRet(str); return sz == NULL ? strRet : strRet.append(sz); }
inline tstring operator+(PCTSTR sz, const tstring& str)
{ tstring strRet(sz); return strRet.append(str); }
inline tstring operator+(const tstring& str, PCOSTR sz)
{ tstring strRet(str); return strRet.append(tstring(sz)); }
inline tstring operator+(PCOSTR sz, const tstring& str)
{ tstring strRet(sz); return strRet.append(str); }
#ifdef STDSTRING_INC_COMDEF
    inline tstring operator+(const _bstr_t& bstr, const tstring& str)
    { return tstring(static_cast<PCTSTR>(bstr)) + str; }
    inline tstring operator+(const tstring& str, const _bstr_t& bstr)
    { return str + static_cast<PCTSTR>(bstr); }
#endif



inline TCHAR&       tstring::operator[](int nIdx) { return STRBASE::operator[](nIdx); }
inline const TCHAR& tstring::operator[](int nIdx) const { return STRBASE::operator[](nIdx); }
inline              tstring::operator PCTSTR() const { return c_str(); };    // implicit cast to const TCHAR*


// In MFC builds, define some global serialization operators

#ifdef _MFC_VER
     CArchive& AFXAPI operator>>(CArchive& ar, tstring& string);
     CArchive& AFXAPI operator<<(CArchive& ar, const tstring& string);
    inline void tstring::SetResourceHandle(HINSTANCE hNew) { AfxSetResourceHandle(hNew); }
    inline HINSTANCE tstring::GetResourceHandle() { return AfxGetResourceHandle(); };
#else
    
    // Because we're a template with no C file, we can't simply have a glocal static
    // HINSTANCE.  Instead, we have a class-static function which in turn has a static
    // HINSTANCE.  Since only that class-static function has access to the HINSTANCE,
    // it has the ability to set or retrieve its static HINSTANCE.
    //
    // In short, the HInstanceSingleton is static to the class, and its _hInstance
    // variable is static to the HInstanceSingleton function, so the _hInstance variable
    // is static to the class.

    inline const HINSTANCE & HInstanceSingleton(HINSTANCE hNew = NULL, bool bSet = false)
    {
        static HINSTANCE _hInstance = ::GetModuleHandle(NULL);
        if (bSet)
            _hInstance = hNew;
        return _hInstance;        
    }
    inline void tstring::SetResourceHandle(HINSTANCE hNew) 
    {
        HInstanceSingleton(hNew, true); 
    }
    inline HINSTANCE tstring::GetResourceHandle() 
    { 
        return HInstanceSingleton(); 
    };
#endif

// Some code still refers to old names of this class -- Account for this.
#define CSTLString  tstring
#define CW32String  tstring

// WUSysMessage -- return the system string corresponding to a system error or HRESULT value.
tstring WUSysMessage(DWORD dwError, DWORD p_dwLangId=MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT));

// WUFormat -- creates and formats a tstring with one line of code instead of the two it normally takes
tstring WUFormat(PCTSTR szFormat, ...);
tstring WUFormat(UINT nId, ...);

// Functional Comparators
//
//      These structs are derived from the std::binary_function template.  They give us functional
//      classes (which may be used in Standard C++ Library collections and algorithms) that perform
//      case-insensitive comparisons of tstring objects.  This is useful for maps in which the key
//      may be the proper string but in the wrong case.

#define tstring_lessnocase     _SSLNC      // define shorter name to avoid compiler warning 4786
#define tstring_comparenocase  _SSENC      // define shorter name to avoid compiler warning 4786

struct  tstring_lessnocase : std::binary_function<tstring, tstring, bool>
{
    bool operator()(const tstring& strFirst, const tstring& strSecond) const
    { 
        return _tcsicmp(strFirst, strSecond) < 0; 
    }
};

struct  tstring_comparenocase : std::binary_function<tstring, tstring, bool>
{
    bool operator()(const tstring& strFirst, const tstring& strSecond) const
    { 
        return _tcsicmp(strFirst, strSecond) == 0; 
    }
};

#endif  // #ifndef _STDSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shtl\tstring.cpp ===
//  FILE:  tstring.cpp
//  AUTHOR: Davepl
//  REMARKS:
//
//      (c) 1999 Dave Plummer.  Portions of this code derived from source 
//      produced by Joe O'Leary with the following license:
//        > This code is free.  Use it anywhere you want.  Rewrite
//        > it, restructure it, whatever you want.  Please don't blame me if it causes your
//        > $30 billion dollar satellite to explode.  If you redistribute it in any form, I
//        > would appreciate it if you would leave this notice here.

#include "shtl.h"
#include "tstring.h"

#include <xutility>

#if defined (max)
    #undef max
    #undef min
#endif

#define max(a,b) std::_cpp_max(a,b)
#define min(a,b) std::_cpp_min(a,b)

#include <algorithm>
#include <functional>
#include <locale>

// If conversion has NOT been explicitly turned off...

#ifndef _NO_STDCONVERSION
    
    // Global MBCS-to-UNICODE helper function

    __DATL_INLINE PWSTR  StdA2WHelper(PWSTR pw, PCSTR pa, int nChars)
    {
        if (pa == NULL)
            return NULL;
        ASSERT(pw != NULL);
        pw[0] = '\0';
        VERIFY(MultiByteToWideChar(CP_ACP, 0, pa, -1, pw, nChars));
        return pw;
    }

    // Global UNICODE-to_MBCS helper function

    __DATL_INLINE PSTR StdW2AHelper(PSTR pa, PCWSTR pw, int nChars)
    {
        if (pw == NULL)
            return NULL;
        ASSERT(pa != NULL);
        pa[0] = '\0';
        VERIFY(WideCharToMultiByte(CP_ACP, 0, pw, -1, pa, nChars, NULL, NULL));
        return pa;
    }

#endif // _NO_STDCONVERSION

// CONSTRUCTOR:  tstring::tstring
//      tstring(PCTSTR pT)
//           
// DESCRIPTION:
//      This particular overload of the tstring constructor takes either a real
//      string or a resource ID which has been converted with the MAKEINTRESOURCE()
//      macro
//
// PARAMETERS: 
//      pT  - a NULL-terminated raw string with which the tstring object should be
//            initialized or a resource ID converted with MAKEINTRESOURCE (or NULL)

__DATL_INLINE tstring::tstring(PCTSTR pT) : STRBASE(szTNull)  // constructor for either a literal string or a resource ID
{ 
    if ( pT == NULL )
        ;
    else if ( HIWORD(pT) == 0 ) 
    { 
        if ( !Load(_TRES(pT)) ) 
            TRACE(_T("Can't load string %u\n"), _TRES(pT));
    } 
    else
        *this = pT;
}

__DATL_INLINE tstring::tstring(UINT nID) : STRBASE(szTNull)
{
    if ( !Load(nID) ) 
        TRACE(_T("Can't load string %u\n"), nID);
}

// FUNCTION:  tstring::Load
//      bool Load(UINT nId)
//           
// DESCRIPTION:
//      This function attempts to load the specified string resource from application's
//      resource table.
//
// PARAMETERS: 
//      nId - the resource Identifier from the string table.
//
// RETURN VALUE: 
//      true if the function succeeds, false otherwise


#define MAX_LOAD_TRIES  8           // max # of times we'll attempt to load a string
#define LOAD_BUF_SIZE   256         

__DATL_INLINE bool tstring::Load(UINT nId)
{
#ifdef _MFC_VER
    CString strRes(MAKEINTRESOURCE(nId));
    *this = strRes;
    return !empty();

#else
    
    // Get the resource name via MAKEINTRESOURCE.  This line is pretty much lifted from CString

    HINSTANCE hInstance = tstring::GetResourceHandle();

    HRSRC hrsrc;
    int cwch = 0;
    WCHAR * pwch;

    // String tables are broken up into "bundles" of 16 strings each.

    if (HIWORD(nId) == 0) 
    {
        hrsrc = ::FindResource(hInstance, reinterpret_cast<LPTSTR>((UINT_PTR)(1 + nId / 16)), RT_STRING);
        if (hrsrc) 
        {
            pwch = (PWCHAR)LoadResource(hInstance, hrsrc);
            if (pwch) 
            {
                // Now skip over the strings in the resource until we
                // hit the one we want.  Each entry is a counted string,
                // just like Pascal.
             
                for (nId %= 16; nId; nId--) {
                    pwch += *pwch + 1;
                }
                cwch = *pwch;
                if (cwch)
                {
                    LPTSTR pszBuffer = GetBuffer(cwch);
                    #ifdef UNICODE
                        memcpy(pszBuffer, pwch+1, cwch * sizeof(WCHAR)); /* Copy the goo */
                    #else
                        WideCharToMultiByte(CP_ACP, 0, pwch+1, cwch, pszBuffer, cwch+1, NULL, NULL);
                    #endif
            
                    *(pszBuffer+cwch) = TEXT('\0');
                    ReleaseBuffer(cwch);
                }
            }
        }
    }
    return (cwch != 0);

#endif
}

// FUNCTION:  tstring::Format
//      void _cdecl Formst(tstring& PCTSTR szFormat, ...)
//      void _cdecl Format(PCTSTR szFormat);
//           
// DESCRIPTION:
//      This function does sprintf/wsprintf style formatting on tstring objects.  It
//      is very much a copy of the MFC CString::Format function.  Some people might even
//      call this identical.  However all these people are now dead.
//
// PARAMETERS: 
//      nId - ID of string resource holding the format string
//      szFormat - a PCTSTR holding the format specifiers
//      argList - a va_list holding the arguments for the format specifiers.
//
// RETURN VALUE:  None.

__DATL_INLINE tstring& tstring::Format(UINT nId, ...)
{
    va_list argList;
    va_start(argList, nId);

    tstring strFmt;
    if ( strFmt.Load(nId) )
        FormatV(strFmt, argList);

    va_end(argList); 
    return *this;
}

__DATL_INLINE tstring& tstring::Format(PCTSTR szFormat, ...)
{
    va_list argList;
    va_start(argList, szFormat);
    FormatV(szFormat, argList);
    va_end(argList);
    return *this;
}


// FUNCTION:  tstring::FormatV
//      void FormatV(PCTSTR szFormat, va_list, argList);
//           
// DESCRIPTION:
//      This function formats the string with sprintf style format-specifications.  It
//      makes a general guess at required buffer size and then tries successively larger
//      buffers until it finds one big enough or a threshold (MAX_FMT_TRIES) is exceeded.
//
// PARAMETERS: 
//      szFormat - a PCTSTR holding the format of the output
//      argList  - va_list for variable argument lists
//
// RETURN VALUE: 


#define MAX_FMT_TRIES   5
#define FMT_BLOCK_SIZE  256

__DATL_INLINE tstring& tstring::FormatV(PCTSTR szFormat, va_list argList)
{
    va_list argListSave = argList;

    // We're just going to use the normal _vsntprintf function, assuming FMT_BLOCK_SIZE characters.
    // However, if FMT_BLOCK_SIZE characters is not be enough, we will try 2 * FMT_BLOCK_SIZE, then
    // 3 * FMT_BLOCK_SIZE, up to MAX_FMT_TRIES * FMT_BLOCK_SIZE characters.

    int nTriesLeft = MAX_FMT_TRIES-1;
    int nCharsUsed = - 1;
    int nTChars = 0;

    // Keep looping until either we succeed or we have exhausted the number of tries

    do
    
    {
        nTChars += FMT_BLOCK_SIZE;      // number of TCHARS in the string

        // Allocate a buffer on the stack to hold the characters and NULL terminate it

        TCHAR* szBuf = reinterpret_cast<TCHAR*>(_alloca((nTChars+1) * sizeof(TCHAR)));
        szBuf[nTChars+1] = '\0';

        // Now try the actual formatting.  The docs say even the wide version takes the
        // number of BYTES as the second argument, not the number of characters (TCHARs).
        // However the docs are wrong.  I checked the actual implementation of 
        // _vsnprintf and _vsnwprintf and they multiply count by sizeof TCHAR. 

        nCharsUsed = _vsntprintf(szBuf, nTChars+1, szFormat, argListSave);
        if ( nCharsUsed >= 0 )
            *this = szBuf;

    } while ( nCharsUsed < 0 && nTriesLeft > 0);

    va_end(argListSave);
    return *this;
}

// This class is used for TrimRight() and TrimLeft() function implementations.

class NotSpace : public std::unary_function<TCHAR, bool>
{
public:
    inline bool operator() (TCHAR tchar) 
    { 
        return !_istspace(tchar); 
    };
};

// FUNCTION:  tstring::TrimRight
//      tstring& TrimRight();
//
// DESCRIPTION:
//      This function removes any whitespace characters from the right end of the string.
//
// PARAMETERS: none
// RETURN VALUE:
//      a reference to this object (*this) -- allows chaining together of
//      these calls, eg. strTest.TrimRight().TrimLeft().ToUpper();

__DATL_INLINE tstring& tstring::TrimRight()
{
    tstring::reverse_iterator iter = std::find_if(rbegin(), rend(), NotSpace());
    if ( iter != rend() )
    {
        tstring::size_type nNewSize = find_last_of(*iter);
        erase(nNewSize+1);
    }
    else
    {
        erase();
    }
    return *this;
}

// FUNCTION:  tstring::TrimLeft
//      tstring& TrimLeft();
//
// DESCRIPTION:
//      This function removes any whitespace characters from the left end of the string.
//
// PARAMETERS: none
// RETURN VALUE:
//      a reference to this object (*this) -- allows chaining together of
//      these calls, (eg. strTest.TrimRight().TrimLeft().ToUpper();)

__DATL_INLINE tstring& tstring::TrimLeft()
{
    tstring::iterator iter = std::find_if(begin(), end(), NotSpace());
    tstring strNew(iter, end());
    STRBASE::assign(strNew);
    return *this;
}

// FUNCTION:  tstring::ToUpper
//      tstring& ToUpper()
//           
// DESCRIPTION:
//      This function converts the tstring to all uppercase characters using ctype
//
// PARAMETERS: 
// RETURN VALUE: 
//      a reference to this object (*this) -- allows chaining together of
//      these calls, (eg. strTest.TrimRight().TrimLeft().ToUpper();)


__DATL_INLINE tstring& tstring::ToUpper()
{
    //  std::transform(begin(), end(), begin(), toupper);   // slow and portable
    _tcsupr(const_cast<PTSTR>(data()));                     // fast and not portable
    return *this;
}



// FUNCTION:  tstring::ToLower
//      tstring& ToLower()
//           
// DESCRIPTION:
//      This function converts the tstring to all lowercase characters using ctype
//
// PARAMETERS: 
// RETURN VALUE: 
//      a reference to this object (*this) -- allows chaining together of
//      these calls, (eg. strTest.ToLower().TrimLeft().ToUpper();)

__DATL_INLINE tstring& tstring::ToLower()
{
    //std::transform(begin(), end(), begin(), tolower); // portable, slow way of doing it
    _tcslwr(const_cast<PTSTR>(data()));                 // unportable, fast way of doing it
    return *this;
}

// FUNCTION:  tstring::CopyString
//      static void CopyString(PCTSTR p_szSource, PTSTR p_szDest, int p_nMaxChars=0);
//      static void CopyString(PCOSTR p_szSource, POSTR p_szDest, int p_nMaxChars=0);
//      static void CopyString(PCSTR p_szSource, PWSTR p_szDest, int p_nMaxChars=0);
//      static void CopyString(PCWSTR p_szSource, PSTR p_szDest, int p_nMaxChars=0);
//
// DESCRIPTION:
//      These 3 overloads simplify copying one C-style string into another.
//
// PARAMETERS: 
//      p_szSource - the string to be copied FROM.  May be either an MBCS string (char) or
//                   a wide string (wchar_t)
//      p_szDest - the string to be copied TO.  Also may be either MBCS or wide
//      p_nMaxChars - the maximum number of characters to be copied into p_szDest.  Note
//                    that this is expressed in whatever a "character" means to p_szDest.
//                    If p_szDest is a wchar_t type string than this will be the maximum
//                    number of wchar_ts that my be copied.  The p_szDest string must be
//                    large enough to hold least p_nMaxChars+1 characters.


__DATL_INLINE void tstring::CopyString(PCTSTR p_szSource, PTSTR p_szDest, int p_nMaxChars)
{
    int nSrcLen = ( p_szSource == NULL ? 0 : _tcslen(p_szSource) );
    int nChars = ( p_nMaxChars > 0 ? min(p_nMaxChars,nSrcLen) : nSrcLen );
    memcpy(p_szDest, p_szSource, nChars * sizeof(TCHAR));
    p_szDest[nChars] = '\0';
}

__DATL_INLINE void tstring::CopyString(PCOSTR p_szSource, POSTR p_szDest, int p_nMaxChars)
{
    #ifdef _UNICODE
        int nSrcLen = ( p_szSource == NULL ? 0 : strlen(p_szSource) );
    #else
        int nSrcLen = ( p_szSource == NULL ? 0 : wcslen(p_szSource) );
    #endif

    int nChars = ( p_nMaxChars > 0 ? min(p_nMaxChars,nSrcLen) : nSrcLen );
    memcpy(p_szDest, p_szSource, nChars * sizeof(TOTHER));
    p_szDest[nChars] = '\0';
}

__DATL_INLINE void tstring::CopyString(PCSTR p_szSource, PWSTR p_szDest, int p_nMaxChars)
{
    USES_CONVERSION;
    PCWSTR szConverted = (A2W(p_szSource));
    int nSrcLen = ( szConverted == NULL ? 0 : wcslen(szConverted) );
    int nChars = ( p_nMaxChars > 0 ? min(p_nMaxChars,nSrcLen) : nSrcLen );
    memcpy(p_szDest, szConverted, nChars * sizeof(wchar_t));
    p_szDest[nChars] = '\0';
}

__DATL_INLINE void tstring::CopyString(PCWSTR p_szSource, PSTR p_szDest, int p_nMaxChars)
{
    USES_CONVERSION;
    PCSTR szConverted = (W2A(p_szSource));
    int nSrcLen = ( szConverted == NULL ? 0 : strlen(szConverted) );
    int nChars = ( p_nMaxChars > 0 ? min(p_nMaxChars,nSrcLen) : nSrcLen );
    memcpy(p_szDest, szConverted, nChars);
    p_szDest[nChars] = '\0';
}


// Special, TEMPORARY operators that allow us to serialize tstrings to CArchives.

#ifdef _MFC_VER
__DATL_INLINE CArchive& AFXAPI operator<<(CArchive& ar, const tstring& string)
{
    USES_CONVERSION;

    // All tstrings are serialized as wide strings
    PCWSTR pWide = T2CW(string.data());
    int nChars = wcslen(pWide);
    ar << nChars;
    ar.Write(pWide, nChars*sizeof(wchar_t));
    return ar;
}

__DATL_INLINE CArchive& AFXAPI operator>>(CArchive& ar, tstring& string)
{
    // All tstrings are serialized as wide strings
    UINT nLen;
    ar >> nLen;
    if ( nLen > 0 )
    {
        UINT nByteLen = nLen * sizeof(wchar_t);
        PWSTR pWide = (PWSTR)_alloca(nByteLen+sizeof(wchar_t));
        VERIFY(ar.Read(pWide, nByteLen) == nByteLen);
        pWide[nLen] = '\0';
        string = tstring(pWide);
    }
    else
    {
        string.erase();
    }
    return ar;
}
#endif
#ifdef STDSTRING_INC_COMDEF


// FUNCTION: tstring::StreamSave
//      HRESULT StreamSave(IStream* pStream) const;
//
// DESCRIPTION:
//      This function write the length and contents of the tstring object
//      out to an IStream as a char based string;
//
// PARAMETERS:
//      pStream - the stream to which the string must be written
//
// RETURN VALUE: 
//      HRESULT return valued of IStream Write function


__DATL_INLINE HRESULT tstring::StreamSave(IStream* pStream) const
{
    USES_CONVERSION;
    HRESULT hr = E_FAIL;
    ASSERT(pStream != NULL);

    // All tstrings are serialized as wide strings

    PCSTR pStr = T2CA(this->data());
    ULONG nChars = strlen(pStr);

    if ( FAILED(hr=pStream->Write(&nChars, sizeof(ULONG), NULL)) )
        TRACE(_T("tstring::StreamSave -- Unable to write length to IStream due to error 0x%X\n"), hr);
    else if ( FAILED(hr=pStream->Write(pStr, nChars*sizeof(char), NULL)) )
        TRACE(_T("tstring::StreamSave -- Unable to write string to IStream due to error 0x%X\n"), hr);

    return hr;
}


// FUNCTION: tstring::StreamLoad
//      HRESULT StreamLoad(IStream* pStream);
//
// DESCRIPTION:
//      This function reads in a tstring object from an IStream
//
// PARAMETERS:
//      pStream - the stream from which the string must be read
//
// RETURN VALUE: 
//      HRESULT return value of the IStream Read function


__DATL_INLINE HRESULT tstring::StreamLoad(IStream* pStream)
{
    // All tstrings are serialized as char strings
    ASSERT(pStream != NULL);

    ULONG nChars;
    HRESULT hr = E_FAIL;
    if ( FAILED(hr=pStream->Read(&nChars, sizeof(ULONG), NULL)) )
    {
        TRACE(_T("tstring::StreamLoad -- Unable to read length from IStream due to error 0x%X\n"), hr);
    }
    else if ( nChars > 0 )
    {
        ULONG nByteLen = nChars * sizeof(char);
        PSTR pStr = (PSTR)_alloca(nByteLen+sizeof(char));       // add an extra char for terminating NULL
        if ( FAILED(hr=pStream->Read(pStr, nByteLen, NULL)) )
            TRACE(_T("tstring::StreamLoad -- Unable to read string from IStream due to error 0x%X\n"), hr);
        pStr[nChars] = '\0';
        *this = tstring(pStr);
    }
    else
    {
        this->erase();
    }
    return hr;
}


// FUNCTION: tstring::StreamSize
//      ULONG StreamSize() const;   
//           
// DESCRIPTION:
//      This function tells the caller how many bytes will be required to write
//      this tstring object to an IStream using the StreamSave() function.
//      This is the capability lacking in CComBSTR which would force an IPersistXXX
//      implementation to know the implementation details of CComBSTR::StreamSave
//      in order to use CComBSTR in an IPersistXXX implementation.  
//
// PARAMETERS: none
// RETURN VALUE: 
//      length in >> bytes << required to write the tstring

__DATL_INLINE ULONG tstring::StreamSize() const
{
    USES_CONVERSION;
    return ( strlen(T2CA(this->data())) * sizeof(char) ) + sizeof(ULONG);
/// return ( wcslen(T2CW(this->data())) * sizeof(wchar_t) ) + sizeof(ULONG);
}

#endif



// FUNCTION: WUSysMessage
//      TSTRING WUSysMessage(DWORD p_dwError, bool bUseDefault=false)
//           
// DESCRIPTION:
//      This function simplifies the process of obtaining a string equivalent
//      of a system error code returned from GetLastError().  You simply
//      supply the value returned by GetLastError() to this function and the
//      corresponding system string is returned in the form of a tstring.
//
// PARAMETERS: 
//      p_dwError - a DWORD value representing the error code to be translated
//      p_dwLangId - the language id to use.  defaults to english.
//
// RETURN VALUE: 
//      a tstring equivalent of the error code.  Currently, this function
//      only returns either English of the system default language strings.  

#define MAX_FMT_TRIES   5
#define FMT_BLOCK_SIZE  256
__DATL_INLINE tstring WUSysMessage(DWORD p_dwError, DWORD p_dwLangId)
{
    TCHAR szBuf[512];

    if ( ::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, p_dwError, p_dwLangId, szBuf, 511, NULL) != 0 )
        return WUFormat(_T("%s (0x%X)"), szBuf, p_dwError);
    else
        return WUFormat(_T("Unknown error (0x%X)"), p_dwError);
}

// GLOBAL FUNCTION:  WUFormat
//      tstring WUFormat(UINT nId, ...);
//      tstring WUFormat(PCTSTR szFormat, ...);
//
// REMARKS:
//      This function allows the caller for format and return a tstring object with a single line
//      of code.  Frequently you want to print out a formatted string but don't care about it once
//      you are done with it.  You end up having to create temporary tstring objects and then
//      calling their Format() functions.   By using this function instead, you can cut down on the
//      clutter.

__DATL_INLINE tstring WUFormat(UINT nId, ...)
{
    va_list argList;
    va_start(argList, nId);

    tstring strFmt;
    tstring strOut;
    if ( strFmt.Load(nId) )
        strOut.FormatV(strFmt, argList);

    va_end(argList);
    return strOut;
}

__DATL_INLINE tstring WUFormat(PCTSTR szFormat, ...)
{
    va_list argList;
    va_start(argList, szFormat);
    tstring strOut;
    strOut.FormatV(szFormat, argList);
    va_end(argList);
    return strOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\findimgs.h ===
#ifndef __cd172658_dfdf_459d_850b_74ccd8a3053e__
#define __cd172658_dfdf_459d_850b_74ccd8a3053e__

#include <windows.h>
#include "findfile.h"
#include "simarray.h"

class CFindImageFiles
{
private:
    CSimpleDynamicArray<CSimpleString> m_ImageFiles;
    int                                m_nCurrentFile;

private:
    CFindImageFiles( const CFindImageFiles & );
    CFindImageFiles &operator=( const CFindImageFiles & );

public:
    CFindImageFiles(void);
    virtual ~CFindImageFiles(void);

    bool NextFile( CSimpleString &strFilename );
    bool PreviousFile( CSimpleString &strFilename );
    bool FoundFile( LPCTSTR pszFilename )
    {
        if (pszFilename)
        {
            m_ImageFiles.Append(pszFilename);
        }
        return true;
    }
    
    void Reset(void)
    {
        m_nCurrentFile = 0;
    }
    
    int Count(void) const
    {
        return(m_ImageFiles.Size());
    }
    CSimpleString operator[](int nIndex)
    {
        return(m_ImageFiles[nIndex]);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\findinstance.h ===
#ifndef __d6fae41e_2973_4474_bd22_af0773f51969__
#define __d6fae41e_2973_4474_bd22_af0773f51969__

#include "precomp.h"
#include <tchar.h>

BOOL CALLBACK EnumWindowsProc(HWND hwnd,      // handle to parent window
                              LPARAM lParam   // application-defined value
)
{
    BOOL iRet = FALSE;
    if(hwnd && lParam)
    {
        TCHAR pBuffer[255] = {0};
        if(0 == GetClassName(hwnd,(TCHAR*)&pBuffer,255))
        {
            if(!_tcscmp(pBuffer,MAIN_WINDOW_CLASSNAME))
            {
                *((bool*)lParam) = true;
            }
            iRet = TRUE;
        }
    }
    return iRet;
}

class CFindInstance
{
public:
    CFindInstance()
    {
    }
    ~CFindInstance()
    {
    }

    bool CFindInstance::FindInstance(LPTSTR pWindowClass)
    {
        bool bInstanceFound = false;
        EnumWindows(&EnumWindowsProc,(LPARAM)&bInstanceFound);
        return bInstanceFound;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\findfile.cpp ===
#include "precomp.h"
#include "findfile.h"
#include "simtok.h"

static CSimpleString EnsureTrailingBackslash( const CSimpleString &filename )
{
    if (!filename.Length())
    {
        return (filename + CSimpleString(TEXT("\\")));
    }
    else if (!filename.MatchLastCharacter(TEXT('\\')))
    {
        return (filename + CSimpleString(TEXT("\\")));
    }
    else 
    {
        return filename;
    }
}

bool RecursiveFindFiles( CSimpleString strDirectory, const CSimpleString &strMask, FindFilesCallback pfnFindFilesCallback, PVOID pvParam )
{
    bool bFindResult = true;
    bool bContinue = true;
    WIN32_FIND_DATA FindData = {0};
    HANDLE hFind = ::FindFirstFile( EnsureTrailingBackslash(strDirectory) + TEXT("*"), &FindData );
    if (hFind != INVALID_HANDLE_VALUE)
    {
        while (bFindResult && bContinue)
        {
            if ( (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && 
                  lstrcmp(FindData.cFileName,TEXT("..")) && 
                  lstrcmp(FindData.cFileName,TEXT(".")))
            {
                if (pfnFindFilesCallback)
                {
                    bContinue = pfnFindFilesCallback( false, 
                                                      EnsureTrailingBackslash(strDirectory)+FindData.cFileName, 
                                                      &FindData, 
                                                      pvParam );
                }
                if (bContinue)
                {
                    bContinue = ::RecursiveFindFiles( EnsureTrailingBackslash(strDirectory) + FindData.cFileName, 
                                                    strMask, 
                                                    pfnFindFilesCallback, 
                                                    pvParam );
                }
            }
            bFindResult = (::FindNextFile(hFind,&FindData) != FALSE);
        }
        FindClose(hFind);
    }
    CSimpleStringToken<CSimpleString> strMasks(strMask);
    while (bContinue)
    {
        CSimpleString TempMask = strMasks.Tokenize(TEXT(";"));
        if (!TempMask.Length())
        {
            break;
        }
        TempMask.TrimLeft();
        TempMask.TrimRight();
        if (TempMask.Length())
        {
            hFind = ::FindFirstFile( EnsureTrailingBackslash(strDirectory)+TempMask, &FindData );
            if (hFind != INVALID_HANDLE_VALUE)
            {
                bFindResult = true;
                while (bFindResult && bContinue)
                {
                    if (pfnFindFilesCallback)
                    {
                        bContinue = pfnFindFilesCallback( true,
                                                          EnsureTrailingBackslash(strDirectory)+FindData.cFileName,
                                                          &FindData, 
                                                          pvParam );
                    }
                    bFindResult = (FindNextFile(hFind,&FindData) != FALSE);
                }
                FindClose(hFind);
            }
        }
    }
    return bContinue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\findimgs.cpp ===
#include "precomp.h"
#include "findimgs.h"
#include "ssutil.h"

CFindImageFiles::CFindImageFiles(void)
                :m_nCurrentFile(0)
{
}

CFindImageFiles::~CFindImageFiles(void)
{
}

bool CFindImageFiles::NextFile( CSimpleString &strFilename )
{
    bool bResult = false;
    strFilename = TEXT("");
    if (m_ImageFiles.Size())
    {
        if (m_nCurrentFile >= m_ImageFiles.Size())
        {
            m_nCurrentFile = 0;
        }
        strFilename = m_ImageFiles[m_nCurrentFile];
        m_nCurrentFile++;
        bResult = (strFilename.Length() != 0);
    }
    return(bResult);
}

bool CFindImageFiles::PreviousFile( CSimpleString &strFilename )
{
    bool bResult = false;
    strFilename = TEXT("");
    if (m_ImageFiles.Size()==1)
    {
        m_nCurrentFile = 0;
        strFilename = m_ImageFiles[0];
        bResult = (strFilename.Length() != 0);
    }
    else if (m_ImageFiles.Size()>=2)
    {
        m_nCurrentFile--;
        if (m_nCurrentFile < 0)
        {
            m_nCurrentFile = m_ImageFiles.Size()-1;
        }
        int nPrevFile = m_nCurrentFile-1;
        if (nPrevFile < 0)
        {
            nPrevFile = m_ImageFiles.Size()-1;
        }
        strFilename = m_ImageFiles[nPrevFile];
        bResult = (strFilename.Length() != 0);
    }
    return(bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\imgs.h ===
#ifndef __7ce01a97_b0e7_4c05_84c1_bbeae369a488__
#define __7ce01a97_b0e7_4c05_84c1_bbeae369a488__

#include <windows.h>
#include "simdc.h"
#include "simstr.h"

class CBitmapImage
{
private:
    HBITMAP m_hBitmap;
    HPALETTE m_hPalette;

private:
    operator=( const CBitmapImage & );
    CBitmapImage( const CBitmapImage & );

public:
    CBitmapImage(void);
    virtual ~CBitmapImage(void);
    void Destroy(void);
    bool IsValid(void) const;
    HPALETTE Palette(void) const;
    HBITMAP GetBitmap(void) const;
    SIZE ImageSize(void) const;

    HPALETTE PreparePalette( CSimpleDC &dc, HBITMAP hBitmap );

    bool Load( CSimpleDC  &dc, LPCTSTR pszFilename, const RECT &rcScreen, int nMaxScreenPercent, bool bAllowStretching, bool bDisplayFilename );
};

#endif //__IMGS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\findthrd.h ===
#ifndef __2542cbc9_9348_4930_a641_c43c6497181b__
#define __2542cbc9_9348_4930_a641_c43c6497181b__

#include "gphelper.h"

class CFoundFileMessageData
{
private:
    CSimpleString m_strFilename;

private:
    CFoundFileMessageData(void);
    CFoundFileMessageData( const CFoundFileMessageData & );
    CFoundFileMessageData &operator=( const CFoundFileMessageData & );

public:
    CFoundFileMessageData( const CSimpleString &strFilename )
      : m_strFilename(strFilename)
    {
    }
    ~CFoundFileMessageData(void)
    {
    }
    CSimpleString Name(void) const
    {
        return m_strFilename;
    }
};

class CFindFilesThread
{
private:
    CSimpleString       m_strDirectory;
    CSimpleString       m_strMask;
    HWND                m_hwndNotify;
    UINT                m_nNotifyMessage;
    HANDLE              m_hEventCancel;
    int                 m_nDirectoryCount;
    int                 m_nFailedFileCount;
    int                 m_nSuccessfulFileCount;
    int                 m_nMaxFailedFiles;
    int                 m_nMaxSuccessfulFiles;
    int                 m_nMaxDirectories;
    CImageFileFormatVerifier m_ImageFileFormatVerifier;

private:
    CFindFilesThread(
        const CSimpleString &strDirectory,
        const CSimpleString &strMask,
        HWND hwndNotify,
        UINT nNotifyMessage,
        HANDLE hEventCancel,
        int nMaxFailedFiles,
        int nMaxSuccessfulFiles,
        int nMaxDirectories
    )
      : m_strDirectory(strDirectory),
        m_strMask(strMask),
        m_hwndNotify(hwndNotify),
        m_nNotifyMessage(nNotifyMessage),
        m_hEventCancel(NULL),
        m_nDirectoryCount(0),
        m_nFailedFileCount(0),
        m_nSuccessfulFileCount(0),
        m_nMaxFailedFiles(nMaxFailedFiles),
        m_nMaxSuccessfulFiles(nMaxSuccessfulFiles),
        m_nMaxDirectories(nMaxDirectories)
    {
        if (!DuplicateHandle( GetCurrentProcess(), hEventCancel, GetCurrentProcess(), &m_hEventCancel, 0, FALSE, DUPLICATE_SAME_ACCESS ))
            m_hEventCancel = NULL;
    }
    ~CFindFilesThread(void)
    {
        if (m_hEventCancel)
        {
            CloseHandle(m_hEventCancel);
            m_hEventCancel = NULL;
        }
    }

private:
    static bool FoundFile( bool bIsFile, LPCTSTR pszFilename, const WIN32_FIND_DATA *, PVOID pvParam )
    {
        CFindFilesThread *pThis = reinterpret_cast<CFindFilesThread*>(pvParam);
        if (pThis)
            return pThis->FoundFile( bIsFile, pszFilename );
        return false;
    }

    bool FoundFile( bool bIsFile, LPCTSTR pszFilename )
    {
        //WIA_PUSH_FUNCTION((TEXT("CFindFilesThread::FoundFile( %d, %s )"), bIsFile, pszFilename ));
        // Check to see if we've been cancelled
        if (m_hEventCancel)
        {
            DWORD dwRes = WaitForSingleObject(m_hEventCancel,0);
            if (WAIT_OBJECT_0 == dwRes)
                return false;
        }

        // If this is a file, and it is an image file that we can decode, package up a message and send it off
        if (bIsFile)
        {
            if (m_nNotifyMessage && m_hwndNotify && IsWindow(m_hwndNotify))
            {
                if (m_ImageFileFormatVerifier.IsImageFile(pszFilename))
                {
                    m_nSuccessfulFileCount++;
                    CFoundFileMessageData *pFoundFileMessageData = new CFoundFileMessageData( pszFilename );
                    if (pFoundFileMessageData)
                    {
                        PostMessage( m_hwndNotify, m_nNotifyMessage, true, reinterpret_cast<LPARAM>(pFoundFileMessageData) );
                    }
                }
                else m_nFailedFileCount++;
            }
        }
        else m_nDirectoryCount++;

        // If we've exceeded the number of failures we're allowed, stop searching
        if (m_nMaxFailedFiles && m_nFailedFileCount >= m_nMaxFailedFiles)
        {
            //WIA_TRACE((TEXT("FailedFileCount exceeded MaxFailedFiles, bailing out")));
            return false;
        }

        // If we've exceeded the number of files we want to handle, stop searching
        if (m_nMaxSuccessfulFiles && m_nSuccessfulFileCount >= m_nMaxSuccessfulFiles)
        {
            //WIA_TRACE((TEXT("m_nSuccessfulFileCount exceeded MaxSuccessfulFiles, bailing out")));
            return false;
        }

        // If we've exceeded the number of directories we're allowed, stop searching
        if (m_nMaxDirectories && m_nDirectoryCount >= m_nMaxDirectories)
        {
            //WIA_TRACE((TEXT("DirectoryCount exceeded MaxDirectories, bailing out")));
            return false;
        }

        return true;
    }

    bool Find(void)
    {
        bool bResult = RecursiveFindFiles( m_strDirectory, m_strMask, FoundFile, this );

        // Tell the window we're done
        if (m_nNotifyMessage && m_hwndNotify && IsWindow(m_hwndNotify))
        {
            PostMessage( m_hwndNotify, m_nNotifyMessage, FALSE, FALSE );
        }
        return bResult;
    }

    static DWORD __stdcall ThreadProc( PVOID pVoid )
    {
        CFindFilesThread *pFindFilesThread = reinterpret_cast<CFindFilesThread*>(pVoid);
        if (pFindFilesThread)
        {
            pFindFilesThread->Find();
            delete pFindFilesThread;
        }
        return 0;
    }
public:
    static HANDLE Find(
        const CSimpleString &strDirectory,
        const CSimpleString &strMask,
        HWND hwndNotify,
        UINT nNotifyMessage,
        HANDLE hEventCancel,
        int nMaxFailedFiles,
        int nMaxSuccessfulFiles,
        int nMaxDirectories
    )
    {
        HANDLE hThread = NULL;
        CFindFilesThread *pFindFilesThread = new CFindFilesThread( strDirectory, strMask, hwndNotify, nNotifyMessage, hEventCancel, nMaxFailedFiles, nMaxSuccessfulFiles, nMaxDirectories );
        if (pFindFilesThread)
        {
            DWORD dwThreadId;
            hThread = CreateThread( NULL, 0, ThreadProc, pFindFilesThread, 0, &dwThreadId );
            if (!hThread)
            {
                delete pFindFilesThread;
            }
            else
            {
                SetThreadPriority( hThread, THREAD_PRIORITY_LOWEST );
            }
        }
        return hThread;
    }
};

#endif //__FINDTHRD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\gphelper.cpp ===
#include "precomp.h"
#include "gphelper.h"
#include "psutil.h"

using namespace Gdiplus;

CGdiPlusHelper::CGdiPlusHelper(void)
  : m_pImageEncoderInfo(NULL),
    m_nImageEncoderCount(0),
    m_pImageDecoderInfo(NULL),
    m_nImageDecoderCount(0)
#if defined(GDIPLUSHELPER_EXPLICIT_INITIALIZATION)
    ,m_bGdiplusInitialized(false)
    ,m_pGdiplusToken(NULL)
#endif
{
    Initialize();
}

CGdiPlusHelper::~CGdiPlusHelper(void)
{
    Destroy();
}

HRESULT CGdiPlusHelper::Initialize(void)
{
#if defined(GDIPLUSHELPER_EXPLICIT_INITIALIZATION)
    // Make sure GDI+ is initialized
    Gdiplus::GdiplusStartupInput StartupInput;
    m_bGdiplusInitialized = (Gdiplus::GdiplusStartup(&m_pGdiplusToken,&StartupInput,NULL) == Gdiplus::Ok);
#endif

    // Get the installed encoders
    HRESULT hr = E_FAIL;
    UINT cbCodecs = 0;
    GetImageEncodersSize( &m_nImageEncoderCount, &cbCodecs );
    if (cbCodecs)
    {
        m_pImageEncoderInfo = static_cast<ImageCodecInfo*>(LocalAlloc(LPTR,cbCodecs));
        if (m_pImageEncoderInfo)
        {
            GpStatus Status = GetImageEncoders( m_nImageEncoderCount, cbCodecs, m_pImageEncoderInfo );
            if (Ok == Status)
            {
                for (UINT i=0;i<m_nImageEncoderCount;i++)
                {
                    ////WIA_PRINTGUID((m_pImageEncoderInfo[i].Clsid,TEXT("m_pImageEncoderInfo[i].Clsid")));
                    ////WIA_PRINTGUID((m_pImageEncoderInfo[i].FormatID,TEXT("m_pImageEncoderInfo[i].FormatID")));
                }
                hr = S_OK;
            }
        }
    }

    // Get the installed decoders
    cbCodecs = 0;
    GetImageDecodersSize( &m_nImageDecoderCount, &cbCodecs );
    if (cbCodecs)
    {
        m_pImageDecoderInfo = static_cast<ImageCodecInfo*>(LocalAlloc(LPTR,cbCodecs));
        if (m_pImageDecoderInfo)
        {
            GpStatus Status = GetImageDecoders( m_nImageDecoderCount, cbCodecs, m_pImageDecoderInfo );
            if (Ok == Status)
            {
                hr = S_OK;
            }
        }
    }
    // If there was a problem, make sure there are no half-initialized things laying around
    if (FAILED(hr))
    {
        Destroy();
    }
    return hr;
}

void CGdiPlusHelper::Destroy(void)
{

#if defined(GDIPLUSHELPER_EXPLICIT_INITIALIZATION)
    // Shut down GDI+
    if (m_bGdiplusInitialized)
    {
        Gdiplus::GdiplusShutdown(m_pGdiplusToken);
        m_bGdiplusInitialized = false;
        m_pGdiplusToken = NULL;
    }
#endif

    // Free the lists of Encoders and Decoders
    if (m_pImageEncoderInfo)
    {
        LocalFree(m_pImageEncoderInfo);
        m_pImageEncoderInfo = NULL;
    }
    m_nImageEncoderCount = 0;

    if (m_pImageDecoderInfo)
    {
        LocalFree(m_pImageDecoderInfo);
        m_pImageDecoderInfo = NULL;
    }
    m_nImageDecoderCount = 0;
}

bool CGdiPlusHelper::IsValid(void) const
{
    // Make sure we've been completely created
#if defined(GDIPLUSHELPER_EXPLICIT_INITIALIZATION)
    return(m_bGdiplusInitialized && m_pImageEncoderInfo && m_nImageEncoderCount && m_pImageDecoderInfo && m_nImageDecoderCount);
#else
    return(m_pImageEncoderInfo && m_nImageEncoderCount && m_pImageDecoderInfo && m_nImageDecoderCount);
#endif
}

HRESULT CGdiPlusHelper::LoadAndScale( HBITMAP &hTargetBitmap, LPCTSTR pszFilename, UINT nMaxWidth, UINT nMaxHeight, bool bStretchSmallImages )
{
    hTargetBitmap = NULL;
    // Make sure we have a valid filename
    if (pszFilename && lstrlen(pszFilename))
    {
        Bitmap SourceBitmap( CSimpleStringConvert::WideString(CSimpleString(pszFilename) ) );
        if (Ok == SourceBitmap.GetLastStatus())
        {
            // Get the image width and height
            UINT nSourceWidth = SourceBitmap.GetWidth();
            UINT nSourceHeight = SourceBitmap.GetHeight();

            // Make sure the width and height are non-zero
            if (nSourceWidth && nSourceHeight)
            {
                // Assume the source dimensions are fine
                UINT nTargetWidth = nSourceWidth;
                UINT nTargetHeight = nSourceHeight;

                // If the height or the width exceed the allowed maximum, scale it down, or if we are allowing stretching
                if ((nTargetWidth > nMaxWidth) || (nTargetHeight > nMaxHeight) || bStretchSmallImages)
                {
                    SIZE sizeDesiredImageSize = PrintScanUtil::ScalePreserveAspectRatio( nMaxWidth, nMaxHeight, nTargetWidth, nTargetHeight );
                    nTargetWidth = sizeDesiredImageSize.cx;
                    nTargetHeight = sizeDesiredImageSize.cy;
                }

                // Make sure we have valid sizes
                if (nTargetWidth && nTargetHeight)
                {
                    // Create the target bitmap and make sure it succeeded
                    Bitmap TargetBitmap( nTargetWidth, nTargetHeight );
                    if (Ok == TargetBitmap.GetLastStatus())
                    {
                        // Get a graphics to render to
                        Graphics *pGraphics = Graphics::FromImage(&TargetBitmap);
                        if (pGraphics)
                        {
                            // Make sure it is valid
                            if (pGraphics->GetLastStatus() == Ok)
                            {
                                // Draw scaled image
                                if (pGraphics->DrawImage(&SourceBitmap, 0, 0, nTargetWidth, nTargetHeight) == Ok)
                                {
                                    // Get an HBITMAP for this image
                                    TargetBitmap.GetHBITMAP( Color::Black, &hTargetBitmap );
                                }
                            }
                            // Clean up our dynamically allocated graphics
                            delete pGraphics;
                        }
                    }
                }
            }
        }
    }
    return(hTargetBitmap ? S_OK : E_FAIL);
}


// Construct a string like this: JPG;BMP;PNG with all supported extensions
HRESULT CGdiPlusHelper::ConstructCodecExtensionSearchStrings( CSimpleString &strExtensions, Gdiplus::ImageCodecInfo *pImageCodecInfo, UINT nImageCodecCount )
{
    for (UINT i=0;i<nImageCodecCount;i++)
    {
        if (strExtensions.Length())
        {
            strExtensions += TEXT(";");
        }
        strExtensions += CSimpleStringConvert::NaturalString(CSimpleStringWide(pImageCodecInfo[i].FilenameExtension));
    }
    return (strExtensions.Length() ? S_OK : E_FAIL);
}

HRESULT CGdiPlusHelper::ConstructDecoderExtensionSearchStrings( CSimpleString &strExtensions )
{
    return CGdiPlusHelper::ConstructCodecExtensionSearchStrings( strExtensions, m_pImageDecoderInfo, m_nImageDecoderCount );
}


HRESULT CGdiPlusHelper::ConstructEncoderExtensionSearchStrings( CSimpleString &strExtensions )
{
    return CGdiPlusHelper::ConstructCodecExtensionSearchStrings( strExtensions, m_pImageEncoderInfo, m_nImageEncoderCount );
}


CImageFileFormatVerifier::CImageFileFormatVerifierItem::CImageFileFormatVerifierItem(void)
  : m_pSignature(NULL),
    m_pMask(NULL),
    m_nLength(0),
    m_guidFormat(IID_NULL),
    m_clsidDecoder(IID_NULL)
{
}

CImageFileFormatVerifier::CImageFileFormatVerifierItem::CImageFileFormatVerifierItem( const PBYTE pSignature, const PBYTE pMask, int nLength, const GUID &guidFormat, const CLSID &guidDecoder )
  : m_pSignature(NULL),
    m_pMask(NULL),
    m_nLength(0),
    m_guidFormat(IID_NULL),
    m_clsidDecoder(IID_NULL)
{
    Assign( pSignature, pMask, nLength, guidFormat, guidDecoder );
}


CImageFileFormatVerifier::CImageFileFormatVerifierItem::CImageFileFormatVerifierItem( const CImageFileFormatVerifierItem &other )
  : m_pSignature(NULL),
    m_pMask(NULL),
    m_nLength(0),
    m_guidFormat(IID_NULL),
    m_clsidDecoder(IID_NULL)
{
    Assign( other.Signature(), other.Mask(), other.Length(), other.Format(), other.Decoder() );
}


CImageFileFormatVerifier::CImageFileFormatVerifierItem &CImageFileFormatVerifier::CImageFileFormatVerifierItem::operator=( const CImageFileFormatVerifierItem &other )
{
    if (this != &other)
    {
        return Assign( other.Signature(), other.Mask(), other.Length(), other.Format(), other.Decoder() );
    }
    else return *this;
}


CImageFileFormatVerifier::CImageFileFormatVerifierItem &CImageFileFormatVerifier::CImageFileFormatVerifierItem::Assign( const PBYTE pSignature, const PBYTE pMask, int nLength, const GUID &guidFormat, const CLSID &clsidDecoder )
{
    Destroy();
    bool bOK = false;
    m_nLength = nLength;
    m_guidFormat = guidFormat;
    m_clsidDecoder = clsidDecoder;
    if (nLength && pSignature && pMask)
    {
        m_pSignature = new BYTE[nLength];
        m_pMask = new BYTE[nLength];
        if (m_pSignature && m_pMask)
        {
            CopyMemory( m_pSignature, pSignature, nLength );
            CopyMemory( m_pMask, pMask, nLength );
            bOK = true;
        }
    }
    if (!bOK)
    {
        Destroy();
    }
    return *this;
}


void CImageFileFormatVerifier::CImageFileFormatVerifierItem::Destroy(void)
{
    if (m_pSignature)
    {
        delete[] m_pSignature;
        m_pSignature = NULL;
    }
    if (m_pMask)
    {
        delete[] m_pMask;
        m_pMask;
    }
    m_nLength = 0;
    m_guidFormat = IID_NULL;
    m_clsidDecoder = IID_NULL;
}


CImageFileFormatVerifier::CImageFileFormatVerifierItem::~CImageFileFormatVerifierItem(void)
{
    Destroy();
}


PBYTE CImageFileFormatVerifier::CImageFileFormatVerifierItem::Signature(void) const
{
    return m_pSignature;
}


PBYTE CImageFileFormatVerifier::CImageFileFormatVerifierItem::Mask(void) const
{
    return m_pMask;
}


int CImageFileFormatVerifier::CImageFileFormatVerifierItem::Length(void) const
{
    return m_nLength;
}


GUID CImageFileFormatVerifier::CImageFileFormatVerifierItem::Format(void) const
{
    return m_guidFormat;
}


CLSID CImageFileFormatVerifier::CImageFileFormatVerifierItem::Decoder(void) const
{
    return m_clsidDecoder;
}


bool CImageFileFormatVerifier::CImageFileFormatVerifierItem::Match( PBYTE pBytes, int nLen ) const
{
    if (nLen < Length())
    {
        return false;
    }
    for (int i=0;i<Length();i++)
    {
        if (false == ((pBytes[i] & m_pMask[i]) == m_pSignature[i]))
        {
            return false;
        }
    }
    return true;
}



CImageFileFormatVerifier::CImageFileFormatVerifier(void)
  : m_nMaxSignatureLength(0),
    m_pSignatureBuffer(NULL)
{
    // Get the decoder count and size of the decoder info array
    UINT nImageDecoderCount = 0, cbCodecs = 0;
    if (Gdiplus::Ok == Gdiplus::GetImageDecodersSize( &nImageDecoderCount, &cbCodecs ))
    {
        // Make sure we got good sizes back
        if (cbCodecs && nImageDecoderCount)
        {
            // Allocate the array
            Gdiplus::ImageCodecInfo *pImageDecoderInfo = static_cast<Gdiplus::ImageCodecInfo*>(LocalAlloc(LPTR,cbCodecs));
            if (pImageDecoderInfo)
            {
                // Get the actual decoder info
                if (Gdiplus::Ok == Gdiplus::GetImageDecoders( nImageDecoderCount, cbCodecs, pImageDecoderInfo ))
                {
                    // Add each decoder to the format list
                    for (UINT i=0;i<nImageDecoderCount;i++)
                    {
                        // Add each signature to the format list
                        for (UINT j=0;j<pImageDecoderInfo[i].SigCount;j++)
                        {
#if defined(DBG)
                            CSimpleString strPattern;
                            CSimpleString strMask;
                            for (ULONG x=0;x<pImageDecoderInfo[i].SigSize;x++)
                            {
                                strPattern += CSimpleString().Format( TEXT("%02X"), ((const PBYTE)(pImageDecoderInfo[i].SigPattern+(j*pImageDecoderInfo[i].SigSize)))[x] );
                                strMask += CSimpleString().Format( TEXT("%02X"), ((const PBYTE)(pImageDecoderInfo[i].SigMask+(j*pImageDecoderInfo[i].SigSize)))[x] );
                            }
                            //WIA_PRINTGUID((pImageDecoderInfo[i].FormatID,TEXT("FormatID")));
                            //WIA_PRINTGUID((pImageDecoderInfo[i].Clsid,TEXT("  Clsid")));
                            //WIA_TRACE((TEXT("  strPattern: %s, strMask: %s, SigSize: %d"), strPattern.String(), strMask.String(), pImageDecoderInfo[i].SigSize ));
#endif
                            m_FileFormatVerifierList.Append( CImageFileFormatVerifier::CImageFileFormatVerifierItem( (const PBYTE)(pImageDecoderInfo[i].SigPattern+(j*pImageDecoderInfo[i].SigSize)), (const PBYTE)(pImageDecoderInfo[i].SigMask+(j*pImageDecoderInfo[i].SigSize)), pImageDecoderInfo[i].SigSize, pImageDecoderInfo[i].FormatID, pImageDecoderInfo[i].Clsid ) );
                        }
                    }
                }
                // Free the array
                LocalFree(pImageDecoderInfo);
            }
        }
    }

    // Assume the max length is Zero
    m_nMaxSignatureLength = 0;

    // For each signature, check if it is greater in length than the maximum.
    for (int i=0;i<m_FileFormatVerifierList.Size();i++)
    {
        // If it is the longest, save the length
        if (m_FileFormatVerifierList[i].Length() > m_nMaxSignatureLength)
        {
            m_nMaxSignatureLength = m_FileFormatVerifierList[i].Length();
        }
    }

    // If we have a valid max length, allocate a buffer to hold the file's data
    if (m_nMaxSignatureLength)
    {
        m_pSignatureBuffer = new BYTE[m_nMaxSignatureLength];
    }

    // If anything failed, free everything
    if (!IsValid())
    {
        Destroy();
    }
}


void CImageFileFormatVerifier::Destroy(void)
{
    // Free the file signature buffer
    if (m_pSignatureBuffer)
    {
        delete[] m_pSignatureBuffer;
        m_pSignatureBuffer = NULL;
    }
    m_nMaxSignatureLength = 0;
    m_FileFormatVerifierList.Destroy();
}


bool CImageFileFormatVerifier::IsValid(void) const
{
    return (m_pSignatureBuffer && m_nMaxSignatureLength && m_FileFormatVerifierList.Size());
}

CImageFileFormatVerifier::~CImageFileFormatVerifier(void)
{
    Destroy();
}


GUID CImageFileFormatVerifier::GetImageType( LPCTSTR pszFilename )
{
    // Assume we will not find a match
    GUID guidResult = IID_NULL;

    // Open the file for reading
    HANDLE hFile = CreateFile( pszFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    if (INVALID_HANDLE_VALUE != hFile)
    {
        // Read the maximum signature length number of bytes
        DWORD dwBytesRead = 0;
        if (ReadFile( hFile, m_pSignatureBuffer, m_nMaxSignatureLength, &dwBytesRead, NULL ))
        {
            // Make sure we got some bytes
            if (dwBytesRead)
            {
                // Go though the list and try to find a match
                for (int i=0;i<m_FileFormatVerifierList.Size();i++)
                {
                    // If we found a match, we are done
                    if (m_FileFormatVerifierList[i].Match(m_pSignatureBuffer,dwBytesRead))
                    {
                        guidResult = m_FileFormatVerifierList[i].Format();
                        break;
                    }
                }
            }
        }
        // Close the file
        CloseHandle(hFile);
    }

    // This will contain IID_NULL if no matching image type was found
    return guidResult;
}


bool CImageFileFormatVerifier::IsImageFile( LPCTSTR pszFilename )
{
    //WIA_PUSH_FUNCTION((TEXT("CImageFileFormatVerifier::IsImageFile(%s)"),pszFilename));
    // Try to find the image type
    GUID guidImageType = GetImageType(pszFilename);

    //WIA_PRINTGUID((guidImageType,TEXT("guidImageType")));

    // If the image type is IID_NULL, it isn't an image
    return ((IID_NULL != guidImageType) != FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\imagescr.h ===
#ifndef __4c5a2307_6dd9_4dfb_9c42_76680f6cb9bf__
#define __4c5a2307_6dd9_4dfb_9c42_76680f6cb9bf__

#include "findimgs.h"
#include "painters.h"
#include "waitcurs.h"
#include "simlist.h"
#include "simarray.h"
#include "gphelper.h"

class CImageScreenSaver
{
private:
    CFindImageFiles           m_FindImageFiles;
    CImagePainter            *m_pPainter;
    HINSTANCE                 m_hInstance;
    RECT                      m_rcClient;
    CGdiPlusHelper            m_GdiPlusHelper;
    bool                      m_bToolbarVisible;

private:
    // No implementation
    CImageScreenSaver(void);
    CImageScreenSaver( const CImageScreenSaver & );
    CImageScreenSaver &operator=( const CImageScreenSaver & );

public:
    CImageScreenSaver( HINSTANCE hInstance, 
                       bool bToolbarVisible );
    ~CImageScreenSaver(void);
    void ShowToolbar(bool bFlag);
    void OnInput();
    bool IsValid(void) const;
    HANDLE Initialize( HWND hwndNotify,
    	             UINT nNotifyMessage,
    	             HANDLE hEventCancel );
    bool TimerTick( CSimpleDC &ClientDC );
    void Paint( CSimpleDC &PaintDC );
    bool ReplaceImage( bool bForward, bool bNoTransition );
    int Count(void) const
    {
        return m_FindImageFiles.Count();
    }

    void ResetFileQueue(void)
    {
        m_FindImageFiles.Reset();
    }

    bool FoundFile( LPCTSTR pszFilename )
    {
        return m_FindImageFiles.FoundFile( pszFilename );
    }

    void SetScreenRect( HWND hWnd )
    {
        GetClientRect( hWnd, &m_rcClient );
    }

    CBitmapImage *CreateImage( LPCTSTR pszFilename );
};

#endif // __IMAGESCR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\painters.cpp ===
#include "precomp.h"
#include "painters.h"
#include <windowsx.h>
#include "ssutil.h"

CImagePainter::CImagePainter(CBitmapImage *pBitmapImage,
                             CSimpleDC &ClientDC,
                             const RECT &rcScreen,
                             bool bToolbarVisible )
: m_pBitmapImage(pBitmapImage),
  m_dwInitialTickCount(0),
  m_rcScreen(rcScreen),
  m_bFirstFrame(true),
  m_dwDuration(0),
  m_bAlreadyPaintedLastFrame(false),
  m_bNeedPainting(false),
  m_dwLastInput(NULL),
  m_bToolbarVisible(bToolbarVisible)
{
    ComputeImageLayout();
}

CImagePainter::~CImagePainter(void)
{
    if (m_pBitmapImage)
    {
        delete m_pBitmapImage;
        m_pBitmapImage = NULL;
    }
}

// sets m_rcFinal
void CImagePainter::ComputeImageLayout()
{
    if (m_pBitmapImage)
    {
        // always center image
        m_rcFinal.top =  (m_rcScreen.bottom/2)-((m_pBitmapImage->ImageSize().cy)/2);
        m_rcFinal.left = (m_rcScreen.right/2)-((m_pBitmapImage->ImageSize().cx)/2);
        m_rcFinal.bottom = 0;
        m_rcFinal.right = 0;
    }
}

void CImagePainter::SetToolbarVisible(bool bVisible)
{
    m_bToolbarVisible = bVisible;
}

DWORD CImagePainter::ElapsedTime(void) const
{
    DWORD dwElapsed = GetTickCount() - m_dwInitialTickCount;
    if (dwElapsed > m_dwDuration)
    {
        dwElapsed = m_dwDuration;
    }
    return(dwElapsed);
}

CBitmapImage* CImagePainter::BitmapImage(void) const
{
    return(m_pBitmapImage);
}

void CImagePainter::Paint( CSimpleDC &PaintDC )
{
    if (PaintDC.IsValid() && m_pBitmapImage)
    {
        ScreenSaverUtil::SelectPalette( PaintDC, m_pBitmapImage->Palette(), FALSE );
        CSimpleDC MemoryDC;
        if (MemoryDC.CreateCompatibleDC(PaintDC))
        {
            ScreenSaverUtil::SelectPalette( MemoryDC, m_pBitmapImage->Palette(), FALSE );
            Paint( PaintDC, MemoryDC );
        }
    }
}

void CImagePainter::Paint(CSimpleDC &PaintDC, CSimpleDC &MemoryDC)
{
    SelectBitmap( MemoryDC, BitmapImage()->GetBitmap() );
    BitBlt(PaintDC,
           m_rcFinal.left,
           m_rcFinal.top,
           RECTWIDTH(m_rcFinal),
           RECTHEIGHT(m_rcFinal),
           MemoryDC,
           0,
           0,
           SRCCOPY);
}

void CImagePainter::OnInput()
{
    m_dwLastInput = GetTickCount();
}

bool CImagePainter::TimerTick( CSimpleDC &ClientDC )
{
    bool bStopPainting = false;

    if (m_bFirstFrame)
    {
        m_dwInitialTickCount = GetTickCount();
        Erase( ClientDC, m_rcScreen );
    }

    if (m_bFirstFrame || NeedPainting())
    {
        if (m_pBitmapImage && ClientDC.IsValid())
        {
            ScreenSaverUtil::SelectPalette( ClientDC, m_pBitmapImage->Palette(), FALSE );
            CSimpleDC MemoryDC;
            if (MemoryDC.CreateCompatibleDC(ClientDC))
            {
                ScreenSaverUtil::SelectPalette( MemoryDC, m_pBitmapImage->Palette(), FALSE );
                PaintFrame( ClientDC, MemoryDC );
            }
        }
        if (m_bFirstFrame)
        {
            m_bFirstFrame = false;
        }
    }
    else
    {
        bStopPainting = true;
    }

    m_bNeedPainting = false;

    return bStopPainting;
}

//PERF:: should double buffer this
void CImagePainter::Erase( CSimpleDC &ClientDC, RECT &rc )
{
    FillRect( ClientDC, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH) );    
    m_bNeedPainting = true;
}

bool CImagePainter::NeedPainting(void)
{
    return(m_bNeedPainting);
}

bool CImagePainter::IsValid(void)
{
    return(m_pBitmapImage && m_pBitmapImage->GetBitmap());
}

/****************************************************************************
CSimpleTransitionPainter
*****************************************************************************/
CSimpleTransitionPainter::CSimpleTransitionPainter( CBitmapImage *pBitmapImage,
                                                    CSimpleDC &ClientDC,
                                                    const RECT &rcScreen,
                                                    bool bToolbarVisible )
: CImagePainter( pBitmapImage,
                 ClientDC,
                 rcScreen,
                 bToolbarVisible )
{
}


CSimpleTransitionPainter::~CSimpleTransitionPainter(void)
{
}

void CSimpleTransitionPainter::PaintFrame(CSimpleDC &ClientDC, CSimpleDC &MemoryDC)
{
    SelectBitmap(MemoryDC, BitmapImage()->GetBitmap());
    SIZE sizeImage = BitmapImage()->ImageSize();
    BitBlt(ClientDC,
           m_rcFinal.left,
           m_rcFinal.top,
           sizeImage.cx,
           sizeImage.cy,
           MemoryDC,
           0,
           0,
           SRCCOPY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\gphelper.h ===
#ifndef __1fe1d0e2_d009_4c25_a3bc_d0620c61ed8d__
#define __1fe1d0e2_d009_4c25_a3bc_d0620c61ed8d__

#include <windows.h>
#include "simstr.h"
#include <gdiplus.h>
#include "simarray.h"

//
// We will define this when explicit initialization is implemented correctly
//
#define GDIPLUSHELPER_EXPLICIT_INITIALIZATION

#if defined(GDIPLUSHELPER_EXPLICIT_INITIALIZATION)
#include <gdiplusinit.h>
#endif

class CGdiPlusHelper
{
private:
    Gdiplus::ImageCodecInfo  *m_pImageEncoderInfo;
    UINT                      m_nImageEncoderCount;

    Gdiplus::ImageCodecInfo  *m_pImageDecoderInfo;
    UINT                      m_nImageDecoderCount;


#if defined(GDIPLUSHELPER_EXPLICIT_INITIALIZATION)
    //
    // GDI+ Initialization stuff
    //
    ULONG_PTR m_pGdiplusToken;
    bool m_bGdiplusInitialized;
#endif

private:
    CGdiPlusHelper( const CGdiPlusHelper & );
    CGdiPlusHelper &operator=( const CGdiPlusHelper & );

public:
    CGdiPlusHelper(void);
    ~CGdiPlusHelper(void);

protected:
    HRESULT Initialize(void);
    static HRESULT ConstructCodecExtensionSearchStrings( CSimpleString &strExtensions, Gdiplus::ImageCodecInfo *pImageCodecInfo, UINT nImageCodecCount );
    void Destroy(void);

public:
    bool IsValid(void) const;

    HRESULT ConstructDecoderExtensionSearchStrings( CSimpleString &strExtensions );
    HRESULT ConstructEncoderExtensionSearchStrings( CSimpleString &strExtensions );
    HRESULT GetClsidOfEncoder( const GUID &guidFormatId, CLSID &clsidFormat ) const;
    HRESULT GetClsidOfDecoder( const GUID &guidFormatId, CLSID &clsidFormat ) const;
    HRESULT Convert( LPCWSTR pszInputFilename, LPCWSTR pszOutputFilename, const CLSID &guidOutputFormat ) const;
    HRESULT LoadAndScale( HBITMAP &hTargetBitmap, LPCTSTR pszFilename, UINT nMaxWidth, UINT nMaxHeight, bool bStretchSmallImages );
    HRESULT SaveMultipleImagesAsMultiPage( const CSimpleDynamicArray<CSimpleStringWide> &Filenames, const CSimpleStringWide &strFilename, const CLSID &guidOutputFormat );

    static Gdiplus::EncoderParameters *AppendEncoderParameter( Gdiplus::EncoderParameters *pEncoderParameters, const GUID &guidProp, ULONG nType, PVOID pVoid );
    static inline GDISTATUS_TO_HRESULT(Gdiplus::Status status) { return (status == Gdiplus::Ok) ? S_OK : E_FAIL; }
};


class CImageFileFormatVerifier
{
private:
    //
    // Internal class used to store the file signatures
    //
    class CImageFileFormatVerifierItem
    {
    private:
        PBYTE  m_pSignature;
        PBYTE  m_pMask;
        int    m_nLength;
        GUID   m_guidFormat;
        CLSID  m_clsidDecoder;

    public:
        //
        // Constructors, assignment operator and destructor
        //
        CImageFileFormatVerifierItem(void);
        CImageFileFormatVerifierItem( const PBYTE pSignature, const PBYTE pMask, int nLength, const GUID &guidFormat, const CLSID &guidDecoder );
        CImageFileFormatVerifierItem( const CImageFileFormatVerifierItem &other );
        CImageFileFormatVerifierItem &operator=( const CImageFileFormatVerifierItem &other );
        CImageFileFormatVerifierItem &Assign( const PBYTE pSignature, const PBYTE pMask, int nLength, const GUID &Format, const CLSID &guidDecoder );
        ~CImageFileFormatVerifierItem(void);

    protected:
        void Destroy(void);

    public:
        //
        // Accessor functions
        //
        PBYTE Signature(void) const;
        PBYTE Mask(void) const;
        int Length(void) const;
        GUID Format(void) const;
        CLSID Decoder(void) const;

        //
        // Does this stream of bytes match this format?
        //
        bool Match( PBYTE pBytes, int nLen ) const;
    };


private:
    CSimpleDynamicArray<CImageFileFormatVerifierItem> m_FileFormatVerifierList;
    int   m_nMaxSignatureLength;
    PBYTE m_pSignatureBuffer;

private:
    CImageFileFormatVerifier( const CImageFileFormatVerifier & );
    CImageFileFormatVerifier &operator=( const CImageFileFormatVerifier & );

public:
    CImageFileFormatVerifier(void);
    ~CImageFileFormatVerifier(void);
    void Destroy(void);
    bool IsValid(void) const;
    bool IsImageFile( LPCTSTR pszFilename );
    GUID GetImageType( LPCTSTR pszFilename );

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\imagescr.cpp ===
#include "precomp.h"
#include "imagescr.h"
#include "waitcurs.h"
#include "ssutil.h"
#include "findthrd.h"
#include "ssmprsrc.h"

CImageScreenSaver::CImageScreenSaver( HINSTANCE hInstance, 
                                      bool bToolbarVisible )
                  :m_pPainter(NULL),
                   m_hInstance(hInstance),
                   m_bToolbarVisible(bToolbarVisible)
{
}

CImageScreenSaver::~CImageScreenSaver(void)
{
    if (m_pPainter)
    {
        delete m_pPainter;
        m_pPainter = NULL;
    }
}

void CImageScreenSaver::ShowToolbar(bool bFlag)
{
    m_bToolbarVisible = bFlag;
    if(m_pPainter)
    {
        m_pPainter->SetToolbarVisible(bFlag);
    }
}

bool CImageScreenSaver::IsValid(void) const
{
    return(true);
}

HANDLE CImageScreenSaver::Initialize( HWND hwndNotify,
	                                  UINT nNotifyMessage,
	                                  HANDLE hEventCancel )
{
    HANDLE hResult = NULL;

    // Get the file extensions for the file types we are able to deal with
    CSimpleString strExtensions;
    m_GdiPlusHelper.ConstructDecoderExtensionSearchStrings(strExtensions);

    // Start the image finding thread
    TCHAR pBuffer[MAX_PATH] = {0};
    ::GetCurrentDirectory(MAX_PATH,(LPTSTR)&pBuffer);
    hResult = CFindFilesThread::Find((LPTSTR) pBuffer,
                                     strExtensions,
                                     hwndNotify,
                                     nNotifyMessage,
                                     hEventCancel,
                                     MAX_FAILED_FILES,
                                     MAX_SUCCESSFUL_FILES,
                                     MAX_DIRECTORIES );
    // Return the thread handle
    return hResult;
}

void CImageScreenSaver::OnInput()
{
    if(m_pPainter)
    {
        m_pPainter->OnInput();
    }
}

bool CImageScreenSaver::TimerTick( CSimpleDC &ClientDC )
{
    if (m_pPainter && ClientDC.IsValid())
    {
        return m_pPainter->TimerTick( ClientDC );
    }
    return false;
}

void CImageScreenSaver::Paint( CSimpleDC &PaintDC )
{
    if (m_pPainter && PaintDC.IsValid())
    {
        m_pPainter->SetToolbarVisible(m_bToolbarVisible);
        m_pPainter->Paint( PaintDC );
    }
}

bool CImageScreenSaver::ReplaceImage( bool bForward, bool bNoTransition )
{
    CSimpleString strCurrentFile;
    if (m_pPainter)
    {
        delete m_pPainter;
        m_pPainter = NULL;
    }

    if (m_FindImageFiles.Count())
    {
        // exit the loop when we get a valid image or we've exhausted the list
        int nNumTries = 0;
        while (!m_pPainter && nNumTries < m_FindImageFiles.Count())
        {
            CSimpleString strNextFile;
            bool bNextFile = bForward ? m_FindImageFiles.NextFile(strNextFile) : m_FindImageFiles.PreviousFile(strNextFile);
            if (bNextFile)
            {
                CSimpleDC ClientDC;
                if (ClientDC.GetDC(NULL))
                {
                    CBitmapImage *pBitmapImage = new CBitmapImage;
                    if (pBitmapImage)
                    {
                        if (pBitmapImage->Load( ClientDC,
                                                strNextFile,
                                                m_rcClient,
                                                MAX_SCREEN_PERCENT,
                                                ALLOW_STRECTCHING,
                                                false ))
                        {
                            m_pPainter = new CSimpleTransitionPainter( pBitmapImage, 
                                                                       ClientDC, 
                                                                       m_rcClient,
                                                                       m_bToolbarVisible );
                            //
                            // If we couldn't create a painter, delete the bitmap
                            //
                            if (!m_pPainter)
                            {
                                delete pBitmapImage;
                            }
                        }
                        else
                        {
                            delete pBitmapImage;
                        }
                    }
                }
            }
            nNumTries++;
        }
    }
    return(m_pPainter != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\imgs.cpp ===
#include "precomp.h"
#include "imgs.h"
#include "gphelper.h"
#include "ssutil.h"
#include "psutil.h"

CBitmapImage::CBitmapImage(void)
  : m_hBitmap(NULL),
    m_hPalette(NULL)
{
}

CBitmapImage::~CBitmapImage(void)
{
    Destroy();
}

void CBitmapImage::Destroy(void)
{
    if (m_hBitmap)
    {
        DeleteObject(m_hBitmap);
        m_hBitmap = NULL;
    }
    if (m_hPalette)
    {
        DeleteObject(m_hPalette);
        m_hPalette = NULL;
    }
}

bool CBitmapImage::IsValid(void) const
{
    return(m_hBitmap != NULL);
}

HPALETTE CBitmapImage::Palette(void) const
{
    return(m_hPalette);
}

HBITMAP CBitmapImage::GetBitmap(void) const
{
    return(m_hBitmap);
}

// Create a palette for the image
HPALETTE CBitmapImage::PreparePalette( CSimpleDC &dc, HBITMAP hBitmap )
{
    HPALETTE hPalette = NULL;
    if (GetDeviceCaps(dc,RASTERCAPS) & RC_PALETTE)
    {
        if (hBitmap)
        {
            DIBSECTION ds = {0};
            GetObject(hBitmap, sizeof (DIBSECTION), &ds);

            int nColors;
            if (ds.dsBmih.biClrUsed != 0)
            {
                nColors = ds.dsBmih.biClrUsed;
            }
            else
            {
                // Handle the special case of an image that claims to be
                // a 32bit DIB as a 24bit DIB
                if (ds.dsBmih.biBitCount == 32)
                {
                    nColors = 1 << 24;
                }
                else
                {
                    nColors = 1 << ds.dsBmih.biBitCount;
                }
            }

            // Create a halftone palette if the DIB section contains more
            // than 256 colors
            if (nColors > 256)
            {
                hPalette = CreateHalftonePalette(dc);
            }

            // Create a custom palette from the DIB section's color table
            // if the number of colors is 256 or less
            else
            {
                RGBQUAD* pRGB = new RGBQUAD[nColors];
                if (pRGB)
                {
                    CSimpleDC MemDC;
                    MemDC.CreateCompatibleDC(dc);
                    SelectObject( MemDC, hBitmap );
                    GetDIBColorTable( MemDC, 0, nColors, pRGB );

                    UINT nSize = sizeof (LOGPALETTE) + (sizeof (PALETTEENTRY) * (nColors - 1));

                    LOGPALETTE* pLP = (LOGPALETTE*) new BYTE[nSize];
                    if (pLP)
                    {
                        pLP->palVersion = 0x300;
                        pLP->palNumEntries = (WORD)nColors;

                        for (int i=0; i<nColors; i++)
                        {
                            pLP->palPalEntry[i].peRed = pRGB[i].rgbRed;
                            pLP->palPalEntry[i].peGreen = pRGB[i].rgbGreen;
                            pLP->palPalEntry[i].peBlue = pRGB[i].rgbBlue;
                            pLP->palPalEntry[i].peFlags = 0;
                        }

                        hPalette = CreatePalette(pLP);
                        delete[] pLP;
                    }
                    delete[] pRGB;
                }
            }
        }
    }
    else
    {
        hPalette = CreateHalftonePalette(dc);
    }
    return hPalette;
}

SIZE CBitmapImage::ImageSize(void) const
{
    SIZE sizeImage = {0,0};
    if (IsValid())
    {
        BITMAP bm = {0};
        if (GetObject( m_hBitmap, sizeof(bm), &bm ))
        {
            sizeImage.cx = bm.bmWidth;
            sizeImage.cy = bm.bmHeight;
        }
    }
    return(sizeImage);
}

bool CBitmapImage::Load( CSimpleDC  &dc,
                         LPCTSTR     pszFilename,
                         const RECT &rcScreen,
                         int         nMaxScreenPercent,
                         bool        bAllowStretching,
                         bool        bDisplayFilename
                       )
{
    // Clean up, if necessary
    Destroy();

    // Validate the arguments
    if (!pszFilename || !lstrlen(pszFilename))
    {
        return false;
    }

    // Try to load and scale the image using GDI plus
    CGdiPlusHelper GdiPlusHelper;
    if (SUCCEEDED(GdiPlusHelper.LoadAndScale( m_hBitmap, 
                                              pszFilename, 
                                              PrintScanUtil::MulDivNoRound(rcScreen.right - rcScreen.left,nMaxScreenPercent,100), 
                                              PrintScanUtil::MulDivNoRound(rcScreen.bottom - rcScreen.top,nMaxScreenPercent,100), 
                                              bAllowStretching )) && m_hBitmap)
    {
        // Prepare the image's palette, if it has one
        m_hPalette = PreparePalette( dc, m_hBitmap );
    }
    return (m_hBitmap != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\psutil.h ===
#ifndef __eea5eb1f_2730_4617_a6e8_347ffd1068fa__
#define __eea5eb1f_2730_4617_a6e8_347ffd1068fa__

#include <windows.h>
#include "simstr.h"

namespace PrintScanUtil
{
    inline int MulDivNoRound( int nNumber, int nNumerator, int nDenominator )
    {
        return(int)(((LONGLONG)nNumber * nNumerator) / nDenominator);
    }

    inline SIZE ScalePreserveAspectRatio( int nAvailX, int nAvailY, int nItemX, int nItemY )
    {
        SIZE sizeResult = { nAvailX, nAvailY };
        if (nItemX && nItemY)
        {
            //
            // Width is greater than height.  X is the constraining factor
            //
            if (nAvailY*nItemX > nAvailX*nItemY)
            {
                sizeResult.cy = MulDivNoRound(nItemY,nAvailX,nItemX);
            }

            //
            // Height is greater than width.  Y is the constraining factor
            //
            else
            {
                sizeResult.cx = MulDivNoRound(nItemX,nAvailY,nItemY);
            }
        }
        return sizeResult;
    }
}


#endif // __PSUTIL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\precomp.h ===
#ifndef __b4844ae5_d6e1_43d5_9820_28ad3445cf0d__
#define __b4844ae5_d6e1_43d5_9820_28ad3445cf0d__

#include <w4warn.h>
#pragma warning (disable:4127) // conditional expression is constant
#pragma warning (disable:4189) // local variable is initialized but not referenced
#pragma warning (disable:4245) // conversion from/to signed/unsigned mismatch
#pragma warning (disable:4706) // assignment within conditional expression

#include <windows.h>
#include <commctrl.h>

#define MAIN_WINDOW_CLASSNAME      TEXT("MySlideshowPicturesWindow")
#include <stdio.h>
#include <tchar.h>

void DebugMsg(int i, const char* pszFormat, ...);
#define DM_TRACE 1

#define CHANGE_TIMER_INTERVAL_MSEC 6000             // slides are displayed for 6 seconds
#define PAINT_TIMER_INTERVAL_MSEC  100              // how often to paint
#define TOOLBAR_TIMER_DELAY        6000             // toolbar is left up 6 seconds after input
#define MAX_FAILED_FILES           1                // on any failures - close the screen saver
#define MAX_SUCCESSFUL_FILES       14400            // maximum number of images to support.  
                                                    // with a 6 second delay, will run for 24 hours
#define MAX_DIRECTORIES            1000             // maximum number of directories to walk into
#define MAX_SCREEN_PERCENT         100
#define ALLOW_STRECTCHING          0                // expand images to full screen?

#define RECTWIDTH(rc)   ((rc).right-(rc).left)
#define RECTHEIGHT(rc)  ((rc).bottom-(rc).top)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\simdc.h ===
#ifndef _e286ad83_019d_48da_8892_eecb45e07ec8_
#define _e286ad83_019d_48da_8892_eecb45e07ec8_

#include <windows.h>
#include "ssmprsrc.h"

extern HINSTANCE g_hInstance;

class CSimpleDC
{
public:
    // Where'd we get it from?
    enum CContextSource
    {
        FromWindowDC,
        FromClientDC,
        FromPaintDC,
        FromCompatibleDC,
        FromCreateDC,
        FromNullDC
    };

private:
    HDC            m_hDC;
    HWND           m_hWnd;
    CContextSource m_nSource;
    PAINTSTRUCT    m_PaintStruct;

    HBITMAP        m_hOriginalBitmap;
    HBRUSH         m_hOriginalBrush;
    HFONT          m_hOriginalFont;
    HPEN           m_hOriginalPen;
    HPALETTE       m_hOriginalPalette;

private:
    // No implementation
    CSimpleDC &operator=( const CSimpleDC &other );
    CSimpleDC( const CSimpleDC &other );

private:
    void SaveState(void)
    {
        if (m_hDC)
        {
            HBITMAP hTempBitmap = LoadBitmap( g_hInstance, MAKEINTRESOURCE(IDB_1) );
            if (hTempBitmap)
            {
                m_hOriginalBitmap = reinterpret_cast<HBITMAP>(SelectObject(m_hDC,hTempBitmap));
                if (m_hOriginalBitmap)
                {
                    SelectObject( m_hDC, m_hOriginalBitmap );
                }
                DeleteObject(hTempBitmap);
            }
            m_hOriginalBrush = reinterpret_cast<HBRUSH>(SelectObject(m_hDC,GetStockObject(NULL_BRUSH)));
            m_hOriginalFont = reinterpret_cast<HFONT>(SelectObject(m_hDC,GetStockObject(SYSTEM_FONT)));
            m_hOriginalPen = reinterpret_cast<HPEN>(SelectObject(m_hDC,GetStockObject(NULL_PEN)));
            m_hOriginalPalette = reinterpret_cast<HPALETTE>(SelectPalette(m_hDC,reinterpret_cast<HPALETTE>(GetStockObject(DEFAULT_PALETTE)),TRUE));
        }
    }
    void RestoreState(void)
    {
        if (m_hDC)
        {
            if (m_hOriginalBitmap)
            {
                SelectObject( m_hDC, m_hOriginalBitmap );
            }
            if (m_hOriginalBrush)
            {
                SelectObject( m_hDC, m_hOriginalBrush );
            }
            if (m_hOriginalFont)
            {
                SelectObject( m_hDC, m_hOriginalFont );
            }
            if (m_hOriginalPen)
            {
                SelectObject( m_hDC, m_hOriginalPen );
            }
            if (m_hOriginalPalette)
            {
                SelectPalette( m_hDC, m_hOriginalPalette, TRUE );
            }
        }
    }

public:
    CSimpleDC(void)
      : m_hDC(NULL),
        m_hWnd(NULL),
        m_nSource(FromNullDC),
        m_hOriginalBitmap(NULL),
        m_hOriginalBrush(NULL),
        m_hOriginalFont(NULL),
        m_hOriginalPen(NULL),
        m_hOriginalPalette(NULL)
    {
        ::ZeroMemory(&m_PaintStruct,sizeof(m_PaintStruct));
    }
    virtual ~CSimpleDC(void)
    {
        Release();
    }
    void Release(void)
    {
        RestoreState();
        if (m_hDC)
        {
            switch (m_nSource)
            {
            case FromWindowDC:
                if (m_hDC)
                {
                    ReleaseDC( m_hWnd, m_hDC );
                }
                break;

            case FromClientDC:
                if (m_hDC)
                {
                    ReleaseDC( m_hWnd, m_hDC );
                }
                break;

            case FromPaintDC:
                if (m_hDC)
                {
                    EndPaint( m_hWnd, &m_PaintStruct );
                }
                break;

            case FromCompatibleDC:
                if (m_hDC)
                {
                    DeleteDC( m_hDC );
                }
                break;

            case FromCreateDC:
                if (m_hDC)
                {
                    DeleteDC( m_hDC );
                }
                break;

            case FromNullDC:
                break;
            }
        }
        ZeroMemory( &m_PaintStruct, sizeof(m_PaintStruct));
        m_hDC         = NULL;
        m_hWnd        = NULL;
        m_nSource     = FromNullDC;
    }

    bool GetDC( HWND hWnd )
    {
        Release();
        if (m_hDC = ::GetDC(hWnd))
        {
            m_hWnd = hWnd;
            m_nSource = FromClientDC;
            SaveState();
        }
        return (m_hDC != NULL);
    }

    bool BeginPaint( HWND hWnd )
    {
        Release();
        m_hDC = ::BeginPaint( hWnd, &m_PaintStruct );
        if (m_hDC)
        {
            m_hWnd = hWnd;
            m_nSource = FromPaintDC;
            SaveState();
        }
        return (m_hDC != NULL);
    }

    bool CreateCompatibleDC( HDC hDC )
    {
        Release();
        m_hDC = ::CreateCompatibleDC( hDC );
        if (m_hDC)
        {
            m_nSource = FromCompatibleDC;
            SaveState();
        }
        return (m_hDC != NULL);
    }

    bool CreateDC( LPCTSTR lpszDriver, LPCTSTR lpszDevice, LPCTSTR lpszOutput, CONST DEVMODE *lpInitData )
    {
        Release();
        m_hDC = ::CreateDC( lpszDriver, lpszDevice, lpszOutput, lpInitData );
        if (m_hDC)
        {
            m_nSource = FromCreateDC;
            SaveState();
        }
        return (m_hDC != NULL);
    }

    bool IsValid(void) const
    {
        return (m_hDC != NULL && m_nSource != FromNullDC);
    }

    operator HDC(void)
    {
        return m_hDC;
    }
};

#endif // __SIMDC_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\painters.h ===
#ifndef __b59ae174_378f_48e2_bb6d_61eceb410c32__
#define __b59ae174_378f_48e2_bb6d_61eceb410c32__

#include <windows.h>
#include "imgs.h"
#include "simdc.h"

class CImagePainter
{
private:
    CBitmapImage     *m_pBitmapImage;
    DWORD             m_dwInitialTickCount;
    bool              m_bFirstFrame;
    bool              m_bAlreadyPaintedLastFrame;
    bool              m_bNeedPainting;
    DWORD             m_dwLastInput;            // on input, show command buttons

protected:
    bool              m_bToolbarVisible;
    RECT              m_rcScreen;
    RECT              m_rcFinal;
    DWORD             m_dwDuration;

private:
    CImagePainter(void);
    CImagePainter( const CImagePainter & );
    operator=( const CImagePainter & );
    void ComputeImageLayout();

public:
    void SetToolbarVisible(bool bVisible);
    
    CImagePainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcScreen, bool bToolbarVisible );
    virtual ~CImagePainter(void);
    DWORD ElapsedTime(void) const;
    CBitmapImage* BitmapImage(void) const;
    void Paint( CSimpleDC &PaintDC );
    bool TimerTick( CSimpleDC &ClientDC );
    void Erase( CSimpleDC &ClientDC, RECT &rc );

    virtual void Paint( CSimpleDC &PaintDC, CSimpleDC &MemoryDC );
    void NeedPainting(bool bNeedPainting) { m_bNeedPainting = true; };
    virtual bool NeedPainting(void);
    virtual bool IsValid(void);
    virtual void PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC ) = 0;
    void OnInput();
};


class CSimpleTransitionPainter : public CImagePainter
{
public:
    CSimpleTransitionPainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcScreen, bool bToolbarVisible );
    virtual ~CSimpleTransitionPainter(void);
    virtual void PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC );
};

#endif // __PAINTERS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\simarray.h ===
#ifndef __8fbf879f_339a_4738_b8ae_2948b62b9863__
#define __8fbf879f_339a_4738_b8ae_2948b62b9863__

template<class T>
class CSimpleDynamicArray
{
private:
    int m_nSize;
    int m_nMaxSize;
    int m_nGrowSize;
    T *m_pArray;
    enum
    {
        eGrowSize = 10  // The number of items to add each time the array grows.
    };
public:
    CSimpleDynamicArray(void)
      : m_nSize(0),
        m_nMaxSize(0),
        m_nGrowSize(eGrowSize),
        m_pArray(NULL)
    {
    }
    CSimpleDynamicArray( int nInitialSize, int nGrowSize=0 )
      : m_nSize(0),
        m_nMaxSize(0),
        m_nGrowSize(nGrowSize ? nGrowSize : eGrowSize),
        m_pArray(NULL)
    {
        GrowTo(nInitialSize);
    }
    CSimpleDynamicArray( const CSimpleDynamicArray<T> &other )
      : m_nSize(0),
        m_nMaxSize(0),
        m_nGrowSize(eGrowSize),
        m_pArray(NULL)
    {
        Append(other);
    }
    virtual ~CSimpleDynamicArray(void)
    {
        Destroy();
    }
    CSimpleDynamicArray &operator=( const CSimpleDynamicArray &other )
    {
        if (this != &other)
        {
            Destroy();
            Append(other);
        }
        return *this;
    }
    void Destroy(void)
    {
        if (m_pArray)
        {
            delete[] m_pArray;
            m_pArray = NULL;
        }
        m_nSize = m_nMaxSize = 0;
    }
    void Append( const CSimpleDynamicArray &other )
    {
        if (GrowTo( m_nSize + other.Size() ))
        {
            for (int i=0;i<other.Size();i++)
            {
                Append(other[i]);
            }
        }
    }
    int Append( const T &element )
    {
        if (GrowTo( m_nSize + 1 ))
        {
            m_pArray[m_nSize] = element;
            int nResult = m_nSize;
            m_nSize++;
            return nResult;
        }
        else return -1;
    }
    int Insert( const T &element, int nIndex )
    {
        //
        // Make sure we can accomodate this new item
        //
        if (GrowTo( m_nSize + 1 ))
        {
            //
            // Make sure the item is within the range we've allocated
            //
            if (nIndex >= 0 && nIndex <= m_nSize)
            {
                //
                // Make room for the new item by moving all items above up by one slot
                //
                for (int i=Size();i>nIndex;i--)
                {
                    m_pArray[i] = m_pArray[i-1];
                }

                //
                // Save the new item
                //
                m_pArray[nIndex] = element;

                //
                // We're now one larger
                //
                m_nSize++;

                //
                // Return the index of the slot we used
                //
                return nIndex;
            }
        }

        //
        // Return an error
        //
        return -1;
    }
    void Delete( int nItem )
    {
        if (nItem >= 0 && nItem < m_nSize && m_pArray)
        {
            T *pTmpArray = new T[m_nMaxSize];
            if (pTmpArray)
            {
                T *pSrc, *pTgt;
                pSrc = m_pArray;
                pTgt = pTmpArray;
                for (int i=0;i<m_nSize;i++)
                {
                    if (i != nItem)
                    {
                        *pTgt = *pSrc;
                        pTgt++;
                    }
                    pSrc++;
                }
                delete[] m_pArray;
                m_pArray = pTmpArray;
                m_nSize--;
            }
        }
    }
    bool GrowTo( int nSize )
    {
        //
        // If the array is already large enough, just return true
        //
        if (nSize < m_nMaxSize)
        {
            return true;
        }

        //
        // Save old size, in case we can't allocate a new array
        //
        int nOldMaxSize = m_nMaxSize;

        //
        // Find the correct size to grow to
        //
        while (m_nMaxSize < nSize)
        {
            m_nMaxSize += m_nGrowSize;
        }

        //
        // Allocate the array
        //
        T *pTmpArray = new T[m_nMaxSize];
        if (pTmpArray)
        {
            //
            // Copy the old array over
            //
            for (int i=0;i<m_nSize;i++)
            {
                pTmpArray[i] = m_pArray[i];
            }

            //
            // Delete the old array
            //
            if (m_pArray)
            {
                delete[] m_pArray;
            }

            //
            // Assign the new array to the old one and return true
            //
            m_pArray = pTmpArray;
            return true;
        }
        else
        {
            //
            // If we couldn't allocate the new array, restore the maximum size
            // and return false
            //
            m_nMaxSize = nOldMaxSize;
            return false;
        }
    }
    int Find( const T& element )
    {
        for (int i=0;i<m_nSize;i++)
            if (m_pArray[i] == element)
                return i;
        return -1;
    }
    bool operator==( const CSimpleDynamicArray &other )
    {
        if (Size() != other.Size())
            return false;
        for (int i=0;i<Size();i++)
            if (!(m_pArray[i] == other[i]))
                return false;
        return true;
    }
    bool Contains( const T& element )     { return(Find(element) >= 0);}
    void Size( int nSize )                { m_nSize = nSize;}
    void MaxSize( int nMaxSize )          { m_nMaxSize = nMaxSize;}
    void GrowSize( int nGrowSize )        { m_nGrowSize = nGrowSize;}
    int Size(void) const                  { return m_nSize;}
    int MaxSize(void) const               { return m_nMaxSize;}
    int GrowSize(void) const              { return m_nGrowSize;}
    const T *Array(void) const            { return m_pArray;}
    const T &operator[](int nIndex) const { return m_pArray[nIndex];}
    T &operator[](int nIndex)             { return m_pArray[nIndex];}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\simtok.h ===
#ifndef __03aef7a5_f6eb_4234_9ffc_05627e330871__
#define __03aef7a5_f6eb_4234_9ffc_05627e330871__

#include "simstr.h"

template <class T>
class CSimpleStringToken
{
private:
    T m_strStr;
    int m_nIndex;
public:
    CSimpleStringToken(void);
    CSimpleStringToken( const T &str );
    CSimpleStringToken( const CSimpleStringToken &other );
    CSimpleStringToken &operator=( const CSimpleStringToken &other );
    virtual ~CSimpleStringToken(void);
    void Reset(void);
    T Tokenize( const T &strDelim );
    T String(void) const;
    int Index(void) const;
};

template <class T>
CSimpleStringToken<T>::CSimpleStringToken(void)
:m_nIndex(0)
{
}

template <class T>
CSimpleStringToken<T>::CSimpleStringToken( const T &str )
: m_strStr(str), m_nIndex(0)
{
}

template <class T>
CSimpleStringToken<T>::CSimpleStringToken( const CSimpleStringToken &other )
: m_strStr(other.String()), m_nIndex(other.Index())
{
}

template <class T>
CSimpleStringToken<T> &CSimpleStringToken<T>::operator=( const CSimpleStringToken &other )
{
    m_strStr = other.String();
    m_nIndex = other.Index();
    return *this;
}

template <class T>
CSimpleStringToken<T>::~CSimpleStringToken(void)
{
}

template <class T>
void CSimpleStringToken<T>::Reset(void)
{
    m_nIndex = 0;
}

template <class T>
T CSimpleStringToken<T>::Tokenize( const T &strDelim )
{
    T strToken(TEXT(""));
    // Throw away the leading delimiters
    while (m_nIndex < (int)m_strStr.Length())
    {
        if (strDelim.Find(m_strStr[m_nIndex]) < 0)
            break;
        ++m_nIndex;
    }
    // Copy the string until we reach a delimiter
    while (m_nIndex < (int)m_strStr.Length())
    {
        if (strDelim.Find(m_strStr[m_nIndex]) >= 0)
            break;
        strToken += m_strStr[m_nIndex];
        ++m_nIndex;
    }
    // Throw away the trailing delimiters
    while (m_nIndex < (int)m_strStr.Length())
    {
        if (strDelim.Find(m_strStr[m_nIndex]) < 0)
            break;
        ++m_nIndex;
    }
    return strToken;
}

template <class T>
T CSimpleStringToken<T>::String(void) const
{
    return m_strStr;
}

template <class T>
int CSimpleStringToken<T>::Index(void) const
{
    return m_nIndex;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\sshndler.h ===
#ifndef __SSHNDLER_H_INCLUDED_
#define __SSHNDLER_H_INCLUDED_

#include "precomp.h"

#include "imagescr.h"
#include "extimer.h"
#include "simstr.h"
#include "findthrd.h"

class CScreenSaverHandler
{
private:
    CImageScreenSaver         *m_pImageScreenSaver;
    HINSTANCE                 m_hInstance;
    HWND                      m_hWnd;
    UINT                      m_nPaintTimerId;
    UINT                      m_nChangeTimerId;
    UINT                      m_nToolbarTimerId;
    bool                      m_bToolbarVisible;
    UINT                      m_nFindNotifyMessage;
    bool                      m_bPaused;
    CExclusiveTimer           m_TimerPaint;
    CExclusiveTimer           m_TimerInput;
    HANDLE                    m_hFindThread;
    HANDLE                    m_hFindCancel;
    bool                      m_bFirstImage;
    HWND                      m_hwndTB;
    LPARAM                    m_LastMousePosition;

private:
    HRESULT _ShowToolbar(bool bShow);
    HRESULT _CreateToolbar();
    HRESULT _InitializeToolbar(HWND hwndTB, int idCold, int idHot);
    void _OnInput();
    void HandleButtons(HDC hDC);
    void OnPlay();
    void OnNext();
    void OnStop();
    void OnPrev();
    void OnPause();

    // No implementation
    CScreenSaverHandler(void);
    CScreenSaverHandler( const CScreenSaverHandler & );
    CScreenSaverHandler &operator=( const CScreenSaverHandler & );

public:
    void Initialize(void);
    CScreenSaverHandler( HWND hWnd, 
                         UINT nFindNotifyMessage, 
                         UINT nPaintTimer, 
                         UINT nChangeTimer, 
                         UINT nToolbarTimer,
                         HINSTANCE hInstance );
    virtual ~CScreenSaverHandler(void);

    // Message handlers
    bool HandleKeyboardMessage(UINT nMessage, WPARAM nVirtkey);
    bool HandleMouseMessage(WPARAM wParam, LPARAM lParam);
    bool HandleMouseMove(WPARAM wParam, LPARAM lParam);
    void HandleConfigChange();
    void OnSize(WPARAM wParam, LPARAM lParam);
    void HandleTimer( WPARAM nEvent );
    void HandlePaint(void);
    void HandleFindFile( CFoundFileMessageData *pFoundFileMessageData );
    void HandleOnCommand( WPARAM wParam, LPARAM lParam);
    void HandleOnAppCommand ( WPARAM wParam, LPARAM lParam);
};

#endif // __SSHNDLER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\simlist.h ===
#ifndef __SIMLIST_H_INCLUDED
#define __SIMLIST_H_INCLUDED

template <class T>
class CSimpleLinkedList
{
private:

    class CLinkedListNode
    {
    private:
        CLinkedListNode *m_pNext;
        T                m_Data;
    public:
        CLinkedListNode( const T &data )
        : m_pNext(NULL), m_Data(data)
        {
        }
        const CLinkedListNode *Next(void) const
        {
            return (m_pNext);
        }
        CLinkedListNode *Next(void)
        {
            return (m_pNext);
        }
        void Next( CLinkedListNode *pNext )
        {
            m_pNext = pNext;
        }
        const T &Data(void) const
        {
            return (m_Data);
        }
        T &Data(void)
        {
            return (m_Data);
        }
    };

    CLinkedListNode *m_pHead, *m_pTail;
    int m_nItemCount;

public:
    CSimpleLinkedList( const CSimpleLinkedList &other )
    : m_pHead(NULL),m_pTail(NULL),m_nItemCount(0)
    {
        for (Iterator i(other);i != other.End();i++)
            Append(*i);
    }
    CSimpleLinkedList(void)
    : m_pHead(NULL),m_pTail(NULL),m_nItemCount(0)
    {
    }
    CSimpleLinkedList &operator=( const CSimpleLinkedList &other )
    {
        if (this != &other)
        {
            Destroy();
            for (Iterator i(other);i != other.End();i++)
                Append(*i);
        }
        return *this;
    }
    virtual ~CSimpleLinkedList(void)
    {
        Destroy();
    }
    void Destroy(void)
    {
        while (m_pHead)
        {
            CLinkedListNode *pCurr = m_pHead;
            m_pHead = m_pHead->Next();
            delete pCurr;
        }
        m_pHead = m_pTail = NULL;
        m_nItemCount = 0;
    }
    void Remove( const T &data )
    {
        CLinkedListNode *pPrev = NULL, *pCurr = m_pHead;
        while (pCurr && pCurr->Data() != data)
        {
            pPrev = pCurr;
            pCurr = pCurr->Next();
        }
        if (!pCurr)
            return;
        if (!pPrev)
        {
            m_pHead = pCurr->Next();
            delete pCurr;
            m_nItemCount--;
        }
        else
        {
            pPrev->Next(pCurr->Next());
            delete pCurr;
            m_nItemCount--;
        }
    }
    void Append( const CSimpleLinkedList &other )
    {
        for (Iterator i(other);i != other.End();i++)
            Append(*i);
    }

    int Count(void) const
    {
        return m_nItemCount;
    }

    class Iterator;
    friend class Iterator;
    class Iterator
    {
    private:
        CLinkedListNode *m_pCurr;
    public:
        Iterator( CLinkedListNode *pNode )
        : m_pCurr(pNode)
        {
        }
        Iterator( const CSimpleLinkedList &list )
        : m_pCurr(list.m_pHead)
        {
        }
        Iterator(void)
        : m_pCurr(NULL)
        {
        }
        Iterator &Next(void)
        {
            if (m_pCurr)
                m_pCurr = m_pCurr->Next();
            return (*this);
        }
        Iterator &Begin(const CSimpleLinkedList &list)
        {
            m_pCurr = list.m_pHead;
            return (*this);
        }
        Iterator &operator=( const Iterator &other )
        {
            m_pCurr = other.m_pCurr;
            return (*this);
        }
        bool End(void) const
        {
            return(m_pCurr == NULL);
        }
        T &operator*(void)
        {
            return (m_pCurr->Data());
        }
        const T &operator*(void) const
        {
            return (m_pCurr->Data());
        }
        Iterator &operator++(void)
        {
            Next();
            return (*this);
        }
        Iterator operator++(int)
        {
            Iterator tmp(*this);
            Next();
            return (tmp);
        }
        bool operator!=( const Iterator &other ) const
        {
            return (m_pCurr != other.m_pCurr);
        }
        bool operator==( const Iterator &other ) const
        {
            return (m_pCurr == other.m_pCurr);
        }
    };
    Iterator Begin(void) const
    {
        return Iterator(*this);
    }
    Iterator End(void) const
    {
        return Iterator();
    }
    Iterator Begin(void)
    {
        return Iterator(*this);
    }
    Iterator End(void)
    {
        return Iterator();
    }
    Iterator Find( const T &data )
    {
        for (Iterator i=Begin();i != End();++i)
            if (*i == data)
                return i;
        return End();
    }
    Iterator Insert( Iterator &nextItem, const T &data )
    {
        CLinkedListNode *pNewItem = new CLinkedListNode(data);
        if (pNewItem)
        {
            if (Empty())
            {
                m_pHead = m_pTail = pNewItem;
            }
            else if (nextItem.Data() == m_pHead)
            {
                pNewItem->Next(m_pHead);
                m_pHead = pNewItem;
            }
            else if (nextItem.Data() == NULL)
            {
                m_pTail->Next(pNewItem);
                m_pTail = pNewItem;
            }

            m_nItemCount++;
        }
    }
    Iterator Prepend( const T &data )
    {
        CLinkedListNode *pNewItem = new CLinkedListNode(data);
        if (pNewItem)
        {
            if (Empty())
            {
                m_pHead = m_pTail = pNewItem;
            }
            else
            {
                pNewItem->Next(m_pHead);
                m_pHead = pNewItem;
            }
            m_nItemCount++;
        }
        return Iterator(pNewItem);
    }
    Iterator Append( const T &data )
    {
        CLinkedListNode *pNewItem = new CLinkedListNode(data);
        if (pNewItem)
        {
            if (Empty())
            {
                m_pHead = m_pTail = pNewItem;
            }
            else
            {
                m_pTail->Next(pNewItem);
                m_pTail = pNewItem;
            }
            m_nItemCount++;
        }
        return Iterator(pNewItem);
    }
    bool Empty(void) const
    {
        return (m_pHead == NULL);
    }
};

template <class T>
class CSimpleStack : public CSimpleLinkedList<T>
{
private:
    CSimpleStack( const CSimpleStack &other );
    CSimpleStack &operator=( const CSimpleStack &other );
public:
    CSimpleStack(void)
    {
    }
    virtual ~CSimpleStack(void)
    {
    }
    void Push( const T &data )
    {
        Prepend(data);
    }
    bool Pop( T &data )
    {
        if (Empty())
            return false;
        Iterator iter(*this);
        data = *iter;
        Remove(*iter);
        return true;
    }
};


template <class T>
class CSimpleQueue : public CSimpleLinkedList<T>
{
private:
    CSimpleQueue( const CSimpleQueue &other );
    CSimpleQueue &operator=( const CSimpleQueue &other );
public:
    CSimpleQueue(void)
    {
    }
    virtual ~CSimpleQueue(void)
    {
    }
    void Enqueue( const T &data )
    {
        Append(data);
    }
    bool Dequeue( T &data )
    {
        if (Empty())
            return false;
        Iterator iter(*this);
        data = *iter;
        Remove(*iter);
        return true;
    }
};

#endif __SIMLIST_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\ssmprsrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ssmprsrc.rc
//
#define IDS_NO_FILES_FOUND              2
#define IDB_1                           2009
#define IDB_SLIDESHOWTOOLBAR            2016
#define IDB_SLIDESHOWTOOLBARHOT         2017
#define IDC_STATIC                      -1

// Slideshow Mode Commands              
#define ID_FIRSTSLIDESHOWCMD            600
#define ID_PLAYCMD                      600
#define ID_PAUSECMD                     601
#define ID_PREVCMD                      602
#define ID_NEXTCMD                      603
#define ID_CLOSECMD                     604
#define ID_LASTSLIDESHOWCMD             605

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2018
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1027
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\simstr.h ===
#ifndef _SIMSTR_H_INCLUDED
#define _SIMSTR_H_INCLUDED

/*
 * Simple string class.
 *
 * Template class:
 *   CSimpleStringBase<T>
 * Implementations:
 *   CSimpleStringBase<wchar_t> CSimpleStringWide
 *   CSimpleStringBase<char> CSimpleStringAnsi
 *   CSimpleString = CSimpleString[Ansi|Wide] depending on UNICODE macro
 * Inline functions:
 *   CSimpleStringAnsi CSimpleStringConvert::AnsiString(T n)
 *   CSimpleStringWide CSimpleStringConvert::WideString(T n)
 *   CSimpleString     CSimpleStringConvert::NaturalString(T n)
 * Macros:
 *   IS_CHAR(T)
 *   IS_WCHAR(T)
 */

#include <windows.h>
#include <stdarg.h>

#define IS_CHAR(x)     (sizeof(x)==sizeof(char))
#define IS_WCHAR(x)    (sizeof(x)==sizeof(wchar_t))
#define SS_TEXT(t,s)   (IS_CHAR((t)) ? (s) : (L##s))

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)   (sizeof(x) / sizeof(x[0]))
#endif

template <class T>
class CSimpleStringBase
{
private:
    T *m_pstrData;
    UINT m_nMaxSize;
    UINT m_nGranularity;
    enum
    {
        m_nDefaultGranularity = 16,
        m_nMaxLoadStringBuffer = 512
    };
    static int Min( int a, int b )
    {
        return((a < b) ? a : b);
    }
public:
    // Replacements (in some cases just wrappers) for strlen, strcpy, ...
    static inline T   *GenericCopy( T *pstrTgtStr, const T *pstrSrcStr );
    static inline T   *GenericCopyLength( T *pstrTgtStr, const T *pstrSrcStr, UINT nSize );
    static inline UINT GenericLength( const T *pstrStr );
    static inline T   *GenericConcatenate( T *pstrTgtStr, const T *pstrSrcStr );
    static inline int  GenericCompare( const T *pstrTgtStr, const T *pstrSrcStr );
    static inline int  GenericCompareNoCase( const T *pstrStrA, const T *pstrStrB );
    static inline int  GenericCompareLength( const T *pstrTgtStr, const T *pstrSrcStr, UINT nLength );
    static inline T   *GenericCharNext( const T *pszStr );
public:
    // Constructors and destructor
    CSimpleStringBase( void );
    CSimpleStringBase( const CSimpleStringBase & );
    CSimpleStringBase( const T *szStr );
    CSimpleStringBase( T ch );
    CSimpleStringBase( UINT nResId, HMODULE hModule );
    virtual ~CSimpleStringBase(void);

    bool EnsureLength( UINT nMaxSize );
    UINT Length(void) const;
    void Concat( const CSimpleStringBase &other );
    bool Assign( const T *szStr );
    bool Assign( const CSimpleStringBase & );
    void Destroy(void);

    CSimpleStringBase &Format( const T *strFmt, ... );
    CSimpleStringBase &Format( int nResId, HINSTANCE hInst, ... );

    // Handy Win32 wrappers
    CSimpleStringBase &GetWindowText( HWND hWnd );
    bool SetWindowText( HWND hWnd );
    bool LoadString( UINT nResId, HMODULE hModule );
    bool Load( HKEY hRegKey, const T *pszValueName, const T *pszDefault=NULL );
    bool Store( HKEY hRegKey, const T *pszValueName, DWORD nType = REG_SZ );
    void SetAt( UINT nIndex, T chValue );
    CSimpleStringBase &operator=( const CSimpleStringBase &other );
    CSimpleStringBase &operator=( const T *other );
    CSimpleStringBase &operator+=( const CSimpleStringBase &other );
    CSimpleStringBase operator+( const CSimpleStringBase &other ) const;
    T &operator[](int index);
    const T &operator[](int index) const;

    CSimpleStringBase ToUpper(void) const;
    CSimpleStringBase ToLower(void) const;

    CSimpleStringBase &MakeUpper(void);
    CSimpleStringBase &MakeLower(void);
    CSimpleStringBase &TrimRight(void);
    CSimpleStringBase &TrimLeft(void);
    CSimpleStringBase &Trim(void);
    CSimpleStringBase &Reverse(void);

    int Find( T cChar ) const;
    int Find( const CSimpleStringBase &other, UINT nStart=0 ) const;
    int ReverseFind( T cChar ) const;
    int ReverseFind( const CSimpleStringBase &other ) const;

    CSimpleStringBase SubStr( int nStart, int nCount=-1 ) const;
    int CompareNoCase( const CSimpleStringBase &other, int nLength=-1 ) const;
    int Compare( const CSimpleStringBase &other, int nLength=-1 ) const;
    bool MatchLastCharacter( T cChar ) const;

    // Some useful inlines
    UINT Granularity( UINT nGranularity )                       { if (nGranularity>0) m_nGranularity = nGranularity;return m_nGranularity;}
    UINT Granularity( void )                          const     { return m_nGranularity;}
    CSimpleStringBase Left( int nCount )              const     { return SubStr( 0, nCount );}
    CSimpleStringBase Right( int nCount )             const     { return SubStr( max(0,(int)Length()-nCount), -1 );}
    bool operator<( const CSimpleStringBase &other )  const     { return(Compare(other) <  0);}
    bool operator<=( const CSimpleStringBase &other ) const     { return(Compare(other) <= 0);}
    bool operator==( const CSimpleStringBase &other ) const     { return(Compare(other) == 0);}
    bool operator!=( const CSimpleStringBase &other ) const     { return(Compare(other) != 0);}
    bool operator>=( const CSimpleStringBase &other ) const     { return(Compare(other) >= 0);}
    bool operator>( const CSimpleStringBase &other )  const     { return(Compare(other) >  0);}
    const T *String(void)                             const     { return m_pstrData;}
    operator const T *(void)                          const     { return String();}
    bool IsValid(void)                                const     { return(NULL != m_pstrData);}
};


template <class T>
inline T *CSimpleStringBase<T>::GenericCopy( T *pszDest, const T *pszSource )
{
    T *pCurr = pszDest;
    while (*pCurr++ = *pszSource++)
        ;
    return(pszDest);
}

template <class T>
inline T *CSimpleStringBase<T>::GenericCharNext( const T *pszStr )
{
    if (IS_CHAR(*pszStr))
    {
        return (T*)CharNextA((LPCSTR)pszStr);
    }
    else if (!*pszStr)
    {
        return (T*)pszStr;
    }
    else
    {  
        return (T*)((LPWSTR)pszStr + 1);
    }
}

template <class T>
inline T *CSimpleStringBase<T>::GenericCopyLength( T *pszDest, const T *source, UINT count )
{
    T *start = pszDest;
    while (count && (*pszDest++ = *source++))
        count--;
    if (count)
        while (--count)
            *pszDest++ = 0;
    return(start);
}

template <class T>
inline UINT CSimpleStringBase<T>::GenericLength( const T *pszString )
{
    const T *eos = pszString;

    while (*eos++)
        ;
    return((UINT)(eos - pszString - 1));
}

template <class T>
inline T*CSimpleStringBase<T>::GenericConcatenate( T *pszDest, const T *pszSource )
{
    T *pCurr = pszDest;

    while (*pCurr)
        pCurr++;

    while (*pCurr++ = *pszSource++)
        ;

    return( pszDest );
}

template <class T>
inline int CSimpleStringBase<T>::GenericCompare( const T *pszSource, const T *pszDest )
{
#if defined(DBG) && !defined(UNICODE) && !defined(_UNICODE)
    if (sizeof(T) == sizeof(wchar_t))
    {
        OutputDebugString(TEXT("CompareStringW is not supported under win9x, so this call is going to fail!"));
    }
#endif
    int nRes = IS_CHAR(*pszSource) ?
               CompareStringA( LOCALE_USER_DEFAULT, 0, (LPCSTR)pszSource, -1, (LPCSTR)pszDest, -1 ) :
               CompareStringW( LOCALE_USER_DEFAULT, 0, (LPCWSTR)pszSource, -1, (LPCWSTR)pszDest, -1 );
    switch (nRes)
    {
    case CSTR_LESS_THAN:
        return -1;
    case CSTR_GREATER_THAN:
        return 1;
    default:
        return 0;
    }
}


template <class T>
inline int CSimpleStringBase<T>::GenericCompareNoCase( const T *pszSource, const T *pszDest )
{
#if defined(DBG) && !defined(UNICODE) && !defined(_UNICODE)
    if (sizeof(T) == sizeof(wchar_t))
    {
        OutputDebugString(TEXT("CompareStringW is not supported under win9x, so this call is going to fail!"));
    }
#endif
    int nRes = IS_CHAR(*pszSource) ?
               CompareStringA( LOCALE_USER_DEFAULT, NORM_IGNORECASE, (LPCSTR)pszSource, -1, (LPCSTR)pszDest, -1 ) :
               CompareStringW( LOCALE_USER_DEFAULT, NORM_IGNORECASE, (LPCWSTR)pszSource, -1, (LPCWSTR)pszDest, -1 );
    switch (nRes)
    {
    case CSTR_LESS_THAN:
        return -1;
    case CSTR_GREATER_THAN:
        return 1;
    default:
        return 0;
    }
}

template <class T>
inline int CSimpleStringBase<T>::GenericCompareLength( const T *pszStringA, const T *pszStringB, UINT nLength )
{
#if defined(DBG) && !defined(UNICODE) && !defined(_UNICODE)
    if (sizeof(T) == sizeof(wchar_t))
    {
        OutputDebugString(TEXT("CompareStringW is not supported under win9x, so this call is going to fail!"));
    }
#endif
    if (!nLength)
        return(0);
    int nRes = IS_CHAR(*pszStringA) ?
               CompareStringA( LOCALE_USER_DEFAULT, 0, (LPCSTR)pszStringA, Min(nLength,CSimpleStringBase<CHAR>::GenericLength((LPCSTR)pszStringA)), (LPCSTR)pszStringB, Min(nLength,CSimpleStringBase<CHAR>::GenericLength((LPCSTR)pszStringB)) ) :
               CompareStringW( LOCALE_USER_DEFAULT, 0, (LPWSTR)pszStringA, Min(nLength,CSimpleStringBase<WCHAR>::GenericLength((LPCWSTR)pszStringA)), (LPCWSTR)pszStringB, Min(nLength,CSimpleStringBase<WCHAR>::GenericLength((LPCWSTR)pszStringB)) );
    switch (nRes)
    {
    case CSTR_LESS_THAN:
        return -1;
    case CSTR_GREATER_THAN:
        return 1;
    default:
        return 0;
    }
}

template <class T>
bool CSimpleStringBase<T>::EnsureLength( UINT nMaxSize )
{
    UINT nOldMaxSize = m_nMaxSize;
    if (m_nMaxSize >= nMaxSize)
        return true;
    while (m_nMaxSize < nMaxSize)
    {
        m_nMaxSize += 16;
    }
    T *pszTmp = new T[m_nMaxSize];
    if (!pszTmp)
    {
        m_nMaxSize = nOldMaxSize;
        return false;
    }
    if (m_pstrData)
    {
        GenericCopy(pszTmp,m_pstrData);
        delete[] m_pstrData;
    }
    m_pstrData = pszTmp;
    return true;
}

template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::GetWindowText( HWND hWnd )
{
    Destroy();
    // Assume it didn't work
    bool bSuccess = false;
    int nLen = ::GetWindowTextLength(hWnd);
    if (nLen)
    {
        if (EnsureLength(nLen+1))
        {
            if (::GetWindowText( hWnd, m_pstrData, (nLen+1) ))
            {
                bSuccess = true;
            }
        }
    }
    if (!bSuccess)
    {
        Destroy();
    }
    return *this;
}

template <class T>
bool CSimpleStringBase<T>::SetWindowText( HWND hWnd )
{
    return(::SetWindowText( hWnd, String() ) != FALSE);
}

template <class T>
CSimpleStringBase<T>::CSimpleStringBase(void)
: m_pstrData(NULL),m_nMaxSize(0),m_nGranularity(m_nDefaultGranularity)
{
    T szTmp[1] = { 0};
    Assign(szTmp);
}

template <class T>
CSimpleStringBase<T>::CSimpleStringBase( const CSimpleStringBase &other )
: m_pstrData(NULL),m_nMaxSize(0),m_nGranularity(m_nDefaultGranularity)
{
    Assign(other.String());
}

template <class T>
CSimpleStringBase<T>::CSimpleStringBase( const T *szStr )
: m_pstrData(NULL),m_nMaxSize(0),m_nGranularity(m_nDefaultGranularity)
{
    Assign(szStr);
}

template <class T>
CSimpleStringBase<T>::CSimpleStringBase( T ch )
: m_pstrData(NULL),m_nMaxSize(0),m_nGranularity(m_nDefaultGranularity)
{
    T szTmp[2];
    szTmp[0] = ch;
    szTmp[1] = 0;
    Assign(szTmp);
}


template <class T>
CSimpleStringBase<T>::CSimpleStringBase( UINT nResId, HMODULE hModule )
: m_pstrData(NULL),m_nMaxSize(0),m_nGranularity(m_nDefaultGranularity)
{
    LoadString( nResId, hModule );
}


template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::Format( const T *strFmt, ... )
{
    T szTmp[1024];
    va_list arglist;

    va_start(arglist, strFmt);
    int nRet = IS_CHAR(*m_pstrData) ?
               ::wvsprintfA((LPSTR)szTmp, (LPCSTR)strFmt, arglist) :
               ::wvsprintfW((LPWSTR)szTmp, (LPCWSTR)strFmt, arglist);
    va_end(arglist);
    Assign(szTmp);
    return *this;
}

template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::Format( int nResId, HINSTANCE hInst, ... )
{
    CSimpleStringBase<T> strFmt;
    va_list arglist;
    if (strFmt.LoadString(nResId,hInst))
    {
        T szTmp[1024];
        va_start(arglist, hInst);
        int nRet = IS_CHAR(*m_pstrData) ?
                   ::wvsprintfA((LPSTR)szTmp, (LPCSTR)strFmt.String(), arglist) :
                   ::wvsprintfW((LPWSTR)szTmp, (LPCWSTR)strFmt.String(), arglist);
        va_end(arglist);
        Assign(szTmp);
    }
    else Assign(NULL);
    return *this;
}

template <class T>
bool CSimpleStringBase<T>::LoadString( UINT nResId, HMODULE hModule )
{
    if (!hModule)
        hModule = GetModuleHandle(NULL);
    T szTmp[m_nMaxLoadStringBuffer];
    int nRet = IS_CHAR(*m_pstrData) ?
               ::LoadStringA( hModule, nResId, (LPSTR)szTmp, ARRAYSIZE(szTmp)) :
               ::LoadStringW( hModule, nResId, (LPWSTR)szTmp, ARRAYSIZE(szTmp));
    if (nRet)
        return Assign(szTmp);
    else return Assign(NULL);
}


template <class T>
CSimpleStringBase<T>::~CSimpleStringBase(void)
{
    Destroy();
}

template <class T>
void CSimpleStringBase<T>::Destroy(void)
{
    if (m_pstrData)
        delete[] m_pstrData;
    m_pstrData = NULL;
    m_nMaxSize = 0;
}

template <class T>
UINT CSimpleStringBase<T>::Length(void) const
{
    return(m_pstrData ? GenericLength(m_pstrData) : 0);
}

template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::operator=( const CSimpleStringBase &other )
{
    if (&other == this)
        return *this;
    Assign(other.String());
    return *this;
}

template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::operator=( const T *other )
{
    if (other == String())
        return *this;
    Assign(other);
    return *this;
}

template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::operator+=( const CSimpleStringBase &other )
{
    Concat(other.String());
    return *this;
}

template <class T>
CSimpleStringBase<T> CSimpleStringBase<T>::operator+( const CSimpleStringBase &other ) const
{
    CSimpleStringBase tmp(*this);
    tmp.Concat(other);
    return tmp;
}

template <class T>
bool CSimpleStringBase<T>::Assign( const T *szStr )
{
    if (szStr && EnsureLength(GenericLength(szStr)+1))
    {
        GenericCopy(m_pstrData,szStr);
    }
    else if (EnsureLength(1))
    {
        *m_pstrData = 0;
    }
    else Destroy();
    return(NULL != m_pstrData);
}

template <class T>
bool CSimpleStringBase<T>::Assign( const CSimpleStringBase &other )
{
    return Assign( other.String() );
}

template <class T>
void CSimpleStringBase<T>::SetAt( UINT nIndex, T chValue )
{
    //
    // Make sure we don't go off the end of the string or overwrite the '\0'
    //
    if (m_pstrData && Length() > nIndex)
    {
        m_pstrData[nIndex] = chValue;
    }
}


template <class T>
void CSimpleStringBase<T>::Concat( const CSimpleStringBase &other )
{
    if (EnsureLength( Length() + other.Length() + 1 ))
    {
        GenericConcatenate(m_pstrData,other.String());
    }
}

template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::MakeUpper(void)
{
    //
    // Make sure the string is not NULL
    //
    if (m_pstrData)
    {
        IS_CHAR(*m_pstrData) ? CharUpperBuffA( (LPSTR)m_pstrData, Length() ) : CharUpperBuffW( (LPWSTR)m_pstrData, Length() );
    }
    return *this;
}

template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::MakeLower(void)
{
    //
    // Make sure the string is not NULL
    //
    if (m_pstrData)
    {
        IS_CHAR(*m_pstrData) ? CharLowerBuffA( (LPSTR)m_pstrData, Length() ) : CharLowerBuffW( (LPWSTR)m_pstrData, Length() );
    }
    return *this;
}

template <class T>
CSimpleStringBase<T> CSimpleStringBase<T>::ToUpper(void) const
{
    CSimpleStringBase str(*this);
    str.MakeUpper();
    return str;
}

template <class T>
CSimpleStringBase<T> CSimpleStringBase<T>::ToLower(void) const
{
    CSimpleStringBase str(*this);
    str.MakeLower();
    return str;
}

template <class T>
T &CSimpleStringBase<T>::operator[](int nIndex)
{
    return m_pstrData[nIndex];
}

template <class T>
const T &CSimpleStringBase<T>::operator[](int index) const
{
    return m_pstrData[index];
}

template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::TrimRight(void)
{
    T *pFirstWhitespaceCharacterInSequence = NULL;
    bool bInWhiteSpace = false;
    T *pszPtr = m_pstrData;
    while (pszPtr && *pszPtr)
    {
        if (*pszPtr == L' ' || *pszPtr == L'\t' || *pszPtr == L'\n' || *pszPtr == L'\r')
        {
            if (!bInWhiteSpace)
            {
                pFirstWhitespaceCharacterInSequence = pszPtr;
                bInWhiteSpace = true;
            }
        }
        else
        {
            bInWhiteSpace = false;
        }
        pszPtr = GenericCharNext(pszPtr);
    }
    if (pFirstWhitespaceCharacterInSequence && bInWhiteSpace)
        *pFirstWhitespaceCharacterInSequence = 0;
    return *this;
}

template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::TrimLeft(void)
{
    T *pszPtr = m_pstrData;
    while (pszPtr && *pszPtr)
    {
        if (*pszPtr == L' ' || *pszPtr == L'\t' || *pszPtr == L'\n' || *pszPtr == L'\r')
        {
            pszPtr = GenericCharNext(pszPtr);
        }
        else break;
    }
    Assign(CSimpleStringBase<T>(pszPtr).String());
    return *this;
}

template <class T>
inline CSimpleStringBase<T> &CSimpleStringBase<T>::Trim(void)
{
    TrimLeft();
    TrimRight();
    return *this;
}

//
// Note that this function WILL NOT WORK CORRECTLY for multi-byte characters in ANSI strings
//
template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::Reverse(void)
{
    UINT nLen = Length();
    for (UINT i = 0;i<nLen/2;i++)
    {
        T tmp = m_pstrData[i];
        m_pstrData[i] = m_pstrData[nLen-i-1];
        m_pstrData[nLen-i-1] = tmp;
    }
    return *this;
}

template <class T>
int CSimpleStringBase<T>::Find( T cChar ) const
{
    T strTemp[2] = { cChar, 0};
    return Find(strTemp);
}


template <class T>
int CSimpleStringBase<T>::Find( const CSimpleStringBase &other, UINT nStart ) const
{
    if (!m_pstrData)
        return -1;
    if (nStart > Length())
        return -1;
    T *pstrCurr = m_pstrData+nStart, *pstrSrc, *pstrSubStr;
    while (*pstrCurr)
    {
        pstrSrc = pstrCurr;
        pstrSubStr = (T *)other.String();
        while (*pstrSrc && *pstrSubStr && *pstrSrc == *pstrSubStr)
        {
            pstrSrc = GenericCharNext(pstrSrc);
            pstrSubStr = GenericCharNext(pstrSubStr);
        }
        if (!*pstrSubStr)
            return static_cast<int>(pstrCurr-m_pstrData);
        pstrCurr = GenericCharNext(pstrCurr);
    }
    return -1;
}

template <class T>
int CSimpleStringBase<T>::ReverseFind( T cChar ) const
{
    T strTemp[2] = { cChar, 0};
    return ReverseFind(strTemp);
}

template <class T>
int CSimpleStringBase<T>::ReverseFind( const CSimpleStringBase &srcStr ) const
{
    int nLastFind = -1, nFind=0;
    while ((nFind = Find( srcStr, nFind )) >= 0)
    {
        nLastFind = nFind;
        ++nFind;
    }
    return nLastFind;
}

template <class T>
CSimpleStringBase<T> CSimpleStringBase<T>::SubStr( int nStart, int nCount ) const
{
    if (nStart >= (int)Length() || nStart < 0)
        return CSimpleStringBase<T>();
    if (nCount < 0)
        nCount = Length() - nStart;
    CSimpleStringBase<T> strTmp;
    T *pszTmp = new T[nCount+1];
    if (pszTmp)
    {
        GenericCopyLength( pszTmp, m_pstrData+nStart, nCount+1 );
        pszTmp[nCount] = 0;
        strTmp = pszTmp;
        delete[] pszTmp;
    }
    return strTmp;
}



template <class T>
int CSimpleStringBase<T>::CompareNoCase( const CSimpleStringBase &other, int nLength ) const
{
    if (nLength < 0)
    {
        //
        // Make sure both strings are non-NULL
        //
        if (!String() && !other.String())
        {
            return 0;
        }
        else if (!String())
        {
            return -1;
        }
        else if (!other.String())
        {
            return 1;
        }
        else return GenericCompareNoCase(m_pstrData,other.String());
    }
    CSimpleStringBase<T> strSrc(*this);
    CSimpleStringBase<T> strTgt(other);
    strSrc.MakeUpper();
    strTgt.MakeUpper();
    //
    // Make sure both strings are non-NULL
    //
    if (!strSrc.String() && !strTgt.String())
    {
        return 0;
    }
    else if (!strSrc.String())
    {
        return -1;
    }
    else if (!strTgt.String())
    {
        return 1;
    }
    else return GenericCompareLength(strSrc.String(),strTgt.String(),nLength);
}


template <class T>
int CSimpleStringBase<T>::Compare( const CSimpleStringBase &other, int nLength ) const
{
    //
    // Make sure both strings are non-NULL
    //
    if (!String() && !other.String())
    {
        return 0;
    }
    else if (!String())
    {
        return -1;
    }
    else if (!other.String())
    {
        return 1;
    }

    if (nLength < 0)
    {
        return GenericCompare(String(),other.String());
    }
    return GenericCompareLength(String(),other.String(),nLength);
}

template <class T>
bool CSimpleStringBase<T>::MatchLastCharacter( T cChar ) const
{
    int nFind = ReverseFind(cChar);
    if (nFind < 0)
        return false;
    if (nFind == (int)Length()-1)
        return true;
    else return false;
}

template <class T>
bool CSimpleStringBase<T>::Load( HKEY hRegKey, const T *pszValueName, const T *pszDefault )
{
    bool bResult = false;
    Assign(pszDefault);
    DWORD nType=0;
    DWORD nSize=0;
    LONG nRet;
    if (IS_CHAR(*m_pstrData))
        nRet = RegQueryValueExA( hRegKey, (LPCSTR)pszValueName, NULL, &nType, NULL, &nSize);
    else nRet = RegQueryValueExW( hRegKey, (LPCWSTR)pszValueName, NULL, &nType, NULL, &nSize);
    if (ERROR_SUCCESS == nRet)
    {
        if ((nType == REG_SZ) || (nType == REG_EXPAND_SZ))
        {
            // Round up to the nearest 2
            nSize = ((nSize + 1) & 0xFFFFFFFE);
            T *pstrTemp = new T[nSize / sizeof(T)];
            if (pstrTemp)
            {
                if (IS_CHAR(*m_pstrData))
                    nRet = RegQueryValueExA( hRegKey, (LPCSTR)pszValueName, NULL, &nType, (PBYTE)pstrTemp, &nSize);
                else nRet = RegQueryValueExW( hRegKey, (LPCWSTR)pszValueName, NULL, &nType, (PBYTE)pstrTemp, &nSize);
                if (ERROR_SUCCESS == nRet)
                {
                    Assign(pstrTemp);
                    bResult = true;
                }
                delete pstrTemp;
            }
        }
    }
    return bResult;
}

template <class T>
bool CSimpleStringBase<T>::Store( HKEY hRegKey, const T *pszValueName, DWORD nType )
{
    bool bResult = false;
    long nRet;
    if (Length())
    {
        if (IS_CHAR(*m_pstrData))
            nRet = RegSetValueExA( hRegKey, (LPCSTR)pszValueName, 0, nType, (PBYTE)m_pstrData, sizeof(*m_pstrData)*(Length()+1) );
        else nRet = RegSetValueExW( hRegKey, (LPCWSTR)pszValueName, 0, nType, (PBYTE)m_pstrData, sizeof(*m_pstrData)*(Length()+1) );
    }
    else
    {
        T strBlank = 0;
        if (IS_CHAR(*m_pstrData))
            nRet = RegSetValueExA( hRegKey, (LPCSTR)pszValueName, 0, nType, (PBYTE)&strBlank, sizeof(T) );
        else nRet = RegSetValueExW( hRegKey, (LPCWSTR)pszValueName, 0, nType, (PBYTE)&strBlank, sizeof(T) );
    }
    return(ERROR_SUCCESS == nRet);
}


typedef CSimpleStringBase<char>     CSimpleStringAnsi;
typedef CSimpleStringBase<wchar_t>  CSimpleStringWide;

#if defined(UNICODE) || defined(_UNICODE)
#define CSimpleString CSimpleStringWide
#else
#define CSimpleString CSimpleStringAnsi
#endif

namespace CSimpleStringConvert
{
    template <class T>
    CSimpleStringWide WideString(const T &str)
    {
        if (IS_WCHAR(str[0]))
            return CSimpleStringWide((LPCWSTR)str.String());
        else
        {
            if (!str.Length())
                return CSimpleStringWide(L"");
            int iLen = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, (LPCSTR)str.String(), str.Length()+1, NULL, 0 );
            CSimpleStringWide sswTmp;
            LPWSTR pwszTmp = new WCHAR[iLen];
            if (pwszTmp)
            {
                MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, (LPCSTR)str.String(), str.Length()+1, pwszTmp, iLen );
                sswTmp = pwszTmp;
                delete[] pwszTmp;
            }
            return sswTmp;
        }
    }

    template <class T>
    CSimpleStringAnsi AnsiString(const T &str)
    {
        if (IS_CHAR(str[0]))
            return CSimpleStringAnsi((LPCSTR)str.String());
        else
        {
            if (!str.Length())
                return CSimpleStringAnsi("");
            int iLen = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)str.String(), str.Length()+1, NULL, 0, NULL, NULL );
            CSimpleStringAnsi ssaTmp;
            LPSTR pszTmp = new CHAR[iLen];
            if (pszTmp)
            {
                WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)str.String(), str.Length()+1, pszTmp, iLen, NULL, NULL );
                ssaTmp = pszTmp;
                delete[] pszTmp;
            }
            return ssaTmp;
        }
    }

#if defined(_UNICODE) || defined(UNICODE)
    template <class T>
    CSimpleStringWide NaturalString(const T &str)
    {
        return WideString(str);
    }
#else
    template <class T>
    CSimpleStringAnsi NaturalString(const T &str)
    {
        return AnsiString(str);
    }
#endif

    inline CSimpleString NumberToString( int nNumber, LCID Locale=LOCALE_USER_DEFAULT )
    {
        TCHAR szTmp[MAX_PATH]=TEXT("");
        TCHAR szNumberStr[MAX_PATH]=TEXT("");
        TCHAR szDigitGrouping[32]=TEXT("");
        TCHAR szThousandsSeparator[32]=TEXT("");
        TCHAR szDecimalSeparator[32]=TEXT("");

        // Initialize the number format
        NUMBERFMT NumberFormat;
        NumberFormat.NumDigits = 0;
        NumberFormat.LeadingZero = 0;
        NumberFormat.NegativeOrder = 0;
        // This turns a string into a number, like so: 3;2;0=32 or 3;0 = 3 or 1;2;3;4;5;6;0 = 123456.  Got it?
        GetLocaleInfo( Locale, LOCALE_SGROUPING, szDigitGrouping, ARRAYSIZE(szDigitGrouping));
        NumberFormat.Grouping = 0;
        LPTSTR pszCurr = szDigitGrouping;
        while (*pszCurr && *pszCurr >= TEXT('1') && *pszCurr <= TEXT('9'))
        {
            NumberFormat.Grouping *= 10;
            NumberFormat.Grouping += (*pszCurr - TEXT('0'));
            pszCurr += 2;
        }
        GetLocaleInfo( Locale, LOCALE_STHOUSAND, szThousandsSeparator, ARRAYSIZE(szThousandsSeparator));
        NumberFormat.lpThousandSep = szThousandsSeparator;
        GetLocaleInfo( Locale, LOCALE_SDECIMAL, szDecimalSeparator, ARRAYSIZE(szDecimalSeparator));
        NumberFormat.lpDecimalSep = szDecimalSeparator;
        // Create the number string
        wsprintf(szTmp, TEXT("%d"), nNumber );
        if (GetNumberFormat( Locale, 0, szTmp, &NumberFormat, szNumberStr, ARRAYSIZE(szNumberStr)))
            return szNumberStr;
        else return TEXT("");
    }
}  // End CSimpleStringConvert namespace

#endif  // ifndef _SIMSTR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\sshndler.cpp ===
#include "precomp.h"
#include "sshndler.h"
#include "ssutil.h"
#include <Windowsx.h>

CScreenSaverHandler::CScreenSaverHandler( HWND hWnd,
                                          UINT nFindNotifyMessage,
                                          UINT nPaintTimer,
                                          UINT nChangeTimer,
                                          UINT nToolbarTimer,
                                          HINSTANCE hInstance )
  : m_hWnd(hWnd),
    m_hInstance(hInstance),
    m_nFindNotifyMessage(nFindNotifyMessage),
    m_nPaintTimerId(nPaintTimer),
    m_nChangeTimerId(nChangeTimer),
    m_nToolbarTimerId(nToolbarTimer),
    m_pImageScreenSaver(NULL),
    m_bPaused(false),
    m_hFindThread(NULL),
    m_hFindCancel(NULL),
    m_bFirstImage(true),
    m_hwndTB(NULL),
    m_bToolbarVisible(false),
    m_LastMousePosition(NULL)
{
}

static const TBBUTTON    c_tbSlideShow[] =
{
    // override default toolbar width for separators; iBitmap member of
    // TBBUTTON struct is a union of bitmap index & separator width
    { 0, ID_PLAYCMD,        TBSTATE_ENABLED | TBSTATE_CHECKED,   TBSTYLE_CHECKGROUP,     {0,0}, 0, 0},
    { 1, ID_PAUSECMD,       TBSTATE_ENABLED,                     TBSTYLE_CHECKGROUP,     {0,0}, 0, 0},
    { 5, 0,                 TBSTATE_ENABLED,                     TBSTYLE_SEP,            {0,0}, 0, 0},
    { 2, ID_PREVCMD,        TBSTATE_ENABLED,                     TBSTYLE_BUTTON,         {0,0}, 0, 0},
    { 3, ID_NEXTCMD,        TBSTATE_ENABLED,                     TBSTYLE_BUTTON,         {0,0}, 0, 0},
    { 6, 0,                 TBSTATE_ENABLED,                     TBSTYLE_SEP,            {0,0}, 0, 0},
    { 7, 0,                 TBSTATE_ENABLED,                     TBSTYLE_SEP,            {0,0}, 0, 0},
    { 4, ID_CLOSECMD,       TBSTATE_ENABLED,                     TBSTYLE_BUTTON,         {0,0}, 0, 0},
};

HRESULT CScreenSaverHandler::_InitializeToolbar(HWND hwndTB, 
                                                int idCold, 
                                                int idHot)
{
	HRESULT hr = S_OK;
	
    int cxBitmap = 16, cyBitmap = 16;

    ::SendMessage(hwndTB, CCM_SETVERSION, COMCTL32_VERSION, 0);
    ::SendMessage(hwndTB, TB_SETEXTENDEDSTYLE, 0, TBSTYLE_EX_MIXEDBUTTONS);
    ::SendMessage(hwndTB, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
    ::SendMessage(hwndTB, TB_SETMAXTEXTROWS, 1, 0);

    // Create, fill, and assign the image list for default buttons.
    HBITMAP hbCold = (HBITMAP)::CreateMappedBitmap(m_hInstance,
                                                  idCold,
                                                  0,
                                                  NULL,
                                                  0);
    if(!hbCold)
    {
    	hr = E_FAIL;
    }
    else
    {
        HIMAGELIST himl = ::ImageList_Create(cxBitmap, 
                                             cyBitmap, 
                                             ILC_COLOR8|ILC_MASK, 
                                             0, 
                                             ARRAYSIZE(c_tbSlideShow));
        if(!himl)
        {
            hr = E_FAIL;
        }
    
        if( -1 == ::ImageList_AddMasked(himl, hbCold, RGB(255, 0, 255)))
        {
            hr = E_FAIL;
        }

        ::SendMessage(hwndTB, TB_SETIMAGELIST, 0, (LPARAM)himl);
        ::DeleteObject(hbCold);
    }

    // Create, fill, and assign the image list for hot buttons.
    HBITMAP hbHot = (HBITMAP)::CreateMappedBitmap(m_hInstance, 
                                                  idHot, 
                                                  0, 
                                                  NULL, 
                                                  0);
    if(!hbHot)
    {
    	hr = E_FAIL;
    }
    else
    {
        HIMAGELIST himlHot = ::ImageList_Create(cxBitmap, 
                                                cyBitmap, 
                                                ILC_COLOR8|ILC_MASK, 
                                                0, 
                                                ARRAYSIZE(c_tbSlideShow));
        if(!himlHot)
        {
            hr = E_FAIL;
        }
        ::ImageList_AddMasked(himlHot, hbHot, RGB(255, 0, 255));

        ::SendMessage(hwndTB, TB_SETHOTIMAGELIST, 0, (LPARAM)himlHot);
        ::DeleteObject(hbHot);
    }

    return hr;
}

HRESULT CScreenSaverHandler::_CreateToolbar()
{
    HRESULT hr = S_OK;

    ::InitCommonControls();
    
    DWORD dwStyle = WS_CHILD | CCS_ADJUSTABLE;
    m_hwndTB = ::CreateWindowEx(0, TOOLBARCLASSNAME, 
                                NULL, dwStyle, 0, 0, 0, 0,
                                m_hWnd, (HMENU) NULL, m_hInstance, NULL);
   if(!m_hwndTB)
   {
       hr = E_FAIL;
   }
   else
   {
       _InitializeToolbar(m_hwndTB, IDB_SLIDESHOWTOOLBAR, IDB_SLIDESHOWTOOLBARHOT);

       TBBUTTON tbSlideShow[ARRAYSIZE(c_tbSlideShow)];
       ::memcpy(tbSlideShow, c_tbSlideShow, sizeof(c_tbSlideShow));

       // Add the buttons, and then set the minimum and maximum button widths.
       ::SendMessage(m_hwndTB, TB_ADDBUTTONS, 
                     (UINT)ARRAYSIZE(c_tbSlideShow), (LPARAM)tbSlideShow);

       LRESULT dwSize = ::SendMessage(m_hwndTB, TB_GETBUTTONSIZE, 0, 0);
       RECT rcClient = {0};
       RECT rcToolbar = {0, 0, GET_X_LPARAM(dwSize) * ARRAYSIZE(c_tbSlideShow), GET_Y_LPARAM(dwSize)};


       ::GetClientRect(m_hWnd,&rcClient);
       ::AdjustWindowRectEx(&rcToolbar, dwStyle, FALSE, WS_EX_TOOLWINDOW);
       ::SetWindowPos(m_hwndTB,
                      HWND_TOP,
                      RECTWIDTH(rcClient)-RECTWIDTH(rcToolbar),
                      0,
                      RECTWIDTH(rcToolbar),
                      RECTHEIGHT(rcToolbar),
                      SWP_NOCOPYBITS | SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW);
       ::ShowCursor(false);
       ::SendMessage(m_hwndTB, TB_AUTOSIZE, 0, 0);
   }
   return hr;
}

void CScreenSaverHandler::Initialize(void)
{
    CWaitCursor wc;

    HDC hDC = ::GetDC(m_hWnd);
    if (hDC)
    {
        m_pImageScreenSaver = new CImageScreenSaver( m_hInstance, 
                                                     true );
        if (m_pImageScreenSaver)
        {
            m_pImageScreenSaver->SetScreenRect(m_hWnd);

            if (m_pImageScreenSaver->IsValid())
            {
                m_hFindCancel = ::CreateEvent( NULL, TRUE, FALSE, NULL );
                if (m_hFindCancel)
                {
                    m_hFindThread = m_pImageScreenSaver->Initialize( m_hWnd, 
                                                                     m_nFindNotifyMessage, 
                    	                                             m_hFindCancel );
                }
            }
            else
            {
                delete m_pImageScreenSaver;
                m_pImageScreenSaver = NULL;
            }
        }

        ::ReleaseDC( m_hWnd, hDC );
    }
    _CreateToolbar();
}

CScreenSaverHandler::~CScreenSaverHandler(void)
{
    if (m_pImageScreenSaver)
    {
        delete m_pImageScreenSaver;
        m_pImageScreenSaver = NULL;
    }
    if (m_hFindCancel)
    {
        ::SetEvent(m_hFindCancel);
        ::CloseHandle(m_hFindCancel);
        m_hFindCancel = NULL;
    }
    if (m_hFindThread)
    {
        ::WaitForSingleObject( m_hFindThread, INFINITE );
        ::CloseHandle(m_hFindThread);
        m_hFindThread = NULL;
    }
}

void CScreenSaverHandler::OnPrev()
{
	OnPause();
    if(m_pImageScreenSaver)
    {
        if(!m_pImageScreenSaver->ReplaceImage(false,true))
        {
            OnStop();
        }
        m_pImageScreenSaver->OnInput();
    }
    HandleTimer(m_nPaintTimerId);
}

void CScreenSaverHandler::OnNext()
{
	OnPause();
    if(m_pImageScreenSaver)
    {
        if(!m_pImageScreenSaver->ReplaceImage(true,true))
        {
            OnStop();
        }
        m_pImageScreenSaver->OnInput();
    }
    HandleTimer(m_nPaintTimerId);
}

void CScreenSaverHandler::OnPause()
{
    m_bPaused = true;
    if(m_hwndTB)
    {
        ::SendMessage(m_hwndTB, TB_SETSTATE, ID_PAUSECMD, (LPARAM) MAKELONG(TBSTATE_CHECKED | TBSTATE_ENABLED,0));
        ::SendMessage(m_hwndTB, TB_SETSTATE, ID_PLAYCMD, (LPARAM) MAKELONG(TBSTATE_ENABLED,0));
    }
}

void CScreenSaverHandler::OnStop()
{
    ::PostMessage(m_hWnd, WM_CLOSE, 0, 0);
}

void CScreenSaverHandler::OnPlay()
{
    m_bPaused = false;
    if(m_hwndTB)
    {
        ::SendMessage(m_hwndTB, TB_SETSTATE, ID_PAUSECMD, (LPARAM) MAKELONG(TBSTATE_ENABLED,0));
        ::SendMessage(m_hwndTB, TB_SETSTATE, ID_PLAYCMD, (LPARAM) MAKELONG(TBSTATE_CHECKED | TBSTATE_ENABLED,0));
    }

    if (m_pImageScreenSaver)
    {
        m_pImageScreenSaver->OnInput();
        if(m_pImageScreenSaver->ReplaceImage(true,true))
        {
            m_TimerPaint.Set( m_hWnd,
                              m_nPaintTimerId,
                              CHANGE_TIMER_INTERVAL_MSEC );
        }
        else
        {
            OnStop();
        }
    }
}

// turn on the toolbar window.
// let the screen saver know it's on.
// start the toolbar timer - which will turn it off later.
HRESULT CScreenSaverHandler::_ShowToolbar(bool bShow)
{
    HRESULT hr = S_OK;

    if(m_pImageScreenSaver)
    {
        m_pImageScreenSaver->ShowToolbar(bShow);
    }

    if((bShow == true) && 
       (m_bToolbarVisible == false))
    {
        m_bToolbarVisible = bShow;

        if(m_hwndTB)
        {
            ::ShowWindow(m_hwndTB, SW_SHOW);
            ::ShowCursor(true);
            m_bToolbarVisible = true;
        }
        // set timer to remove toolbar
        m_TimerInput.Set( m_hWnd,
                          m_nToolbarTimerId,
                          TOOLBAR_TIMER_DELAY );
        InvalidateRect(m_hwndTB,NULL,TRUE);
    }
    else if((bShow == false) && 
            (m_bToolbarVisible == true))
    {
        if(m_hwndTB)
        {
            ::ShowWindow(m_hwndTB, SW_HIDE);
            ::ShowCursor(false);
            m_bToolbarVisible = false;
        }
    }
    
    HandlePaint();   // repaint the frame
    return hr;
}

bool CScreenSaverHandler::HandleMouseMove(WPARAM wParam, LPARAM lParam)
{
    if(m_LastMousePosition == NULL)
    {
        m_LastMousePosition = lParam;
    }
    else if (m_LastMousePosition != lParam)
    {
        _OnInput();
        m_LastMousePosition = lParam;
    }

    return false;
}

bool CScreenSaverHandler::HandleMouseMessage(WPARAM wParam, LPARAM lParam)
{
    if (m_pImageScreenSaver)
    {        
        m_pImageScreenSaver->OnInput();
    }
    return false;
}

void CScreenSaverHandler::HandleOnCommand( WPARAM wParam, LPARAM lParam)
{
    _OnInput();

    switch(wParam)
    {
    case ID_PLAYCMD:
       OnPlay();
       break;
    case ID_PAUSECMD:
       OnPause();
       break;
    case ID_PREVCMD:
       OnPrev();
       break;
    case ID_NEXTCMD:
       OnNext();
       break;
    case ID_CLOSECMD:
       OnStop();
       break;
    }
}

void CScreenSaverHandler::HandleOnAppCommand( WPARAM wParam, LPARAM lParam)
{
    _OnInput();
    switch(GET_APPCOMMAND_LPARAM(lParam))
    {
    case APPCOMMAND_BROWSER_BACKWARD:
    case APPCOMMAND_MEDIA_PREVIOUSTRACK:
        {
            OnPrev();
        }
        break;
    case APPCOMMAND_MEDIA_NEXTTRACK:
    case APPCOMMAND_BROWSER_FORWARD:
        {
            OnNext();
        }
        break;
    case APPCOMMAND_MEDIA_STOP:
    case APPCOMMAND_BROWSER_STOP:
        {
            OnStop();
        }
        break;
    case APPCOMMAND_MEDIA_PLAY_PAUSE:
        {
            if(m_bPaused)
            {
                OnPlay();
            }
            else
            {
                OnPause();
            }
        }
        break;
    }
}

void CScreenSaverHandler::_OnInput()
{
    m_TimerInput.Set( m_hWnd, m_nToolbarTimerId, TOOLBAR_TIMER_DELAY );
    _ShowToolbar(true);
}


bool CScreenSaverHandler::HandleKeyboardMessage( UINT nMessage, WPARAM nVirtkey )
{
    _OnInput();

    if (m_pImageScreenSaver)
    {
        m_pImageScreenSaver->OnInput();
        if (nMessage == WM_KEYDOWN)
        {
            switch (nVirtkey)
            {
            case VK_DOWN:
                if (nMessage == WM_KEYDOWN)
                {
                    m_bPaused = !m_bPaused;
                    if (!m_bPaused)
                    {
                        if (m_pImageScreenSaver)
                        {
                            if (m_pImageScreenSaver->ReplaceImage(true,false))
                            {
                                m_TimerPaint.Set( m_hWnd, m_nPaintTimerId, PAINT_TIMER_INTERVAL_MSEC );
                            }
                            else
                            {
                                OnStop();
                            }
                        }
                    }
                }
                return true;

            case VK_LEFT:
                if (nMessage == WM_KEYDOWN)
                {
                    OnPrev();
                }
                return true;

            case VK_RIGHT:
                if (nMessage == WM_KEYDOWN)
                {
                    OnNext();
                }
                return true;

            case VK_ESCAPE:
            case VK_DELETE:
                if (nMessage == WM_KEYDOWN)
                {
                    OnStop();
                }
                return true;
            }
        }
    }
    return false;
}


void CScreenSaverHandler::OnSize(WPARAM wParam, LPARAM lParam)
{
    HandlePaint();
}

void CScreenSaverHandler::HandleConfigChange()
{
    if (m_pImageScreenSaver)
    {
        m_pImageScreenSaver->SetScreenRect(m_hWnd);
    }
}


void CScreenSaverHandler::HandleTimer( WPARAM nEvent )
{
    if (nEvent == m_nPaintTimerId)
    {
        if (m_pImageScreenSaver)
        {
            CSimpleDC ClientDC;
            if (ClientDC.GetDC(m_hWnd))
            {
                bool bResult = m_pImageScreenSaver->TimerTick( ClientDC );
                if (bResult)
                {
                    m_TimerPaint.Set( m_hWnd,
                                      m_nChangeTimerId,
                                      CHANGE_TIMER_INTERVAL_MSEC );
                }
                InvalidateRect(m_hwndTB,NULL,TRUE);
            }
        }
    }
    else if (nEvent == m_nChangeTimerId)
    {
        m_TimerPaint.Kill();

        if (!m_bPaused && m_pImageScreenSaver)
        {
            if(m_pImageScreenSaver->ReplaceImage(true,false))
            {
                m_TimerPaint.Set( m_hWnd, m_nPaintTimerId, PAINT_TIMER_INTERVAL_MSEC );
            }
            else
            {
                // unable to find next image - so exit the screensaver.
                OnStop();
            }
        }
    }
    else if (nEvent == m_nToolbarTimerId)
    {
        // m_TimerInput expired - so turn off toolbar
        _ShowToolbar(false);
    }
}


void CScreenSaverHandler::HandlePaint(void)
{
    if (m_pImageScreenSaver)
    {
        CSimpleDC PaintDC;
        if (PaintDC.BeginPaint(m_hWnd))
        {
            m_pImageScreenSaver->Paint(PaintDC);
        }
    }
}

void CScreenSaverHandler::HandleFindFile( CFoundFileMessageData *pFoundFileMessageData )
{
    if (m_pImageScreenSaver)
    {
        if (pFoundFileMessageData)
        {
            bool bResult = m_pImageScreenSaver->FoundFile( pFoundFileMessageData->Name() );
            if (!bResult)
            {
                ::SetEvent( m_hFindCancel );
            }
            if (m_bFirstImage && m_pImageScreenSaver->Count())
            {
                // If this is our first image, start things up
                ::SendMessage( m_hWnd, WM_TIMER, m_nChangeTimerId, 0 );
                m_bFirstImage = false;
            }
            delete pFoundFileMessageData;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\ssutil.cpp ===
#include "precomp.h"
#pragma hdrstop
#include "ssutil.h"
#include <shlobj.h>

HPALETTE ScreenSaverUtil::SelectPalette( HDC hDC, HPALETTE hPalette, BOOL bForceBackground )
{
    HPALETTE hOldPalette = NULL;
    if (hDC && hPalette)
    {
        hOldPalette = ::SelectPalette( hDC, hPalette, bForceBackground );
        RealizePalette( hDC );
        SetBrushOrgEx( hDC, 0,0, NULL );
    }
    return hOldPalette;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\waitcurs.h ===
#ifndef __034b8365_8d02_4653_9065_2ec7e33d0fbe__
#define __034b8365_8d02_4653_9065_2ec7e33d0fbe__

class CWaitCursor
{
private:
    HCURSOR m_hCurOld;
public:
    CWaitCursor(void)
    {
        m_hCurOld = SetCursor( LoadCursor( NULL, IDC_WAIT ) );
    }
    ~CWaitCursor(void)
    {
        SetCursor(m_hCurOld);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\ssutil.h ===
#ifndef __0a7afb3c_5d75_4349_b74d_e75b8204abf7__
#define __0a7afb3c_5d75_4349_b74d_e75b8204abf7__

#include <windows.h>

#ifndef WM_APPCOMMAND
#define FAPPCOMMAND_MASK  0xF000
#define GET_APPCOMMAND_LPARAM(lParam) ((short)(HIWORD(lParam) & ~FAPPCOMMAND_MASK))
#define WM_APPCOMMAND                   0x0319
#define APPCOMMAND_BROWSER_BACKWARD       1
#define APPCOMMAND_BROWSER_FORWARD        2
#define APPCOMMAND_BROWSER_REFRESH        3
#define APPCOMMAND_BROWSER_STOP           4
#define APPCOMMAND_BROWSER_SEARCH         5
#define APPCOMMAND_BROWSER_FAVORITES      6
#define APPCOMMAND_BROWSER_HOME           7
#define APPCOMMAND_VOLUME_MUTE            8
#define APPCOMMAND_VOLUME_DOWN            9
#define APPCOMMAND_VOLUME_UP              10
#define APPCOMMAND_MEDIA_NEXTTRACK        11
#define APPCOMMAND_MEDIA_PREVIOUSTRACK    12
#define APPCOMMAND_MEDIA_STOP             13
#define APPCOMMAND_MEDIA_PLAY_PAUSE       14
#define APPCOMMAND_LAUNCH_MAIL            15
#define APPCOMMAND_LAUNCH_MEDIA_SELECT    16
#define APPCOMMAND_LAUNCH_APP1            17
#define APPCOMMAND_LAUNCH_APP2            18
#define APPCOMMAND_BASS_DOWN              19
#define APPCOMMAND_BASS_BOOST             20
#define APPCOMMAND_BASS_UP                21
#define APPCOMMAND_TREBLE_DOWN            22
#define APPCOMMAND_TREBLE_UP              23
#endif
    
namespace ScreenSaverUtil
{
    HPALETTE SelectPalette( HDC hDC, HPALETTE hPalette, BOOL bForceBackground );
} // Namespace

#endif //__SSUTIL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sshow\sshow.cpp ===
/*******************************************************************************
*  TITLE:       SSHOW.CPP
*  VERSION:     1.0
*  AUTHOR:      HunterH
*  DATE:        11/20/2000
*  DESCRIPTION: SlideShow for downlevel platforms.
*******************************************************************************/
#include "precomp.h"

#include <windows.h>
#include <gdiplus.h>
#include "imagescr.h"
#include "scrnsave.h"
#include "sshndler.h"
#include "ssmprsrc.h"
#include "findthrd.h"
#include "FindInstance.h"
#include "ssutil.h"

#define MAIN_WINDOW_CLASSNAME      TEXT("MySlideshowPicturesWindow")

#define ID_PAINTTIMER              1
#define ID_CHANGETIMER             2
#define ID_TOOLBARTIMER            3
#define UWM_FINDFILE               (WM_USER+1301)

HINSTANCE g_hInstance = NULL;

// Turn Features ON
#define FEATURE_FULLSCREEN_MODE

class CMainWindow
{
private:
    HWND m_hWnd;
    CScreenSaverHandler *m_pScreenSaverHandler;
public:
    CMainWindow( HWND hWnd )
        : m_hWnd(hWnd),m_pScreenSaverHandler(NULL)
    {
    }
    virtual ~CMainWindow(void)
    {
    }

    static HWND Create( DWORD dwExStyle,
                        LPCTSTR lpWindowName, 
                        DWORD dwStyle, 
                        int x, 
                        int y, 
                        int nWidth, 
                        int nHeight, 
                        HWND hWndParent, 
                        HMENU hMenu, 
                        HINSTANCE hInstance )
    {
        RegisterClass( hInstance );
        return CreateWindowEx( dwExStyle, 
                               MAIN_WINDOW_CLASSNAME, 
                               lpWindowName, 
                               dwStyle, 
                               x, 
                               y, 
                               nWidth, 
                               nHeight, 
                               hWndParent, 
                               hMenu, 
                               hInstance, 
                               NULL );
    }

    static bool RegisterClass( HINSTANCE hInstance )
    {
        WNDCLASSEX wcex = {0};
        wcex.cbSize = sizeof(wcex);
        wcex.style = CS_DBLCLKS;
        wcex.lpfnWndProc = WndProc;
        wcex.hInstance = hInstance;
        wcex.hIcon = LoadIcon( NULL, IDI_APPLICATION );
        wcex.hIconSm = LoadIcon( NULL, IDI_APPLICATION );
        wcex.hCursor = LoadCursor( NULL, IDC_ARROW );
        wcex.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
        wcex.lpszClassName = MAIN_WINDOW_CLASSNAME;
        BOOL res = (::RegisterClassEx(&wcex) != 0);
        return (res != 0);
    }

    LRESULT OnDestroy( WPARAM, LPARAM )
    {
        if (m_pScreenSaverHandler)
        {
            delete m_pScreenSaverHandler;
        }
        m_pScreenSaverHandler = NULL;
        PostQuitMessage(0);
        return 0;
    }

    LRESULT OnTimer( WPARAM wParam, LPARAM )
    {
        if (m_pScreenSaverHandler)
        {
            m_pScreenSaverHandler->HandleTimer(wParam);
        }
        return 0;
    }


    LRESULT OnPaint( WPARAM, LPARAM )
    {
        if (m_pScreenSaverHandler)
        {
            m_pScreenSaverHandler->HandlePaint();
        }
        return 0;
    }

    LRESULT OnShowWindow( WPARAM, LPARAM )
    {
        if (!m_pScreenSaverHandler)
        {
            m_pScreenSaverHandler = new CScreenSaverHandler( m_hWnd, 
                                                             UWM_FINDFILE, 
                                                             ID_PAINTTIMER, 
                                                             ID_CHANGETIMER,
                                                             ID_TOOLBARTIMER,
                                                             g_hInstance );
            if (m_pScreenSaverHandler)
            {
                m_pScreenSaverHandler->Initialize();
            }
        }
        return 0;
    }

    LRESULT OnMouseButton(WPARAM wParam, LPARAM lParam)
    {
        if (m_pScreenSaverHandler)
        {
            m_pScreenSaverHandler->HandleMouseMessage( wParam, lParam ); 
        }
        return 0;
    }

    LRESULT OnMouseMove(WPARAM wParam, LPARAM lParam)
    {
        if (m_pScreenSaverHandler)
        {
            m_pScreenSaverHandler->HandleMouseMove( wParam, lParam );
        }
        return 0;
    }

    LRESULT OnConfigChanged( WPARAM, LPARAM )
    {
        if (m_pScreenSaverHandler)
        {
            m_pScreenSaverHandler->HandleConfigChange();
        }
        return 0;
    }

    LRESULT OnSize(WPARAM wParam, LPARAM lParam)
    {
        if (m_pScreenSaverHandler)
        {
            m_pScreenSaverHandler->OnSize(wParam,lParam);
        }
        return 0;
    }

    LRESULT OnKeydown( WPARAM wParam, LPARAM )
    {
        if (m_pScreenSaverHandler)
        {
            m_pScreenSaverHandler->HandleKeyboardMessage( WM_KEYDOWN, 
            	                                        static_cast<int>(wParam) );
        }
        return 0;
    }

    LRESULT OnKeyup( WPARAM wParam, LPARAM )
    {
        if (m_pScreenSaverHandler)
        {
            m_pScreenSaverHandler->HandleKeyboardMessage( WM_KEYUP, 
            	                                        static_cast<int>(wParam) );
        }
        return 0;
    }

    LRESULT OnChar( WPARAM wParam, LPARAM )
    {
        if (m_pScreenSaverHandler)
        {
            m_pScreenSaverHandler->HandleKeyboardMessage( WM_CHAR, 
            	                                        static_cast<int>(wParam) );
        }
        return 0;
    }

    LRESULT OnWmAppCommand( WPARAM wParam, LPARAM lParam )
    {
        if (m_pScreenSaverHandler)
        {
            m_pScreenSaverHandler->HandleOnAppCommand(wParam,lParam);
        }
        return 0;
    }

    LRESULT OnFindFile( WPARAM wParam, LPARAM lParam )
    {
        if (m_pScreenSaverHandler && lParam)
        {
            m_pScreenSaverHandler->HandleFindFile( reinterpret_cast<CFoundFileMessageData*>(lParam) );
        }
        return 0;
    }

    LRESULT OnCommand( WPARAM wParam, LPARAM lParam)
    {
        if (m_pScreenSaverHandler)
        {
            m_pScreenSaverHandler->HandleOnCommand(wParam,lParam);
        }
        return 0;
    }

    LRESULT OnNotify( WPARAM wParam, LPARAM lParam )
    {
        LPNMHDR pNMHDR = (LPNMHDR) lParam;
        if(pNMHDR)
        {
        }
        return 0;
    }

    static LRESULT CALLBACK WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        CMainWindow *pThis = (CMainWindow*)GetWindowLongPtrA(hWnd,GWLP_USERDATA);
        if (WM_CREATE == uMsg) 
        { 
            pThis = new CMainWindow(hWnd); 
            SetWindowLongA(hWnd,GWLP_USERDATA,(INT_PTR)pThis); 
        } 
        else if (WM_NCDESTROY == uMsg) 
        { 
            delete pThis; 
            pThis = 0; 
            SetWindowLongA(hWnd,GWLP_USERDATA,0); 
        }
        
        switch (uMsg)
        {
            case (WM_COMMAND): 
                { 
                    if (pThis) 
                    {
                        return pThis->OnCommand( wParam, lParam ); 
                    } 
                }
                break;

            case (WM_SHOWWINDOW): 
                { 
                    if (pThis)
                    {
                        return pThis->OnShowWindow( wParam, lParam );
                    } 
                }
                break;

            case (WM_DESTROY):
                { 
                    if (pThis)
                    {
                        return pThis->OnDestroy( wParam, lParam );
                    }
                }
                break;

            case (WM_TIMER): 
                { 
                    if (pThis)
                    {
                        return pThis->OnTimer( wParam, lParam ); 
                    } 
                }
                break;

            case (WM_PAINT): 
                { 
                    if (pThis)
                    {
                        return pThis->OnPaint( wParam, lParam ); 
                    }
                }
                break;

            case (WM_SIZE): 
                { 
                    if (pThis)
                    {
                        return pThis->OnSize( wParam, lParam ); 
                    } 
                }
                break;

            case (WM_KEYDOWN): 
                { 
                    if (pThis)
                    {
                        return pThis->OnKeydown( wParam, lParam ); 
                    } 
                }
                break;

            case (WM_KEYUP): 
                { 
                    if (pThis) 
                    {
                        return pThis->OnKeyup( wParam, lParam ); 
                    } 
                }
                break;

            case (WM_CHAR): 
                { 
                    if (pThis) 
                    {
                        return pThis->OnChar( wParam, lParam ); 
                    } 
                }
                break;

            case (WM_NOTIFY): 
                { 
                    if (pThis)
                    {
                        return pThis->OnNotify( wParam, lParam ); 
                    } 
                }
                break;

            case (WM_LBUTTONDOWN): 
                { 
                    if (pThis) 
                    {
                        return pThis->OnMouseButton( wParam, lParam ); 
                    } 
                }
                break;

            case (WM_MOUSEMOVE): 
                { 
                    if (pThis)
                    {
                        return pThis->OnMouseMove( wParam, lParam ); 
                    } 
                }
                break;

            case (WM_RBUTTONDOWN): 
                { 
                    if (pThis)
                    {
                        return pThis->OnMouseButton( wParam, lParam ); 
                    }
                }
                break;

            case (UWM_FINDFILE): 
                { 
                    if (pThis) 
                    {
                        return pThis->OnFindFile( wParam, lParam ); 
                    } 
                }
                break;
            case (WM_APPCOMMAND):
                {
                    if (pThis)
                    {
                        return pThis->OnWmAppCommand( wParam, lParam );
                    }
                }
                break;
        }
        return (DefWindowProcA(hWnd,uMsg,wParam,lParam));
    }
};

typedef void (CALLBACK* lpFunc)(HWND,HINSTANCE,LPTSTR,int);
int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE prevInstance, LPSTR lpszCmdParam, int nCmdShow )
{
    try
    {
        SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX | SEM_NOGPFAULTERRORBOX);

        // see if we've already started a copy?
        CFindInstance FindInstance;
        if(FindInstance.FindInstance(MAIN_WINDOW_CLASSNAME))
        {
            return 1;
        }

        g_hInstance = hInstance;

#ifdef FEATURE_FULLSCREEN_MODE
        HWND hwndMain = CMainWindow::Create( 0, 
                                             TEXT("My Slideshow"),
                                             WS_POPUP | WS_VISIBLE,
                                             CW_USEDEFAULT,
                                             CW_USEDEFAULT,
                                             ::GetSystemMetrics(SM_CXSCREEN),
                                             ::GetSystemMetrics(SM_CYSCREEN),
                                             NULL,
                                             NULL,
                                             hInstance );
#else
        HWND hwndMain = CMainWindow::Create( 0, 
                                             TEXT("My Slideshow"),
                                             WS_OVERLAPPEDWINDOW,
                                             CW_USEDEFAULT,
                                             CW_USEDEFAULT,
                                             CW_USEDEFAULT,
                                             CW_USEDEFAULT,
                                             NULL,
                                             NULL,
                                             hInstance );
#endif
        if (hwndMain)
        {
            ShowWindow( hwndMain, nCmdShow );
            UpdateWindow( hwndMain );

            MSG msg;
            while (GetMessage(&msg, 0, 0, 0))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
       }
    }
    catch(...)
    {
    }
    return 0;
}


void DebugMsg(int i, const char* pszFormat, ...)
{
#ifdef _DEBUG
    char buf[4096];
    sprintf(buf, "[%s](0x%x): ", "sshow", GetCurrentThreadId());
	va_list arglist;
	va_start(arglist, pszFormat);
    vsprintf(&buf[strlen(buf)], pszFormat, arglist);
	va_end(arglist);
    strcat(buf, "\n");
    OutputDebugString(buf);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\cfact.h ===
class CSysTrayFactory: public IClassFactory
{
public:
    // IUnknown Implementation
    HRESULT __stdcall QueryInterface(REFIID iid, void** ppvObject);
    ULONG __stdcall AddRef(void);
    ULONG __stdcall Release(void);

    // IOleCommandTarget Implementation
    HRESULT __stdcall CreateInstance(IUnknown* pUnkOuter, REFIID iid, void** ppvObject);
    HRESULT __stdcall LockServer(BOOL fLock);

    CSysTrayFactory(BOOL fRunTrayOnConstruct);
    ~CSysTrayFactory();
private:
    // Data
    long m_cRef;
    BOOL m_fRunTrayOnConstruct;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\csc.c ===
#include "stdafx.h"
#include "systray.h"
#include <cscuiext.h>
///////////////////////////////////////////////////////////////////////////////
// CSC_CheckEnable

typedef BOOL (WINAPI* PFNCSCMSGPROCESS)(LPMSG);

static HWND g_hWndCSC = NULL;
static HMODULE g_hCSCUIDll = NULL;
static PFNCSCMSGPROCESS g_pfnMsgProcess = NULL;

BOOL CSC_CheckEnable(HWND hWnd, BOOL bSvcEnabled)
{

    if ((g_hWndCSC && IsWindow(g_hWndCSC) && !bSvcEnabled) ||
        (((!g_hWndCSC) || !IsWindow(g_hWndCSC)) && bSvcEnabled))
    
    {
        if (!g_hCSCUIDll)
            g_hCSCUIDll = LoadLibrary(TEXT("cscui.dll"));
            
        if (g_hCSCUIDll)
        {
            PFNCSCUIINITIALIZE pfn = (PFNCSCUIINITIALIZE)GetProcAddress(g_hCSCUIDll, "CSCUIInitialize");
            g_pfnMsgProcess = (PFNCSCMSGPROCESS)GetProcAddress(g_hCSCUIDll, "CSCUIMsgProcess");
            if (pfn)
            {
                DWORD dwFlags = CI_INITIALIZE | CI_CREATEWINDOW;

                if (!bSvcEnabled)
                    dwFlags = CI_TERMINATE | CI_DESTROYWINDOW;
                    
                g_hWndCSC = (*pfn)(NULL, dwFlags);
            }    
        }

        if (g_hCSCUIDll && !bSvcEnabled)
        {
            FreeLibrary(g_hCSCUIDll);
            g_hCSCUIDll = NULL;
            g_pfnMsgProcess = NULL;
        }
    }        
    return(TRUE);
}

BOOL CSC_MsgProcess(LPMSG pMsg)
{
    if (g_pfnMsgProcess)
        return (*g_pfnMsgProcess)(pMsg);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\cfact.cpp ===
#include "stdafx.h"
#include "cfact.h"
#include "stobject.h"

/************************************************************************************
IUnknown Implementation

************************************************************************************/

HRESULT CSysTrayFactory::QueryInterface(REFIID iid, void** ppvObject)
{
    HRESULT hr = S_OK;

    if ((iid == IID_IClassFactory) || (iid == IID_IUnknown))
    {
        *ppvObject = (IClassFactory*) this;
    }
    else
    {
        *ppvObject = NULL;
        hr = E_NOINTERFACE;
    }

    if (hr == S_OK)
    {
        ((IUnknown*) (*ppvObject))->AddRef();
    }

    return hr;
}

ULONG CSysTrayFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CSysTrayFactory::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    
    return m_cRef;
}

/************************************************************************************
IClassFactory Implementation

************************************************************************************/
HRESULT CSysTrayFactory::CreateInstance(IUnknown* pUnkOuter, REFIID iid, void** ppvObject)
{
    HRESULT hr = S_OK;
    
    if (pUnkOuter != NULL)
    {
        hr = CLASS_E_NOAGGREGATION;
    }
    else
    {
        CSysTray* ptray = new CSysTray(m_fRunTrayOnConstruct);

        if (ptray != NULL)
        {
            hr = ptray->QueryInterface(iid, ppvObject);
            ptray->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT CSysTrayFactory::LockServer(BOOL fLock)
{
    if (fLock) 
        InterlockedIncrement(&g_cLocks);
    else
        InterlockedDecrement(&g_cLocks);

    return S_OK;
}

/************************************************************************************
Constructor/Destructor Implementation

************************************************************************************/

CSysTrayFactory::CSysTrayFactory(BOOL fRunTrayOnConstruct)
{
    m_fRunTrayOnConstruct = fRunTrayOnConstruct;
    m_cRef = 1;
    InterlockedIncrement(&g_cLocks);
}

CSysTrayFactory::~CSysTrayFactory()
{
    InterlockedDecrement(&g_cLocks);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\access.c ===
#include "stdafx.h"
#include "systray.h"
#include "winuserp.h"
// These two lines must be commented out before checkin
//#define DBG 1
//#include "..\..\..\osshell\accessib\inc\w95trace.c"
#define DBPRINTF 1 ? (void)0 : (void)

STICKYKEYS sk;
int skIconShown = -1; // either -1 or displacement of icon
HICON skIcon;

MOUSEKEYS mk;
DWORD mkStatus;
int mkIconShown = -1; // either -1 or equivalent to mkStatus
HICON mkIcon;

FILTERKEYS fk;
HICON fkIcon;

extern HINSTANCE g_hInstance;
void StickyKeys_UpdateStatus(HWND hWnd, BOOL bShowIcon);
void StickyKeys_UpdateIcon(HWND hWnd, DWORD message);
void MouseKeys_UpdateStatus(HWND hWnd, BOOL bShowIcon);
void MouseKeys_UpdateIcon(HWND hWnd, DWORD message);
void FilterKeys_UpdateStatus(HWND hWnd, BOOL bShowIcon);
void FilterKeys_UpdateIcon(HWND hWnd, DWORD message);
void NormalizeIcon(HICON *phIcon);

extern DWORD g_uiShellHook; //shell hook window message

__inline void RegShellHook(HWND hWnd)
{
    // Only register the shell hook if it isn't yet registered
    if (!g_uiShellHook) {
        g_uiShellHook = RegisterWindowMessage(L"SHELLHOOK");
        RegisterShellHookWindow(hWnd);
        DBPRINTF(TEXT("RegShellHook\r\n"));
    }
}

__inline void UnregShellHook(HWND hWnd)
{
    // Only unregister the shell hook if neither sticky keys or mouse keys is on
    if (skIconShown == -1 && mkIconShown == -1) {
        g_uiShellHook = 0;
        DeregisterShellHookWindow(hWnd);
        DBPRINTF(TEXT("UnregShellHook\r\n"));
    }
}

BOOL StickyKeys_CheckEnable(HWND hWnd)
{
    BOOL bEnable;

    sk.cbSize = sizeof(sk);
    SystemParametersInfo(
      SPI_GETSTICKYKEYS,
      sizeof(sk),
      &sk,
      0);

    bEnable = sk.dwFlags & SKF_INDICATOR && sk.dwFlags & SKF_STICKYKEYSON;

    DBPRINTF(TEXT("StickyKeys_CheckEnable\r\n"));
    StickyKeys_UpdateStatus(hWnd, bEnable);

    return(bEnable);
}

void StickyKeys_UpdateStatus(HWND hWnd, BOOL bShowIcon) {
    if (bShowIcon != (skIconShown!= -1)) {
        if (bShowIcon) {
            StickyKeys_UpdateIcon(hWnd, NIM_ADD);
            RegShellHook(hWnd);
        } else {
            skIconShown = -1;
            UnregShellHook(hWnd);
            SysTray_NotifyIcon(hWnd, STWM_NOTIFYSTICKYKEYS, NIM_DELETE, NULL, NULL);
            if (skIcon) {
                DestroyIcon(skIcon);
                skIcon = NULL;
            }
        }
    }
    if (bShowIcon) {
        StickyKeys_UpdateIcon(hWnd, NIM_MODIFY);
    }
}

void StickyKeys_UpdateIcon(HWND hWnd, DWORD message)
{
    LPTSTR      lpsz;

    int iStickyOffset = 0;

    if (sk.dwFlags & SKF_LSHIFTLATCHED) iStickyOffset |= 1;
    if (sk.dwFlags & SKF_RSHIFTLATCHED) iStickyOffset |= 1;
    if (sk.dwFlags & SKF_LSHIFTLOCKED) iStickyOffset |= 1;
    if (sk.dwFlags & SKF_RSHIFTLOCKED) iStickyOffset |= 1;

    if (sk.dwFlags & SKF_LCTLLATCHED) iStickyOffset |= 2;
    if (sk.dwFlags & SKF_RCTLLATCHED) iStickyOffset |= 2;
    if (sk.dwFlags & SKF_LCTLLOCKED) iStickyOffset |= 2;
    if (sk.dwFlags & SKF_RCTLLOCKED) iStickyOffset |= 2;

    if (sk.dwFlags & SKF_LALTLATCHED) iStickyOffset |= 4;
    if (sk.dwFlags & SKF_RALTLATCHED) iStickyOffset |= 4;
    if (sk.dwFlags & SKF_LALTLOCKED) iStickyOffset |= 4;
    if (sk.dwFlags & SKF_RALTLOCKED) iStickyOffset |= 4;

    if (sk.dwFlags & SKF_LWINLATCHED) iStickyOffset |= 8;
    if (sk.dwFlags & SKF_RWINLATCHED) iStickyOffset |= 8;
    if (sk.dwFlags & SKF_LWINLOCKED) iStickyOffset |= 8;
    if (sk.dwFlags & SKF_RWINLOCKED) iStickyOffset |= 8;

    if ((!skIcon) || (iStickyOffset != skIconShown)) {
        if (skIcon) DestroyIcon(skIcon);
        skIcon = LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_STK000 + iStickyOffset),
                                        IMAGE_ICON, 16, 16, 0);
        skIconShown = iStickyOffset;
    }
    lpsz    = LoadDynamicString(IDS_STICKYKEYS);
    if (skIcon)
    {
        NormalizeIcon(&skIcon);
        SysTray_NotifyIcon(hWnd, STWM_NOTIFYSTICKYKEYS, message, skIcon, lpsz);
    }
    DeleteDynamicString(lpsz);
}

void StickyKeys_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    switch (lParam)
    {
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
        WinExec("rundll32.exe Shell32.dll,Control_RunDLL access.cpl,,1",SW_SHOW);
        break;
    }
}

BOOL MouseKeys_CheckEnable(HWND hWnd)
{
    BOOL bEnable;

    mk.cbSize = sizeof(mk);
    SystemParametersInfo(
      SPI_GETMOUSEKEYS,
      sizeof(mk),
      &mk,
      0);

    bEnable = mk.dwFlags & MKF_INDICATOR && mk.dwFlags & MKF_MOUSEKEYSON;

    DBPRINTF(TEXT("MouseKeys_CheckEnable\r\n"));
    MouseKeys_UpdateStatus(hWnd, bEnable);

    return(bEnable);
}

void MouseKeys_UpdateStatus(HWND hWnd, BOOL bShowIcon) {
    if (bShowIcon != (mkIconShown!= -1)) {
        if (bShowIcon) {
            MouseKeys_UpdateIcon(hWnd, NIM_ADD);
            RegShellHook(hWnd);
        } else {
            mkIconShown = -1;
            UnregShellHook(hWnd);
            SysTray_NotifyIcon(hWnd, STWM_NOTIFYMOUSEKEYS, NIM_DELETE, NULL, NULL);
            if (mkIcon) {
                DestroyIcon(mkIcon);
                mkIcon = NULL;
            }
        }
    }
    if (bShowIcon) {
        MouseKeys_UpdateIcon(hWnd, NIM_MODIFY);
    }
}

int MouseIcon[] = {
        IDI_MKPASS,           // 00 00  no buttons selected
        IDI_MKGT,             // 00 01  left selected, up
        IDI_MKTG,             // 00 10  right selected, up
        IDI_MKGG,             // 00 11  both selected, up
        IDI_MKPASS,           // 01 00  no buttons selected
        IDI_MKBT,             // 01 01  left selected, and down
        IDI_MKTG,             // 01 10  right selected, up
        IDI_MKBG,             // 01 11  both selected, left down, right up
        IDI_MKPASS,           // 10 00  no buttons selected
        IDI_MKGT,             // 10 01  left selected, right down
        IDI_MKTB,             // 10 10  right selected, down
        IDI_MKGB,             // 10 11  both selected, right down
        IDI_MKPASS,           // 11 00  no buttons selected
        IDI_MKBT,             // 11 01  left selected, down
        IDI_MKTB,             // 11 10  right selected, down
        IDI_MKBB};            // 11 11  both selected, down

void MouseKeys_UpdateIcon(HWND hWnd, DWORD message)
{
    LPTSTR      lpsz;
    int iMouseIcon = 0;

    if (!(mk.dwFlags & MKF_MOUSEMODE)) iMouseIcon = IDI_MKPASS;
    else {
        /*
         * Set up iMouseIcon as an index into the table first
         */

        if (mk.dwFlags & MKF_LEFTBUTTONSEL) iMouseIcon |= 1;
        if (mk.dwFlags & MKF_RIGHTBUTTONSEL) iMouseIcon |= 2;
        if (mk.dwFlags & MKF_LEFTBUTTONDOWN) iMouseIcon |= 4;
        if (mk.dwFlags & MKF_RIGHTBUTTONDOWN) iMouseIcon |= 8;
        iMouseIcon = MouseIcon[iMouseIcon];
    }

    if ((!mkIcon) || (iMouseIcon != mkIconShown)) {
        if (mkIcon) DestroyIcon(mkIcon);
        mkIcon = LoadImage(g_hInstance, MAKEINTRESOURCE(iMouseIcon),
                                        IMAGE_ICON, 16, 16, 0);
        mkIconShown = iMouseIcon;
    }
    lpsz    = LoadDynamicString(IDS_MOUSEKEYS);
    if (mkIcon)
    {
        NormalizeIcon(&mkIcon);
        SysTray_NotifyIcon(hWnd, STWM_NOTIFYMOUSEKEYS, message, mkIcon, lpsz);
    }
    DeleteDynamicString(lpsz);
}

void MouseKeys_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    switch (lParam)
    {
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
        WinExec("rundll32.exe Shell32.dll,Control_RunDLL access.cpl,,4",SW_SHOW);
        break;
    }
}


BOOL FilterKeys_CheckEnable(HWND hWnd)
{
    BOOL bEnable;

    fk.cbSize = sizeof(fk);
    SystemParametersInfo(
      SPI_GETFILTERKEYS,
      sizeof(fk),
      &fk,
      0);

    bEnable = fk.dwFlags & FKF_INDICATOR && fk.dwFlags & FKF_FILTERKEYSON;

    DBPRINTF(TEXT("FilterKeys_CheckEnable\r\n"));
    FilterKeys_UpdateStatus(hWnd, bEnable);

    return(bEnable);
}

void FilterKeys_UpdateStatus(HWND hWnd, BOOL bShowIcon) {
    if (bShowIcon != (fkIcon!= NULL)) {
        if (bShowIcon) {
            FilterKeys_UpdateIcon(hWnd, NIM_ADD);
        } else {
            SysTray_NotifyIcon(hWnd, STWM_NOTIFYFILTERKEYS, NIM_DELETE, NULL, NULL);
            if (fkIcon) {
                DestroyIcon(fkIcon);
                fkIcon = NULL;
            }
        }
    }
}

void FilterKeys_UpdateIcon(HWND hWnd, DWORD message)
{
    LPTSTR      lpsz;

    if (!fkIcon) {
        fkIcon = LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_FILTER),
                                        IMAGE_ICON, 16, 16, 0);
    }
    lpsz    = LoadDynamicString(IDS_FILTERKEYS);
    if (fkIcon)
    {
        NormalizeIcon(&fkIcon);
        SysTray_NotifyIcon(hWnd, STWM_NOTIFYFILTERKEYS, message, fkIcon, lpsz);
    }
    DeleteDynamicString(lpsz);
}

void FilterKeys_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    switch (lParam)
    {
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
        WinExec("rundll32.exe Shell32.dll,Control_RunDLL access.cpl,,1",SW_SHOW);
        break;
    }
}

//
// This function takes the resource icon and changes the dark blue
// pixels to the window text color (black in normal mode or white
// in high contrast).
//
// If any part of the conversion fails, the normal icon is unchanged.
// If the conversion is successful, the normal icon is destroyed and
// replaced with the converted one.
//
void NormalizeIcon(HICON *phIcon)
{
	BITMAP BmpInfo;
	ICONINFO IconInfo;
	HBITMAP hCopyBmp = NULL;
	HDC hdcCopyBmp = NULL;
	HDC hdcIconBmp = NULL;
	ICONINFO ic;
	HICON hNewIcon = NULL;
	int i, j;
	COLORREF clr = GetSysColor(COLOR_WINDOWTEXT);
    HGDIOBJ hObjTmp1, hObjTmp2;

	if (!GetIconInfo(*phIcon, &IconInfo))
    {
        DBPRINTF(TEXT("GetIconInfo failed\r\n"));
        goto Cleanup;
    }
    if (!GetObject(IconInfo.hbmColor, sizeof(BITMAP), &BmpInfo ))
    {
        DBPRINTF(TEXT("GetObject failed\r\n"));
        goto Cleanup;
    }

	hCopyBmp = CreateBitmap(BmpInfo.bmWidth,
							BmpInfo.bmHeight,
							BmpInfo.bmPlanes,			// Planes
							BmpInfo.bmBitsPixel,		// BitsPerPel
							NULL);						// bits
    if (!hCopyBmp)
    {
        DBPRINTF(TEXT("CreateBitmap failed\r\n"));
        goto Cleanup;
    }

	hdcCopyBmp = CreateCompatibleDC(NULL);
	if (!hdcCopyBmp)
    {
		DBPRINTF(TEXT("CreateCompatibleDC 1 failed\r\n"));
        goto Cleanup;
    }
	hObjTmp1 = SelectObject(hdcCopyBmp, hCopyBmp);

	// Select Icon bitmap into a memoryDC so we can use it
	hdcIconBmp = CreateCompatibleDC(NULL);
	if (!hdcIconBmp)
    {
		DBPRINTF(TEXT("CreateCompatibleDC 2 failed\r\n"));
	    SelectObject(hdcCopyBmp, hObjTmp1); // restore original bitmap
        goto Cleanup;
    }
	hObjTmp2 = SelectObject(hdcIconBmp, IconInfo.hbmColor);

	BitBlt(	hdcCopyBmp, 
			0,  
			0,  
			BmpInfo.bmWidth,  
			BmpInfo.bmHeight, 
			hdcIconBmp,  
			0,   
			0,   
			SRCCOPY  
			);

	ic.fIcon = TRUE;				// This is an icon
	ic.xHotspot = 0;
	ic.yHotspot = 0;
	ic.hbmMask = IconInfo.hbmMask;
			
	for (i=0; i < BmpInfo.bmWidth; i++)
		for (j=0; j < BmpInfo.bmHeight; j++)
		{
			COLORREF pel_value = GetPixel(hdcCopyBmp, i, j);
			if (pel_value == (COLORREF) RGB(0,0,128)) // The color on icon resource is BLUE!!
				SetPixel(hdcCopyBmp, i, j, clr);	// Window-Text icon
		}

	ic.hbmColor = hCopyBmp;

	hNewIcon = CreateIconIndirect(&ic);
    if (hNewIcon)
    {
        DestroyIcon(*phIcon);
        *phIcon = hNewIcon;

	    SelectObject(hdcIconBmp, hObjTmp2);  // restore original bitmap
    }

Cleanup:
    if (hdcIconBmp)
	    DeleteDC(hdcIconBmp);
    if (hdcCopyBmp)
	    DeleteDC(hdcCopyBmp);
    if (hCopyBmp)
        DeleteObject(hCopyBmp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\dll.cpp ===
#include "stdafx.h"
#include <initguid.h>
#include "stobject.h"
#include "cfact.h"
#define DECL_CRTFREE
#include <crtfree.h>

// One lock for each running component + one lock per LockServer call
long g_cLocks = 0;
HINSTANCE g_hinstDll = NULL;
const TCHAR g_szThreadModel[] = TEXT("Both");

STDAPI DllCanUnloadNow()
{
    return (g_cLocks == 0);
}

STDAPI DllGetClassObject(const CLSID& clsid, const IID& iid, void** ppvObject)
{
    HRESULT hr = S_OK;
    BOOL fRunTrayOnConstruct;
    *ppvObject = NULL;

    if (clsid == CLSID_SysTray)
    {
        // The SysTray object is being requested - we don't actually launch the tray thread until
        // told to do so though IOleCommandTarget
        fRunTrayOnConstruct = FALSE;
    }
    else if (clsid == CLSID_SysTrayInvoker)
    {
        // The simple invoker object is being requested - the tray thread will be launched immediately
        fRunTrayOnConstruct = TRUE;
    }
    else
    {
        // We don't support this object!
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    // If one of the two objects we support was requested:
    if (SUCCEEDED(hr))
    {
        // Try to create the object
        CSysTrayFactory* ptrayfact = new CSysTrayFactory(fRunTrayOnConstruct);

        if (ptrayfact != NULL)
        {
            hr = ptrayfact->QueryInterface(iid, ppvObject);
            ptrayfact->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


BOOL RegisterComponent(const CLSID& clsid, const TCHAR* szProgID)
{
    // Build a CLSID string for the registry
    BOOL fSuccess = FALSE;
    TCHAR szSubkey[MAX_PATH];
    TCHAR szCLSID[GUIDSTR_MAX];
    TCHAR szModule[MAX_PATH];
    HKEY hkeyCLSID = NULL;
    HKEY hkeyInproc = NULL;
    DWORD dwDisp;
    TCHAR* pszNameOnly;

    // Try and get all the strings we need
    if (StringFromGUID2(clsid, szCLSID, ARRAYSIZE(szCLSID)) != 0)
    {
        if ((GetModuleFileName(g_hinstDll, szModule, ARRAYSIZE(szModule)) != 0) &&
            (pszNameOnly = PathFindFileName(szModule)))
        {
            if (wnsprintf(szSubkey, ARRAYSIZE(szSubkey), TEXT("CLSID\\%s"), szCLSID) > 0)
            {
                // We've built our strings, so write stuff to the registry
                if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, szSubkey, 0, 
                    NULL, 0, KEY_WRITE, NULL, &hkeyCLSID, &dwDisp))
                {

                    RegSetValueEx(hkeyCLSID, NULL, 0, REG_SZ, (const BYTE*) szProgID, 
                        (lstrlen(szProgID) + 1) * sizeof(TCHAR));

                    if (ERROR_SUCCESS == RegCreateKeyEx(hkeyCLSID, TEXT("InprocServer32"), 
                        0, NULL, 0, KEY_SET_VALUE, NULL, &hkeyInproc, &dwDisp))
                    {

                        RegSetValueEx(hkeyInproc, NULL, 0, REG_SZ, 
                            (const BYTE*) szModule, (lstrlen(szModule) + 1) * sizeof(TCHAR));
                        RegSetValueEx(hkeyInproc, TEXT("ThreadingModel"), 0, REG_SZ, 
                            (const BYTE*) g_szThreadModel, sizeof(g_szThreadModel));
                        fSuccess = TRUE;
                    }
                }
            }
        }
    }

    if (hkeyCLSID != NULL)
        RegCloseKey(hkeyCLSID);

    if (hkeyInproc != NULL)
        RegCloseKey(hkeyInproc);

    return fSuccess;
}

BOOL UnregisterComponent(const CLSID& clsid)
{
    // Build a CLSID string for the registry
    BOOL fSuccess = FALSE;
    TCHAR szSubkey[MAX_PATH];
    TCHAR szCLSID[GUIDSTR_MAX];
    HKEY hkeyCLSID = NULL;

    // Try and get all the strings we need
    if (StringFromGUID2(clsid, szCLSID, ARRAYSIZE(szCLSID)) != 0)
    {
        if (wnsprintf(szSubkey, ARRAYSIZE(szSubkey), TEXT("CLSID\\%s"), szCLSID) > 0)
        {        
            // We've built our strings, so delete our registry stuff
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szSubkey, 0, 
                KEY_WRITE, &hkeyCLSID))
            {
                RegDeleteKey(hkeyCLSID, TEXT("InprocServer32"));
                RegCloseKey(hkeyCLSID);
                hkeyCLSID = NULL;

                RegDeleteKey(HKEY_CLASSES_ROOT, szSubkey);
                fSuccess = TRUE;
            }
        }
    }
    if (hkeyCLSID != NULL)
        RegCloseKey(hkeyCLSID);
    
    return fSuccess;
}

BOOL RegisterShellServiceObject(const CLSID& clsid, const TCHAR* szProgID, BOOL fRegister)
{
    const static TCHAR szSubkey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad");
    BOOL fSuccess = FALSE;
    TCHAR szCLSID[GUIDSTR_MAX];
    HKEY hkey = NULL;

    // Try and get all the strings we need
    if (StringFromGUID2(clsid, szCLSID, ARRAYSIZE(szCLSID)) != 0)
    {

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSubkey, 0, 
            KEY_WRITE, &hkey))
        {
            if (fRegister)
            {
                fSuccess = RegSetValueEx(hkey, szProgID, 0, REG_SZ, (const BYTE*) szCLSID,
                    (lstrlen(szCLSID) + 1) * sizeof(TCHAR));
            }
            else
            {
                fSuccess = RegDeleteValue(hkey, szProgID);
            }
        }
    }

    if (hkey != NULL)
        RegCloseKey(hkey);
    
    return fSuccess;    
}

STDAPI DllRegisterServer()
{
    BOOL fSuccess;
    fSuccess = RegisterComponent(CLSID_SysTray, TEXT("SysTray"));
    fSuccess &= RegisterComponent(CLSID_SysTrayInvoker, TEXT("SysTrayInvoker"));
    fSuccess &= RegisterShellServiceObject(CLSID_SysTray, TEXT("SysTray"), TRUE);
    return fSuccess;
}

STDAPI DllUnregisterServer()
{
    BOOL fSuccess;
    fSuccess = UnregisterComponent(CLSID_SysTray);
    fSuccess &= UnregisterComponent(CLSID_SysTrayInvoker);
    fSuccess &= RegisterShellServiceObject(CLSID_SysTray, TEXT("SysTray"), FALSE);
    return fSuccess;
}

STDAPI DllMain(HINSTANCE hModule, DWORD dwReason, void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        SHFusionInitializeFromModule(hModule);
        // Don't have DllMain called for thread init's.
        DisableThreadLibraryCalls(hModule);
        g_hinstDll = hModule;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        SHFusionUninitialize();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\pccrdapi.h ===
#ifndef _INC_PCCRDAPI
#define _INC_PCCRDAPI


#ifndef PCCARD_DEVICE_ID
#define PCCARD_DEVICE_ID    0x097C
#endif

//
//  32-bit IOCTL APIs
//
#define PCCARD_IOCTL_GET_VERSION	0
//
//  Output buffer contains array of devnodes for all sockets
//
#define PCCARD_IOCTL_GET_DEVNODES	1
//
//  Input:  Devnode handle
//  Output: String description of device
//
#define PCCARD_IOCTL_GET_DESCRIPTION	2


//
//  16-Bit APIs
//
//  ENTRY:
//	  AX = 0000h - Get Version Information
//  EXIT:
//	  AX = Version number
//	  Carry clear
#define PCCARD_API_GET_VERSION		0x0000


//  ENTRY:
//	  AX = 100h - Get Devnodes for Sockets
//	  CX = user buffer length in bytes
//	  ES:BX = pointer to user buffer
//  EXIT:
//	  CX = number of logical sockets in system
//	  Carry set if error
//	  Carry clear, user buffer is filled in with devnodes for sockets
//
#define PCCARD_API_GET_DEVNODES 	0x0100

#endif // _INC_PCCRDAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\pccard.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:	PCCARD.C
*
*  VERSION:     1.0
*
*  AUTHOR:	RAL
*
*  DATE:	11/01/94
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  Nov. 11, 94 RAL Original
*  Oct  23, 95 Shawnb UNICODE enabled
*
*******************************************************************************/

#include "stdafx.h"
#include "systray.h"

#define PCMCIAMENU_PROPERTIES	100
#define PCMCIAMENU_DISABLE		101

#define PCMCIAMENU_SOCKET		200

extern HANDLE g_hPCCARD;
extern HINSTANCE g_hInstance;

static BOOL		g_bPCMCIAEnabled = FALSE;
static BOOL		g_bPCMCIAIconShown = FALSE;
static HICON	g_hPCMCIAIcon = NULL;


#define MAX_DEVNODES 20

static DWORD	g_aDevnodes[MAX_DEVNODES];
static BYTE		g_aSktState[MAX_DEVNODES] = {0};
static UINT		g_numskts = 0;
static DWORD	g_PCMCIAFlags = 0;
static       TCHAR g_szDevNodeKeyFmt[] = REGSTR_PATH_DYNA_ENUM TEXT ("\\%X");
static const TCHAR g_szEnumKeyPrefix[] = REGSTR_PATH_ENUM TEXT ("\\");
static const TCHAR g_szPCMCIAFlags[]   = REGSTR_VAL_SYSTRAYPCCARDFLAGS;
static const TCHAR g_szClass[]         = REGSTR_VAL_CLASS;
static const TCHAR g_szModemClass[]    = REGSTR_KEY_MODEM_CLASS;
#if NOTYET
static const TCHAR g_szDiskDriveClass[] = REGSTR_KEY_DISKDRIVE_CLASS;
#endif

#define SKTSTATE_GOODEJECT	1
#define SKTSTATE_SHOULDWARN	2
#define SKTSTATE_TYPEKNOWN	4


HKEY OpenDevnodeDynKey(DWORD dwDevnode)
{
	TCHAR	szScratch[MAX_PATH];
	HKEY	hkDyn = NULL;

	wsprintf(szScratch, g_szDevNodeKeyFmt, dwDevnode);
	if (RegOpenKey(HKEY_DYN_DATA, szScratch, &hkDyn) != ERROR_SUCCESS) {
		return(NULL);
	}
	return hkDyn;
}


UINT GetDynInfo(DWORD dwDevNode, LPCTSTR lpszValName,
                LPVOID lpBuffer, UINT cbBuffer)
{
	UINT cbSize = 0;
	HKEY hkDyn = OpenDevnodeDynKey(dwDevNode);

	if (hkDyn) {
		if (RegQueryValueEx(hkDyn, lpszValName, NULL, NULL,
						    lpBuffer, &cbBuffer) == ERROR_SUCCESS) {
			cbSize = cbBuffer;
		}
  
		RegCloseKey(hkDyn);
	}
	return(cbSize);
}


HKEY OpenDevnodeHwKey(DWORD dwDevnode)
{
	TCHAR	szScratch[MAX_PATH];
	HKEY    hkDyn, hkHw = NULL;
	UINT    cbSize;
	UINT    cchOffset;

	if ((hkDyn = OpenDevnodeDynKey(dwDevnode)) == NULL) {
		return(NULL);
	}
	lstrcpy(szScratch, g_szEnumKeyPrefix);

	cbSize = sizeof(szScratch) - sizeof(g_szEnumKeyPrefix);
	cchOffset = ARRAYSIZE(g_szEnumKeyPrefix) - 1;

	if (RegQueryValueEx(hkDyn, REGSTR_VAL_HARDWARE_KEY,
						NULL, NULL, (LPSTR)&(szScratch[cchOffset]),
						&cbSize) == ERROR_SUCCESS) {
		if (RegOpenKey(HKEY_LOCAL_MACHINE, szScratch, &hkHw) != ERROR_SUCCESS) {
			hkHw = NULL;
		}
	}
	RegCloseKey(hkDyn);
	return(hkHw);
}


UINT GetHwInfo(DWORD dwDevNode, LPCTSTR lpszValName,
               LPVOID lpBuffer, UINT cbBuffer)
{
	UINT cbSize = 0;
	HKEY hkHw = OpenDevnodeHwKey(dwDevNode);

	if (hkHw) {
		if (RegQueryValueEx(hkHw, lpszValName, NULL, NULL,
						    lpBuffer, &cbBuffer) == ERROR_SUCCESS) {
			cbSize = cbBuffer;
		}
		RegCloseKey(hkHw);
	}
	return(cbSize);
}


void UpdateSktTypes()
{
	UINT i;
	TCHAR szClassName[32];

	for (i = 0; i < g_numskts; i++) {
		if (g_aSktState[i] == 0 && g_aDevnodes[i] != 0) {
			if (GetHwInfo(g_aDevnodes[i], g_szClass,
						  szClassName, sizeof(szClassName))) {
				g_aSktState[i] |= SKTSTATE_TYPEKNOWN;
				if (lstrcmpi(g_szModemClass, szClassName) != 0) {
					g_aSktState[i] |= SKTSTATE_SHOULDWARN;
				}
			}
		}
	}
}


void UpdateSocketInfo()
{
	UINT cbReturned;
	if (DeviceIoControl(g_hPCCARD, PCCARD_IOCTL_GET_DEVNODES,
					    NULL, 0,
						g_aDevnodes, sizeof(g_aDevnodes), &cbReturned, NULL)) {
		g_numskts = cbReturned / 4;
	} else {
		g_numskts = 0;
	}
	UpdateSktTypes();
}



void UpdateGlobalFlags()
{
	HKEY hk;
	if (RegOpenKey(HKEY_CURRENT_USER, REGSTR_PATH_SYSTRAY, &hk) ==
		 ERROR_SUCCESS) {
		UINT cb = sizeof(g_PCMCIAFlags);
		if (RegQueryValueEx(hk, g_szPCMCIAFlags, NULL, NULL,
				            (LPSTR)(&g_PCMCIAFlags), &cb) != ERROR_SUCCESS) {
			g_PCMCIAFlags = 0;
		}

		RegCloseKey(hk);
	}
}


BOOL PCMCIA_Init(HWND hWnd)
{
	if (g_hPCCARD == INVALID_HANDLE_VALUE) {
		g_hPCCARD = CreateFile(TEXT ("\\\\.\\PCCARD"), GENERIC_READ | GENERIC_WRITE,
							   FILE_SHARE_READ | FILE_SHARE_WRITE,
							   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		UpdateGlobalFlags();
	}

	return(g_hPCCARD != INVALID_HANDLE_VALUE);
}




//
//  NOTE:  This function expects the caller to have called UpdateSocketInfo
//	   prior to calling it.
//
void PCMCIA_UpdateStatus(HWND hWnd, BOOL bShowIcon, DWORD dnRemove)
{
	if (bShowIcon) {
		UINT  i;
		bShowIcon = FALSE;	// Assume no devnodes
		for (i = 0; i < g_numskts; i++) {
			if (g_aDevnodes[i] != 0 && g_aDevnodes[i] != dnRemove) {
				bShowIcon = TRUE;
				break;
			}
		}
	}

	if (bShowIcon != g_bPCMCIAIconShown) {
		g_bPCMCIAIconShown = bShowIcon;
		if (bShowIcon) {
			LPTSTR pStr = LoadDynamicString(IDS_PCMCIATIP);
			g_hPCMCIAIcon = LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_PCMCIA),
									 IMAGE_ICON, 16, 16, 0);
			SysTray_NotifyIcon(hWnd, STWM_NOTIFYPCMCIA, NIM_ADD,
							   g_hPCMCIAIcon, pStr);
			DeleteDynamicString(pStr);
		} else {
			SysTray_NotifyIcon(hWnd, STWM_NOTIFYPCMCIA, NIM_DELETE, NULL, NULL);
			if (g_hPCMCIAIcon) {
				DestroyIcon(g_hPCMCIAIcon);
			}
		}
	}
}


#define DEVNODE_NOT_IN_LIST -1

int FindSocketIndex(DWORD dn)
{
	int i;
	for (i = 0; i < (int)g_numskts; i++) {
		if (g_aDevnodes[i] == dn) {
			return(i);
		}
	}
	return(DEVNODE_NOT_IN_LIST);
}



void PCMCIA_DeviceChange(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
	int i;

	#define lpdbd ((PDEV_BROADCAST_DEVNODE)lParam)
	#define DN_STARTED  0x00000008          // WARNING KEEP THIS IN SYNC WITH CONFIGMG.H

	if ((wParam != DBT_DEVICEREMOVEPENDING &&
		wParam != DBT_DEVICEARRIVAL &&
		wParam != DBT_DEVICEREMOVECOMPLETE) ||
		lpdbd->dbcd_devicetype != DBT_DEVTYP_DEVNODE) {
		return;
	}

	switch (wParam) {
	case DBT_DEVICEREMOVEPENDING:    // Query remove succeeded
		i = FindSocketIndex(lpdbd->dbcd_devnode);
		if (i != DEVNODE_NOT_IN_LIST) {
			g_aSktState[i] |= SKTSTATE_GOODEJECT;
		}
		break;

	case DBT_DEVICEARRIVAL:
		UpdateSocketInfo();
		i = FindSocketIndex(lpdbd->dbcd_devnode);
		if (i != DEVNODE_NOT_IN_LIST) {
			g_aSktState[i] = 0;
			UpdateSktTypes();
			PCMCIA_UpdateStatus(hDlg, TRUE, 0);
		}
		break;

	case DBT_DEVICEREMOVECOMPLETE:
	{
		ULONG	Status = 0L;
		ULONG	Size = sizeof(ULONG);
		TCHAR	szDevNode[REGSTR_MAX_VALUE_LENGTH];
		HKEY	hkDevDyna;
       
		wsprintf(szDevNode, TEXT ("%s\\%8X"),REGSTR_PATH_DYNA_ENUM,lpdbd->dbcd_devnode);
		if (RegOpenKey( HKEY_DYN_DATA,
						 szDevNode,
						 &hkDevDyna ) == ERROR_SUCCESS) 
		{
			RegQueryValueEx( hkDevDyna, REGSTR_VAL_STATUS, 0, NULL, (LPSTR)&Status, &Size );
			RegCloseKey(hkDevDyna);
		}
         
		if (Status & DN_STARTED) 
		{
			i = FindSocketIndex(lpdbd->dbcd_devnode);
			if (i != DEVNODE_NOT_IN_LIST) {
				//
				//  Check to see if we're supposed to warn the user about this
				//  eject.  Only warn if NOT good eject and class is one we warn
				//  about.
				//
				BOOL fWarnUser = (g_aSktState[i] &
								 (SKTSTATE_SHOULDWARN | SKTSTATE_GOODEJECT)) ==
								 SKTSTATE_SHOULDWARN;
				g_aSktState[i] = 0;
				UpdateSocketInfo();
				PCMCIA_UpdateStatus(hDlg, TRUE, lpdbd->dbcd_devnode);
				if (fWarnUser) {
					// Make sure the user did not turn this off earlier
					UpdateGlobalFlags();
					if (!(g_PCMCIAFlags & PCMCIA_REGFLAG_NOWARN)) {
						const TCHAR szOpen[]	= TEXT ("open");
						const TCHAR szRunDLL[]	= TEXT ("RUNDLL32.EXE");
						const TCHAR szParams[]	= TEXT ("RUNDLL mspcic.dll,EjectWarningDlg");
                 
						ShellExecute(NULL, szOpen, szRunDLL, 
								     szParams, NULL, SW_SHOW);
					}
				}
			}	                
		}
		break;
	}        
	}
#undef lpdbd
}



//
//  Called at init time and whenever services are enabled/disabled.
//  Returns false if PCMCIA services are not active.
//
BOOL PCMCIA_CheckEnable(HWND hWnd, BOOL bSvcEnabled)
{
	BOOL bEnable = bSvcEnabled && PCMCIA_Init(hWnd);

	if (bEnable != g_bPCMCIAEnabled) {
		g_bPCMCIAEnabled = bEnable;
		UpdateSocketInfo();
		PCMCIA_UpdateStatus(hWnd, bEnable, 0);
		if (!bEnable) {
			CloseIfOpen(&g_hPCCARD);
		}
	}

   return(bEnable);
}


/*----------------------------------------------------------------------------
 * PCMCIA_CreateMenu()
 *
 * build a menu containing all sockets.
 *
 *----------------------------------------------------------------------------*/

//static CRITICAL_SECTION csMenu;
static HMENU _hMenu[2] = {0};

HMENU PCMCIA_CreateMenu(LONG l)
{
	//EnterCriticalSection(&csMenu);

	if (l > 0) {
		if (_hMenu[1] == NULL) {
			HMENU  hmenu = _hMenu[l] = CreatePopupMenu();
			LPTSTR lpszMenu;

			if ((lpszMenu = LoadDynamicString(IDS_PCCARDMENU1)) != NULL) {
				AppendMenu(hmenu,MF_STRING,PCMCIAMENU_PROPERTIES,lpszMenu);
				DeleteDynamicString(lpszMenu);
			}
     
			if ((lpszMenu = LoadDynamicString(IDS_PCCARDMENU2)) != NULL) {
				AppendMenu(hmenu,MF_STRING,PCMCIAMENU_DISABLE,lpszMenu);
				DeleteDynamicString(lpszMenu);
			}
		  
			SetMenuDefaultItem(hmenu,PCMCIAMENU_PROPERTIES,FALSE);
		}
	} else {
		HMENU hMenu;

		if (_hMenu[0]) {
			DestroyMenu(_hMenu[0]);
		}

		hMenu = _hMenu[0] = CreatePopupMenu();

		if (g_hPCCARD != INVALID_HANDLE_VALUE) {
			TCHAR    szDesc[80];
			LPTSTR   lpszMenuText;
			UINT     i;

			UpdateSocketInfo();
			for (i = 0; i < g_numskts; i++) {
				if (g_aDevnodes[i] &&
				    GetHwInfo(g_aDevnodes[i], REGSTR_VAL_DEVDESC, szDesc, sizeof(szDesc))) {
#if NOTYET
					DWORD   dwChild;
					TCHAR   szClassName[32];
					TCHAR   szDriveLetters[32];

					if (GetDynInfo(g_aDevnodes[i], REGSTR_VAL_CHILD,
						           &dwChild, sizeof(dwChild)) &&
					    GetHwInfo(dwChild, g_szClass,
							      szClassName, sizeof(szClassName)) &&
						lstrcmpi(g_szDiskDriveClass, szClassName) == 0 &&
						GetHwInfo(dwChild, REGSTR_VAL_CURDRVLET,
							      szDriveLetters, sizeof(szDriveLetters)) &&
						lstrlen(szDriveLetters) > 0) {
						lpszMenuText = LoadDynamicString(IDS_EJECTFMTDISKDRIVE,
												         szDesc, szDriveLetters[0]);
					} 
					else
#endif
					{
						lpszMenuText = LoadDynamicString(IDS_EJECTFMT, szDesc);
					}

					if (lpszMenuText) {
						AppendMenu(hMenu,MF_STRING,PCMCIAMENU_SOCKET+i,lpszMenuText);
						DeleteDynamicString(lpszMenuText);
					}
				}
			}
		}
	}

	//LeaveCriticalSection(&csMenu);

	return _hMenu[l];
}


void PCMCIA_Menu(HWND hwnd, UINT uMenuNum, UINT uButton)
{
	POINT pt;
	UINT iCmd;

	SetForegroundWindow(hwnd);
	GetCursorPos(&pt);
	iCmd = TrackPopupMenu(PCMCIA_CreateMenu(uMenuNum), uButton | TPM_RETURNCMD | TPM_NONOTIFY,
						  pt.x, pt.y, 0, hwnd, NULL);
	if (iCmd >= PCMCIAMENU_SOCKET) {
		const TCHAR szOpen[]	= TEXT ("open");
		const TCHAR szRunDLL[]	= TEXT ("RUNDLL32.EXE");
		LPTSTR lpszCommand		= LoadDynamicString(IDS_RUNEJECT, iCmd-PCMCIAMENU_SOCKET);
		if (lpszCommand == NULL)
			return;
   
		ShellExecute(NULL, szOpen, szRunDLL,
					 lpszCommand, NULL, SW_SHOW);
   
		DeleteDynamicString(lpszCommand);
	} else {
		switch (iCmd) {
		case PCMCIAMENU_PROPERTIES:
			SysTray_RunProperties(IDS_RUNPCMCIAPROPERTIES);
			break;

		case PCMCIAMENU_DISABLE:
			PostMessage(hwnd, STWM_ENABLESERVICE, STSERVICE_PCMCIA, FALSE);
			break;
		}
	}
}


void PCMCIA_Notify(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	switch (lParam) 
	{
		case WM_RBUTTONUP:
			PCMCIA_Menu(hwnd, 1, TPM_RIGHTBUTTON);
			break;

		case WM_LBUTTONDOWN:
			SetTimer(hwnd, PCMCIA_TIMER_ID, GetDoubleClickTime()+100, NULL);
			break;

		case WM_LBUTTONDBLCLK:
			KillTimer(hwnd, PCMCIA_TIMER_ID);
			SysTray_RunProperties(IDS_RUNPCMCIAPROPERTIES);
			break;
	}
}


void PCMCIA_Timer(HWND hwnd)
{
	KillTimer(hwnd, PCMCIA_TIMER_ID);
	PCMCIA_Menu(hwnd, 0, TPM_LEFTBUTTON);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\hplug.c ===
/*
 *  Copyright (c) 1992-1997 Microsoft Corporation
 *  hotplug routines
 *
 *  09-May-1997 Jonle , created
 *
 */

#include "stdafx.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "systray.h"
#include <setupapi.h>
#include <cfgmgr32.h>
#include <dbt.h>
#include <initguid.h>
#include <devguid.h>
#include <ks.h>
#include <ksmedia.h>
#include <ntddstor.h>


//
// Support system sounds for device events.
//
#define SOUNDS 1

#if SOUNDS

BOOL
HotplugPlaySoundThisSession(
    VOID
    );

//
// Hardware application sound event names.
//
#define DEVICE_ARRIVAL_SOUND            TEXT("DeviceConnect")
#define DEVICE_REMOVAL_SOUND            TEXT("DeviceDisconnect")
#define DEVICE_FAILURE_SOUND            TEXT("DeviceFail")

#endif // SOUNDS


//
// Simple checks for console / remote TS sessions.
//

#define MAIN_SESSION      ((ULONG)0)
#define THIS_SESSION      ((ULONG)NtCurrentPeb()->SessionId)
#define CONSOLE_SESSION   ((ULONG)USER_SHARED_DATA->ActiveConsoleId)

#define IsConsoleSession()        (BOOL)(THIS_SESSION == CONSOLE_SESSION)
#define IsRemoteSession()         (BOOL)(THIS_SESSION != CONSOLE_SESSION)
#define IsPseudoConsoleSession()  (BOOL)(THIS_SESSION == MAIN_SESSION)


//
// 2001/02/01 - Disable support for *both* arrival bubbles and departure
// bubbles (hotplug.dll must be kept in sync here.) This code is disabled for
// beta2, and should be removed afterwards if feedback is positive.
//
#define BUBBLES 0


#define HPLUG_EJECT_EVENT           TEXT("HPlugEjectEvent")

#if BUBBLES
#define HPLUG_DOCK_TIMER            TEXT("HPlugProfileChangeTimer")
#define SURPRISE_UNDOCK_TIMER       TEXT("Local\\HotPlug_SurpriseUndockTimer_{25126bc2-1ab0-4494-8b6d-e4034cb9c24a}")

//
// We suppress bubbles for some period of time after a dock event. Free build,
// ~15 secs, Checked build ~60.
//
#if DBG
#define BUBBLE_SUPPRESSION_TIME     60
#else
#define BUBBLE_SUPPRESSION_TIME     15
#endif
#endif // BUBBLES

typedef struct _HotPlugDevices {
     struct _HotPlugDevices *Next;
     DEVINST DevInst;
     WORD    EjectMenuIndex;
     BOOLEAN PendingEvent;
     PTCHAR  DevName;
     TCHAR   DevInstanceId[1];
} HOTPLUGDEVICES, *PHOTPLUGDEVICES;

BOOL HotPlugInitialized = FALSE;
BOOL ShowShellIcon = FALSE;
HICON HotPlugIcon = NULL;
BOOL ServiceEnabled = FALSE;
HANDLE hEjectEvent = NULL;   // Event to if we are in the process of ejecting a device
HDEVINFO g_hCurrentDeviceInfoSet = INVALID_HANDLE_VALUE;
HDEVINFO g_hRemovableDeviceInfoSet = INVALID_HANDLE_VALUE;

#if BUBBLES
HANDLE hDockEventTimer = NULL;
HANDLE hSurpriseUndockEventTimer = NULL;
CRITICAL_SECTION g_BubbleCrit = { 0 };
#endif // BUBBLES

extern HINSTANCE g_hInstance;       //  Global instance handle 4 this application.

BOOL
pDoesUserHavePrivilege(
    PCTSTR PrivilegeName
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process has
    the specified privilege.  The privilege does not have
    to be currently enabled.  This routine is used to indicate
    whether the caller has the potential to enable the privilege.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    Privilege - the name form of privilege ID (such as
        SE_SECURITY_NAME).

Return Value:

    TRUE - Caller has the specified privilege.

    FALSE - Caller does not have the specified privilege.

--*/

{
    HANDLE Token;
    ULONG BytesRequired;
    PTOKEN_PRIVILEGES Privileges;
    BOOL b;
    DWORD i;
    LUID Luid;

    //
    // Open the process token.
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&Token)) {
        return(FALSE);
    }

    b = FALSE;
    Privileges = NULL;

    //
    // Get privilege information.
    //
    if(!GetTokenInformation(Token,TokenPrivileges,NULL,0,&BytesRequired)
    && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    && (Privileges = LocalAlloc(LPTR, BytesRequired))
    && GetTokenInformation(Token,TokenPrivileges,Privileges,BytesRequired,&BytesRequired)
    && LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {

        //
        // See if we have the requested privilege
        //
        for(i=0; i<Privileges->PrivilegeCount; i++) {

            if((Luid.LowPart  == Privileges->Privileges[i].Luid.LowPart)
            && (Luid.HighPart == Privileges->Privileges[i].Luid.HighPart)) {

                b = TRUE;
                break;
            }
        }
    }

    //
    // Clean up and return.
    //

    if(Privileges) {
        LocalFree(Privileges);
    }

    CloseHandle(Token);

    return(b);
}

BOOL
IsHotPlugDevice(
    DEVINST DevInst,
    PBOOL   WarnUserOnInsertion OPTIONAL
    )
/**+

    A device is considered a HotPlug device if the following are TRUE:
        - has Capability CM_DEVCAP_REMOVABLE
        - does NOT have Capability CM_DEVCAP_SURPRISEREMOVALOK
        - does NOT have Capability CM_DEVCAP_DOCKDEVICE
        - must be started (have the DN_STARTED devnode flag)
            - unless has capability CM_DEVCAP_EJECTSUPPORTED

    WarnUserOnInsertion - Receives TRUE if the user should be warned to use the
                          hotplug applet when this device is inserted.

Returns:
    TRUE if this is a HotPlug device
    FALSE if this is not a HotPlug device.

-**/
{
    DWORD Capabilities, ConfigFlags;
    DWORD Len;
    DWORD Status, Problem;
    CONFIGRET ConfigRet;

    Capabilities = Status = Problem = 0;

    if (ARGUMENT_PRESENT(WarnUserOnInsertion)) {
        *WarnUserOnInsertion = FALSE;
    }

    Len = sizeof(Capabilities);

    if (CM_Get_DevNode_Registry_Property(DevInst,
                                         CM_DRP_CAPABILITIES,
                                         NULL,
                                         (PVOID)&Capabilities,
                                         &Len,
                                         0
                                         ) != CR_SUCCESS) {

        return FALSE;
    }

    if (CM_Get_DevNode_Status(&Status,
                              &Problem,
                              DevInst,
                              0
                              ) != CR_SUCCESS) {

        return FALSE;
    }

    //
    // If this device is not removable, or it is surprise removal ok, or
    // it is a dock device, then it is not a hotplug device.
    //
    if ((!(Capabilities & CM_DEVCAP_REMOVABLE)) ||
        (Capabilities & CM_DEVCAP_SURPRISEREMOVALOK) ||
        (Capabilities & CM_DEVCAP_DOCKDEVICE)) {

        return FALSE;
    }

    //
    // We won't consider a device to be a hotplug device if it is not started,
    // unless it is an eject capable device.
    //
    // The reason for this test is that a bus driver might set the
    // CM_DEVCAP_REMOVABLE capability, but if the PDO doesn't get loaded then
    // it can't set the CM_DEVCAP_SURPRISEREMOVALOK. So we won't trust the
    // CM_DEVCAP_REMOVABLE capability if the PDO is not started.
    //
    if ((!(Capabilities & CM_DEVCAP_EJECTSUPPORTED)) &&
        (!(Status & DN_STARTED))) {

        return FALSE;
    }

#if BUBBLES
    if (ARGUMENT_PRESENT(WarnUserOnInsertion)) {

        Len = sizeof(ConfigFlags);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                                        CM_DRP_CONFIGFLAGS,
                                                        NULL,
                                                        (PVOID)&ConfigFlags,
                                                        &Len,
                                                        0,
                                                        NULL);
        if ((ConfigRet == CR_SUCCESS) &&
            (ConfigFlags & CONFIGFLAG_SUPPRESS_SURPRISE)) {
            *WarnUserOnInsertion = FALSE;
        } else {
            *WarnUserOnInsertion = TRUE;
        }
    }
#endif // BUBBLES

    return TRUE;
}

BOOL
IsRemovableDevice(
    IN  DEVINST     dnDevInst
    )

/*++

Routine Description:

    This routine determines whether a device is removable.

Arguments:

    dnDevInst - Device instance.

Return Value:

    Returns TRUE if the device is removable.

--*/

{
    CONFIGRET Status = CR_SUCCESS;
    ULONG  ulPropertyData, ulDataSize, ulRegDataType;

    //
    // Validate parameters.
    //
    if (dnDevInst == 0) {
        return FALSE;
    }

    //
    // Get the capabilities for this device.
    //
    ulDataSize = sizeof(ulPropertyData);

    if (CM_Get_DevNode_Registry_Property_Ex(dnDevInst,
                                            CM_DRP_CAPABILITIES,
                                            &ulRegDataType,
                                            &ulPropertyData,
                                            &ulDataSize,
                                            0,
                                            NULL) != CR_SUCCESS) {
        return FALSE;
    }

    //
    // Check if the device has the removable capability.
    //
    if ((ulPropertyData & CM_DEVCAP_REMOVABLE) == 0) {
        return FALSE;
    }

    return TRUE;

} // IsRemovableDevice

LPTSTR
DevNodeToDriveLetter(
    DEVINST DevInst
    )
{
    BOOL Result = FALSE;
    ULONG ulSize;
    TCHAR DeviceID[MAX_DEVICE_ID_LEN];
    LPTSTR DriveName = NULL;
    LPTSTR DeviceInterface = NULL;

    if (CM_Get_Device_ID_Ex(DevInst,
                            DeviceID,
                            ARRAYSIZE(DeviceID),
                            0,
                            NULL
                            ) != CR_SUCCESS) {

        return FALSE;
    }

    ulSize = 0;

    if ((CM_Get_Device_Interface_List_Size(&ulSize,
                                           (LPGUID)&VolumeClassGuid,
                                           DeviceID,
                                           0)  == CR_SUCCESS) &&
        (ulSize > 1) &&
        ((DeviceInterface = LocalAlloc(LPTR, ulSize*sizeof(TCHAR))) != NULL) &&
        (CM_Get_Device_Interface_List((LPGUID)&VolumeClassGuid,
                                      DeviceID,
                                      DeviceInterface,
                                      ulSize,
                                      0
                                      )  == CR_SUCCESS) &&
        *DeviceInterface)
    {
        LPTSTR devicePath, p;
        TCHAR thisVolumeName[MAX_PATH];
        TCHAR enumVolumeName[MAX_PATH];
        TCHAR driveName[4];
        ULONG length;
        BOOL bResult;

        length = lstrlen(DeviceInterface);
        devicePath = LocalAlloc(LPTR, (length + 1) * sizeof(TCHAR) + sizeof(UNICODE_NULL));

        if (devicePath) {

            lstrcpyn(devicePath, DeviceInterface, length + 1);

            p = wcschr(&(devicePath[4]), TEXT('\\'));

            if (!p) {
                //
                // No refstring is present in the symbolic link; add a trailing
                // '\' char (as required by GetVolumeNameForVolumeMountPoint).
                //
                p = devicePath + length;
                *p = TEXT('\\');
            }

            p++;
            *p = UNICODE_NULL;

            thisVolumeName[0] = UNICODE_NULL;
            bResult = GetVolumeNameForVolumeMountPoint(devicePath,
                                                       thisVolumeName,
                                                       MAX_PATH
                                                       );
            LocalFree(devicePath);

            if (bResult && thisVolumeName[0]) {

                driveName[1] = TEXT(':');
                driveName[2] = TEXT('\\');
                driveName[3] = TEXT('\0');

                for (driveName[0] = TEXT('A'); driveName[0] <= TEXT('Z'); driveName[0]++) {

                    enumVolumeName[0] = TEXT('\0');

                    GetVolumeNameForVolumeMountPoint(driveName, enumVolumeName, MAX_PATH);

                    if (!lstrcmpi(thisVolumeName, enumVolumeName)) {

                        driveName[2] = TEXT('\0');

                        DriveName = LocalAlloc(LPTR, (lstrlen(driveName) + 1) * sizeof(TCHAR));

                        if (DriveName) {

                            lstrcpy(DriveName, driveName);
                        }

                        break;
                    }
                }
            }
        }
    }

    if (DeviceInterface) {

        LocalFree(DeviceInterface);
    }

    return DriveName;
}

int
CollectRelationDriveLetters(
    DEVINST DevInst,
    LPTSTR ListOfDrives
    )
/*++

    This function looks at the removal relations of the specified DevInst and adds any drive
    letters associated with these removal relations to the ListOfDrives.

Return:
    Number of drive letters added to the list.

--*/
{
    int NumberOfDrives = 0;
    LPTSTR SingleDrive = NULL;
    TCHAR szSeparator[32];
    DEVINST RelationDevInst;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    ULONG Len;
    PTCHAR DeviceIdRelations, CurrDevId;

    if (CM_Get_Device_ID(DevInst,
                         DeviceInstanceId,
                         ARRAYSIZE(DeviceInstanceId),
                         0
                         ) == CR_SUCCESS) {

        Len = 0;
        if ((CM_Get_Device_ID_List_Size(&Len,
                                        DeviceInstanceId,
                                        CM_GETIDLIST_FILTER_REMOVALRELATIONS
                                        ) == CR_SUCCESS) &&
            (Len)) {

            DeviceIdRelations = LocalAlloc(LPTR, Len*sizeof(TCHAR));

            if (DeviceIdRelations) {

                *DeviceIdRelations = TEXT('\0');

                if ((CM_Get_Device_ID_List(DeviceInstanceId,
                                           DeviceIdRelations,
                                           Len,
                                           CM_GETIDLIST_FILTER_REMOVALRELATIONS
                                           ) == CR_SUCCESS) &&
                    (*DeviceIdRelations)) {

                    for (CurrDevId = DeviceIdRelations; *CurrDevId; CurrDevId += lstrlen(CurrDevId) + 1) {

                        if (CM_Locate_DevNode(&RelationDevInst, CurrDevId, 0) == CR_SUCCESS) {

                            SingleDrive = DevNodeToDriveLetter(RelationDevInst);

                            if (SingleDrive) {

                                NumberOfDrives++;

                                //
                                // If this is not the first drive the add a comma space separator
                                //
                                if (ListOfDrives[0] != TEXT('\0')) {

                                    LoadString(g_hInstance, IDS_SEPARATOR, szSeparator, sizeof(szSeparator)/sizeof(TCHAR));

                                    lstrcat(ListOfDrives, szSeparator);
                                }

                                lstrcat(ListOfDrives, SingleDrive);

                                LocalFree(SingleDrive);
                            }
                        }
                    }
                }

                LocalFree(DeviceIdRelations);
            }
        }
    }

    return NumberOfDrives;
}

int
CollectDriveLettersForDevNodeWorker(
    DEVINST DevInst,
    LPTSTR ListOfDrives
    )
{
    DEVINST ChildDevInst;
    DEVINST SiblingDevInst;
    int NumberOfDrives = 0;
    LPTSTR SingleDrive = NULL;
    TCHAR szSeparator[32];

    //
    // Enumerate through all of the siblings and children of this devnode
    //
    do {

        ChildDevInst = 0;
        SiblingDevInst = 0;

        CM_Get_Child(&ChildDevInst, DevInst, 0);
        CM_Get_Sibling(&SiblingDevInst, DevInst, 0);

        //
        // Only get the drive letter for this device if it is NOT a hotplug
        // device.  If it is a hotplug device then it will have it's own
        // subtree that contains it's drive letters.
        //
        if (!IsHotPlugDevice(DevInst, NULL)) {

            SingleDrive = DevNodeToDriveLetter(DevInst);

            if (SingleDrive) {

                NumberOfDrives++;

                //
                // If this is not the first drive the add a comma space separator
                //
                if (ListOfDrives[0] != TEXT('\0')) {

                    LoadString(g_hInstance, IDS_SEPARATOR, szSeparator, sizeof(szSeparator)/sizeof(TCHAR));

                    lstrcat(ListOfDrives, szSeparator);
                }

                lstrcat(ListOfDrives, SingleDrive);

                LocalFree(SingleDrive);
            }

            //
            // Get the drive letters for any children of this devnode
            //
            if (ChildDevInst) {

                NumberOfDrives += CollectDriveLettersForDevNodeWorker(ChildDevInst, ListOfDrives);
            }

            //
            // Add the drive letters for any removal relations of this devnode
            //
            NumberOfDrives += CollectRelationDriveLetters(DevInst, ListOfDrives);
        }

    } while ((DevInst = SiblingDevInst) != 0);

    return NumberOfDrives;
}

LPTSTR
CollectDriveLettersForDevNode(
    DEVINST DevInst
    )
{
    TCHAR Format[MAX_PATH];
    TCHAR ListOfDrives[MAX_PATH];
    DEVINST ChildDevInst;
    int NumberOfDrives = 0;
    LPTSTR SingleDrive = NULL;
    LPTSTR FinalDriveString = NULL;

    ListOfDrives[0] = TEXT('\0');

    //
    //First get any drive letter associated with this devnode
    //
    SingleDrive = DevNodeToDriveLetter(DevInst);

    if (SingleDrive) {

        NumberOfDrives++;

        lstrcat(ListOfDrives, SingleDrive);

        LocalFree(SingleDrive);
    }

    //
    // Next add on any drive letters associated with the children
    // of this devnode
    //
    ChildDevInst = 0;
    CM_Get_Child(&ChildDevInst, DevInst, 0);

    if (ChildDevInst) {

        NumberOfDrives += CollectDriveLettersForDevNodeWorker(ChildDevInst, ListOfDrives);
    }

    //
    // Finally add on any drive letters associated with the removal relations
    // of this devnode
    //
    NumberOfDrives += CollectRelationDriveLetters(DevInst, ListOfDrives);

    if (ListOfDrives[0] != TEXT('\0')) {

        LoadString(g_hInstance,
                   (NumberOfDrives > 1) ? IDS_DISKDRIVES : IDS_DISKDRIVE,
                   Format,
                   sizeof(Format)/sizeof(TCHAR)
                   );


        FinalDriveString = LocalAlloc(LPTR, (lstrlen(ListOfDrives) + lstrlen(Format) + 1) * sizeof(TCHAR));

        if (FinalDriveString) {

            wsprintf(FinalDriveString, Format, ListOfDrives);
        }
    }

    return FinalDriveString;
}

DWORD
GetHotPlugFlags(
   void
   )
{
    HKEY hKey;
    LONG Error;
    DWORD HotPlugFlags, cbHotPlugFlags;

    Error = RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_SYSTRAY, &hKey);

    if (Error == ERROR_SUCCESS) {

        cbHotPlugFlags = sizeof(HotPlugFlags);

        Error = RegQueryValueEx(hKey,
                                TEXT("HotPlugFlags"),
                                NULL,
                                NULL,
                                (PVOID)&HotPlugFlags,
                                &cbHotPlugFlags
                                );
        RegCloseKey(hKey);
        if (Error == ERROR_SUCCESS) {

            return HotPlugFlags;
        }
    }

    return 0;
}

ULONG
RegistryDeviceName(
    DEVINST DevInst,
    PTCHAR  Buffer,
    DWORD   cbBuffer
    )
{
    ULONG ulSize = 0;
    CONFIGRET ConfigRet;
    LPTSTR ListOfDrives = NULL;

    //
    // Get the list of drives
    //
    ListOfDrives = CollectDriveLettersForDevNode(DevInst);

    //
    // Try the registry for FRIENDLYNAME
    //

    ulSize = cbBuffer;
    *Buffer = TEXT('\0');
    ConfigRet = CM_Get_DevNode_Registry_Property(DevInst,
                                                 CM_DRP_FRIENDLYNAME,
                                                 NULL,
                                                 Buffer,
                                                 &ulSize,
                                                 0
                                                 );

    if (ConfigRet != CR_SUCCESS || !(*Buffer)) {

        //
        // Try the registry for DEVICEDESC
        //

        ulSize = cbBuffer;
        *Buffer = TEXT('\0');
        ConfigRet = CM_Get_DevNode_Registry_Property(DevInst,
                                                     CM_DRP_DEVICEDESC,
                                                     NULL,
                                                     Buffer,
                                                     &ulSize,
                                                     0);

        if (ConfigRet != CR_SUCCESS || !(*Buffer)) {


            //
            // try classname
            //

            ulSize = cbBuffer;
            *Buffer = TEXT('\0');
            ConfigRet = CM_Get_DevNode_Registry_Property(DevInst,
                                                         CM_DRP_CLASS,
                                                         NULL,
                                                         Buffer,
                                                         &ulSize,
                                                         0);

            if (ConfigRet != CR_SUCCESS || !(*Buffer)) {

                ulSize = 0;;
            }
        }
    }

    //
    // Concatonate on the list of drive letters if this device has drive
    // letters and there is enough space
    //
    if (ListOfDrives) {

        if ((ulSize + (lstrlen(ListOfDrives) * sizeof(TCHAR))) < cbBuffer) {

            lstrcat(Buffer, ListOfDrives);

            ulSize += (lstrlen(ListOfDrives) * sizeof(TCHAR));
        }

        LocalFree(ListOfDrives);
    }

    return ulSize;
}

BOOL
IsDevInstInDeviceInfoSet(
    IN  DEVINST  DevInst,
    IN  HDEVINFO hDeviceInfoSet,
    OUT PSP_DEVINFO_DATA DeviceInfoDataInSet  OPTIONAL
    )
{
    DWORD MemberIndex;
    SP_DEVINFO_DATA DeviceInfoData;
    BOOL bIsMember = FALSE;

    ASSERT(hDeviceInfoSet != INVALID_HANDLE_VALUE);

    if (hDeviceInfoSet == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
    MemberIndex = 0;

    while (SetupDiEnumDeviceInfo(hDeviceInfoSet,
                                 MemberIndex,
                                 &DeviceInfoData
                                 )) {

        if (DevInst == DeviceInfoData.DevInst) {
            bIsMember = TRUE;
            if (ARGUMENT_PRESENT(DeviceInfoDataInSet)) {
                ASSERT(DeviceInfoDataInSet->cbSize >= DeviceInfoData.cbSize);
                memcpy(DeviceInfoDataInSet, &DeviceInfoData, DeviceInfoDataInSet->cbSize);
            }
            break;
        }
        MemberIndex++;
    }
    return bIsMember;
}

BOOL
AnyHotPlugDevices(
    IN  HDEVINFO hRemovableDeviceInfoSet,
    IN  HDEVINFO hOldDeviceInfoSet,
    OUT PBOOL    bNewHotPlugDevice           OPTIONAL,
    OUT PBOOL    bWarnUserAboutNewDevices    OPTIONAL
    )
{
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD dwMemberIndex;
    BOOL bAnyHotPlugDevices = FALSE;
    BOOL bWarnOnInsertion;

    //
    // Initialize output parameters.
    //
    if (ARGUMENT_PRESENT(bNewHotPlugDevice)) {
        *bNewHotPlugDevice = FALSE;
    }

    if (ARGUMENT_PRESENT(bWarnUserAboutNewDevices)) {
        *bWarnUserAboutNewDevices = FALSE;
    }

    //
    // We already have an updated list of just removable devices, so we can just
    // enumerate those devices and see if any also meet the criteria for hotplug
    // devices.
    //
    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
    dwMemberIndex = 0;

    while (SetupDiEnumDeviceInfo(hRemovableDeviceInfoSet,
                                 dwMemberIndex,
                                 &DeviceInfoData)) {

        if (IsHotPlugDevice(DeviceInfoData.DevInst, &bWarnOnInsertion)) {

            bAnyHotPlugDevices = TRUE;

            //
            // If the caller doesn't want to know if any new hotplug devices
            // have arrived then just break at this point.
            //
            if (!ARGUMENT_PRESENT(bNewHotPlugDevice)) {
                break;
            }

            //
            // If the caller wants to know if the hotplug device is new, we must
            // have a list of devices to check against.
            //
            ASSERT(hOldDeviceInfoSet != INVALID_HANDLE_VALUE);

            //
            // The caller wants to know if we have any new hotplug devices.  So,
            // we will compare this hotplug device to see if it is also in the
            // old current list of devices.  If it is not then we have found a
            // new hotplug device.
            //
            if (!IsDevInstInDeviceInfoSet(DeviceInfoData.DevInst,
                                          hOldDeviceInfoSet,
                                          NULL)) {
                *bNewHotPlugDevice = TRUE;

                if (ARGUMENT_PRESENT(bWarnUserAboutNewDevices) && bWarnOnInsertion) {

                    *bWarnUserAboutNewDevices = TRUE;

                    //
                    // There is no longer any reason to continue the
                    // enumeration.
                    //
                    break;
                }
            }
        }
        dwMemberIndex++;
    }

    return bAnyHotPlugDevices;
}

BOOL
UpdateRemovableDeviceList(
    IN  HDEVINFO hDeviceInfoSet,
    OUT PBOOL    bRemovableDeviceAdded    OPTIONAL,
    OUT PBOOL    bRemovableDeviceRemoved  OPTIONAL,
    OUT PBOOL    bRemovableDeviceFailure  OPTIONAL
    )
{
    SP_DEVINFO_DATA DeviceInfoData;
    TCHAR    DeviceInstanceId[MAX_DEVICE_ID_LEN];
    DWORD    dwMemberIndex;
    ULONG    ulDevStatus, ulDevProblem;

    //
    // Initialize output parameters.
    //
    if (ARGUMENT_PRESENT(bRemovableDeviceAdded)) {
        *bRemovableDeviceAdded = FALSE;
    }

    if (ARGUMENT_PRESENT(bRemovableDeviceRemoved)) {
        *bRemovableDeviceRemoved = FALSE;
    }

    if (ARGUMENT_PRESENT(bRemovableDeviceFailure)) {
        *bRemovableDeviceFailure = FALSE;
    }

    //
    // We at least need a current list of devices in the system.
    //
    if (hDeviceInfoSet == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (g_hRemovableDeviceInfoSet == INVALID_HANDLE_VALUE) {
        //
        // If we don't already have a global device info set for removable
        // devices in the system, create one now.  No removable devices have
        // been removed in this case, because we didn't know about any prior to
        // this.
        //
        g_hRemovableDeviceInfoSet = SetupDiCreateDeviceInfoListEx(NULL,
                                                                  NULL,
                                                                  NULL,
                                                                  NULL);

        //
        // If we couldn't create a list to store removable devices, there's no
        // point in checking anything else here.
        //
        if (g_hRemovableDeviceInfoSet == INVALID_HANDLE_VALUE) {
            return FALSE;
        }

    } else {
        //
        // If we already had a list of removable devices, enumerate the devices
        // to see if any have been removed from the system since we last
        // checked.
        //
        DeviceInfoData.cbSize = sizeof(DeviceInfoData);
        dwMemberIndex = 0;

        while (SetupDiEnumDeviceInfo(g_hRemovableDeviceInfoSet,
                                     dwMemberIndex,
                                     &DeviceInfoData)) {

            if (!IsDevInstInDeviceInfoSet(DeviceInfoData.DevInst,
                                          hDeviceInfoSet,
                                          NULL)) {

                //
                // A removable device is missing from the system.
                //
                if (ARGUMENT_PRESENT(bRemovableDeviceRemoved)) {
                    *bRemovableDeviceRemoved = TRUE;
                }

#if DBG // DBG
                if (SetupDiGetDeviceInstanceId(g_hRemovableDeviceInfoSet,
                                               &DeviceInfoData,
                                               DeviceInstanceId,
                                               MAX_DEVICE_ID_LEN,
                                               NULL)) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               (0x00000010 | DPFLTR_MASK),
                               "HPLUG: Removing device %ws from g_hRemovableDeviceInfoSet.\n",
                               DeviceInstanceId));
                }
#endif  // DBG

                //
                // Remove the device from the global list of removable devices.
                //
                SetupDiDeleteDeviceInfo(g_hRemovableDeviceInfoSet,
                                        &DeviceInfoData);
            }

            //
            // Increment the enumeration index.
            //
            dwMemberIndex++;
        }
    }

    //
    // Enumerate the current list of devices and see if any removable devices
    // have been added to the system.
    //
    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
    dwMemberIndex = 0;

    while (SetupDiEnumDeviceInfo(hDeviceInfoSet,
                                 dwMemberIndex,
                                 &DeviceInfoData)) {

        //
        // If this device is not already in the removable device list, and it's
        // removable, add it to the list.
        //
        if ((!IsDevInstInDeviceInfoSet(DeviceInfoData.DevInst,
                                       g_hRemovableDeviceInfoSet,
                                       NULL)) &&
            (IsRemovableDevice(DeviceInfoData.DevInst))) {

            //
            // A removable device was added to the system.
            //
            if (ARGUMENT_PRESENT(bRemovableDeviceAdded)) {
                *bRemovableDeviceAdded = TRUE;
            }

            //
            // Add the device to the global list of removable devices.
            //
            if (SetupDiGetDeviceInstanceId(hDeviceInfoSet,
                                           &DeviceInfoData,
                                           DeviceInstanceId,
                                           MAX_DEVICE_ID_LEN,
                                           NULL)) {

                KdPrintEx((DPFLTR_PNPMGR_ID,
                           (0x00000010 | DPFLTR_MASK),
                           "HPLUG: Adding device %ws to g_hRemovableDeviceInfoSet\n",
                           DeviceInstanceId));

                SetupDiOpenDeviceInfo(g_hRemovableDeviceInfoSet,
                                      DeviceInstanceId,
                                      NULL,
                                      0,
                                      NULL);
            }

            //
            // If the caller is also interested in device failures, check the
            // status of the new device.
            //
            if (ARGUMENT_PRESENT(bRemovableDeviceFailure)) {

                if (CM_Get_DevNode_Status_Ex(&ulDevStatus,
                                             &ulDevProblem,
                                             DeviceInfoData.DevInst,
                                             0,
                                             NULL) == CR_SUCCESS) {

                    if (((ulDevStatus & DN_HAS_PROBLEM) != 0) &&
                        (ulDevProblem != CM_PROB_NOT_CONFIGURED) &&
                        (ulDevProblem != CM_PROB_REINSTALL)) {

                        *bRemovableDeviceFailure = TRUE;

                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   (0x00000010 | DPFLTR_MASK),
                                   "HPLUG: Device %ws considered a failed insertion (Status = 0x%08lx, Problem = 0x%08lx)\n",
                                   DeviceInstanceId, ulDevStatus, ulDevProblem));
                    }
                }
            }
        }

        //
        // Increment the enumeration index.
        //
        dwMemberIndex++;
    }

    return TRUE;
}

BOOL
AddHotPlugDevice(
    DEVINST      DeviceInstance,
    PHOTPLUGDEVICES *HotPlugDevicesList
    )
{
    PHOTPLUGDEVICES HotPlugDevice;
    DWORD      Len, LenDevName, LenDevInstanceId;
    CONFIGRET  ConfigRet;
    TCHAR      DevInstanceId[MAX_DEVICE_ID_LEN];
    TCHAR      DevName[MAX_PATH];


    //
    // Retrieve the device instance id
    //
    *DevInstanceId = TEXT('\0');
    LenDevInstanceId = ARRAYSIZE(DevInstanceId);
    ConfigRet = CM_Get_Device_ID(DeviceInstance,
                                 (PVOID)DevInstanceId,
                                 LenDevInstanceId,
                                 0);

    if (ConfigRet != CR_SUCCESS || !*DevInstanceId) {
        *DevInstanceId = TEXT('\0');
        LenDevInstanceId = 0;
    }

    Len = sizeof(HOTPLUGDEVICES) + LenDevInstanceId;
    HotPlugDevice = LocalAlloc(LPTR, Len);

    if (!HotPlugDevice) {
        return FALSE;
    }

    //
    // link it in
    //
    HotPlugDevice->Next = *HotPlugDevicesList;
    *HotPlugDevicesList = HotPlugDevice;
    HotPlugDevice->DevInst = DeviceInstance;

    //
    // copy in the names
    //
    memcpy(HotPlugDevice->DevInstanceId, DevInstanceId, LenDevInstanceId);

    LenDevName = RegistryDeviceName(DeviceInstance, DevName, sizeof(DevName));
    HotPlugDevice->DevName = LocalAlloc(LPTR, LenDevName + sizeof(TCHAR));

    if (HotPlugDevice->DevName) {
        memcpy(HotPlugDevice->DevName, DevName, LenDevName);
    }

    return TRUE;
}

BOOL
AddHotPlugDevices(
    PHOTPLUGDEVICES *HotPlugDevicesList
    )
{
    CONFIGRET ConfigRet;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD    dwMemberIndex;

    //
    // Initialize output list of hotplug devices.
    //
    *HotPlugDevicesList = NULL;

    //
    // Enumerate the list of removable devices.
    //
    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
    dwMemberIndex = 0;

    while (SetupDiEnumDeviceInfo(g_hRemovableDeviceInfoSet,
                                 dwMemberIndex,
                                 &DeviceInfoData)) {

        //
        // If any removable device also meets the criteria of a hotplug device,
        // add it to the linked list.
        //
        if (IsHotPlugDevice(DeviceInfoData.DevInst, NULL)) {
            AddHotPlugDevice(DeviceInfoData.DevInst, HotPlugDevicesList);
        }
        dwMemberIndex++;
    }

    return TRUE;
}


void
FreeHotPlugDevicesList(
    PHOTPLUGDEVICES *HotPlugDevicesList
    )
{
    PHOTPLUGDEVICES HotPlugDevices, HotPlugDevicesFree;

    HotPlugDevices = *HotPlugDevicesList;
    *HotPlugDevicesList = NULL;

    while (HotPlugDevices) {

        HotPlugDevicesFree = HotPlugDevices;
        HotPlugDevices = HotPlugDevicesFree->Next;

        if (HotPlugDevicesFree->DevName) {

           LocalFree(HotPlugDevicesFree->DevName);
           HotPlugDevicesFree->DevName = NULL;
        }

        LocalFree(HotPlugDevicesFree);
    }
}


/*
 *  Shows or deletes the shell notify icon and tip
 */

void
HotPlugShowNotifyIcon(
    HWND hWnd,
    BOOL bShowIcon
    )
{
    TCHAR HotPlugTip[64];

    ShowShellIcon = bShowIcon;

    if (bShowIcon) {

        LoadString(g_hInstance,
                   IDS_HOTPLUGTIP,
                   HotPlugTip,
                   sizeof(HotPlugTip)/sizeof(TCHAR)
                   );

        HotPlugIcon = LoadImage(g_hInstance,
                                MAKEINTRESOURCE(IDI_HOTPLUG),
                                IMAGE_ICON,
                                16,
                                16,
                                0
                                );

        SysTray_NotifyIcon(hWnd, STWM_NOTIFYHOTPLUG, NIM_ADD, HotPlugIcon, HotPlugTip);

    }

    else {

        SysTray_NotifyIcon(hWnd, STWM_NOTIFYHOTPLUG, NIM_DELETE, NULL, NULL);

        if (HotPlugIcon) {

            DestroyIcon(HotPlugIcon);
        }
    }
}



//
// first time intialization of Hotplug module.
//



BOOL
HotPlugInit(
    HWND hWnd
    )
{
    HDEVINFO  hNewDeviceInfoSet;
    BOOL bAnyHotPlugDevices;
    LARGE_INTEGER liDelayTime;

    //
    // Get a new "current" list of all devices present in the system.
    //
    hNewDeviceInfoSet = SetupDiGetClassDevs(NULL,
                                            NULL,
                                            NULL,
                                            DIGCF_ALLCLASSES | DIGCF_PRESENT);

    //
    // Update the list of removable devices, don't play any sounds.
    //
    UpdateRemovableDeviceList(hNewDeviceInfoSet,
                              NULL,
                              NULL,
                              NULL);

    //
    // Find out whether there are any HotPlug devices in the list of removable
    // devices.  We're just deciding whether the icon needs to be enabled or
    // not, so we don't care if there are any new hotplug devices or not (we
    // won't even look at g_hCurrentDeviceInfoSet).
    //
    bAnyHotPlugDevices = AnyHotPlugDevices(g_hRemovableDeviceInfoSet,
                                           g_hCurrentDeviceInfoSet,
                                           NULL,
                                           NULL);

    //
    // Delete the old current list of devices and set it
    // (g_hCurrentDeviceInfoSet) to the new current list.
    //
    if (g_hCurrentDeviceInfoSet != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(g_hCurrentDeviceInfoSet);
    }

    //
    // Update the global list of devices currently in the system.
    //
    g_hCurrentDeviceInfoSet = hNewDeviceInfoSet;

    //
    // If hotplug was previously initialized, we don't need to create the events
    // and timers below.
    //
    if (HotPlugInitialized) {
        return bAnyHotPlugDevices;
    }

    hEjectEvent = CreateEvent(NULL, TRUE, TRUE, HPLUG_EJECT_EVENT);

#if BUBBLES
    //
    // Create a timer that will be used to suppress "insertion warnings" that
    // occur when a dock is attached.
    //
    hDockEventTimer = CreateWaitableTimer(NULL, TRUE, HPLUG_DOCK_TIMER);
    if (hDockEventTimer) {

        //
        // Signal it immediately
        //
        liDelayTime.QuadPart = 0;

        SetWaitableTimer(hDockEventTimer, &liDelayTime, 0, NULL, NULL, FALSE);
    }

    //
    // Create a session-wide timer hotplug.dll will use to suppress surprise
    // remove messages during surprise undocks. We create the timer here as
    // hotplug comes and goes while we stick around.
    //
    hSurpriseUndockEventTimer = CreateWaitableTimer(
        NULL,
        TRUE,
        SURPRISE_UNDOCK_TIMER
        );

    if ((hSurpriseUndockEventTimer != NULL) &&
        (GetLastError() == ERROR_SUCCESS)) {

        //
        // We created it (if not the status would be
        // ERROR_ALREADY_EXISTS). Signal it immediately.
        //
        liDelayTime.QuadPart = 0;

        SetWaitableTimer(hSurpriseUndockEventTimer, &liDelayTime, 0, NULL, NULL, FALSE);
    }

    try {
        InitializeCriticalSection(&g_BubbleCrit);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }
#endif // BUBBLES

    HotPlugInitialized = TRUE;

    return bAnyHotPlugDevices;
}

BOOL
HotPlug_CheckEnable(
    HWND hWnd,
    BOOL bSvcEnabled
    )
/*++

Routine Description:

   Called at init time and whenever services are enabled/disabled.
   Hotplug is always alive to receive device change notifications.

   The shell notify icon is enabled\disabled depending on:

   - systray registry setting for services,
        AND
   - availability of removable devices.


Arguments:

   hwnd - Our Window handle

   bSvcEnabled - TRUE Service is being enabled.


Return Value:

   BOOL Returns TRUE if active.


--*/

{
    BOOL EnableShellIcon;
    HANDLE hHotplugBalloonEvent = NULL;

    //
    // If we are being enabled and we are already enabled, or we
    // are being disabled and we are already disabled then just
    // return since we have nothing to do.
    //
    if (ServiceEnabled == bSvcEnabled) {
        return ServiceEnabled;
    }

    ServiceEnabled = bSvcEnabled;

    //
    // There are some special checks we need to make if we are enabling the
    // hotplug service.
    //
    if (bSvcEnabled) {

        //
        // If this is a remote session and the user does not have the
        // SE_LOAD_DRIVER_NAME privileges then we won't enable the service
        // since they do not have the privileges to stop any hotplug devices.
        //
        if (GetSystemMetrics(SM_REMOTESESSION) &&
            !pDoesUserHavePrivilege((PCTSTR)SE_LOAD_DRIVER_NAME)) {
            ServiceEnabled = FALSE;

        } else {

            //
            // hotplug.dll will disable the hotplug service when it is
            // displaying a balloon for a surprise removal or safe removal
            // event. When it is displaying it's balloon we don't want to
            // enable our service because then there will be two hotplug icons
            // in the tray. So if it's named event is set then we will ignore
            // any attempts to enable our service.  Once hotplug.dll's balloon
            // has gone away then it will automatically enable the hotplug
            // service.
            //
            hHotplugBalloonEvent = CreateEvent(NULL,
                                               FALSE,
                                               TRUE,
                                               TEXT("Local\\HotPlug_TaskBarIcon_Event")
                                               );

            if (hHotplugBalloonEvent) {

                if (WaitForSingleObject(hHotplugBalloonEvent, 0) != WAIT_OBJECT_0) {
                    ServiceEnabled = FALSE;
                }

                CloseHandle(hHotplugBalloonEvent);
            }
        }
    }

    EnableShellIcon = ServiceEnabled && HotPlugInit(hWnd);

    HotPlugShowNotifyIcon(hWnd, EnableShellIcon);

    return EnableShellIcon;
}

DWORD
HotPlugEjectDevice_Thread(
   LPVOID pThreadParam
   )
{
    DEVNODE DevNode = (DEVNODE)(ULONG_PTR)pThreadParam;
    CONFIGRET ConfigRet;

    ConfigRet = CM_Request_Device_Eject_Ex(DevNode,
                                           NULL,
                                           NULL,
                                           0,
                                           0,
                                           NULL);

    //
    // Set the hEjectEvent so that the right-click popup menu will work again now that we are finished
    // ejecting/stopping the device.
    //
    SetEvent(hEjectEvent);

    SetLastError(ConfigRet);
    return (ConfigRet == CR_SUCCESS);
}

void
HotPlugEjectDevice(
    HWND hwnd,
    DEVNODE DevNode
    )
{
    DWORD ThreadId;

    //
    // Reset the hEjectEvent so that the user can't bring up the right-click popup menu when
    // we are in the process of ejecting/stopping a device.
    //
    ResetEvent(hEjectEvent);

    //
    // We need to have stobject.dll eject/stop the device on a separate thread because if
    // we remove a device that stobject.dll listens for (battery, sound, ect.) we will cause
    // a large delay and the eject/stop could end up getting vetoed because the stobject.dll
    // code could not be processed and release it's handles because we were locking up the main
    // thread.
    //
    CreateThread(NULL,
                 0,
                 (LPTHREAD_START_ROUTINE)HotPlugEjectDevice_Thread,
                 (LPVOID)(ULONG_PTR)DevNode,
                 0,
                 &ThreadId
                 );
}

void
HotPlug_Timer(
   HWND hwnd
   )
/*++

Routine Description:

   Hotplug Timer msg handler, used to invoke hmenuEject for single Left click

Arguments:

   hDlg - Our Window handle


Return Value:

   BOOL Returns TRUE if active.


--*/


{
    POINT pt;
    UINT MenuIndex;
    PHOTPLUGDEVICES HotPlugDevicesList;
    PHOTPLUGDEVICES SingleHotPlugDevice;
    TCHAR  MenuDeviceName[MAX_PATH+64];
    TCHAR  Format[64];


    KillTimer(hwnd, HOTPLUG_TIMER_ID);

    if (!HotPlugInitialized) {

        PostMessage(hwnd, STWM_ENABLESERVICE, 0, TRUE);
        return;
    }

    //
    // We only want to create the popup menu if the hEjectEvent is signaled.  If it is not
    // signaled then we are in the middle of ejecting/stopping a device on a separate thread
    // and don't want to allow the user to bring up the menu until we are finished with that
    // device.
    //
    if (!hEjectEvent ||
        WaitForSingleObject(hEjectEvent, 0) == WAIT_OBJECT_0) {

        //
        // We are not in the middle of ejecting/stopping a device so we should display the popup
        // menu.
        //
        HMENU hmenuEject = CreatePopupMenu();
        if (hmenuEject)
        {

            SetForegroundWindow(hwnd);
            GetCursorPos(&pt);


            //
            // Add each of the removable devices in the list to the menu.
            //

            if (!AddHotPlugDevices(&HotPlugDevicesList)) {
                DestroyMenu(hmenuEject);
                return;
            }

            SingleHotPlugDevice = HotPlugDevicesList;


            //
            // Add a title and separator at the top of the menu.
            //

            LoadString(g_hInstance,
                       IDS_HPLUGMENU_REMOVE,
                       Format,
                       sizeof(Format)/sizeof(TCHAR)
                       );


            MenuIndex = 1;

            while (SingleHotPlugDevice) {

                wsprintf(MenuDeviceName, Format, SingleHotPlugDevice->DevName);
                AppendMenu(hmenuEject, MF_STRING, MenuIndex, MenuDeviceName);
                SingleHotPlugDevice->EjectMenuIndex = MenuIndex++;
                SingleHotPlugDevice = SingleHotPlugDevice->Next;
            }


            MenuIndex = TrackPopupMenu(hmenuEject,
                                       TPM_LEFTBUTTON | TPM_RETURNCMD | TPM_NONOTIFY,
                                       pt.x,
                                       pt.y,
                                       0,
                                       hwnd,
                                       NULL
                                       );


            // now do an eject!

            SingleHotPlugDevice = HotPlugDevicesList;

            while (SingleHotPlugDevice) {

                if (MenuIndex == SingleHotPlugDevice->EjectMenuIndex) {
                    DEVNODE DevNode;

                    if (CM_Locate_DevNode(&DevNode,
                                          SingleHotPlugDevice->DevInstanceId,
                                          0) == CR_SUCCESS) {
                        HotPlugEjectDevice(hwnd, DevNode);
                    }
                    break;
                }

                SingleHotPlugDevice = SingleHotPlugDevice->Next;
            }


            if (!SingleHotPlugDevice) {

                SetIconFocus(hwnd, STWM_NOTIFYHOTPLUG);
            }

            FreeHotPlugDevicesList(&HotPlugDevicesList);
        }

        DestroyMenu(hmenuEject);
    }

    return;
}

void
HotPlugContextMenu(
   HWND hwnd
   )
{
    POINT pt;
    HMENU ContextMenu;
    UINT MenuIndex;
    TCHAR Buffer[MAX_PATH];


    ContextMenu = CreatePopupMenu();
    if (!ContextMenu) {
        return;
    }

    SetForegroundWindow(hwnd);
    GetCursorPos(&pt);

    LoadString(g_hInstance, IDS_HPLUGMENU_PROPERTIES, Buffer, sizeof(Buffer)/sizeof(TCHAR));
    AppendMenu(ContextMenu, MF_STRING,IDS_HPLUGMENU_PROPERTIES, Buffer);

    SetMenuDefaultItem(ContextMenu, IDS_HPLUGMENU_PROPERTIES, FALSE);


    MenuIndex = TrackPopupMenu(ContextMenu,
                               TPM_RIGHTBUTTON | TPM_RETURNCMD | TPM_NONOTIFY,
                               pt.x,
                               pt.y,
                               0,
                               hwnd,
                               NULL
                               );



    switch (MenuIndex) {
        case IDS_HPLUGMENU_PROPERTIES:
            SysTray_RunProperties(IDS_RUNHPLUGPROPERTIES);
            break;

    }

    DestroyMenu(ContextMenu);

    SetIconFocus(hwnd, STWM_NOTIFYHOTPLUG);

    return;
}

void
HotPlug_Notify(
   HWND hwnd,
   WPARAM wParam,
   LPARAM lParam
   )

{
    switch (lParam) {

    case WM_RBUTTONUP:
        HotPlugContextMenu(hwnd);
        break;

    case WM_LBUTTONDOWN:
        SetTimer(hwnd, HOTPLUG_TIMER_ID, GetDoubleClickTime()+100, NULL);
        break;

    case WM_LBUTTONDBLCLK:
        KillTimer(hwnd, HOTPLUG_TIMER_ID);
        SysTray_RunProperties(IDS_RUNHPLUGPROPERTIES);
        break;
    }

    return;
}

int
HotPlug_DeviceChangeTimer(
   HWND hDlg
   )
{
    BOOL bAnyHotPlugDevices, bNewHotPlugDevice, bWarnUser;
    BOOL bRemovableDeviceAdded, bRemovableDeviceRemoved, bRemovableDeviceFailure;
    HDEVINFO hNewDeviceInfoSet;

    KillTimer(hDlg, HOTPLUG_DEVICECHANGE_TIMERID);

    //
    // If the service is not enabled then don't bother because the icon will NOT
    // be shown, sounds will not be played, etc.  (see notes for
    // HotplugPlaySoundThisSession).
    //
    if (!ServiceEnabled) {
        goto Clean0;
    }

    //
    // Get a new "current" list of all devices present in the system.
    //
    hNewDeviceInfoSet = SetupDiGetClassDevs(NULL,
                                            NULL,
                                            NULL,
                                            DIGCF_ALLCLASSES | DIGCF_PRESENT);

    //
    // Update the list of removable devices, based on the new current list.
    //
    UpdateRemovableDeviceList(hNewDeviceInfoSet,
                              &bRemovableDeviceAdded,
                              &bRemovableDeviceRemoved,
                              &bRemovableDeviceFailure);

#if SOUNDS
    //
    // If we should play sounds in this session, check if any removable devices
    // were either added or removed.
    //
    if (HotplugPlaySoundThisSession()) {
        //
        // We'll only play one sound at a time, so if we discover that multiple
        // events have happened simultaneously, let failure override arrival,
        // which overrides removal.  This way the user receives notification of
        // the most important event.
        //
        if (bRemovableDeviceFailure) {
            PlaySound(DEVICE_FAILURE_SOUND, NULL, SND_ASYNC|SND_NODEFAULT);
        } else if (bRemovableDeviceAdded) {
            PlaySound(DEVICE_ARRIVAL_SOUND, NULL, SND_ASYNC|SND_NODEFAULT);
        } else if (bRemovableDeviceRemoved) {
            PlaySound(DEVICE_REMOVAL_SOUND, NULL, SND_ASYNC|SND_NODEFAULT);
        }
    }
#endif // SOUNDS

    //
    // Let's see if we have any hot plug devices, which means we need to
    // show the systray icon.  We also want to know about new hotplug
    // devices that just arrived, so we compare the set of removable devices
    // (which we just updated) against the old current set of devices in the
    // system.
    //
    bAnyHotPlugDevices = AnyHotPlugDevices(g_hRemovableDeviceInfoSet,
                                           g_hCurrentDeviceInfoSet,
                                           &bNewHotPlugDevice,
                                           &bWarnUser);


    if (bAnyHotPlugDevices) {
        //
        // We have some hotplug devices so make sure the icon is shown and show
        // the balloon info if necessary.
        //

        //
        // If the hotplug icon is not being shown, then show it.
        //
        if (!ShowShellIcon) {
            HotPlugShowNotifyIcon(hDlg, TRUE);
        }

#if BUBBLES
        //
        // If we have any new hotplug devices then show the balloon info.
        //
        if (bNewHotPlugDevice && bWarnUser) {

            NOTIFYICONDATA nid = { sizeof(nid), hDlg, 0 };

            try {

                EnterCriticalSection(&g_BubbleCrit);

                if ((hDockEventTimer == NULL) ||
                    (WaitForSingleObject(hDockEventTimer, 0) == WAIT_OBJECT_0)) {

                    nid.uID = STWM_NOTIFYHOTPLUG;
                    nid.uFlags = NIF_INFO;
                    nid.uTimeout = 10000;
                    nid.dwInfoFlags = NIIF_INFO;
                    LoadString(g_hInstance,
                               IDS_HOTPLUG_TITLE,
                               nid.szInfoTitle,
                               sizeof(nid.szInfoTitle) / sizeof(TCHAR)
                               );
                    LoadString(g_hInstance,
                               IDS_HOTPLUG_INSERT_INFO,
                               nid.szInfo,
                               sizeof(nid.szInfo) / sizeof(TCHAR)
                               );

                    Shell_NotifyIcon(NIM_MODIFY, &nid);
                }
            }
            finally
                {
                    LeaveCriticalSection(&g_BubbleCrit);
                }
        }
#endif // BUBBLES

    } else {
        //
        // There are NOT any hot plug devices so if the icon is still being
        // shown, then hide it.
        //
        if (ShowShellIcon) {
            HotPlugShowNotifyIcon(hDlg, FALSE);
        }
    }

    //
    // Delete the old current list of devices and set it
    // (g_hCurrentDeviceInfoSet) to the new current list.
    //
    if (g_hCurrentDeviceInfoSet != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(g_hCurrentDeviceInfoSet);
    }

    g_hCurrentDeviceInfoSet = hNewDeviceInfoSet;

 Clean0:

    return 0;
}

void
HotPlug_DeviceChange(
   HWND hwnd,
   WPARAM wParam,
   LPARAM lParam
   )

/*++

Routine Description:

    Handle WM_DEVICECHANGE messages.

Arguments:

   hDlg        - Window handle of Dialog

   wParam  - DBT Event

   lParam  - DBT event notification type.

Return Value:

--*/

{
    LARGE_INTEGER liDelayTime;
    NOTIFYICONDATA nid;
    BOOL bPresent;

    switch(wParam) {

        case DBT_DEVNODES_CHANGED:
            //
            // To avoid deadlock with CM, a timer is started and the timer
            // message handler does the real work.
            //
            SetTimer(hwnd, HOTPLUG_DEVICECHANGE_TIMERID, 100, NULL);
            break;

        case DBT_CONFIGCHANGED:
            //
            // A docking event (dock, undock, surprise undock, etc) has
            // occured.
            //
#if SOUNDS
            //
            // Play a sound for hardware profile changes if we're supposed to.
            //
            if (HotplugPlaySoundThisSession()) {
                if ((CM_Is_Dock_Station_Present(&bPresent) == CR_SUCCESS) &&
                    (bPresent)) {
                    //
                    // If there is a dock present, we most-likely just docked
                    // (though we may have just ejected one of many docks), so
                    // play an arrival.
                    //
                    PlaySound(DEVICE_ARRIVAL_SOUND, NULL, SND_ASYNC|SND_NODEFAULT);
                } else {
                    //
                    // If no dock is present we just undocked, so play a
                    // removal.
                    //
                    PlaySound(DEVICE_REMOVAL_SOUND, NULL, SND_ASYNC|SND_NODEFAULT);
                }
            }
#endif // SOUNDS

#if BUBBLES
            //
            // Make sure no bubbles appear for devices in a newly
            // attached dock.
            //
            if ((CM_Is_Dock_Station_Present(&bPresent) != CR_SUCCESS) ||
                (!bPresent)) {

                //
                // We don't suppress if something appears after an undock.
                //
                break;
            }

            try {

                EnterCriticalSection(&g_BubbleCrit);

                if (hDockEventTimer) {

                    liDelayTime.QuadPart = BUBBLE_SUPPRESSION_TIME * -10000000;
                    SetWaitableTimer(
                        hDockEventTimer,
                        &liDelayTime,
                        0,
                        NULL,
                        NULL,
                        FALSE
                        );
                }

                //
                // Slap down any bubble that might currently be displayed.
                //
                nid.cbSize = sizeof(nid);
                nid.hWnd = hwnd;
                nid.uID = STWM_NOTIFYHOTPLUG;
                nid.uFlags = 0;
                nid.uTimeout = 0;
                nid.dwInfoFlags = 0;
                Shell_NotifyIcon(NIM_MODIFY, &nid);

            }
            finally
            {
                LeaveCriticalSection(&g_BubbleCrit);
            }
#endif // BUBBLES
            break;

        default:
            break;
    }

    return;
}

void
HotPlug_WmDestroy(
    HWND hWnd
    )
{
    if (hEjectEvent) {
        CloseHandle(hEjectEvent);
    }

#if BUBBLES
    if (hDockEventTimer) {

        CloseHandle(hDockEventTimer);
    }

    if (hSurpriseUndockEventTimer) {

        CloseHandle(hSurpriseUndockEventTimer);
    }

    try {

        DeleteCriticalSection(&g_BubbleCrit);

    } except(EXCEPTION_EXECUTE_HANDLER) {

        NOTHING;
    }
#endif // BUBBLES

    if (g_hCurrentDeviceInfoSet != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(g_hCurrentDeviceInfoSet);
        g_hCurrentDeviceInfoSet = INVALID_HANDLE_VALUE;
    }

    if (g_hRemovableDeviceInfoSet != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(g_hRemovableDeviceInfoSet);
        g_hRemovableDeviceInfoSet = INVALID_HANDLE_VALUE;
    }
}

void
HotPlug_SessionChange(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // If our console session is getting disconnected then disable our service
    // since we don't need to do any work if no UI is being displayed.
    //
    // If our console session is getting connected then re-enable our service.
    //
    if ((wParam == WTS_CONSOLE_CONNECT) ||
        (wParam == WTS_REMOTE_CONNECT)) {
        HotPlug_CheckEnable(hWnd, TRUE);
    } else if ((wParam == WTS_CONSOLE_DISCONNECT) ||
               (wParam == WTS_REMOTE_DISCONNECT)) {
        HotPlug_CheckEnable(hWnd, FALSE);
    }
}


#if SOUNDS

BOOL
IsFastUserSwitchingEnabled(
    VOID
    )

/*++

Routine Description:

    Checks to see if Terminal Services Fast User Switching is enabled.  This is
    to check if we should use the physical console session for UI dialogs, or
    always use session 0.

    Fast User Switching exists only on workstation product version, where terminal
    services are available, when AllowMultipleTSSessions is set.

    On server and above, or when multiple TS users are not allowed, session 0
    can only be attached remotely be special request, in which case it should be
    considered the "Console" session.

Arguments:

    None.

Return Value:

    Returns TRUE if Fast User Switching is currently enabled, FALSE otherwise.

--*/

{
    static BOOL bVerified = FALSE;
    static BOOL bIsTSWorkstation = FALSE;

    HKEY   hKey;
    ULONG  ulSize, ulValue;
    BOOL   bFusEnabled;

    //
    // Verify the product version if we haven't already.
    //
    if (!bVerified) {
        OSVERSIONINFOEX osvix;
        DWORDLONG dwlConditionMask = 0;

        ZeroMemory(&osvix, sizeof(OSVERSIONINFOEX));
        osvix.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

        osvix.wProductType = VER_NT_WORKSTATION;
        VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_LESS_EQUAL);

        osvix.wSuiteMask = VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS;
        VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

        if (VerifyVersionInfo(&osvix,
                              VER_PRODUCT_TYPE | VER_SUITENAME,
                              dwlConditionMask)) {
            bIsTSWorkstation = TRUE;
        }

        bVerified = TRUE;
    }

    //
    // Fast user switching (FUS) only applies to the Workstation product where
    // Terminal Services are enabled (i.e. Personal, Professional).
    //
    if (!bIsTSWorkstation) {
        return FALSE;
    }

    //
    // Check if multiple TS sessions are currently allowed.  We can't make this
    // info static because it can change dynamically.
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                     0,
                     KEY_READ,
                     &hKey) != ERROR_SUCCESS) {
        return FALSE;
    }

    ulValue = 0;
    ulSize = sizeof(ulValue);
    bFusEnabled = FALSE;

    if (RegQueryValueEx(hKey,
                        TEXT("AllowMultipleTSSessions"),
                        NULL,
                        NULL,
                        (LPBYTE)&ulValue,
                        &ulSize) == ERROR_SUCCESS) {
        bFusEnabled = (ulValue != 0);
    }
    RegCloseKey(hKey);

    return bFusEnabled;

} // IsFastUserSwitchingEnabled

BOOL
HotplugPlaySoundThisSession(
    VOID
    )

/*++

Routine Description:

    This routine determines whether a sound should be played in the current
    session.

Arguments:

    None.

Return Value:

    Returns TRUE if sounds should be played in this session.

Notes:

    The user-mode plug and play manager (umpnpmgr.dll) implements the following
    behavior for UI dialogs:

    * When Fast User Switching is enabled, only the physical Console session
      is used for UI dialogs.

    * When Fast User Switching is not enabled, only Session 0 is used for UI
      dialogs.

    Since sound events require no user interaction there is no problem with
    multiple sessions responding to these events simultaneously.

    We should *always* play a sound on the physical console when possible, and
    adopt a behavior similar to umpnpmgr for for the non-Fast User Switching
    case, such that session 0 will also play sound events when possible because
    it should be treated somewhat special in the non-FUS case...

    ... BUT, since we disable the service altogether if the session is remote
    and the user doesn't have permission to eject hotplug devices (so we don't
    show the icon), we won't even respond to DBT_DEVNODES_CHANGED events, and
    consequently won't play sound.  We could actually turn this on just by
    allowing those events to be processed when the services is disabled, but
    this function is successful.  Since the idea of allowing hardware events on
    remote session 0 without FUS is really just for remote management, then it's
    probably ok that we don't play sounds for a user that can't manage hardware.

--*/

{
    //
    // Always play sound events on the physical console.
    //
    if (IsConsoleSession()) {
        return TRUE;
    }

    //
    // If fast user switching is not enabled, play sound events on the
    // pseudo-console (Session 0) also.
    //
    if ((IsPseudoConsoleSession()) &&
        (!IsFastUserSwitchingEnabled())) {
        return TRUE;
    }

    //
    // Otherwise, no sound.
    //
    return FALSE;

} // HotplugPlaySoundThisSession

#endif // SOUNDS


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\power.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*
*  TITLE:       POWER.C
*
*  VERSION:     2.0
*
*  AUTHOR:      TCS/RAL
*
*  DATE:        08 Feb 1994
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  08 Feb 1994 TCS Original implementation.
*  11 Nov 1994 RAL Converted from batmeter to systray
*  11 Aug 1995 JEM Split batmeter functions into power.c & minor enahncements
*  23 Oct 1995 Shawnb UNICODE Enabled
*  24 Jan 1997 Reedb ACPI power management, common battery meter code.
*
*******************************************************************************/

#include "stdafx.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <initguid.h>
#include <ntpoapi.h>
#include <poclass.h>

#include "systray.h"

#include "batmeter.h"
#include "powrprof.h"
#include "powercfp.h"

#define UPDATE_REGISTRY TRUE
#define NO_REGISTRY_UPDATE FALSE

// Structure to manage the power profile enum proc parameters.
typedef struct _POWER_PROFILE_ENUM_PROC_PARAMS
{
    UINT    uiCurActiveIndex;
    HMENU   hMenu;
    UINT    uiCurActiveID;
} POWER_PROFILE_ENUM_PROC_PARAMS, *PPOWER_PROFILE_ENUM_PROC_PARAMS;


// G L O B A L  D A T A -------------------------------------------------------
BOOL    g_bPowerEnabled;      // Tracks the power service state.
UINT    g_uiPowerSchemeCount; // Number of power schemes, left context menu.
HMENU   g_hMenu[2];           // Context menus.

// BatMeter creation parameters.
HWND    g_hwndBatMeter;
BOOL    g_bShowMulti;
HWND    g_hwndBatMeterFrame;

GLOBAL_POWER_POLICY g_gpp;

// Context sensitive help must be added to the windows.hlp file,
// for now we will use this dummy array define. Remove when windows.hlp updated.

#define IDH_POWERCFG_ENABLEMULTI IDH_POWERCFG_POWERSTATUSBAR

const DWORD g_ContextMenuHelpIDs[] = {
    IDC_POWERSTATUSGROUPBOX,    IDH_COMM_GROUPBOX,
    IDC_ENABLEMETER,            IDH_POWERCFG_ENABLEMETER,
    IDC_ENABLEMULTI,            IDH_POWERCFG_ENABLEMULTI,
    0, 0
};

// Used to track registration for WM_DEVICECHANGED message.
HDEVNOTIFY g_hDevNotify;

/*******************************************************************************
*
*  RunningOffLine
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN RunningOffLine(void)
{
   SYSTEM_POWER_STATUS  sps;
   BOOLEAN              bRet = FALSE;

   if (GetSystemPowerStatus(&sps)) {
      if (sps.ACLineStatus == 0) {
         bRet = TRUE;
      }
   }
   return bRet;
}

/*----------------------------------------------------------------------------
 * Power_OnCommand
 *
 * Process WM_COMMAND msgs for the battery meter dialog.
 *
 *----------------------------------------------------------------------------*/

void
Power_OnCommand(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    BOOL  Checked;
    DWORD dwMask;
    UINT  uiCommandID = GET_WM_COMMAND_ID(wParam, lParam);

    switch (uiCommandID) {

        case IDC_ENABLEMETER:
            dwMask = EnableSysTrayBatteryMeter;
            goto DoUpdateFlags;

        case IDC_ENABLEMULTI:
            dwMask = EnableMultiBatteryDisplay;
            goto DoUpdateFlags;

DoUpdateFlags:
            Checked = (IsDlgButtonChecked(hWnd, uiCommandID) == BST_CHECKED);
            Update_PowerFlags(dwMask, Checked);
            if (uiCommandID == IDC_ENABLEMETER) {
                PowerCfg_Notify();
                SysTray_EnableService(STSERVICE_POWER, g_gpp.user.GlobalFlags & EnableSysTrayBatteryMeter);
            }
            else {
                g_bShowMulti = Checked;
                Power_UpdateStatus(hWnd, NIM_MODIFY, TRUE);
            }
            break;

        case IDCANCEL:
            EndDialog(hWnd, wParam);
            break;

        default:
            // Notify battery meter of enter key events.
            if (HIWORD(wParam) == BN_CLICKED) {
                SendMessage(g_hwndBatMeter, WM_COMMAND, wParam, lParam);
            }
    }
}

/*******************************************************************************
*
*  Power_OnPowerBroadcast
*
*  DESCRIPTION:
*   Process WM_POWERBROADCAS message for the battery meter dialog.
*
*  PARAMETERS:
*
*******************************************************************************/

void Power_OnPowerBroadcast(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
   if (wParam == PBT_APMPOWERSTATUSCHANGE) {

      // If the power icon is not showing (power service disabled) and
      // we are running on batteries, enable the systray power service.
      if (!g_bPowerEnabled && RunningOffLine()) {
         PostMessage(hWnd, STWM_ENABLESERVICE, STSERVICE_POWER, TRUE);
      } else

      // If the power icon is showing (power service enabled) and
      // we are not running on batteries, disable the systray power service.
      if (g_bPowerEnabled && !RunningOffLine()) {
         PostMessage(hWnd, STWM_ENABLESERVICE, STSERVICE_POWER, FALSE);
      }

      // Don't change the state of the power service, just update the icon.
      Power_UpdateStatus(hWnd, NIM_MODIFY, FALSE);
   }
}

/*******************************************************************************
*
*  Power_OnDeviceChange
*
*  DESCRIPTION:
*   Process WM_DEVICECHANGE message for the battery meter dialog.
*
*  PARAMETERS:
*
*******************************************************************************/

void Power_OnDeviceChange(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
   //
   // Only listen to the WM_DEVICECHANGE if it is for GUID_DEVICE_BATTERY and
   // it is a DBT_DEVICEARRIVAL, DBT_DEVICEREMOVECOMPLETE, or DBT_DEVICEQUERYREMOVEFAILED.
   //
   if (((wParam == DBT_DEVICEARRIVAL) ||
       (wParam == DBT_DEVICEREMOVECOMPLETE) ||
       (wParam == DBT_DEVICEQUERYREMOVEFAILED)) &&
       (lParam) &&
       (((PDEV_BROADCAST_DEVICEINTERFACE)lParam)->dbcc_devicetype == DBT_DEVTYP_DEVICEINTERFACE) &&
       (IsEqualGUID(&((PDEV_BROADCAST_DEVICEINTERFACE)lParam)->dbcc_classguid, &GUID_DEVICE_BATTERY))) {

      // Make sure BatMeter has been initialized.
      if (g_hwndBatMeterFrame) {
         if (g_hwndBatMeter) {
            g_hwndBatMeter = DestroyBatMeter(g_hwndBatMeter);
         }
         g_hwndBatMeter = CreateBatMeter(hWnd,
                                         g_hwndBatMeterFrame,
                                         g_bShowMulti,
                                         NULL);
         InvalidateRect(hWnd, NULL, TRUE);
      }
   }
}

/*******************************************************************************
*
*  Power_OnActivate
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN Power_OnActivate(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
   if (g_hwndBatMeter) {
      SendMessage(g_hwndBatMeter, WM_ACTIVATE, wParam, lParam);
      return TRUE;
   }
   return FALSE;
}

/*******************************************************************************
*
*  PowerProfileEnumProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

#define POWERMENU_SCHEME 300

BOOLEAN CALLBACK PowerProfileEnumProc(
    UINT                    uiID,
    DWORD                   dwNameSize,
    LPTSTR                  lpszName,
    DWORD                   dwDescSize,
    LPTSTR                  lpszDesc,
    PPOWER_POLICY           ppp,
    LPARAM                  lParam
)
{
    PPOWER_PROFILE_ENUM_PROC_PARAMS pppepp;
    MENUITEMINFO mii;

    if ((pppepp = (PPOWER_PROFILE_ENUM_PROC_PARAMS) lParam) == NULL) {
        return FALSE;
    }

    AppendMenu(pppepp->hMenu, MF_STRING,
               POWERMENU_SCHEME + g_uiPowerSchemeCount, lpszName);

    // Store the power scheme ID in the menu info.
    mii.cbSize = sizeof(mii);
    mii.fMask  = MIIM_DATA;
    mii.dwItemData = uiID;
    SetMenuItemInfo(pppepp->hMenu,
                    POWERMENU_SCHEME + g_uiPowerSchemeCount,
                    FALSE, &mii);

    if (uiID == pppepp->uiCurActiveID) {
        pppepp->uiCurActiveIndex = POWERMENU_SCHEME + g_uiPowerSchemeCount;
    }

    g_uiPowerSchemeCount++;
    return TRUE;
}

/*----------------------------------------------------------------------------
 * GetPowerMenu()
 *
 * Build a menu containing battery meter/power selections.
 *
 *----------------------------------------------------------------------------*/

#define POWERMENU_OPEN          100
#define POWERMENU_PROPERTIES    101

#define POWERMENU_ENABLEWARN    200
#define POWERMENU_SHOWTIME      201
#define POWERMENU_SHOWPERCENT   202


HMENU
GetPowerMenu(LONG l)
{
    LPTSTR  lpszMenu;
    UINT    uiCurActiveID;

    POWER_PROFILE_ENUM_PROC_PARAMS  ppepp;

    if (l > 0)
    {
        // Right button menu -- can change, rebuild each time.
       if (g_hMenu[0])
       {
           DestroyMenu(g_hMenu[0]);
       }

       g_hMenu[1] = CreatePopupMenu();

       // Properties for Power, PowerCfg.
       if ((lpszMenu = LoadDynamicString(IDS_PROPFORPOWER)) != NULL)
       {
           AppendMenu(g_hMenu[1], MF_STRING, POWERMENU_PROPERTIES, lpszMenu);
           DeleteDynamicString(lpszMenu);
       }

       // If we have a battery meter, add it's menu item and set as default.
       if (g_hwndBatMeter) {
           if ((lpszMenu = LoadDynamicString(IDS_OPEN)) != NULL)
           {
               AppendMenu(g_hMenu[1], MF_STRING, POWERMENU_OPEN, lpszMenu);
               DeleteDynamicString(lpszMenu);
           }
           // Open BatMeter is default (double click action)
           SetMenuDefaultItem(g_hMenu[1], POWERMENU_OPEN, FALSE);
       }
       else {
           // Use open PowerCfg as default (double click action)
           SetMenuDefaultItem(g_hMenu[1], POWERMENU_PROPERTIES, FALSE);
       }
    }

    // Left button menu -- can change, rebuild each time.
    if (g_hMenu[0])
    {
        DestroyMenu(g_hMenu[0]);
    }

    g_hMenu[0] = CreatePopupMenu();

    // Get the currently active power policies.
    if (GetActivePwrScheme(&uiCurActiveID)) {
        g_uiPowerSchemeCount = 0;
        ppepp.hMenu = g_hMenu[0];
        ppepp.uiCurActiveID = uiCurActiveID;
        EnumPwrSchemes(PowerProfileEnumProc, (LPARAM)&ppepp);

        // Check the currently active menu item.
        CheckMenuRadioItem(g_hMenu[0],
                           POWERMENU_SCHEME,
                           POWERMENU_SCHEME + g_uiPowerSchemeCount - 1,
                           ppepp.uiCurActiveIndex,
                           MF_BYCOMMAND);
    }
    return g_hMenu[l];
}

/*----------------------------------------------------------------------------
 * Power_Open
 *
 * Update and display the battery meter dialog
 *
 *----------------------------------------------------------------------------*/

void
Power_Open(HWND hWnd)
{
    if (g_hwndBatMeter) {
        SetFocus(GetDlgItem(hWnd, IDC_ENABLEMETER));
        CheckDlgButton(hWnd, IDC_ENABLEMULTI,
                       (g_gpp.user.GlobalFlags & EnableMultiBatteryDisplay) ?
                       BST_CHECKED : BST_UNCHECKED);

        CheckDlgButton(hWnd, IDC_ENABLEMETER,
                       (g_gpp.user.GlobalFlags & EnableSysTrayBatteryMeter) ?
                       BST_CHECKED : BST_UNCHECKED);

        Power_UpdateStatus(hWnd, NIM_MODIFY, FALSE); // show current info
        ShowWindow(hWnd, SW_SHOW);
        SetForegroundWindow(hWnd);
    }
    else {
        SysTray_RunProperties(IDS_RUNPOWERPROPERTIES);
    }
}


/*----------------------------------------------------------------------------
 * DoPowerMenu
 *
 * Create and process a right or left button menu.
 *
 *----------------------------------------------------------------------------*/

void
DoPowerMenu(HWND hwnd, UINT uMenuNum, UINT uButton)
{
    POINT pt;
    UINT iCmd;
    MENUITEMINFO mii;

    SetForegroundWindow(hwnd);
    GetCursorPos(&pt);

    iCmd = (UINT)TrackPopupMenu(GetPowerMenu(uMenuNum),
                          uButton | TPM_RETURNCMD | TPM_NONOTIFY,
                          pt.x, pt.y, 0, hwnd, NULL);

    if (iCmd >= POWERMENU_SCHEME) {
        mii.cbSize = sizeof(mii);
        mii.fMask  = MIIM_DATA;
        if (GetMenuItemInfo(g_hMenu[uMenuNum], iCmd, FALSE, &mii)) {
            SetActivePwrScheme((UINT)mii.dwItemData, NULL, NULL);
            PowerCfg_Notify();
        }
    }
    else {
        switch (iCmd) {

            case POWERMENU_OPEN:
                Power_Open(hwnd);
                break;

            case POWERMENU_PROPERTIES:
                SysTray_RunProperties(IDS_RUNPOWERPROPERTIES);
                break;

            case 0:
                // The user cancelled the menu without choosing.
                SetIconFocus(hwnd, STWM_NOTIFYPOWER);
                break;
        }
    }
}


/*----------------------------------------------------------------------------
 * Power_Notify
 *
 * Handle a notification from the power tray icon.
 *
 *----------------------------------------------------------------------------*/

#define PN_TIMER_CLEAR  0
#define PN_TIMER_SET    1
#define PN_DBLCLK       2

UINT g_uiTimerSet = PN_TIMER_CLEAR;
LARGE_INTEGER g_liHoverUpdateTime = {0,0};

void Power_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    LARGE_INTEGER liPerformanceFrequency;
    LARGE_INTEGER liPerformanceCount;

    switch (lParam)
    {
    case WM_RBUTTONUP:
        DoPowerMenu(hWnd, 1, TPM_RIGHTBUTTON);  // right button menu
        break;

    case WM_LBUTTONUP:
        // start timing for left button menu
        if (g_uiTimerSet == PN_TIMER_CLEAR) {
            SetTimer(hWnd, POWER_TIMER_ID, GetDoubleClickTime()+100, NULL);
            g_uiTimerSet = PN_TIMER_SET;
        }
        break;

    case WM_LBUTTONDBLCLK:
        g_uiTimerSet = PN_DBLCLK;
        Power_Open(hWnd);                       // show battery meter dialog
        break;

    case WM_MOUSEMOVE:
        if (QueryPerformanceFrequency (&liPerformanceFrequency)) {
            if (QueryPerformanceCounter (&liPerformanceCount)) {
                // Update no more than once a second
                if ((liPerformanceCount.QuadPart - g_liHoverUpdateTime.QuadPart) >
                    liPerformanceFrequency.QuadPart) {
                    g_liHoverUpdateTime = liPerformanceCount;
                    Power_UpdateStatus(hWnd, NIM_MODIFY, FALSE);
                }
            }
        }
        break;

    }
}

/*-----------------------------------------------------------------------------
 * Power_Timer
 *
 * Execute the left button menu on WM_LBUTTONDOWN time-out.
 *
 *----------------------------------------------------------------------------*/

void Power_Timer(HWND hwnd)
{
    KillTimer(hwnd, POWER_TIMER_ID);
    if (g_uiTimerSet != PN_DBLCLK) {
        DoPowerMenu(hwnd, 0, TPM_LEFTBUTTON);
    }
    g_uiTimerSet = PN_TIMER_CLEAR;
}

/*----------------------------------------------------------------------------
 * Update_PowerFlags
 *
 * Set power flags using powrprof.dll API's.
 *
 *----------------------------------------------------------------------------*/

void Update_PowerFlags(DWORD dwMask, BOOL bEnable)
{
    if (bEnable) {
        g_gpp.user.GlobalFlags |= dwMask;
    }
    else {
        g_gpp.user.GlobalFlags &= ~dwMask;
    }
    WriteGlobalPwrPolicy(&g_gpp);
}

/*----------------------------------------------------------------------------
 * Get_PowerFlags
 *
 * Get power flags using powrprof.dll API's.
 *
 *----------------------------------------------------------------------------*/

DWORD Get_PowerFlags(void)
{
    ReadGlobalPwrPolicy(&g_gpp);
    return g_gpp.user.GlobalFlags;
}


/*******************************************************************************
*
*  BatteryMeterInit
*
*  DESCRIPTION:
*       NOTE: Can be called multiple times.  Simply re-init.
*
*  PARAMETERS:
*     (returns), TRUE if the Battery Meter could be enabled
*
*******************************************************************************/

BOOL PASCAL BatteryMeterInit(HWND hWnd)
{
   PUINT puiBatCount = NULL;

   if (!BatMeterCapabilities(&puiBatCount)) {
      return FALSE;
   }

   if (!g_hwndBatMeter) {
      g_hwndBatMeterFrame = GetDlgItem(hWnd, IDC_STATIC_FRAME_BATMETER);
      g_bShowMulti = g_gpp.user.GlobalFlags & EnableMultiBatteryDisplay;
      g_hwndBatMeter = CreateBatMeter(hWnd,
                                      g_hwndBatMeterFrame,
                                      g_bShowMulti,
                                      NULL);
   }
   return TRUE;
}

/*******************************************************************************
*
*  Power_UpdateStatus
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID PASCAL Power_UpdateStatus(
    HWND hWnd,
    DWORD NotifyIconMessage,
    BOOL bForceUpdate
)
{
   static  TCHAR szTipCache[64];
   static  HICON hIconCache;

   TCHAR   szTip[64];
   LPTSTR  lpsz;
   BATTERY_STATE bs;
   UINT    uiHour, uiMin;

   *szTip = 0;

   bs.ulSize = sizeof(BATTERY_STATE);
   UpdateBatMeter(g_hwndBatMeter,
                  g_bShowMulti,
                  bForceUpdate,
                  &bs);

   // Build up a new tool tip.
   if (g_hwndBatMeter &&
       !(((bs.ulPowerState & BATTERY_POWER_ON_LINE) &&
          !(bs.ulPowerState & BATTERY_CHARGING)))) {

      if (bs.ulBatLifePercent <= 100) {
         if (bs.ulBatLifeTime != (UINT) -1) {
            uiHour = bs.ulBatLifeTime / 3600;
            uiMin  = (bs.ulBatLifeTime % 3600) / 60;
            if (uiHour) {
               lpsz = LoadDynamicString(IDS_TIMEREMFORMATHOUR,
                                        uiHour, uiMin,
                                        bs.ulBatLifePercent);
            }
            else {
               lpsz = LoadDynamicString(IDS_TIMEREMFORMATMIN, uiMin,
                                        bs.ulBatLifePercent);
            }
            if (lpsz) {
               lstrcpy(szTip, lpsz);
               LocalFree(lpsz);
               if (bs.ulPowerState & BATTERY_CHARGING) {
                  if ((lpsz = LoadDynamicString(IDS_CHARGING)) != NULL) {
                     lstrcat(szTip, lpsz);
                     LocalFree(lpsz);
                  }
               }
            }
         }
         else {
            if ((lpsz = LoadDynamicString(IDS_REMAINING,
                                          bs.ulBatLifePercent)) != NULL) {
               lstrcpy(szTip, lpsz);
               LocalFree(lpsz);
               if (bs.ulPowerState & BATTERY_CHARGING) {
                  if ((lpsz = LoadDynamicString(IDS_CHARGING)) != NULL) {
                     lstrcat(szTip, lpsz);
                     LocalFree(lpsz);
                  }
               }
            }
         }
      }
      else {
         lpsz = LoadDynamicString(IDS_UNKNOWN);
         lstrcpy(szTip, lpsz);
         LocalFree(lpsz);
      }
   }
   else {
      lpsz = LoadDynamicString(IDS_ACPOWER);
      lstrcpy(szTip, lpsz);
      LocalFree(lpsz);
   }

   if ((NotifyIconMessage == NIM_ADD)  ||
       (hIconCache != bs.hIconCache16) ||
       (lstrcmp(szTip, szTipCache))) {

      hIconCache = bs.hIconCache16;
      lstrcpy(szTipCache, szTip);

      SysTray_NotifyIcon(hWnd, STWM_NOTIFYPOWER, NotifyIconMessage,
                         hIconCache, szTipCache);
   }
}

/*******************************************************************************
*
*  RegisterForDeviceNotification
*
*  DESCRIPTION:
*    Do onetime registration for WM_DEVICECHANGED.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL RegisterForDeviceNotification(HWND hWnd)
{
   DEV_BROADCAST_DEVICEINTERFACE dbc;

   memset(&dbc, 0, sizeof(DEV_BROADCAST_DEVICEINTERFACE));
   dbc.dbcc_size         = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
   dbc.dbcc_devicetype   = DBT_DEVTYP_DEVICEINTERFACE;
   dbc.dbcc_classguid    = GUID_DEVICE_BATTERY;
   g_hDevNotify = RegisterDeviceNotification(hWnd,
                                             &dbc,
                                             DEVICE_NOTIFY_WINDOW_HANDLE);
   if (!g_hDevNotify) {
      return FALSE;
   }
   return TRUE;
}

/*******************************************************************************
*
*  Power_WmDestroy
*
*  DESCRIPTION:
*
*
*  PARAMETERS:
*
*******************************************************************************/

void Power_WmDestroy(HWND hWnd)
{
   if (g_hDevNotify) {
      UnregisterDeviceNotification(g_hDevNotify);
      g_hDevNotify = NULL;
   }
}

/*******************************************************************************
*
*  Power_CheckEnable
*
*  DESCRIPTION:
*   Return TRUE if the power service icon was enabled.
*        Can be called multiple times.  Simply re-init.
*
*  PARAMETERS:
*     bSvcEnabled - Request to enable/disable power service on tray.
*
*******************************************************************************/

BOOL Power_CheckEnable(HWND hWnd, BOOL bSvcEnable)
{
   static BOOL bRegisteredForDC = FALSE;

   // Is there any reason to display the systray power icon?
   if (!PowerCapabilities()) {
      return FALSE;
   }

   // Do onetime registration for WM_DEVICECHANGED.
   if (!bRegisteredForDC) {
      bRegisteredForDC = RegisterForDeviceNotification(hWnd);
   }

   // Get current battery meter flags from the registry
   Get_PowerFlags();

   // Are we running on battery power or has the user set
   // the systray power icon to always on? If so, force enable.
   if ((g_gpp.user.GlobalFlags & EnableSysTrayBatteryMeter) ||
       (RunningOffLine())) {
      bSvcEnable = TRUE;
   }
   else {
      bSvcEnable = FALSE;
   }

   // Set the power service state.
   if (bSvcEnable) {
      if (g_bPowerEnabled) {
         Power_UpdateStatus(hWnd, NIM_MODIFY, FALSE);
      }
      else {
         BatteryMeterInit(hWnd);
         Power_UpdateStatus(hWnd, NIM_ADD, FALSE);
      }
      g_bPowerEnabled = TRUE;
   }
   else {
      SysTray_NotifyIcon(hWnd, STWM_NOTIFYPOWER, NIM_DELETE, NULL, NULL);
      g_bPowerEnabled = FALSE;
   }
   return g_bPowerEnabled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by systray.rc
//
#define IDC_NONOTIFICATIONS             1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        112
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\stdafx.h ===
// Global Headers
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <regstr.h>

#define NOPOWERSTATUSDEFINES

#include <mmsystem.h>
#include <shellapi.h>
#include <shlapip.h>
#include <commctrl.h>
#include <winuserp.h>
#include "pccrdapi.h"     
#include <systrayp.h>
#include <help.h>         
#include <dbt.h>
#include <ntpoapi.h>
#include <poclass.h>
#include <cscuiext.h>

#include <objbase.h>
#include <docobj.h>
#include <shlwapi.h>
#include <shlobj.h>
#include <shlobjp.h>

#include <dbt.h>
#include <shfusion.h>

// Global vars
extern long g_cLocks;
extern long g_cComponents;
extern HINSTANCE g_hinstDll;

// Macros
#ifndef ARRAYSIZE
#define ARRAYSIZE(x)   (sizeof((x))/sizeof((x)[0]))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\print.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    print.cpp

Abstract:

    This module implements the tray icon for printers.

Author:

    Lazar Ivanov (lazari) 17-May-2000 (initial creation)

Revision History:

--*/

#include "stdafx.h"

extern "C" {
#include <systray.h>

typedef BOOL WINAPI fntype_PrintNotifyTrayInit();
typedef BOOL WINAPI fntype_PrintNotifyTrayExit();

}

static HMODULE g_hPrintUI = NULL;
static fntype_PrintNotifyTrayInit *g_pfnPrintNotifyTrayInit = NULL;
static fntype_PrintNotifyTrayExit *g_pfnPrintNotifyTrayExit = NULL;
static LPCITEMIDLIST g_pidlPrintersFolder = NULL;
static UINT g_uPrintNotify = 0;


BOOL Print_SHChangeNotify_Register(HWND hWnd)
{
    if (NULL == g_hPrintUI && NULL == g_pidlPrintersFolder && 0 == g_uPrintNotify)
    {
        g_pidlPrintersFolder = SHCloneSpecialIDList(hWnd, CSIDL_PRINTERS, FALSE);
        if (g_pidlPrintersFolder)
        {
            SHChangeNotifyEntry fsne = {g_pidlPrintersFolder, TRUE};
            g_uPrintNotify = SHChangeNotifyRegister(hWnd, SHCNRF_NewDelivery | SHCNRF_ShellLevel,
                                    SHCNE_CREATE | SHCNE_UPDATEITEM | SHCNE_DELETE,
                                    WM_PRINT_NOTIFY, 1, &fsne);
        }
    }
    return (g_pidlPrintersFolder && g_uPrintNotify);
}

BOOL Print_SHChangeNotify_Unregister()
{
    BOOL bReturn = (g_pidlPrintersFolder && g_uPrintNotify);

    if (g_uPrintNotify)
    {
        SHChangeNotifyDeregister(g_uPrintNotify);
        g_uPrintNotify = 0;
    }

    if (g_pidlPrintersFolder)
    {
        SHFree((void*)g_pidlPrintersFolder);
        g_pidlPrintersFolder = NULL;
    }
    
    return bReturn;
}

LRESULT Print_Notify(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    switch( uMsg )
    {
        case WM_PRINT_NOTIFY:
            {
                LPSHChangeNotificationLock pshcnl = SHChangeNotification_Lock((HANDLE)wParam, (DWORD)lParam, NULL, NULL);
                if (pshcnl)
                {
                    // a print job was printed, init tray code
                    Print_TrayInit();
                    SHChangeNotification_Unlock(pshcnl);
                    lres = 1;
                }
            }
            break;
    }
    return lres;
}

BOOL Print_TrayInit()
{
    BOOL bReturn = FALSE;

    if (!g_hPrintUI)
    {
        g_hPrintUI = LoadLibrary(TEXT("printui.dll"));
        g_pfnPrintNotifyTrayInit = g_hPrintUI ? (fntype_PrintNotifyTrayInit *)GetProcAddress(g_hPrintUI, "PrintNotifyTray_Init") : NULL;
        g_pfnPrintNotifyTrayExit = g_hPrintUI ? (fntype_PrintNotifyTrayInit *)GetProcAddress(g_hPrintUI, "PrintNotifyTray_Exit") : NULL;
    }

    if( g_pfnPrintNotifyTrayInit && g_pfnPrintNotifyTrayExit )
    {
        // initialize print notify code
        bReturn = g_pfnPrintNotifyTrayInit();

        /*
         * temporary solution for bug #175462 until
         * we come up with better solution after Beta1
         *
        if (bReturn)
        {
            // no need to listen further...
            Print_SHChangeNotify_Unregister();
        }
         */
    }

    return bReturn;
}

BOOL Print_TrayExit()
{
    BOOL bReturn = FALSE;

    if( g_hPrintUI && g_pfnPrintNotifyTrayInit && g_pfnPrintNotifyTrayExit )
    {
        // shutdown the print tray notify code
        bReturn = g_pfnPrintNotifyTrayExit();
    }

    // cleanup...
    if( g_hPrintUI )
    {
        g_pfnPrintNotifyTrayInit = NULL;
        g_pfnPrintNotifyTrayExit = NULL;

        FreeLibrary(g_hPrintUI);
        g_hPrintUI = NULL;
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\stobject.cpp ===
#include "stdafx.h"
#include "stobject.h"
#include "systray.h"


#include <initguid.h>
// 7007ACCF-3202-11D1-AAD2-00805FC1270E     CLSID_ConnectionTray
DEFINE_GUID(CLSID_ConnectionTray,                   0x7007ACCF,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);

IOleCommandTarget *g_pctNetShell = NULL;

extern "C"
{
void StartNetShell()
{
    ASSERT(!g_pctNetShell);

    HRESULT hr = CoCreateInstance(CLSID_ConnectionTray, NULL, CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
                            IID_IOleCommandTarget, (void **)&g_pctNetShell);

    if (SUCCEEDED(hr))
    {
        g_pctNetShell->Exec(&CGID_ShellServiceObject, SSOCMDID_OPEN, 0, NULL, NULL);
    }
}

void StopNetShell()
{
    if (g_pctNetShell)
    {
        g_pctNetShell->Exec(&CGID_ShellServiceObject, SSOCMDID_CLOSE, 0, NULL, NULL);
        g_pctNetShell->Release();
        g_pctNetShell = NULL;
    }
}
} // extern C

/************************************************************************************
IUnknown Implementation

************************************************************************************/

HRESULT CSysTray::QueryInterface(REFIID iid, void** ppvObject)
{
    HRESULT hr = S_OK;

    if ((iid == IID_IOleCommandTarget) || (iid == IID_IUnknown))
    {
        *ppvObject = (IOleCommandTarget*) this;
    }
    else
    {
        *ppvObject = NULL;
        hr = E_NOINTERFACE;
    }

    if (hr == S_OK)
    {
        ((IUnknown*) (*ppvObject))->AddRef();
    }

    return hr;
}

ULONG CSysTray::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CSysTray::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    
    return m_cRef;
}

/************************************************************************************
IOleCommandTarget Implementation

************************************************************************************/

HRESULT CSysTray::QueryStatus(const GUID* pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT* pCmdText)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;
 
    if (*pguidCmdGroup == CGID_ShellServiceObject)
    {
        // We like Shell Service Object notifications...
        hr = S_OK;
    }

    return hr;
}

HRESULT CSysTray::Exec(const GUID* pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG* pvaIn, VARIANTARG* pvaOut)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (*pguidCmdGroup == CGID_ShellServiceObject)
    {
        // Handle Shell Service Object notifications here.
        switch (nCmdID)
        {
            case SSOCMDID_OPEN:
                hr = CreateSysTrayThread();
                break;

            case SSOCMDID_CLOSE:
                hr = DestroySysTrayWindow();
                break;

            default:
                hr = S_OK;
                break;
        }
    }

    return hr;
}

/************************************************************************************
Constructor/Destructor Implementation

************************************************************************************/
CSysTray::CSysTray(BOOL fRunTrayOnConstruct)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cLocks);

    if (fRunTrayOnConstruct)
    {
        // We are being called through SHLoadInProc - Launch the systray thread immediately
        CreateSysTrayThread();
    }
}

CSysTray::~CSysTray()
{
    InterlockedDecrement(&g_cLocks);
}

/************************************************************************************
Private Function Implementation

************************************************************************************/

HRESULT CSysTray::CreateSysTrayThread()
{
    HRESULT hr = S_OK;
    HANDLE hThread;
    DWORD dwThreadId;
 
    hThread = CreateThread(NULL, 0, CSysTray::SysTrayThreadProc, NULL, 0, &dwThreadId);
    if (hThread != NULL)
    {
        CloseHandle(hThread);
    }
    else
        hr = E_FAIL;

    return hr;
}

DWORD CSysTray::SysTrayThreadProc(void* lpv)
{
    // We pass a "" for the command line to so that the tray applets dont' start.
    TCHAR szModule[MAX_PATH];

    GetModuleFileName(g_hinstDll, szModule, ARRAYSIZE(szModule));

    HINSTANCE hInstThis = LoadLibrary(szModule);

    int Result = SysTrayMain(g_hinstDll, NULL, TEXT(""), SW_SHOWNORMAL);
    
    FreeLibraryAndExitThread(hInstThis, (DWORD) Result);

    // Never gets here
    return 0; 
}

HRESULT CSysTray::DestroySysTrayWindow()
{
    HWND hExistWnd = FindWindow(SYSTRAY_CLASSNAME, NULL);
    if (hExistWnd) 
    {
        // Destroy the window. Note that we can't use DestroyWindow since
        // the window is on a different thread and DestroyWindow fails.
        SendMessage(hExistWnd, WM_CLOSE, 0, 0);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\stresid.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       BMRESID.H
*
*  VERSION:     2.0
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        20 Feb 1994
*
*  Resource identifiers for the battery meter.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  20 Feb 1994 TCS Original implementation.  Seperated from RESOURCE.H so that
*                  some documentation could be added without AppStudio screwing
*                  it up later.
*
*******************************************************************************/

#ifndef _INC_STRESID
#define _INC_STRESID

//  Main battery meter dialog box.
#define IDD_BATTERYMETER                100

//  Control identifiers of IDD_BATTERYMETER.
#define IDC_STATIC_FRAME_BATMETER       1000
#define IDC_POWERSTATUSGROUPBOX         1001
#define IDC_ENABLEMETER                 1002
#define IDC_ENABLEMULTI                 1003

// Control identifiers for hotplug
#define IDI_HOTPLUG                     210
#define IDS_HOTPLUGTIP                  211
#define IDS_HPLUGMENU_PROPERTIES        215
#define IDS_HPLUGMENU_REMOVE            216
#define IDS_RUNHPLUGPROPERTIES          217
#define IDS_SEPARATOR			        218
#define IDS_DISKDRIVE			        219
#define IDS_DISKDRIVES			        220
#define IDS_DRIVELETTERS		        221
#define IDS_HOTPLUG_TITLE               222
#define IDS_HOTPLUG_INSERT_INFO         223


//  Control identifiers for Volume
#define IDI_VOLUME                      230
#define IDI_MUTE                        231
#define IDS_MMSYSPROPTITLE              233
#define IDS_MMSYSPROPTAB                234

#define IDS_VOLUME                      252
#define IDS_VOLUMEMENU1                 255
#define IDS_VOLUMEMENU2                 256
#define IDS_VOLUMEAPP                   257
#define IDS_MUTED                       258




// Control identifiers for Sticky Keys

#define IDI_STK000                      300
#define IDI_STK001                      301
#define IDI_STK002                      302
#define IDI_STK003                      303
#define IDI_STK004                      304
#define IDI_STK005                      305
#define IDI_STK006                      306
#define IDI_STK007                      307
#define IDI_STK008                      308
#define IDI_STK009                      309
#define IDI_STK00A                      310
#define IDI_STK00B                      311
#define IDI_STK00C                      312
#define IDI_STK00D                      313
#define IDI_STK00E                      314
#define IDI_STK00F                      315

#define IDI_MKTT                        316
#define IDI_MKTB                        317
#define IDI_MKTG                        318
#define IDI_MKBT                        319
#define IDI_MKBB                        320
#define IDI_MKBG                        321
#define IDI_MKGT                        322
#define IDI_MKGB                        323
#define IDI_MKGG                        324
#define IDI_MKPASS                      325

#define IDI_FILTER                      326
// access strings
#define IDS_STICKYKEYS                  330
#define IDS_MOUSEKEYS                   331
#define IDS_FILTERKEYS                  332

#define IDS_PROPFORPOWER                152
#define IDS_OPEN                        153
#define IDS_RUNPOWERPROPERTIES          157
#define IDS_REMAINING                   158
#define IDS_CHARGING                    159
#define IDS_UNKNOWN                     160
#define IDS_ACPOWER                     161
#define IDS_TIMEREMFORMATHOUR           162
#define IDS_TIMEREMFORMATMIN            163

#define IDI_BATTERYPLUG                 200

#endif // _INC_STRESID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\stobject.h ===
#include "stclsid.h"

class CSysTray: public IOleCommandTarget
{
public:
    // IUnknown Implementation
    HRESULT __stdcall QueryInterface(REFIID iid, void** ppvObject);
    ULONG __stdcall AddRef(void);
    ULONG __stdcall Release(void);

    // IOleCommandTarget Implementation
    HRESULT __stdcall QueryStatus(const GUID* pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT* pCmdText);
    HRESULT __stdcall Exec(const GUID* pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG* pvaIn, VARIANTARG* pvaOut);

    CSysTray(BOOL fRunTrayOnConstruct);
    ~CSysTray();

private:
    // Data
    long m_cRef;

private:
    // Functions
    HRESULT CreateSysTrayThread();
    static DWORD WINAPI SysTrayThreadProc(void* lpv);
    HRESULT DestroySysTrayWindow();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\stclsid.h ===
// CLSIDs for my objects

// SysTray - This object creates normally and supports IOleCommandTarget to launch
// the systray thread.
// {35CEC8A3-2BE6-11d2-8773-92E220524153}
DEFINE_GUID(CLSID_SysTray, 
0x35cec8a3, 0x2be6, 0x11d2, 0x87, 0x73, 0x92, 0xe2, 0x20, 0x52, 0x41, 0x53);

// SysTrayInvoker - This guy automatically launches the systray thread as
// soon as he's created; works good with SHLoadInProc
// {730F6CDC-2C86-11d2-8773-92E220524153}
DEFINE_GUID(CLSID_SysTrayInvoker, 
0x730f6cdc, 0x2c86, 0x11d2, 0x87, 0x73, 0x92, 0xe2, 0x20, 0x52, 0x41, 0x53);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\version.h ===
// Resources for the common version chunk

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Systray shell service object"
#define VER_INTERNALNAME_STR            "stobject"
#define VER_ORIGINALFILENAME_STR        "stobject.dll"

#include <ntverp.h>
#include <common.ver>

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\usbui.c ===
#include "stdafx.h"

#include "systray.h"

#include <stdio.h>
#include <initguid.h>
#include <usbioctl.h>
#include <wmium.h>
#include <tchar.h>
#include <setupapi.h>

#define USBUIMENU               100

#define NUM_HCS_TO_CHECK 10

typedef int (CALLBACK *USBERRORMESSAGESCALLBACK)
    (PUSB_CONNECTION_NOTIFICATION,LPTSTR);

extern HINSTANCE g_hInstance;

static BOOL    g_bUSBUIEnabled = FALSE;
static BOOL    g_bUSBUIIconShown = FALSE;
static HINSTANCE g_hUsbWatch = NULL;
static USBERRORMESSAGESCALLBACK g_UsbHandler = NULL;
static BOOL    g_bSubstituteDll = FALSE;
static TCHAR   g_strSubstituteDll[MAX_PATH];
static HANDLE  g_hWait = NULL;

int _cdecl main(){
    return 0;
}

#define USBUI_OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)Base + Offset))

LPTSTR USBUI_CountedStringToSz(LPTSTR lpString)
{
   SHORT    usNameLength;
   LPTSTR  lpStringPlusNull;

   usNameLength = * (USHORT *) lpString;

   lpStringPlusNull = (LPTSTR) LocalAlloc(LMEM_ZEROINIT,
                                          sizeof(TCHAR) * (usNameLength+1));

   if (lpStringPlusNull != NULL) {
      lpString = (LPTSTR) USBUI_OffsetToPtr(lpString, sizeof(USHORT));

      wcsncpy( lpStringPlusNull, lpString, usNameLength );

      lpStringPlusNull[usNameLength] = TEXT('0');
      // _tcscpy( lpStringPlusNull + usNameLength, _TEXT("") );
   }

   return lpStringPlusNull;
}

void USBUI_EventCallbackRoutine(PWNODE_HEADER WnodeHeader, UINT_PTR NotificationContext)
{
    PWNODE_SINGLE_INSTANCE          wNode = (PWNODE_SINGLE_INSTANCE)WnodeHeader;
    PUSB_CONNECTION_NOTIFICATION    usbConnectionNotification;
    LPGUID                          eventGuid = &WnodeHeader->Guid;
    LPTSTR                          strInstanceName;

    if (memcmp(&GUID_USB_WMI_STD_DATA, eventGuid, sizeof(GUID)) == 0) {
        usbConnectionNotification = (PUSB_CONNECTION_NOTIFICATION)
                                    USBUI_OffsetToPtr(wNode,
                                                      wNode->DataBlockOffset);

        //
        // Get the instance name
        //
        strInstanceName =
            USBUI_CountedStringToSz((LPTSTR)
                                    USBUI_OffsetToPtr(wNode,
                                                      wNode->OffsetInstanceName));
        if (strInstanceName) {
            if (g_hUsbWatch && g_UsbHandler) {
USBUIEngageHandler:
                g_UsbHandler(usbConnectionNotification, strInstanceName);
            } else {
                if (g_bSubstituteDll) {
                    g_hUsbWatch = LoadLibrary(g_strSubstituteDll);
                } else {
                    g_hUsbWatch = LoadLibrary(TEXT("usbui.dll"));
                }
                g_UsbHandler = (USBERRORMESSAGESCALLBACK)
                    GetProcAddress(g_hUsbWatch, "USBErrorHandler");
                goto USBUIEngageHandler;
            }
            LocalFree(strInstanceName);
        }
    }
}

VOID USBUI_WaitRoutineCallback(WMIHANDLE Handle, BOOLEAN Unused) {
    ASSERT(!Unused);
    UnregisterWaitEx(g_hWait, NULL);
    g_hWait = NULL;
    WmiReceiveNotifications(1, &Handle, USBUI_EventCallbackRoutine, (ULONG_PTR)NULL);
    RegisterWaitForSingleObject(&g_hWait,
                                 Handle,
                                 USBUI_WaitRoutineCallback,
                                 Handle, // context
                                 INFINITE,
                                 WT_EXECUTELONGFUNCTION | WT_EXECUTEONLYONCE);
}

int USBUI_ErrorMessagesEnable(BOOL fEnable)
{
    ULONG status = ERROR_SUCCESS;
    BOOL result;
    static WMIHANDLE hWmi = NULL;

    if (fEnable) {
        ASSERT(!g_hWait);
        ASSERT(!hWmi);
        status = WmiOpenBlock((LPGUID) &GUID_USB_WMI_STD_DATA,
                              WMIGUID_NOTIFICATION | SYNCHRONIZE,
                              &hWmi);

        if (!status) {
            result = RegisterWaitForSingleObject(&g_hWait,
                                             hWmi,
                                             USBUI_WaitRoutineCallback,
                                             hWmi, // context
                                             INFINITE,
                                             WT_EXECUTELONGFUNCTION | WT_EXECUTEONLYONCE);
            status = result ? 0 : ERROR_INVALID_FUNCTION;
        }
    } else {
        ASSERT(hWmi);
        if (g_hWait) {
            result = UnregisterWait(g_hWait);
        }
        if (hWmi) {
            status = WmiCloseBlock(hWmi);
        }
        hWmi = NULL;
        g_hWait = NULL;
        if (g_hUsbWatch) {

            // This allows us to replace the library

            FreeLibrary(g_hUsbWatch);
            g_hUsbWatch = NULL;
            g_UsbHandler = NULL;
        }
    }

    return status;

}

void USBUI_Notify(HWND hwnd, WPARAM wParam, LPARAM lParam)
{

    switch (lParam)
    {
        case WM_RBUTTONUP:
        {
            USBUI_Menu(hwnd, 1, TPM_RIGHTBUTTON);
        }
        break;

        case WM_LBUTTONDOWN:
        {
            SetTimer(hwnd, USBUI_TIMER_ID, GetDoubleClickTime()+100, NULL);
        }
        break;

        case WM_LBUTTONDBLCLK:
        {
            KillTimer(hwnd, USBUI_TIMER_ID);
            USBUI_Toggle();
        }
        break;
    }
}

void USBUI_Toggle()
{
    USBUI_SetState(!g_bUSBUIEnabled);
}

void USBUI_Timer(HWND hwnd)
{
    KillTimer(hwnd, USBUI_TIMER_ID);
    USBUI_Menu(hwnd, 0, TPM_LEFTBUTTON);
}
/*
HMENU USBUI_CreateMenu()
{
    HMENU hmenu;
    LPSTR lpszMenu1;

    hmenu = CreatePopupMenu();

    if (!hmenu)
    {
        return NULL;
    }

    lpszMenu1 = LoadDynamicString(g_bUSBUIEnabled?IDS_USBUIDISABLE:IDS_USBUIENABLE);

    // AppendMenu(hmenu,MF_STRING,USBUIMENU,lpszMenu1);
    SysTray_AppendMenuString (hmenu,USBUIMENU,lpszMenu1);

    SetMenuDefaultItem(hmenu,USBUIMENU,FALSE);

    DeleteDynamicString(lpszMenu1);

    return hmenu;
}
  */
void USBUI_Menu(HWND hwnd, UINT uMenuNum, UINT uButton)
{
    POINT   pt;
    UINT    iCmd;
    HMENU   hmenu = 0;

    GetCursorPos(&pt);

//    hmenu = USBUI_CreateMenu();

    if (!hmenu)
    {
        return;
    }

    SetForegroundWindow(hwnd);

    iCmd = TrackPopupMenu(hmenu, uButton | TPM_RETURNCMD | TPM_NONOTIFY, pt.x, pt.y, 0, hwnd, NULL);

    DestroyMenu(hmenu);

    switch (iCmd)
    {
        case USBUIMENU:
        {
            USBUI_Toggle();
        }
        break;
    }
}

BOOL USBUI_SetState(BOOL NewState)
{
    int retValue;

    if (g_bUSBUIEnabled != NewState) {
        //
        // Only enable it if not already enabled
        //
        retValue = (int) USBUI_ErrorMessagesEnable (NewState);
        g_bUSBUIEnabled = retValue ? g_bUSBUIEnabled : NewState;
    }
    return g_bUSBUIEnabled;
}

BOOL
IsErrorCheckingEnabled()
{
    DWORD ErrorCheckingEnabled = TRUE, size;
    HKEY hKey;

    //
    // Check the registry value ErrorCheckingEnabled to make sure that we should
    // be enabling this.
    //
    if (ERROR_SUCCESS ==
        RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Usb"),
                        0,
                        KEY_READ,
                        &hKey)) {

        // Get the ErrorCheckingEnabled value

        size = sizeof(DWORD);
        RegQueryValueEx(hKey,
                        TEXT("ErrorCheckingEnabled"),
                        0,
                        NULL,
                        (LPBYTE) &ErrorCheckingEnabled,
                        &size);

        if (ErrorCheckingEnabled) {

            // Look for a substitute dll for usbui.dll

            size = MAX_PATH*sizeof(TCHAR);

            if (ERROR_SUCCESS ==
                RegQueryValueEx(hKey,
                            TEXT("SubstituteDll"),
                            0,
                            NULL,
                            (LPBYTE) g_strSubstituteDll,
                            &size)) {
                g_bSubstituteDll = TRUE;
            } else {
                g_bSubstituteDll = FALSE;
            }
        }
    }

    return (BOOL) ErrorCheckingEnabled;
}

BOOL USBUI_Init(HWND hWnd)
{
    TCHAR       HCName[16];
    BOOL        ControllerFound = FALSE;
    int         HCNum;
    HDEVINFO    hHCDev;

    //
    // Check the registry to make sure that it is turned on
    //
    if (!IsErrorCheckingEnabled()) {
        return FALSE;
    }

    //
    // Check for the existence of a USB controller.
    // If there is one, load and initialize USBUI.dll which will check for
    // usb error messages.  If we can't open a controller, than we shouldn't
    // load a USB watch dll.
    //
    for (HCNum = 0; HCNum < NUM_HCS_TO_CHECK; HCNum++)
    {
        wsprintf(HCName, TEXT("\\\\.\\HCD%d"), HCNum);

        hHCDev = CreateFile(HCName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL);
        //
        // If the handle is valid, then we've successfully opened a Host
        // Controller.
        //

        if (hHCDev != INVALID_HANDLE_VALUE) {
            CloseHandle(hHCDev);
            return TRUE;
        }
    }



    hHCDev = SetupDiGetClassDevs(&GUID_CLASS_USB_HOST_CONTROLLER,
                                 NULL,
                                 NULL,
                                 (DIGCF_DEVICEINTERFACE | DIGCF_PRESENT));
    if(hHCDev == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    SetupDiDestroyDeviceInfoList(hHCDev);
    return TRUE;
}

//
//  Called at init time and whenever services are enabled/disabled.
//
BOOL USBUI_CheckEnable(HWND hWnd, BOOL bSvcEnabled)
{
    BOOL bEnable = bSvcEnabled && USBUI_Init(hWnd);

    if (bEnable != g_bUSBUIEnabled)
    {
        //
        // state change
        //
        USBUI_SetState(bEnable);
    }

    return(bEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\systray.h ===
#include "stresid.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)   (sizeof((x))/sizeof((x)[0]))
#endif

#define STWM_NOTIFYHOTPLUG  STWM_NOTIFYPCMCIA
#define STSERVICE_HOTPLUG   STSERVICE_PCMCIA
#define HOTPLUG_REGFLAG_NOWARN PCMCIA_REGFLAG_NOWARN

void SysTray_RunProperties(UINT RunStringID);

VOID
PASCAL
SysTray_NotifyIcon(
    HWND hWnd,
    UINT uCallbackMessage,
    DWORD Message,
    HICON hIcon,
    LPCTSTR lpTip
    );

LPTSTR
NEAR CDECL
LoadDynamicString(
    UINT StringID,
    ...
    );

UINT EnableService(UINT uNewSvcMask, BOOL fEnable);
BOOL PASCAL GenericGetSet(HKEY hKey, LPCTSTR pszValue, LPVOID pData,
                          ULONG  cbSize, BOOL   bSet);

VOID
PASCAL
SysTray_AppendMenuString(
    HMENU hmenu,
    UINT item,
    LPTSTR lpszMenuItem
    );

//  Wrapper for LocalFree to make the code a little easier to read.
#define DeleteDynamicString(x)          LocalFree((HLOCAL) (x))

#define HOTPLUG_TIMER_ID                2
#define VOLUME_TIMER_ID                 3
#define POWER_TIMER_ID                  4
#define HOTPLUG_DEVICECHANGE_TIMERID    5
#define USBUI_TIMER_ID                  6
#define FAX_STARTUP_TIMER_ID            7
#define PRINT_STARTUP_TIMER_ID          8

#define FAX_SHUTDOWN_TIMER_ID		   99

void    Power_Timer(HWND hWnd);
BOOL    Power_CheckEnable(HWND hWnd, BOOL bSvcEnabled);
void    Power_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam);
void    Power_OnCommand(HWND hWnd, WPARAM wParam, LPARAM lParam);
void    Power_OnPowerBroadcast(HWND hWnd, WPARAM wParam, LPARAM lParam);
void    Power_OnDeviceChange(HWND hWnd, WPARAM wParam, LPARAM lParam);
void    Power_WmDestroy(HWND hWnd);
BOOLEAN Power_OnActivate(HWND hWnd, WPARAM wParam, LPARAM lParam);
void    Update_PowerFlags(DWORD dwMask, BOOL bEnable);
DWORD   Get_PowerFlags(void);
VOID    PASCAL Power_UpdateStatus(HWND, DWORD, BOOL);

void CloseIfOpen(LPHANDLE);

BOOL Volume_Init(HWND hWnd);
BOOL Volume_CheckEnable(HWND hWnd, BOOL bEnabled);
void Volume_DeviceChange(HWND hWnd, WPARAM wParam, LPARAM lParam);
void Volume_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam);
void Volume_Timer(HWND hWnd);
void Volume_LineChange(HWND hWnd, HMIXER hmx, DWORD dwID );
void Volume_ControlChange(HWND hWnd, HMIXER hmx, DWORD dwID );
void Volume_Shutdown(HWND hWnd);
void Volume_WinMMDeviceChange(HWND hWnd);
void Volume_HandlePowerBroadcast(HWND hWnd, WPARAM wParam, LPARAM lParam);
void Volume_DeviceChange_Cleanup(void);
void Volume_WmDestroy(HWND hWnd);

BOOL HotPlug_CheckEnable(HWND hWnd, BOOL bEnabled);
void HotPlug_DeviceChange(HWND hWnd, WPARAM wParam, LPARAM lParam);
void HotPlug_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam);
void HotPlug_Timer(HWND hWnd);
int  HotPlug_DeviceChangeTimer(HWND hWnd);
void HotPlug_WmDestroy(HWND HWnd);
void HotPlug_SessionChange(HWND hWnd, WPARAM wParam, LPARAM lParam);

BOOL StickyKeys_CheckEnable(HWND hWnd);
void StickyKeys_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam);

BOOL MouseKeys_CheckEnable(HWND hWnd);
void MouseKeys_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam);

BOOL CSC_CheckEnable(HWND hWnd, BOOL bSvcEnabled);
BOOL CSC_MsgProcess(LPMSG pMsg);

void USBUI_Notify(HWND hwnd, WPARAM wParam, LPARAM lParam);
//HMENU USBUI_CreateMenu();
void USBUI_Menu(HWND hwnd, UINT uMenuNum, UINT uButton);
BOOL USBUI_Init(HWND hWnd);
void USBUI_UpdateStatus(HWND hWnd, BOOL bShowIcon);
BOOL USBUI_CheckEnable(HWND hWnd, BOOL bSvcEnabled);
void USBUI_Toggle();
BOOL USBUI_SetState(BOOL On);
void USBUI_Timer(HWND hwnd);

BOOL FilterKeys_CheckEnable(HWND hWnd);
void FilterKeys_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam);

BOOL Print_SHChangeNotify_Register(HWND hWnd);
BOOL Print_SHChangeNotify_Unregister();
BOOL Print_TrayInit();
BOOL Print_TrayExit();

#define WM_PRINT_NOTIFY        (WM_APP + 1)
LRESULT Print_Notify(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

VOID
SetIconFocus(
    HWND hwnd,
    UINT uiIcon
    );

STDAPI_(int) SysTrayMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\vpowerd.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       VPOWERD.H
*
*  VERSION:     1.0
*
*  DATE:        01 Oct 1993
*
*  AUTHOR:      TCS
*
*  Definitions for the Virtual Power Management Device.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  01 Oct 1993 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_VPOWERD
#define _INC_VPOWERD

#ifndef Not_VxD

//
//  Virtual Power Management Device service table.
//

/*XLATOFF*/
#define VPOWERD_Service                 Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VPOWERD, VxD)

    VPOWERD_Service     (_VPOWERD_Get_Version, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Get_APM_BIOS_Version, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Get_Power_Management_Level, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Set_Power_Management_Level, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Set_Device_Power_State, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Set_System_Power_State, VxD_LOCKED_CODE)
    VPOWERD_Service     (_VPOWERD_Restore_Power_On_Defaults, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Get_Power_Status, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Get_Power_State, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_OEM_APM_Function, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Register_Power_Handler, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Deregister_Power_Handler, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_W32_Get_System_Power_Status, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_W32_Set_System_Power_State, VxD_PAGEABLE_CODE)

End_Service_Table(VPOWERD, VxD)
/*ENDMACROS*/

#endif

/*XLATOFF*/

#ifdef IS_32
#define POWERFAR
#else
#define POWERFAR                        _far
#endif

/*XLATON*/

//
//  Standard return type from VPOWERD services and handlers.
//
//  Error codes 0x00000001 through 0x000000FF are reserved for APM firmware
//  errors.
//
//  Error codes above 0x80000000 are reserved for definition by VPOWERD.
//

typedef DWORD                           POWERRET;

#define PR_SUCCESS                      0x00000000

#define PR_PM_DISABLED                  0x00000001
#define PR_RM_CONNECT_EXISTS            0x00000002
#define PR_INTERFACE_NOT_CONNECTED      0x00000003
#define PR_16BIT_PM_CONNECT_EXISTS      0x00000005
#define PR_16BIT_PM_UNSUPPORTED         0x00000006
#define PR_32BIT_PM_CONNECT_EXISTS      0x00000007
#define PR_32BIT_PM_UNSUPPORTED         0x00000008
#define PR_UNRECOGNIZED_DEVICE_ID       0x00000009
#define PR_PARAMETER_OUT_OF_RANGE       0x0000000A
#define PR_INTERFACE_NOT_ENGAGED        0x0000000B
#define PR_CANNOT_ENTER_STATE           0x00000060
#define PR_NO_PM_EVENTS_PENDING         0x00000080
#define PR_APM_NOT_PRESENT              0x00000086
#define PR_UNDEFINED_FUNCTION           0x000000FF

#define PR_DEFAULT                      0x80000000
#define PR_FAILURE                      0x80000001
#define PR_REQUEST_VETOED               0x80000002
#define PR_INVALID_POINTER              0x80000003
#define PR_INVALID_FLAG                 0x80000004
#define PR_INVALID_PMLEVEL              0x80000005
#define PR_INVALID_DEVICE_ID            0x80000006
#define PR_INVALID_POWER_STATE          0x80000007
#define PR_INVALID_REQUEST_TYPE         0x80000008
#define PR_OUT_OF_MEMORY                0x80000009
#define PR_DUPLICATE_POWER_HANDLER      0x8000000A
#define PR_POWER_HANDLER_NOT_FOUND      0x8000000B
#define PR_INVALID_FUNCTION             0x8000000C

//
//  Power device ID type and standard IDs as defined by the APM 1.1
//  specification.
//

typedef DWORD                           POWER_DEVICE_ID;

#define PDI_APM_BIOS                    0x0000
#define PDI_MANAGED_BY_APM_BIOS         0x0001
#define PDI_MANAGED_BY_APM_BIOS_OLD     0xFFFF

//
//  Power state type and standard power states as defined by the APM 1.1
//  specification.
//

typedef DWORD                           POWER_STATE;
typedef POWER_STATE POWERFAR*           LPPOWER_STATE;

#define PSTATE_APM_ENABLED              0x0000
#define PSTATE_STANDBY                  0x0001
#define PSTATE_SUSPEND                  0x0002
#define PSTATE_OFF                      0x0003

//
//  Valid power management levels.
//

#define PMLEVEL_ADVANCED                0
#define PMLEVEL_STANDARD                1
#define PMLEVEL_OFF                     2
#define PMLEVEL_MAXIMUM                 PMLEVEL_OFF

//
//  Valid request types.
//

#define REQTYPE_USER_INITIATED          0x00000000
#define REQTYPE_TIMER_INITIATED         0x00000001
#define REQTYPE_FORCED_REQUEST          0x00000002
#define REQTYPE_BIOS_CRITICAL_SUSPEND   0x00000003
#define REQTYPE_FROM_BIOS_FLAG          0x80000000                  // ;Internal

//
//  Power status structures returned by _VPOWERD_Get_Power_Status and
//  _VPOWERD_W32_Get_Power_Status.
//

#ifndef NOPOWERSTATUSDEFINES

#define AC_LINE_OFFLINE                 0x00
#define AC_LINE_ONLINE                  0x01
#define AC_LINE_BACKUP_POWER            0x02
#define AC_LINE_UNKNOWN                 0xFF

#define BATTERY_STATUS_HIGH             0x00
#define BATTERY_STATUS_LOW              0x01
#define BATTERY_STATUS_CRITICAL         0x02
#define BATTERY_STATUS_CHARGING         0x03
#define BATTERY_STATUS_UNKNOWN          0xFF

#define BATTERY_FLAG_HIGH               0x01
#define BATTERY_FLAG_LOW                0x02
#define BATTERY_FLAG_CRITICAL           0x04
#define BATTERY_FLAG_CHARGING           0x08
#define BATTERY_FLAG_NO_BATTERY         0x80
#define BATTERY_FLAG_UNKNOWN            0xFF

#define BATTERY_PERCENTAGE_UNKNOWN      0xFF

#define BATTERY_LIFE_MINUTES_MASK       0x8000
#define BATTERY_LIFE_UNKNOWN            0xFFFF

#define BATTERY_LIFE_W32_UNKNOWN        0xFFFFFFFF

#endif  // NOPOWERSTATUSDEFINES

typedef struct _POWER_STATUS {
    BYTE PS_AC_Line_Status;
    BYTE PS_Battery_Status;
    BYTE PS_Battery_Flag;
    BYTE PS_Battery_Life_Percentage;
    WORD PS_Battery_Life_Time;
}   POWER_STATUS;

typedef POWER_STATUS POWERFAR* LPPOWER_STATUS;

typedef struct _WIN32_SYSTEM_POWER_STATUS {
    BYTE W32PS_AC_Line_Status;
    BYTE W32PS_Battery_Flag;
    BYTE W32PS_Battery_Life_Percent;
    BYTE W32PS_Reserved1;
    DWORD W32PS_Battery_Life_Time;
    DWORD W32PS_Battery_Full_Life_Time;
}   WIN32_SYSTEM_POWER_STATUS;

typedef WIN32_SYSTEM_POWER_STATUS POWERFAR* LPWIN32_SYSTEM_POWER_STATUS;

//
//  OEM APM Register Structure used by _VPOWERD_OEM_APM_Function.
//

struct _OEM_APM_BYTE_REGS {
    WORD OEMAPM_Reserved1[6];
    BYTE OEMAPM_BL;
    BYTE OEMAPM_BH;
    WORD OEMAPM_Reserved2;
    BYTE OEMAPM_DL;
    BYTE OEMAPM_DH;
    WORD OEMAPM_Reserved3;
    BYTE OEMAPM_CL;
    BYTE OEMAPM_CH;
    WORD OEMAPM_Reserved4;
    BYTE OEMAPM_AL;
    BYTE OEMAPM_AH;
    WORD OEMAPM_Reserved5;
    BYTE OEMAPM_Flags;
    BYTE OEMAPM_Reserved6[3];
};

struct _OEM_APM_WORD_REGS {
    WORD OEMAPM_DI;
    WORD OEMAPM_Reserved7;
    WORD OEMAPM_SI;
    WORD OEMAPM_Reserved8;
    WORD OEMAPM_BP;
    WORD OEMAPM_Reserved9;
    WORD OEMAPM_BX;
    WORD OEMAPM_Reserved10;
    WORD OEMAPM_DX;
    WORD OEMAPM_Reserved11;
    WORD OEMAPM_CX;
    WORD OEMAPM_Reserved12;
    WORD OEMAPM_AX;
    WORD OEMAPM_Reserved13[3];
};

struct _OEM_APM_DWORD_REGS {
    DWORD OEMAPM_EDI;
    DWORD OEMAPM_ESI;
    DWORD OEMAPM_EBP;
    DWORD OEMAPM_EBX;
    DWORD OEMAPM_EDX;
    DWORD OEMAPM_ECX;
    DWORD OEMAPM_EAX;
    DWORD OEMAPM_Reserved14;
};

typedef union _OEM_APM_REGS {
    struct _OEM_APM_BYTE_REGS ByteRegs;
    struct _OEM_APM_WORD_REGS WordRegs;
    struct _OEM_APM_DWORD_REGS DwordRegs;
}   OEM_APM_REGS;

typedef OEM_APM_REGS POWERFAR*          LPOEM_APM_REGS;

//
//  Possible power function codes that are sent to POWER_HANDLER callbacks.
//

typedef DWORD                           POWERFUNC;

#define PF_SUSPEND_PHASE1               0x00000000
#define PF_SUSPEND_PHASE2               0x00000001
#define PF_SUSPEND_INTS_OFF             0x00000002
#define PF_RESUME_INTS_OFF              0x00000003
#define PF_RESUME_PHASE2                0x00000004
#define PF_RESUME_PHASE1                0x00000005
#define PF_BATTERY_LOW                  0x00000006
#define PF_POWER_STATUS_CHANGE          0x00000007
#define PF_UPDATE_TIME                  0x00000008
#define PF_APMOEMEVENT_FIRST            0x00000200
#define PF_APMOEMEVENT_LAST             0x000002FF

//
//
//

#define PFG_UI_ALLOWED                  0x00000001
#define PFG_CANNOT_FAIL                 0x00000002
#define PFG_REQUEST_VETOED              0x00000004
#define PFG_REVERSE                     0x00000008
#define PFG_STANDBY                     0x00000010
#define PFG_CRITICAL                    0x00000020

//
//  Standard POWER_HANDLER priority levels.
//

#define PHPL_PBT_BROADCAST              0x40000000
#define PHPL_UNKNOWN                    0x80000000
#define PHPL_CONFIGMG                   0xC0000000
#define PHPL_TIMER			0xE0000000

//
//
//

typedef POWERRET (*POWER_HANDLER)(POWERFUNC, DWORD);

//
//  VPOWERD BroadcastSystemMessage API parameter blocks.
//

typedef struct _VPOWERD_BSMAPI_HEADER {
    DWORD VBAPIH_Packet_Size;
    WORD VBAPIH_Function;
    DWORD VBAPIH_Return_Code;
}   VPOWERD_BSMAPI_HEADER;

#define VBAPIF_W32_SET_SYSTEM_STATE     0x000D

typedef struct _VPOWERD_BSMAPI_W32_SET_SYSTEM_STATE {
    struct _VPOWERD_BSMAPI_HEADER VBWSSS_VBAPIH;
    DWORD VBWSSS_Force_Flag;
}   VPOWERD_BSMAPI_W32_SET_SYSTEM_STATE;

//
//  Virtual Power Management Device service prototypes.
//

/*XLATOFF*/

BOOL
POWERFAR CDECL
VPOWERD_Get_Entry_Point(
    VOID
    );

DWORD
POWERFAR CDECL
_VPOWERD_Get_Version(
    VOID
    );

DWORD
POWERFAR CDECL
_VPOWERD_Get_APM_BIOS_Version(
    VOID
    );

DWORD
POWERFAR CDECL
_VPOWERD_Get_Power_Management_Level(
    VOID
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Set_Power_Management_Level(
    DWORD Power_Management_Level
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Set_Device_Power_State(
    POWER_DEVICE_ID Power_Device_ID,
    POWER_STATE Power_State
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Set_System_Power_State(
    POWER_STATE Power_State,
    DWORD Request_Type
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Restore_Power_On_Defaults(
    VOID
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Get_Power_Status(
    POWER_DEVICE_ID Power_Device_ID,
    LPPOWER_STATUS lpPower_Status
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Get_Power_State(
    POWER_DEVICE_ID Power_Device_ID,
    LPPOWER_STATE lpPower_State
    );

POWERRET
POWERFAR CDECL
_VPOWERD_OEM_APM_Function(
    LPOEM_APM_REGS lpOEM_APM_Regs
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Register_Power_Handler(
    POWER_HANDLER Power_Handler,
    DWORD Priority
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Deregister_Power_Handler(
    POWER_HANDLER Power_Handler
    );

BOOL
POWERFAR CDECL
_VPOWERD_W32_Get_System_Power_Status(
    LPWIN32_SYSTEM_POWER_STATUS lpWin32_System_Power_Status
    );

DWORD
POWERFAR CDECL
_VPOWERD_W32_Set_System_Power_State(
    BOOL Suspend_Flag,
    BOOL Force_Flag
    );

/*XLATON*/

#endif // _INC_VPOWERD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\systray.c ===
#include "stdafx.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wtsapi32.h>
#include <faxreg.h>
#include "systray.h"

#ifndef FAX_SYS_TRAY_DLL
#define FAX_SYS_TRAY_DLL       TEXT("fxsst.dll")            // Fax notification bar DLL (loaded by STObject.dll)
#define IS_FAX_MSG_PROC                 "IsFaxMessage"      // Fax message handler (used by GetProcAddress)
typedef BOOL (*PIS_FAX_MSG_PROC)(PMSG);                     // IsFaxMessage type
#define FAX_MONITOR_SHUTDOWN_PROC       "FaxMonitorShutdown"// Fax monitor shutdown (used by GetProcAddress)
typedef BOOL (*PFAX_MONITOR_SHUTDOWN_PROC)();               // FaxMonitorShutdown type
#endif


//  Global instance handle of this application.
HINSTANCE g_hInstance;

DWORD g_uiShellHook; //shell hook window message

//  Global handle to VxDs
HANDLE g_hPCCARD = INVALID_HANDLE_VALUE;

static UINT g_uEnabledSvcs = 0;

//  Context sensitive help array used by the WinHelp engine.
extern const DWORD g_ContextMenuHelpIDs[];

UINT g_msg_winmm_devicechange = 0;

DWORD g_msgTaskbarCreated;
LRESULT CALLBACK SysTrayWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam);

HMODULE g_hFaxLib = NULL;
PIS_FAX_MSG_PROC g_pIsFaxMessage = NULL;
PFAX_MONITOR_SHUTDOWN_PROC g_pFaxMonitorShutdown = NULL;

/*******************************************************************************
*
*  DESCRIPTION:
*       Turns the specified service on or off depending upon the value in
*       fEnable and writes the new value to the registry.
*
*  PARAMETERS:
*     (returns), Mask of all currently enabled services.
*
*******************************************************************************/

UINT EnableService(UINT uNewSvcMask, BOOL fEnable)
{
    HKEY hk;
    UINT CurSvcMask;
    DWORD cb;
    CurSvcMask = STSERVICE_ALL; // Enable all standard serivces

    if (RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_SYSTRAY, &hk) == ERROR_SUCCESS)
    {
        cb = sizeof(CurSvcMask);
        RegQueryValueEx(hk, REGSTR_VAL_SYSTRAYSVCS, NULL, NULL, (LPSTR)&CurSvcMask, &cb);

        if (uNewSvcMask)
        {
            if (fEnable)
            {
                CurSvcMask |= uNewSvcMask;
            }
            else
            {
                CurSvcMask &= ~uNewSvcMask;
            }

            RegSetValueEx(hk, REGSTR_VAL_SYSTRAYSVCS, 0, REG_DWORD, (LPSTR)&CurSvcMask, sizeof(CurSvcMask));
        }

        RegCloseKey(hk);
    }

    return(CurSvcMask & STSERVICE_ALL);
}


//
//  Closes file handles IFF the global variable != INVALID_HANDLE_VALUE
//
void CloseIfOpen(LPHANDLE lph)
{
    if (*lph != INVALID_HANDLE_VALUE)
    {
        CloseHandle(*lph);
        *lph = INVALID_HANDLE_VALUE;
    }
}


// From stobject.cpp
void StartNetShell();
void StopNetShell();

// if lpCmdLine contains an integer value then we'll enable that service

STDAPI_(int) SysTrayMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow)
{
    HWND hExistWnd = FindWindow(SYSTRAY_CLASSNAME, NULL);
    UINT iEnableServ = StrToInt(lpszCmdLine);

    CoInitializeEx (NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);

    g_hInstance = hInstance;
    g_uiShellHook = 0;
    g_msg_winmm_devicechange = RegisterWindowMessage(TEXT("winmm_devicechange")); 

    if (hExistWnd)
    {
        // NOTE: Send an enable message even if the command line parameter
        //       is 0 to force us to re-check for all enabled services.
        SendMessage(hExistWnd, STWM_ENABLESERVICE, iEnableServ, TRUE);
    }
    else
    {
        WNDCLASSEX wc;

        //  Register a window class for the Battery Meter.  This is done so that
        //  the power control panel applet has the ability to detect us and turn us
        //  off if we're running.

        wc.cbSize          = sizeof(wc);
        wc.style           = CS_GLOBALCLASS;
        wc.lpfnWndProc     = SysTrayWndProc;
        wc.cbClsExtra      = 0;
        wc.cbWndExtra      = DLGWINDOWEXTRA;
        wc.hInstance       = hInstance;
        wc.hIcon           = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_BATTERYPLUG));
        wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground   = (HBRUSH) (COLOR_3DFACE + 1);
        wc.lpszMenuName    = NULL;
        wc.lpszClassName   = SYSTRAY_CLASSNAME;
        wc.hIconSm         = NULL;

        if (RegisterClassEx(&wc))
        {
            MSG Msg;
            //  Create the Battery Meter and get this thing going!!!
            HWND hWnd = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_BATTERYMETER), NULL, NULL);

            g_msgTaskbarCreated = RegisterWindowMessage(L"TaskbarCreated");

            // Ensure we're always running the CSC "service" on Win2000.
            // CSC won't work without it.
            //
            //
            // Ensure we're always running the hotplug "service" on Win2000.
            // 
            iEnableServ |= (STSERVICE_CSC | STSERVICE_HOTPLUG);

            // create the timer that will delay the startup of the fax code.
            SetTimer( hWnd, FAX_STARTUP_TIMER_ID, 20 * 1000, NULL );

            // create the timer that will delay the startup of the print tray code.
            SetTimer( hWnd, PRINT_STARTUP_TIMER_ID, 20 * 1000, NULL );
    
            //
            //   This message will initialize all existing services if iEnableServ
            //   is 0, so it's used to do the general initialization as well as to
            //   enable a new service via the command line.
            //
            SendMessage(hWnd, STWM_ENABLESERVICE, iEnableServ, TRUE);


            // Whistler runs NETSHELL in the thread of the systray
            StartNetShell();

            while (GetMessage(&Msg, NULL, 0, 0))
            {
                if(g_pIsFaxMessage && g_pIsFaxMessage(&Msg))
                {
                    continue;
                }

                if (!IsDialogMessage(hWnd, &Msg) &&
                    !CSC_MsgProcess(&Msg))
                {
                    TranslateMessage(&Msg);
                    DispatchMessage(&Msg);
                }
            }
            // Whistler runs NETSHELL in the thread of the systray
            StopNetShell();
        }
        CloseIfOpen(&g_hPCCARD);
    }
    CoUninitialize();
    return 0;
}


/*******************************************************************************
*
*  UpdateServices
*
*  DESCRIPTION:
*       Enables or disables all services specified by the uEnabled mask.
*
*  PARAMETERS:
*     (returns), TRUE if any service wants to remain resident.
*
*******************************************************************************/

BOOL UpdateServices(HWND hWnd, UINT uEnabled)
{
    BOOL bAnyEnabled = FALSE;

    g_uEnabledSvcs = uEnabled;
    bAnyEnabled |= CSC_CheckEnable(hWnd, uEnabled & STSERVICE_CSC);
    bAnyEnabled |= Power_CheckEnable(hWnd, uEnabled & STSERVICE_POWER);
    bAnyEnabled |= HotPlug_CheckEnable(hWnd, uEnabled & STSERVICE_HOTPLUG);
    bAnyEnabled |= Volume_CheckEnable(hWnd, uEnabled & STSERVICE_VOLUME);
    bAnyEnabled |= USBUI_CheckEnable(hWnd, uEnabled & STSERVICE_USBUI);

    //
    // now check accessibility features
    //

    bAnyEnabled |= StickyKeys_CheckEnable(hWnd);
    bAnyEnabled |= MouseKeys_CheckEnable(hWnd);
    bAnyEnabled |= FilterKeys_CheckEnable(hWnd);

    // register to listen for SHChangeNotify events, so if somebody prints a job 
    // we start the print tray code before the kick off timer.
    Print_SHChangeNotify_Register(hWnd);

    return(bAnyEnabled);
}


/*******************************************************************************
*
*  SysTrayWndProc
*
*  DESCRIPTION:
*     Callback procedure for the BatteryMeter window.
*
*  PARAMETERS:
*     hWnd, handle of BatteryMeter window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

LRESULT CALLBACK SysTrayWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)
{
    
    if (g_uiShellHook && Message == g_uiShellHook) // NT5: 406505 shellhook for MouseKeys
    {
        switch (wParam)
        {
        case HSHELL_ACCESSIBILITYSTATE:
            switch (lParam)
            {
            case ACCESS_STICKYKEYS:
                StickyKeys_CheckEnable(hWnd);
                break;

            case ACCESS_MOUSEKEYS:
                MouseKeys_CheckEnable(hWnd);
                break;
//  Since we only enable the shellhook when MouseKeys or StickKeys is on, we should only get that msg
//            case ACCESS_FILTERKEYS:
//                FilterKeys_CheckEnable(hWnd);
//                break;
            }
        }
        return 0;
    }


    if (Message == g_msg_winmm_devicechange)
    {
        if (g_uEnabledSvcs & STSERVICE_VOLUME)
        {
            Volume_WinMMDeviceChange(hWnd);
        }
        return 0;
    }

    switch (Message)
    {
    case WM_CREATE:
        WTSRegisterSessionNotification(hWnd, NOTIFY_FOR_THIS_SESSION);
        break;

    case WM_COMMAND:
        Power_OnCommand(hWnd, wParam, lParam);
        break;

    case STWM_NOTIFYPOWER:
        Power_Notify(hWnd, wParam, lParam);
        break;

    case STWM_NOTIFYUSBUI:
        USBUI_Notify(hWnd, wParam, lParam);
        break;

    case STWM_NOTIFYHOTPLUG:   
        HotPlug_Notify(hWnd, wParam, lParam);
        break;

    case STWM_NOTIFYSTICKYKEYS:
        StickyKeys_Notify(hWnd, wParam, lParam);
        break;

    case STWM_NOTIFYMOUSEKEYS:
        MouseKeys_Notify(hWnd, wParam, lParam);
        break;

    case STWM_NOTIFYFILTERKEYS:
        FilterKeys_Notify(hWnd, wParam, lParam);
        break;

    case STWM_NOTIFYVOLUME:
        Volume_Notify(hWnd, wParam, lParam);
        break;
    
    case STWM_ENABLESERVICE:
        UpdateServices(hWnd, EnableService((UINT)wParam, (BOOL)lParam));
        break;

    case STWM_GETSTATE:
        return((BOOL)(g_uEnabledSvcs & (UINT)wParam));

    case MM_MIXM_CONTROL_CHANGE:
        Volume_ControlChange(hWnd, (HMIXER)wParam, (DWORD)lParam);
        break;

    case MM_MIXM_LINE_CHANGE:
        Volume_LineChange(hWnd, (HMIXER)wParam, (DWORD)lParam);
        break;

    case WM_ACTIVATE:
        if (Power_OnActivate(hWnd, wParam, lParam)) 
        {
            break;
        }
        return DefWindowProc(hWnd, Message, wParam, lParam);

    case WM_TIMER:
        switch (wParam)
        {

        case VOLUME_TIMER_ID:
            Volume_Timer(hWnd);
            break;

        case POWER_TIMER_ID:
            Power_Timer(hWnd);
            break;

        case HOTPLUG_TIMER_ID:
            HotPlug_Timer(hWnd);
            break;

        case USBUI_TIMER_ID:
            USBUI_Timer(hWnd);
            break;

        case HOTPLUG_DEVICECHANGE_TIMERID:
            HotPlug_DeviceChangeTimer(hWnd);
            break;
        case FAX_STARTUP_TIMER_ID:
            KillTimer(hWnd, FAX_STARTUP_TIMER_ID);
            if (NULL == g_hFaxLib)
            {
                g_hFaxLib = LoadLibrary(FAX_SYS_TRAY_DLL);

                g_pIsFaxMessage = NULL;
                g_pFaxMonitorShutdown = NULL;
                if(g_hFaxLib)
                {
                    g_pIsFaxMessage = (PIS_FAX_MSG_PROC)GetProcAddress(g_hFaxLib, IS_FAX_MSG_PROC);
                    g_pFaxMonitorShutdown = (PFAX_MONITOR_SHUTDOWN_PROC)GetProcAddress(g_hFaxLib, FAX_MONITOR_SHUTDOWN_PROC);
                }
            }

            break;

        case PRINT_STARTUP_TIMER_ID:
            KillTimer(hWnd, PRINT_STARTUP_TIMER_ID);
            Print_TrayInit();
            break;

        case FAX_SHUTDOWN_TIMER_ID:
            {
                if (g_hFaxLib)
                {
                    if (g_pFaxMonitorShutdown)
                    {
                        g_pFaxMonitorShutdown();
                    }
                    FreeLibrary (g_hFaxLib);
                    g_hFaxLib = NULL;
                    g_pIsFaxMessage = NULL;
                    g_pFaxMonitorShutdown = NULL;
                }
            }
            break;
        }
        break;

    //
    // Handle SC_CLOSE to hide the window without destroying it. This
    // happens when we display the window and the user "closes" it.
    // Don't pass SC_CLOSE to DefWindowProc since that causes a
    // WM_CLOSE which destroys the window.
    //
    // Note that CSysTray::DestroySysTrayWindow must send WM_CLOSE
    // to destroy the window.  It can't use DestroyWindow since it's
    // typically on a different thread and DestroyWindow fails.
    //
    case WM_SYSCOMMAND:
        if (SC_CLOSE != (wParam & ~0xf))
            return DefWindowProc(hWnd, Message, wParam, lParam);
        ShowWindow(hWnd, SW_HIDE);
        break;

    case WM_POWERBROADCAST:
         Power_OnPowerBroadcast(hWnd, wParam, lParam);
         Volume_HandlePowerBroadcast(hWnd, wParam, lParam);
         break;

    case WM_DEVICECHANGE:
        Power_OnDeviceChange(hWnd, wParam, lParam);

        if (g_uEnabledSvcs & STSERVICE_VOLUME)
        {
            Volume_DeviceChange(hWnd, wParam, lParam);
        }

        HotPlug_DeviceChange(hWnd, wParam, lParam);
        break;

    case WM_ENDSESSION:
        if (g_uEnabledSvcs & STSERVICE_VOLUME)
        {
            Volume_Shutdown(hWnd);
        }
        break;

    case WM_WTSSESSION_CHANGE:
        HotPlug_SessionChange(hWnd, wParam, wParam);
        break;

    case WM_DESTROY:
        WTSUnRegisterSessionNotification(hWnd);
        UpdateServices(hWnd, 0);          // Force all services off
        Volume_WmDestroy(hWnd);
        Power_WmDestroy(hWnd);
        HotPlug_WmDestroy(hWnd);
        Print_SHChangeNotify_Unregister();
        Print_TrayExit();
        if (g_hFaxLib)
        {
            if (g_pFaxMonitorShutdown)
            {
                g_pFaxMonitorShutdown();
            }
            FreeLibrary (g_hFaxLib);
            g_hFaxLib = NULL;
            g_pIsFaxMessage = NULL;
            g_pFaxMonitorShutdown = NULL;
        }
        PostQuitMessage(0);
        break;

    case WM_HELP:
        WinHelp(((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP,
                (ULONG_PTR)(LPSTR)g_ContextMenuHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
                (ULONG_PTR)(LPSTR) g_ContextMenuHelpIDs);
        break;

    case WM_SYSCOLORCHANGE:
        StickyKeys_CheckEnable(hWnd);
        FilterKeys_CheckEnable(hWnd);
        MouseKeys_CheckEnable(hWnd);
                break;


    case WM_SETTINGCHANGE:
        switch(wParam)
        {
            case SPI_SETSTICKYKEYS:
                StickyKeys_CheckEnable(hWnd);
                break;
            case SPI_SETFILTERKEYS:
                FilterKeys_CheckEnable(hWnd);
                break;
            case SPI_SETMOUSEKEYS:
                MouseKeys_CheckEnable(hWnd);
                break;
        }
        break;

    case WM_PRINT_NOTIFY:
        Print_Notify(hWnd, Message, wParam, lParam);
        break;

    default:

        //
        // if Taskbar Created notification renenable all shell notify icons.
        //

        if (Message == g_msgTaskbarCreated)
        {
            UpdateServices(hWnd, EnableService(0, TRUE));
            break;
        }


        return DefWindowProc(hWnd, Message, wParam, lParam);
    }

    return 0;
}


// Loads the specified string ID and executes it.

void SysTray_RunProperties(UINT RunStringID)
{
    LPTSTR pszRunCmd = LoadDynamicString(RunStringID);
    if (pszRunCmd)
    {
        ShellExecute(NULL, TEXT("open"), TEXT("RUNDLL32.EXE"), pszRunCmd, NULL, SW_SHOWNORMAL);
        DeleteDynamicString(pszRunCmd);
    }
}


/*******************************************************************************
*
*  SysTray_NotifyIcon
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of BatteryMeter window.
*     Message,
*     hIcon,
*     lpTip,
*
*******************************************************************************/

VOID SysTray_NotifyIcon(HWND hWnd, UINT uCallbackMessage, DWORD Message, HICON hIcon, LPCTSTR lpTip)
{
    NOTIFYICONDATA nid = {0};

    nid.cbSize = sizeof(nid);
    nid.uID = uCallbackMessage;
    nid.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;
    nid.uCallbackMessage = uCallbackMessage;

    nid.hWnd = hWnd;
    nid.hIcon = hIcon;
    if (lpTip)
    {
        UINT cch = ARRAYSIZE(nid.szTip);
        lstrcpyn(nid.szTip, lpTip, cch);
    }
    else
    {
        nid.szTip[0] = 0;
    }

    Shell_NotifyIcon(Message, &nid);
}


/*******************************************************************************
*
*  DESCRIPTION:
*     Wrapper for the FormatMessage function that loads a string from our
*     resource table into a dynamically allocated buffer, optionally filling
*     it with the variable arguments passed.
*
*     BE CAREFUL in 16-bit code to pass 32-bit quantities for the variable
*     arguments.
*
*  PARAMETERS:
*     StringID, resource identifier of the string to use.
*     (optional), parameters to use to format the string message.
*
*******************************************************************************/

LPTSTR CDECL LoadDynamicString(UINT StringID, ...)
{
    TCHAR   Buffer[256];
    LPTSTR  pStr=NULL;
    va_list Marker;

    // va_start is a macro...it breaks when you use it as an assign
    va_start(Marker, StringID);

    LoadString(g_hInstance, StringID, Buffer, ARRAYSIZE(Buffer));

    FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                  (void *) (LPTSTR) Buffer, 0, 0, (LPTSTR) (LPTSTR *) &pStr, 0, &Marker);

    return pStr;
}


//*****************************************************************************
//
//  GenericGetSet
//
//  DESCRIPTION:
//  Reads or writes a registry key value.  The key must already be open.
//  The key will be closed after the data is read/written.
//
//  PARAMETERS:
//  hk         - HKEY to open registry key to read/write
//  lpszOptVal - value name string pointer
//  lpData     - pointer to data buffer to read/write
//  cbSize     - size of data to read/write in bytes
//  bSet       - FALSE if reading, TRUE if writing
//
//  RETURNS:
//  TRUE if successful, FALSE if not.
//
//  NOTE:
//  Assumes data is of type REG_BINARY or REG_DWORD when bSet = TRUE!
//
//*****************************************************************************

BOOL GenericGetSet(HKEY hk, LPCTSTR lpszOptVal, void * lpData, ULONG cbSize, BOOL bSet)
{
    DWORD rr;

    if (bSet)
        rr = RegSetValueEx(hk, lpszOptVal, 0, (cbSize == sizeof(DWORD)) ? REG_DWORD : REG_BINARY,
                           lpData, cbSize);
    else
        rr = RegQueryValueEx(hk, lpszOptVal, NULL, NULL, lpData, &cbSize);

    RegCloseKey(hk);
    return rr == ERROR_SUCCESS;
}


VOID SetIconFocus(HWND hwnd, UINT uiIcon)
{
    NOTIFYICONDATA nid = {0};

    nid.cbSize = sizeof(NOTIFYICONDATA);
    nid.hWnd = hwnd;
    nid.uID = uiIcon;

    Shell_NotifyIcon(NIM_SETFOCUS, &nid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\dll\volume.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       VOLUME.C
*
*  VERSION:     1.0
*
*  AUTHOR:      RAL
*
*  DATE:        11/01/94
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  Nov. 11, 94 RAL Original
*  Oct. 24, 95 Shawnb UNICODE enabled
*
*******************************************************************************/
#include "stdafx.h"
#include "systray.h"

#include <objbase.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <initguid.h>
#include <devguid.h>

#include <ks.h>
#include <ksmedia.h>
#include <mmddkp.h>


#define HWAVEOUT_MAPPER       ((HWAVEOUT)IntToPtr(WAVE_MAPPER))
#define HWAVEIN_MAPPER        ((HWAVEIN)IntToPtr(WAVE_MAPPER))
#define HMIDIOUT_MAPPER       ((HMIDIOUT)IntToPtr(WAVE_MAPPER))

#define HWAVEOUT_INDEX(i)     ((HWAVEOUT)IntToPtr(i))
#define HWAVEIN_INDEX(i)      ((HWAVEIN)IntToPtr(i))
#define HMIDIOUT_INDEX(i)     ((HMIDIOUT)IntToPtr(i))
#define HMIXER_INDEX(i)       ((HMIXER)IntToPtr(i))
#define HMIXEROBJ_INDEX(i)    ((HMIXEROBJ)IntToPtr(i))

/* defined in mmddk.h */
#define DRV_QUERYDEVNODE     (DRV_RESERVED + 2)

#define VOLUMEMENU_PROPERTIES               100
#define VOLUMEMENU_SNDVOL                   101

extern HINSTANCE g_hInstance;

static BOOL    g_bVolumeEnabled = FALSE;
static BOOL    g_bVolumeIconShown = FALSE;
static HICON   g_hVolumeIcon = NULL;
static HICON   g_hMuteIcon = NULL;
static HMENU   g_hVolumeMenu = NULL;
static HMIXER  g_hMixer = NULL;
static UINT    g_uMixer = 0;
static DWORD   g_dwMixerDevNode = 0;
static DWORD   g_dwMute = (DWORD) -1;
static DWORD   g_dwVSlider = 0;
static DWORD   g_dwMasterLine = (DWORD) -1;

HDEVNOTIFY DeviceEventContext = NULL;


void Volume_DeviceChange_Init(HWND hWnd, DWORD dwMixerID);
void Volume_DeviceChange_Cleanup(void);

void Volume_UpdateStatus(HWND hWnd, BOOL bShowIcon, BOOL bKillSndVol32);
void Volume_VolumeControl();
void Volume_ControlPanel(HWND hwnd);
MMRESULT Volume_GetDefaultMixerID(int *pid);
void Volume_UpdateIcon(HWND hwnd, DWORD message);
BOOL Volume_Controls(UINT uMxID);
BOOL FileExists (LPCTSTR pszFileName);
BOOL FindSystemFile (LPCTSTR pszFileName, LPTSTR pszFullPath, UINT cchSize);
void Volume_WakeUpOrClose(BOOL fClose);

HMENU Volume_CreateMenu()
{
        HMENU  hmenu;
        LPTSTR lpszMenu1;
        LPTSTR lpszMenu2;

        lpszMenu1 = LoadDynamicString(IDS_VOLUMEMENU1);
        if (!lpszMenu1)
                return NULL;

        lpszMenu2 = LoadDynamicString(IDS_VOLUMEMENU2);
        if (!lpszMenu2)
        {
                DeleteDynamicString(lpszMenu1);
                return NULL;
        }

        hmenu = CreatePopupMenu();
        if (!hmenu)
        {
                DeleteDynamicString(lpszMenu1);
                DeleteDynamicString(lpszMenu2);
                return NULL;
        }

        AppendMenu(hmenu,MF_STRING,VOLUMEMENU_SNDVOL,lpszMenu2);
        AppendMenu(hmenu,MF_STRING,VOLUMEMENU_PROPERTIES,lpszMenu1);

        SetMenuDefaultItem(hmenu,VOLUMEMENU_SNDVOL,FALSE);

        DeleteDynamicString(lpszMenu1);
        DeleteDynamicString(lpszMenu2);

        return hmenu;
}





BOOL Volume_Init(HWND hWnd)
{
        UINT        uMxID;
        const TCHAR szVolApp[] = TEXT ("SNDVOL32.EXE");

        if (g_hMixer == NULL)
        {
                if (Volume_GetDefaultMixerID(&uMxID) != MMSYSERR_NOERROR)
                        return FALSE;

                //
                // check for sndvol32 existence.  checking for the .exe
                // first will ensure that the service gets disabled properly
                //
                
                if (! FindSystemFile (szVolApp, NULL, 0))
                {
                        //
                        // disable the volume service
                        //
                        EnableService (STSERVICE_VOLUME, FALSE);
                
                        return FALSE;
                }


                //
                // do we have output volume controls on this mixer?
                //
                if (! Volume_Controls(uMxID))
                        return FALSE;

                if (mixerOpen(&g_hMixer, uMxID, (DWORD_PTR)hWnd, 0
                                , CALLBACK_WINDOW | MIXER_OBJECTF_MIXER)
                        == MMSYSERR_NOERROR)
                {
            Volume_DeviceChange_Init(hWnd, uMxID);

                        g_uMixer = uMxID;
                        if (mixerMessage (HMIXER_INDEX(uMxID), DRV_QUERYDEVNODE
                                 , (DWORD_PTR)&g_dwMixerDevNode, 0L))
                                g_dwMixerDevNode = 0L;
                        return TRUE;
                }
        }
        else
                return TRUE;

        return FALSE;
}

//
//  Called at init time and whenever services are enabled/disabled.
//  Returns false if mixer services are not active.
//
BOOL Volume_CheckEnable(HWND hWnd, BOOL bSvcEnabled)
{
        BOOL bEnable = bSvcEnabled && Volume_Init(hWnd);

        if (bEnable != g_bVolumeEnabled) {
                //
                // state change
                //
                g_bVolumeEnabled = bEnable;
                Volume_UpdateStatus(hWnd, bEnable, TRUE);
        }
        return(bEnable);
}

void Volume_UpdateStatus(HWND hWnd, BOOL bShowIcon, BOOL bKillSndVol32)
{
    // Don't show icon if not enabled
    if (!g_bVolumeEnabled)
        bShowIcon = FALSE;

        if (bShowIcon != g_bVolumeIconShown) {
                g_bVolumeIconShown = bShowIcon;
                if (bShowIcon) {
                        g_hVolumeIcon = LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_VOLUME),
                                                IMAGE_ICON, 16, 16, 0);
                        g_hMuteIcon = LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_MUTE),
                                                IMAGE_ICON, 16, 16, 0);
                        Volume_UpdateIcon(hWnd, NIM_ADD);
                } else {
                        SysTray_NotifyIcon(hWnd, STWM_NOTIFYVOLUME, NIM_DELETE, NULL, NULL);
                        if (g_hVolumeIcon) {
                                DestroyIcon(g_hVolumeIcon);
                                g_hVolumeIcon = NULL;
                        }
                        if (g_hMuteIcon) {
                                DestroyIcon(g_hMuteIcon);
                                g_hMuteIcon = NULL;
                        }
                        if (g_hMixer)
                        {
                                mixerClose(g_hMixer);
                                g_hMixer = NULL;
                        }
                        g_uMixer = 0;
                        g_dwMixerDevNode = 0L;

                        //
                        // SNDVOL32 may have a TRAYMASTER window open,
                        // sitting on a timer before it closes (so multiple
                        // l-clicks on the tray icon can bring up the app
                        // quickly after the first hit).  Close that app
                        // if it's around.
                        //
                        if (bKillSndVol32)
                        {
                                Volume_WakeUpOrClose (TRUE);
                        }
                }
    }
}

const TCHAR szMapperPath[]      = TEXT ("Software\\Microsoft\\Multimedia\\Sound Mapper");
const TCHAR szPlayback[]        = TEXT ("Playback");
const TCHAR szPreferredOnly[]   = TEXT ("PreferredOnly");


/*
 * Volume_GetDefaultMixerID
 *
 * Get the default mixer id.  We only appear if there is a mixer associated
 * with the default wave.
 *
 */
MMRESULT Volume_GetDefaultMixerID(int *pid)
{
    MMRESULT        mmr;
    DWORD           dwWaveID;
    DWORD           dwMixID;
    DWORD           dwFlags = 0;
    
    mmr = waveOutMessage(HWAVEOUT_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) &dwWaveID, (DWORD_PTR) &dwFlags);

    if (mmr == MMSYSERR_NOERROR)
    {
        mmr = mixerGetID(HMIXEROBJ_INDEX(dwWaveID), &dwMixID, MIXER_OBJECTF_WAVEOUT);

                if (mmr == MMSYSERR_NOERROR && pid)
                {
                        *pid = dwMixID;
                }
    }

    return mmr;
}
        

/*
 * Process line changes
 */
void Volume_LineChange(
    HWND        hwnd,
    HMIXER      hmx,
    DWORD       dwLineID)
{
    if (dwLineID != g_dwMasterLine)
                return;
    //
    // if our line is disabled, go away, I guess
    //
}

/*
 * Process control changes
 */
void Volume_ControlChange(
    HWND        hwnd,
    HMIXER      hmx,
    DWORD       dwControlID)
{
    if ((dwControlID != g_dwMute) && (g_dwMute != (DWORD) -1))
                return;

    //
    // Change mute icon state
    //
    Volume_UpdateIcon(hwnd, NIM_MODIFY);
}


BOOL Volume_IsMute()
{
    MMRESULT            mmr;
    MIXERCONTROLDETAILS mxcd;
    BOOL                fMute;

    if (!g_hMixer && (g_dwMute != (DWORD) -1))
    {
                return FALSE;
    }

    mxcd.cbStruct       = sizeof(mxcd);
    mxcd.dwControlID    = g_dwMute;
    mxcd.cChannels      = 1;
    mxcd.cMultipleItems = 0;
    mxcd.cbDetails      = sizeof(DWORD);
    mxcd.paDetails      = (LPVOID)&fMute;

    mmr = mixerGetControlDetails( (HMIXEROBJ)g_hMixer, &mxcd, MIXER_GETCONTROLDETAILSF_VALUE);

    if (mmr == MMSYSERR_NOERROR)
    {
                return fMute;
    }

    return FALSE;
}

BOOL Volume_Controls(
    UINT                uMxID)
{
    MIXERLINECONTROLS   mxlc;
    MIXERCONTROL        mxctrl;
    MIXERCAPS           mxcaps;
    MMRESULT            mmr;
    BOOL                fResult = FALSE;
    DWORD               iDest;
    g_dwMasterLine      = (DWORD) -1;
    g_dwMute            = (DWORD) -1;

    mmr = mixerGetDevCaps(uMxID, &mxcaps, sizeof(mxcaps));

    if (mmr != MMSYSERR_NOERROR)
    {
                return FALSE;
    }

    for (iDest = 0; iDest < mxcaps.cDestinations; iDest++)
    {
                MIXERLINE       mlDst;
        
                mlDst.cbStruct      = sizeof ( mlDst );
                mlDst.dwDestination = iDest;
        
                mmr = mixerGetLineInfo( HMIXEROBJ_INDEX(uMxID), &mlDst, MIXER_GETLINEINFOF_DESTINATION);

                if (mmr != MMSYSERR_NOERROR)
        {
                        continue;
        }

                switch (mlDst.dwComponentType)
                {
                    default:
                    continue;
                    
                case MIXERLINE_COMPONENTTYPE_DST_SPEAKERS:
                case MIXERLINE_COMPONENTTYPE_DST_HEADPHONES:
            {
                            g_dwMasterLine = mlDst.dwLineID;
            }
                        break;
                }
        
                mxlc.cbStruct       = sizeof(mxlc);
                mxlc.dwLineID       = g_dwMasterLine;
                mxlc.dwControlType  = MIXERCONTROL_CONTROLTYPE_MUTE;
                mxlc.cControls      = 1;
                mxlc.cbmxctrl       = sizeof(mxctrl);
                mxlc.pamxctrl       = &mxctrl;
                
                mmr = mixerGetLineControls( HMIXEROBJ_INDEX(uMxID), &mxlc, MIXER_GETLINECONTROLSF_ONEBYTYPE);

                if (mmr == MMSYSERR_NOERROR)
        {
                        g_dwMute = mxctrl.dwControlID;
        }
        
                fResult = TRUE;
                break;
        
    }
    return fResult;
}

void Volume_UpdateIcon(
    HWND hWnd,
    DWORD message)
{
    BOOL        fMute;
    LPTSTR      lpsz;
    HICON       hVol;

    fMute   = Volume_IsMute();
    hVol    = fMute?g_hMuteIcon:g_hVolumeIcon;
    lpsz    = LoadDynamicString(fMute?IDS_MUTED:IDS_VOLUME);
    SysTray_NotifyIcon(hWnd, STWM_NOTIFYVOLUME, message, hVol, lpsz);
    DeleteDynamicString(lpsz);
}



// WinMM is telling us the preferred device has changed for some reason
// Dump the old, open the new
//
void Volume_WinMMDeviceChange(HWND hWnd)
{
    DWORD dwMixID;

        if (g_hMixer)               // Dumping the Old
        {
                mixerClose(g_hMixer);
                g_hMixer = NULL;
                g_uMixer = 0;
                g_dwMixerDevNode = 0L;
        }
                                // Opening the new
    if (Volume_GetDefaultMixerID(&dwMixID) == MMSYSERR_NOERROR)
    {   
                if ( Volume_Controls(dwMixID) && 
             (mixerOpen(&g_hMixer, dwMixID, (DWORD_PTR)hWnd, 0L, CALLBACK_WINDOW | MIXER_OBJECTF_MIXER) == MMSYSERR_NOERROR))
                {
                        Volume_UpdateStatus(hWnd, TRUE, TRUE);

                        if (mixerMessage (HMIXER_INDEX(dwMixID), DRV_QUERYDEVNODE, (DWORD_PTR)&g_dwMixerDevNode, 0L))
            {
                                g_dwMixerDevNode = 0L;
            }

                        g_uMixer = dwMixID;

            Volume_UpdateIcon(hWnd, NIM_MODIFY);
                }
                else
                {
                        Volume_UpdateStatus(hWnd, FALSE, TRUE);
                }
    }
    else
    {
                Volume_UpdateStatus(hWnd, FALSE, TRUE);
    }
}


// Need to free up in the event of a power broadcast as well
//
void Volume_HandlePowerBroadcast(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    switch (wParam)
    {
            case PBT_APMQUERYSUSPEND:
        {
                if (g_hMixer)               // Dumping the Old
                {
                        mixerClose(g_hMixer);
                        g_hMixer = NULL;
                        g_uMixer = 0;
                        g_dwMixerDevNode = 0L;
                }
        }
            break;

            case PBT_APMQUERYSUSPENDFAILED:
            case PBT_APMRESUMESUSPEND:
        {
            Volume_WinMMDeviceChange(hWnd); 
        }
            break;
    }
}


void Volume_DeviceChange_Cleanup()
{
   if (DeviceEventContext) 
   {
       UnregisterDeviceNotification(DeviceEventContext);
       DeviceEventContext = 0;
   }

   return;
}

/*
**************************************************************************************************
        Volume_GetDeviceHandle()

        given a mixerID this functions opens its corresponding device handle. This handle can be used 
        to register for DeviceNotifications.

        dwMixerID -- The mixer ID
        phDevice -- a pointer to a handle. This pointer will hold the handle value if the function is
                                successful
        
        return values -- If the handle could be obtained successfully the return vlaue is TRUE.

**************************************************************************************************
*/
BOOL Volume_GetDeviceHandle(DWORD dwMixerID, HANDLE *phDevice)
{
        MMRESULT mmr;
        ULONG cbSize=0;
        TCHAR *szInterfaceName=NULL;

        //Query for the Device interface name
        mmr = mixerMessage(HMIXER_INDEX(dwMixerID), DRV_QUERYDEVICEINTERFACESIZE, (DWORD_PTR)&cbSize, 0L);
        if(MMSYSERR_NOERROR == mmr)
        {
                szInterfaceName = (TCHAR *)GlobalAllocPtr(GHND, (cbSize+1)*sizeof(TCHAR));
                if(!szInterfaceName)
                {
                        return FALSE;
                }

                mmr = mixerMessage(HMIXER_INDEX(dwMixerID), DRV_QUERYDEVICEINTERFACE, (DWORD_PTR)szInterfaceName, cbSize);
                if(MMSYSERR_NOERROR != mmr)
                {
                        GlobalFreePtr(szInterfaceName);
                        return FALSE;
                }
        }
        else
        {
                return FALSE;
        }

        //Get an handle on the device interface name.
        *phDevice = CreateFile(szInterfaceName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        GlobalFreePtr(szInterfaceName);
        if(INVALID_HANDLE_VALUE == *phDevice)
        {
                return FALSE;
        }

        return TRUE;
}


/*      DeviceChange_Init()
*       First time initialization for WM_DEVICECHANGE messages
*       
*       On NT 5.0, you have to register for device notification
*/
void Volume_DeviceChange_Init(HWND hWnd, DWORD dwMixerID)
{
        DEV_BROADCAST_HANDLE DevBrodHandle;
        HANDLE hMixerDevice=NULL;


        //If we had registered already for device notifications, unregister ourselves.
        Volume_DeviceChange_Cleanup();

        //If we get the device handle register for device notifications on it.
        if(Volume_GetDeviceHandle(dwMixerID, &hMixerDevice))
        {
                memset(&DevBrodHandle, 0, sizeof(DEV_BROADCAST_HANDLE));

                DevBrodHandle.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
                DevBrodHandle.dbch_devicetype = DBT_DEVTYP_HANDLE;
                DevBrodHandle.dbch_handle = hMixerDevice;

                DeviceEventContext = RegisterDeviceNotification(hWnd, &DevBrodHandle, DEVICE_NOTIFY_WINDOW_HANDLE);

                if(hMixerDevice)
                {
                        CloseHandle(hMixerDevice);
                        hMixerDevice = NULL;
                }
    }
}

// Watch for PNP events to free up the open handle when needed
// We will assume any changes will now generate a WINMM_DEVICECHANGED message from WinMM
// except for the QUERYREMOVEFAILED case, in this case we will just re-aquire the preferred mixer
//
void Volume_DeviceChange(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
    PDEV_BROADCAST_HANDLE bh = (PDEV_BROADCAST_HANDLE)lParam;
        
    //If we have an handle on the device then we get a DEV_BROADCAST_HDR structure as the lParam.

    if(!DeviceEventContext || !bh || (bh->dbch_devicetype != DBT_DEVTYP_HANDLE))
    {
        return;
    }
        
    switch (wParam)
    {
        case DBT_DEVICEQUERYREMOVE:             // Someone wants to remove this device, let's let them.
        {
                if (g_hMixer)
                    {
                            mixerClose(g_hMixer);
                            g_hMixer = NULL;
                            g_uMixer = 0;
                            g_dwMixerDevNode = 0L;
                    }
                }
            break;

            case DBT_DEVICEQUERYREMOVEFAILED:       // The query failed, the device will not be removed, so lets reopen it.
        {
            Volume_WinMMDeviceChange(hWnd);     // Lets just use this function to do it.
        }
            break;
    }
}

void Volume_WmDestroy(
   HWND hDlg
   )
{
    Volume_DeviceChange_Cleanup();
}

void Volume_Shutdown(
    HWND hWnd)
{
    Volume_UpdateStatus(hWnd, FALSE, FALSE);
}

void Volume_Menu(HWND hwnd, UINT uMenuNum, UINT uButton)
{
    POINT   pt;
    UINT    iCmd;
    HMENU   hmenu;

    GetCursorPos(&pt);

    hmenu = Volume_CreateMenu();
    if (!hmenu)
                return;

    SetForegroundWindow(hwnd);
    iCmd = TrackPopupMenu(hmenu, uButton | TPM_RETURNCMD | TPM_NONOTIFY,
        pt.x, pt.y, 0, hwnd, NULL);

    DestroyMenu(hmenu);
    switch (iCmd) {
        case VOLUMEMENU_PROPERTIES:
            Volume_ControlPanel(hwnd);
            break;

        case VOLUMEMENU_SNDVOL:
            Volume_VolumeControl();
            break;
    }

    SetIconFocus(hwnd, STWM_NOTIFYVOLUME);

}

void Volume_Notify(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    switch (lParam)
    {
        case WM_RBUTTONUP:
            Volume_Menu(hwnd, 1, TPM_RIGHTBUTTON);
            break;

        case WM_LBUTTONDOWN:
            SetTimer(hwnd, VOLUME_TIMER_ID, GetDoubleClickTime()+100, NULL);
            break;

        case WM_LBUTTONDBLCLK:
            KillTimer(hwnd, VOLUME_TIMER_ID);
            Volume_VolumeControl();
            break;
    }
}


/* WARNING - WARNING - DANGER - DANGER - WARNING - WARNING - DANGER - DANGER */
/* WARNING - WARNING - DANGER - DANGER - WARNING - WARNING - DANGER - DANGER */
/* WARNING - WARNING - DANGER - DANGER - WARNING - WARNING - DANGER - DANGER */
/*
 * MYWM_WAKEUP and the "Tray Volume" window are defined by the SNDVOL32.EXE
 * application.  Changing these values or changing the values in SNDVOL32.EXE
 * without mirroring them here will break the tray volume dialog.
 */
/* WARNING - WARNING - DANGER - DANGER - WARNING - WARNING - DANGER - DANGER */
/* WARNING - WARNING - DANGER - DANGER - WARNING - WARNING - DANGER - DANGER */
/* WARNING - WARNING - DANGER - DANGER - WARNING - WARNING - DANGER - DANGER */

#define MYWM_WAKEUP             (WM_APP+100+6)

void Volume_Timer(HWND hwnd)
{
        KillTimer(hwnd, VOLUME_TIMER_ID);

        Volume_WakeUpOrClose (FALSE);
}

void Volume_WakeUpOrClose(BOOL fClose)
{
        const TCHAR szVolWindow [] = TEXT ("Tray Volume");
        HWND hApp;

        if (hApp = FindWindow(szVolWindow, NULL))
        {
                SendMessage(hApp, MYWM_WAKEUP, (WPARAM)fClose, 0);
        }
        else if (!fClose)
        {
                const TCHAR szOpen[]    = TEXT ("open");
                const TCHAR szVolApp[]  = TEXT ("SNDVOL32.EXE");
                const TCHAR szParamsWakeup[]  = TEXT ("/t");

                ShellExecute (NULL, szOpen, szVolApp, szParamsWakeup, NULL, SW_SHOWNORMAL);
        }
}


/*
 * Volume_ControlPanel
 *
 * Launch "Audio" control panel/property sheet upon request.
 *
 * */
void Volume_ControlPanel(HWND hwnd)
{
        const TCHAR szOpen[]    = TEXT ("open");
        const TCHAR szRunDLL[]  = TEXT ("RUNDLL32.EXE");
        const TCHAR szParams[]  = TEXT ("MMSYS.CPL,ShowFullControlPanel");

        ShellExecute(NULL, szOpen, szRunDLL, szParams, NULL, SW_SHOWNORMAL);
}

/*
 * Volume_VolumeControl
 *
 * Launch Volume Control App
 *
 * */
void Volume_VolumeControl()
{
        const TCHAR szOpen[]    = TEXT ("open");
        const TCHAR szVolApp[]  = TEXT ("SNDVOL32.EXE");

        ShellExecute(NULL, szOpen, szVolApp, NULL, NULL, SW_SHOWNORMAL);
}



/*
 * FileExists
 *
 * Does a file exist
 *
 * */

BOOL FileExists(LPCTSTR pszPath)
{
        return (GetFileAttributes(pszPath) != (DWORD)-1);
} // End FileExists


/*
 * FindSystemFile
 *
 * Finds full path to specified file
 *
 * */

BOOL FindSystemFile(LPCTSTR pszFileName, LPTSTR pszFullPath, UINT cchSize)
{
        TCHAR       szPath[MAX_PATH];
        LPTSTR      pszName;
        DWORD       cchLen;

        if ((pszFileName == NULL) || (pszFileName[0] == 0))
                return FALSE;

        cchLen = SearchPath(NULL, pszFileName, NULL, MAX_PATH,
                                                szPath,&pszName);
        if (cchLen == 0)
                return FALSE;
        
        if (cchLen >= MAX_PATH)
                cchLen = MAX_PATH - 1;

        if (! FileExists (szPath))
                return FALSE;

        if ((pszFullPath == NULL) || (cchSize == 0))
                return TRUE;

           // Copy full path into buffer
        if (cchLen >= cchSize)
                cchLen = cchSize - 1;
        
        lstrcpyn (pszFullPath, szPath, cchLen);
        
        pszFullPath[cchLen] = 0;

        return TRUE;
} // End FindSystemFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\exestub\version.h ===
// Resources for the common version chunk

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Systray .exe stub"
#define VER_INTERNALNAME_STR            "systray"
#define VER_ORIGINALFILENAME_STR        "systray.exe"

#include <ntverp.h>
#include <common.ver>

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\test\main.cpp ===
#include <windows.h>
#include <objbase.h>
#include <docobj.h>
#include <initguid.h>
#include "stobject.h"

int __cdecl main()
{
    HRESULT hr;
    IOleCommandTarget* ptgt;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_SysTray, NULL, CLSCTX_INPROC_SERVER, 
            IID_IOleCommandTarget, (void**) &ptgt);

        if (SUCCEEDED(hr))
        {
            ptgt->Release();
        }

        CoUninitialize();
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\systray\exestub\systray.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       SYSTRAY.C
*
*  VERSION:     2.0
*
*  AUTHOR:      TCS/RAL
*
*  DATE:        08 Feb 1994
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  08 Feb 1994 TCS Original implementation.
*  11 Nov 1994 RAL Converted from batmeter to systray
*  11 Aug 1995 JEM Split batmeter functions into power.c & minor enahncements
*  23 Oct 1995 Shawnb Unicode enabled
*  07 Aug 1998 dsheldon Created systray.dll and made this into a stub exe
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shlobj.h>
#include <shellapi.h>
#include <systrayp.h>
#include <initguid.h>
#include <stclsid.h>

//  Global instance handle of this application.
HINSTANCE g_hInstance;

INT intval(LPCTSTR lpsz)
{
    INT i = 0;
    while (*lpsz >= TEXT ('0') && *lpsz <= TEXT ('9'))
    {
        i = i * 10 + (int)(*lpsz - TEXT ('0'));
        lpsz++;
    }
    return(i);
}

// stolen from the CRT, used to shrink our code

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPTSTR pszCmdLine = GetCommandLine ();

    if ( *pszCmdLine == TEXT ('\"') )
    {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != TEXT ('\"')) )
            ;

        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT ('\"') )
            pszCmdLine++;
    }
    else
    {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' '))
    {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfo (&si);

    i = WinMain(GetModuleHandle(NULL), NULL, (LPSTR)pszCmdLine,
                si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;    // We never come here.
}



/*******************************************************************************
*
*  WinMain
*
*  DESCRIPTION:
*
*  PARAMETERS:
*       if lpCmdLine contains an integer value then we'll enable that service
*
*******************************************************************************/
STDAPI_(int) WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    HWND hWnd;

    HWND hExistWnd = FindWindow(SYSTRAY_CLASSNAME, NULL);
    UINT iEnableServ = intval((LPTSTR)lpszCmdLine);
    g_hInstance = hInstance;

    if (hExistWnd)
    {
        //
        // NOTE: Send an enable message even if the command line parameter
        //       is 0 to force us to re-check for all enabled services.
        //
        PostMessage(hExistWnd, STWM_ENABLESERVICE, iEnableServ, TRUE);
        goto ExitMain;
    }
    else
    {
        int i;

        // We have to inject systray.dll into the explorer process
        if (SUCCEEDED(SHLoadInProc(&CLSID_SysTrayInvoker)))
        {
            // Wait for up to 30 seconds for the window to be created, 
            // send our message every second
        
            for (i = 0; i < 30; i ++)
            {
                Sleep(1000);
                hExistWnd = FindWindow(SYSTRAY_CLASSNAME, NULL);
                if (hExistWnd)
                {
                    PostMessage(hExistWnd, STWM_ENABLESERVICE, iEnableServ, TRUE);
                    goto ExitMain;        
                }
            }
        }
    }

ExitMain:
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\cbsc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cbsc.h
//
//--------------------------------------------------------------------------
#ifndef __TASKUI_CBSC_H
#define __TASKUI_CBSC_H


template <DWORD dwBindFlags=BINDF_ASYNCHRONOUS|BINDF_ASYNCSTORAGE|BINDF_PULLDATA>
class ATL_NO_VTABLE CBindStatusCallback :
    public CComObjectRoot,
    public IBindStatusCallback
{
private:
BEGIN_COM_MAP(CBindStatusCallback)
    COM_INTERFACE_ENTRY(IBindStatusCallback)
END_COM_MAP()

    STDMETHOD(OnStartBinding)(DWORD dwReserved, IBinding *pBinding)
    {
        return S_OK;
    }

    STDMETHOD(GetPriority)(LONG *pnPriority)
    {
        if (NULL == pnPriority)
            return E_POINTER;
        *pnPriority = THREAD_PRIORITY_NORMAL;
        return S_OK;
    }

    STDMETHOD(OnLowResource)(DWORD reserved)
    {
        return S_OK;
    }

    STDMETHOD(OnProgress)(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
    {
        return S_OK;
    }

    STDMETHOD(OnStopBinding)(HRESULT hresult, LPCWSTR szError)
    {
        return S_OK;
    }

    STDMETHOD(GetBindInfo)(DWORD *pgrfBINDF, BINDINFO *pbindInfo)
    {
        if (pbindInfo==NULL || pbindInfo->cbSize==0 || pgrfBINDF==NULL)
            return E_INVALIDARG;

        *pgrfBINDF = dwBindFlags; //BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA;

        ULONG cbSize = pbindInfo->cbSize;       // remember incoming cbSize
        memset(pbindInfo, 0, cbSize);           // zero out structure
        pbindInfo->cbSize = cbSize;             // restore cbSize
        pbindInfo->dwBindVerb = BINDVERB_GET;   // set verb
        return S_OK;
    }

    STDMETHOD(OnDataAvailable)(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
    {
        return S_OK;
    }

    STDMETHOD(OnObjectAvailable)(REFIID riid, IUnknown *punk)
    {
        return S_OK;
    }

public:
    static HRESULT Download(BSTR bstrURL, IStream** ppStream)
    {
        CComObject<CBindStatusCallback<dwBindFlags> > *pbsc;
        HRESULT hr = CComObject<CBindStatusCallback<dwBindFlags> >::CreateInstance(&pbsc);
        if (SUCCEEDED(hr))
        {
            CComPtr<IMoniker> spMoniker;
            hr = CreateURLMoniker(NULL, bstrURL, &spMoniker);
            if (SUCCEEDED(hr))
            {
                CComPtr<IBindCtx> spBindCtx;
                hr = CreateBindCtx(0, &spBindCtx);
                if (SUCCEEDED(hr))
                {
                    hr = RegisterBindStatusCallback(spBindCtx, static_cast<IBindStatusCallback*>(pbsc), 0, 0L);
                    if (SUCCEEDED(hr))
                        hr = spMoniker->BindToStorage(spBindCtx, 0, IID_IStream, (void**)ppStream);
                }
            }
        }
        return hr;
    }
};

HRESULT BindToURL(BSTR bstrURL, IStream** ppStream)
{
    return CBindStatusCallback<>::Download(bstrURL, ppStream);
}

#endif // __TASKUI_CBSC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\debug.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       debug.cpp
//
//--------------------------------------------------------------------------
#include "stdafx.h"

#define DECLARE_DEBUG
#define SZ_DEBUGINI     "taskui.ini"
#define SZ_MODULE       "taskui"
#define SZ_DEBUGSECTION ""
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\cdpa.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cdpa.h
//
//--------------------------------------------------------------------------
#ifndef __TASKUI_CDPA_H
#define __TASKUI_CDPA_H

//
// Each one of these "CpaDestroyer_XXXX" classes implements a single 
// "Destroy" function to free one item held in a DPA.  Currently there
// are only two flavors, one that calls "delete" and one that calls
// "LocalFree".  By default the CDpa class uses the CDpaDestoyer_Delete
// class as that is the most commont form of freeing required.  To use
// another type, just specify another similar class as the 'D' template
// argument to CDpa.
//
template <typename T>
class CDpaDestroyer_Delete
{
    public:
        static void Destroy(T* p)
            { delete p; }
};

template <typename T>
class CDpaDestroyer_Free
{
    public:
        static void Destroy(T* p)
            { if (p) LocalFree(p); }
};

class CDpaDestroyer_None
{
    public:
        static void Destroy(void*)
            { }
};


//-----------------------------------------------------------------------------
// CDpa  - Template class.
//
// Simplifies working with a DPA.
//-----------------------------------------------------------------------------

template <typename T, typename D = CDpaDestroyer_Delete<T> >
class CDpa
{
public:
    explicit CDpa(int cGrow = 4)
        : m_hdpa(DPA_Create(cGrow)) { }

    ~CDpa(void) { Destroy(); }

    bool IsValid(void) const { return NULL != m_hdpa; }

    int Count(void) const
    { 
        return IsValid() ? DPA_GetPtrCount(m_hdpa) : 0;
    }

    const T* Get(int i) const
    {
        ASSERT(IsValid());
        ASSERT(i >= 0 && i < Count());
        return (const T*)DPA_GetPtr(m_hdpa, i);
    }

    T* Get(int i)
    {
        ASSERT(IsValid());
        ASSERT(i >= 0 && i < Count());
        return (T*)DPA_GetPtr(m_hdpa, i);
    }

    const T* operator [](int i) const
    {
        return Get(i);
    }

    T* operator [](int i)
    {
        return Get(i);
    }

    void Set(int i, T* p)
    {
        ASSERT(IsValid());
        ASSERT(i < Count());
        DPA_SetPtr(m_hdpa, i, p);
    }

    int Append(T* p)
    { 
        ASSERT(IsValid());
        return DPA_AppendPtr(m_hdpa, p);
    }

    T* Remove(int i)
    {
        ASSERT(IsValid());
        ASSERT(i >= 0 && i < Count());
        return (T*)DPA_DeletePtr(m_hdpa, i);
    }


private:
    HDPA m_hdpa;

    void Destroy(void)
    {
        if (NULL != m_hdpa)
        {
            const int c = Count();
            for (int i = 0; i < c; i++)
            {
                D::Destroy(Get(i));
            }
            DPA_Destroy(m_hdpa);
            m_hdpa = NULL;
        }
    }

    //
    // Prevent copy.
    //
    CDpa(const CDpa& rhs);
    CDpa& operator = (const CDpa& rhs);
};
                

#endif // __TASKUI_CDPA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__69A4FA0F_C0FB_435E_96D0_CB4D1628A05A__INCLUDED_)
#define AFX_DLLDATAX_H__69A4FA0F_C0FB_435E_96D0_CB4D1628A05A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__69A4FA0F_C0FB_435E_96D0_CB4D1628A05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB    // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define USE_STUBLESS_PROXY //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "TaskUI_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\htmlcontrol.cpp ===
// TaskUI_HTMLControl.cpp : Implementation of CTaskUI_HTMLControl

#include "stdafx.h"
#include "TaskUI.h"
#include "HTMLControl.h"

/////////////////////////////////////////////////////////////////////////////
// CTaskUI_HTMLControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\page.h ===
// Page.h: interface for the TaskPage class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PAGE_H__4E334889_E550_4C84_9C9D_5E8DE8DA11D2__INCLUDED_)
#define AFX_PAGE_H__4E334889_E550_4C84_9C9D_5E8DE8DA11D2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "TaskUI.h"

class TaskPage : public HWNDElement
{
public:
    static HRESULT Create(Element**) { return E_NOTIMPL; } // Required for ClassInfo
    static HRESULT Create(REFCLSID rclsidPage, HWND hParent, OUT TaskPage** ppElement);

    virtual ~TaskPage() { ATOMICRELEASE(_pTaskPage); }

    const CLSID& GetID() const { return _idPage; }
    HRESULT CreateContent(ITaskPage* pPage);
    HRESULT Reinitialize();

protected:
    TaskPage(REFCLSID rclsidPage) : _idPage(rclsidPage), _pTaskPage(NULL) {}

private:
    CLSID _idPage;
    ITaskPage *_pTaskPage;
};

#endif // !defined(AFX_PAGE_H__4E334889_E550_4C84_9C9D_5E8DE8DA11D2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\makefile.inc ===
RES_FILES = \
            taskui.rcv             \
            tasksheet.rgs          \
            HTMLControl.rgs        \
            nbhothi.bmp            \
            nbdef.bmp              \
            nbhot.bmp              \
            nbdefhi.bmp            \
            topleftcorner.bmp      \
            $(O)\taskui.uipp       \


$(SELFREGNAME) : selfreg.inx
    $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $*.cln
    $(CLEANINF) -inf $*.cln $@
    del $*.cln

$(O)\taskui.uipp: taskui.ui resource.h
    $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $*.cln
    $(CLEANINF) -w -htm $*.cln $@
    del $*.cln

taskui.rc : resource.h $(MIDL_TLBDIR)\taskui.tlb $(SELFREGNAME) $(RES_FILES)

taskui.cpp: stdafx.h resource.h $(PASS0_HEADERDIR)\taskui.h dlldatax.h $(PASS0_SOURCEDIR)\taskui_i.c tasksheet.h taskframe.h

tasksheet.h: resource.h taskframe.h
tasksheet.cpp: stdafx.h $(PASS0_HEADERDIR)\taskui.h tasksheet.h propbag.h

taskframe.h: resource.h $(PASS0_HEADERDIR)\taskui.h page.h cdpa.h
taskframe.cpp: stdafx.h taskframe.h

page.h: $(PASS0_HEADERDIR)\taskui.h
page.cpp: stdafx.h page.h

propbag.cpp: stdafx.h $(PASS0_HEADERDIR)\taskui.h cdpa.h

htmlcontrol.cpp: stdafx.h $(PASS0_HEADERDIR)\taskui.h htmlcontrol.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\htmlcontrol.h ===
// TaskUI_HTMLControl.h : Declaration of the CTaskUI_HTMLControl

#ifndef __TASKUI_HTMLCONTROL_H_
#define __TASKUI_HTMLCONTROL_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CTaskUI_HTMLControl
class ATL_NO_VTABLE CTaskUI_HTMLControl : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<ITaskUI_HTMLControl, &IID_ITaskUI_HTMLControl, &LIBID_TASKUILib>,
    public CComControl<CTaskUI_HTMLControl>,
    public IOleControlImpl<CTaskUI_HTMLControl>,
    public IOleObjectImpl<CTaskUI_HTMLControl>,
    public IOleInPlaceActiveObjectImpl<CTaskUI_HTMLControl>,
    public IViewObjectExImpl<CTaskUI_HTMLControl>,
    public IOleInPlaceObjectWindowlessImpl<CTaskUI_HTMLControl>,
    public CComCoClass<CTaskUI_HTMLControl, &CLSID_TaskUI_HTMLControl>
{
public:
    CTaskUI_HTMLControl() : m_strURL(NULL)
    {
        m_bWindowOnly = TRUE;

        CWndClassInfo& wci = GetWndClassInfo();
        if (!wci.m_atom)
        {
            // Modify wndclass here if necessary
            wci.m_wc.style &= ~(CS_HREDRAW | CS_VREDRAW);
        }
    }

DECLARE_REGISTRY_RESOURCEID(IDR_TASKUI_HTMLCONTROL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTaskUI_HTMLControl)
    COM_INTERFACE_ENTRY(ITaskUI_HTMLControl)
    COM_INTERFACE_ENTRY2(IDispatch, ITaskUI_HTMLControl)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
END_COM_MAP()

BEGIN_PROP_MAP(CTaskUI_HTMLControl)
    //PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
    //PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CTaskUI_HTMLControl)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    CHAIN_MSG_MAP(CComControl<CTaskUI_HTMLControl>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IViewObjectEx
    DECLARE_VIEW_STATUS(0)

// ITaskUI_HTMLControl
public:
    STDMETHOD(Initialize)(/*[in]*/ BSTR strURL, /*[in, optional]*/ IDispatch* pExternalDispatch)
    {
        m_strURL = strURL;
        m_spExternalDispatch = pExternalDispatch;
        return S_OK;
    }

// IOleObject overrides
    STDMETHOD(GetExtent)(DWORD /*dwDrawAspect*/, SIZEL *psizel)
    {
        if (psizel == NULL)
            return E_POINTER;

        psizel->cx = MAXLONG;
        psizel->cy = MAXLONG;

        return S_OK;
    }

// Message handlers
    LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
    {
        if (m_strURL)
        {
            CAxWindow wnd(m_hWnd);
            HRESULT hr = wnd.CreateControl(m_strURL);
            if (SUCCEEDED(hr) && m_spExternalDispatch)
                hr = wnd.SetExternalDispatch(m_spExternalDispatch);
            return SUCCEEDED(hr) ? 0 : -1;
        }
        return -1;
    }

private:
    CComBSTR m_strURL;
    CComPtr<IDispatch> m_spExternalDispatch;
};

#endif //__TASKUI_HTMLCONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TaskUI.rc
//
#define IDS_PROJNAME                    100
#define IDR_TASKSHEET                   100
#define ID_BACK                         101
#define ID_FORWARD                      102
#define ID_HOME                         103
#define IDR_TASKUI_UI                   104
#define IDR_ACCEL                       105
#define IDR_TASKUI_HTMLCONTROL          106
#define IDC_STATUSBAR                   200
#define IDC_NAVBAR                      201
#define IDB_NAVBAR                      202
#define IDB_NAVBARHOT                   203
#define IDB_NAVBARHICOLOR               204
#define IDB_NAVBARHOTHICOLOR            205
#define IDB_CORNER                      206
#define IDB_BACKGROUND                  207

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        208
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         207
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\page.cpp ===
// Page.cpp: implementation of the TaskPage class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Page.h"


////////////////////////////////////////////////////////
// ActiveX Host Element

class AxHost : public HWNDHost
{
public:
    static HRESULT Create(Element**) { return E_NOTIMPL; } // Required for ClassInfo
    static HRESULT Create(OUT AxHost** ppElement) { return Create(0, AE_MouseAndKeyboard, ppElement); }
    static HRESULT Create(UINT nCreate, UINT nActive, OUT AxHost** ppElement);

    ~AxHost() { ATOMICRELEASE(_pOleObject); }

    // Initialization
    HRESULT AttachControl(IUnknown* punkObject);

    // Rendering
    virtual SIZE GetContentSize(int dConstW, int dConstH, Surface* psrf);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }

protected:
    AxHost() : _pOleObject(NULL) {}

    virtual HWND CreateHWND(HWND hwndParent)
    {
        return CreateWindowEx(0,
                              CAxWindow::GetWndClassName(),
                              NULL,
                              WS_CHILD | WS_VISIBLE,
                              0, 0, 0, 0,
                              hwndParent,
                              NULL,
                              NULL,
                              NULL);
    }

private:
    IOleObject* _pOleObject;
};

////////////////////////////////////////////////////////
// AxHost Initialization

HRESULT AxHost::Create(UINT nCreate, UINT nActive, OUT AxHost** ppElement)
{
    if (!ppElement)
        return E_POINTER;

    *ppElement = NULL;

    AxHost* pe = new AxHost;
    if (!pe)
        return E_OUTOFMEMORY;

    HRESULT hr = pe->Initialize(nCreate, nActive);
    if (FAILED(hr))
    {
        pe->Destroy();
    }
    else
    {
        *ppElement = pe;
    }

    return hr;
}

HRESULT AxHost::AttachControl(IUnknown* punkObject)
{
    HRESULT hr;

    if (NULL == GetHWND())
        return E_UNEXPECTED;

    if (NULL == punkObject)
        return E_INVALIDARG;

    ATOMICRELEASE(_pOleObject);

    hr = punkObject->QueryInterface(IID_IOleObject, (void**)&_pOleObject);

    if (SUCCEEDED(hr))
    {
        CComPtr<IUnknown> spUnk;
        hr = AtlAxGetHost(GetHWND(), &spUnk);
        if (SUCCEEDED(hr))
        {
            CComPtr<IAxWinHostWindow> spAxHostWindow;
            hr = spUnk->QueryInterface(&spAxHostWindow);
            if (SUCCEEDED(hr))
            {
                hr = spAxHostWindow->AttachControl(punkObject, GetHWND());
            }
        }
    }

    return hr;
}

////////////////////////////////////////////////////////
// AxHost Rendering

SIZE AxHost::GetContentSize(int dConstW, int dConstH, Surface* psrf)
{
    SIZE size = { 0, 0 };

    // Ask the attached ActiveX control for its preferred size
    if (NULL != _pOleObject)
    {
        SIZEL sizeT;
        if (SUCCEEDED(_pOleObject->GetExtent(DVASPECT_CONTENT, &sizeT)))
        {
            int dpiX;
            int dpiY;

            switch (psrf->GetType())
            {
            case Surface::stDC:
                {
                    HDC hDC = CastHDC(psrf);
                    dpiX = GetDeviceCaps(hDC, LOGPIXELSX);
                    dpiY = GetDeviceCaps(hDC, LOGPIXELSX);
                }
                break;

#ifdef GADGET_ENABLE_GDIPLUS
            case Surface::stGdiPlus:
                {
                    Gdiplus::Graphics * pgpgr = CastGraphics(psrf);
                    dpiX = (int)pgpgr->GetDpiX();
                    dpiY = (int)pgpgr->GetDpiY();
                }
                break;
#endif
            default:
                dpiX = dpiY = 96;
                break;
            }

            // Convert from HIMETRIC to pixels
            size.cx = (MAXLONG == sizeT.cx) ? MAXLONG : MulDiv(sizeT.cx, dpiX, 2540);
            size.cy = (MAXLONG == sizeT.cy) ? MAXLONG : MulDiv(sizeT.cy, dpiY, 2540);

            if (-1 != dConstW && size.cx > dConstW) size.cx = dConstW;
            if (-1 != dConstH && size.cy > dConstH) size.cy = dConstH;
        }
    }

    return size;
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
//static PropertyInfo* _aPI[] = {;};

// Define class info with type and base type, set static class pointer
static ClassInfo<AxHost,HWNDHost> _ciAxHost(L"AxHost", NULL, 0);
//static ClassInfo<AxHost,HWNDHost> _ciAxHost(L"AxHost", _aPI, sizeof(_aPI) / sizeof(PropertyInfo*));
IClassInfo* AxHost::Class = &_ciAxHost;


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

HRESULT TaskPage::Create(REFCLSID rclsidPage, HWND hParent, OUT TaskPage** ppElement)
{
    if (!ppElement)
        return E_POINTER;

    *ppElement = NULL;

    TaskPage* pe = new TaskPage(rclsidPage);
    if (!pe)
        return E_OUTOFMEMORY;

    HRESULT hr = pe->Initialize(hParent, /*double-buffer*/ true, 0);
    if (FAILED(hr))
    {
        pe->Destroy();
    }
    else
    {
        *ppElement = pe;
    }

    return hr;
}

HRESULT TaskPage::CreateContent(ITaskPage* pPage)
{
    HRESULT hr;
    UINT nPane;

    if (NULL != _pTaskPage)
        return E_UNEXPECTED;

    if (NULL == _hWnd)
        return E_FAIL;

    if (NULL == pPage)
        return E_INVALIDARG;

    _pTaskPage = pPage;
    _pTaskPage->AddRef();

    for (nPane = 0; ; nPane++)
    {
        // Panes are sequentially numbered, starting at 0, with id names
        // "Pane0", "Pane1", etc.
        WCHAR szPane[16] = L"Pane";
        _ultow(nPane, &szPane[4], 10);

        // Don't use StrToID here since it asserts success
        // but we expect it to fail.
        ATOM atomID = FindAtomW(szPane);
        if (INVALID_ATOM == atomID)
        {
            // No more panes
            break;
        }

        Element *pePane = FindDescendent(atomID);
        if (NULL != pePane)
        {
            // How many objects are in this pane?
            UINT cObjects = 0;
            hr = _pTaskPage->GetObjectCount(nPane, &cObjects);
            if (SUCCEEDED(hr) && 0 != cObjects)
            {
                UINT nObject;
                for (nObject = 0; nObject < cObjects; nObject++)
                {
                    // Create the object
                    CComPtr<IUnknown> spObject;
                    hr = _pTaskPage->CreateObject(nPane, nObject, IID_IUnknown, (void**)&spObject);
                    if (SUCCEEDED(hr))
                    {
                        AxHost* pAxHost;

                        // Create an AxHost container for the object
                        hr = AxHost::Create(&pAxHost);
                        if (SUCCEEDED(hr))
                        {
                            // Add the element to the heirarchy
                            // Note: this is where AxHost::CreateHWND() is called
                            hr = pePane->Add(pAxHost);
                            if (SUCCEEDED(hr))
                            {
                                // Must have an HWND for this to work, so do
                                // this after pePane->Add.
                                hr = pAxHost->AttachControl(spObject);
                                if (FAILED(hr))
                                {
                                    pePane->Remove(pAxHost);
                                    delete pAxHost; //::DestroyWindow(pAxHost->GetHWND());
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // Turn on WS_VISIBLE
    SetVisible(true);

    return S_OK;
}

HRESULT TaskPage::Reinitialize()
{
    if (NULL == _pTaskPage)
        return E_UNEXPECTED;

    return _pTaskPage->Reinitialize(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\propbag.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       propbag.cpp
//
//  This property bag implementation supports the standard COM interface
//  IPropertyBag as well as the specialized interface ITaskSheetPropertyBag.
//
//  The following facilities are available through ITaskSheetPropertyBag.
//
//      1. Property change notifications.
//      2. Constants
//      3. Property groups (namespace scoping)
//      4. Use IDs or names for property identification
//
//
//  Here's the general structure of the implementation.
//
//  The implementation uses 8 C++ classes.
//
//  CPropertyBag - The property bag.
//
//  CPropertyGroup - A group of properties.  All properties in a group
//      exist in their own namespace.  A default 'global' group is always
//      present.  A property bag can have an unlimited number of groups.
//      Groups can be added and removed dynamically by the application.
//
//  CPropertyBucket - A set of properties who's identifiers (ID or name)
//      hash to the same value.  It's just a simple container to manage
//      hash table collisions.  Each property group has HASH_TABLE_SIZE - 1
//      buckets.  Buckets are created on-demand so an unused hash value 
//      has a minimal cost.
//
//  CProperty - A property in the property bag.  A property has an 
//      identifier (ID or name), a value and a set of flags.  Currently,
//      only the "CONSTANT" flag is used.  A property may be a read-write
//      or a constant value.  Each property bucket contains one or more
//      CProperty objects.  CProperty objects may not be removed individually.
//      They are removed only through destruction of the property bag or
//      removal of the parent property group.
//
//  CPropertyName - The identifier of a property.  Abstracts the use
//      of both a property ID and property name from the rest of the 
//      implementation.  Each CProperty object has one CPropertyName
//      member.  Handles identity comparison of two properties.
//
//  CNotifyMap - A simple bit map used to represent notification clients
//      interested in changes to one or more properties in the property
//      bag.  Each bit corresponds directly to an entry in the "notify
//      client table" in the CNotifier object.  The table is merely an 
//      array of pointers to ITaskSheetPropertyNotifySink.  Therefore, if
//      bit 5 is set, that means the the client who's notify sink pointer
//      is stored in element 5 of the notify table wants to be notified.
//
//      Each of the following objects has a notify map:
//
//          1. CPropertyBag - This is the 'global' notify map.  A bit set
//                 in this map indicates the corresponding client is
//                 interested in changes to ANY property in the bag.
// 
//          2. CPropertyGroup - A bit set in a group's notify map indicates
//                 the corresponding client is interested in changes to 
//                 any property in the group.
//
//          3. CProperty - A bit set in a property's notify map indicates
//                 the corresponding client is interested in changes
//                 to this property.
//
//          4. CNotifier - This is the 'active' notify map and is used
//                 to indicate which clients are to receive notification
//                 of the change to the property currently being changed
//                 by a 'set' operation.  See below for a description of
//                 the CNotifier object.
//               
//  CNotifier - Handles registration of notification clients and performs
//      client notifications when properties change.  The property bag
//      has a single CNotifier member.  When a client registers for change
//      notifications, the client's ITaskSheetPropertyNotifySink pointer
//      is stored in the notifier's client table (array of ptrs).  The
//      index of the pointer is the "cookie" returned to the client.
//      When a "set" operation begins, the notifier is initialized and 
//      a reference to it is passed down the function call chain
//      (bag->group->bucket->property).  At the 'bag', 'group' and 'property' 
//      points in the call stack each respective object's "notify map" is 
//      merged into the notifier's 'active' notify map.  Once the call reaches
//      the point of setting the property value, the map contains bits set to 
//      represent each of the notification clients interested in changes to 
//      this property.  The notifier is then called to notify all interested 
//      clients.  Clients may be dynamically added or removed at any time.
//
//
//
//  The implementation of IPropertyBag automatically uses the 'global' 
//  property group.  Therefore, if you were to write some properties
//  through IPropertyBag::Write, those properties would be avaialble through
//  the 'global' property group (PROPGROUP_GLOBAL) when using 
//  ITaskSheetPropertyBag.
//
//
//  [brianau - 06/20/00]
// 
//--------------------------------------------------------------------------
#include "stdafx.h"
#include "taskui.h"
#include "cdpa.h"

//
// Size of each property group hash table.  This should be a prime
// number for best hashing distribution.
//
const int HASH_TABLE_SIZE = 13;
//
// The type of data used by the change notify map.
// A ULONGLONG provides 64 bits which means we can have 64 registered
// notification clients.  Use a DWORD and this drops to 32.
//
typedef ULONGLONG NOTIFYMAPTYPE;
//
// The maximum number of unique change notify connections.  It's just the
// number of bits available in a notify map.
//
const int MAX_NOTIFY_CNX = sizeof(NOTIFYMAPTYPE) * 8;
//
// ----------------------------------------------------------------------------
//     CASE SENSITIVITY
// ----------------------------------------------------------------------------
// The following macro controls the case sensitivity of the property bag.
// By default the macro is undefined and the property bag is case-insensitive
// with respect to property names.  To make the bag case sensitive, uncomment 
// this macro and recompile.
//
// #define TASKUI_PROPBAG_CASE_SENSITIVE
//
inline int ComparePropertyNames(LPCWSTR s1, LPCWSTR s2)
{
#ifdef TASKUI_PROPBAG_CASE_SENSITIVE
    return lstrcmpW(s1, s2);
#else
    return lstrcmpiW(s1, s2);
#endif
}

inline int CharValue(WCHAR c)
{
#ifdef TASKUI_PROPBAG_CASE_SENSITIVE
    return c;
#else
    return towlower(c);
#endif
}


//
// Validate the writeability of an "out" pointer.  This just saves
// us from entering the sizeof() part, potentially reducing bugs.
//
template <typename T>
inline bool IsValidWritePtr(T *p)
{
    return (!IsBadWritePtr(p, sizeof(*p)));
}


//-----------------------------------------------------------------------------
// CNotifyMap
//
// Represents a 64-bit bitmap for the purpose of representing notification
// registrations in the property bag.  There are 3 levels of notify maps
// in the system.
//
//  1. Global   - owned by the CPropertyBag object.
//  2. Group    - one owned by each CPropertyGroup object.
//  3. Property - one owned by each CProperty object.
//
// Whenever a client registers for notification at one of these levels,
// the appropriate map is located and the bit corresponding to that client's
// connection cookie is set.  When a property is set, the union of all three
// maps represents the clients requesting notification.
//
//-----------------------------------------------------------------------------

class CNotifyMap
{
    public:
        CNotifyMap(void)
            : m_bits(0) { }

        bool IsSet(int iBit) const;
            
        HRESULT Set(int iBit, bool bSet);

        bool AnySet(void) const
            { return NOTIFYMAPTYPE(0) != m_bits; }

        void Clear(void)
            { m_bits = NOTIFYMAPTYPE(0); }

        void Union(const CNotifyMap& rhs)
            { m_bits |= rhs.m_bits; }

    private:
        NOTIFYMAPTYPE m_bits;

        bool _IsValidBitIndex(int iBit) const
            { return (iBit < (sizeof(m_bits) * 8)); }

        NOTIFYMAPTYPE _MaskFromBit(int iBit) const
            { return NOTIFYMAPTYPE(1) << iBit; }
};


//
// Set or clear a bit corresponding to a client
//
// Returns:
//    S_OK                - Bit was set or cleared.
//    TSPB_E_NOTIFYCOOKIE - Passed an invalid bit index.
//
HRESULT 
CNotifyMap::Set(
    int iBit, 
    bool bSet      // true == set bit, false == clear
    )
{
    HRESULT hr = TSPB_E_NOTIFYCOOKIE;
    ASSERT(_IsValidBitIndex(iBit));

    if (_IsValidBitIndex(iBit))
    {
        if (bSet)
        {
            m_bits |= _MaskFromBit(iBit);
        }
        else
        {
            m_bits &= ~(_MaskFromBit(iBit));
        }
        hr = S_OK;
    }
    return hr;
}


//
// Determines if a given bit is set in the map.
// On 'free' builds, returns false if an invalid bit number 
// is specified.  Asserts on 'check' builds.
//
bool 
CNotifyMap::IsSet(
    int iBit
    ) const
{ 
    ASSERT(_IsValidBitIndex(iBit)); 

    return (_IsValidBitIndex(iBit) && (0 != (_MaskFromBit(iBit) & m_bits)));
}



//-----------------------------------------------------------------------------
// CNotifier
//
// This class handles all of the duties of client notification including
// client registration, client unregistration and client notification.
//
// A property bag has a notifier as a member.  When a client wishes to
// register for a change notification, the property bag calls CNotifier::Register
// to create an entry in the client table.  The cookie returned is merely the 
// index into the client table.
// 
// When a "set prop" operation begins, the notifier's notification map is set 
// equal to the bag's global notify map and the prop group handle is set to that 
// of the group specified in the "set" operation.  A reference to the 
// notifier is then passed down the chain of "set" calls 
// (bag -> group -> property).  At each point the notify maps are merged 
// (union) so that the map in the notifier represents all requested 
// notifications.  Finally, the CProperty::SetValue method sets the property 
// then calls CNotifier::Notify.  The notifier then scans it's current notify 
// map and notifies each client corresponding to bits set.
//
// That sounds like a lot but it really is quite simple and happens very fast.
// The best thing is that is cleanly handles dynamic registration and
// unregstration of clients as well as addition and removal of properties
// and property categories.
//
//-----------------------------------------------------------------------------

class CNotifier
{
    public:
        explicit CNotifier(ITaskSheetPropertyBag *pBag);
        ~CNotifier(void);

        HRESULT Register(ITaskSheetPropertyNotifySink *pClient, DWORD *pdwCookie);

        HRESULT Unregister(DWORD dwCookie);

        void Notify(LPCWSTR pszPropertyName);

        void MergeWithActiveNotifyMap(const CNotifyMap& map)
            { m_NotifyMapActive.Union(map); }

        void Reset(void)
            { m_NotifyMapActive.Clear(); m_hGroup = PROPGROUP_INVALID; }

        void SetPropertyGroup(HPROPGROUP hGroup)
            { ASSERT(PROPGROUP_INVALID != hGroup); m_hGroup = hGroup; }

    private:
        //
        // A single entry in the connection table.
        // Why use an array of structures rather than simply an array
        // of client pointers?  Good question!  While developing this property
        // bag I've twice stored something along with the client pointer in each
        // client table slot.  Once a ref count, the other time a private data
        // ptr.  As the final design solidified, neither were required.  However,
        // I've left the structure just in case we need to again store something
        // with the client notification pointer. [brianau - 6/20/00].
        //
        struct Entry
        {
            ITaskSheetPropertyNotifySink *pClient;  // Client's notification interface ptr.
        };

        ITaskSheetPropertyBag *m_pBag;                   // Don't addref.  Will create circular reference
        Entry                  m_rgCnx[MAX_NOTIFY_CNX];  // The connection table.
        CNotifyMap             m_NotifyMapActive;        // The "active" notify map.
        HPROPGROUP             m_hGroup;                 // Handle of group associated with prop.
                                                         // with the property bag.

        HRESULT _FindEntry(ITaskSheetPropertyNotifySink *pClient, Entry **ppEntry, DWORD *pdwIndex);
        HRESULT _FindFirstUnusedEntry(Entry **ppEntry, DWORD *pdwIndex);
        //
        // Prevent copy.
        //
        CNotifier(const CNotifier& rhs);
        CNotifier& operator = (const CNotifier& rhs);
};




//-----------------------------------------------------------------------------
// CNotifier
//-----------------------------------------------------------------------------

CNotifier::CNotifier(
    ITaskSheetPropertyBag *pBag
    ) : m_hGroup(PROPGROUP_INVALID),
        m_pBag(pBag)
{
    ASSERT(NULL != m_pBag);

    ZeroMemory(m_rgCnx, sizeof(m_rgCnx));
    //
    // Note that we DON'T addref the property bag interface.
    // Since the CNotifier object is a member of CPropertyBag,
    // that would create a circular reference with the property bag.
    // We can be assured that the notifier's lifetime is contained
    // within the property bag's lifetime.
    //
}


CNotifier::~CNotifier(
    void
    )
{
    for (int i = 0; i < ARRAYSIZE(m_rgCnx); i++)
    {
        if (NULL != m_rgCnx[i].pClient)
        {
            m_rgCnx[i].pClient->Release();
        }
    }
    //
    // DON'T Release m_pBag.  See ctor above for details.
    //
}


//
// Register a notifiation client.  Returns Cookie in pdwCookie to be
// used in call to Unregister if unregistration is desired.
//
// Returns:
//    S_OK    - Registration successful.
//    S_FALSE - Already registered.  
//
HRESULT 
CNotifier::Register(
    ITaskSheetPropertyNotifySink *pClient, 
    DWORD *pdwCookie                   // Optional.  May be NULL.
    )
{
    ASSERT(NULL != pClient);

    Entry *pEntry = NULL;
    DWORD dwIndex = DWORD(-1);
    HRESULT hr = _FindEntry(pClient, &pEntry, &dwIndex);
    if (S_OK == hr)
    {
        //
        // Found existing entry for this client.
        //
        hr = S_FALSE;
    }
    else if (S_FALSE == hr)
    {
        //
        // Need to create a new entry for this client.
        // Find a slot for it.
        //
        hr = _FindFirstUnusedEntry(&pEntry, &dwIndex);
        if (SUCCEEDED(hr))
        {
            ASSERT(NULL == pEntry->pClient);

            pClient->AddRef();
            pEntry->pClient = pClient;
            hr              = S_OK;
        }
    }
    if (SUCCEEDED(hr) && NULL != pdwCookie)
    {
        ASSERT(IsValidWritePtr(pdwCookie));
        ASSERT(DWORD(-1) != dwIndex);

        *pdwCookie = dwIndex;
    }
    return hr;
}


//
// Unregister a client to cancel it's reception of all notifications.
// The dwCookie parameter is the one received via the Register method.
//
// Returns:
//    S_OK                - Connection unregistered.
//    TSPB_E_NOTIFYCOOKIE - Cookie references an invalid connection.
//
HRESULT 
CNotifier::Unregister(
    DWORD dwCookie
    )
{
    HRESULT hr = TSPB_E_NOTIFYCOOKIE;
    if (int(dwCookie) >= 0 && int(dwCookie) < ARRAYSIZE(m_rgCnx))
    {
        Entry& entry = m_rgCnx[dwCookie];
        if (NULL != entry.pClient)
        {
            entry.pClient->Release();
            entry.pClient = NULL;

            hr = S_OK;
        }
    }
    return hr;
}


//
// Called by CProperty::SetValue when a value has been altered.
// This function scans the active notify map and notifies each
// registered client specified by a bit set in the map.
//
void
CNotifier::Notify(
    LPCWSTR pszPropertyName
    )
{
    ASSERT(NULL != m_pBag);
    ASSERT(NULL != pszPropertyName);

    if (m_NotifyMapActive.AnySet())
    {
        //
        // We pass a pointer to the property bag in the notification
        // so we AddRef it to ensure it remains alive across the
        // notification.
        //
        m_pBag->AddRef();
        //
        // As we notify clients we'll clear the corresponding bit in 
        // notify map.  This way we examine the map only as long as
        // necessary.
        //
        for (int i = 0; i < ARRAYSIZE(m_rgCnx) && m_NotifyMapActive.AnySet(); i++)
        {
            if (m_NotifyMapActive.IsSet(i))
            {
                ITaskSheetPropertyNotifySink *pClient = m_rgCnx[i].pClient;

                ASSERT(NULL != pClient);
                if (NULL != pClient)
                {
                    pClient->OnPropChanged(m_pBag, m_hGroup, pszPropertyName);
                    m_NotifyMapActive.Set(i, false);
                }
            }
        }
        m_pBag->Release();
    }
    //
    // Reset our internal state in preparation for the next
    // property notify.  The map should be clear at this point.
    //
    ASSERT(!m_NotifyMapActive.AnySet());
    Reset();
}


//
// Locates an entry in the client table.
// The pClient argument is the key.
// Using COM identity rules, we QI for IUnknown on both the key
// interface and each of the table entries.  If IUnknown ptrs
// match then we found the entry.
//
// Returns:
//    S_OK     - Entry found.
//    S_FALSE  - Entry not found.
//
//
HRESULT
CNotifier::_FindEntry(
    ITaskSheetPropertyNotifySink *pClient,  // Looking for this client.
    Entry **ppEntry,
    DWORD *pdwIndexOut                      // Optional.  Can be NULL.
    )
{
    ASSERT(NULL != pClient);
    ASSERT(NULL != ppEntry);
    ASSERT(IsValidWritePtr(ppEntry));

    Entry *pEntry = NULL;
    DWORD dwIndex = DWORD(-1);
    IUnknown *pUnkClient;

    //
    // Get the IUnknown interface pointer from both the key and
    // each entry.  When we find a match we've found the entry.
    //
    HRESULT hr = pClient->QueryInterface(IID_IUnknown, (void **)&pUnkClient);
    if (SUCCEEDED(hr))
    {
        for (int i = 0; i < ARRAYSIZE(m_rgCnx) && NULL == pEntry; i++)
        {
            if (NULL != m_rgCnx[i].pClient)
            {
                IUnknown *pUnkEntry;
                hr = m_rgCnx[i].pClient->QueryInterface(IID_IUnknown, (void **)&pUnkEntry);
                if (SUCCEEDED(hr))
                {
                    if (pUnkEntry == pUnkClient)
                    {
                        pEntry  = &m_rgCnx[i];
                        dwIndex = i;
                    }
                    pUnkEntry->Release();
                }
            }
        }
        pUnkClient->Release();
    }
    *ppEntry = pEntry;
    if (NULL != pEntry)
    {
        //
        // Entry found.
        //
        ASSERT(DWORD(-1) != dwIndex);

        if (NULL != pdwIndexOut)
        {
            ASSERT(IsValidWritePtr(pdwIndexOut));
            *pdwIndexOut = dwIndex;
        }
        hr = S_OK;
    }
    else if (hr == S_OK)
    {
        //
        // Entry not found.
        //
        ASSERT(NULL == pEntry);
        ASSERT(DWORD(-1) == dwIndex);

        hr = S_FALSE;
    }
    return hr;
}


//
// Search the table for the first unused entry.
// Returns:
//    S_OK                - Unused entry found.
//    TSPB_E_MAXNOTIFYCNX - Notify client table is full.
//
HRESULT
CNotifier::_FindFirstUnusedEntry(
    Entry **ppEntry,
    DWORD *pdwIndexOut          // Optional.  May be NULL.
    )
{
    ASSERT(NULL != ppEntry);
    ASSERT(IsValidWritePtr(ppEntry));

    HRESULT hr    = TSPB_E_MAXNOTIFYCNX;
    Entry *pEntry = NULL;
    DWORD dwIndex = DWORD(-1);
    for (int i = 0; i < ARRAYSIZE(m_rgCnx); i++)
    {
        if (NULL == m_rgCnx[i].pClient)
        {
            pEntry  = &m_rgCnx[i];
            dwIndex = i;
            hr      = S_OK;
            break;
        }
    }
    *ppEntry = pEntry;
    if (SUCCEEDED(hr))
    {
        if (NULL != pdwIndexOut)
        {
            ASSERT(DWORD(-1) != dwIndex);
            ASSERT(IsValidWritePtr(pdwIndexOut));

            *pdwIndexOut = dwIndex;
        }
    }
    ASSERT(FAILED(hr) || DWORD(-1) != dwIndex);
    ASSERT(FAILED(hr) || NULL != pEntry);
    return hr;
}


//-----------------------------------------------------------------------------
// CPropertyName
//
// This class handles the dual-nature of property names.  A name can either be
// a text string or a property ID created wtih the MAKEPROPID macro.  Prop
// IDs are used the same was as Windows Resource IDs thorugh the 
// MAKEINTRESOURCE macro.
//-----------------------------------------------------------------------------

class CPropertyName
{
    public:
        CPropertyName(LPCWSTR pszName);
        ~CPropertyName(void);

        bool IsValid(void) const
            { return NULL != m_pszName; }

        bool CompareEqual(LPCWSTR pszName) const;

        operator LPCWSTR() const
            { return m_pszName; }

    private:
        LPWSTR m_pszName;

        //
        // Prevent copy.
        //
        CPropertyName(const CPropertyName& rhs);
        CPropertyName& operator = (const CPropertyName& rhs);

        static bool IsPropID(LPCWSTR pszName)
            { return IS_PROPID(pszName); }
};


CPropertyName::CPropertyName(
    LPCWSTR pszName
    ) : m_pszName(NULL)
{
    ASSERT(NULL != pszName);

    if (!IsPropID(pszName))
    {
        m_pszName = StrDupW(pszName);
    }
    else
    {
        m_pszName = (LPWSTR)pszName;
    }
}


CPropertyName::~CPropertyName(
    void
    )
{
    if (!IsPropID(m_pszName))
    {
        if (NULL != m_pszName)
        {
            LocalFree(m_pszName);
        }
    }
}


bool 
CPropertyName::CompareEqual (
    LPCWSTR pszName
    ) const
{
    bool bEqual = false;
    //
    // The pszName (and m_pszName) values can be either a pointer to
    // a name string or a property ID.
    //
    const bool bLhsIsID = IsPropID(m_pszName);
    const bool bRhsIsID = IsPropID(pszName);
    if (bLhsIsID == bRhsIsID)
    {
        if (bLhsIsID)
        {
            bEqual = (m_pszName == pszName);
        }
        else
        {
            bEqual = (0 == ComparePropertyNames(m_pszName, pszName));
        }
    }
    return bEqual;
}



//-----------------------------------------------------------------------------
// CProperty
//
// Represents a single property in the property bag.
//-----------------------------------------------------------------------------

class CProperty
{
    public:
        static HRESULT CreateInstance(LPCWSTR pszName, 
                                      const VARIANT *pVar, 
                                      bool bConstant,
                                      CProperty **ppPropOut);

        ~CProperty(void);

        HRESULT SetValue(const VARIANT *pVar, CNotifier& notifier);

        HRESULT GetValue(VARIANT *pVarOut) const;

        LPCWSTR GetName(void) const
            { return m_Name; }

        bool CompareNamesEqual(LPCWSTR pszName) const
            { return m_Name.CompareEqual(pszName); }

        HRESULT Advise(int iClient)
            { m_NotifyMapProperty.Set(iClient, true); return S_OK; }

        HRESULT Unadvise(int iClient)
            { m_NotifyMapProperty.Set(iClient, false); return S_OK; }


    private:
        CProperty(LPCWSTR pszName, const VARIANT *pVar, bool bConstant);

        enum { CONSTANT = 0x00000001 };

        CPropertyName m_Name;               // The property name or prop ID.
        CComVariant   m_Value;              // The value.
        DWORD         m_dwFlags;            // Flags like 'CONSTANT'.
        CNotifyMap    m_NotifyMapProperty;  // Clients who want notification.

        //
        // Prevent copy.
        //
        CProperty(const CProperty& rhs);
        CProperty& operator = (const CProperty& rhs);
};



//
// Create a property.
//
HRESULT 
CProperty::CreateInstance(     // [static]
    LPCWSTR pszName, 
    const VARIANT *pVar, 
    bool bConstant,
    CProperty **ppPropOut
    )
{
    ASSERT(NULL != pszName);
    ASSERT(NULL != ppPropOut);
    ASSERT(IsValidWritePtr(ppPropOut));

    HRESULT hr = E_OUTOFMEMORY;

    *ppPropOut = NULL;
    CProperty *pProp = new CProperty(pszName, pVar, bConstant);
    if (NULL != pProp)
    {
        if (pProp->m_Name.IsValid())
        {
            *ppPropOut = pProp;
            hr = S_OK;
        }
        else
        {
            delete pProp;
        }
    }
    return hr;
}



CProperty::CProperty(
    LPCWSTR pszName,
    const VARIANT *pVar,
    bool bConstant
    ) : m_dwFlags(0),
        m_Name(pszName)
{
    ASSERT(NULL != pszName);
    ASSERT(NULL != pVar);

    if (bConstant)
    {
        m_dwFlags |= CONSTANT;
    }
    m_Value.Copy(pVar);
}



CProperty::~CProperty(
    void
    )
{

}


//
// Set the property's value.
//
// Returns:
//    S_OK               - Value set.
//    S_FALSE            - New value same as old.  Not changed.
//    TSPB_E_MODIFYCONST - Attempt to modify a const property.
//
HRESULT 
CProperty::SetValue(
    const VARIANT *pVar,
    CNotifier& notifier
    )
{
    ASSERT(NULL != pVar);

    HRESULT hr = TSPB_E_MODIFYCONST;
    if (0 == (CONSTANT & m_dwFlags))
    {
        hr = S_FALSE;  // Assume no change.
        //
        // Only set the value and notify clients if the value is 
        // going to change.
        //
        if (m_Value != *pVar)
        {
            //
            // Copy the value.  Must first clear the value to release
            // any VARIANT memory we might be holding.
            //
            m_Value.Clear();
            hr = m_Value.Copy(pVar);
            if (SUCCEEDED(hr))
            {
                //
                // Merge the property's notify map with the 'active' 
                // notify map.  The notifier's 'active' map is now the 
                // union of the 'global' map, the 'group' map and the 
                // 'property' map.  It contains bits representing
                // all of the clients interested in this property change.
                //
                notifier.MergeWithActiveNotifyMap(m_NotifyMapProperty);
                //
                // Notify the clients whos bits are set in the 'active' notify
                // map.
                //
                notifier.Notify(m_Name);
            }
        }
    }
    return hr;
}


//
// Retrieve the property's value.  The value is copied
// the output variant.
//
HRESULT 
CProperty::GetValue(
    VARIANT *pVarOut
    ) const
{ 
    ASSERT(NULL != pVarOut);
    ASSERT(IsValidWritePtr(pVarOut));

    //
    // Must first initialize the output variant before copying.
    //
    ::VariantInit(pVarOut);
    return ::VariantCopy(pVarOut, (VARIANT *)&m_Value);
}



//-----------------------------------------------------------------------------
// CPropertyBucket
//
// This is a simple container representing the chain of collisions in
// a conventional 'linear-chaining' hash table.  The bucket is just a 
// DPA of CProperty object ptrs.
//-----------------------------------------------------------------------------

class CPropertyBucket
{
    public:
        static HRESULT CreateInstance(CPropertyBucket **ppBucketOut);

        ~CPropertyBucket(void);

        HRESULT SetProperty(LPCWSTR pszName, const VARIANT *pVar, CNotifier& notifier);
        HRESULT SetConstProperty(LPCWSTR pszName, const VARIANT *pVAr);
        HRESULT GetProperty(LPCWSTR pszName, VARIANT *pVarOut) const;
        HRESULT Advise(LPCWSTR pszPropertyName, int iClient);
        HRESULT Unadvise(int iClient);

    private:
        CPropertyBucket(void);

        CDpa<CProperty> m_dpaProp;  // DPA of (CProperty *)

        CProperty *_FindProperty(LPCWSTR pszName) const;
        HRESULT _InsertProperty(CProperty *pProp);

        //
        // Prevent copy.
        //
        CPropertyBucket(const CPropertyBucket& rhs);
        CPropertyBucket& operator = (const CPropertyBucket& rhs);
};


//
// Create a bucket.
//
HRESULT 
CPropertyBucket::CreateInstance( // [static]
    CPropertyBucket **ppBucketOut
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    CPropertyBucket *pBucket = new CPropertyBucket();
    if (NULL != pBucket)
    {
        if (pBucket->m_dpaProp.IsValid())
        {
            ASSERT(IsValidWritePtr(ppBucketOut));
            *ppBucketOut = pBucket;
            hr = S_OK;
        }
        else
        {
            delete pBucket;
        }
    }
    return hr;
}



CPropertyBucket::CPropertyBucket(
    void
    ) : m_dpaProp(4)
{

}


CPropertyBucket::~CPropertyBucket(
    void
    )
{
    //
    // Note that the m_dpaProp member is self-destructive.
    //
}



//
// Set a named property in the bucket to a new value.
// If the property doesn't exist it is created.
//
// Returns:
//    S_OK          - Property value set.
//    S_FALSE       - Property value unchanged (dup value).
//    E_OUTOFMEMORY - Insuffient memory to add property.
//
HRESULT 
CPropertyBucket::SetProperty(
    LPCWSTR pszName, 
    const VARIANT *pVar,
    CNotifier& notifier
    )
{
    ASSERT(NULL != pszName);
    ASSERT(NULL != pVar);

    HRESULT hr;
    CProperty *pProp = _FindProperty(pszName);
    if (NULL != pProp)
    {
        //
        // Found the property in the bucket.  Set it's value.
        //
        hr = pProp->SetValue(pVar, notifier);
    }
    else
    {
        //
        // Must be a new property.  Create a property object and
        // insert it into the bucket.
        //
        hr = CProperty::CreateInstance(pszName, pVar, false, &pProp);
        if (SUCCEEDED(hr))
        {
            hr = _InsertProperty(pProp);
            if (FAILED(hr))
            {
                delete pProp;
            }
        }
    }
    return hr;
}



//
// Create a named constant property in the bucket and intialize
// it with the specified value.  Note that this property is now
// a constant and cannot be modified.  It will however be deleted
// when it's parent property group is removed.  If a property of the
// specified name already exists, this method fails.
//
// Returns:
//    S_OK               - Constant created.
//    TSPB_E_MODIFYCONST - Property of this name already exists.
//    E_OUTOFMEMORY      - Insuffient memory to add property.
//
HRESULT 
CPropertyBucket::SetConstProperty(
    LPCWSTR pszName, 
    const VARIANT *pVar
    )
{
    ASSERT(NULL != pszName);
    ASSERT(NULL != pVar);

    HRESULT hr = TSPB_E_MODIFYCONST;
    CProperty *pProp = _FindProperty(pszName);
    if (NULL == pProp)
    {
        hr = CProperty::CreateInstance(pszName, pVar, true, &pProp);
        if (SUCCEEDED(hr))
        {
            hr = _InsertProperty(pProp);
            if (FAILED(hr))
            {
                delete pProp;
            }
        }
    }
    return hr;
}


//
// Retrieve the value of a named property in the bucket.
// Returns:
//    S_OK                - Property retrieved.
//    TSPB_E_PROPNOTFOUND - Property not found.
//
HRESULT 
CPropertyBucket::GetProperty(
    LPCWSTR pszName, 
    VARIANT *pVarOut
    ) const
{
    ASSERT(NULL != pszName);
    ASSERT(NULL != pVarOut);
    ASSERT(IsValidWritePtr(pVarOut));

    HRESULT hr = TSPB_E_PROPNOTFOUND;
    CProperty *pProp = _FindProperty(pszName);
    if (NULL != pProp)
    {
        hr = pProp->GetValue(pVarOut);
    }
    return hr;
}


//
// Register a client for a change notification on a property.
// Returns:
//    S_OK                - Change notify registered on the property.
//    TSPB_E_PROPNOTFOUND - Property not found.
//
HRESULT 
CPropertyBucket::Advise(
    LPCWSTR pszPropertyName, 
    int iClient
    )
{
    ASSERT(NULL != pszPropertyName);

    HRESULT hr = TSPB_E_PROPNOTFOUND;
    CProperty *pProp = _FindProperty(pszPropertyName);
    if (NULL != pProp)
    {
        hr = pProp->Advise(iClient);
    }
    return hr;
}


//
// Remove the change notification registration for a particular
// client.  This cancels the registration on all properties in the
// bucket.
// Returns:
//    Always returns S_OK.
//
HRESULT 
CPropertyBucket::Unadvise(
    int iClient
    )
{
    const int cProps = m_dpaProp.Count();
    for (int i = 0; i < cProps; i++)
    {
        CProperty *pProp = m_dpaProp.Get(i);
        if (NULL != pProp)
        {
            pProp->Unadvise(iClient);
        }
    }
    return S_OK;
}


//
// Find a property (by name) in a bucket.  This is simply
// a linear search.  We don't do any sorting of items in the
// bucket.  
//
// REVIEW:  Sorting items could yield a slight performance
//          improvement if collision chains become long.
//
// Returns NULL if the property is not found.
// If found, the pointer returned is for reference only and
// is not to be deleted by the caller.
//
CProperty *
CPropertyBucket::_FindProperty(
    LPCWSTR pszName
    ) const
{
    ASSERT(NULL != pszName);
    ASSERT(m_dpaProp.IsValid());

    const int cProps = m_dpaProp.Count();
    for (int iProp = 0; iProp < cProps; iProp++)
    {
        const CProperty *pProp = m_dpaProp.Get(iProp);
        ASSERT(NULL != pProp);
        if (pProp->CompareNamesEqual(pszName))
        {
            //
            // This function is const because it doesn't modify
            // the DPA.  However, it returns a non-const ptr
            // to a CProperty object because the caller may 
            // need to change the object.
            //
            return const_cast<CProperty *>(pProp);
        }
    }
    return NULL;
}



//
// Insert a new property object into the bucket.
// This simply appends the pointer onto the DPA.
// It is assumed that the pProp argument is a heap address.
//
HRESULT 
CPropertyBucket::_InsertProperty(
    CProperty *pProp
    )
{
    ASSERT(NULL != pProp);

    HRESULT hr = E_OUTOFMEMORY;
    if (-1 != m_dpaProp.Append(pProp))
    {
        hr = S_OK;
    }
    return hr;
}



//-----------------------------------------------------------------------------
// CPropertyGroup
//
// This class represents a group of properties in the property bag.
// The point is to simulate "scopes" of properties so that clients can create
// separate namespaces within the property bag.  This should help greatly with
// reducing bugs related to 'unexpected' changes in property values resulting
// in name collisions.  Each group is identified in the application 
// namespace by a GUID.  GUID_NULL always represents the 'global' namespace.
// When a group is first created, we hand back a 'handle' that is used in
// all other accesses.  The handle is merely an index into our group table
// providing direct access to a group.  Helper functions are provided to
// return a handle from a property group ID (guid) if necessary.
//
//-----------------------------------------------------------------------------

class CPropertyGroup
{
    public:
        explicit CPropertyGroup(REFGUID id);
        ~CPropertyGroup(void);

        REFGUID GetID(void) const
            { return m_id; }

        HRESULT SetProperty(LPCWSTR pszName, const VARIANT *pVar, CNotifier& notifier);
        HRESULT SetConstProperty(LPCWSTR pszName, const VARIANT *pVar);
        HRESULT GetProperty(LPCWSTR pszName, VARIANT *pVarOut) const;
        HRESULT Advise(LPCWSTR pszPropertyName, int iClient);
        HRESULT Unadvise(int iClient);

    private:
        const GUID       m_id;                          // Property group ID.
        CNotifyMap       m_NotifyMapGroup;    
        CPropertyBucket *m_rgpBuckets[HASH_TABLE_SIZE]; // Hash table buckets.

        DWORD _HashName(LPCWSTR pszName) const;
        
        CPropertyBucket *_GetBucket(LPCWSTR pszName) const;

        //
        // Prevent copy.
        //
        CPropertyGroup(const CPropertyGroup& rhs);
        CPropertyGroup& operator = (const CPropertyGroup& rhs);
};



CPropertyGroup::CPropertyGroup(
    REFGUID id
    ) : m_id(id)
{
    ZeroMemory(m_rgpBuckets, sizeof(m_rgpBuckets));
}


CPropertyGroup::~CPropertyGroup(
    void
    )
{
    for (int iBucket = 0; iBucket < ARRAYSIZE(m_rgpBuckets); iBucket++)
    {
        delete m_rgpBuckets[iBucket];
    }
}


//
// Set the value of a property in the group.
// Will fail if the named property is a constant.
//
// Returns:
//    S_OK                - Property value changed.
//    S_FALSE             - Property value unchanged (dup value).
//    E_OUTOFMEMORY
//    TSPB_E_PROPNOTFOUND - Property name not found.
//    TSPB_E_MODIFYCONST  - Attempt to modify a const property.
//
HRESULT 
CPropertyGroup::SetProperty(
    LPCWSTR pszName, 
    const VARIANT *pVar,
    CNotifier& notifier
    )
{
    ASSERT(NULL != pszName);
    ASSERT(NULL != pVar);

    HRESULT hr = E_OUTOFMEMORY;
    CPropertyBucket *pBucket = _GetBucket(pszName);
    if (NULL != pBucket)
    {
        //
        // Merging the group's notify map with the 'active'
        // map adds those notifications registered at the 
        // group level for this group.
        //
        notifier.MergeWithActiveNotifyMap(m_NotifyMapGroup);
        hr = pBucket->SetProperty(pszName, pVar, notifier);
    }
    return hr;
}



//
// Creates a new constant property and sets its value.
// Since constants are only initialized and cannot be changed,
// this operation does not generate a notification event.
//
// Returns:
//    S_OK
//    E_OUTOFMEMORY
//    TSPB_E_PROPNOTFOUND - Property name not found.
//    TSPB_E_MODIFYCONST  - Attempt to modify a const property.
//
HRESULT 
CPropertyGroup::SetConstProperty(
    LPCWSTR pszName, 
    const VARIANT *pVar
    )
{
    ASSERT(NULL != pszName);
    ASSERT(NULL != pVar);

    HRESULT hr = E_OUTOFMEMORY;
    CPropertyBucket *pBucket = _GetBucket(pszName);
    if (NULL != pBucket)
    {
        hr = pBucket->SetConstProperty(pszName, pVar);
    }
    return hr;
}


//
// Retrieve the value of a property in the property group.
//
// Returns:
//    S_OK
//    E_OUTOFMEMORY
//    TSPB_E_PROPNOTFOUND - Property name not found.
//
HRESULT 
CPropertyGroup::GetProperty(
    LPCWSTR pszName, 
    VARIANT *pVarOut
    ) const
{
    ASSERT(NULL != pszName);
    ASSERT(NULL != pVarOut);
    ASSERT(IsValidWritePtr(pVarOut));

    HRESULT hr = E_OUTOFMEMORY;
    CPropertyBucket *pBucket = _GetBucket(pszName);
    if (NULL != pBucket)
    {
        hr = pBucket->GetProperty(pszName, pVarOut);
    }
    return hr;
}


//
// Register a client for change notifications on a single property
// or all properties in a group.
//
// Returns:
//    S_OK
//    E_OUTOFMEMORY
//    TSPB_E_PROPNOTFOUND - Property name not found.
//    TSPB_E_NOTIFYCOOKIE - iClient is invalid.
//
HRESULT
CPropertyGroup::Advise(
    LPCWSTR pszPropertyName,  // NULL == All properties in group.
    int iClient
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    if (NULL == pszPropertyName || L'\0' == *pszPropertyName)
    {
        //
        // Register for a change on any property in this group.
        //
        hr = m_NotifyMapGroup.Set(iClient, true);
    }
    else
    {
        //
        // Register for a change on a specific property.
        //
        CPropertyBucket *pBucket = _GetBucket(pszPropertyName);
        if (NULL != pBucket)
        {
            hr = pBucket->Advise(pszPropertyName, iClient);
        }
    }
    return hr;
}


//
// Cancel change notifications for a given client on all the property
// group and all properties in the group.
// Always returns S_OK.
//
HRESULT 
CPropertyGroup::Unadvise(
    int iClient
    )
{
    m_NotifyMapGroup.Set(iClient, false);

    for (int i = 0; i < ARRAYSIZE(m_rgpBuckets); i++)
    {
        CPropertyBucket *pBucket = m_rgpBuckets[i];
        if (NULL != pBucket)
        {
            pBucket->Unadvise(iClient);
        }
    }
    return S_OK;
}


//
// Retrieve the address of a bucket object containing a named property.
// The bucket number is calculated by a hash on the property name.
// If a bucket does not yet exist for the property, one is created.
// Returns NULL if a bucket doesn't exist and can't be created.
//
CPropertyBucket *
CPropertyGroup::_GetBucket(
    LPCWSTR pszName
    ) const
{ 
    ASSERT(NULL != pszName);

    const DWORD iBucket = _HashName(pszName);
    if (NULL == m_rgpBuckets[iBucket])
    {
        //
        // Create a new bucket.
        //
        CPropertyBucket *pBucket;
        HRESULT hr = CPropertyBucket::CreateInstance(&pBucket);
        if (SUCCEEDED(hr))
        {
            CPropertyGroup *pNonConstThis = const_cast<CPropertyGroup *>(this);
            pNonConstThis->m_rgpBuckets[iBucket] = pBucket;
        }
    }
    return m_rgpBuckets[iBucket];
}



//
// Generate a hash value from a property name.
// The number generated will be between 0 and HASH_TABLE_SIZE.
//
DWORD
CPropertyGroup::_HashName(
    LPCWSTR pszText
    ) const
{
    LPCWSTR p = NULL;
    DWORD dwCode = 0;
    if (IS_INTRESOURCE(pszText))
    {
        //
        // Property name is really an ID.  In that case just
        // use the (ID % tablesize) as the hash code.
        //
        dwCode = (DWORD)((ULONG_PTR)(pszText));
    }
    else
    {
        DWORD dwTemp = 0;
        for (p = pszText; TEXT('\0') != *p; p++)
        {
            dwCode = (dwCode << 4) + CharValue(*p);
            if (0 != (dwTemp = dwCode & 0xF0000000))
            {
                dwCode = dwCode ^ (dwTemp >> 24);
                dwCode = dwCode ^ dwTemp;
            }
        }
    }

    dwCode %= HASH_TABLE_SIZE;

    ASSERT(dwCode < HASH_TABLE_SIZE);
    return dwCode;
}


//-----------------------------------------------------------------------------
// CPropertyBag
//-----------------------------------------------------------------------------
class CPropertyBag : public IPropertyBag,
                     public ITaskSheetPropertyBag
                     
{
    public:
        ~CPropertyBag(void);

        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();
        //
        // IPropertyBag
        //
        STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
        STDMETHOD(Write)(LPCOLESTR pszPropName, VARIANT *pVar);
        //
        // ITaskSheetPropertyBag
        //
        STDMETHOD(CreatePropertyGroup)(REFGUID idGroup, HPROPGROUP *phGroupOut);
        STDMETHOD(RemovePropertyGroup)(HPROPGROUP hGroup);
        STDMETHOD(Set)(HPROPGROUP hGroup, LPCWSTR pszName, VARIANT *pVar);
        STDMETHOD(SetConst)(HPROPGROUP hGroup, LPCWSTR pszName, VARIANT *pVar);
        STDMETHOD(Get)(HPROPGROUP hGroup, LPCWSTR pszName, VARIANT *pVarOut);
        STDMETHOD(PropertyGroupIdToHandle)(REFGUID id, HPROPGROUP *phGroupOut);
        STDMETHOD(PropertyGroupHandleToId)(HPROPGROUP hGroup, GUID *pidCatOut);
        STDMETHOD(RegisterNotify)(ITaskSheetPropertyNotifySink *pSink, DWORD *pdwCookie);
        STDMETHOD(UnregisterNotify)(DWORD dwCookie);
        STDMETHOD(Advise)(DWORD dwCookie, HPROPGROUP hGroup, LPCWSTR pszPropName);

    private:
        CPropertyBag(void);

        LONG                 m_cRef;
        CNotifyMap           m_NotifyMapGlobal;  // Global notify map.
        CNotifier            m_Notifier;         // Handles notifying clients on chg.
        CDpa<CPropertyGroup> m_dpaGroups;        // DPA of (CPropertyGroup *)

        //
        // Prevent copy.
        //
        CPropertyBag(const CPropertyBag& rhs);
        CPropertyBag& operator = (const CPropertyBag& rhs);

        HRESULT _FindPropertyGroupByID(REFGUID idGroup, HPROPGROUP *phGroup) const;
        HRESULT _GetPropertyGroup(HPROPGROUP hGroup, CPropertyGroup **ppGroup);
        bool _IsValidPropertyGroupHandle(HPROPGROUP hGroup) const;

        //
        // Friendship with instance generator is typical.
        //
        friend HRESULT TaskUiPropertyBag_CreateInstance(REFIID riid, void **ppv);
};



//
// Create a property bag.
//
HRESULT 
TaskUiPropertyBag_CreateInstance(
    REFIID riid,
    void **ppv
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    CPropertyBag *pBag = new CPropertyBag();
    if (NULL != pBag)
    {
        if (pBag->m_dpaGroups.IsValid())
        {
            //
            // Create the 'global' property group.
            //
            HPROPGROUP hGroup;
            hr = pBag->CreatePropertyGroup(PGID_GLOBAL, &hGroup);
            if (SUCCEEDED(hr))
            {
                ASSERT(PROPGROUP_GLOBAL == hGroup);
                hr = pBag->QueryInterface(riid, ppv);
                pBag->Release();
            }
        }
        if (FAILED(hr))
        {
            delete pBag;
        }
    }
    return hr;
}



CPropertyBag::CPropertyBag(
    void
    ) : m_cRef(1),
        m_dpaGroups(4),
        m_Notifier(this)
{


}


CPropertyBag::~CPropertyBag(
    void
    )
{
    //
    // Note that the m_dpaGroups member is self-destructive.
    //
}


STDMETHODIMP
CPropertyBag::QueryInterface(
    REFIID riid,
    void **ppv
    )
{
    static const QITAB qit[] = {
        QITABENT(CPropertyBag, IPropertyBag),
        QITABENT(CPropertyBag, ITaskSheetPropertyBag),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


STDMETHODIMP_ (ULONG)
CPropertyBag::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_ (ULONG)
CPropertyBag::Release(
    void
    )
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}



//
// Returns:
//    S_OK - Group created.
//    E_OUTOFMEMORY.
//    TSPB_E_GROUPEXISTS
//
STDMETHODIMP
CPropertyBag::CreatePropertyGroup(
    REFGUID idGroup,
    HPROPGROUP *phGroupOut
    )
{
    ASSERT(NULL != phGroupOut);
    ASSERT(IsValidWritePtr(phGroupOut));

    if (NULL == phGroupOut || !IsValidWritePtr(phGroupOut))
    {
        //
        // Parameter validation for public API.
        //
        return E_INVALIDARG;
    }

    HRESULT hr = _FindPropertyGroupByID(idGroup, phGroupOut);
    if (S_OK == hr)
    {
        hr = TSPB_E_GROUPEXISTS;
    }
    else if (S_FALSE == hr)
    {
        hr = E_OUTOFMEMORY;
        CPropertyGroup *pGroup = new CPropertyGroup(idGroup);
        if (NULL != pGroup)
        {
            //
            // First try to find an empty slot in the DPA.
            //
            int cSlots = m_dpaGroups.Count();
            for (int i = 0; i < cSlots; i++)
            {
                if (NULL == m_dpaGroups.Get(i))
                {
                    m_dpaGroups.Set(i, pGroup);
                    *phGroupOut = i;
                    pGroup      = NULL;
                    break;
                }
            }
            if (NULL != pGroup)
            {
                //
                // DPA is full, extend it.
                //
                const int iGroup = m_dpaGroups.Append(pGroup);
                if (-1 != iGroup)
                {
                    *phGroupOut = iGroup;
                    hr          = S_OK;
                }
                else
                {
                    delete pGroup;
                }
            }
        }
    }
    return hr;
}


//
// Removes a property group from the bag.  This includes removing
// all of the properties associated with the group.
// Note that the 'global' group cannot be
// removed.  It's scope is the lifetime of the property bag and
// is destroyed when the bag is destroyed.
//
STDMETHODIMP
CPropertyBag::RemovePropertyGroup(
    HPROPGROUP hGroup
    )
{
    CPropertyGroup *pGroup;
    HRESULT hr = _GetPropertyGroup(hGroup, &pGroup);
    if (SUCCEEDED(hr) && PROPGROUP_GLOBAL != hGroup)
    {
        delete pGroup;
        m_dpaGroups.Set(hGroup, NULL);
    }
    return hr;
}


//
// Converts a property group ID (guid) to a group handle.
// The handle returned is the same value that was returned
// in CreatePropertyGroup.
//
STDMETHODIMP
CPropertyBag::PropertyGroupIdToHandle(
    REFGUID idGroup,
    HPROPGROUP *phGroupOut
    )
{
    ASSERT(NULL != phGroupOut);
    ASSERT(IsValidWritePtr(phGroupOut));

    if (NULL == phGroupOut || !IsValidWritePtr(phGroupOut))
    {
        //
        // Parameter validation for public API.
        //
        return E_INVALIDARG;
    }

    HRESULT hr = TSPB_E_GROUPNOTFOUND;
    const int cGroups = m_dpaGroups.Count();
    for (int i = 0; i < cGroups; i++)
    {
        CPropertyGroup *pGroup = m_dpaGroups.Get(i);
        if (NULL != pGroup && IsEqualGUID(pGroup->GetID(), idGroup))
        {
            *phGroupOut = i;
            hr = S_OK;
        }
    }
    return hr;
}


//
// Converts a property group handle to a group ID (guid).
// Returns TSPB_E_GROUPNOTFOUND if the group handle is invalid.
// Cannot retrieve a handle to the pseudo-group handles
// PROPGROUP_ANY or PROPGROUP_INVALID.
//
STDMETHODIMP 
CPropertyBag::PropertyGroupHandleToId(
    HPROPGROUP hGroup, 
    GUID *pidGroupOut
    )
{
    ASSERT(NULL != pidGroupOut);
    ASSERT(IsValidWritePtr(pidGroupOut));

    if (NULL == pidGroupOut || !IsValidWritePtr(pidGroupOut))
    {
        //
        // Parameter validation for public API.
        //
        return E_INVALIDARG;
    }

    CPropertyGroup *pGroup;
    HRESULT hr = _GetPropertyGroup(hGroup, &pGroup);
    if (SUCCEEDED(hr))
    {
        ASSERT(NULL != pGroup);
        *pidGroupOut = pGroup->GetID();
    }
    return hr;
}


//
// Set a property value in the bag.
// 
// Returns:
//    S_OK                 - Property value changed.
//    S_FALSE              - Property value unchanged (dup value).
//    E_INVALIDARG
//    E_OUTOFMEMORY
//    TSPB_E_GROUPNOTFOUND - Invalid group handle.
//    TSPB_E_MODIFYCONST   - Attempt to modify a const property.
//
STDMETHODIMP 
CPropertyBag::Set(
    HPROPGROUP hGroup,
    LPCWSTR pszName,
    VARIANT *pVar
    )
{
    ASSERT(NULL != pszName);
    ASSERT(NULL != pVar);

    if (NULL == pszName || NULL == pVar)
    {
        //
        // Parameter validation for public API.
        //
        return E_INVALIDARG;
    }

    CPropertyGroup *pGroup;
    HRESULT hr = _GetPropertyGroup(hGroup, &pGroup);
    if (SUCCEEDED(hr))
    {
        ASSERT(NULL != pGroup);
        //
        // Initialize the active notify map to the content of the 
        // global notify map.
        //
        m_Notifier.Reset();
        m_Notifier.MergeWithActiveNotifyMap(m_NotifyMapGlobal);
        m_Notifier.SetPropertyGroup(hGroup);
        hr = pGroup->SetProperty(pszName, pVar, m_Notifier);
    }
    return hr;
}


//
// Create a constant property value in the bag.
//
// 
// Returns:
//    S_OK
//    E_INVALIDARG
//    E_OUTOFMEMORY
//    TSPB_E_GROUPNOTFOUND - Invalid group handle.
//    TSPB_E_MODIFYCONST   - Attempt to modify a const property.
//
STDMETHODIMP 
CPropertyBag::SetConst(
    HPROPGROUP hGroup,
    LPCWSTR pszName, 
    VARIANT *pVar
    )
{
    ASSERT(NULL != pszName);
    ASSERT(NULL != pVar);

    if (NULL == pszName || NULL == pVar)
    {
        //
        // Parameter validation for public API.
        //
        return E_INVALIDARG;
    }

    CPropertyGroup *pGroup;
    HRESULT hr = _GetPropertyGroup(hGroup, &pGroup);
    if (SUCCEEDED(hr))
    {
        ASSERT(NULL != pGroup);
        hr = pGroup->SetConstProperty(pszName, pVar);
    }
    return hr;
}


//
// Retrieve property value from the bag.
// 
// Returns:
//    S_OK
//    E_INVALIDARG
//    E_OUTOFMEMORY
//    TSPB_E_GROUPNOTFOUND - Invalid group handle.
//    TSPB_E_MODIFYCONST   - Attempt to modify a const property.
//
STDMETHODIMP 
CPropertyBag::Get(
    HPROPGROUP hGroup,
    LPCWSTR pszName, 
    VARIANT *pVarOut
    )
{
    ASSERT(NULL != pszName);
    ASSERT(NULL != pVarOut);
    ASSERT(IsValidWritePtr(pVarOut));

    if (NULL == pszName || NULL == pVarOut || !IsValidWritePtr(pVarOut))
    {
        //
        // Parameter validation for public API.
        //
        return E_INVALIDARG;
    }

    CPropertyGroup *pGroup;
    HRESULT hr = _GetPropertyGroup(hGroup, &pGroup);
    if (SUCCEEDED(hr))
    {
        ASSERT(NULL != pGroup);
        hr = pGroup->GetProperty(pszName, pVarOut);
    }
    return hr;
}



//
// Register an interface pointer for property change notifications.
//
STDMETHODIMP 
CPropertyBag::RegisterNotify(
    ITaskSheetPropertyNotifySink *pSink, 
    DWORD *pdwCookie
    )
{
    ASSERT(NULL != pSink);
    ASSERT(NULL != pdwCookie);

    if (NULL == pSink || NULL == pdwCookie || !IsValidWritePtr(pdwCookie))
    {
        //
        // Parameter validation for public API.
        //
        return E_INVALIDARG;
    }

    return m_Notifier.Register(pSink, pdwCookie);
}



//
// Cancel all notifications associated with a given connection cookie.
//
// Returns:
//    S_OK
//    TSPB_E_GROUPNOTFOUND - Invalid group handle.
//
STDMETHODIMP 
CPropertyBag::UnregisterNotify(
    DWORD dwCookie
    )
{
    //
    // Unegister the sink with the notifier.
    //
    HRESULT hr = m_Notifier.Unregister(dwCookie);
    if (SUCCEEDED(hr))
    {
        //
        // Unregister from the global notify map.
        //
        m_NotifyMapGlobal.Set(dwCookie, false);
        //
        // Unregister each property group.
        //
        const cGroups = m_dpaGroups.Count();
        for (int i = 0; i < cGroups; i++)
        {
            CPropertyGroup *pGroup = m_dpaGroups.Get(i);
            if (NULL != pGroup)
            {
                pGroup->Unadvise(dwCookie);
            }
        }
    }
    return hr;
}


//
// Request that a notification interface be notified when certain 
// properties change.  The interface is identified by the 'cookie' that
// was returned in RegisterNotify.
// The property(s) of interested are identified through the hGroup
// and pszPropertyName arguments as follows:
//
//  hGroup          pszPropName(*)    Notify triggered on change
// ------------     ----------------  ------------------------------------
// ANYPROPGROUP     <ignored>         Any property in the bag.
// PROPGROUP_GLOBAL NULL              Any property in the global group
// PROPGROUP_GLOBAL Non-NULL          Named property in the global group
// Other            NULL              Any property in the group
// Other            Non-NULL          Named property in the group
//
// (*) For the prop name, NULL and L"" are equivalent.
//
// Returns:
//    S_OK
//    E_INVALIDARG
//    E_OUTOFMEMORY
//    TSPB_E_GROUPNOTFOUND - Invalid group handle.
//
STDMETHODIMP 
CPropertyBag::Advise(
    DWORD dwCookie,
    HPROPGROUP hGroup,
    LPCWSTR pszPropertyName
    )
{
    HRESULT hr;
    if (PROPGROUP_ANY == hGroup)
    {
        //
        // Register for changes in any property.
        //
        hr = m_NotifyMapGlobal.Set(dwCookie, true);
    }
    else
    {
        CPropertyGroup *pGroup;
        hr = _GetPropertyGroup(hGroup, &pGroup);
        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != pGroup);
            //
            // Register for changes in either a group or a specific
            // property.
            //
            hr = pGroup->Advise(pszPropertyName, dwCookie);
        }
    }
    return hr;
}




//
// IPropertyBag implementation.
//
// Read a property from the 'global' namespace.
//
// BUGBUG:  Do we need to do anything with pErrorLog?
//
STDMETHODIMP 
CPropertyBag::Read(
    LPCOLESTR pszPropName, 
    VARIANT *pVar, 
    IErrorLog * /* unused */
    )
{
    ASSERT(NULL != pszPropName);
    ASSERT(NULL != pVar);
    ASSERT(IsValidWritePtr(pVar));

    if (NULL == pszPropName || NULL == pVar || !IsValidWritePtr(pVar))
    {
        //
        // Parameter validation for public API.
        //
        return E_INVALIDARG;
    }
    return Get(PROPGROUP_GLOBAL, pszPropName, pVar);
}


//
// Write a property to the 'global' namespace.
//

STDMETHODIMP 
CPropertyBag::Write(
    LPCOLESTR pszPropName, 
    VARIANT *pVar
    )
{
    ASSERT(NULL != pszPropName);
    ASSERT(NULL != pVar);

    if (NULL == pszPropName || NULL == pVar)
    {
        //
        // Parameter validation for public API.
        //
        return E_INVALIDARG;
    }
    return Set(PROPGROUP_GLOBAL, pszPropName, pVar);
}


//
// Locate a property group by it's ID (guid), returning it's handle.
// Returns:
//    S_OK    - Found group.
//    S_FALSE - Didn't find group.
//
HRESULT
CPropertyBag::_FindPropertyGroupByID(
    REFGUID idGroup,
    HPROPGROUP *phGroup
    ) const
{
    ASSERT(NULL != phGroup);
    ASSERT(IsValidWritePtr(phGroup));

    const int cCategories = m_dpaGroups.Count();
    for (int i = 0; i < cCategories; i++)
    {
        const CPropertyGroup *pGroup = m_dpaGroups.Get(i);
        if (NULL != pGroup && IsEqualGUID(pGroup->GetID(), idGroup))
        {
            *phGroup = i;
            return S_OK;
        }
    }
    return S_FALSE;
}


//
// Determine if a group handle is valid.
// Note that the pseudo handle PROPGROUP_GLOBAL is valid.
//
bool 
CPropertyBag::_IsValidPropertyGroupHandle(
    HPROPGROUP hGroup
    ) const
{
    return (PROPGROUP_ANY != hGroup &&
            PROPGROUP_INVALID != hGroup &&
            hGroup < m_dpaGroups.Count());
}


//
// Retrieve the address of the CPropertyGroup object associated
// with a particular group handle.  The function performs handle
// validation.
//
HRESULT 
CPropertyBag::_GetPropertyGroup(
    HPROPGROUP hGroup, 
    CPropertyGroup **ppGroup
    )
{
    ASSERT(NULL != ppGroup);
    ASSERT(IsValidWritePtr(ppGroup));

    HRESULT hr = TSPB_E_GROUPNOTFOUND;
    if (_IsValidPropertyGroupHandle(hGroup))
    {
        *ppGroup = m_dpaGroups.Get(hGroup);
        hr = S_OK;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\propbag.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       propbag.h
//
//--------------------------------------------------------------------------
#ifndef __TASKUI_PROPBAG_H
#define __TASKUI_PROPBAG_H


HRESULT TaskUiPropertyBag_CreateInstance(REFIID riid, void **ppv);

#endif // __TASKUI_PROPBAG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__582E89EB_1452_4A9B_9642_4F9E1EFFC387__INCLUDED_)
#define AFX_STDAFX_H__582E89EB_1452_4A9B_9642_4F9E1EFFC387__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <windows.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <debug.h>
#include <ccstock.h>
#include <ctype.h>

#ifdef GADGET_ENABLE_GDIPLUS
#include <gdiplus.h>
using namespace Gdiplus;
#endif

// DirectUser and DirectUI
#define GADGET_ENABLE_TRANSITIONS
#define GADGET_ENABLE_CONTROLS
#include <duser.h>
#include <directui.h>

using namespace DirectUI;
UsingDUIClass(Element);
UsingDUIClass(HWNDElement);
UsingDUIClass(HWNDHost);

#ifndef GADGET_ENABLE_GDIPLUS
#include <gdiplus.h>
using namespace Gdiplus;
#endif


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlhost.h>
#include <atlwin.h>
#include <mshtml.h>
#include <exdisp.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__582E89EB_1452_4A9B_9642_4F9E1EFFC387__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\taskframe.h ===
// TaskFrame.h: Definition of the CTaskFrame class
//
//////////////////////////////////////////////////////////////////////

#if !defined(__TASKFRAME_H_INCLUDED_)
#define __TASKFRAME_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

#include "TaskUI.h"
#include "Page.h"
#include "cdpa.h"

extern HACCEL g_hAccel;

/////////////////////////////////////////////////////////////////////////////
// CTaskFrame

class CTaskFrame : 
    public CComObjectRoot,
    public CWindowImpl<CTaskFrame, CWindow, CFrameWinTraits>,
    public ITaskFrame
{
public:
    CTaskFrame();
    virtual ~CTaskFrame();

DECLARE_NOT_AGGREGATABLE(CTaskFrame) 

BEGIN_COM_MAP(CTaskFrame)
COM_INTERFACE_ENTRY(ITaskFrame)
END_COM_MAP()

BEGIN_MSG_MAP(CTaskFrame)
    if (g_hAccel && TranslateAcceleratorW(m_hWnd, g_hAccel, (LPMSG)GetCurrentMessage()))
    {
        return TRUE;
    }
MESSAGE_HANDLER(WM_CREATE, _OnCreate)
MESSAGE_HANDLER(WM_SIZE, _OnSize)
MESSAGE_HANDLER(WM_ERASEBKGND, _OnEraseBackground)
COMMAND_ID_HANDLER(ID_BACK, _OnBack)
COMMAND_ID_HANDLER(ID_FORWARD, _OnForward)
COMMAND_ID_HANDLER(ID_HOME, _OnHome)
NOTIFY_HANDLER(IDC_NAVBAR, TBN_GETINFOTIP, _OnTBGetInfoTip)
NOTIFY_HANDLER(IDC_NAVBAR, NM_CUSTOMDRAW, _OnTBCustomDraw)
MESSAGE_HANDLER(WM_APPCOMMAND, _OnAppCommand)
MESSAGE_HANDLER(WM_GETMINMAXINFO, _OnGetMinMaxInfo)
END_MSG_MAP()

public:

// ITaskFrame
    STDMETHOD(GetPropertyBag)(REFIID riid, void **ppv)
    {
        if (ppv == NULL)
            return E_POINTER;
        if (m_pPropertyBag)
            return m_pPropertyBag->QueryInterface(riid, ppv);
        return E_UNEXPECTED;
    }
    STDMETHOD(ShowPage)(REFCLSID rclsidPage, BOOL bTrimHistory);
    STDMETHOD(Back)(UINT cPages);
    STDMETHOD(Forward)();
    STDMETHOD(Home)();
    STDMETHOD(Close)()
    {
        if (IsWindow())
        {
            SendMessage(WM_CLOSE);
            return S_OK;
        }
        return E_UNEXPECTED;
    }
    STDMETHOD(SetStatusText)(LPCWSTR pszText);

    static HRESULT CreateInstance(IPropertyBag *pPropertyBag, ITaskPageFactory *pPageFactory, CComObject<CTaskFrame> **ppFrameOut);
    HWND CreateFrameWindow(HWND hwndOwner, UINT nID = 0, LPVOID pParam = NULL);

protected:
    HRESULT _Init(IPropertyBag* pBag, ITaskPageFactory* pPageFact);

private:
    IPropertyBag* m_pPropertyBag;
    ITaskPageFactory* m_pPageFactory;
    Parser *m_pUIParser;
    HWND m_hwndNavBar;
    HWND m_hwndStatusBar;
    HIMAGELIST m_himlNBDef;
    HIMAGELIST m_himlNBHot;
    Bitmap* m_pbmWatermark;
    CDpa<TaskPage, CDpaDestroyer_None> m_dpaHistory;
    int m_iCurrentPage;
    RECT m_rcPage;
    POINT m_ptMinSize;
    BOOL m_bResizable;

    HRESULT _ReadProp(LPCWSTR pszProp, VARTYPE vt, CComVariant& var);

    void _CreateNavBar();
    void _SetNavBarState();
    HRESULT _CreatePage(REFCLSID rclsidPage, TaskPage **ppPage);
    HRESULT _ActivatePage(int iPage, BOOL bInit = FALSE);
    HRESULT _DeactivateCurrentPage();
    void _SyncPageRect(TaskPage* pPage);
    void _DestroyPage(TaskPage* pPage);

    LRESULT _OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT _OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT _OnEraseBackground(UINT, WPARAM, LPARAM, BOOL&) { return 0; }
    LRESULT _OnBack(WORD, WORD, HWND, BOOL&)                { Back(1); return 0; }
    LRESULT _OnForward(WORD, WORD, HWND, BOOL&)             { Forward(); return 0; }
    LRESULT _OnHome(WORD, WORD, HWND, BOOL&)                { Home(); return 0; }
    LRESULT _OnTBGetInfoTip(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT _OnTBCustomDraw(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT _OnAppCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT _OnGetMinMaxInfo(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};

#endif // !defined(__TASKFRAME_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\taskframe.cpp ===
// TaskFrame.cpp : Implementation of CTaskUIApp and DLL registration.

#include "stdafx.h"
#include "TaskFrame.h"
#include "cbsc.h"


/////////////////////////////////////////////////////////////////////////////
//

//
// Create and initialize an instance of the task frame.
//
HRESULT 
CTaskFrame::CreateInstance(     // [static]
    IPropertyBag *pPropertyBag, 
    ITaskPageFactory *pPageFactory, 
    CComObject<CTaskFrame> **ppFrameOut
    )
{
    ASSERT(NULL != pPropertyBag);
    ASSERT(NULL != pPageFactory);
    ASSERT(!IsBadWritePtr(ppFrameOut, sizeof(*ppFrameOut)));

    CComObject<CTaskFrame> *pFrame;
    HRESULT hr = CComObject<CTaskFrame>::CreateInstance(&pFrame);
    if (SUCCEEDED(hr))
    {
        hr = pFrame->_Init(pPropertyBag, pPageFactory);
        if (SUCCEEDED(hr))
        {
            pFrame->AddRef();
        }
        else
        {
            delete pFrame;
            pFrame = NULL;
        }
    }
    *ppFrameOut = pFrame;

    ASSERT(SUCCEEDED(hr) || NULL == *ppFrameOut);
    return hr;
}


CTaskFrame::CTaskFrame()
    : m_pPropertyBag(NULL), m_pPageFactory(NULL), m_pUIParser(NULL),
      m_hwndNavBar(NULL), m_hwndStatusBar(NULL),
      m_himlNBDef(NULL), m_himlNBHot(NULL), m_pbmWatermark(NULL)
{
    SetRectEmpty(&m_rcPage);
    m_ptMinSize.x = m_ptMinSize.y = 0;

    // DUI initialization
    InitThread();
}


CTaskFrame::~CTaskFrame()
{
    Close();

    // m_dpaHistory is self-destructing

    if (m_himlNBDef)
        ImageList_Destroy(m_himlNBDef);
    if (m_himlNBHot)
        ImageList_Destroy(m_himlNBHot);

    ATOMICRELEASE(m_pPropertyBag);
    ATOMICRELEASE(m_pPageFactory);

    delete m_pbmWatermark;
    delete m_pUIParser;

    // DUI shutdown
    UnInitThread();
}

void CALLBACK TaskUIParseError(LPCWSTR pszError, LPCWSTR pszToken, int dLine)
{
//#if DBG
#if 1
    WCHAR buf[201];

    if (dLine != -1)
        swprintf(buf, L"%s '%s' at line %d", pszError, pszToken, dLine);
    else
        swprintf(buf, L"%s '%s'", pszError, pszToken);

    MessageBoxW(NULL, buf, L"Parser Message", MB_OK);
#endif
}

HRESULT CTaskFrame::_Init(IPropertyBag* pBag, ITaskPageFactory* pPageFact)
{
    HRESULT hr;

    if (!pBag || !pPageFact)
        return E_INVALIDARG;

    m_pPropertyBag = pBag;
    m_pPropertyBag->AddRef();

    m_pPageFactory = pPageFact;
    m_pPageFactory->AddRef();

    m_iCurrentPage = -1;

    hr = Parser::Create(IDR_TASKUI_UI, _Module.GetResourceInstance(), TaskUIParseError, &m_pUIParser);
    if (FAILED(hr))
        return hr;

    if (m_pUIParser->WasParseError())
        return E_FAIL;

    CWndClassInfo& wci = GetWndClassInfo();
    if (!wci.m_atom)
    {
        // Modify wndclass here if necessary
        wci.m_wc.style &= ~(CS_HREDRAW | CS_VREDRAW);
    }

    return S_OK;
}

HWND CTaskFrame::CreateFrameWindow(HWND hwndOwner, UINT nID, LPVOID pParam)
{
    if (NULL == m_pPropertyBag)
        return NULL;

    // Register the AtlAxHost window class, etc.
    AtlAxWinInit();

    // Default window styles & dimensions
    DWORD dwWndStyle = GetWndStyle(0);      // WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS
    DWORD dwWndExStyle = GetWndExStyle(0);  // WS_EX_APPWINDOW | WS_EX_WINDOWEDGE
    RECT rcFrame = CWindow::rcDefault;      // { CW_USEDEFAULT, CW_USEDEFAULT, 0, 0 }

    CComVariant var;

    // Get the initial window dimensions from the property bag
    if (SUCCEEDED(_ReadProp(TS_PROP_WIDTH, VT_I4, var)))
    {
        rcFrame.right = rcFrame.left + var.lVal;
    }
    if (SUCCEEDED(_ReadProp(TS_PROP_HEIGHT, VT_I4, var)))
    {
        rcFrame.bottom = rcFrame.top + var.lVal;
    }

    // See if we're resizable. Default is TRUE;
    m_bResizable = TRUE;
    if (SUCCEEDED(_ReadProp(TS_PROP_RESIZABLE, VT_BOOL, var)))
    {
        m_bResizable = (VARIANT_TRUE == var.boolVal);
    }
    if (m_bResizable)
    {
        // Resizable: get minimum dimensions if provided
        if (SUCCEEDED(_ReadProp(TS_PROP_MINWIDTH, VT_I4, var)))
        {
            m_ptMinSize.x = var.lVal;
        }
        if (SUCCEEDED(_ReadProp(TS_PROP_MINHEIGHT, VT_I4, var)))
        {
            m_ptMinSize.y = var.lVal;
        }
    }
    else
    {
        // No resize: switch to a simple border style and don't allow maximize
        dwWndStyle = (dwWndStyle & ~(WS_THICKFRAME | WS_MAXIMIZEBOX)) | WS_BORDER;
    }

    // See if we're modeless. Default is FALSE (modal).
    BOOL bModeless = FALSE;
    if (SUCCEEDED(_ReadProp(TS_PROP_MODELESS, VT_BOOL, var)))
    {
        bModeless = (VARIANT_TRUE == var.boolVal);
    }
    if (!bModeless)
    {
        // Modal

        if (!m_bResizable)
            dwWndExStyle |= WS_EX_DLGMODALFRAME;

        // If not a top-level window, disallow minimize
        if (hwndOwner)
            dwWndStyle &= ~WS_MINIMIZEBOX;
    }

    // Get the application graphics
    if (SUCCEEDED(_ReadProp(TS_PROP_WATERMARK, VT_BSTR, var)))
    {
        CComPtr<IStream> spStream;
        HRESULT hr = BindToURL(var.bstrVal, &spStream);
        if (SUCCEEDED(hr))
        {
            // Create GDI+ Bitmap from stream
            delete m_pbmWatermark;
            m_pbmWatermark = Bitmap::FromStream(spStream);
            if (NULL != m_pbmWatermark && (Ok != m_pbmWatermark->GetLastStatus()))
            {
                delete m_pbmWatermark;
                m_pbmWatermark = NULL;
            }
            // Later, when creating a page, set m_pbmWatermark as content of the
            // "Picture" element
        }
    }

    // Get the window title from the property bag
    CComVariant varTitle;
    if (FAILED(_ReadProp(TS_PROP_TITLE, VT_BSTR, varTitle)))
    {
        // Use NULL for no title
        varTitle.bstrVal = NULL;
    }

    dwWndExStyle |= WS_EX_CONTROLPARENT;

    return Create(hwndOwner, rcFrame, varTitle.bstrVal, dwWndStyle, dwWndExStyle, nID, pParam);
}

STDMETHODIMP CTaskFrame::ShowPage(REFCLSID rclsidNewPage, BOOL bTrimHistory)
{
    HRESULT hr;
    int iPage;
    TaskPage *pSavePage = NULL;

    if (!m_dpaHistory.IsValid())
        return E_OUTOFMEMORY;

    hr = S_OK;

    // m_iCurrentPage = -1 should only occur when Count = 0
    ASSERT(-1 != m_iCurrentPage || 0 == m_dpaHistory.Count());

    // If we don't have any pages, then we can't trim the history
    if (-1 == m_iCurrentPage)
        bTrimHistory = FALSE;

    // First remove any forward pages from the history.
    // Note that we never remove the first page (index 0).
    for (iPage = m_dpaHistory.Count() - 1; iPage > 0 && iPage > m_iCurrentPage; iPage--)
    {
        TaskPage *pPage = m_dpaHistory[iPage];
        ASSERT(NULL != pPage);

        // Optimization: if we are navigating forward and the next page
        // is the page we want, go directly there and reinitialize it.
        if (!bTrimHistory && iPage == m_iCurrentPage+1 && rclsidNewPage == pPage->GetID())
        {
            hr = _ActivatePage(iPage, TRUE);
            if (SUCCEEDED(hr))
            {
                _SetNavBarState();
                return hr;
            }
        }

        m_dpaHistory.Remove(iPage);

        // TODO OPTIMIZATION: cache the page
        _DestroyPage(pPage);
    }

    // Either m_iCurrentPage = -1 and Count = 0, or
    // m_iCurrentPage is the last page (Count-1) since
    // we just truncated the history.
    ASSERT(m_iCurrentPage + 1 == m_dpaHistory.Count());

    iPage = m_iCurrentPage;
    _DeactivateCurrentPage(); // sets m_iCurrentPage to -1

    if (bTrimHistory)
    {
        // Can't delete this guy right right away since he's still
        // processing messages (this is the page we just deactivated).
        pSavePage = m_dpaHistory[iPage];

        // Work backwards looking for rclsidNewPage, trimming as we go.
        // Note that we never remove the first page (index 0).
        while (0 < iPage)
        {
            TaskPage *pPage = m_dpaHistory[iPage];
            ASSERT(NULL != pPage);

            if (rclsidNewPage == pPage->GetID())
                break;

            m_dpaHistory.Remove(iPage);
            if (pSavePage != pPage)
            {
                // TODO OPTIMIZATION: cache the page
                _DestroyPage(pPage);
            }

            --iPage;
        }
    }

    // Create a new page if necessary
    TaskPage *pNewPage = NULL;
    TaskPage *pCurrentPage = (-1 == iPage) ? NULL : m_dpaHistory[iPage];
    if (NULL == pCurrentPage || rclsidNewPage != pCurrentPage->GetID())
    {
        hr = _CreatePage(rclsidNewPage, &pNewPage);
        if (SUCCEEDED(hr))
        {
            iPage = m_dpaHistory.Append(pNewPage);
        }
    }

    if (FAILED(hr) || -1 == iPage)
    {
        // Something bad happened, try to activate the home page
        if (0 < m_dpaHistory.Count())
        {
            _ActivatePage(0);
        }
        if (NULL != pNewPage)
        {
            _DestroyPage(pNewPage);
        }
    }
    else
    {
        // Show the page
        hr = _ActivatePage(iPage, NULL != pNewPage ? FALSE : TRUE);
    }

    _SetNavBarState();

    if (pSavePage)
    {
        // TODO: need to free this guy later (currently leaked)
    }

    return hr;
}

STDMETHODIMP CTaskFrame::Back(UINT cPages)
{
    HRESULT hr;

    if (-1 == m_iCurrentPage || 0 == m_dpaHistory.Count())
        return E_UNEXPECTED;

    hr = S_FALSE;

    if (0 < m_iCurrentPage)
    {
        int iNewPage;

        ASSERT(m_iCurrentPage < m_dpaHistory.Count());

        if (0 == cPages)
            iNewPage = m_iCurrentPage - 1;
        else if (cPages > (UINT)m_iCurrentPage)
            iNewPage = 0;
        else // cPages > 0 && cPages <= m_iCurrentPage
            iNewPage = m_iCurrentPage - cPages;

        hr = _ActivatePage(iNewPage);
    }

    _SetNavBarState();

    return hr;
}

STDMETHODIMP CTaskFrame::Forward()
{
    HRESULT hr;

    if (-1 == m_iCurrentPage || 0 == m_dpaHistory.Count())
        return E_UNEXPECTED;

    hr = S_FALSE;

    int iNewPage = m_iCurrentPage + 1;
    if (iNewPage < m_dpaHistory.Count())
    {
        hr = _ActivatePage(iNewPage);
    }

    _SetNavBarState();

    return hr;
}

STDMETHODIMP CTaskFrame::Home()
{
    if (-1 == m_iCurrentPage || 0 == m_dpaHistory.Count())
        return E_UNEXPECTED;

    HRESULT hr = _ActivatePage(0);

    _SetNavBarState();

    return hr;
}

STDMETHODIMP CTaskFrame::SetStatusText(LPCWSTR pszText)
{
    if (NULL == m_hwndStatusBar)
        return E_UNEXPECTED;

    ::SendMessageW(m_hwndStatusBar, SB_SETTEXT, SB_SIMPLEID, (LPARAM)pszText);
    return S_OK;
}

HRESULT CTaskFrame::_ReadProp(LPCWSTR pszProp, VARTYPE vt, CComVariant& var)
{
    HRESULT hr;

    ASSERT(NULL != m_pPropertyBag);

    var.Clear();
    hr = m_pPropertyBag->Read(pszProp, &var, NULL);
    if (SUCCEEDED(hr))
    {
        hr = var.ChangeType(vt);
    }

    return hr;
}

LRESULT CTaskFrame::_OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
{
    BOOL bNavBar;
    BOOL bStatusBar;
    CComVariant var;

    ASSERT(NULL != m_pPropertyBag);

    // See if we're supposed to show the NavBar. Default is TRUE.
    bNavBar = TRUE;
    if (SUCCEEDED(_ReadProp(TS_PROP_NAVBAR, VT_BOOL, var)))
    {
        bNavBar = (VARIANT_TRUE == var.boolVal);
    }
    if (bNavBar)
    {
        _CreateNavBar();
    }

    // See if we're supposed to show a status bar. Default is FALSE.
    bStatusBar = FALSE;
    if (SUCCEEDED(_ReadProp(TS_PROP_STATUSBAR, VT_BOOL, var)))
    {
        bStatusBar = (VARIANT_TRUE == var.boolVal);
    }
    if (bStatusBar)
    {
        DWORD dwStyle = WS_CHILD | WS_VISIBLE | CCS_BOTTOM;
        if (m_bResizable)
            dwStyle |= SBARS_SIZEGRIP;
        m_hwndStatusBar = CreateStatusWindowW(dwStyle, NULL, m_hWnd, IDC_STATUSBAR);
    }

    // Force m_rcPage to be calculated
    LPCREATESTRUCT pcs = (LPCREATESTRUCT)lParam;
    _OnSize(WM_SIZE, SIZE_RESTORED, MAKELONG(LOWORD(pcs->cx),LOWORD(pcs->cy)), bHandled);

    return 0;
}

LRESULT CTaskFrame::_OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    if (SIZE_RESTORED == wParam || SIZE_MAXIMIZED == wParam)
    {
        GetClientRect(&m_rcPage);

        if (m_hwndNavBar)
        {
            RECT rc;
            ::SendMessageW(m_hwndNavBar, uMsg, wParam, lParam);
            ::GetWindowRect(m_hwndNavBar, &rc);
            m_rcPage.top += (rc.bottom - rc.top);
        }

        if (m_hwndStatusBar)
        {
            RECT rc;
            ::SendMessageW(m_hwndStatusBar, uMsg, wParam, lParam);
            ::GetWindowRect(m_hwndStatusBar, &rc);
            m_rcPage.bottom -= (rc.bottom - rc.top);
        }

        // At this point, m_rcPage represents the remaining usable client
        // area between the toolbar and statusbar.

        if (-1 != m_iCurrentPage)
        {
            // Resize the current page. Other pages will be resized
            // as necessary when we show them.
            _SyncPageRect(m_dpaHistory[m_iCurrentPage]);
        }
    }

    return 0;
}

LRESULT CTaskFrame::_OnTBGetInfoTip(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
{
    LPNMTBGETINFOTIP pgit = (LPNMTBGETINFOTIP)pnmh;
    ::LoadStringW(_Module.GetResourceInstance(), pgit->iItem, pgit->pszText, pgit->cchTextMax);
    return 0;
}

LRESULT CTaskFrame::_OnTBCustomDraw(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
{
    LPNMCUSTOMDRAW pcd = (LPNMCUSTOMDRAW)pnmh;
    switch (pcd->dwDrawStage)
    {
    case CDDS_PREPAINT:
        return CDRF_NOTIFYITEMERASE;

    case CDDS_PREERASE:
        FillRect(pcd->hdc, &pcd->rc, GetSysColorBrush(COLOR_3DFACE));
        break;
    }
    return CDRF_DODEFAULT;
}

LRESULT CTaskFrame::_OnAppCommand(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
{
    switch (GET_APPCOMMAND_LPARAM(lParam))
    {
    case APPCOMMAND_BROWSER_BACKWARD:
        Back(1);
        break;

    case APPCOMMAND_BROWSER_FORWARD:
        Forward();
        break;

    case APPCOMMAND_BROWSER_HOME:
        Home();
        break;

    default:
        bHandled = FALSE;
        break;
    }
    return 0;
}

LRESULT CTaskFrame::_OnGetMinMaxInfo(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
{
    ((LPMINMAXINFO)lParam)->ptMinTrackSize = m_ptMinSize;
    return 0;
}


#define NAVBAR_CX               16

void CTaskFrame::_CreateNavBar()
{
    HINSTANCE hInst = _Module.GetResourceInstance();
    const DWORD dwStyle = WS_CHILD | WS_VISIBLE | CCS_TOP | TBSTYLE_FLAT | TBSTYLE_LIST | TBSTYLE_CUSTOMERASE | TBSTYLE_TOOLTIPS;

    // Create the NavBar toolbar control
    m_hwndNavBar = CreateWindowExW(TBSTYLE_EX_MIXEDBUTTONS /*| TBSTYLE_EX_DOUBLEBUFFER*/,
                                   TOOLBARCLASSNAME,
                                   NULL,
                                   dwStyle,
                                   0, 0, 0, 0,
                                   m_hWnd,
                                   (HMENU)IDC_NAVBAR,
                                   hInst,
                                   NULL);
    if (m_hwndNavBar)
    {
        ::SendMessageW(m_hwndNavBar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);

        int idBmp = IDB_NAVBAR;

        if (SHGetCurColorRes() > 8)
            idBmp += (IDB_NAVBARHICOLOR - IDB_NAVBAR);

        m_himlNBDef = ImageList_LoadImageW(hInst,
                                           MAKEINTRESOURCE(idBmp),
                                           NAVBAR_CX,
                                           0,
                                           CLR_DEFAULT,
                                           IMAGE_BITMAP,
                                           LR_CREATEDIBSECTION);
        if (m_himlNBDef)
            ::SendMessageW(m_hwndNavBar, TB_SETIMAGELIST, 0, (LPARAM)m_himlNBDef);

        m_himlNBHot = ImageList_LoadImageW(hInst,
                                           MAKEINTRESOURCE(idBmp+1),
                                           NAVBAR_CX,
                                           0,
                                           CLR_DEFAULT,
                                           IMAGE_BITMAP,
                                           LR_CREATEDIBSECTION);
        if (m_himlNBHot)
            ::SendMessageW(m_hwndNavBar, TB_SETHOTIMAGELIST, 0, (LPARAM)m_himlNBHot);

        if (!m_himlNBDef && !m_himlNBHot)
        {
            // Must be serious low memory or other resource problems.
            // There's no point having a toolbar without any images.
            ::DestroyWindow(m_hwndNavBar);
            m_hwndNavBar = NULL;
        }
        else
        {
            TCHAR szBack[64];
            TBBUTTON rgButtons[] =
            {
                {0, ID_BACK,    TBSTATE_ENABLED, BTNS_BUTTON | BTNS_AUTOSIZE | BTNS_SHOWTEXT, {0}, 0, (INT_PTR)szBack},
                {1, ID_FORWARD, TBSTATE_ENABLED, BTNS_BUTTON | BTNS_AUTOSIZE, {0}, 0, 0},
                {2, ID_HOME,    TBSTATE_ENABLED, BTNS_BUTTON | BTNS_AUTOSIZE, {0}, 0, 0},
            };

            ::LoadStringW(hInst, ID_BACK, szBack, ARRAYSIZE(szBack));
            ::SendMessageW(m_hwndNavBar, TB_ADDBUTTONSW, ARRAYSIZE(rgButtons), (LPARAM)rgButtons);

            // This happens in _OnSize
            //::SendMessageW(m_hwndNavBar, TB_AUTOSIZE, 0, 0);
        }

        _SetNavBarState();
    }
}

void CTaskFrame::_SetNavBarState()
{
    if (m_hwndNavBar)
    {
        ::SendMessage(m_hwndNavBar, TB_ENABLEBUTTON, ID_BACK, MAKELONG((m_iCurrentPage > 0), 0));
        ::SendMessage(m_hwndNavBar, TB_ENABLEBUTTON, ID_HOME, MAKELONG((m_iCurrentPage > 0), 0));
        ::SendMessage(m_hwndNavBar, TB_ENABLEBUTTON, ID_FORWARD, MAKELONG((m_iCurrentPage < m_dpaHistory.Count() - 1), 0));
    }
}

HRESULT CTaskFrame::_CreatePage(REFCLSID rclsidPage, TaskPage **ppPage)
{
    HRESULT hr;

    ASSERT(NULL != ppPage);
    *ppPage = NULL;

    if (NULL == m_pPageFactory || NULL == m_pUIParser)
        return E_UNEXPECTED;

    // Get this page's ITaskPage interface from the App
    CComPtr<ITaskPage> spTaskPage;
    hr = m_pPageFactory->CreatePage(rclsidPage, IID_ITaskPage, (void**)&spTaskPage.p);

    if (S_OK == hr)
    {
        // Give the ITaskPage our ITaskFrame interface
        CComQIPtr<ITaskFrame> spThis(this);
        if (spThis)
            spTaskPage->SetFrame(spThis);

        // Create an HWNDElement to contain and layout the page content
        TaskPage *pNewPage;
        hr = TaskPage::Create(rclsidPage, m_hWnd, &pNewPage);

        if (SUCCEEDED(hr))
        {
            Element* pe;    // dummy

            // Fill contents from markup using substitution
            hr = m_pUIParser->CreateElement(L"main", pNewPage, &pe);
            if (SUCCEEDED(hr))
            {
                Element::StartDefer();

                _SyncPageRect(pNewPage);

                // Some examples of ways to add graphics to the page

                Element* pe = pNewPage->FindDescendent(StrToID(L"Picture"));

                //pe->SetContentGraphic(L"C:\\windows\\ua_bkgnd.bmp", GRAPHIC_EntireAlpha, 64);
                //pe->SetContentGraphic(L"C:\\windows\\ua_bkgnd.bmp", GRAPHIC_TransColorAuto);

                //Value* pv = Value::CreateGraphic(MAKEINTRESOURCE(IDB_BACKGROUND), GRAPHIC_TransColorAuto, 0, 0, 0, _Module.GetResourceInstance());
                //pe->SetValue(Element::ContentProp, PI_Local, pv);
                //pv->Release();

#ifdef GADGET_ENABLE_GDIPLUS
                if (NULL != m_pbmWatermark)
                {
                    Value* pv = Value::CreateGraphic(m_pbmWatermark);
                    pe->SetValue(Element::ContentProp, PI_Local, pv);
                    pv->Release();
                }
#endif

                hr = pNewPage->CreateContent(spTaskPage);

                Element::EndDefer();
            }

            if (SUCCEEDED(hr))
            {
                *ppPage = pNewPage;
            }
            else
            {
                _DestroyPage(pNewPage);
            }
        }
    }

    return hr;
}

HRESULT CTaskFrame::_ActivatePage(int iPage, BOOL bInit)
{
    HRESULT hr = S_OK;

    ASSERT(m_dpaHistory.IsValid());
    ASSERT(0 < m_dpaHistory.Count());
    ASSERT(iPage >= 0 && iPage < m_dpaHistory.Count());

    TaskPage *pPage = m_dpaHistory[iPage];

    ASSERT(NULL != pPage);

    if (bInit)
    {
        hr = pPage->Reinitialize();
        if (FAILED(hr))
        {
            // Can't reinitialize? Create a new instance instead.
            TaskPage *pNewPage = NULL;
            hr = _CreatePage(pPage->GetID(), &pNewPage);
            if (SUCCEEDED(hr))
            {
                m_dpaHistory.Set(iPage, pNewPage);
                _DestroyPage(pPage);
                pPage = pNewPage;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (m_iCurrentPage != iPage)
        {
            _DeactivateCurrentPage();
        }

        // In case we were resized since we last showed this page
        _SyncPageRect(pPage);

        m_iCurrentPage = iPage;
        ::ShowWindow(pPage->GetHWND(), SW_SHOW);
        ::SetFocus(pPage->GetHWND());
    }

    return hr;
}

HRESULT CTaskFrame::_DeactivateCurrentPage()
{
    if (-1 != m_iCurrentPage)
    {
        ASSERT(m_dpaHistory.IsValid());
        ASSERT(m_iCurrentPage >= 0 && m_iCurrentPage < m_dpaHistory.Count());

        TaskPage *pPage = m_dpaHistory[m_iCurrentPage];

        ASSERT(NULL != pPage);

        m_iCurrentPage = -1;
        ::ShowWindow(pPage->GetHWND(), SW_HIDE);
    }

    return S_OK;
}

void CTaskFrame::_SyncPageRect(TaskPage* pPage)
{
    if (NULL != pPage)
    {
        Element::StartDefer();

        pPage->SetX(m_rcPage.left);
        pPage->SetY(m_rcPage.top);
        pPage->SetWidth(m_rcPage.right-m_rcPage.left);
        pPage->SetHeight(m_rcPage.bottom-m_rcPage.top);

        Element::EndDefer();
    }
}

void CTaskFrame::_DestroyPage(TaskPage* pPage)
{
    if (NULL != pPage)
    {
        HWND hwndPage = pPage->GetHWND();

        if (NULL != hwndPage && ::IsWindow(hwndPage))
        {
            // This causes pPage to be deleted
            ::DestroyWindow(hwndPage);
        }
        else
        {
            // If the window exists, this would not destroy it, so only
            // do this when there is no window.
            delete pPage;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\tasksheet.cpp ===
// TaskSheet.cpp : Implementation of CTaskSheet
#include "stdafx.h"
#include "TaskUI.h"
#include "TaskSheet.h"
#include "propbag.h"

/////////////////////////////////////////////////////////////////////////////
// CTaskSheet

CTaskSheet::CTaskSheet(void) 
    : m_pTaskFrame(NULL),
      m_pPropertyBag(NULL)
{ 
}

CTaskSheet::~CTaskSheet(void)
{
    ATOMICRELEASE(m_pTaskFrame);
    ATOMICRELEASE(m_pPropertyBag);
}


//
// Retrieve an interface to the sheet's property bag.
// If the bag doesn't yet exist, one is created.
// NOTE, this is not currently thread-safe.
//
STDMETHODIMP CTaskSheet::GetPropertyBag(REFIID riid, void **ppv)
{
    if (ppv == NULL)
        return E_POINTER;

    if (NULL == m_pPropertyBag)
    {
        HRESULT hr = TaskUiPropertyBag_CreateInstance(IID_IPropertyBag, (void **)&m_pPropertyBag);
        if (FAILED(hr))
            return hr;
    }
    return m_pPropertyBag->QueryInterface(riid, ppv);
}



STDMETHODIMP CTaskSheet::Run(ITaskPageFactory *pPageFactory, REFCLSID rclsidStartPage, HWND hwndOwner)
{
    HRESULT     hr;
    BOOL        bModeless;
    HWND        hwndTopOwner;
    HWND        hwndOriginalFocus;
    HWND        hwndFrame;

    if (NULL == pPageFactory)
        return E_POINTER;

    if (CLSID_NULL == rclsidStartPage)
        return E_INVALIDARG;

    if (NULL != m_pTaskFrame)
        return E_UNEXPECTED;

    bModeless = FALSE;      // default is modal
    hwndTopOwner = NULL;
    hwndOriginalFocus = NULL;

    CComPtr<IPropertyBag> pPropertyBag;
    hr = GetPropertyBag(IID_IPropertyBag, (void **)&pPropertyBag);
    if (FAILED(hr))
        return hr;

    hr = CTaskFrame::CreateInstance(pPropertyBag, pPageFactory, &m_pTaskFrame);
    if (FAILED(hr))
        return hr;

    // Figure out whether we're modal or modeless
    CComVariant var;
    if (SUCCEEDED(pPropertyBag->Read(TS_PROP_MODELESS, &var, NULL)) &&
        SUCCEEDED(var.ChangeType(VT_BOOL)))
    {
        bModeless = (VARIANT_TRUE == var.boolVal);
    }

    if (!bModeless)
    {
        // Modal case: disable the toplevel parent of the owner window

        hwndTopOwner = hwndOwner;
        hwndOriginalFocus = GetFocus();

        if (hwndTopOwner)
        {
            while (GetWindowLongW(hwndTopOwner, GWL_STYLE) & WS_CHILD)
                hwndTopOwner = GetParent(hwndTopOwner);

            if (hwndOriginalFocus != hwndTopOwner && !IsChild(hwndTopOwner, hwndOriginalFocus))
                hwndOriginalFocus = NULL;

            //
            // If the window was the desktop window, then don't disable
            // it now and don't reenable it later.
            // Also, if the window was already disabled, then don't
            // enable it later.
            //
            if (hwndTopOwner == GetDesktopWindow() ||
                EnableWindow(hwndTopOwner, FALSE))
            {
                hwndTopOwner = NULL;
            }
        }
    }

    // Create the frame window
    hwndFrame = m_pTaskFrame->CreateFrameWindow(hwndOwner);
    if (hwndFrame)
    {
        hr = m_pTaskFrame->ShowPage(rclsidStartPage, FALSE);
        if (SUCCEEDED(hr))
        {
            ShowWindow(hwndFrame, SW_SHOW);
            UpdateWindow(hwndFrame);

            if (!bModeless)
            {
                // Modal case: pump messages

                MSG msg;

                while (IsWindow(hwndFrame) && GetMessageW(&msg, NULL, 0, 0) > 0)
                {
                    //if (!IsDialogMessageW(hwndFrame, &msg))
                    {
                        TranslateMessage(&msg);
                        DispatchMessageW(&msg);
                    }
                }

                // Enable the owner prior to setting focus back to wherever
                // it was, since it may have been the owner that had focus.
                if (hwndTopOwner)
                {
                    EnableWindow(hwndTopOwner, TRUE);
                    hwndTopOwner = NULL;
                }

                if (hwndOriginalFocus && IsWindow(hwndOriginalFocus))
                    SetFocus(hwndOriginalFocus);

                ATOMICRELEASE(m_pTaskFrame);
            }
        }
    }
    else
    {
        DWORD dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
    }

    // In case an error prevented us from re-enabling the owner above
    if (hwndTopOwner)
        EnableWindow(hwndTopOwner, TRUE);

    return hr;
}

STDMETHODIMP CTaskSheet::Close()
{
    HRESULT hr;

    if (NULL == m_pTaskFrame)
        return E_UNEXPECTED;

    hr = m_pTaskFrame->Close();
    ATOMICRELEASE(m_pTaskFrame);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\tasksheet.h ===
// TaskSheet.h : Declaration of the CTaskSheet

#ifndef __TASKSHEET_H_INCLUDED_
#define __TASKSHEET_H_INCLUDED_

#include "resource.h"       // main symbols
#include <shlwapip.h>       // SHCreatePropertyBagOnMemory
#include "TaskFrame.h"

/////////////////////////////////////////////////////////////////////////////
// CTaskSheet
class ATL_NO_VTABLE CTaskSheet : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CTaskSheet, &CLSID_TaskSheet>,
    public ITaskSheet
{
public:
    CTaskSheet(void); 
    ~CTaskSheet(void);

DECLARE_REGISTRY_RESOURCEID(IDR_TASKSHEET)
DECLARE_NOT_AGGREGATABLE(CTaskSheet)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTaskSheet)
COM_INTERFACE_ENTRY(ITaskSheet)
END_COM_MAP()

protected:
    HRESULT CreatePropertyBag();

public:
// ITaskSheet
    STDMETHOD(GetPropertyBag)(REFIID riid, void **ppv);
    STDMETHOD(Run)(ITaskPageFactory *pPageFactory, REFCLSID rclsidStartPage, HWND hwndOwner);
    STDMETHOD(Close)();

private:
    CComObject<CTaskFrame> *m_pTaskFrame;
    IPropertyBag           *m_pPropertyBag;
};

#endif //__TASKSHEET_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\taskui.cpp ===
// TaskUI.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for TaskUI.idl by adding the following 
//      files to the Outputs.
//          TaskUI_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f TaskUIps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "TaskUI.h"
#include "dlldatax.h"

#include "TaskUI_i.c"
#include "TaskSheet.h"
#include "TaskFrame.h"
#include "HTMLControl.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

HACCEL g_hAccel = NULL;

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TaskSheet, CTaskSheet)
OBJECT_ENTRY(CLSID_TaskUI_HTMLControl, CTaskUI_HTMLControl)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_TASKUILib);
        DisableThreadLibraryCalls(hInstance);
        g_hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACCEL));
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\nusrmgr\htmlimpl.h ===
// HTMLImpl.h : Declaration of the CHTMLPageImpl

#ifndef __HTMLIMPL_H_
#define __HTMLIMPL_H_

#include "Nusrmgr.h"

/////////////////////////////////////////////////////////////////////////////
// CHTMLPageImpl
template <typename T, typename I>
class CHTMLPageImpl :
    public ITaskPage,
    public IDispatchImpl<I, &__uuidof(I), &LIBID_NUSRMGRLib>
{
public:
    CHTMLPageImpl() : _pTaskFrame(NULL), _pBag(NULL) {}
    ~CHTMLPageImpl() { ATOMICRELEASE(_pTaskFrame); ATOMICRELEASE(_pBag); }

// ITaskPage
public:
    STDMETHOD(SetFrame)(ITaskFrame* pFrame)
    {
        ATOMICRELEASE(_pTaskFrame);
        ATOMICRELEASE(_pBag);

        _pTaskFrame = pFrame;
        if (_pTaskFrame)
        {
            _pTaskFrame->AddRef();
            _pTaskFrame->GetPropertyBag(IID_IPropertyBag, (void**)&_pBag);
        }
        return S_OK;
    }

    STDMETHOD(GetObjectCount)(UINT nArea, UINT *pVal)
    {
        if (!pVal)
            return E_POINTER;
        *pVal = nArea < ARRAYSIZE(T::c_aHTML) ? 1 : 0;
        return S_OK;
    }

    STDMETHOD(CreateObject)(UINT nArea, UINT nIndex, REFIID riid, void **ppv)
    {
        if (nArea >= ARRAYSIZE(T::c_aHTML))
            return E_UNEXPECTED;
        CComPtr<ITaskUI_HTMLControl> spContent;
        HRESULT hr = spContent.CoCreateInstance(__uuidof(TaskUI_HTMLControl));
        if (SUCCEEDED(hr))
        {
            hr = spContent->Initialize((BSTR)T::c_aHTML[nArea], static_cast<I*>(this));
            if (SUCCEEDED(hr))
            {
                hr = spContent->QueryInterface(riid, ppv);
            }
        }
        return hr;
    }

    STDMETHOD(Reinitialize)(/*[in]*/ ULONG /*reserved*/)
    {
        return E_NOTIMPL;
    }


// IExternalUI
public:
    STDMETHOD(get_cssPath)(/*[out, retval]*/ BSTR *pVal)
    {
        if (NULL == pVal)
            return E_POINTER;
        *pVal = NULL;
        if (NULL == _pBag)
            return E_UNEXPECTED;
        CComVariant var;
        if (SUCCEEDED(_pBag->Read(UA_PROP_CSSPATH, &var, NULL)))
        {
            *pVal = var.bstrVal;
            var.vt = VT_EMPTY;
        }
        return S_OK;
    }

    STDMETHOD(navigate)(/*[in]*/ VARIANT varClsid, /*[in]*/ VARIANT_BOOL bTrimHistory, /*[in]*/ VARIANT var2)
    {
        if (NULL == _pTaskFrame || NULL == _pBag)
            return E_UNEXPECTED;
        _pBag->Write(UA_PROP_PAGEINITDATA, &var2);
        if (varClsid.vt == VT_BSTR)
        {
            CLSID clsid;
            if (SUCCEEDED(CLSIDFromString(varClsid.bstrVal, &clsid)))
                return _pTaskFrame->ShowPage(clsid, !(VARIANT_FALSE == bTrimHistory));
            else
                MessageBoxW(NULL, varClsid.bstrVal, (var2.vt == VT_BSTR ? var2.bstrVal : L"navigate"), MB_OK);
        }
        return S_OK;
    }

    STDMETHOD(goBack)(/*[in, optional, defaultvalue=1]*/ VARIANT varCount)
    {
        if (NULL == _pTaskFrame)
            return E_UNEXPECTED;
        int cBack = 1;
        if (SUCCEEDED(VariantChangeType(&varCount, &varCount, 0, VT_I4)))
            cBack = varCount.lVal;
        if (-1 == cBack)
            _pTaskFrame->Home();
        else
            _pTaskFrame->Back(cBack);
        return S_OK;
    }

    STDMETHOD(goForward)()
    {
        if (NULL == _pTaskFrame)
            return E_UNEXPECTED;
        _pTaskFrame->Forward();
        return S_OK;
    }

    STDMETHOD(showHelp)(/*[in]*/ VARIANT var)
    {
        if (var.vt == VT_BSTR)
            MessageBoxW(NULL, var.bstrVal, L"showHelp", MB_OK);
        return S_OK;
    }

protected:
    ITaskFrame* _pTaskFrame;
    IPropertyBag* _pBag;
};

#endif //__HTMLIMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\nusrmgr\logonpage.h ===
// LogonPage.h : Declaration of the CLogonPage

#ifndef __LOGONPAGE_H_
#define __LOGONPAGE_H_

#include "Nusrmgr.h"
#include "HTMLImpl.h"
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CLogonPage
class ATL_NO_VTABLE DECLSPEC_UUID("C282FA70-BE5B-4D20-A819-14424E4A3950") CLogonPage : 
    public CComObjectRoot,
    public CHTMLPageImpl<CLogonPage,ILogonPageUI>
{
public:
    CLogonPage() : _pLogonTypeCheckbox(NULL), _pTSModeCheckbox(NULL),
        _bFriendlyUIEnabled(VARIANT_FALSE), _bMultipleUsersEnabled(VARIANT_FALSE) {}
    ~CLogonPage() { ATOMICRELEASE(_pLogonTypeCheckbox); ATOMICRELEASE(_pTSModeCheckbox); }

DECLARE_NOT_AGGREGATABLE(CLogonPage)

//DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CLogonPage)
    COM_INTERFACE_ENTRY(ITaskPage)
    COM_INTERFACE_ENTRY(ILogonPageUI)
    COM_INTERFACE_ENTRY2(IDispatch, ILogonPageUI)
END_COM_MAP()

// ITaskPage overrides
public:
    STDMETHOD(Reinitialize)(/*[in]*/ ULONG reserved);

// ILogonPageUI
public:
    STDMETHOD(initPage)(/*[in]*/ IDispatch* pdispLogonTypeCheckbox, /*[in]*/ IDispatch* pdispTSModeCheckbox);
    STDMETHOD(onOK)();

private:
    IHTMLInputElement* _pLogonTypeCheckbox;
    IHTMLInputElement* _pTSModeCheckbox;
    VARIANT_BOOL _bFriendlyUIEnabled;
    VARIANT_BOOL _bMultipleUsersEnabled;

public:
    static LPWSTR c_aHTML[2];
};

EXTERN_C const CLSID CLSID_LogonPage;

#endif //__LOGONPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\nusrmgr\mainpage.cpp ===
// MainPage.cpp : Implementation of CMainPage
#include "stdafx.h"
#include "MainPage.h"

EXTERN_C const CLSID CLSID_MainPage = __uuidof(CMainPage);

/////////////////////////////////////////////////////////////////////////////
// CMainPage

LPWSTR CMainPage::c_aHTML[] =
{
    L"res://nusrmgr.exe/mainpage.htm",
    L"res://nusrmgr.exe/mainpage_sec.htm"
};

STDMETHODIMP CMainPage::createUserTable(IDispatch *pdispUserTableParent)
{
    HRESULT hr;

    if (NULL == pdispUserTableParent)
        return E_INVALIDARG;

    if (NULL == _pBag)
        return E_UNEXPECTED;

    CComVariant var;
    hr = _pBag->Read(UA_PROP_USERLIST, &var, NULL);
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;

        CComQIPtr<ILogonEnumUsers> spUserList(var.punkVal);

        CComQIPtr<IHTMLElement> spParent(pdispUserTableParent);
        if (spParent)
        {
            CComBSTR strHTML;
            hr = CreateUserTableHTML(spUserList, 2, &strHTML);
            if (SUCCEEDED(hr))
                hr = spParent->put_innerHTML(strHTML);
        }
    }
    return hr;
}


LPWSTR FormatString(LPCWSTR pszFormat, ...)
{
    LPWSTR pszResult = NULL;
    DWORD dwResult;
    va_list args;

    if (NULL == pszFormat)
        return NULL;

    va_start(args, pszFormat);
    dwResult = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                              pszFormat,
                              0,
                              0,
                              (LPWSTR)&pszResult,
                              1,
                              &args);
    va_end(args);

    if (0 == dwResult && NULL != pszResult)
    {
        LocalFree(pszResult);
        pszResult = NULL;
    }

    return pszResult;
}

//
// Localized strings (move to resources)
//
const WCHAR L_Admin_Property[]          = L"Owner account";
const WCHAR L_Standard_Property[]       = L"Standard account";
const WCHAR L_Limited_Property[]        = L"Limited account";
const WCHAR L_Password_Property[]       = L"<BR>Password-protected";
const WCHAR L_GuestEnabled_Property[]   = L"Guest access allowed";
const WCHAR L_GuestDisabled_Property[]  = L"Guest access not allowed";

const WCHAR L_Account_ToolTip[]         = L"Changes this person&#039s account information, such as the account type, name, or picture, or lets you delete this account.";
const WCHAR L_Guest_ToolTip[]           = L"Lets you change the guest account picture or prevent guest access to this computer.";
const WCHAR L_GuestEnable_ToolTip[]     = L"Provides computer access for people without a user account on this machine.";


//
// Non-localized strings
//
const WCHAR c_szAdminGroup[]            = L"Owners";
const WCHAR c_szStandardGroup[]         = L"Adults";
const WCHAR c_szLimitedGroup[]          = L"Children";
const WCHAR c_szGuestGroup[]            = L"Guests";
const WCHAR c_szDefaultImage[]          = L"accountgrey.bmp";


struct { LPCWSTR szGroupName; LPCWSTR szAccountType; }
g_AccountTypes[] =
{
    { c_szAdminGroup,       L_Admin_Property        },
    { c_szStandardGroup,    L_Standard_Property     },
    { c_szLimitedGroup,     L_Limited_Property      },
    { c_szGuestGroup,       L_GuestEnabled_Property },
};

BOOL IsAccountType(ILogonUser* pUser, UINT iType)
{
    if (iType < ARRAYSIZE(g_AccountTypes))
    {
        CComVariant varType;
        if (SUCCEEDED(pUser->get_setting(L"AccountType", &varType)) && VT_BSTR == varType.vt)
        {
            return (0 == lstrcmpiW(varType.bstrVal, g_AccountTypes[iType].szGroupName));
        }
    }
    return FALSE;
}

UINT GetAccountType(ILogonUser* pUser)
{
    UINT i;
    for (i = 0; i < ARRAYSIZE(g_AccountTypes); i++)
    {
        if (IsAccountType(pUser, i))
            return i;
    }
    return 2; //LIMITED;
}

BOOL IsSameAccount(ILogonUser* pUser, LPCWSTR pszLoginName)
{
    CComVariant varName;
    if (SUCCEEDED(pUser->get_setting(L"LoginName", &varName)) && VT_BSTR == varName.vt)
    {
        return (0 == lstrcmpiW(varName.bstrVal, pszLoginName));
    }
    return FALSE;
}

BSTR GetUserDisplayName(ILogonUser* pUser)
{
    BSTR strResult = NULL;

    CComVariant var;
    HRESULT hr = pUser->get_setting(L"DisplayName", &var);
    if (FAILED(hr) || VT_BSTR != var.vt || NULL == var.bstrVal || L'\0' == *var.bstrVal)
    {
        var.Clear();
        hr = pUser->get_setting(L"LoginName", &var);
    }

    if (SUCCEEDED(hr) && VT_BSTR == var.vt && NULL != var.bstrVal)
    {
        strResult = var.bstrVal;
        var.vt = VT_EMPTY;

        // Truncate really long names
        if (lstrlenW(strResult) > 20)
        {
            //var iBreak = szDisplayName.lastIndexOf(' ',17);
            //if (-1 == iBreak) iBreak = 17;
            //szDisplayName = szDisplayName.substring(0,iBreak) + "...";
            lstrcpyW(&strResult[17], L"...");
        }
    }

    return strResult;
}

LPWSTR CreateUserDisplayHTML(LPCWSTR pszName, LPCWSTR pszSubtitle, LPCWSTR pszPicture)
{
    static const WCHAR c_szUserHTML[] =
        L"<TABLE cellspacing=0 cellpadding=0 style='border:0'><TR>" \
          L"<TD style='padding:1mm;margin-right:2mm'>" \
            L"<IMG src='%3' class='UserPict' onerror='OnPictureLoadError(this);'/>" \
          L"</TD>" \
          L"<TD style='vertical-align:middle'>" \
            L"<DIV class='FontSubHeader1 ColorPrimaryLink1'>%1</DIV>" \
            L"<DIV class='FontDescription1 ColorPrimaryLink1'>%2</DIV>" \
          L"</TD>" \
        L"</TR></TABLE>";

    return FormatString(c_szUserHTML, pszName, pszSubtitle, pszPicture);
}

LPWSTR CreateUserDisplayHTML(ILogonUser* pUser)
{
    if (NULL == pUser)
        return NULL;

    CComBSTR strSubtitle(g_AccountTypes[GetAccountType(pUser)].szAccountType);

    VARIANT_BOOL bPassword = VARIANT_FALSE;
    if (SUCCEEDED(pUser->get_passwordRequired(&bPassword)) && (VARIANT_TRUE == bPassword))
    {
        strSubtitle.Append(L_Password_Property);
    }

    CComVariant varPicture;
    if (FAILED(pUser->get_setting(L"Picture", &varPicture)))
        varPicture = c_szDefaultImage;

    CComBSTR strName;
    strName.Attach(GetUserDisplayName(pUser));

    return CreateUserDisplayHTML(strName, strSubtitle, varPicture.bstrVal);
}

LPWSTR CreateDisabledGuestHTML()
{
    return CreateUserDisplayHTML(g_szGuestName, L_GuestDisabled_Property, c_szDefaultImage);
}

HRESULT CreateUserTableHTML(ILogonEnumUsers* pUserList, UINT cColumns, BSTR* pstrHTML)
{
    HRESULT hr;

    static const WCHAR c_szTableStart[] = L"<TABLE cellspacing=10 cellpadding=1 style='border:0;table-layout:fixed'>";
    static const WCHAR c_szTableEnd[] = L"</TABLE>";
    static const WCHAR c_szTRStart[] = L"<TR>";
    static const WCHAR c_szTREnd[] = L"</TR>";
    static const WCHAR c_szTDStart[] = L"<TD class='Selectable' tabindex=0 LoginName='%1' title='%2' onclick='%3' style='width:%4!d!%%'>";
    static const WCHAR c_szTDEnd[] = L"</TD>";
    static const WCHAR c_szSwitchUser[] = L"window.external.navigate(\"{F4924514-CFBC-4AAB-9EC5-6C6E6D0DB38D}\",false,this.LoginName);";
    static const WCHAR c_szEnableGuest[] = L"window.external.navigate(\"enableguest.htm\",false);";

    if (NULL == pUserList)
        return E_INVALIDARG;

    if (NULL == pstrHTML)
        return E_POINTER;

    *pstrHTML = NULL;

    if (0 == cColumns)
        cColumns = 1;

    LONG nColWidth = 100 / cColumns; // percent (e.g. for 2 columns, width=50%)

    UINT cUsers = 0;
    hr = pUserList->get_length(&cUsers);
    if (SUCCEEDED(hr) && 0 == cUsers)
        hr = E_FAIL;
    if (FAILED(hr))
        return hr;

    CComPtr<IStream> spStream;
    hr = CreateStreamOnHGlobal(NULL, TRUE, &spStream);
    if (FAILED(hr))
        return hr;

    // Continue if this fails
    CComPtr<ILogonUser> spLoggedOnUser;
    pUserList->get_currentUser(&spLoggedOnUser);

    BOOL fIncludeSelf = (NULL != spLoggedOnUser.p);
    BOOL bShowAdmin = (!fIncludeSelf || IsSameAccount(spLoggedOnUser, g_szAdminName));
    if (!bShowAdmin)
    {
        // TODO: Check registry
    }

    UINT i;
    UINT j = 0;

    VARIANT varI;
    varI.vt = VT_I4;

    ULONG cbWritten;
    spStream->Write(c_szTableStart, sizeof(c_szTableStart)-sizeof(L'\0'), &cbWritten);

    for (i = 0; i < cUsers;)
    {
        spStream->Write(c_szTRStart, sizeof(c_szTRStart)-sizeof(L'\0'), &cbWritten);

        for (j = 0; j < cColumns && i < cUsers; i++)
        {
            CComPtr<ILogonUser> spUser;
            varI.ulVal = i;
            hr = pUserList->item(varI, &spUser);
            if (FAILED(hr))
                continue;

            CComVariant varLoginName;
            if (FAILED(spUser->get_setting(L"LoginName", &varLoginName)) || VT_BSTR != varLoginName.vt)
                continue;

            // Add "Guest" later
            if (0 == lstrcmpiW(varLoginName.bstrVal, g_szGuestName))
                continue;

            // Normally don't want to show "Administrator"
            if (!bShowAdmin && (0 == lstrcmpiW(varLoginName.bstrVal, g_szAdminName)))
                continue;

            BOOL bIsLoggedOnUser = spLoggedOnUser ? IsSameAccount(spLoggedOnUser, varLoginName.bstrVal) : FALSE;

            //
            // fIncludeSelf causes spLoggedOnUser to be
            // placed first in the list
            //
            if (fIncludeSelf || !bIsLoggedOnUser)
            {
                if (fIncludeSelf)
                {
                    if (!bIsLoggedOnUser)
                    {
                        CComVariant varTemp;
                        if (SUCCEEDED(spLoggedOnUser->get_setting(L"LoginName", &varTemp)) && VT_BSTR == varTemp.vt)
                        {
                            varLoginName = varTemp;
                            spUser = spLoggedOnUser;
                            i--;
                        }
                    }
                    fIncludeSelf = FALSE;
                }

                LPWSTR pszTDStart = FormatString(c_szTDStart, varLoginName.bstrVal, L_Account_ToolTip, c_szSwitchUser, nColWidth);
                if (NULL != pszTDStart)
                {
                    spStream->Write(pszTDStart, sizeof(WCHAR)*lstrlenW(pszTDStart), &cbWritten);
                    LocalFree(pszTDStart);
                }
                else
                {
                    continue;
                }

                LPWSTR pszUserDisplay = CreateUserDisplayHTML(spUser);
                if (NULL != pszUserDisplay)
                {
                    spStream->Write(pszUserDisplay, sizeof(WCHAR)*lstrlenW(pszUserDisplay), &cbWritten);
                    LocalFree(pszUserDisplay);
                }

                spStream->Write(c_szTDEnd, sizeof(c_szTDEnd)-sizeof(L'\0'), &cbWritten);

                j++;
            }
        }

        // Last time through?
        if (i == cUsers)
        {
            // Add the "Guest" entry now

            VARIANT_BOOL bGuestEnabled = VARIANT_FALSE;
            CComPtr<ILocalMachine> spLocalMachine;
            hr = spLocalMachine.CoCreateInstance(CLSID_ShellLocalMachine);
            if (SUCCEEDED(hr))
                spLocalMachine->get_isGuestEnabled(&bGuestEnabled);

            if (j == cColumns)
            {
                spStream->Write(c_szTREnd, sizeof(c_szTREnd)-sizeof(L'\0'), &cbWritten);
                spStream->Write(c_szTRStart, sizeof(c_szTRStart)-sizeof(L'\0'), &cbWritten);
            }

            LPCWSTR pszTitle;
            LPCWSTR pszOnClick;
            LPWSTR pszUserDisplay;

            if (VARIANT_TRUE == bGuestEnabled)
            {
                // Enabled Guest is a real entry (from pUserList)

                CComPtr<ILogonUser> spUser;
                CComVariant var(g_szGuestName);
                hr = pUserList->item(var, &spUser);

                pszTitle = L_Guest_ToolTip;
                pszOnClick = c_szSwitchUser;
                pszUserDisplay = CreateUserDisplayHTML(spUser);
            }
            else
            {
                // Disabled Guest is a fake entry

                pszTitle = L_GuestEnable_ToolTip;
                pszOnClick = c_szEnableGuest;
                pszUserDisplay = CreateDisabledGuestHTML();
            }

            LPWSTR pszTDStart = FormatString(c_szTDStart, g_szGuestName, pszTitle, pszOnClick, nColWidth);
            if (NULL != pszTDStart)
            {
                spStream->Write(pszTDStart, sizeof(WCHAR)*lstrlenW(pszTDStart), &cbWritten);
                LocalFree(pszTDStart);

                if (NULL != pszUserDisplay)
                    spStream->Write(pszUserDisplay, sizeof(WCHAR)*lstrlenW(pszUserDisplay), &cbWritten);

                spStream->Write(c_szTDEnd, sizeof(c_szTDEnd)-sizeof(L'\0'), &cbWritten);
            }

            if (NULL != pszUserDisplay)
                LocalFree(pszUserDisplay);
        }

        spStream->Write(c_szTREnd, sizeof(c_szTREnd)-sizeof(L'\0'), &cbWritten);
    }

    // Include the NULL terminator on the last write
    spStream->Write(c_szTableEnd, sizeof(c_szTableEnd), &cbWritten);

    HGLOBAL hBuffer;
    hr = GetHGlobalFromStream(spStream, &hBuffer);
    if (SUCCEEDED(hr))
    {
        LPCWSTR pszHTML = (LPCWSTR)GlobalLock(hBuffer);
        *pstrHTML = SysAllocString(pszHTML);
        GlobalUnlock(hBuffer);
        if (NULL == *pstrHTML)
            hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\nusrmgr\pagefact.cpp ===
// PageFact.cpp: implementation of the CPageFactory class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "PageFact.h"
#include "MainPage.h"
#include "UserPage.h"
#include "LogonPage.h"

//////////////////////////////////////////////////////////////////////
// ITaskPageFactory
//////////////////////////////////////////////////////////////////////

BEGIN_PAGE_MAP(CPageFactory)
    PAGE_ENTRY(CMainPage)
    PAGE_ENTRY(CUserPage)
    PAGE_ENTRY(CLogonPage)
END_PAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\nusrmgr\logonpage.cpp ===
// LogonPage.cpp : Implementation of CLogonPage
#include "stdafx.h"
#include "MainPage.h"
#include "LogonPage.h"

EXTERN_C const CLSID CLSID_LogonPage = __uuidof(CLogonPage);

/////////////////////////////////////////////////////////////////////////////
// CLogonPage

LPWSTR CLogonPage::c_aHTML[] =
{
    L"res://nusrmgr.exe/logonpage.htm",
    L"res://nusrmgr.exe/logonpage_sec.htm"
};

STDMETHODIMP CLogonPage::Reinitialize(ULONG /*reserved*/)
{
    _bFriendlyUIEnabled = VARIANT_FALSE;
    _bMultipleUsersEnabled = VARIANT_FALSE;

    CComPtr<ILocalMachine> spLocalMachine;
    if (SUCCEEDED(spLocalMachine.CoCreateInstance(CLSID_ShellLocalMachine)))
    {
        spLocalMachine->get_isFriendlyUIEnabled(&_bFriendlyUIEnabled);
        spLocalMachine->get_isMultipleUsersEnabled(&_bMultipleUsersEnabled);
    }

    if (NULL != _pLogonTypeCheckbox)
        _pLogonTypeCheckbox->put_checked(_bFriendlyUIEnabled);

    if (NULL != _pTSModeCheckbox)
        _pTSModeCheckbox->put_checked(VARIANT_FALSE == _bMultipleUsersEnabled ? VARIANT_TRUE : VARIANT_FALSE);

    return S_OK;
}

STDMETHODIMP CLogonPage::initPage(IDispatch* pdispLogonTypeCheckbox, IDispatch* pdispTSModeCheckbox)
{
    ATOMICRELEASE(_pLogonTypeCheckbox);
    ATOMICRELEASE(_pTSModeCheckbox);

    if (NULL != pdispLogonTypeCheckbox)
        pdispLogonTypeCheckbox->QueryInterface(&_pLogonTypeCheckbox);

    if (NULL != pdispTSModeCheckbox)
        pdispTSModeCheckbox->QueryInterface(&_pTSModeCheckbox);

    return Reinitialize(0);
}

STDMETHODIMP CLogonPage::onOK()
{
    HRESULT hr = S_OK;

    VARIANT_BOOL bFriendlyUIEnabled = VARIANT_FALSE;
    VARIANT_BOOL bMultipleUsersDisabled = VARIANT_TRUE;

    if (NULL != _pLogonTypeCheckbox)
        _pLogonTypeCheckbox->get_checked(&bFriendlyUIEnabled);

    if (NULL != _pTSModeCheckbox)
        _pTSModeCheckbox->get_checked(&bMultipleUsersDisabled);

    CComPtr<ILocalMachine> spLocalMachine;

    if (bFriendlyUIEnabled != _bFriendlyUIEnabled)
    {
        hr = spLocalMachine.CoCreateInstance(CLSID_ShellLocalMachine);
        if (spLocalMachine)
        {
            hr = spLocalMachine->put_isFriendlyUIEnabled(bFriendlyUIEnabled);
            if (SUCCEEDED(hr))
            {
                _bFriendlyUIEnabled = bFriendlyUIEnabled;
            }
            else
            {
                //alert(L_FriendlyUI_ErrorMessage);
            }
        }
    }

    if (bMultipleUsersDisabled == _bMultipleUsersEnabled)
    {
        if (!spLocalMachine)
            hr = spLocalMachine.CoCreateInstance(CLSID_ShellLocalMachine);

        if (spLocalMachine)
        {
            hr = spLocalMachine->put_isMultipleUsersEnabled(VARIANT_FALSE == bMultipleUsersDisabled ? VARIANT_TRUE : VARIANT_FALSE);
            if (SUCCEEDED(hr))
            {
                _bMultipleUsersEnabled = VARIANT_FALSE == bMultipleUsersDisabled ? VARIANT_TRUE : VARIANT_FALSE;
            }
            else
            {
                // There are 2 possible errors here. Need to check with
                // VTan about what they are, then make 2 different messages.

                //alert(L_MultiUser_ErrorMessage);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (NULL != _pTaskFrame)
            hr = _pTaskFrame->ShowPage(CLSID_MainPage, TRUE);
        else
            hr = E_UNEXPECTED;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\nusrmgr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\nusrmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by nusrmgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_UA_TITLE                    101
#define IDS_ADMINNAME                   102
#define IDS_GUESTNAME                   103
#define IDB_WATERMARK                   201
#define IDR_MAINPAGE                    203

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        204
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\nusrmgr\mainpage.h ===
// MainPage.h : Declaration of the CMainPage

#ifndef __MAINPAGE_H_
#define __MAINPAGE_H_

#include "Nusrmgr.h"
#include "HTMLImpl.h"
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMainPage
class ATL_NO_VTABLE DECLSPEC_UUID("C9332CBE-E2D6-4722-B81D-283E2A400E84") CMainPage : 
    public CComObjectRoot,
    public CHTMLPageImpl<CMainPage,IMainPageUI>
{
public:

DECLARE_NOT_AGGREGATABLE(CMainPage)

//DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMainPage)
    COM_INTERFACE_ENTRY(ITaskPage)
    COM_INTERFACE_ENTRY(IMainPageUI)
    COM_INTERFACE_ENTRY2(IDispatch, IMainPageUI)
END_COM_MAP()

// IMainPageUI
public:
    STDMETHOD(createUserTable)(/*[in]*/ IDispatch* pdispParent);

public:
    static LPWSTR c_aHTML[2];
};

EXTERN_C const CLSID CLSID_MainPage;


LPWSTR FormatString(LPCWSTR pszFormat, ...);

BOOL    IsAccountType(ILogonUser* pUser, UINT iType);
UINT    GetAccountType(ILogonUser* pUser);
BOOL    IsSameAccount(ILogonUser* pUser, LPCWSTR pszLoginName);
BSTR    GetUserDisplayName(ILogonUser* pUser);
LPWSTR  CreateUserDisplayHTML(LPCWSTR pszName, LPCWSTR pszSubtitle, LPCWSTR pszPicture);
LPWSTR  CreateUserDisplayHTML(ILogonUser* pUser);
LPWSTR  CreateDisabledGuestHTML();
HRESULT CreateUserTableHTML(ILogonEnumUsers* pUserList, UINT cColumns, BSTR* pstrHTML);

__inline BOOL IsOwnerAccount(ILogonUser* pUser) { return IsAccountType(pUser, 0); }
__inline BOOL IsAdminAccount(ILogonUser* pUser) { return IsSameAccount(pUser, g_szAdminName); }
__inline BOOL IsGuestAccount(ILogonUser* pUser) { return IsSameAccount(pUser, g_szGuestName); }

#endif //__MAINPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\nusrmgr\nusrmgr.cpp ===
// nusrmgr.cpp : Implementation of WinMain

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "nusrmgr.h"
#include "nusrmgr_i.c"

#include <lmaccess.h>   // for NetUserModalsGet
#include <lmapibuf.h>   // for NetApiBufferFree
#include <lmerr.h>      // for NERR_Success

#include "PageFact.h"
#include "MainPage.h"
//#include "UserPage.h"
//#include "LogonPage.h"

WCHAR g_szAdminName[MAX_PATH];
WCHAR g_szGuestName[MAX_PATH];

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
//OBJECT_ENTRY(CLSID_MainPage, CMainPage)
//OBJECT_ENTRY(CLSID_UserPage, CUserPage)
//OBJECT_ENTRY(CLSID_LogonPage, CLogonPage)
END_OBJECT_MAP()


DWORD BuildAccountSidFromRid(LPCWSTR pszServer, DWORD dwRid, PSID* ppSid)
{
    DWORD dwErr = ERROR_SUCCESS;
    PUSER_MODALS_INFO_2 umi2;
    NET_API_STATUS nasRet;

    *ppSid = NULL;

    // Get the account domain Sid on the target machine
    nasRet = NetUserModalsGet(pszServer, 2, (LPBYTE*)&umi2);

    if ( nasRet == NERR_Success )
    {
        UCHAR cSubAuthorities;
        PSID pSid;

        cSubAuthorities = *GetSidSubAuthorityCount(umi2->usrmod2_domain_id);

        // Allocate storage for new the Sid (domain Sid + account Rid)
        pSid = (PSID)LocalAlloc(LPTR, GetSidLengthRequired((UCHAR)(cSubAuthorities+1)));

        if ( pSid != NULL )
        {
            if ( InitializeSid(pSid,
                               GetSidIdentifierAuthority(umi2->usrmod2_domain_id),
                               (BYTE)(cSubAuthorities+1)) )
            {
                // Copy existing subauthorities from domain Sid to new Sid
                for (UINT i = 0; i < cSubAuthorities; i++)
                {
                    *GetSidSubAuthority(pSid, i) = *GetSidSubAuthority(umi2->usrmod2_domain_id, i);
                }

                // Append Rid to new Sid
                *GetSidSubAuthority(pSid, cSubAuthorities) = dwRid;

                *ppSid = pSid;
            }
            else
            {
                dwErr = GetLastError();
                LocalFree(pSid);
            }
        }
        else
        {
            dwErr = GetLastError();
        }

        NetApiBufferFree(umi2);
    }
    else
    {
        dwErr = nasRet;
    }

    return dwErr;
}


BOOL GetAccountNameFromRid(LPCWSTR pszServer, DWORD dwRid, LPWSTR pszName, DWORD cchName)
{
    BOOL bResult = FALSE;
    PSID pSid;

    pszName[0] = L'\0';

    if (NOERROR == BuildAccountSidFromRid(pszServer, dwRid, &pSid))
    {
        WCHAR szDomain[DNLEN+1];
        DWORD cchDomain = ARRAYSIZE(szDomain);
        SID_NAME_USE snu;

        bResult =  LookupAccountSidW(pszServer, pSid, pszName, &cchName, szDomain, &cchDomain, &snu);

        LocalFree(pSid);
    }

    return bResult;
}


HRESULT ShowUserAccounts()
{
    HRESULT hr;

    CComPtr<ITaskSheet> spTaskSheet;
    hr = spTaskSheet.CoCreateInstance(__uuidof(TaskSheet));

    if (SUCCEEDED(hr))
    {
        CComPtr<IPropertyBag> spProps = NULL;

        hr = spTaskSheet->GetPropertyBag(IID_IPropertyBag, (void**)&spProps);

        if (SUCCEEDED(hr))
        {
            WCHAR szTitle[MAX_PATH];
            LoadStringW(_Module.GetResourceInstance(), IDS_UA_TITLE, szTitle, ARRAYSIZE(szTitle));

            CComVariant var(szTitle);
            spProps->Write(TS_PROP_TITLE, &var);

            var = 750;
            spProps->Write(TS_PROP_WIDTH, &var);

            var = 500;
            spProps->Write(TS_PROP_HEIGHT, &var);

            var = 600;
            spProps->Write(TS_PROP_MINWIDTH, &var);

            var = 400;
            spProps->Write(TS_PROP_MINHEIGHT, &var);

            LPWSTR pszTemp = FormatString(L"res://nusrmgr.exe/%d/%d", RT_BITMAP, IDB_WATERMARK);
            if (NULL != pszTemp)
            {
                var = pszTemp;
                spProps->Write(TS_PROP_WATERMARK, &var);
                LocalFree(pszTemp);
            }

            var = false;
            spProps->Write(TS_PROP_MODELESS, &var);
            spProps->Write(TS_PROP_STATUSBAR, &var);

            var = true;
            spProps->Write(TS_PROP_RESIZABLE, &var);

            //try
            //{
            //    var oThemeManager = new ActiveXObject("Theme.Manager");
            //    css = objThemeManger.WebviewCSS;
            //}
            //catch (e)
            //{
            //    css = "res://webvw.dll/cpwebvw.css";
            //}
            var = L"res://webvw.dll/cpwebvw.css";
            spProps->Write(UA_PROP_CSSPATH, &var);

            CComPtr<ILogonEnumUsers> spUserList;
            hr = spUserList.CoCreateInstance(CLSID_ShellLogonEnumUsers);
            if (SUCCEEDED(hr))
            {
                var = (IUnknown*)spUserList;
                spProps->Write(UA_PROP_USERLIST, &var);

                CComPtr<ITaskPageFactory> spPageFactory;
                hr = CPageFactory::CreateInstance(&spPageFactory);
                if (SUCCEEDED(hr))
                {
                    hr = spTaskSheet->Run(spPageFactory, CLSID_MainPage, NULL);
                }
            }
        }                                                       
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI WinMain(HINSTANCE hInstance,
                              HINSTANCE /*hPrevInstance*/,
                              LPSTR /*lpCmdLine*/,
                              int /*nShowCmd*/)
{
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
    HRESULT hrCom = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
    HRESULT hrCom = CoInitialize(NULL);
#endif

    _Module.Init(ObjectMap, hInstance);
    _Module.RegisterTypeLib();

    if (!GetAccountNameFromRid(NULL, DOMAIN_USER_RID_ADMIN, g_szAdminName, ARRAYSIZE(g_szAdminName)))
        LoadStringW(hInstance, IDS_ADMINNAME, g_szAdminName, ARRAYSIZE(g_szAdminName));

    if (!GetAccountNameFromRid(NULL, DOMAIN_USER_RID_GUEST, g_szGuestName, ARRAYSIZE(g_szGuestName)))
        LoadStringW(hInstance, IDS_GUESTNAME, g_szGuestName, ARRAYSIZE(g_szGuestName));

    ShowUserAccounts();

    _Module.Term();

    if (SUCCEEDED(hrCom))
        CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\nusrmgr\pagefact.h ===
// PageFact.h: interface for the CPageFactory class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __PAGEFACT_H_
#define __PAGEFACT_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


typedef struct
{
    const CLSID *pclsid;
    _ATL_CREATORFUNC* pfnCreateInstance;
} _PAGEMAP_ENTRY;

#define PAGE_ENTRY2(clsid,class)    {&clsid, class::_CreatorClass::CreateInstance},
#define PAGE_ENTRY(class)           PAGE_ENTRY2(__uuidof(class), class)

#define BEGIN_PAGE_MAP(class)       const _PAGEMAP_ENTRY class::s_rgPage[] = {
#define END_PAGE_MAP()              {&CLSID_NULL, NULL} };


class CPageFactory :
    public CComObjectRoot,
    public ITaskPageFactory
{
public:
    DECLARE_NOT_AGGREGATABLE(CPageFactory)

    BEGIN_COM_MAP(CPageFactory)
    COM_INTERFACE_ENTRY(ITaskPageFactory)
    END_COM_MAP()

    // ITaskPageFactory
    STDMETHOD(CreatePage)(REFCLSID rclsidPage, REFIID riid, void **ppv)
    {
        HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;
        for (UINT i = 0; CLSID_NULL != *s_rgPage[i].pclsid; i++)
        {
            if (rclsidPage == *s_rgPage[i].pclsid)
            {
                if (NULL != s_rgPage[i].pfnCreateInstance)
                {
                    hr = s_rgPage[i].pfnCreateInstance(NULL, riid, ppv);
                }
                break;
            }
        }
        return hr;
    }

    template <class Q>
    static HRESULT CreateInstance(Q** pp)
    {
        return CPageFactory::_CreatorClass::CreateInstance(NULL, __uuidof(Q), (void**)pp);
    }

private:
    static const _PAGEMAP_ENTRY s_rgPage[];
};


#endif // __PAGEFACT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\nusrmgr\userpage.h ===
// UserPage.h : Declaration of the CUserPage

#ifndef __USERPAGE_H_
#define __USERPAGE_H_

#include "Nusrmgr.h"
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CUserPage
class ATL_NO_VTABLE DECLSPEC_UUID("F4924514-CFBC-4AAB-9EC5-6C6E6D0DB38D") CUserPage : 
    public CComObjectRoot,
    public CHTMLPageImpl<CUserPage,IUserPageUI>
{
public:
    CUserPage() : _pUser(NULL), _bSelf(FALSE), _bRunningAsOwner(FALSE), _bRunningAsAdmin(FALSE) {}
    ~CUserPage() { ATOMICRELEASE(_pUser); }

DECLARE_NOT_AGGREGATABLE(CUserPage)

//DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CUserPage)
    COM_INTERFACE_ENTRY(ITaskPage)
    COM_INTERFACE_ENTRY(IUserPageUI)
    COM_INTERFACE_ENTRY2(IDispatch, IUserPageUI)
END_COM_MAP()

// ITaskPage overrides
public:
    STDMETHOD(SetFrame)(ITaskFrame* pFrame);
    STDMETHOD(Reinitialize)(/*[in]*/ ULONG reserved);

// IUserPageUI
public:
    STDMETHOD(get_isSelf)(/*[out, retval]*/ VARIANT_BOOL *pVal)         { return _GetBool(_bSelf, pVal); }
    STDMETHOD(get_runningAsOwner)(/*[out, retval]*/ VARIANT_BOOL *pVal) { return _GetBool(_bRunningAsOwner, pVal); }
    STDMETHOD(get_runningAsAdmin)(/*[out, retval]*/ VARIANT_BOOL *pVal) { return _GetBool(_bRunningAsAdmin, pVal); }
    STDMETHOD(get_passwordRequired)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(get_isAdmin)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(get_isGuest)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(get_isOwner)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(get_userDisplayName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(createUserDisplayHTML)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(countOwners)(/*[out, retval]*/ UINT *pVal);
    STDMETHOD(enableGuest)(/*[in]*/ VARIANT_BOOL bEnable);

private:
    HRESULT _GetBool(BOOL bVal, VARIANT_BOOL *pVal)
    {
        if (NULL == pVal)
            return E_POINTER;
        *pVal = bVal ? VARIANT_TRUE : VARIANT_FALSE;
        return S_OK;
    }

public:
    static LPWSTR c_aHTML[2];

private:
    ILogonUser* _pUser;
    BOOL _bSelf;
    BOOL _bRunningAsOwner;
    BOOL _bRunningAsAdmin;
};

EXTERN_C const CLSID CLSID_UserPage;


HRESULT CountOwners(IUnknown* punkUserList, UINT *pVal);
HRESULT EnableGuest(VARIANT_BOOL bEnable);

#endif //__USERPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\test\mainwnd.h ===
// MainWnd.h: interface for the CMainWnd class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINWND_H__8C77E845_5BA0_4B41_B6E0_619E0BA76E5E__INCLUDED_)
#define AFX_MAINWND_H__8C77E845_5BA0_4B41_B6E0_619E0BA76E5E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CMainWnd : public CWindowImpl<CMainWnd, CWindow, CFrameWinTraits>  
{
public:
    CMainWnd(void);
    ~CMainWnd(void);

BEGIN_MSG_MAP(CMainWnd)
MESSAGE_HANDLER(WM_INITMENUPOPUP, OnInitMenuPopup)
COMMAND_ID_HANDLER(ID_TEST_DOMODAL, OnDoModal)
COMMAND_ID_HANDLER(ID_TEST_DOMODELESS, OnDoModeless)
COMMAND_ID_HANDLER(ID_TEST_CLOSEMODELESS, OnCloseModeless)
COMMAND_ID_HANDLER(ID_TEST_EXIT, OnExit)
END_MSG_MAP()

private:
    CComPtr<ITaskSheet> m_spTaskSheet;

    virtual void OnFinalMessage(HWND hwnd);
    LRESULT OnInitMenuPopup(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDoModal(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnDoModeless(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCloseModeless(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnExit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    HRESULT CreateTaskSheet(BOOL bModeless);
    HRESULT CloseTaskSheet();
};

#endif // !defined(AFX_MAINWND_H__8C77E845_5BA0_4B41_B6E0_619E0BA76E5E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\nusrmgr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef __STDAFX_H_
#define __STDAFX_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <debug.h>
#include <ccstock.h>

#include <shgina.h>
#include <TaskUI.h>

extern WCHAR g_szAdminName[];
extern WCHAR g_szGuestName[];

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlhost.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // __STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\test\litecontrol.h ===
// LiteControl.h : Declaration of the CLiteControl

#ifndef __LITECONTROL_H_
#define __LITECONTROL_H_

#include "resource.h"       // main symbols
#include <atlctl.h>


/////////////////////////////////////////////////////////////////////////////
// CLiteControl
class ATL_NO_VTABLE CLiteControl : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<ILiteControl, &IID_ILiteControl, &LIBID_TaskAppLib>,
	public CComControl<CLiteControl>,
	public IPersistStreamInitImpl<CLiteControl>,
	public IOleControlImpl<CLiteControl>,
	public IOleObjectImpl<CLiteControl>,
	public IOleInPlaceActiveObjectImpl<CLiteControl>,
	public IViewObjectExImpl<CLiteControl>,
	public IOleInPlaceObjectWindowlessImpl<CLiteControl>,
	public CComCoClass<CLiteControl, &CLSID_LiteControl>
{
public:
    CLiteControl() : m_pTaskFrame(NULL), m_clsidDestPage(GUID_NULL), m_strText(L"<empty>")
    {
        m_sizePreferred = m_sizeExtent;
    }
    ~CLiteControl() { ATOMICRELEASE(m_pTaskFrame); }

    HRESULT SetFrame(ITaskFrame* pFrame)
    {
        ATOMICRELEASE(m_pTaskFrame);
        m_pTaskFrame = pFrame;
        if (m_pTaskFrame)
            m_pTaskFrame->AddRef();
        return S_OK;
    }

    HRESULT SetDestinationPage(REFCLSID rclsidPage)
    {
        m_clsidDestPage = rclsidPage;
        return S_OK;
    }

    HRESULT SetText(LPCWSTR pszText)
    {
        m_strText = pszText;
        return S_OK;
    }

    HRESULT SetMaxExtent(LONG cxWidth, LONG cxHeight)
    {
        if (0 == cxWidth)
            cxWidth = 2540;     // 1 inch
        if (0 == cxHeight)
            cxHeight = 2540;    // 1 inch

        m_sizePreferred.cx = cxWidth;
        m_sizePreferred.cy = cxHeight;
        return S_OK;
    }

    STDMETHOD(GetExtent)(DWORD /*dwDrawAspect*/, SIZEL *psizel)
    {
        if (psizel == NULL)
            return E_POINTER;
        *psizel = m_sizePreferred;
        return S_OK;
    }

DECLARE_NOT_AGGREGATABLE(CLiteControl)
//DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CLiteControl)
	COM_INTERFACE_ENTRY(ILiteControl)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
END_COM_MAP()

BEGIN_PROP_MAP(CLiteControl)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CLiteControl)
	CHAIN_MSG_MAP(CComControl<CLiteControl>)
	DEFAULT_REFLECTION_HANDLER()
	MESSAGE_HANDLER(WM_LBUTTONUP, OnButtonUP)
	MESSAGE_HANDLER(WM_RBUTTONUP, OnButtonUP)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// ILiteControl
public:

    HRESULT OnDraw(ATL_DRAWINFO& di)
    {
        RECT& rc = *(RECT*)di.prcBounds;
        Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);

        LPCWSTR pszText = m_strText ? m_strText : L"<empty>";
        SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
        TextOutW(di.hdcDraw,
                 (rc.left + rc.right) / 2,
                 (rc.top + rc.bottom) / 2,
                 pszText,
                 lstrlen(pszText));

        return S_OK;
    }

private:
    ITaskFrame* m_pTaskFrame;
    CLSID m_clsidDestPage;
    CComBSTR m_strText;
    SIZEL m_sizePreferred;

    LRESULT OnButtonUP(UINT uMsg, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
    {
        if (NULL != m_pTaskFrame)
            m_pTaskFrame->ShowPage(m_clsidDestPage, WM_RBUTTONUP == uMsg);
        return 0;
    }
};

#endif //__LITECONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\test\litecontrol.cpp ===
// LiteControl.cpp : Implementation of CLiteControl

#include "pch.h"
#include "TaskApp.h"
#include "LiteControl.h"

/////////////////////////////////////////////////////////////////////////////
// CLiteControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\test\mainwnd.cpp ===
// MainWnd.cpp: implementation of the CMainWnd class.
//
//////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "resource.h"
#include "Page1.h"
#include "MainWnd.h"
#include "pagefact.h"


//////////////////////////////////////////////////////////////////////
// CMainWnd
//////////////////////////////////////////////////////////////////////
CMainWnd::CMainWnd(void)
{

}


CMainWnd::~CMainWnd(void)
{

}


void CMainWnd::OnFinalMessage(HWND /*hwnd*/)
{
    CloseTaskSheet();
    PostQuitMessage(0);
}

LRESULT CMainWnd::OnInitMenuPopup(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    const UINT uEnable = MF_BYCOMMAND | MF_ENABLED;
    const UINT uDisable = MF_BYCOMMAND | MF_DISABLED | MF_GRAYED;

    if (0 == LOWORD(lParam))
    {
        HMENU hMenu = (HMENU)wParam;
        BOOL bSheetOpen = m_spTaskSheet ? TRUE : FALSE;
        EnableMenuItem(hMenu, ID_TEST_DOMODAL, bSheetOpen ? uDisable : uEnable);
        EnableMenuItem(hMenu, ID_TEST_DOMODELESS, bSheetOpen ? uDisable : uEnable);
        EnableMenuItem(hMenu, ID_TEST_CLOSEMODELESS, bSheetOpen ? uEnable : uDisable);
    }
    return 0;
}

LRESULT CMainWnd::OnDoModal(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
{
    CreateTaskSheet(FALSE);
    return 0;
}

LRESULT CMainWnd::OnDoModeless(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
{
    CreateTaskSheet(TRUE);
    return 0;
}

LRESULT CMainWnd::OnCloseModeless(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
{
    CloseTaskSheet();
    return 0;
}

LRESULT CMainWnd::OnExit(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
{
    SendMessage(WM_CLOSE);
    return 0;
}

HRESULT CMainWnd::CreateTaskSheet(BOOL bModeless)
{
    HRESULT hr;

    // For sanity
    CloseTaskSheet();

    hr = m_spTaskSheet.CoCreateInstance(__uuidof(TaskSheet));

    if (SUCCEEDED(hr))
    {
        CComPtr<IPropertyBag> spProps = NULL;

        hr = m_spTaskSheet->GetPropertyBag(IID_IPropertyBag, (void**)&spProps);

        if (SUCCEEDED(hr))
        {
            CComVariant var(L"Task Sheet Test");
            spProps->Write(TS_PROP_TITLE, &var);

            var = 600;
            spProps->Write(TS_PROP_WIDTH, &var);

            var = 400;
            spProps->Write(TS_PROP_HEIGHT, &var);

            var = 400;
            spProps->Write(TS_PROP_MINWIDTH, &var);

            var = 250;
            spProps->Write(TS_PROP_MINHEIGHT, &var);

            WCHAR szTemp[MAX_PATH];
            wnsprintfW(szTemp, ARRAYSIZE(szTemp), L"res://taskapp.exe/%d/%d", RT_BITMAP, IDB_WATERMARK);
            var = szTemp;
            //var = L"file://c:\\windows\\ua_bkgnd.bmp";
            spProps->Write(TS_PROP_WATERMARK, &var);

            // Note: Make modeless be resizable and modal not-resizable,
            // just to exercise both resizable and not.
            // Ditto for showing the statusbar.
            var = bModeless;
            spProps->Write(TS_PROP_MODELESS, &var);
            spProps->Write(TS_PROP_RESIZABLE, &var);
            spProps->Write(TS_PROP_STATUSBAR, &var);

            ITaskPageFactory *pPageFactory = NULL;
            hr = CPageFactory::CreateInstance(&pPageFactory);
            if (SUCCEEDED(hr))
            {
                hr = m_spTaskSheet->Run(pPageFactory, CLSID_CPage1, m_hWnd);
                pPageFactory->Release();
            }
        }                                                       

        if (!bModeless)
            m_spTaskSheet.Release();
    }

    return hr;
}

HRESULT CMainWnd::CloseTaskSheet()
{
    HRESULT hr = E_UNEXPECTED;

    if (m_spTaskSheet)
    {
        hr = m_spTaskSheet->Close();
        m_spTaskSheet.Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\nusrmgr\userpage.cpp ===
// UserPage.cpp : Implementation of CUserPage
#include "stdafx.h"
#include "MainPage.h"
#include "UserPage.h"

EXTERN_C const CLSID CLSID_UserPage = __uuidof(CUserPage);


/////////////////////////////////////////////////////////////////////////////
// CUserPage

LPWSTR CUserPage::c_aHTML[] =
{
    L"res://nusrmgr.exe/userpage.htm",
    L"res://nusrmgr.exe/userpage_sec.htm"
};

STDMETHODIMP CUserPage::SetFrame(ITaskFrame* pFrame)
{
    HRESULT hr;

    ATOMICRELEASE(_pUser);
    _bSelf = FALSE;
    _bRunningAsOwner = FALSE;
    _bRunningAsAdmin = FALSE;

    hr = CHTMLPageImpl<CUserPage,IUserPageUI>::SetFrame(pFrame);

    if (NULL != _pBag)
    {
        CComVariant var;
        hr = _pBag->Read(UA_PROP_USERLIST, &var, NULL);
        if (SUCCEEDED(hr))
        {
            CComQIPtr<ILogonEnumUsers> spUserList(var.punkVal);
            if (spUserList)
            {
                CComPtr<ILogonUser> spLoggedOnUser;
                hr = spUserList->get_currentUser(&spLoggedOnUser);

                var.Clear();
                hr = _pBag->Read(UA_PROP_PAGEINITDATA, &var, NULL);
                if (SUCCEEDED(hr))
                {
                    hr = spUserList->item(var, &_pUser);
                    if (SUCCEEDED(hr))
                    {
                        if (spLoggedOnUser)
                            _bSelf = IsSameAccount(spLoggedOnUser, var.bstrVal);

                        // Clear the pageinit prop
                        var.Clear();
                        _pBag->Write(UA_PROP_PAGEINITDATA, &var);
                    }
                }
                else
                {
                    _pUser = spLoggedOnUser;
                    if (NULL != _pUser)
                    {
                        _pUser->AddRef();
                        _bSelf = TRUE;
                    }
                }

                if (spLoggedOnUser)
                {
                    _bRunningAsOwner = IsOwnerAccount(spLoggedOnUser);
                    _bRunningAsAdmin = IsAdminAccount(spLoggedOnUser);
                }
            }
        }
    }

    return hr;
}

STDMETHODIMP CUserPage::Reinitialize(ULONG /*reserved*/)
{
    if (NULL == _pBag || NULL == _pUser)
        return E_UNEXPECTED;

    CComVariant var;
    if (SUCCEEDED(_pBag->Read(UA_PROP_PAGEINITDATA, &var, NULL)) &&
        (VT_BSTR == var.vt) &&
        IsSameAccount(_pUser, var.bstrVal))
    {
        // It's the same user, so this page can be reused as is.

        // TODO: actually, should reinit in case something has changed and
        // we need to hide/show different tasks. Also, the UserDisplayHTML
        // may be out of date.
        //
        // Leaving this in for now to verify frame optimizations

        // Clear the pageinit prop
        var.Clear();
        _pBag->Write(UA_PROP_PAGEINITDATA, &var);
        return S_OK;
    }

    // We could do some more work to re-init the page here.
    // Failing causes the page to be thrown away and recreated.

    return E_FAIL;
}

STDMETHODIMP CUserPage::get_passwordRequired(VARIANT_BOOL *pVal)
{
    if (NULL == pVal)
        return E_POINTER;

    *pVal = NULL;

    if (NULL == _pUser)
        return E_UNEXPECTED;

    return _pUser->get_passwordRequired(pVal);
}

STDMETHODIMP CUserPage::get_isAdmin(VARIANT_BOOL *pVal)
{
    if (NULL == _pUser)
        return E_UNEXPECTED;

    return _GetBool((_bSelf ? _bRunningAsAdmin : IsAdminAccount(_pUser)), pVal);
}

STDMETHODIMP CUserPage::get_isGuest(VARIANT_BOOL *pVal)
{
    if (NULL == _pUser)
        return E_UNEXPECTED;

    return _GetBool(IsGuestAccount(_pUser), pVal);
}

STDMETHODIMP CUserPage::get_isOwner(VARIANT_BOOL *pVal)
{
    if (NULL == _pUser)
        return E_UNEXPECTED;

    return _GetBool(IsOwnerAccount(_pUser), pVal);
}

STDMETHODIMP CUserPage::get_userDisplayName(BSTR *pVal)
{
    if (NULL == pVal)
        return E_POINTER;

    *pVal = NULL;

    if (NULL == _pUser)
        return E_UNEXPECTED;

    *pVal = GetUserDisplayName(_pUser);

    return S_OK;
}

STDMETHODIMP CUserPage::createUserDisplayHTML(BSTR *pVal)
{
    if (NULL == pVal)
        return E_POINTER;

    *pVal = NULL;

    if (NULL == _pUser)
        return E_UNEXPECTED;

    LPWSTR pszHTML = CreateUserDisplayHTML(_pUser);

    if (NULL != pszHTML)
    {
        *pVal = SysAllocString(pszHTML);
        LocalFree(pszHTML);
    }

    return S_OK;
}

STDMETHODIMP CUserPage::countOwners(UINT *pVal)
{
    if (NULL == pVal)
        return E_POINTER;

    *pVal = 0;

    if (NULL == _pBag)
        return E_UNEXPECTED;

    CComVariant var;
    HRESULT hr = _pBag->Read(UA_PROP_USERLIST, &var, NULL);
    if (SUCCEEDED(hr))
    {
        // The user list is saved as VT_UNKNOWN
        hr = CountOwners(var.punkVal, pVal);
    }

    return hr;
}

STDMETHODIMP CUserPage::enableGuest(VARIANT_BOOL bEnable)
{
    if (NULL == _pTaskFrame)
        return E_UNEXPECTED;

    HRESULT hr = EnableGuest(bEnable);
    if (SUCCEEDED(hr))
        hr = _pTaskFrame->ShowPage(CLSID_MainPage, TRUE);
    return hr;
}

HRESULT CountOwners(IUnknown* punkUserList, UINT *pVal)
{
    if (NULL == pVal)
        return E_POINTER;

    *pVal = 0;

    if (NULL == punkUserList)
        return E_INVALIDARG;

    UINT cOwners = 0;

    CComQIPtr<ILogonEnumUsers> spUserList(punkUserList);
    if (spUserList)
    {
        // Note that 'Administrator' is not included in the count.

        // Note also that we don't really need a true count, we only
        // need to know whether there is 0, 1, or many. Therefore, we
        // always stop counting at 2.

        UINT cUsers = 0;
        spUserList->get_length(&cUsers);

        VARIANT var;
        var.vt = VT_I4;

        for (UINT i = 0; i < cUsers && cOwners < 2; i++)
        {
            CComPtr<ILogonUser> spUser;
            var.lVal = i;
            spUserList->item(var, &spUser);

            if (spUser && IsOwnerAccount(spUser) && !IsAdminAccount(spUser))
                ++cOwners;
        }
    }

    *pVal = cOwners;

    return S_OK;
}

HRESULT EnableGuest(VARIANT_BOOL bEnable)
{
    CComPtr<ILocalMachine> spLocalMachine;
    HRESULT hr = spLocalMachine.CoCreateInstance(CLSID_ShellLocalMachine);
    if (SUCCEEDED(hr))
        hr = spLocalMachine->put_isGuestEnabled(bEnable);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\test\page1.cpp ===
// Page1.cpp : Implementation of CTaskAppApp and DLL registration.

#include "pch.h"
#include "TaskApp.h"
#include "LiteControl.h"
#include "Page1.h"
#include "Page2.h"

EXTERN_C const CLSID CLSID_CPage1 = __uuidof(CPage1);

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CPage1::SetFrame(ITaskFrame* pFrame)
{
    ATOMICRELEASE(m_pTaskFrame);
    m_pTaskFrame = pFrame;
    if (m_pTaskFrame)
        m_pTaskFrame->AddRef();
    return S_OK;
}

// 1 primary, 3 secondary
static const UINT s_rgObjectCount[] = { 1, 3 };

STDMETHODIMP CPage1::GetObjectCount(UINT nArea, UINT *pVal)
{
    if (!pVal)
        return E_POINTER;

    *pVal = 0;

    if (nArea < ARRAYSIZE(s_rgObjectCount))
        *pVal = s_rgObjectCount[nArea];

    return S_OK;
}

STDMETHODIMP CPage1::CreateObject(UINT nArea, UINT nIndex, REFIID riid, void **ppv)
{
    HRESULT hr;

    CComObject<CLiteControl>* pControl = NULL;
    hr = CComObject<CLiteControl>::CreateInstance(&pControl);
    if (SUCCEEDED(hr))
    {
        static const LPCWSTR pszFormat[] =
        {
            L"Page 1 primary control #%d",
            L"Secondary #%d",
            L"Unknown %d"
        };
        WCHAR szText[MAX_PATH];

        pControl->AddRef();

        pControl->SetFrame(m_pTaskFrame);
        pControl->SetDestinationPage(CLSID_CPage2);

        nArea = min(nArea, ARRAYSIZE(pszFormat)-1);
        wsprintfW(szText, pszFormat[nArea], nIndex+1);
        pControl->SetText(szText);

        pControl->SetMaxExtent(MAXLONG, nArea ? 0 : MAXLONG);

        hr = pControl->QueryInterface(riid, ppv);

        pControl->Release();
    }

    return hr;
}

STDMETHODIMP CPage1::Reinitialize(ULONG /*reserved*/)
{
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\test\page2.h ===
// Page2.h: Definition of the Page2 class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PAGE2_H__C9332CBE_E2D6_4722_B81D_283E2A400E84__INCLUDED_)
#define AFX_PAGE2_H__C9332CBE_E2D6_4722_B81D_283E2A400E84__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPage2

class DECLSPEC_UUID("c4ba3bb9-2105-4f8d-95a6-1e9166ec2710") CPage2 : 
    public ITaskPage,
    public CComObjectRoot
{
public:
    CPage2() : m_pTaskFrame(NULL) {}
    ~CPage2() { ATOMICRELEASE(m_pTaskFrame); }

BEGIN_COM_MAP(CPage2)
    COM_INTERFACE_ENTRY(ITaskPage)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CPage2) 

// ITaskPage
public:
    STDMETHOD(SetFrame)(ITaskFrame* pFrame);
    STDMETHOD(GetObjectCount)(UINT nArea, UINT *pVal);
    STDMETHOD(CreateObject)(UINT nArea, UINT nIndex, REFIID riid, void **ppv);
    STDMETHOD(Reinitialize)(ULONG reserved);

private:
    ITaskFrame* m_pTaskFrame;
};

EXTERN_C const CLSID CLSID_CPage2;

#endif // !defined(AFX_PAGE2_H__C9332CBE_E2D6_4722_B81D_283E2A400E84__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\test\pch.h ===
// pch.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#ifndef __TaskApp_PCH_
#define __TaskApp_PCH_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <dpa.h>
#include <debug.h>
#include <ccstock.h>

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

#include "TaskUI.h"


#endif // __TaskApp_PCH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\test\pagefact.h ===
// PageFact.h: interface for the CPageFactory class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PAGEFACT_H__13C333CD_90F7_42E8_B819_075B4D2B16F5__INCLUDED_)
#define AFX_PAGEFACT_H__13C333CD_90F7_42E8_B819_075B4D2B16F5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CPageFactory :
    public CComObjectRoot,
    public ITaskPageFactory
{
public:

DECLARE_NOT_AGGREGATABLE(CPageFactory)

BEGIN_COM_MAP(CPageFactory)
COM_INTERFACE_ENTRY(ITaskPageFactory)
END_COM_MAP()

// ITaskPageFactory
    STDMETHOD(CreatePage)(REFCLSID rclsidPage, REFIID riid, void **ppv);

    template <class Q>
    static HRESULT CreateInstance(Q** pp)
    {
        return CPageFactory::_CreatorClass::CreateInstance(NULL, __uuidof(Q), (void**) pp);
    }
};

#endif // !defined(AFX_PAGEFACT_H__13C333CD_90F7_42E8_B819_075B4D2B16F5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\test\pagefact.cpp ===
// PageFact.cpp: implementation of the CPageFactory class.
//
//////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "PageFact.h"
#include "Page1.h"
#include "Page2.h"

//////////////////////////////////////////////////////////////////////
// ITaskPageFactory
//////////////////////////////////////////////////////////////////////

typedef struct
{
    const CLSID *pclsid;
    _ATL_CREATORFUNC* pfnCreateInstance;
} _PAGEMAP_ENTRY;

#define PAGE_ENTRY2(clsid,class)    {&clsid, class::_CreatorClass::CreateInstance},
#define PAGE_ENTRY(class)           PAGE_ENTRY2(__uuidof(class), class)

static const _PAGEMAP_ENTRY s_rgPage[] =
{
    PAGE_ENTRY(CPage1)
    PAGE_ENTRY(CPage2)
};

STDMETHODIMP CPageFactory::CreatePage(REFCLSID rclsidPage, REFIID riid, void ** ppv)
{
    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

    //if (CLSID_CPage1 == rclsidPage)
    //{
    //    hr = CPage1::_CreatorClass::CreateInstance(NULL, riid, ppv);
    //}
    //else if (CLSID_CPage2 == rclsidPage)
    //{
    //    hr = CPage2::_CreatorClass::CreateInstance(NULL, riid, ppv);
    //}
    // etc.

    for (UINT i = 0; i < ARRAYSIZE(s_rgPage); i++)
    {
        if (rclsidPage == *s_rgPage[i].pclsid)
        {
            if (NULL != s_rgPage[i].pfnCreateInstance)
            {
                hr = s_rgPage[i].pfnCreateInstance(NULL, riid, ppv);
            }
            break;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\test\page1.h ===
// Page1.h: Definition of the Page1 class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PAGE1_H__C9332CBE_E2D6_4722_B81D_283E2A400E84__INCLUDED_)
#define AFX_PAGE1_H__C9332CBE_E2D6_4722_B81D_283E2A400E84__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPage1

class DECLSPEC_UUID("C9332CBE-E2D6-4722-B81D-283E2A400E84") CPage1 : 
    public ITaskPage,
    public CComObjectRoot
{
public:
    CPage1() : m_pTaskFrame(NULL) {}
    ~CPage1() { ATOMICRELEASE(m_pTaskFrame); }

BEGIN_COM_MAP(CPage1)
    COM_INTERFACE_ENTRY(ITaskPage)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CPage1) 

// ITaskPage
public:
    STDMETHOD(SetFrame)(ITaskFrame* pFrame);
    STDMETHOD(GetObjectCount)(UINT nArea, UINT *pVal);
    STDMETHOD(CreateObject)(UINT nArea, UINT nIndex, REFIID riid, void **ppv);
    STDMETHOD(Reinitialize)(ULONG reserved);

private:
    ITaskFrame* m_pTaskFrame;
};

EXTERN_C const CLSID CLSID_CPage1;

#endif // !defined(AFX_PAGE1_H__C9332CBE_E2D6_4722_B81D_283E2A400E84__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\test\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TaskApp.rc
//
#define IDS_PROJNAME                    100
#define IDR_MAINMENU                    201
#define IDB_LITECONTROL                 202
#define IDB_WATERMARK                   203
#define ID_TEST_DOMODAL                 32768
#define ID_TEST_DOMODELESS              32769
#define ID_TEST_CLOSEMODELESS           32770
#define ID_TEST_EXIT                    32771

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        204
#define _APS_NEXT_COMMAND_VALUE         32772
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\test\page2.cpp ===
// Page2.cpp : Implementation of CTaskAppApp and DLL registration.

#include "pch.h"
#include "TaskApp.h"
#include "LiteControl.h"
#include "Page1.h"
#include "Page2.h"

EXTERN_C const CLSID CLSID_CPage2 = __uuidof(CPage2);

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CPage2::SetFrame(ITaskFrame* pFrame)
{
    ATOMICRELEASE(m_pTaskFrame);
    m_pTaskFrame = pFrame;
    if (m_pTaskFrame)
        m_pTaskFrame->AddRef();
    return S_OK;
}

// 1 primary, 2 secondary
static const UINT s_rgObjectCount[] = { 1, 2 };

STDMETHODIMP CPage2::GetObjectCount(UINT nArea, UINT *pVal)
{
    if (!pVal)
        return E_POINTER;

    *pVal = 0;

    if (nArea < ARRAYSIZE(s_rgObjectCount))
        *pVal = s_rgObjectCount[nArea];

    return S_OK;
}

STDMETHODIMP CPage2::CreateObject(UINT nArea, UINT nIndex, REFIID riid, void **ppv)
{
    HRESULT hr;

    CComObject<CLiteControl>* pControl = NULL;
    hr = CComObject<CLiteControl>::CreateInstance(&pControl);
    if (SUCCEEDED(hr))
    {
        static const LPCWSTR pszFormat[] =
        {
            L"Page 2 primary control #%d",
            L"Secondary #%d",
            L"Unknown %d"
        };
        WCHAR szText[MAX_PATH];

        pControl->AddRef();

        pControl->SetFrame(m_pTaskFrame);
        pControl->SetDestinationPage(CLSID_CPage1);

        nArea = min(nArea, ARRAYSIZE(pszFormat)-1);
        wsprintfW(szText, pszFormat[nArea], nIndex+1);
        pControl->SetText(szText);

        pControl->SetMaxExtent(MAXLONG, nArea ? 0 : MAXLONG);

        hr = pControl->QueryInterface(riid, ppv);

        pControl->Release();
    }

    return hr;
}

STDMETHODIMP CPage2::Reinitialize(ULONG /*reserved*/)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\assoc.h ===
/*
 * assoc.h - Type association routines description.
 */


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Global Constants
 *******************/

/* assoc.c */

extern const HKEY g_hkeyURLProtocols;
extern const HKEY g_hkeyMIMESettings;
extern CCHAR g_cszURLProtocol[];
extern CCHAR g_cszContentType[];
extern CCHAR g_cszExtension[];


/* Prototypes
 *************/

/* assoc.c */

extern BOOL RegisterMIMETypeForExtension(PCSTR pcszExtension, PCSTR pcszMIMEContentType);
extern BOOL UnregisterMIMETypeForExtension(PCSTR pcszExtension);
extern BOOL RegisterExtensionForMIMEType(PCSTR pcszExtension, PCSTR pcszMIMEContentType);
extern BOOL UnregisterExtensionForMIMEType(PCSTR pcszMIMEContentType);
extern BOOL RegisterMIMEAssociation(PCSTR pcszFile, PCSTR pcszMIMEContentType);
extern BOOL RegisterURLAssociation(PCSTR pcszProtocol, PCSTR pcszApp);
extern HRESULT MyMIMEAssociationDialog(HWND hwndParent, DWORD dwInFlags, PCSTR pcszFile, PCSTR pcszMIMEContentType, PSTR pszAppBuf, UINT ucAppBufLen);
extern HRESULT MyURLAssociationDialog(HWND hwndParent, DWORD dwInFlags, PCSTR pcszFile, PCSTR pcszURL, PSTR pszAppBuf, UINT ucAppBufLen);


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\addon.h ===
// Common strings

#define NO_HELP                         ((DWORD) -1)
#define IDH_COMM_GROUPBOX               0001

// Welcome Help after Setup: Jessev

#define GET_WELCOME			0002

// Enhanced Property Sheet ID's: Shawnb


#define IDH_COMPDRV_TABLE_ULTRA		1002
#define IDH_COMPDRV_TABLE_HIPACK	1003
#define IDH_COMPDRV_TABLE_STD		1004
#define IDH_COMPDRV_TABLE_UNCOMP	1005
#define IDH_COMPDRV_TABLE_FREESP	1006
#define IDH_COMPDRV_TABLE_REDUCED	1007
#define IDH_COMPDRV_PIE                 1008
#define IDH_COMPDRV_TABLE               1009
#define IDH_COMPDRV_RECOMPNOW           1010
#define IDH_COMPDRV_UPGRADENOW		1011
#define IDH_COMPDRV_ADV                 1012
#define IDH_COMPDRV_ADV_HIDEHOST        1013
#define IDH_UNCOMPDRV_COMPDRIVE         1014
#define IDH_UNCOMPDRV_COMPPIE           1015
#define IDH_UNCOMPDRV_CREATENEW         1016
#define IDH_UNCOMPDRV_CREATEPIE         1017
#define IDH_HOSTDRV_PIE                 1018
#define IDH_HOSTDRV_TABLE           	1019
#define IDH_RUN_DRVSPACE                1020
#define IDH_COMPDRV_GAUGE		1021
#define IDH_COMPDRV_TABLE_TOTAL		1022


//ID's for the Theme Picker applet

#define IDH_THEME_LIST			2001		
#define IDH_THEME_SAVEAS		2002
#define IDH_THEME_DELETE		2003
#define IDH_THEME_PREVSCRN		2004
#define IDH_THEME_PREVETC		2005
#define IDH_THEME_PREVIEW		2006
#define IDH_THEME_SCRNSAVER		2007
#define IDH_THEMES_SOUNDS		2008
#define IDH_THEME_POINTERS		2009
#define IDH_THEME_WALLPAPER		2010
#define IDH_THEME_ICONS			2011
#define IDH_THEME_COLORS		2012
#define IDH_THEME_FONTS			2013
#define IDH_THEME_BORDER		2014
#define IDH_THEME_POINTERS_LIST		2015
#define IDH_THEME_POINTERS_PREV		2016
#define IDH_THEME_POINTERS_FILE		2018
#define IDH_THEME_SOUNDS_LIST		2019
#define IDH_THEME_SOUNDS_ICON_PREV	2020
#define IDH_THEME_SOUNDS_PLAYS		2021
#define IDH_THEME_SOUNDS_FILE		2022
#define IDH_THEME_PICS_LIST		2023
#define IDH_THEME_PICS_PREV		2024
#define IDH_THEME_PICS_FILE		2025
// #define IDH_THEME_SAVE_NAME		2026
#define IDH_THEME_ICON_SIZESPACE	2027

// Lens settings ID's

#define IDH_LENS_FLIP			3000		// Temporary
#define IDH_LENS_GLASS_SPHERE		3001
#define IDH_LENS_INSIDE_OUT		3002
#define IDH_LENS_BLACK_HOLE		3003
#define IDH_LENS_DENT			3004
#define IDH_LENS_SPIRAL			3005
#define IDH_LENS_SIZE			3006
#define IDH_LENS_SPEED			3007
#define IDH_LENS_INDEX			3008
#define IDH_LENS_ALTITUDE		3009
#define IDH_LENS_MASS			3010
#define IDH_LENS_HEIGHT			3011
#define IDH_LENS_TWIST			3012
#define IDH_LENS_WALLPAPER		3013

//Blocks settings ID's

#define IDH_BLOCKS_SIZE			3050
#define IDH_BLOCKS_SPEED		3051

//Socha Settings ID's

#define IDH_SCRNSAVER_GEN_MONITOR	3100
#define IDH_SCRNSAVER_GEN_MOUSESEN	3101
#define IDH_SCRNSAVER_GEN_PASSREQUIRED	3102
#define IDH_SCRNSAVER_GEN_ABOUT		3103
#define IDH_SCRNSAVER_PREVIEW		3104
#define IDH_SCRNSAVER_GEN_NOSOUND	3105

// Plus Display Properties ID's

#define IDH_DISPLAY_PLUSPACK_LIST	4100
#define IDH_DISPLAY_PLUSPACK_CHANGEICON	4101
#define IDH_DISPLAY_PLUSPACK_ALLCOLORS	4102
#define IDH_DISPLAY_PLUSPACK_FULLWINDOW	4103
#define IDH_DISPLAY_PLUSPACK_FONTSMOOTH	4104
#define IDH_DISPLAY_PLUSPACK_STRETCH	4105 
#define IDH_DISPLAY_PLUSPACK_LARGEICONS	4106


// RNA dial-in ID's

#define IDH_RNA_IN_NOACC                4259
#define IDH_RNA_IN_ENABLEACC            4260
#define IDH_RNA_IN_PASSWORD             4263
#define IDH_RNA_IN_COMMENT              4264
#define IDH_RNA_IN_STATUS               4265
#define IDH_RNA_IN_DISCONNECT           4266
#define IDH_RNA_MODEM_SERVER		4275

// Internet Shortcut Target URL

#define IDH_INTERNET_SHORTCUT_TARGET	6001

// Disk Troubleshooter ID's

#define IDH_DSKTRB_FREESPACE		5001
#define IDH_COMPSET_TRB_MAIN            5002    // Must match DOS\DOS86\DBLSPACE\UTILITY\FROSTHLP.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\autodial.hpp ===
/*****************************************************************/
/**				  Microsoft Windows								**/
/**		      Copyright (C) Microsoft Corp., 1995				**/
/*****************************************************************/ 

//
//	AUTODIAL.HPP - winsock autodial hook code
//

//	HISTORY:
//	
//	3/22/95	jeremys		Created.
//

#ifndef _AUTODIAL_HPP_
#define _AUTODIAL_HPP_


#include <raserror.h>

// typedefs for function pointers for RNA functions
typedef DWORD 		(WINAPI * RNAENUMDEVICES) (LPBYTE, LPDWORD, LPDWORD);
typedef DWORD 		(WINAPI * RNAIMPLICITDIAL) (HWND,LPSTR);
typedef DWORD 		(WINAPI * RNAACTIVATEENGINE) (VOID);
typedef DWORD 		(WINAPI * RNADEACTIVATEENGINE) (VOID);
typedef DWORD		(WINAPI * RNAENUMCONNENTRIES) (LPSTR,UINT,LPDWORD);
typedef DWORD		(WINAPI * RASCREATEPHONEBOOKENTRY) (HWND,LPSTR);
typedef DWORD		(WINAPI * RASEDITPHONEBOOKENTRY) (HWND,LPSTR,LPSTR);

// typedefs for function pointers for Internet wizard functions
typedef VOID		(WINAPI * INETPERFORMSECURITYCHECK) (HWND,LPBOOL);

// structure for getting proc addresses of api functions
typedef struct APIFCN {
	PVOID * ppFcnPtr;
	LPCSTR pszName;
} APIFCN;

#define SMALLBUFLEN		48	// convenient size for small buffers

#ifndef RAS_MaxEntryName
#undef RAS_MaxEntryName
#endif // RAS_MaxEntryName
#define RAS_MaxEntryName	256


/* Prototypes
 *************/

/* autodial.cpp */

extern BOOL InitAutodialModule(void);
extern void ExitAutodialModule(void);

// opcode ordinals for dwOpCode parameter in hook
#define AUTODIAL_CONNECT		1
#define AUTODIAL_GETHOSTBYADDR	2
#define AUTODIAL_GETHOSTBYNAME	3
#define AUTODIAL_LISTEN			4
#define AUTODIAL_RECVFROM		5
#define AUTODIAL_SENDTO			6

// maximum length of local host name
#define MAX_LOCAL_HOST			255

// max length of exported autodial handler function
#define MAX_AUTODIAL_FCNNAME	48
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\assoc.c ===
/*
 * assoc.c - Type association routines.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include <mluisupp.h>

#define _INTSHCUT_          /* for intshcut.h */
#include <intshcut.h>
#include <intshctp.h>       /* ALL_???_FLAGS */

#include "assoc.h"
#include "extricon.h"
#include "openas.h"
#pragma warning(disable:4001) /* "single line comment" warning */
#include "filetype.h"
#include "resource.h"
#pragma warning(default:4001) /* "single line comment" warning */
#include "shlstock.h"
#include "shlvalid.h"


/* Global Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

PUBLIC_DATA const HKEY g_hkeyURLProtocols          = HKEY_CLASSES_ROOT;
PUBLIC_DATA const HKEY g_hkeyMIMESettings          = HKEY_CLASSES_ROOT;

PUBLIC_DATA CCHAR g_cszURLProtocol[]               = "URL Protocol";

PUBLIC_DATA CCHAR g_cszContentType[]               = "Content Type";
PUBLIC_DATA CCHAR g_cszExtension[]                 = "Extension";

#pragma data_seg()


/* Module Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

PRIVATE_DATA CCHAR s_cszShellOpenCmdSubKeyFmt[]    = "%s\\shell\\open\\command";
PRIVATE_DATA CCHAR s_cszAppOpenCmdFmt[]            = "%s %%1";
PRIVATE_DATA CCHAR s_cszDefaultIconSubKeyFmt[]     = "%s\\DefaultIcon";
PRIVATE_DATA CCHAR s_cszDefaultIcon[]              = "url.dll,0";

#pragma data_seg()


/***************************** Private Functions *****************************/


/*
** RegisterAppAsURLProtocolHandler()
**
** Under HKEY_CLASSES_ROOT\url-protocol\shell\open\command, add default value =
** "c:\foo\bar.exe %1".
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL RegisterAppAsURLProtocolHandler(PCSTR pcszProtocol,
                                                  PCSTR pcszApp)
{
   BOOL bResult = FALSE;
   DWORD dwcbShellOpenCmdSubKeyLen;
   PSTR pszShellOpenCmdSubKey;

   ASSERT(IS_VALID_STRING_PTR(pcszProtocol, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszApp, CSTR));

   /* (+ 1) for null terminator. */
   dwcbShellOpenCmdSubKeyLen = sizeof(s_cszShellOpenCmdSubKeyFmt) + 1
                               + lstrlen(pcszProtocol);

   if (AllocateMemory(dwcbShellOpenCmdSubKeyLen, &pszShellOpenCmdSubKey))
   {
      DWORD dwcbAppOpenCmdLen;
      PSTR pszAppOpenCmd;

      /* FEATURE: We should quote pcszApp here only if it contains spaces. */

      /* (+ 1) for null terminator. */
      dwcbAppOpenCmdLen = sizeof(s_cszAppOpenCmdFmt) + 1 + lstrlen(pcszApp);

      if (AllocateMemory(dwcbAppOpenCmdLen, &pszAppOpenCmd))
      {
         EVAL((DWORD)wsprintf(pszShellOpenCmdSubKey, s_cszShellOpenCmdSubKeyFmt,
                              pcszProtocol) < dwcbShellOpenCmdSubKeyLen);

         EVAL((DWORD)wsprintf(pszAppOpenCmd, s_cszAppOpenCmdFmt, pcszApp)
              < dwcbAppOpenCmdLen);

         /* (+ 1) for null terminator. */
         bResult = (SetRegKeyValue(g_hkeyURLProtocols, pszShellOpenCmdSubKey,
                                   NULL, REG_SZ, (PCBYTE)pszAppOpenCmd,
                                   lstrlen(pszAppOpenCmd) + 1)
                    == ERROR_SUCCESS);

         FreeMemory(pszShellOpenCmdSubKey);
         pszShellOpenCmdSubKey = NULL;
      }

      FreeMemory(pszAppOpenCmd);
      pszAppOpenCmd = NULL;
   }

   return(bResult);
}


/*
** RegisterURLProtocolDescription()
**
** Under g_hkeyURLSettings\url-protocol, add default value =
** URL:Url-protocol Protocol.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL RegisterURLProtocolDescription(PCSTR pcszProtocol)
{
   BOOL bResult = FALSE;
   PSTR pszProtocolCopy;

   ASSERT(IS_VALID_STRING_PTR(pcszProtocol, CSTR));

   if (StringCopy(pcszProtocol, &pszProtocolCopy))
   {
      char szDescriptionFmt[MAX_PATH_LEN];

      /*
       * Convert first character of protocol to upper case for description
       * string.
       */

      *pszProtocolCopy = (CHAR)PtrToUlong(CharUpper((LPSTR)(DWORD_PTR)*pszProtocolCopy));

      if (MLLoadStringA(IDS_URL_DESC_FORMAT,
                     szDescriptionFmt, sizeof(szDescriptionFmt)))
      {
         char szDescription[MAX_PATH_LEN];

         if ((UINT)lstrlen(szDescriptionFmt) + (UINT)lstrlen(pszProtocolCopy)
             < sizeof(szDescription))
         {
            EVAL(wsprintf(szDescription, szDescriptionFmt, pszProtocolCopy)
                 < sizeof(szDescription));

            /* (+ 1) for null terminator. */
            bResult = (SetRegKeyValue(g_hkeyURLProtocols, pcszProtocol,
                                      NULL, REG_SZ, (PCBYTE)szDescription,
                                      lstrlen(szDescription) + 1)
                       == ERROR_SUCCESS);
         }
      }

      FreeMemory(pszProtocolCopy);
      pszProtocolCopy = NULL;
   }

   return(bResult);
}


/*
** RegisterURLProtocolFlags()
**
** Under g_hkeyURLSettings\url-protocol, add EditFlags = FTA_Show.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL RegisterURLProtocolFlags(PCSTR pcszProtocol)
{
   DWORD dwEditFlags = FTA_Show;

   ASSERT(IS_VALID_STRING_PTR(pcszProtocol, CSTR));

   /* FEATURE: What about preserving any existing EditFlags here? */

   /* (+ 1) for null terminator. */
   return(SetRegKeyValue(g_hkeyURLProtocols, pcszProtocol, g_cszEditFlags,
                         REG_BINARY, (PCBYTE)&dwEditFlags, sizeof(dwEditFlags))
          == ERROR_SUCCESS);
}


/*
** RegisterURLProtocol()
**
** Under g_hkeyURLSettings\url-protocol, add URL Protocol = "".
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL RegisterURLProtocol(PCSTR pcszProtocol)
{
   ASSERT(IS_VALID_STRING_PTR(pcszProtocol, CSTR));

   /* (+ 1) for null terminator. */
   return(SetRegKeyValue(g_hkeyURLProtocols, pcszProtocol, g_cszURLProtocol,
                         REG_SZ, (PCBYTE)EMPTY_STRING,
                         lstrlen(EMPTY_STRING) + 1) == ERROR_SUCCESS);
}


/*
** RegisterURLProtocolDefaultIcon()
**
** Under g_hkeyURLSettings\url-protocol\DefaultIcon, add default value =
** app.exe,0.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL RegisterURLProtocolDefaultIcon(PCSTR pcszProtocol)
{
   BOOL bResult = FALSE;
   DWORD dwcbDefaultIconSubKeyLen;
   PSTR pszDefaultIconSubKey;

   ASSERT(IS_VALID_STRING_PTR(pcszProtocol, CSTR));

   /* (+ 1) for null terminator. */
   dwcbDefaultIconSubKeyLen = sizeof(s_cszDefaultIconSubKeyFmt) + 1
                              + lstrlen(pcszProtocol);

   if (AllocateMemory(dwcbDefaultIconSubKeyLen, &pszDefaultIconSubKey))
   {
      EVAL((DWORD)wsprintf(pszDefaultIconSubKey, s_cszDefaultIconSubKeyFmt,
                           pcszProtocol) < dwcbDefaultIconSubKeyLen);

      bResult = (SetRegKeyValue(g_hkeyURLProtocols, pszDefaultIconSubKey,
                                NULL, REG_SZ, (PCBYTE)s_cszDefaultIcon,
                                sizeof(s_cszDefaultIcon))
                 == ERROR_SUCCESS);

      FreeMemory(pszDefaultIconSubKey);
      pszDefaultIconSubKey = NULL;
   }

   return(bResult);
}


PRIVATE_CODE BOOL AllowedToRegisterMIMEType(PCSTR pcszMIMEContentType)
{
   BOOL bResult;

#pragma data_seg(DATA_SEG_READ_ONLY)

   bResult = (lstrcmpi(pcszMIMEContentType, "application/octet-stream") != 0 &&
              lstrcmpi(pcszMIMEContentType, "application/octet-string") != 0);

#pragma data_seg()

   if (bResult)
      TRACE_OUT(("AllowedToRegisterMIMEType(): MIME type %s may be registered.",
                 pcszMIMEContentType));
   else
      WARNING_OUT(("AllowedToRegisterMIMEType(): MIME type %s may not be registered.",
                   pcszMIMEContentType));

   return(bResult);
}


/****************************** Public Functions *****************************/


/*
** RegisterMIMETypeForExtension()
**
** Under HKEY_CLASSES_ROOT\.ext, add Content Type = mime/type.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL RegisterMIMETypeForExtension(PCSTR pcszExtension,
                                               PCSTR pcszMIMEContentType)
{
   ASSERT(IS_VALID_STRING_PTR(pcszExtension, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszMIMEContentType, CSTR));

   ASSERT(IsValidExtension(pcszExtension));

   /* (+ 1) for null terminator. */
   return(SetRegKeyValue(HKEY_CLASSES_ROOT, pcszExtension, g_cszContentType, REG_SZ,
                         (PCBYTE)pcszMIMEContentType,
                         lstrlen(pcszMIMEContentType) + 1) == ERROR_SUCCESS);
}


/*
** UnregisterMIMETypeForExtension()
**
** Deletes Content Type under HKEY_CLASSES_ROOT\.ext.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL UnregisterMIMETypeForExtension(PCSTR pcszExtension)
{
   ASSERT(IS_VALID_STRING_PTR(pcszExtension, CSTR));

   ASSERT(IsValidExtension(pcszExtension));

   return(NO_ERROR == SHDeleteValue(HKEY_CLASSES_ROOT, pcszExtension, g_cszContentType));
}


/*
** RegisterExtensionForMIMEType()
**
** Under g_hkeyMIMESettings\MIME\Database\Content Type\mime/type, add
** Content Type = mime/type and Extension = .ext.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL RegisterExtensionForMIMEType(PCSTR pcszExtension,
                                               PCSTR pcszMIMEContentType)
{
   BOOL bResult;
   char szMIMEContentTypeSubKey[MAX_PATH_LEN];

   ASSERT(IS_VALID_STRING_PTR(pcszExtension, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszMIMEContentType, CSTR));

   ASSERT(IsValidExtension(pcszExtension));

   bResult = GetMIMETypeSubKey(pcszMIMEContentType, szMIMEContentTypeSubKey,
                               sizeof(szMIMEContentTypeSubKey));

   if (bResult)
      /* (+ 1) for null terminator. */
      bResult = (SetRegKeyValue(g_hkeyMIMESettings, szMIMEContentTypeSubKey,
                                g_cszExtension, REG_SZ, (PCBYTE)pcszExtension,
                                lstrlen(pcszExtension) + 1) == ERROR_SUCCESS);

   if (bResult)
      TRACE_OUT(("RegisterExtensionForMIMEType(): Registered extension %s as default extension for MIME type %s.",
                 pcszExtension,
                 pcszMIMEContentType));
   else
      WARNING_OUT(("RegisterExtensionForMIMEType(): Failed to register extension %s as default extension for MIME type %s.",
                   pcszExtension,
                   pcszMIMEContentType));

   return(bResult);
}


/*
** UnregisterExtensionForMIMEType()
**
** Deletes Extension under
** g_hkeyMIMESettings\MIME\Database\Content Type\mime/type.  If no other values
** or sub keys are left, deletes
** g_hkeyMIMESettings\MIME\Database\Content Type\mime/type.
**
** Arguments:
**
** Returns:
**
** Side Effects:  May also delete MIME key.
*/
PUBLIC_CODE BOOL UnregisterExtensionForMIMEType(PCSTR pcszMIMEContentType)
{
   BOOL bResult;
   char szMIMEContentTypeSubKey[MAX_PATH_LEN];

   ASSERT(IS_VALID_STRING_PTR(pcszMIMEContentType, CSTR));

   bResult = (GetMIMETypeSubKey(pcszMIMEContentType, szMIMEContentTypeSubKey,
                                sizeof(szMIMEContentTypeSubKey)) &&
              SHDeleteValue(g_hkeyMIMESettings, szMIMEContentTypeSubKey,
                                g_cszExtension) == ERROR_SUCCESS &&
              SHDeleteOrphanKey(g_hkeyMIMESettings, szMIMEContentTypeSubKey) == ERROR_SUCCESS);

   if (bResult)
      TRACE_OUT(("UnregisterExtensionForMIMEType(): Unregistered default extension for MIME type %s.",
                 pcszMIMEContentType));
   else
      WARNING_OUT(("UnregisterExtensionForMIMEType(): Failed to unregister default extension for MIME type %s.",
                   pcszMIMEContentType));

   return(bResult);
}


PUBLIC_CODE BOOL RegisterMIMEAssociation(PCSTR pcszFile,
                                         PCSTR pcszMIMEContentType)
{
   BOOL bResult;
   PCSTR pcszExtension;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszMIMEContentType, CSTR));

   pcszExtension = ExtractExtension(pcszFile);

    /*
     * Don't allow association of flag unknown MIME types
     * application/octet-stream and application/octet-string.
     */

   if (EVAL(*pcszExtension) &&
       AllowedToRegisterMIMEType(pcszMIMEContentType))
      bResult = (RegisterMIMETypeForExtension(pcszExtension, pcszMIMEContentType) &&
                 RegisterExtensionForMIMEType(pcszExtension, pcszMIMEContentType));
   else
      bResult = FALSE;

   return(bResult);
}


PUBLIC_CODE BOOL RegisterURLAssociation(PCSTR pcszProtocol, PCSTR pcszApp)
{
   ASSERT(IS_VALID_STRING_PTR(pcszProtocol, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszApp, CSTR));

   return(RegisterAppAsURLProtocolHandler(pcszProtocol, pcszApp) &&
          RegisterURLProtocolDescription(pcszProtocol) &&
          RegisterURLProtocol(pcszProtocol) &&
          RegisterURLProtocolFlags(pcszProtocol) &&
          RegisterURLProtocolDefaultIcon(pcszProtocol));
}


PUBLIC_CODE HRESULT MyMIMEAssociationDialog(HWND hwndParent, DWORD dwInFlags,
                                            PCSTR pcszFile,
                                            PCSTR pcszMIMEContentType,
                                            PSTR pszAppBuf, UINT ucAppBufLen)
{
   HRESULT hr;
   OPENASINFO oainfo;

   ASSERT(IS_VALID_HANDLE(hwndParent, WND));
   ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_MIMEASSOCDLG_FLAGS));
   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszMIMEContentType, CSTR));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszAppBuf, STR, ucAppBufLen));

   /* Use default file name if not supplied by caller. */

   if (ucAppBufLen > 0)
      *pszAppBuf = '\0';

   oainfo.pcszFile = pcszFile;
   oainfo.pcszClass = pcszMIMEContentType;
   oainfo.dwInFlags = 0;

   if (IS_FLAG_SET(dwInFlags, MIMEASSOCDLG_FL_REGISTER_ASSOC))
      SET_FLAG(oainfo.dwInFlags, (OPENASINFO_FL_ALLOW_REGISTRATION |
                                  OPENASINFO_FL_REGISTER_EXT));

   hr = MyOpenAsDialog(hwndParent, &oainfo);

   if (hr == S_OK &&
       IS_FLAG_SET(dwInFlags, MIMEASSOCDLG_FL_REGISTER_ASSOC))
      hr = RegisterMIMEAssociation(pcszFile, pcszMIMEContentType) ? S_OK
                                                                  : E_OUTOFMEMORY;

   if (SUCCEEDED(hr))
      lstrcpyn(pszAppBuf, oainfo.szApp, ucAppBufLen);

   ASSERT(! ucAppBufLen ||
          (IS_VALID_STRING_PTR(pszAppBuf, STR) &&
           EVAL((UINT)lstrlen(pszAppBuf) < ucAppBufLen)));
   ASSERT(SUCCEEDED(hr) ||
          (! ucAppBufLen ||
           EVAL(! *pszAppBuf)));

   return(hr);
}


PUBLIC_CODE HRESULT MyURLAssociationDialog(HWND hwndParent, DWORD dwInFlags,
                                           PCSTR pcszFile, PCSTR pcszURL,
                                           PSTR pszAppBuf, UINT ucAppBufLen)
{
   HRESULT hr;
   PSTR pszProtocol;

   ASSERT(IS_VALID_HANDLE(hwndParent, WND));
   ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_URLASSOCDLG_FLAGS));
   ASSERT(IS_FLAG_SET(dwInFlags, URLASSOCDLG_FL_USE_DEFAULT_NAME) ||
          IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszURL, CSTR));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszAppBuf, STR, ucAppBufLen));

   /* Use URL protocol as class name. */

   if (ucAppBufLen > 0)
      *pszAppBuf = '\0';

   hr = CopyURLProtocol(pcszURL, &pszProtocol);

   if (hr == S_OK)
   {
      char szInternetShortcut[MAX_PATH_LEN];
      OPENASINFO oainfo;

      /* Use default file name if not supplied by caller. */

      if (IS_FLAG_SET(dwInFlags, URLASSOCDLG_FL_USE_DEFAULT_NAME) &&
          EVAL(MLLoadStringA(IDS_INTERNET_SHORTCUT,
                          szInternetShortcut, sizeof(szInternetShortcut))))
         pcszFile = szInternetShortcut;

      oainfo.pcszFile = pcszFile;
      oainfo.pcszClass = pszProtocol;
      oainfo.dwInFlags = 0;

      if (IS_FLAG_SET(dwInFlags, URLASSOCDLG_FL_REGISTER_ASSOC))
         SET_FLAG(oainfo.dwInFlags, OPENASINFO_FL_ALLOW_REGISTRATION);

      hr = MyOpenAsDialog(hwndParent, &oainfo);

      if (hr == S_OK &&
          IS_FLAG_SET(dwInFlags, URLASSOCDLG_FL_REGISTER_ASSOC))
         hr = RegisterURLAssociation(pszProtocol, oainfo.szApp) ? S_OK
                                                                : E_OUTOFMEMORY;

      if (SUCCEEDED(hr))
         lstrcpyn(pszAppBuf, oainfo.szApp, ucAppBufLen);

      FreeMemory(pszProtocol);
      pszProtocol = NULL;
   }

   ASSERT(! ucAppBufLen ||
          (IS_VALID_STRING_PTR(pszAppBuf, STR) &&
           EVAL((UINT)lstrlen(pszAppBuf) < ucAppBufLen)));
   ASSERT(SUCCEEDED(hr) ||
          (! ucAppBufLen ||
           EVAL(! *pszAppBuf)));

   return(hr);
}


#ifdef DEBUG

PUBLIC_CODE BOOL IsValidPCOPENASINFO(PCOPENASINFO pcoainfo)
{
   return(IS_VALID_READ_PTR(pcoainfo, COPENASINFO) &&
          IS_VALID_STRING_PTR(pcoainfo->pcszFile, CSTR) &&
          (! pcoainfo->pcszClass ||
           IS_VALID_STRING_PTR(pcoainfo->pcszClass, CSTR)) &&
          FLAGS_ARE_VALID(pcoainfo->dwInFlags, ALL_OPENASINFO_FLAGS) &&
          (! *pcoainfo->szApp ||
           IS_VALID_STRING_PTR(pcoainfo->szApp, STR)));
}

#endif   /* DEBUG */


/***************************** Exported Functions ****************************/


INTSHCUTAPI HRESULT WINAPI MIMEAssociationDialogA(HWND hwndParent,
                                                  DWORD dwInFlags,
                                                  PCSTR pcszFile,
                                                  PCSTR pcszMIMEContentType,
                                                  PSTR pszAppBuf,
                                                  UINT ucAppBufLen)
{
   HRESULT hr;

   DebugEntry(MIMEAssociationDialogA);

#ifdef EXPV
   /* Verify parameters. */

   if (IS_VALID_HANDLE(hwndParent, WND) &&
       IS_VALID_STRING_PTR(pcszFile, CSTR) &&
       IS_VALID_STRING_PTR(pcszMIMEContentType, CSTR) &&
       IS_VALID_WRITE_BUFFER_PTR(pszAppBuf, STR, ucAppBufLen))
   {
      if (FLAGS_ARE_VALID(dwInFlags, ALL_MIMEASSOCDLG_FLAGS))
#endif
      {
         hr = MyMIMEAssociationDialog(hwndParent, dwInFlags, pcszFile,
                                      pcszMIMEContentType, pszAppBuf,
                                      ucAppBufLen);
      }
#ifdef EXPV
      else
         hr = E_FLAGS;
   }
   else
      hr = E_POINTER;
#endif

   DebugExitHRESULT(MIMEAssociationDialogA, hr);

   return(hr);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

INTSHCUTAPI HRESULT WINAPI MIMEAssociationDialogW(HWND hwndParent,
                                                  DWORD dwInFlags,
                                                  PCWSTR pcszFile,
                                                  PCWSTR pcszMIMEContentType,
                                                  PWSTR pszAppBuf,
                                                  UINT ucAppBufLen)
{
   HRESULT hr;

   DebugEntry(MIMEAssociationDialogW);

   SetLastError(ERROR_NOT_SUPPORTED);
   hr = E_NOTIMPL;

   DebugExitHRESULT(MIMEAssociationDialogW, hr);

   return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


INTSHCUTAPI HRESULT WINAPI URLAssociationDialogA(HWND hwndParent,
                                                 DWORD dwInFlags,
                                                 PCSTR pcszFile, PCSTR pcszURL,
                                                 PSTR pszAppBuf,
                                                 UINT ucAppBufLen)
{
   HRESULT hr;

   DebugEntry(URLAssociationDialogA);

#ifdef EXPV
   /* Verify parameters. */

   if (IS_VALID_HANDLE(hwndParent, WND) &&
       (IS_FLAG_SET(dwInFlags, URLASSOCDLG_FL_USE_DEFAULT_NAME) ||
        IS_VALID_STRING_PTR(pcszFile, CSTR)) &&
       IS_VALID_STRING_PTR(pcszURL, CSTR) &&
       IS_VALID_WRITE_BUFFER_PTR(pszAppBuf, STR, ucAppBufLen))
   {
      if (FLAGS_ARE_VALID(dwInFlags, ALL_URLASSOCDLG_FLAGS))
#endif
      {
         hr = MyURLAssociationDialog(hwndParent, dwInFlags, pcszFile, pcszURL,
                                     pszAppBuf, ucAppBufLen);
      }
#ifdef EXPV
      else
         hr = E_FLAGS;
   }
   else
      hr = E_POINTER;
#endif

   DebugExitHRESULT(URLAssociationDialogA, hr);

   return(hr);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

INTSHCUTAPI HRESULT WINAPI URLAssociationDialogW(HWND hwndParent,
                                                 DWORD dwInFlags,
                                                 PCWSTR pcszFile,
                                                 PCWSTR pcszURL,
                                                 PWSTR pszAppBuf,
                                                 UINT ucAppBufLen)
{
   HRESULT hr;

   DebugEntry(URLAssociationDialogW);

   SetLastError(ERROR_NOT_SUPPORTED);
   hr = E_NOTIMPL;

   DebugExitHRESULT(URLAssociationDialogW, hr);

   return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\taskui\test\taskapp.cpp ===
// TaskApp.cpp : Defines the entry point for the application.
//

#include "pch.h"
#include "resource.h"
#include "TaskApp.h"
#include "MainWnd.h"
#include "TaskApp_i.c"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE /*hPrevInstance*/,
                     LPSTR     /*lpCmdLine*/,
                     int       nCmdShow)
{
    int nResult = -1;

    CoInitialize(NULL);

    _Module.Init(ObjectMap, hInstance);

    HMENU hMenu = LoadMenu(hInstance, MAKEINTRESOURCE(IDR_MAINMENU));

    if (hMenu)
    {
        // Do not scope this at the outer level or it won't be destroyed
        // until after CoUninitialize, causing errors.
        CMainWnd wnd;

        wnd.Create(NULL, CWindow::rcDefault, TEXT("Task UI Test Application"));

        if (wnd)
        {
            // Could pass hMenu as the ID parameter to wnd.Create above, but
            // the ID parameter is UINT and the HMENU is therefore truncated
            // on 64 bit platforms.  (ATL needs to make it a UINT_PTR param)
            wnd.SetMenu(hMenu);

            wnd.ShowWindow(nCmdShow);
            wnd.UpdateWindow();

            MSG msg;
            while (GetMessage(&msg, NULL, 0, 0) > 0)
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            nResult = (int)msg.wParam;
        }

        DestroyMenu(hMenu);
    }

    _Module.Term();
    CoUninitialize();

    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\autodial.cpp ===
/*****************************************************************/
/**               Microsoft Windows                             **/
/**           Copyright (C) Microsoft Corp., 1995               **/
/*****************************************************************/

//
//  AUTODIAL.CPP - winsock autodial hook code
//

//  HISTORY:
//
//  3/22/95 jeremys     Created.
//  4/11/97 darrenmi    Moved functionality to wininet. Only stubs remain.
//

#include "project.hpp"
#include <wininet.h>

/*******************************************************************

    The following stubs are retained for compatibility.  This 
    functionality has been moved to wininet.

********************************************************************/

INTSHCUTAPI BOOL WINAPI InetIsOffline(DWORD dwFlags)
{
    DWORD   dwState = 0, dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;

    if(InternetQueryOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState,
        &dwSize))
    {
        if(dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }

    return fRet;
}

INTSHCUTAPI STDAPI_(BOOL) WINAPI SetInetOffline(BOOL fOffline)
{
    INTERNET_CONNECTED_INFO ci;

    memset(&ci, 0, sizeof(ci));
    if(fOffline) {
        ci.dwConnectedState = INTERNET_STATE_DISCONNECTED_BY_USER;
        ci.dwFlags = ISO_FORCE_DISCONNECTED;
    } else {
        ci.dwConnectedState = INTERNET_STATE_CONNECTED;
    }

    InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));

    return fOffline;
}

// forward this call to wininet.  Toast once appropriate registry entries
// are set.
extern "C" void AutodialHookCallback(DWORD dwOpCode, LPCVOID lpParam);
extern "C" void InternetAutodialCallback(DWORD dwOpCode, LPCVOID lpParam);

void AutodialHookCallback(DWORD dwOpCode,LPCVOID lpParam)
{
    InternetAutodialCallback(dwOpCode, lpParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\clsfact.cpp ===
/*
 * clsfact.cpp - IClassFactory implementation.
 */


/* Headers
 **********/

#include "project.hpp"
#pragma hdrstop

#include "clsfact.h"
#include "ftps.hpp"
#include "inetcpl.h"
#include "inetps.hpp"


/* Types
 ********/

// callback function used by ClassFactory::ClassFactory()

typedef PIUnknown (*NEWOBJECTPROC)(OBJECTDESTROYEDPROC);
DECLARE_STANDARD_TYPES(NEWOBJECTPROC);

// description of class supported by DllGetClassObject()

typedef struct classconstructor
{
   PCCLSID pcclsid;

   NEWOBJECTPROC NewObject;
}
CLASSCONSTRUCTOR;
DECLARE_STANDARD_TYPES(CLASSCONSTRUCTOR);


/* Classes
 **********/

// object class factory

class ClassFactory : public RefCount,
                     public IClassFactory
{
private:
   NEWOBJECTPROC m_NewObject;

public:
   ClassFactory(NEWOBJECTPROC NewObject, OBJECTDESTROYEDPROC ObjectDestroyed);
   ~ClassFactory(void);

   // IClassFactory methods

   HRESULT STDMETHODCALLTYPE CreateInstance(PIUnknown piunkOuter, REFIID riid, PVOID *ppvObject);
   HRESULT STDMETHODCALLTYPE LockServer(BOOL bLock);

   // IUnknown methods

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);
   HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);

   // friends

#ifdef DEBUG

   friend BOOL IsValidPCClassFactory(const ClassFactory *pcurlcf);

#endif

};
DECLARE_STANDARD_TYPES(ClassFactory);


/* Module Prototypes
 ********************/

PRIVATE_CODE PIUnknown NewInternetShortcut(OBJECTDESTROYEDPROC ObjectDestroyed);
PRIVATE_CODE PIUnknown NewMIMEHook(OBJECTDESTROYEDPROC ObjectDestroyed);
PRIVATE_CODE PIUnknown NewInternet(OBJECTDESTROYEDPROC ObjectDestroyed);


/* Module Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

PRIVATE_DATA CCLASSCONSTRUCTOR s_cclscnstr[] =
{
   { &CLSID_InternetShortcut,             &NewInternetShortcut },
   { &CLSID_MIMEFileTypesPropSheetHook,   &NewMIMEHook },
   { &CLSID_Internet,                     &NewInternet },
};

#pragma data_seg()


/* Module Variables
 *******************/

#pragma data_seg(DATA_SEG_PER_INSTANCE)

// DLL reference count == number of class factories +
//                        number of URLs +
//                        LockServer() count

PRIVATE_DATA ULONG s_ulcDLLRef   = 0;

#pragma data_seg()


/***************************** Private Functions *****************************/


PRIVATE_CODE HRESULT GetClassConstructor(REFCLSID rclsid,
                                         PNEWOBJECTPROC pNewObject)
{
   HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;
   UINT u;

   ASSERT(IsValidREFCLSID(rclsid));
   ASSERT(IS_VALID_WRITE_PTR(pNewObject, NEWOBJECTPROC));

   *pNewObject = NULL;

   for (u = 0; u < ARRAY_ELEMENTS(s_cclscnstr); u++)
   {
      if (rclsid == *(s_cclscnstr[u].pcclsid))
      {
         *pNewObject = s_cclscnstr[u].NewObject;
         hr = S_OK;
      }
   }

   ASSERT((hr == S_OK &&
           IS_VALID_CODE_PTR(*pNewObject, NEWOBJECTPROC)) ||
          (hr == CLASS_E_CLASSNOTAVAILABLE &&
           ! *pNewObject));

   return(hr);
}


PRIVATE_CODE void STDMETHODCALLTYPE DLLObjectDestroyed(void)
{
   TRACE_OUT(("DLLObjectDestroyed(): Object destroyed."));

   DLLRelease();
}


PRIVATE_CODE PIUnknown NewInternetShortcut(OBJECTDESTROYEDPROC ObjectDestroyed)
{
   ASSERT(! ObjectDestroyed ||
          IS_VALID_CODE_PTR(ObjectDestroyed, OBJECTDESTROYEDPROC));

   TRACE_OUT(("NewInternetShortcut(): Creating a new InternetShortcut."));

   return((PIUnknown)(PIUniformResourceLocator)new(InternetShortcut(ObjectDestroyed)));
}


PRIVATE_CODE PIUnknown NewMIMEHook(OBJECTDESTROYEDPROC ObjectDestroyed)
{
   ASSERT(! ObjectDestroyed ||
          IS_VALID_CODE_PTR(ObjectDestroyed, OBJECTDESTROYEDPROC));

   TRACE_OUT(("NewMIMEHook(): Creating a new MIMEHook."));

   return((PIUnknown)(PIShellPropSheetExt)new(MIMEHook(ObjectDestroyed)));
}


PRIVATE_CODE PIUnknown NewInternet(OBJECTDESTROYEDPROC ObjectDestroyed)
{
   ASSERT(! ObjectDestroyed ||
          IS_VALID_CODE_PTR(ObjectDestroyed, OBJECTDESTROYEDPROC));

   TRACE_OUT(("NewInternet(): Creating a new Internet."));

   return((PIUnknown)(PIShellPropSheetExt)new(Internet(ObjectDestroyed)));
}


#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCClassFactory(PCClassFactory pccf)
{
   return(IS_VALID_READ_PTR(pccf, CClassFactory) &&
          IS_VALID_CODE_PTR(pccf->m_NewObject, NEWOBJECTPROC) &&
          IS_VALID_STRUCT_PTR((PCRefCount)pccf, CRefCount) &&
          IS_VALID_INTERFACE_PTR((PCIClassFactory)pccf, IClassFactory));
}

#endif


/****************************** Public Functions *****************************/


PUBLIC_CODE ULONG DLLAddRef(void)
{
   ULONG ulcRef;

   ASSERT(s_ulcDLLRef < ULONG_MAX);

   ulcRef = ++s_ulcDLLRef;

   TRACE_OUT(("DLLAddRef(): DLL reference count is now %lu.",
              ulcRef));

   return(ulcRef);
}


PUBLIC_CODE ULONG DLLRelease(void)
{
   ULONG ulcRef;

   if (EVAL(s_ulcDLLRef > 0))
      s_ulcDLLRef--;

   ulcRef = s_ulcDLLRef;

   TRACE_OUT(("DLLRelease(): DLL reference count is now %lu.",
              ulcRef));

   return(ulcRef);
}


PUBLIC_CODE PULONG GetDLLRefCountPtr(void)
{
   return(&s_ulcDLLRef);
}


/********************************** Methods **********************************/


ClassFactory::ClassFactory(NEWOBJECTPROC NewObject,
                           OBJECTDESTROYEDPROC ObjectDestroyed) :
   RefCount(ObjectDestroyed)
{
   DebugEntry(ClassFactory::ClassFactory);

   // Don't validate this until after construction.

   ASSERT(IS_VALID_CODE_PTR(NewObject, NEWOBJECTPROC));

   m_NewObject = NewObject;

   ASSERT(IS_VALID_STRUCT_PTR(this, CClassFactory));

   DebugExitVOID(ClassFactory::ClassFactory);

   return;
}


ClassFactory::~ClassFactory(void)
{
   DebugEntry(ClassFactory::~ClassFactory);

   ASSERT(IS_VALID_STRUCT_PTR(this, CClassFactory));

   m_NewObject = NULL;

   // Don't validate this after destruction.

   DebugExitVOID(ClassFactory::~ClassFactory);

   return;
}


ULONG STDMETHODCALLTYPE ClassFactory::AddRef(void)
{
   ULONG ulcRef;

   DebugEntry(ClassFactory::AddRef);

   ASSERT(IS_VALID_STRUCT_PTR(this, CClassFactory));

   ulcRef = RefCount::AddRef();

   ASSERT(IS_VALID_STRUCT_PTR(this, CClassFactory));

   DebugExitULONG(ClassFactory::AddRef, ulcRef);

   return(ulcRef);
}


ULONG STDMETHODCALLTYPE ClassFactory::Release(void)
{
   ULONG ulcRef;

   DebugEntry(ClassFactory::Release);

   ASSERT(IS_VALID_STRUCT_PTR(this, CClassFactory));

   ulcRef = RefCount::Release();

   DebugExitULONG(ClassFactory::Release, ulcRef);

   return(ulcRef);
}


HRESULT STDMETHODCALLTYPE ClassFactory::QueryInterface(REFIID riid,
                                                       PVOID *ppvObject)
{
   HRESULT hr = S_OK;

   DebugEntry(ClassFactory::QueryInterface);

   ASSERT(IS_VALID_STRUCT_PTR(this, CClassFactory));
   ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   if (riid == IID_IClassFactory)
   {
      *ppvObject = (PIClassFactory)this;
      ASSERT(IS_VALID_INTERFACE_PTR((PIClassFactory)*ppvObject, IClassFactory));
      TRACE_OUT(("ClassFactory::QueryInterface(): Returning IClassFactory."));
   }
   else if (riid == IID_IUnknown)
   {
      *ppvObject = (PIUnknown)this;
      ASSERT(IS_VALID_INTERFACE_PTR((PIUnknown)*ppvObject, IUnknown));
      TRACE_OUT(("ClassFactory::QueryInterface(): Returning IUnknown."));
   }
   else
   {
      *ppvObject = NULL;
      hr = E_NOINTERFACE;
      TRACE_OUT(("ClassFactory::QueryInterface(): Called on unknown interface."));
   }

   if (hr == S_OK)
      AddRef();

   ASSERT(IS_VALID_STRUCT_PTR(this, CClassFactory));
   ASSERT(FAILED(hr) ||
          IS_VALID_INTERFACE_PTR(*ppvObject, INTERFACE));

   DebugExitHRESULT(ClassFactory::QueryInterface, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE ClassFactory::CreateInstance(PIUnknown piunkOuter,
                                                       REFIID riid,
                                                       PVOID *ppvObject)
{
   HRESULT hr;

   DebugEntry(ClassFactory::CreateInstance);

   ASSERT(IS_VALID_STRUCT_PTR(this, CClassFactory));
   ASSERT(! piunkOuter ||
          IS_VALID_INTERFACE_PTR(piunkOuter, IUnknown));
   ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   *ppvObject = NULL;

   if (! piunkOuter)
   {
      PIUnknown piunk;

      piunk = (*m_NewObject)(&DLLObjectDestroyed);

      if (piunk)
      {
         DLLAddRef();

         hr = piunk->QueryInterface(riid, ppvObject);

         // N.b., the Release() method will destroy the object if the
         // QueryInterface() method failed.

         piunk->Release();
      }
      else
         hr = E_OUTOFMEMORY;
   }
   else
   {
      hr = CLASS_E_NOAGGREGATION;
      WARNING_OUT(("ClassFactory::CreateInstance(): Aggregation not supported."));
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CClassFactory));
   ASSERT(FAILED(hr) ||
          IS_VALID_INTERFACE_PTR(*ppvObject, INTERFACE));

   DebugExitHRESULT(ClassFactory::CreateInstance, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE ClassFactory::LockServer(BOOL bLock)
{
   HRESULT hr;

   DebugEntry(ClassFactory::LockServer);

   ASSERT(IS_VALID_STRUCT_PTR(this, CClassFactory));

   // bLock may be any value.

   if (bLock)
      DLLAddRef();
   else
      DLLRelease();

   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CClassFactory));

   DebugExitHRESULT(ClassFactory::LockServer, hr);

   return(hr);
}


/***************************** Exported Functions ****************************/


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PVOID *ppvObject)
{
   HRESULT hr = S_OK;
   NEWOBJECTPROC NewObject;

   DebugEntry(DllGetClassObject);

   ASSERT(IsValidREFCLSID(rclsid));
   ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   *ppvObject = NULL;

   hr = GetClassConstructor(rclsid, &NewObject);

   if (hr == S_OK)
   {
      if (riid == IID_IUnknown ||
          riid == IID_IClassFactory)
      {
         PClassFactory pcf;

         pcf = new(ClassFactory(NewObject, &DLLObjectDestroyed));

         if (pcf)
         {
            if (riid == IID_IClassFactory)
            {
               *ppvObject = (PIClassFactory)pcf;
               ASSERT(IS_VALID_INTERFACE_PTR((PIClassFactory)*ppvObject, IClassFactory));
               TRACE_OUT(("DllGetClassObject(): Returning IClassFactory."));
            }
            else
            {
               ASSERT(riid == IID_IUnknown);
               *ppvObject = (PIUnknown)pcf;
               ASSERT(IS_VALID_INTERFACE_PTR((PIUnknown)*ppvObject, IUnknown));
               TRACE_OUT(("DllGetClassObject(): Returning IUnknown."));
            }

            DLLAddRef();
            hr = S_OK;

            TRACE_OUT(("DllGetClassObject(): Created a new class factory."));
         }
         else
            hr = E_OUTOFMEMORY;
      }
      else
      {
         WARNING_OUT(("DllGetClassObject(): Called on unknown interface."));
         hr = E_NOINTERFACE;
      }
   }
   else
      WARNING_OUT(("DllGetClassObject(): Called on unknown class."));

   ASSERT(FAILED(hr) ||
          IS_VALID_INTERFACE_PTR(*ppvObject, INTERFACE));

   DebugExitHRESULT(DllGetClassObject, hr);

   return(hr);
}


STDAPI DllCanUnloadNow(void)
{
   HRESULT hr;

   DebugEntry(DllCanUnloadNow);

   hr = (s_ulcDLLRef > 0) ? S_FALSE : S_OK;
    
    if (hr == S_OK) 
        hr = InternetCPLCanUnloadNow();

   TRACE_OUT(("DllCanUnloadNow(): DLL reference count is %lu.",
              s_ulcDLLRef));

   DebugExitHRESULT(DllCanUnloadNow, hr);

   return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\cfmacros.h ===
#ifndef _STATIC_CLASS_FACTORY_
#define _STATIC_CLASS_FACTORY_

/*
 * Class Factory Implementation for C++ without CTRStartup required.
 */

#ifdef __cplusplus

#ifdef UNIX

#define STDMETHODX  STDMETHOD
#define STDMETHODX_ STDMETHOD_

#define DECLARE_CLASS_FACTORY(cf)                                \
   class cf: public IClassFactory                                \
   {                                                             \
     public:                                                     \
       STDMETHODX (QueryInterface)(REFIID, void **);             \
       STDMETHODX_(ULONG, AddRef)();                             \
       STDMETHODX_(ULONG, Release)();                            \
                                                                 \
       STDMETHODX (CreateInstance)(IUnknown *, REFIID, void **); \
       STDMETHODX (LockServer)(BOOL);                            \
   }                                                             \


#else  // UNIX

#define STDMETHODX(fn)      HRESULT __stdcall fn
#define STDMETHODX_(ret,fn) ret __stdcall fn

#define DECLARE_CLASS_FACTORY(cf)                                \
   class cf                                                      \
   {                                                             \
     public:                                                     \
       void *vtable;                                             \
       STDMETHODX (QueryInterface)(REFIID, void **);             \
       STDMETHODX_(ULONG, AddRef)();                             \
       STDMETHODX_(ULONG, Release)();                            \
                                                                 \
       STDMETHODX (CreateInstance)(IUnknown *, REFIID, void **); \
       STDMETHODX (LockServer)(BOOL);                            \
   }                                                             \

#endif // UNIX


DECLARE_CLASS_FACTORY( CClassFactory );


struct IClassFactoryVtbl
{
      // *** IUnknown methods ***
      HRESULT (STDMETHODCALLTYPE CClassFactory::* QueryInterface) (
                                REFIID riid,
                                LPVOID FAR* ppvObj) ;
      ULONG (STDMETHODCALLTYPE CClassFactory::*AddRef) () ;
      ULONG (STDMETHODCALLTYPE CClassFactory::*Release) () ;

      // *** IClassFactory methods ***
      HRESULT (STDMETHODCALLTYPE CClassFactory::*CreateInstance) (
                                LPUNKNOWN pUnkOuter,
                                REFIID riid,
                                LPVOID FAR* ppvObject) ;
      HRESULT (STDMETHODCALLTYPE CClassFactory::*LockServer)(BOOL);
};

typedef struct IClassFactoryVtbl IClassFactoryVtbl;

//
// class CObjectInfo
//
typedef HRESULT (*LPFNCREATEINSTANCE)(IUnknown *punkOuter, REFIID riid, void **ppvOut);

class CObjectInfo : public CClassFactory                               
{                                                                      
public:                                                                
    CObjectInfo(CLSID const* pclsidin, LPFNCREATEINSTANCE pfnCreatein) 
    { pclsid = pclsidin; pfnCreate = pfnCreatein; }                    
    CLSID const* pclsid;                                               
    LPFNCREATEINSTANCE pfnCreate;                                      
};

const IClassFactoryVtbl c_CFVtbl = {
    CClassFactory::QueryInterface, 
    CClassFactory::AddRef,
    CClassFactory::Release,
    CClassFactory::CreateInstance,
    CClassFactory::LockServer
};

//
// CLASS FACTORY TABLE STUFF
//

typedef struct {
    const IClassFactoryVtbl *cf;
    const CLSID *rclsid;
    HRESULT (*pfnCreate)(IUnknown *, REFIID, void **);
} OBJ_ENTRY;


#ifdef UNIX

#define CF_TABLE_BEGIN(cfTable) const CObjectInfo cfTable[] = { 
#define CF_TABLE_ENTRY(pclsid, pfnCreate)  CObjectInfo( pclsid, pfnCreate),
#define CF_TABLE_END(cfTable)  \
    CF_TABLE_ENTRY(NULL, NULL) };

#define GET_ICLASSFACTORY(ptr) SAFECAST( ptr, IClassFactory *)

#else

#define CF_TABLE_BEGIN(cfTable) const OBJ_ENTRY cfTable##_tble[] = { 
#define CF_TABLE_ENTRY(pClsid, pfnCreate )   { &c_CFVtbl, pClsid, pfnCreate },
#define CF_TABLE_END(cfTable)  \
    CF_TABLE_ENTRY(NULL, NULL) }; \
    const CObjectInfo *cfTable = (CObjectInfo *)cfTable##_tble;

#define GET_ICLASSFACTORY(ptr) (&(ptr->vtable))

#endif


#endif // __cplusplus


#endif // _STATIC_CLASS_FACTORY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\comcpp.hpp ===
/*
 * comcpp.hpp - Common C++ functions description.
 */


/* Prototypes
 *************/

// comcpp.cpp

extern HRESULT MyReleaseStgMedium(PSTGMEDIUM pstgmed);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\clsfact.h ===
/*
 * clsfact.h - IClassFactory implementation.
 */


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Prototypes
 *************/

/* clsfact.cpp */

extern ULONG DLLAddRef(void);
extern ULONG DLLRelease(void);
extern PULONG GetDLLRefCountPtr(void);


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\comc.c ===
/*
 * comc.c - Shared routines.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "assoc.h"
#pragma warning(disable:4001) /* "single line comment" warning */
#include "filetype.h"
#pragma warning(default:4001) /* "single line comment" warning */


/* Global Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

PUBLIC_DATA const char g_cszWhiteSpace[]           = " \t";

PUBLIC_DATA const char g_cszSlashes[]              = "/\\";

PUBLIC_DATA const char g_cszPathSeparators[]       = ":/\\";

PUBLIC_DATA const char g_cszEditFlags[]            = "EditFlags";

#pragma data_seg()


/* Module Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

PRIVATE_DATA CCHAR s_cszMIMETypeSubKeyFmt[]        = "MIME\\Database\\Content Type\\%s";

PRIVATE_DATA CCHAR s_cszDefaultVerbSubKeyFmt[]     = "%s\\Shell";
PRIVATE_DATA CCHAR s_cszShellOpenCmdSubKey[]       = "Shell\\Open\\Command";

PRIVATE_DATA CCHAR s_cszContentType[]              = "Content Type";
PRIVATE_DATA CCHAR s_cszExtension[]                = "Extension";

PRIVATE_DATA const char s_cszAppCmdLineFmt[]       = " %s";
PRIVATE_DATA const char s_cszQuotesAppCmdLineFmt[] = " \"%s\"";

#pragma data_seg()


/***************************** Private Functions *****************************/


/*
** GetMIMETypeStringValue()
**
** Retrieves the string for a registered MIME type's value.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL GetMIMETypeStringValue(PCSTR pcszMIMEType, PCSTR pcszValue,
                                         PSTR pszBuf, UINT ucBufLen)
{
   BOOL bResult;
   DWORD dwValueType;
   DWORD dwcbLen = ucBufLen;

   /* GetMIMEValue() will verify parameters. */

   bResult = (GetMIMEValue(pcszMIMEType, pcszValue, &dwValueType,
                           (PBYTE)pszBuf, &dwcbLen) &&
              dwValueType == REG_SZ);

   if (! bResult)
   {
      if (ucBufLen > 0)
         *pszBuf = '\0';
   }

   ASSERT(! ucBufLen ||
          IS_VALID_STRING_PTR(pszBuf, STR));

   return(bResult);
}


/****************************** Public Functions *****************************/


PUBLIC_CODE BOOL DataCopy(PCBYTE pcbyteSrc, ULONG ulcbLen, PBYTE *ppbyteDest)
{
   BOOL bResult;

   ASSERT(IS_VALID_READ_BUFFER_PTR(pcbyteSrc, CBYTE, ulcbLen));
   ASSERT(IS_VALID_WRITE_PTR(ppbyteDest, PBYTE));

   bResult = AllocateMemory(ulcbLen, ppbyteDest);

   if (bResult)
      CopyMemory(*ppbyteDest, pcbyteSrc, ulcbLen);
   else
      *ppbyteDest = NULL;

   ASSERT((bResult &&
           IS_VALID_READ_BUFFER_PTR(*ppbyteDest, BYTE, ulcbLen)) ||
          (! bResult &&
           EVAL(! *ppbyteDest)));

   return(bResult);
}


PUBLIC_CODE BOOL StringCopy(PCSTR pcszSrc, PSTR *ppszCopy)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRING_PTR(pcszSrc, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszCopy, PSTR));

   /* (+ 1) for null terminator. */

   bResult = DataCopy((PCBYTE)pcszSrc, lstrlen(pcszSrc) + 1, (PBYTE *)ppszCopy);

   ASSERT(! bResult ||
          IS_VALID_STRING_PTR(*ppszCopy, STR));

   return(bResult);
}


/*
** GetMIMETypeSubKey()
**
** Generates the HKEY_CLASSES_ROOT subkey for a MIME type.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetMIMETypeSubKey(PCSTR pcszMIMEType,
                                          PSTR pszSubKeyBuf,
                                          UINT ucSubKeyBufLen)
{
   BOOL bResult;

   bResult = ((UINT)lstrlen(s_cszMIMETypeSubKeyFmt) +
              (UINT)lstrlen(pcszMIMEType) < ucSubKeyBufLen);

   if (bResult)
      EVAL((UINT)wsprintf(pszSubKeyBuf, s_cszMIMETypeSubKeyFmt,
                          pcszMIMEType) < ucSubKeyBufLen);
   else
   {
      if (ucSubKeyBufLen > 0)
         *pszSubKeyBuf = '\0';

      WARNING_OUT(("GetMIMETypeSubKey(): Given sub key buffer of length %u is too short to hold sub key for MIME type %s.",
                   ucSubKeyBufLen,
                   pcszMIMEType));
   }

   ASSERT(! ucSubKeyBufLen ||
          (IS_VALID_STRING_PTR(pszSubKeyBuf, STR) &&
           (UINT)lstrlen(pszSubKeyBuf) < ucSubKeyBufLen));
   ASSERT(bResult ||
          ! ucSubKeyBufLen ||
          ! *pszSubKeyBuf);

   return(bResult);
}


/*
** GetMIMEValue()
**
** Retrieves the data for a value of a MIME type.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetMIMEValue(PCSTR pcszMIMEType, PCSTR pcszValue,
                              PDWORD pdwValueType, PBYTE pbyteValueBuf,
                              PDWORD pdwcbValueBufLen)
{
   BOOL bResult;
   char szMIMETypeSubKey[MAX_PATH_LEN];

   ASSERT(IS_VALID_STRING_PTR(pcszMIMEType, CSTR));
   ASSERT(! pcszValue ||
          IS_VALID_STRING_PTR(pcszValue, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pdwValueType, DWORD));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pbyteValueBuf, BYTE, *pdwcbValueBufLen));

   bResult = (GetMIMETypeSubKey(pcszMIMEType, szMIMETypeSubKey,
                                       sizeof(szMIMETypeSubKey)) &&
              GetRegKeyValue(HKEY_CLASSES_ROOT, szMIMETypeSubKey,
                             pcszValue, pdwValueType, pbyteValueBuf,
                             pdwcbValueBufLen) == ERROR_SUCCESS);

   return(bResult);
}


/*
** GetFileTypeValue()
**
** Retrieves the data for a value of the file class associated with an
** extension.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetFileTypeValue(PCSTR pcszExtension, PCSTR pcszSubKey,
                                  PCSTR pcszValue, PDWORD pdwValueType,
                                  PBYTE pbyteValueBuf, PDWORD pdwcbValueBufLen)
{
   BOOL bResult = FALSE;

   ASSERT(IsValidExtension(pcszExtension));
   ASSERT(! pcszSubKey ||
          IS_VALID_STRING_PTR(pcszSubKey, CSTR));
   ASSERT(! pcszValue ||
          IS_VALID_STRING_PTR(pcszValue, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pdwValueType, DWORD));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pbyteValueBuf, BYTE, *pdwcbValueBufLen));

   if (EVAL(*pcszExtension))
   {
      char szSubKey[MAX_PATH_LEN];
      DWORD dwcbLen = sizeof(szSubKey);

      /* Get extension's file type. */

      if (GetDefaultRegKeyValue(HKEY_CLASSES_ROOT, pcszExtension, szSubKey,
                                &dwcbLen) == ERROR_SUCCESS &&
          *szSubKey)
      {
         /* Any sub key to append? */

         if (pcszSubKey)
         {
            /* Yes. */

            /* (+ 1) for possible key separator. */

            bResult = EVAL(lstrlen(szSubKey) + 1 + lstrlen(pcszSubKey)
                           < sizeof(szSubKey));

            if (bResult)
            {
               CatPath(szSubKey, pcszSubKey);
               ASSERT(lstrlen(szSubKey) < sizeof(szSubKey));
            }
         }
         else
            /* No. */
            bResult = TRUE;

         if (bResult)
            /* Get file type's value string. */
            bResult = (GetRegKeyValue(HKEY_CLASSES_ROOT, szSubKey, pcszValue,
                                      pdwValueType, pbyteValueBuf,
                                      pdwcbValueBufLen) == ERROR_SUCCESS);
      }
      else
         TRACE_OUT(("GetFileTypeValue(): No file type registered for extension %s.",
                    pcszExtension));
   }
   else
      WARNING_OUT(("GetFileTypeValue(): No extension given."));

   return(bResult);
}


/*
** GetMIMEFileTypeValue()
**
** Retrieves the data for a value of the file class associated with a MIME
** type.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetMIMEFileTypeValue(PCSTR pcszMIMEType, PCSTR pcszSubKey,
                                      PCSTR pcszValue, PDWORD pdwValueType,
                                      PBYTE pbyteValueBuf,
                                      PDWORD pdwcbValueBufLen)
{
   BOOL bResult;
   char szExtension[MAX_PATH_LEN];

   ASSERT(IS_VALID_STRING_PTR(pcszMIMEType, CSTR));
   ASSERT(! pcszSubKey ||
          IS_VALID_STRING_PTR(pcszSubKey, CSTR));
   ASSERT(! pcszValue ||
          IS_VALID_STRING_PTR(pcszValue, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pdwValueType, DWORD));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pbyteValueBuf, BYTE, *pdwcbValueBufLen));

   /* Get file name extension associated with MIME type. */

   if (MIME_GetExtension(pcszMIMEType, szExtension, sizeof(szExtension)))
      bResult = GetFileTypeValue(szExtension, pcszSubKey, pcszValue, pdwValueType,
                                 pbyteValueBuf, pdwcbValueBufLen);
   else
   {
      bResult = FALSE;

      TRACE_OUT(("GetMIMEFileTypeValue(): No extension registered for MIME type %s.",
                 pcszMIMEType));
   }

   return(bResult);
}


/*
** MIME_IsExternalHandlerRegistered()
**
** Determines whether or not an external handler is registered for a MIME type.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL MIME_IsExternalHandlerRegistered(PCSTR pcszMIMEType)
{
   BOOL bResult;
   DWORD dwValueType;
   char szOpenCmd[MAX_PATH_LEN];
   DWORD dwcbOpenCmdLen = sizeof(szOpenCmd);

   /* GetMIMEFileTypeValue() will verify parameters. */

   /* Look up the open command of the MIME type's associated file type. */

   bResult = (GetMIMEFileTypeValue(pcszMIMEType, s_cszShellOpenCmdSubKey,
                                   NULL, &dwValueType, (PBYTE)szOpenCmd,
                                   &dwcbOpenCmdLen) &&
              dwValueType == REG_SZ);

   TRACE_OUT(("MIME_IsExternalHandlerRegistered(): %s external handler is registered for MIME type %s.",
              bResult ? "An" : "No",
              pcszMIMEType));

   return(bResult);
}


/*
** MIME_GetExtension()
**
** Determines the file name extension to be used when writing a file of a MIME
** type to the file system.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL MIME_GetExtension(PCSTR pcszMIMEType, PSTR pszExtensionBuf,
                                   UINT ucExtensionBufLen)
{
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_STRING_PTR(pcszMIMEType, CSTR));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszExtensionBuf, STR, ucExtensionBufLen));

   if (EVAL(ucExtensionBufLen > 2))
   {
      /* Leave room for possible leading period. */

      if (GetMIMETypeStringValue(pcszMIMEType, s_cszExtension,
                                 pszExtensionBuf + 1, ucExtensionBufLen - 1))
      {
         if (pszExtensionBuf[1])
         {
            /* Prepend period if necessary. */

            if (pszExtensionBuf[1] == PERIOD)
               /* (+ 1) for null terminator. */
               MoveMemory(pszExtensionBuf, pszExtensionBuf + 1,
                          lstrlen(pszExtensionBuf + 1) + 1);
            else
               pszExtensionBuf[0] = PERIOD;

            bResult = TRUE;
         }
      }
   }

   if (! bResult)
   {
      if (ucExtensionBufLen > 0)
         *pszExtensionBuf = '\0';
   }

   if (bResult)
      TRACE_OUT(("MIME_GetExtension(): Extension %s registered as default extension for MIME type %s.",
                 pszExtensionBuf,
                 pcszMIMEType));
   else
      TRACE_OUT(("MIME_GetExtension(): No default extension registered for MIME type %s.",
                 pcszMIMEType));

   ASSERT((bResult &&
           IsValidExtension(pszExtensionBuf)) ||
          (! bResult &&
           (! ucExtensionBufLen ||
            ! *pszExtensionBuf)));
   ASSERT(! ucExtensionBufLen ||
          (UINT)lstrlen(pszExtensionBuf) < ucExtensionBufLen);

   return(bResult);
}


/*
** MIME_GetMIMETypeFromExtension()
**
** Determines the MIME type associated with a file extension.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL MIME_GetMIMETypeFromExtension(PCSTR pcszPath,
                                                      PSTR pszMIMETypeBuf,
                                                      UINT ucMIMETypeBufLen)
{
   BOOL bResult;
   PCSTR pcszExtension;

   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszMIMETypeBuf, STR, ucMIMETypeBufLen));

   pcszExtension = ExtractExtension(pcszPath);

   if (*pcszExtension)
   {
      DWORD dwcLen = ucMIMETypeBufLen;

      bResult = (GetRegKeyStringValue(HKEY_CLASSES_ROOT, pcszExtension,
                                      s_cszContentType, pszMIMETypeBuf,
                                      &dwcLen) == ERROR_SUCCESS);

      if (bResult)
         TRACE_OUT(("MIME_GetMIMETypeFromExtension(): MIME type for extension %s is %s.",

                    pcszExtension,
                    pszMIMETypeBuf));
      else
         TRACE_OUT(("MIME_GetMIMETypeFromExtension(): No MIME type registered for extension %s.",
                    pcszExtension));
   }
   else
   {
      bResult = FALSE;

      TRACE_OUT(("MIME_GetMIMETypeFromExtension(): No extension in path %s.",
                 pcszPath));
   }

   if (! bResult)
   {
      if (ucMIMETypeBufLen > 0)
         *pszMIMETypeBuf = '\0';
   }

   ASSERT(! ucMIMETypeBufLen ||
          (IS_VALID_STRING_PTR(pszMIMETypeBuf, STR) &&
           (UINT)lstrlen(pszMIMETypeBuf) < ucMIMETypeBufLen));
   ASSERT(bResult ||
          ! ucMIMETypeBufLen ||
          ! *pszMIMETypeBuf);

   return(bResult);
}


/*
** CatPath()
**
** Appends a filename to a path string.
**
** Arguments:     pszPath - path string that file name is to be appended to
**                pcszSubPath - path to append
**
** Returns:       void
**
** Side Effects:  none
**
** N.b., truncates path to MAX_PATH_LEN characters in length.
**
** Examples:
**
**    input path        input file name      output path
**    ----------        ---------------      -----------
**    c:\               foo                  c:\foo
**    c:                foo                  c:foo
**    c:\foo\bar\       goo                  c:\foo\bar\goo
**    c:\foo\bar\       \goo                 c:\foo\bar\goo
**    c:\foo\bar\       goo\shoe             c:\foo\bar\goo\shoe
**    c:\foo\bar\       \goo\shoe\           c:\foo\bar\goo\shoe\
**    foo\bar\          goo                  foo\bar\goo
**    <empty string>    <empty string>       <empty string>
**    <empty string>    foo                  foo
**    foo               <empty string>       foo
**    fred              bird                 fred\bird
*/
PUBLIC_CODE void CatPath(PSTR pszPath, PCSTR pcszSubPath)
{
   PSTR pcsz;
   PSTR pcszLast;

   ASSERT(IS_VALID_STRING_PTR(pszPath, STR));
   ASSERT(IS_VALID_STRING_PTR(pcszSubPath, CSTR));
   /* (+ 1) for possible separator. */
   /* (+ 1) for null terminator. */
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszPath, STR, lstrlen(pszPath) + 1 + lstrlen(pcszSubPath) + 1));

   /* Find last character in path string. */

   for (pcsz = pcszLast = pszPath; *pcsz; pcsz = CharNext(pcsz))
      pcszLast = pcsz;

   if (IS_SLASH(*pcszLast) && IS_SLASH(*pcszSubPath))
      pcszSubPath++;
   else if (! IS_SLASH(*pcszLast) && ! IS_SLASH(*pcszSubPath))
   {
      if (*pcszLast && *pcszLast != COLON && *pcszSubPath)
         *pcsz++ = '\\';
   }

   lstrcpy(pcsz, pcszSubPath);

   ASSERT(IS_VALID_STRING_PTR(pszPath, STR));

   return;
}


/*
** MyLStrCpyN()
**
** Like lstrcpy(), but the copy is limited to ucb bytes.  The destination
** string is always null-terminated.
**
** Arguments:     pszDest - pointer to destination buffer
**                pcszSrc - pointer to source string
**                ncb - maximum number of bytes to copy, including null
**                      terminator
**
** Returns:       void
**
** Side Effects:  none
**
** N.b., this function behaves quite differently than strncpy()!  It does not
** pad out the destination buffer with null characters, and it always null
** terminates the destination string.
*/
PUBLIC_CODE void MyLStrCpyN(PSTR pszDest, PCSTR pcszSrc, int ncb)
{
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszDest, STR, ncb));
   ASSERT(IS_VALID_STRING_PTR(pcszSrc, CSTR));
   ASSERT(ncb > 0);

   while (ncb > 1)
   {
      ncb--;

      *pszDest = *pcszSrc;

      if (*pcszSrc)
      {
         pszDest++;
         pcszSrc++;
      }
      else
         break;
   }

   if (ncb == 1)
      *pszDest = '\0';

   ASSERT(IS_VALID_STRING_PTR(pszDest, STR));
   ASSERT(lstrlen(pszDest) < ncb);
   ASSERT(lstrlen(pszDest) <= lstrlen(pcszSrc));

   return;
}


PUBLIC_CODE COMPARISONRESULT MapIntToComparisonResult(int nResult)
{
   COMPARISONRESULT cr;

   /* Any integer is valid input. */

   if (nResult < 0)
      cr = CR_FIRST_SMALLER;
   else if (nResult > 0)
      cr = CR_FIRST_LARGER;
   else
      cr = CR_EQUAL;

   return(cr);
}


/*
** TrimWhiteSpace()
**
** Trims leading and trailing white space from a string in place.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void TrimWhiteSpace(PSTR pszTrimMe)
{
   ASSERT(IS_VALID_STRING_PTR(pszTrimMe, STR));

   TrimString(pszTrimMe, g_cszWhiteSpace);

   /* TrimString() validates pszTrimMe on output. */

   return;
}


/*
** TrimSlashes()
**
** Trims leading and trailing slashes from a string in place.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void TrimSlashes(PSTR pszTrimMe)
{
   ASSERT(IS_VALID_STRING_PTR(pszTrimMe, STR));

   TrimString(pszTrimMe, g_cszSlashes);

   /* TrimString() validates pszTrimMe on output. */

   return;
}


PUBLIC_CODE void TrimString(PSTR pszTrimMe, PCSTR pszTrimChars)
{
   PSTR psz;
   PSTR pszStartMeat;

   ASSERT(IS_VALID_STRING_PTR(pszTrimMe, STR));
   ASSERT(IS_VALID_STRING_PTR(pszTrimChars, CSTR));

   if ( !pszTrimMe )
      return;

   /* Trim leading characters. */

   psz = pszTrimMe;

   while (*psz && strchr(pszTrimChars, *psz))
      psz = CharNext(psz);

   pszStartMeat = psz;

   /* Trim trailing characters. */

   if (*psz)
   {
      psz += lstrlen(psz);

      psz = CharPrev(pszStartMeat, psz);

      if (psz > pszStartMeat)
      {
         while (strchr(pszTrimChars, *psz))
            psz = CharPrev(pszStartMeat, psz);

         psz = CharNext(psz);

         ASSERT(psz > pszStartMeat);

         *psz = '\0';
      }
   }

   /* Relocate stripped string. */

   if (pszStartMeat > pszTrimMe)
      /* (+ 1) for null terminator. */
      MoveMemory(pszTrimMe, pszStartMeat, lstrlen(pszStartMeat) + 1);
   else
      ASSERT(pszStartMeat == pszTrimMe);

   ASSERT(IS_VALID_STRING_PTR(pszTrimMe, STR));

   return;
}


/*
** ExtractFileName()
**
** Extracts the file name from a path name.
**
** Arguments:     pcszPathName - path string from which to extract file name
**
** Returns:       Pointer to file name in path string.
**
** Side Effects:  none
*/
PUBLIC_CODE PCSTR ExtractFileName(PCSTR pcszPathName)
{
   PCSTR pcszLastComponent;
   PCSTR pcsz;

   ASSERT(IS_VALID_STRING_PTR(pcszPathName, CSTR));

   for (pcszLastComponent = pcsz = pcszPathName;
        *pcsz;
        pcsz = CharNext(pcsz))
   {
      if (IS_SLASH(*pcsz) || *pcsz == COLON)
         pcszLastComponent = CharNext(pcsz);
   }

   ASSERT(IsValidPath(pcszLastComponent));

   return(pcszLastComponent);
}


/*
** ExtractExtension()
**
** Extracts the extension from a name.
**
** Arguments:     pcszName - name whose extension is to be extracted
**
** Returns:       If the name contains an extension, a pointer to the period at
**                the beginning of the extension is returned.  If the name has
**                no extension, a pointer to the name's null terminator is
**                returned.
**
** Side Effects:  none
*/
PUBLIC_CODE PCSTR ExtractExtension(PCSTR pcszName)
{
   PCSTR pcszLastPeriod;

   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));

   /* Make sure we have an isolated file name. */

   pcszName = ExtractFileName(pcszName);

   pcszLastPeriod = NULL;

   while (*pcszName)
   {
      if (*pcszName == PERIOD)
         pcszLastPeriod = pcszName;

      pcszName = CharNext(pcszName);
   }

   if (! pcszLastPeriod)
   {
      /* Point at null terminator. */

      pcszLastPeriod = pcszName;
      ASSERT(! *pcszLastPeriod);
   }
   else
      /* Point at period at beginning of extension. */
      ASSERT(*pcszLastPeriod == PERIOD);

   ASSERT(! *pcszLastPeriod ||
          IsValidExtension(pcszLastPeriod));

   return(pcszLastPeriod);
}


/*
** SetRegKeyValue()
**
** Sets the data associated with a registry key's value.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE LONG    SetRegKeyValue(HKEY hkeyParent, PCSTR pcszSubKey,
                                   PCSTR pcszValue, DWORD dwType,
                                   PCBYTE pcbyte, DWORD dwcb)
{
   LONG lResult;
   HKEY hkeySubKey;

   ASSERT(IS_VALID_HANDLE(hkeyParent, KEY));
   ASSERT(IS_VALID_STRING_PTR(pcszSubKey, CSTR));
   ASSERT(IsValidRegistryValueType(dwType));
   ASSERT(! pcszValue ||
          IS_VALID_STRING_PTR(pcszValue, CSTR));
   ASSERT(IS_VALID_READ_BUFFER_PTR(pcbyte, CBYTE, dwcb));

   lResult = RegCreateKeyEx(hkeyParent, pcszSubKey, 0, NULL, 0, KEY_SET_VALUE,
                            NULL, &hkeySubKey, NULL);

   if (lResult == ERROR_SUCCESS)
   {
      LONG lResultClose;

      lResult = RegSetValueEx(hkeySubKey, pcszValue, 0, dwType, pcbyte, dwcb);

      lResultClose = RegCloseKey(hkeySubKey);

      if (lResult == ERROR_SUCCESS)
         lResult = lResultClose;
   }

   return(lResult);
}


/*
** GetRegKeyValue()
**
** Retrieves the data from a registry key's value.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE LONG    GetRegKeyValue(HKEY hkeyParent, PCSTR pcszSubKey,
                                   PCSTR pcszValue, PDWORD pdwValueType,
                                   PBYTE pbyteBuf, PDWORD pdwcbBufLen)
{
   LONG lResult;
   HKEY hkeySubKey;

   ASSERT(IS_VALID_HANDLE(hkeyParent, KEY));
   ASSERT(! pcszSubKey ||
          IS_VALID_STRING_PTR(pcszSubKey, CSTR));
   ASSERT(! pcszValue ||
          IS_VALID_STRING_PTR(pcszValue, CSTR));
   ASSERT(! pdwValueType ||
          IS_VALID_WRITE_PTR(pdwValueType, DWORD));
   ASSERT(! pbyteBuf ||
          IS_VALID_WRITE_BUFFER_PTR(pbyteBuf, BYTE, *pdwcbBufLen));

   lResult = RegOpenKeyEx(hkeyParent, pcszSubKey, 0, KEY_QUERY_VALUE,
                          &hkeySubKey);

   if (lResult == ERROR_SUCCESS)
   {
      LONG lResultClose;

      lResult = RegQueryValueEx(hkeySubKey, pcszValue, NULL, pdwValueType,
                                pbyteBuf, pdwcbBufLen);

      lResultClose = RegCloseKey(hkeySubKey);

      if (lResult == ERROR_SUCCESS)
         lResult = lResultClose;
   }

   return(lResult);
}


/*
** GetRegKeyStringValue()
**
** Retrieves the data from a registry key's string value.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE LONG    GetRegKeyStringValue(HKEY hkeyParent, PCSTR pcszSubKey,
                                         PCSTR pcszValue, PSTR pszBuf,
                                         PDWORD pdwcbBufLen)
{
   LONG lResult;
   DWORD dwValueType;

   /* GetRegKeyValue() will verify the parameters. */

   lResult = GetRegKeyValue(hkeyParent, pcszSubKey, pcszValue, &dwValueType,
                            (PBYTE)pszBuf, pdwcbBufLen);

   if (lResult == ERROR_SUCCESS &&
       dwValueType != REG_SZ)
      lResult = ERROR_CANTREAD;

   return(lResult);
}


/*
** GetDefaultRegKeyValue()
**
** Retrieves the data from a registry key's default string value.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE LONG    GetDefaultRegKeyValue(HKEY hkeyParent, PCSTR pcszSubKey,
                                          PSTR pszBuf, PDWORD pdwcbBufLen)
{
   /* GetRegKeyStringValue() will verify the parameters. */

   return(GetRegKeyStringValue(hkeyParent, pcszSubKey, NULL, pszBuf,
                               pdwcbBufLen));
}


/*
** FullyQualifyPath()
**
** Fully qualifies a path.
**
** Arguments:
**
** Returns:       S_OK
**
**                E_FILE_NOT_FOUND
**
** Side Effects:  none
*/
PUBLIC_CODE HRESULT FullyQualifyPath(PCSTR pcszPath,
                                     PSTR pszFullyQualifiedPath,
                                     UINT ucFullyQualifiedPathBufLen)
{
   HRESULT hr = E_FILE_NOT_FOUND;
   PSTR pszFileName;

   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));

   /* Any path separators? */

   if (! strpbrk(pcszPath, g_cszPathSeparators))
   {
      /* No.  Search for file. */

      TRACE_OUT(("FullyQualifyPath(): Searching PATH for %s.",
                 pcszPath));

      if (SearchPath(NULL, pcszPath, NULL, ucFullyQualifiedPathBufLen,
                     pszFullyQualifiedPath, &pszFileName) > 0)
         hr = S_OK;
      else
         TRACE_OUT(("FullyQualifyPath(): %s not found on PATH.",
                    pcszPath));
   }

   if (hr != S_OK &&
       GetFullPathName(pcszPath, ucFullyQualifiedPathBufLen,
                       pszFullyQualifiedPath, &pszFileName) > 0)
      hr = S_OK;

   if (hr == S_OK)
      TRACE_OUT(("FullyQualifyPath(): %s qualified as %s.",
                 pcszPath,
                 pszFullyQualifiedPath));
   else
   {
      if (ucFullyQualifiedPathBufLen > 0)
         pszFullyQualifiedPath = '\0';

      WARNING_OUT(("FullyQualifyPath(): Failed to qualify %s.",
                   pcszPath));
   }

   ASSERT((hr == S_OK &&
           EVAL(IsFullPath(pszFullyQualifiedPath))) ||
          (hr == E_FILE_NOT_FOUND &&
           (! ucFullyQualifiedPathBufLen ||
            ! *pszFullyQualifiedPath)));

   return(hr);
}


/*
** MyExecute()
**
** Calls CreateProcess() politely.
**
** Arguments:
**
** Returns:       S_OK
**
**                E_FAIL
**                E_FILE_NOT_FOUND
**                E_OUTOFMEMORY
**
** Side Effects:  none
*/
PUBLIC_CODE HRESULT MyExecute(PCSTR pcszApp, PCSTR pcszArgs, DWORD dwInFlags)
{
   HRESULT hr;
   char szFullApp[MAX_PATH_LEN];

   ASSERT(IS_VALID_STRING_PTR(pcszApp, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszArgs, CSTR));
   ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_ME_IN_FLAGS));

   hr = FullyQualifyPath(pcszApp, szFullApp, sizeof(szFullApp));

   if (hr == S_OK)
   {
      DWORD dwcbCmdLineLen;
      PSTR pszCmdLine;

      /* (+ 1) for null terminator. */
      dwcbCmdLineLen = max(sizeof(s_cszAppCmdLineFmt),
                           sizeof(s_cszQuotesAppCmdLineFmt)) +
                       + lstrlen(pcszArgs) + 1;

      if (AllocateMemory(dwcbCmdLineLen * sizeof(*pszCmdLine), &pszCmdLine))
      {
         PCSTR pcszFmt;
         STARTUPINFO si;
         PROCESS_INFORMATION pi;

         /* Execute URL via one-shot app. */

         pcszFmt = (IS_FLAG_SET(dwInFlags, ME_IFL_QUOTE_ARGS) &&
                    strpbrk(pcszArgs, g_cszWhiteSpace) != NULL)
                    ? s_cszQuotesAppCmdLineFmt : s_cszAppCmdLineFmt;

         EVAL((DWORD)wsprintf(pszCmdLine, pcszFmt, pcszArgs)
              < dwcbCmdLineLen);

         ZeroMemory(&si, sizeof(si));
         si.cb = sizeof(si);

         /* Specify command line exactly as given to app. */

         if (CreateProcess(szFullApp, pszCmdLine, NULL, NULL, FALSE, 0, NULL, NULL,
                           &si, &pi))
         {
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);

            hr = S_OK;

            TRACE_OUT(("MyExecute(): CreateProcess() \"%s %s\" succeeded.",
                       szFullApp, pszCmdLine));
         }
         else
         {
            hr = E_FAIL;

            WARNING_OUT(("MyExecute(): CreateProcess() \"%s %s\" failed.",
                         szFullApp, pszCmdLine));
         }

         FreeMemory(pszCmdLine);
         pszCmdLine = NULL;
      }
      else
         hr = E_OUTOFMEMORY;
   }
   else
      WARNING_OUT(("MyExecute(): Unable to find app %s.",
                   pcszApp));

   return(hr);
}


PUBLIC_CODE BOOL GetClassDefaultVerb(PCSTR pcszClass, PSTR pszDefaultVerbBuf,
                                     UINT ucDefaultVerbBufLen)
{
   BOOL bResult;
   char szDefaultVerbSubKey[MAX_PATH_LEN];

   ASSERT(IS_VALID_STRING_PTR(pcszClass, CSTR));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszDefaultVerbBuf, STR, ucDefaultVerbBufLen));

   ASSERT(lstrlen(pcszClass) > 0);

   if (sizeof(s_cszDefaultVerbSubKeyFmt) + lstrlen(pcszClass)
       < sizeof(szDefaultVerbSubKey))
   {
      DWORD dwValueType;
      DWORD dwcbBufLen = ucDefaultVerbBufLen;

      EVAL(wsprintf(szDefaultVerbSubKey, s_cszDefaultVerbSubKeyFmt,
                    pcszClass) < sizeof(szDefaultVerbSubKey));

      bResult = (GetRegKeyValue(HKEY_CLASSES_ROOT, szDefaultVerbSubKey, NULL,
                                &dwValueType, (PBYTE)pszDefaultVerbBuf,
                                &dwcbBufLen) == ERROR_SUCCESS &&
                 dwValueType == REG_SZ &&
                 *pszDefaultVerbBuf);
   }
   else
      bResult = FALSE;

   if (! bResult)
   {
      if (ucDefaultVerbBufLen > 0)
         *pszDefaultVerbBuf = '\0';
   }

   if (bResult)
      TRACE_OUT(("GetClassDefaultVerb(): Default verb for %s class is %s.",
                 pcszClass,
                 pszDefaultVerbBuf));
   else
      TRACE_OUT(("GetClassDefaultVerb(): No default verb for %s class.",
                 pcszClass));

   ASSERT(! ucDefaultVerbBufLen ||
          (IS_VALID_STRING_PTR(pszDefaultVerbBuf, STR) &&
           EVAL((UINT)lstrlen(pszDefaultVerbBuf) < ucDefaultVerbBufLen)));
   ASSERT(bResult ||
          ! ucDefaultVerbBufLen ||
          ! *pszDefaultVerbBuf);

   return(bResult);
}


/*
 * APPCOMPAT: The need for this function should be obviated by a ShellExecuteEx()
 * flag indicating that the default verb, rather than the open verb, should be
 * executed.  This is broken for folders, for compound document files, for
 * files whose extensions are registered without a file class, for files whose
 * extensions are not unregistered, etc.
 */
PUBLIC_CODE BOOL GetPathDefaultVerb(PCSTR pcszPath, PSTR pszDefaultVerbBuf,
                                    UINT ucDefaultVerbBufLen)
{
   BOOL bResult = FALSE;
   PCSTR pcszExtension;
   char szClass[MAX_PATH_LEN];
   DWORD dwcbLen = ucDefaultVerbBufLen;

   ASSERT(IsValidPath(pcszPath));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszDefaultVerbBuf, STR, ucDefaultVerbBufLen));

   pcszExtension = ExtractExtension(pcszPath);

   bResult = (*pcszExtension &&
              GetDefaultRegKeyValue(HKEY_CLASSES_ROOT, pcszExtension,
                                    szClass, &dwcbLen) == ERROR_SUCCESS &&
              *szClass &&
              GetClassDefaultVerb(szClass, pszDefaultVerbBuf,
                                  ucDefaultVerbBufLen));

   if (! bResult)
   {
      if (ucDefaultVerbBufLen > 0)
         *pszDefaultVerbBuf = '\0';
   }

   ASSERT(! ucDefaultVerbBufLen ||
          (IS_VALID_STRING_PTR(pszDefaultVerbBuf, STR) &&
           EVAL((UINT)lstrlen(pszDefaultVerbBuf) < ucDefaultVerbBufLen)));
   ASSERT(bResult ||
          ! ucDefaultVerbBufLen ||
          ! *pszDefaultVerbBuf);

   return(bResult);
}


/*
** ClassIsSafeToOpen()
**
** Determines whether or not a file class is known safe to open.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL ClassIsSafeToOpen(PCSTR pcszClass)
{
   BOOL bSafe;
   DWORD dwValueType;
   DWORD dwEditFlags;
   DWORD dwcbLen = sizeof(dwEditFlags);

   ASSERT(IS_VALID_STRING_PTR(pcszClass, CSTR));

   bSafe = (GetRegKeyValue(HKEY_CLASSES_ROOT, pcszClass, g_cszEditFlags,
                           &dwValueType, (PBYTE)&dwEditFlags, &dwcbLen) == ERROR_SUCCESS &&
            (dwValueType == REG_BINARY ||
             dwValueType == REG_DWORD) &&
            IS_FLAG_SET(dwEditFlags, FTA_OpenIsSafe));

   TRACE_OUT(("ClassIsSafeToOpen(): Class %s %s safe to open.",
              pcszClass,
              bSafe ? "is" : "is not"));

   return(bSafe);
}


/*
** SetClassEditFlags()
**
** Sets or clears EditFlags for a file class.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL SetClassEditFlags(PCSTR pcszClass, DWORD dwFlags, BOOL bSet)
{
   BOOL bResult = FALSE;
   DWORD dwValueType;
   DWORD dwEditFlags;
   DWORD dwcbLen = sizeof(dwEditFlags);

   ASSERT(IS_VALID_STRING_PTR(pcszClass, CSTR));

   /* Get current file class flags. */

   if (GetRegKeyValue(HKEY_CLASSES_ROOT, pcszClass, g_cszEditFlags,
                      &dwValueType, (PBYTE)&dwEditFlags, &dwcbLen) != ERROR_SUCCESS ||
       (dwValueType != REG_BINARY &&
        dwValueType != REG_DWORD))
      dwEditFlags = 0;

   /* Set or clear SafeOpen flag for file class. */

   if (bSet)
      SET_FLAG(dwEditFlags, dwFlags);
   else
      CLEAR_FLAG(dwEditFlags, dwFlags);

   /*
    * N.b., we must set this as REG_BINARY because the base Win95 shell32.dll
    * only accepts REG_BINARY EditFlags.
    */

   bResult = (SetRegKeyValue(HKEY_CLASSES_ROOT, pcszClass, g_cszEditFlags,
                             REG_BINARY, (PCBYTE)&dwEditFlags,
                             sizeof(dwEditFlags)) == ERROR_SUCCESS);

   if (bResult)
      TRACE_OUT(("SetClassEditFlags(): Class %s flags %lu %s.",
                 pcszClass,
                 dwFlags,
                 bSet ? "set" : "cleared"));
   else
      WARNING_OUT(("SetClassEditFlags(): Failed to %s class %s flags %lu.",
                   bSet ? "set" : "clear",
                   pcszClass,
                   dwFlags));

   return(bResult);
}


#ifdef DEBUG

PUBLIC_CODE BOOL IsFullPath(PCSTR pcszPath)
{
   BOOL bResult = FALSE;
   char rgchFullPath[MAX_PATH_LEN];

   if (IS_VALID_STRING_PTR(pcszPath, CSTR) &&
       EVAL(lstrlen(pcszPath) < MAX_PATH_LEN))
   {
      DWORD dwPathLen;
      PSTR pszFileName;

      dwPathLen = GetFullPathName(pcszPath, sizeof(rgchFullPath), rgchFullPath,
                                  &pszFileName);

      if (EVAL(dwPathLen > 0) &&
          EVAL(dwPathLen < sizeof(rgchFullPath)))
         bResult = EVAL(! lstrcmpi(pcszPath, rgchFullPath));
   }

   return(bResult);
}

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\connapi.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//	CONNAPI.H - internal connection state APIs for O'Hare
//			
//

//	HISTORY:
//	
//	4/5/95		jeremys		Created.
//

#ifndef _CONNAPI_H_
#define _CONNAPI_H_

/*******************************************************************

	NAME:		InetDialHandler

	SYNOPSIS:	Prototype for function exported by autodial handler
				(function name can be anything)

	ENTRY:		hwndParent - parent window (can be NULL)
				pszEntryName - name of RNA entry (connectoid) to use
				dwFlags - reserved for future use.  This parameter must be
					zero.
				pdwRetCode - returns a RAS error code.  Only valid if return
					value from function is TRUE.
			
	EXIT:		returns TRUE if dial handler will process this call.  If TRUE,
				then a RAS error code (or ERROR_SUCCESS) is filled in in pdwRetCode.
				Returns FALSE if the dial handler does not want to process this
				call (e.g. it is turned off in other UI), in which case the
				default dialer will be used.

********************************************************************/
BOOL WINAPI InetDialHandler(HWND hwndParent,LPCSTR pszEntryName,DWORD dwFlags,LPDWORD pdwRetCode);
typedef BOOL (WINAPI * INETDIALHANDLER) (HWND, LPCSTR, DWORD, LPDWORD);


/*******************************************************************

	NAME:		InetEnsureConnected

	SYNOPSIS:	Dials to the Internet if not already connected

	ENTRY:		hwndParent - parent window
				dwFlags - reserved for future use.  This parameter must be
					zero.

	EXIT:		returns TRUE if a connection is made, or a connection already
				exists.  Returns FALSE if a connection was not made or the
				user cancelled.

	NOTES:		If a LAN is present and user has set preference to use LAN,
				then no dialing is done.

				Note that this API does not guarantee or verify that the Internet
				is on the other end of the connection -- it merely assures that
				an RNA or LAN connection is present.

				This function may be exposed to ISVs.

********************************************************************/

BOOL WINAPI InetEnsureConnected(HWND hwndParent,DWORD dwFlags);

#endif	// _CONNAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\comcpp.cpp ===
/*
 * comcpp.cpp - Common C++ functions implementation.
 */


/* Headers
 **********/

#include "project.hpp"
#pragma hdrstop


/****************************** Public Functions *****************************/


PUBLIC_CODE HRESULT MyReleaseStgMedium(PSTGMEDIUM pstgmed)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRUCT_PTR(pstgmed, CSTGMEDIUM));

   if (pstgmed->pUnkForRelease)
   {
        hr = pstgmed->pUnkForRelease->Release();
        switch(pstgmed->tymed)
        {
        case TYMED_FILE:
            SHFree(pstgmed->lpszFileName);
            hr = S_OK;
            break;

        case TYMED_ISTREAM:
            hr = pstgmed->pstm->Release();
            break;

        case TYMED_ISTORAGE:
            hr = pstgmed->pstm->Release();
            break;
        }
   }
   else
   {
      switch(pstgmed->tymed)
      {
         case TYMED_HGLOBAL:
            hr = (! GlobalFree(pstgmed->hGlobal)) ? S_OK : E_HANDLE;
            break;

         case TYMED_ISTREAM:
            hr = pstgmed->pstm->Release();
            break;

         case TYMED_ISTORAGE:
            hr = pstgmed->pstm->Release();
            break;

         case TYMED_FILE:
            SHFree(pstgmed->lpszFileName);
            hr = S_OK;
            break;

         case TYMED_GDI:
            hr = (DeleteObject(pstgmed->hBitmap)) ? S_OK : E_HANDLE;
            break;

         case TYMED_MFPICT:
            hr = (DeleteMetaFile((HMETAFILE)(pstgmed->hMetaFilePict)) &&
                  ! GlobalFree(pstgmed->hMetaFilePict)) ? S_OK : E_HANDLE;
            break;

         case TYMED_ENHMF:
            hr = (DeleteEnhMetaFile(pstgmed->hEnhMetaFile)) ? S_OK : E_HANDLE;
            break;

         default:
            ASSERT(pstgmed->tymed == TYMED_NULL);
            hr = S_OK;
            break;
      }
   }

   return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\contmenu.cpp ===
/*
 * contmenu.cpp - Context menu implementation for URL class.
 */


/* Headers
 **********/

#include "project.hpp"
#pragma hdrstop

#include <mapi.h>

#include "resource.h"

#ifdef UNIX
#include <tchar.h>
#include <inetreg.h>
static HRESULT UnixReadNews(HWND hwndParent, PCSTR pszCmdLine);
#endif

/* Types
 ********/

/* MAPISendMail() typedef */

typedef ULONG (FAR PASCAL *MAPISENDMAILPROC)(LHANDLE lhSession, ULONG ulUIParam, lpMapiMessageA lpMessage, FLAGS flFlags, ULONG ulReserved);

/* RunDLL32 DLL entry point typedef */

typedef void (WINAPI *RUNDLL32PROC)(HWND hwndParent, HINSTANCE hinst, PSTR pszCmdLine, int nShowCmd);


/* Module Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

// case-insensitive

PRIVATE_DATA const char s_cszFileProtocolPrefix[]     = "file:";
PRIVATE_DATA const char s_cszMailToProtocolPrefix[]   = "mailto:";
PRIVATE_DATA const char s_cszRLoginProtocolPrefix[]   = "rlogin:";
PRIVATE_DATA const char s_cszTelnetProtocolPrefix[]   = "telnet:";
PRIVATE_DATA const char s_cszTN3270ProtocolPrefix[]   = "tn3270:";

PRIVATE_DATA const char s_cszNewsDLL[]                = "mcm.dll";
#ifndef UNIX
PRIVATE_DATA const char s_cszTelnetApp[]              = "telnet.exe";
#else
PRIVATE_DATA const char s_cszTelnetApp[]              = "telnet";
#endif

PRIVATE_DATA const char s_cszMAPISection[]            = "Mail";
PRIVATE_DATA const char s_cszMAPIKey[]                = "CMCDLLName32";

PRIVATE_DATA const char s_cszMAPISendMail[]           = "MAPISendMail";
PRIVATE_DATA const char s_cszNewsProtocolHandler[]    = "NewsProtocolHandler";

#pragma data_seg()


/***************************** Exported Functions ****************************/


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

extern "C" void WINAPI OpenURL(HWND hwndParent, HINSTANCE hinst,
                               PSTR pszCmdLine, int nShowCmd)
{
   HRESULT hr;
   InternetShortcut intshcut;
   int nResult;

   DebugEntry(OpenURL);

   ASSERT(IS_VALID_HANDLE(hwndParent, WND));
   ASSERT(IS_VALID_HANDLE(hinst, INSTANCE));
   ASSERT(IS_VALID_STRING_PTR(pszCmdLine, STR));
   ASSERT(IsValidShowCmd(nShowCmd));

   // Assume the entire command line is an Internet Shortcut file path.

   TrimWhiteSpace(pszCmdLine);

   TRACE_OUT(("OpenURL(): Trying to open Internet Shortcut %s.",
              pszCmdLine));

   hr = intshcut.LoadFromFile(pszCmdLine, TRUE);

   if (hr == S_OK)
   {
      URLINVOKECOMMANDINFO urlici;

      urlici.dwcbSize = sizeof(urlici);
      urlici.hwndParent = hwndParent;
      urlici.pcszVerb = NULL;
      urlici.dwFlags = (IURL_INVOKECOMMAND_FL_ALLOW_UI |
                        IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB);

      hr = intshcut.InvokeCommand(&urlici);
   }
   else
   {
      if (MyMsgBox(hwndParent, MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                   MAKEINTRESOURCE(IDS_LOADFROMFILE_FAILED),
                   (MB_OK | MB_ICONEXCLAMATION), &nResult, pszCmdLine)) {
         ASSERT(nResult == IDOK);
       }
   }

   DebugExitVOID(OpenURL);

   return;
}


extern "C" void WINAPI FileProtocolHandler(HWND hwndParent, HINSTANCE hinst,
                                           PSTR pszCmdLine, int nShowCmd)
{
   char szDefaultVerb[MAX_PATH_LEN];
   PCSTR pcszVerb;
   HINSTANCE hinstExec;
   int nResult;
   PARSEDURL pu;

   DebugEntry(FileProtocolHandler);

   ASSERT(IS_VALID_HANDLE(hwndParent, WND));
   ASSERT(IS_VALID_HANDLE(hinst, INSTANCE));
   ASSERT(IS_VALID_STRING_PTR(pszCmdLine, STR));
   ASSERT(IsValidShowCmd(nShowCmd));

   // Assume the entire command line is a file: URL.

   TrimWhiteSpace(pszCmdLine);

   pu.cbSize = sizeof(pu);
   if (S_OK == ParseURL(pszCmdLine, &pu) &&
       URL_SCHEME_FILE == pu.nScheme)
   {
      pszCmdLine = (LPSTR)pu.pszSuffix;
   }

   // Get default verb if available.

   if (GetPathDefaultVerb(pszCmdLine, szDefaultVerb, sizeof(szDefaultVerb)))
      pcszVerb = szDefaultVerb;
   else
      pcszVerb = NULL;

   TRACE_OUT(("FileProtocolHandler(): Invoking %s verb on %s.",
              pcszVerb ? pcszVerb : "open",
              pszCmdLine));

   hinstExec = ShellExecute(hwndParent, pcszVerb, pszCmdLine, NULL, NULL,
                            nShowCmd);

   if (hinstExec > (HINSTANCE)32)
      TRACE_OUT(("FileProtocolHandler(): ShellExecute() %s verb on %s succeeded.",
                 pcszVerb ? pcszVerb : "open",
                 pszCmdLine));
   else
   {
      WARNING_OUT(("FileProtocolHandler(): ShellExecute() %s verb on %s failed, returning %lu.",
                   pcszVerb ? pcszVerb : "open",
                   pszCmdLine,
                   hinstExec));

      if (MyMsgBox(hwndParent, MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                   MAKEINTRESOURCE(IDS_SHELLEXECUTE_FAILED),
                   (MB_OK | MB_ICONEXCLAMATION), &nResult, pszCmdLine)) {
         ASSERT(nResult == IDOK);
      }
   }

   DebugExitVOID(FileProtocolHandler);

   return;
}


extern "C" void WINAPI MailToProtocolHandler(HWND hwndParent, HINSTANCE hinst,
                                             PSTR pszCmdLine, int nShowCmd)
{
   int nResult;
   char szMAPIDLL[MAX_PATH_LEN];

   DebugEntry(MailToProtocolHandler);

   ASSERT(IS_VALID_HANDLE(hwndParent, WND));
   ASSERT(IS_VALID_HANDLE(hinst, INSTANCE));
   ASSERT(IS_VALID_STRING_PTR(pszCmdLine, STR));
   ASSERT(IsValidShowCmd(nShowCmd));

   if (GetProfileString(s_cszMAPISection, s_cszMAPIKey, EMPTY_STRING,
                        szMAPIDLL, sizeof(szMAPIDLL)) > 0)
   {
      HINSTANCE hinstMAPI;

      TRACE_OUT(("MailToProtocolHandler(): MAPI provider DLL is %s.",
                 szMAPIDLL));

      hinstMAPI = LoadLibrary(szMAPIDLL);

      if (hinstMAPI)
      {
         MAPISENDMAILPROC MAPISendMailProc;

         MAPISendMailProc = (MAPISENDMAILPROC)GetProcAddress(
                                                         hinstMAPI,
                                                         s_cszMAPISendMail);

         if (MAPISendMailProc)
         {
            MapiRecipDescA mapito;
            MapiMessage mapimsg;
            ULONG ulResult;

            // Assume the entire command line is a mailto: URL.

            TrimWhiteSpace(pszCmdLine);

            // Skip over any url: prefix.

            if (! lstrnicmp(pszCmdLine, g_cszURLPrefix, g_ucbURLPrefixLen))
               pszCmdLine += g_ucbURLPrefixLen;

            // Skip over any mailto: prefix.

            // (- 1) for null terminator.

            if (! lstrnicmp(pszCmdLine, s_cszMailToProtocolPrefix,
                            SIZECHARS(s_cszMailToProtocolPrefix) - 1))
               pszCmdLine += SIZECHARS(s_cszMailToProtocolPrefix) - 1;

            ZeroMemory(&mapito, sizeof(mapito));

            mapito.ulRecipClass = MAPI_TO;
            mapito.lpszName = pszCmdLine;

            ZeroMemory(&mapimsg, sizeof(mapimsg));

            mapimsg.nRecipCount = 1;
            mapimsg.lpRecips = &mapito;

            TRACE_OUT(("MailToProtocolHandler(): Trying to send mail to %s.",
                       mapito.lpszName));

            ulResult = (*MAPISendMailProc)(NULL, 0, &mapimsg,
                                           (MAPI_LOGON_UI | MAPI_DIALOG), 0);

            if (ulResult == SUCCESS_SUCCESS)
               TRACE_OUT(("MailToProtocolHandler(): MAPISendMail() to %s succeeded.",
                          pszCmdLine));
            else
            {
               if (MyMsgBox(hwndParent, MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                            MAKEINTRESOURCE(IDS_MAPI_MAPISENDMAIL_FAILED),
                            (MB_OK | MB_ICONEXCLAMATION), &nResult)) {
                  ASSERT(nResult == IDOK);
                }
            }
         }
         else
         {
            if (MyMsgBox(hwndParent, MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                         MAKEINTRESOURCE(IDS_MAPI_GETPROCADDRESS_FAILED),
                         (MB_OK | MB_ICONEXCLAMATION), &nResult,
                         szMAPIDLL, s_cszMAPISendMail)) {
               ASSERT(nResult == IDOK);
            }
         }

         EVAL(FreeLibrary(hinstMAPI));
      }
      else
      {
         if (MyMsgBox(hwndParent, MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                      MAKEINTRESOURCE(IDS_MAPI_LOADLIBRARY_FAILED),
                      (MB_OK | MB_ICONEXCLAMATION), &nResult, szMAPIDLL)) {
            ASSERT(nResult == IDOK);
         }
      }
   }
   else
   {
      if (MyMsgBox(hwndParent, MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                   MAKEINTRESOURCE(IDS_NO_MAPI_PROVIDER),
                   (MB_OK | MB_ICONEXCLAMATION), &nResult)) {
         ASSERT(nResult == IDOK);
      }
   }

   DebugExitVOID(MailToProtocolHandler);

   return;
}


extern "C" void WINAPI NewsProtocolHandler(HWND hwndParent, HINSTANCE hinst,
                                           PSTR pszCmdLine, int nShowCmd)
{
   int nResult;
   HINSTANCE hinstNews;

   DebugEntry(NewsProtocolHandler);

   ASSERT(IS_VALID_HANDLE(hwndParent, WND));
   ASSERT(IS_VALID_HANDLE(hinst, INSTANCE));
   ASSERT(IS_VALID_STRING_PTR(pszCmdLine, STR));
   ASSERT(IsValidShowCmd(nShowCmd));

#ifndef UNIX
   // Assume the entire command line is a news: URL.

   TrimWhiteSpace(pszCmdLine);

   // Skip over any url: prefix.

   if (! lstrnicmp(pszCmdLine, g_cszURLPrefix, g_ucbURLPrefixLen))
      pszCmdLine += g_ucbURLPrefixLen;

   hinstNews = LoadLibrary(s_cszNewsDLL);

   if (hinstNews)
   {
      RUNDLL32PROC RealNewsProtocolHandler;

      RealNewsProtocolHandler = (RUNDLL32PROC)GetProcAddress(hinstNews,
                                                             s_cszNewsProtocolHandler);

      if (RealNewsProtocolHandler)
      {
         TRACE_OUT(("NewsProtocolHandler(): Trying to open %s.",
                    pszCmdLine));

         (*RealNewsProtocolHandler)(hwndParent, hinst, pszCmdLine, nShowCmd);

         TRACE_OUT(("NewsProtocolHandler(): Returned from NewsProtocolHandler()."));
      }
      else
      {
         if (MyMsgBox(hwndParent, MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                      MAKEINTRESOURCE(IDS_NEWS_GETPROCADDRESS_FAILED),
                      (MB_OK | MB_ICONEXCLAMATION), &nResult)) {
            ASSERT(nResult == IDOK);
         }
      }

      EVAL(FreeLibrary(hinstNews));
   }
   else
   {
      if (MyMsgBox(hwndParent, MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                   MAKEINTRESOURCE(IDS_NEWS_LOADLIBRARY_FAILED),
                   (MB_OK | MB_ICONEXCLAMATION), &nResult)) {
         ASSERT(nResult == IDOK);
      }
   }
#else
   UnixReadNews(hwndParent, pszCmdLine);
#endif
   
   DebugExitVOID(NewsProtocolHandler);

   return;
}


#ifndef ISSPACE
#define ISSPACE(ch) (((ch) == 32) || ((unsigned)((ch) - 9)) <= 13 - 9)
#endif
#ifndef ISQUOTE
#define ISQUOTE(ch) ((ch) == '\"' || (ch) == '\'')
#endif

extern "C" void WINAPI TelnetProtocolHandler(HWND hwndParent, HINSTANCE hinst,
                                             PSTR pszCmdLine, int nShowCmd)
{
   HRESULT hr;
   int nResult;
   char *p;
   char *pDest;
   BOOL fRemove;

#ifdef UNIX
   char szApp[MAX_PATH];
   char szArgs[MAX_PATH];

#ifndef ANSI_SHELL32_ON_UNIX
  char szCmdLine[MAX_PATH];

  memset(szCmdLine, 0, MAX_PATH);

  SHUnicodeToAnsi((LPWSTR)pszCmdLine, szCmdLine, MAX_PATH);
  pszCmdLine = szCmdLine;
#endif /* ANSI_SHELL32_ON_UNIX */
#endif

   
   DebugEntry(TelnetProtocolHandler);

   ASSERT(IS_VALID_HANDLE(hwndParent, WND));
   ASSERT(IS_VALID_HANDLE(hinst, INSTANCE));
   ASSERT(IS_VALID_STRING_PTR(pszCmdLine, STR));
   ASSERT(IsValidShowCmd(nShowCmd));

   // Assume the entire command line is a telnet URL.

   TrimWhiteSpace(pszCmdLine);

   // Skip over any url: prefix.

   if (! lstrnicmp(pszCmdLine, g_cszURLPrefix, g_ucbURLPrefixLen))
      pszCmdLine += g_ucbURLPrefixLen;

   // Skip over any telnet:, rlogin:, or tn3270: prefix.

   // (- 1) for null terminator.

   if (! lstrnicmp(pszCmdLine, s_cszTelnetProtocolPrefix,
                   SIZECHARS(s_cszTelnetProtocolPrefix) - 1))
      pszCmdLine += SIZECHARS(s_cszTelnetProtocolPrefix) - 1;
   else if (! lstrnicmp(pszCmdLine, s_cszRLoginProtocolPrefix,
                        SIZECHARS(s_cszRLoginProtocolPrefix) - 1))
      pszCmdLine += SIZECHARS(s_cszRLoginProtocolPrefix) - 1;
   else if (! lstrnicmp(pszCmdLine, s_cszTN3270ProtocolPrefix,
                        SIZECHARS(s_cszTN3270ProtocolPrefix) - 1))
      pszCmdLine += SIZECHARS(s_cszTN3270ProtocolPrefix) - 1;

   // Remove leading and trailing slashes.

   TrimSlashes(pszCmdLine);

   // Skip user name if given

   p = StrChr(pszCmdLine, '@');

   if (p)
      pszCmdLine = p + 1;

   // Eliminate double quotes...should be no need for these
   // unless trouble is afoot.
   for (pDest = p = pszCmdLine; *p; p++)
   {
      if (!ISQUOTE(*p))
      {
          *pDest = *p;
          pDest++;
      }
   }
   *pDest = '\0';

   // For security reasons, strip the filename cmdline option
   if (pszCmdLine)
   {
       for (p = pszCmdLine; *p; p++)
       {
           // Be careful and don't nuke servernames that start with -f.
           // Since hostnames can't start with a dash, ensure previous char is
           // whitespace, or we're at the beginning.
           //
           // Also, -a sends credentials over the wire, so strip it, too.
           if ((*p == '/' || *p == '-') &&
               (*(p+1) == 'f' || *(p+1) == 'F' || *(p+1) == 'a' || *(p+1) == 'A'))
           {
               fRemove = TRUE;
               if (!((p == pszCmdLine || ISSPACE(*(p-1)) || ISQUOTE(*(p-1)) )))
               {
                   char *pPortChar = p-1;
                   // Doesn't meet easy criteria, but it might be harder to
                   // detect, such as site:-ffilename.  In this case, consider
                   // the -f piece unsafe if everything between -f and a colon
                   // to the left is a digit (no digits will also be unsafe).
                   // If anything else is hit first, then consider it to
                   // be part of the hostname.  Walking to the beginning
                   // be considered safe (e.g. "80-ffilename" would be considered
                   // the hostname).
                   while (pPortChar >= pszCmdLine && *pPortChar != ':')
                   {
                       if (*pPortChar < '0' || *pPortChar > '9')
                       {
                           fRemove = FALSE;
                           break;
                       }
                       pPortChar--;
                   }
                   if (pPortChar < pszCmdLine)
                       fRemove = FALSE;
               }

               if (!fRemove)
                   continue;

               BOOL fQuotedFilename = FALSE;
               LPSTR pStart = p;

               // move past -f
               p+=2;

               // Skip over whitespace and filename following -f option
               if (*(p-1) == 'f' || *(p-1) == 'F')
               {
                   while (*p && ISSPACE(*p))
                       p++;

                   // but wait, it may be a long filename surrounded by quotes
                   if (ISQUOTE(*p))
                   {
                       fQuotedFilename = TRUE;
                       p++;
                   }

                   // Loop until null OR whitespace if not quoted pathname OR quote if a quoted pathname
                   while (!((*p == '\0') ||
                            (ISSPACE(*p) && !fQuotedFilename) ||
                            (ISQUOTE(*p) && fQuotedFilename)))
                       p++;
               }

               // phase out the -a and -f options, but keep going to search the rest of the string
               memmove((VOID *)pStart, (VOID *)p, strlen(p)+1);
               p = pStart-1;
           }
       }
   }

   // If a port has been specified, turn ':' into space, which will make the
   // port become the second command line argument.

   p = StrChr(pszCmdLine, ':');

   if (p)
      *p = ' ';

   TRACE_OUT(("TelnetProtocolHandler(): Trying telnet to %s.",
              pszCmdLine));

#ifndef UNIX
   hr = MyExecute(s_cszTelnetApp, pszCmdLine, 0);
#else
   // On UNIX, telnet is not GUI application, so we need to create
   // separate xterm for it if we want to seet in in the separate window.
   strcpy(szApp, "xterm");
   wnsprintf(szArgs, sizeof(szArgs), "-e %s %s", s_cszTelnetApp, pszCmdLine);
   hr = MyExecute(szApp, szArgs, 0);
#endif

   switch (hr)
   {
      case S_OK:
         break;

      case E_FILE_NOT_FOUND:
         if (MyMsgBox(hwndParent, MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                      MAKEINTRESOURCE(IDS_TELNET_APP_NOT_FOUND),
                      (MB_OK | MB_ICONEXCLAMATION), &nResult,
                      s_cszTelnetApp)) {
            ASSERT(nResult == IDOK);
         }
         break;

      case E_OUTOFMEMORY:
         if (MyMsgBox(hwndParent, MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                      MAKEINTRESOURCE(IDS_OPEN_INTSHCUT_OUT_OF_MEMORY),
                      (MB_OK | MB_ICONEXCLAMATION), &nResult)) {
            ASSERT(nResult == IDOK);
         }
         break;

      default:
         ASSERT(hr == E_FAIL);
         if (MyMsgBox(hwndParent, MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                      MAKEINTRESOURCE(IDS_TELNET_EXEC_FAILED),
                      (MB_OK | MB_ICONEXCLAMATION), &nResult,
                      s_cszTelnetApp)) {
            ASSERT(nResult == IDOK);
         }
         break;
   }

   DebugExitVOID(TelnetProtocolHandler);

   return;
}


#ifdef UNIX
#define OE_NEWS_COMMAND_KEY TEXT("Software\\Clients\\News\\Outlook Express\\shell\\open\\command")
#define OE_URL_COMMAND_NAME TEXT("URLCommand")
#define IE_HOME_ENVIRONMENT TEXT("MWDEV")

HRESULT UnixLaunchOENews(PCSTR pszCmdLine)
{
    HRESULT     hr = S_OK;
    TCHAR       *tszCommand = NULL;
    TCHAR       tszIEHome[MAX_PATH];
    DWORD       cchIEHome;
    DWORD       cchCommand;
    DWORD       dwDisposition;
    TCHAR       *pchPos;
    BOOL        bMailed;
    STARTUPINFO stInfo;
    HKEY        hkey = NULL;
    int         i;
#ifndef ANSI_SHELL32_ON_UNIX
    char szCmdLine[MAX_PATH];

    memset(szCmdLine, 0, MAX_PATH);
   
    SHUnicodeToAnsi((LPWSTR)pszCmdLine, szCmdLine, MAX_PATH);
    pszCmdLine = szCmdLine;
#endif /* ANSI_SHELL32_ON_UNIX */

    cchIEHome = GetEnvironmentVariable(IE_HOME_ENVIRONMENT, tszIEHome, MAX_PATH);
    if (cchIEHome)
    {
    _tcscat(tszIEHome, TEXT("/bin"));
    }
    else
    {
    return E_FAIL;
    }

    hr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, OE_NEWS_COMMAND_KEY, 0, NULL, 0, KEY_READ, NULL, &hkey, &dwDisposition);
    if (hr != ERROR_SUCCESS) 
    {
        goto Cleanup;
    }

    hr = RegQueryValueEx(hkey, OE_URL_COMMAND_NAME, NULL, NULL, (LPBYTE)NULL, &cchCommand);
    if (hr != ERROR_SUCCESS)
    {
        goto Cleanup;
    }
    cchCommand += _tcslen(tszIEHome) + _tcslen(pszCmdLine) + 1;
    tszCommand = (TCHAR*)malloc((cchCommand)*sizeof(TCHAR));

    _tcscpy(tszCommand, tszIEHome);
    _tcscat(tszCommand, TEXT("/"));
    dwDisposition = _tcslen(tszCommand);

    hr = RegQueryValueEx(hkey, OE_URL_COMMAND_NAME, NULL, NULL, (LPBYTE)(&tszCommand[dwDisposition]), &cchCommand);
    if (hr != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    _tcscat(tszCommand, pszCmdLine);


    memset(&stInfo, 0, sizeof(stInfo));
    stInfo.cb = sizeof(stInfo);
    bMailed = CreateProcess(NULL, tszCommand, NULL, NULL, FALSE, DETACHED_PROCESS, NULL, NULL, &stInfo, NULL);

Cleanup:
    if ( hkey != NULL )
        RegCloseKey(hkey);

    if (tszCommand)
        free(tszCommand);

    return hr;
}

HRESULT UnixReadNews(HWND hWndParent, PCSTR pszCmdLine)
{
    HRESULT         hr = S_FALSE;

    CHAR            szCommand[MAX_PATH];
    CHAR            szExpandedCommand[MAX_PATH];
    UINT            nCommandSize;
    int             i;
    HKEY    hkey;
    DWORD   dw;
    BOOL bMailed;
    STARTUPINFOA stInfo;

    DWORD dwType;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwUseOENews;

    hr = SHGetValue(IE_USE_OE_NEWS_HKEY, IE_USE_OE_NEWS_KEY, IE_USE_OE_NEWS_VALUE, 
            &dwType, (void*)&dwUseOENews, &dwSize);
    if ((hr) && (dwType != REG_DWORD))
    {
    // The default value for mail is FALSE
    dwUseOENews = FALSE;
    }
    if (dwUseOENews)
    {
    return UnixLaunchOENews(pszCmdLine);
    }

    hr = RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_NEWSCLIENTS, 0, NULL, 0, KEY_READ, NULL, &hkey, &dw);
    if (hr != ERROR_SUCCESS)
        goto Cleanup;
    dw = MAX_PATH;
    hr = RegQueryValueEx(hkey, REGSTR_PATH_CURRENT, NULL, NULL, (LPBYTE)szCommand, &dw);
    if (hr != ERROR_SUCCESS)
    {
        RegCloseKey(hkey);
        goto Cleanup;
    }

    if (strlen(szCommand) == 0)
      {
    MessageBox(hWndParent,
           TEXT("There is currently no default association for \"news:\" links in UNIX Internet Explorer.  If you have a favorite news reader that supports news specifications on the command line (id and group name), you can define an association for \"news:\" links for this program in the View->Internet Options, Programs Tab.\n"),
           TEXT("Microsoft Internet Explorer"),
           MB_OK|MB_ICONSTOP);
    return S_FALSE;
      }

    dw = ExpandEnvironmentStringsA(szCommand, szExpandedCommand, MAX_PATH);
    if (!dw)
     {
        strcpy(szExpandedCommand, szCommand);
     }

    strcpy(szCommand, szExpandedCommand);
    for (i = lstrlen(szCommand)-1; i >= 0; i--)
    if (szCommand[i] == '/')
    {
        szCommand[i] = '\0';
        break;
    }
    strcat(szCommand, " ");
    strcat(szCommand, (pszCmdLine + strlen("news:")));

    memset(&stInfo, 0, sizeof(stInfo));
    stInfo.cb = sizeof(stInfo);
    bMailed = CreateProcessA(szExpandedCommand, szCommand, NULL, NULL, FALSE, DETACHED_PROCESS, NULL, NULL, &stInfo, NULL);
 
Cleanup:

    return S_OK;
}
#endif

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\contxids.h ===
/*
   Definitions of Help IDs
*/

/* Options - Appearance Page */
#define	IDH_APPEARANCE_SHOW_PICTURES			0x1000 	
#define	IDH_APPEARANCE_USE_CUSTOM_COLORS		0x1001 	
#define	IDH_APPEARANCE_COLORS_TEXT			0x1002 	
#define	IDH_APPEARANCE_COLORS_BACKGROUND		0x1003 	
#define	IDH_APPEARANCE_COLORS_VIEWED			0x1004 	
#define	IDH_APPEARANCE_COLORS_NOT_VIEWED		0x1005 	
#define	IDH_APPEARANCE_UNDERLINE_SHORTCUTS		0x1006	
#define	IDH_APPEARANCE_SHOW_URL_IN_SB			0x1007
#define	IDH_APPEARANCE_SHOW_SIMPLE_URL			0x1008	
#define	IDH_APPEARANCE_SHOW_FULL_URL			0x1009 

/* Options - Home Base */
#define	IDH_HOME_BASE_USE_CURRENT				0x100a
#define	IDH_HOME_BASE_USE_DEFAULT				0x100b

/* Options - Advanced Page */
#define	IDH_ADVANCED_HST_NUM_PLACES				0x100c
#define IDH_ADVANCED_HST_EMPTY					0x100d
#define	IDH_ADVANCED_HST_LOCATION				0x100e	
#define	IDH_ADVANCED_HST_BROWSE					0x100f
#define	IDH_ADVANCED_CACHE_PERCENT				0x1010
#define IDH_ADVANCED_CACHE_EMPTY				0x1011
#define	IDH_ADVANCED_CACHE_LOCATION				0x1012  
#define	IDH_ADVANCED_CACHE_BROWSE				0x1013

/* Goto Dialog Box */
#define	IDH_GOTOURL_COMBO					0x1014
#define	IDH_GOTOURL_NEWWINDOW					0x1015
#define	IDH_GOTOURL_OPENFILE					0x1016

/* Find Dialog Box */
#define IDH_FIND_TEXTTOFIND                                     0x1017
#define IDH_FIND_STARTFROMTOP                                   0x1018
#define IDH_FIND_MATCHCASE                                      0x1019
#define IDH_FIND_FINDNEXT                                       0x101a

/* Page Setup Dialog Box */
#define IDH_PAGESETUP_MARGIN_LEFT                               0x101b
#define IDH_PAGESETUP_MARGIN_TOP                                0x101c
#define IDH_PAGESETUP_MARGIN_RIGHT                              0x101d
#define IDH_PAGESETUP_MARGIN_BOTTOM                             0x101e
#define IDH_PAGESETUP_HEADER_LEFT                               0x101f
#define IDH_PAGESETUP_HEADER_RIGHT                              0x1020
#define IDH_PAGESETUP_FOOTER_LEFT                               0x1021
#define IDH_PAGESETUP_FOOTER_RIGHT                              0x1022

/* More Options - Advanced Page */
#define IDH_ADVANCED_CACHE_ONCEPERSESS                          0x1023
#define IDH_ADVANCED_CACHE_NEVER				0x1024

/* File Type */
#define IDH_FILETYPE_CONTENT_TYPE                               0x1025
#define IDH_FILETYPE_OPENS_WITH                                 0x1026
#define IDH_NEW_FILETYPE_CONTENT_TYPE                           0x1027
#define IDH_NEWFILETYPE_DEFAULT_EXT                             0x1028
#define IDH_FILETYPE_EXTENSION					0X1029

/* New Help IDs for Internet Explorer 1.x below */
/* More Options - Appearance */
#define	IDH_APPEARANCE_PLAY_SOUNDS			0x102a
#define	IDH_APPEARANCE_PROPORTIONAL_FONT		0x102b
#define	IDH_APPEARANCE_FIXED_FONT			0x102c
#define	IDH_APPEARANCE_SHOW_URL				0x102d

/* Options - News */
#define	IDH_NEWS_SERVER 				0x102e
#define	IDH_NEWS_ENABLE_AUTH 				0x102f
#define	IDH_NEWS_USERNAME 				0x1030
#define	IDH_NEWS_PASSWORD 				0x1031
#define IDH_NEWS_ON_OFF                                 0x104a  /* note order! */

/* Options - Start and Search Pages */
#define IDH_PAGES_LISTBOX				0x1032
#define	IDH_PAGES_START_URL 				0x1033
#define	IDH_PAGES_START_USE_CURRENT			0x1034
#define	IDH_PAGES_START_USE_DEFAULT			0x1035
#define	IDH_PAGES_SEARCH_URL 				0x1036
#define	IDH_PAGES_SEARCH_USE_CURRENT			0x1037
#define	IDH_PAGES_SEARCH_USE_DEFAULT			0x1038

/* Options - Security */
#define IDH_SECURITY_TELL_ME				0x1039
#define IDH_SECURITY_SEND_HIGH				0x103a
#define IDH_SECURITY_SEND_MED				0x103b
#define IDH_SECURITY_SEND_LOW				0x103c
#define IDH_SECURITY_VIEW_HIGH				0x103d
#define IDH_SECURITY_VIEW_LOW				0x103e




/* Properties - General */
#define IDH_PROPG_ICON					0x103f
#define IDH_PROPG_TITLE                     		0x1040
#define IDH_PROPG_PROTOCOL         			0x1041
#define IDH_PROPG_TYPE                      		0x1042
#define IDH_PROPG_URL                       		0x1043
#define IDH_PROPG_SIZE                      		0x1044
#define IDH_PROPG_CREATED                   		0x1045
#define IDH_PROPG_MODIFIED                  		0x1046
#define IDH_PROPG_UPDATED                   		0x1047

/* Properties - Security */
#define IDH_PROPS_DESC                      		0x1048
#define IDH_PROPS_CERT                      		0x1049
/* used above: #define IDH_NEWS_ON_OFF                  0x104a  */

/* File Type (continued from above) */
#define IDH_FILETYPE_CONFIRM_OPEN            		0X104b
#define IDH_APPEARANCE_SHOW_VIDEO                       0x104c


#define IDH_COMMON_GROUPBOX                             0x104d

#define IDH_ADVANCED_ASSOC_CHECK                        0x104e 

#ifndef IDH_GROUPBOX
/* Common group box help ID */
#define IDH_GROUPBOX                                    0x2000
#endif

/* help topic that the user gets when he clicks on 
 "tell me about Internet Security" Button */
#define HELP_TOPIC_SECURITY                             0x104f

#define IDH_SECURITY_BAD_CN_SEND						0x1050
#define IDH_SECURITY_BAD_CN_RECV						0x1051


/* help topic that the user gets when he clicks on 
  Help Button in Proxy settings page*/
#define HELP_TOPIC_PROXY_SUPPORT                   HELP_TOPIC_SECURITY


/* Help button at bottom of Print/headers & footers dialog */
#define IDH_PAGESETUP_OVERVIEW                          0x1052

/* new fields on news tab */
#define IDH_NEWS_EMAIL_ADDRESS                          0x1053
#define IDH_NEWS_POSTING_NAME                           0x1054

/* ratings control panel */
#define IDH_RATINGS_SET_RATINGS_BUTTON                  0x1055
#define	IDH_RATINGS_TURNON_BUTTON                       0x1056
#define IDH_RATINGS_CATEGORY_LABEL                      0x1057
#define IDH_RATINGS_CATEGORY_LIST                       0x1058
#define IDH_RATINGS_RATING_LABEL                        0x1059
#define IDH_RATINGS_RATING_TEXT                         0x105a
#define IDH_RATINGS_DESCRIPTION_LABEL                   0x105b
#define IDH_RATINGS_DESCRIPTION_TEXT                    0x105c
#define IDH_RATINGS_UNRATED_CHECKBOX                    0x105d
#define IDH_RATINGS_RATING_SYSTEM_BUTTON                0x105e
#define IDH_RATINGS_RATING_SYSTEM_TEXT                  0x105f
#define IDH_RATINGS_CHANGE_PASSWORD_BUTTON              0x1060
#define IDH_RATINGS_CHANGE_PASSWORD_TEXT                0x1061
#define IDH_RATINGS_OVERRIDE_CHECKBOX                   0x1062
#define IDH_RATINGS_SUPERVISOR_PASSWORD                 0x1063
#define IDH_RATINGS_SUPERVISOR_CREATE_PASSWORD          0x1064       
#define IDH_RATINGS_CHANGE_PASSWORD_CONFIRM             0x1065
#define IDH_RATINGS_BUREAU                              0x1066
#define IDH_RATINGS_VIEW_PROVIDER_PAGE                  0x1067
#define IDH_RATINGS_SYSTEM_RATSYS_LIST                  0x1068
#define IDH_RATINGS_SYSTEM_RATSYS_ADD                   0x1069
#define IDH_RATINGS_SYSTEM_RATSYS_REMOVE                0x106a
#define IDH_RATINGS_CHANGE_PASSWORD_OLD                 0x106b
#define IDH_RATINGS_CHANGE_PASSWORD_NEW                 0x106c


// Safety: Protecting you from the net
#define IDH_SAFETY_YOUWEREPROTECTED						0x106d


// reserve range       0x3000 -- 0x4000 for shell
#define IDH_FOR_SHDOCVW_BEGIN                           0x3000
#define IDH_FOR_SHDOCVW_END                             0x4000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\comc.h ===
/*
 * comc.h - Shared routines description.
 */


/* Types
 ********/

/* input flags to MyExecute() */

typedef enum myexecute_in_flags
{
   /*
    * Adds double quotes around the given argument string on the generated
    * command line if the argument string contains any white space.
    */

   ME_IFL_QUOTE_ARGS    = 0x0001,

   /* flag combinations */

   ALL_ME_IN_FLAGS      = ME_IFL_QUOTE_ARGS
}
MYEXECUTE_IN_FLAGS;


/* Global Variables
 *******************/

/* comc.c */

extern const char g_cszWhiteSpace[];
extern const char g_cszSlashes[];
extern const char g_cszPathSeparators[];
extern const char g_cszEditFlags[];


/* Prototypes
 *************/

/* comc.c */

extern BOOL DataCopy(PCBYTE pcbyteSrc, ULONG ulcbLen, PBYTE *ppbyteDest);
extern BOOL StringCopy(PCSTR pcszSrc, PSTR *ppszCopy);
extern BOOL GetMIMETypeSubKey(PCSTR pcszMIMEType, PSTR pszSubKeyBuf, UINT ucSubKeyBufLen);
extern BOOL GetMIMEValue(PCSTR pcszMIMEType, PCSTR pcszValue, PDWORD pdwValueType, PBYTE pbyteValueBuf, PDWORD pdwcbValueBufLen);
extern BOOL GetFileTypeValue(PCSTR pcszExtension, PCSTR pcszSubKey, PCSTR pcszValue, PDWORD pdwValueType, PBYTE pbyteValueBuf, PDWORD pdwcbValueBufLen);
extern BOOL GetMIMEFileTypeValue(PCSTR pcszMIMEType, PCSTR pcszSubKey, PCSTR pcszValue, PDWORD pdwValueType, PBYTE pbyteValueBuf, PDWORD pdwcbValueBufLen);
extern BOOL MIME_IsExternalHandlerRegistered(PCSTR pcszMIMEType);
extern BOOL MIME_GetExtension(PCSTR pcszMIMEType, PSTR pszExtensionBuf, UINT ucExtensionBufLen);
extern BOOL MIME_GetMIMETypeFromExtension(PCSTR pcszPath, PSTR pszMIMETypeBuf, UINT ucMIMETypeBufLen);
extern void CatPath(PSTR pszPath, PCSTR pcszSubPath);
extern void MyLStrCpyN(PSTR pszDest, PCSTR pcszSrc, int ncb);
extern COMPARISONRESULT MapIntToComparisonResult(int nResult);
extern void TrimWhiteSpace(PSTR pszTrimMe);
extern void TrimSlashes(PSTR pszTrimMe);
extern void TrimString(PSTR pszTrimMe, PCSTR pszTrimChars);
extern PCSTR ExtractFileName(PCSTR pcszPathName);
extern PCSTR ExtractExtension(PCSTR pcszName);
extern LONG SetRegKeyValue(HKEY hkeyParent, PCSTR pcszSubKey, PCSTR pcszValue, DWORD dwType, PCBYTE lpcbyte, DWORD dwcb);;
extern LONG GetRegKeyValue(HKEY hkeyParent, PCSTR pcszSubKey, PCSTR pcszValue, PDWORD pdwValueType, PBYTE pbyteBuf, PDWORD pdwcbBufLen);
extern LONG GetRegKeyStringValue(HKEY hkeyParent, PCSTR pcszSubKey, PCSTR pcszValue, PSTR pszBuf, PDWORD pdwcbBufLen);
extern LONG GetDefaultRegKeyValue(HKEY hkeyParent, PCSTR pcszSubKey, PSTR pszBuf, PDWORD pdwcbBufLen);
extern HRESULT FullyQualifyPath(PCSTR pcszPath, PSTR pszFullyQualifiedPath, UINT ucFullyQualifiedPathBufLen);
extern HRESULT MyExecute(PCSTR pcszApp, PCSTR pcszArgs, DWORD dwInFlags);
extern BOOL GetClassDefaultVerb(PCSTR pcszClass, PSTR pszDefaultVerbBuf, UINT ucDefaultVerbBufLen);
extern BOOL GetPathDefaultVerb(PCSTR pcszPath, PSTR pszDefaultVerbBuf, UINT ucDefaultVerbBufLen);
extern BOOL ClassIsSafeToOpen(PCSTR pcszClass);
extern BOOL SetClassEditFlags(PCSTR pcszClass, DWORD dwFlags, BOOL bSet);

#ifdef DEBUG

extern BOOL IsFullPath(PCSTR pcszPath);

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\dataobj.hpp ===
/*
 * dataobj.hpp - IDataObject implementation description.
 */


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Prototypes
 *************/

// dataobj.cpp

#define InitDataObjectModule() RegisterClipboardFormats()
extern BOOL RegisterClipboardFormats(void);
extern void ExitDataObjectModule(void);


/* Global Variables
 *******************/

// dataobj.cpp

extern UINT g_cfURL;
extern UINT g_cfFileGroupDescriptor;
extern UINT g_cfFileContents;


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\debbase.h ===
/*
 * debbase.h - Base debug macros and their retail translations.
 */


/* Macros
 *********/

/* debug assertion macro */

/*
 * ASSERT() may only be used as a statement, not as an expression.
 *
 * E.g.,
 *
 * ASSERT(pszRest);
 */

#ifdef DEBUG

#define ASSERT(exp) \
   if (exp) \
      ; \
   else \
      ERROR_OUT(("assertion failed '%s'", (PCSTR)#exp))

#else

#define ASSERT(exp)

#endif   /* DEBUG */

/* debug evaluation macro */

/*
 * EVAL() may only be used as a logical expression.
 *
 * E.g.,
 *
 * if (EVAL(exp))
 *    bResult = TRUE;
 */

#ifdef DEBUG

#define EVAL(exp) \
   ((exp) || \
    (ERROR_OUT(("evaluation failed '%s'", (PCSTR)#exp)), 0))

#else

#define EVAL(exp) \
   ((exp) != 0)

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\debspew.c ===
/*
 * debspew.c - Debug spew functions module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#ifdef DEBUG


/* Types
 ********/


/* debug flags */

typedef enum _debugdebugflags
{
   DEBUG_DFL_ENABLE_TRACE_MESSAGES  = 0x0001,

   DEBUG_DFL_LOG_TRACE_MESSAGES     = 0x0002,

   DEBUG_DFL_DUMP_THREAD_ID         = 0x0004,

   ALL_DEBUG_DFLAGS                 = (DEBUG_DFL_ENABLE_TRACE_MESSAGES |
                                       DEBUG_DFL_LOG_TRACE_MESSAGES |
                                       DEBUG_DFL_DUMP_THREAD_ID)
}
DEBUGDEBUGFLAGS;



/* Module Constants
 *******************/


#pragma data_seg(DATA_SEG_READ_ONLY)

/* debug message output log file */

PRIVATE_DATA CCHAR s_cszLogFile[]   = "debug.log";

#pragma data_seg()



/* Global Variables
 *******************/

#pragma data_seg(DATA_SEG_PER_INSTANCE)

/* parameters used by SpewOut() */

PUBLIC_DATA char SrgchSpewLeader[] = "                                                                                ";

PUBLIC_DATA DWORD g_dwSpewFlags = 0;
PUBLIC_DATA UINT g_uSpewSev = 0;
PUBLIC_DATA UINT g_uSpewLine = 0;
PUBLIC_DATA PCSTR g_pcszSpewFile = NULL;

#pragma data_seg()



/* Module Variables
 *******************/


#pragma data_seg(DATA_SEG_PER_INSTANCE)

/* TLS slot used to store stack depth for SpewOut() indentation */

PRIVATE_DATA DWORD s_dwStackDepthSlot = TLS_OUT_OF_INDEXES;

/* hack stack depth counter used until s_dwStackDepthSlot is not available */

PRIVATE_DATA ULONG s_ulcHackStackDepth = 0;

#pragma data_seg(DATA_SEG_SHARED)

/* debug flags */

PRIVATE_DATA DWORD s_dwDebugModuleFlags = 0;

#pragma data_seg(DATA_SEG_READ_ONLY)

/* .ini file switch descriptions */

PRIVATE_DATA CBOOLINISWITCH s_cbisEnableTraceMessages =
{
   IST_BOOL,
   "EnableTraceMessages",
   &s_dwDebugModuleFlags,
   DEBUG_DFL_ENABLE_TRACE_MESSAGES
};

PRIVATE_DATA CBOOLINISWITCH s_cbisLogTraceMessages =
{
   IST_BOOL,
   "LogTraceMessages",
   &s_dwDebugModuleFlags,
   DEBUG_DFL_LOG_TRACE_MESSAGES
};

PRIVATE_DATA CBOOLINISWITCH s_cbisDumpThreadID =
{
   IST_BOOL,
   "DumpThreadID",
   &s_dwDebugModuleFlags,
   DEBUG_DFL_DUMP_THREAD_ID
};

PRIVATE_DATA const PCVOID s_rgcpcvisDebugModule[] =
{
   &s_cbisLogTraceMessages,
   &s_cbisEnableTraceMessages,
   &s_cbisDumpThreadID
};

#pragma data_seg()



/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/


PRIVATE_CODE BOOL LogOutputDebugString(PCSTR);
PRIVATE_CODE BOOL IsValidSpewSev(UINT);




/*
** LogOutputDebugString()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL LogOutputDebugString(PCSTR pcsz)
{
   BOOL bResult = FALSE;
   UINT ucb;
   char rgchLogFile[MAX_PATH_LEN];

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   ucb = GetWindowsDirectory(rgchLogFile, sizeof(rgchLogFile));

   if (ucb > 0 && ucb < sizeof(rgchLogFile))
   {
      HANDLE hfLog;


      lstrcat(rgchLogFile, "\\");
      lstrcat(rgchLogFile, s_cszLogFile);

      hfLog = CreateFile(rgchLogFile, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
                         FILE_FLAG_WRITE_THROUGH, NULL);

      if (hfLog != INVALID_HANDLE_VALUE)
      {
         if (SetFilePointer(hfLog, 0, NULL, FILE_END) != INVALID_SEEK_POSITION)
         {
            DWORD dwcbWritten;

            bResult = WriteFile(hfLog, pcsz, lstrlen(pcsz), &dwcbWritten, NULL);

            if (! CloseHandle(hfLog) && bResult)
               bResult = FALSE;
         }
      }
   }

   return(bResult);
}


/*
** IsValidSpewSev()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidSpewSev(UINT uSpewSev)
{
   BOOL bResult;

   switch (uSpewSev)
   {
      case SPEW_TRACE:
      case SPEW_WARNING:
      case SPEW_ERROR:
      case SPEW_FATAL:
         bResult = TRUE;
         break;

      default:
         ERROR_OUT(("IsValidSpewSev(): Invalid debug spew severity %u.",
                    uSpewSev));
         bResult = FALSE;
         break;
   }

   return(bResult);
}



/****************************** Public Functions *****************************/



/*
** SetDebugModuleIniSwitches()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL SetDebugModuleIniSwitches(void)
{
   BOOL bResult;

   bResult = SetIniSwitches(s_rgcpcvisDebugModule,
                            ARRAY_ELEMENTS(s_rgcpcvisDebugModule));

   ASSERT(FLAGS_ARE_VALID(s_dwDebugModuleFlags, ALL_DEBUG_DFLAGS));

   return(bResult);
}


/*
** InitDebugModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL InitDebugModule(void)
{
   ASSERT(s_dwStackDepthSlot == TLS_OUT_OF_INDEXES);

   s_dwStackDepthSlot = TlsAlloc();

   if (s_dwStackDepthSlot != TLS_OUT_OF_INDEXES)
   {
      EVAL(TlsSetValue(s_dwStackDepthSlot, IntToPtr(s_ulcHackStackDepth)));

      TRACE_OUT(("InitDebugModule(): Using thread local storage slot %lu for debug stack depth counter.",
                 s_dwStackDepthSlot));
   }
   else
      WARNING_OUT(("InitDebugModule(): TlsAlloc() failed to allocate thread local storage for debug stack depth counter."));

   return(TRUE);
}


/*
** ExitDebugModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void ExitDebugModule(void)
{
   if (s_dwStackDepthSlot != TLS_OUT_OF_INDEXES)
   {
      s_ulcHackStackDepth = PtrToUlong(TlsGetValue(s_dwStackDepthSlot));

      /* Leave s_ulcHackStackDepth == 0 if TlsGetValue() fails. */

      EVAL(TlsFree(s_dwStackDepthSlot));
      s_dwStackDepthSlot = TLS_OUT_OF_INDEXES;
   }

   return;
}


/*
** StackEnter()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void StackEnter(void)
{
   if (s_dwStackDepthSlot != TLS_OUT_OF_INDEXES)
   {
      ULONG ulcDepth;

      ulcDepth = PtrToUlong(TlsGetValue(s_dwStackDepthSlot));

      ASSERT(ulcDepth < ULONG_MAX);

      EVAL(TlsSetValue(s_dwStackDepthSlot, IntToPtr(ulcDepth + 1)));
   }
   else
   {
      ASSERT(s_ulcHackStackDepth < ULONG_MAX);
      s_ulcHackStackDepth++;
   }

   return;
}


/*
** StackLeave()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void StackLeave(void)
{
   if (s_dwStackDepthSlot != TLS_OUT_OF_INDEXES)
   {
      ULONG ulcDepth;

      ulcDepth = PtrToUlong(TlsGetValue(s_dwStackDepthSlot));

      if (EVAL(ulcDepth > 0))
         EVAL(TlsSetValue(s_dwStackDepthSlot, IntToPtr(ulcDepth - 1)));
   }
   else
   {
      if (EVAL(s_ulcHackStackDepth > 0))
         s_ulcHackStackDepth--;
   }

   return;
}


/*
** GetStackDepth()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE ULONG GetStackDepth(void)
{
   ULONG ulcDepth;

   if (s_dwStackDepthSlot != TLS_OUT_OF_INDEXES)
      ulcDepth = PtrToUlong(TlsGetValue(s_dwStackDepthSlot));
   else
      ulcDepth = s_ulcHackStackDepth;

   return(ulcDepth);
}


/*
** SpewOut()
**
** Spews out a formatted message to the debug terminal.
**
** Arguments:     pcszFormat - pointer to wvsprintf() format string
**                ... - formatting arguments ala wvsprintf()
**
** Returns:       void
**
** Side Effects:  none
**
** N.b., this function assumes the global variables g_dwSpewFlags, g_uSpewSev,
** g_pcszSpewModule, g_pcszSpewFile, and g_pcszSpewLine are filled in.
**
** SpewOut() uses global variables to set the message parameters in order to
** permit printf()-style macro expansion.
*/
PUBLIC_CODE void SpewOut(PCSTR pcszFormat, ...)
{
   ASSERT(IS_VALID_STRING_PTR(pcszFormat, CSTR));

   ASSERT(FLAGS_ARE_VALID(g_dwSpewFlags, ALL_SPEW_FLAGS));
   ASSERT(IsValidSpewSev(g_uSpewSev));
   ASSERT(IS_FLAG_CLEAR(g_dwSpewFlags, SPEW_FL_SPEW_LOCATION) ||
          (IS_VALID_STRING_PTR(g_pcszSpewFile, CSTR) &&
           IS_VALID_STRING_PTR(g_pcszSpewModule, CSTR)));

   if (g_uSpewSev != SPEW_TRACE || IS_FLAG_SET(s_dwDebugModuleFlags, DEBUG_DFL_ENABLE_TRACE_MESSAGES))
   {
      int nMsgLen;
      char rgchMsg[1024];

      va_list nextArg;


      if (IS_FLAG_SET(g_dwSpewFlags, SPEW_FL_SPEW_PREFIX))
      {
         ULONG ulcStackDepth;
         char chReplaced;
         PSTR pszSpewLeaderEnd;
         PCSTR pcszSpewPrefix;

         /* Build spew message space leader string. */

         ulcStackDepth = GetStackDepth();

         if (ulcStackDepth < sizeof(SrgchSpewLeader))
            pszSpewLeaderEnd = SrgchSpewLeader + ulcStackDepth;
         else
            pszSpewLeaderEnd = SrgchSpewLeader + sizeof(SrgchSpewLeader) - 1;

         chReplaced = *pszSpewLeaderEnd;
         *pszSpewLeaderEnd = '\0';

         /* Determine spew prefix. */

         switch (g_uSpewSev)
         {
            case SPEW_TRACE:
               pcszSpewPrefix = "t";
               break;

            case SPEW_WARNING:
               pcszSpewPrefix = "w";
               break;

            case SPEW_ERROR:
               pcszSpewPrefix = "e";
               break;

            case SPEW_FATAL:
               pcszSpewPrefix = "f";
               break;

            default:
               pcszSpewPrefix = "u";
               ERROR_OUT(("SpewOut(): Invalid g_uSpewSev %u.",
                          g_uSpewSev));
               break;
         }

         nMsgLen = wsprintf(rgchMsg, "%s%s %s ", SrgchSpewLeader, pcszSpewPrefix, g_pcszSpewModule);

         /* Restore spew leader. */

         *pszSpewLeaderEnd = chReplaced;

         ASSERT(nMsgLen < sizeof(rgchMsg));
      }
      else
         nMsgLen = 0;

      /* Append thread ID. */

      if (IS_FLAG_SET(s_dwDebugModuleFlags, DEBUG_DFL_DUMP_THREAD_ID))
      {
         nMsgLen += wsprintf(rgchMsg + nMsgLen, "%#lx ", GetCurrentThreadId());

         ASSERT(nMsgLen < sizeof(rgchMsg));
      }

      /* Build position string. */

      if (IS_FLAG_SET(g_dwSpewFlags, SPEW_FL_SPEW_LOCATION))
      {
         nMsgLen += wsprintf(rgchMsg + nMsgLen, "(%s line %u): ", g_pcszSpewFile, g_uSpewLine);

         ASSERT(nMsgLen < sizeof(rgchMsg));
      }

      /* Append message string. */


      va_start(nextArg, pcszFormat);
      nMsgLen += wvsprintf(rgchMsg + nMsgLen, pcszFormat, nextArg);
      va_end(nextArg);

      ASSERT(nMsgLen < sizeof(rgchMsg));

      if (g_uSpewSev == SPEW_ERROR ||
          g_uSpewSev == SPEW_FATAL)
      {
         nMsgLen += wsprintf(rgchMsg + nMsgLen, " (GetLastError() == %lu)", GetLastError());

         ASSERT(nMsgLen < sizeof(rgchMsg));
      }

      nMsgLen += wsprintf(rgchMsg + nMsgLen, "\r\n");

      ASSERT(nMsgLen < sizeof(rgchMsg));

      OutputDebugString(rgchMsg);

      if (IS_FLAG_SET(s_dwDebugModuleFlags, DEBUG_DFL_LOG_TRACE_MESSAGES))
         LogOutputDebugString(rgchMsg);
   }

   /* Break here on errors and fatal errors. */
#ifndef MAINWIN
   if (g_uSpewSev == SPEW_ERROR || g_uSpewSev == SPEW_FATAL)
      DebugBreak();
#endif
   return;
}

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\dataobj.cpp ===
/*
 * dataobj.cpp - IDataObject implementation for URL class.
 */


/* Headers
 **********/

#include "project.hpp"
#pragma hdrstop

#include "enumfmte.hpp"


/* Global Variables
 *******************/

/* registered clipboard formats */

PUBLIC_DATA UINT g_cfURL = 0;
PUBLIC_DATA UINT g_cfFileGroupDescriptor = 0;
PUBLIC_DATA UINT g_cfFileContents = 0;


/* Module Variables
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

PRIVATE_DATA char s_szURLCF[]                   = "UniformResourceLocator";
PRIVATE_DATA char s_szFileGroupDescriptorCF[]   = CFSTR_FILEDESCRIPTOR;
PRIVATE_DATA char s_szFileContentsCF[]          = CFSTR_FILECONTENTS;

#pragma data_seg()


/***************************** Private Functions *****************************/


BOOL RegisterClipboardFormats(void)
{
   g_cfURL                 = RegisterClipboardFormat(s_szURLCF);
   g_cfFileGroupDescriptor = RegisterClipboardFormat(s_szFileGroupDescriptorCF);
   g_cfFileContents        = RegisterClipboardFormat(s_szFileContentsCF);

   return(g_cfURL &&
          g_cfFileGroupDescriptor &&
          g_cfFileContents);
}


/****************************** Public Functions *****************************/

PUBLIC_CODE void ExitDataObjectModule(void)
{
   return;
}


/********************************** Methods **********************************/


HRESULT STDMETHODCALLTYPE InternetShortcut::GetData(PFORMATETC pfmtetc,
                                                    PSTGMEDIUM pstgmed)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::GetData);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
   ASSERT(IS_VALID_WRITE_PTR(pstgmed, STGMEDIUM));

   // Ignore pfmtetc.ptd.  All supported data formats are device-independent.

   ZeroMemory(pstgmed, sizeof(*pstgmed));

   if (pfmtetc->dwAspect == DVASPECT_CONTENT)
   {
      if (pfmtetc->cfFormat == g_cfURL)
         hr = (pfmtetc->lindex == -1) ? TransferUniformResourceLocator(pfmtetc,
                                                                       pstgmed)
                                      : DV_E_LINDEX;
      else if (pfmtetc->cfFormat == CF_TEXT)
         hr = (pfmtetc->lindex == -1) ? TransferText(pfmtetc, pstgmed)
                                      : DV_E_LINDEX;
      else if (pfmtetc->cfFormat == g_cfFileGroupDescriptor)
         hr = (pfmtetc->lindex == -1) ? TransferFileGroupDescriptor(pfmtetc,
                                                                    pstgmed)
                                      : DV_E_LINDEX;
      else if (pfmtetc->cfFormat == g_cfFileContents)
         hr = (! pfmtetc->lindex) ? TransferFileContents(pfmtetc, pstgmed)
                                  : DV_E_LINDEX;
      else
         hr = DV_E_FORMATETC;
   }
   else
      hr = DV_E_DVASPECT;

   if (hr == S_OK)
      TRACE_OUT(("InternetShortcut::GetData(): Returning clipboard format %s.",
                 GetClipboardFormatNameString(pfmtetc->cfFormat)));
   else
      TRACE_OUT(("InternetShortcut::GetData(): Failed to return clipboard format %s.",
                 GetClipboardFormatNameString(pfmtetc->cfFormat)));

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(FAILED(hr) ||
          IS_VALID_STRUCT_PTR(pstgmed, CSTGMEDIUM));

   DebugExitHRESULT(InternetShortcut::GetData, hr);

   return(hr);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE InternetShortcut::GetDataHere(PFORMATETC pfmtetc,
                                                        PSTGMEDIUM pstgpmed)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::GetDataHere);
   ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
   ASSERT(IS_VALID_STRUCT_PTR(pstgpmed, CSTGMEDIUM));

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   TRACE_OUT(("InternetShortcut::GetDataHere(): Failed to return clipboard format %s.",
              GetClipboardFormatNameString(pfmtetc->cfFormat)));

   hr = DV_E_FORMATETC;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRUCT_PTR(pstgpmed, CSTGMEDIUM));

   DebugExitHRESULT(InternetShortcut::GetDataHere, hr);

   return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


HRESULT STDMETHODCALLTYPE InternetShortcut::QueryGetData(PFORMATETC pfmtetc)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::QueryGetData);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));

   TRACE_OUT(("InternetShortcut::QueryGetData(): Asked for clipboard format %s.",
              GetClipboardFormatNameString(pfmtetc->cfFormat)));

   // Ignore pfmtetc.ptd.  All supported data formats are device-independent.

   if (pfmtetc->dwAspect == DVASPECT_CONTENT)
   {
      if (IS_FLAG_SET(pfmtetc->tymed, TYMED_HGLOBAL))
      {
         if (pfmtetc->cfFormat == g_cfURL)
            hr = (pfmtetc->lindex == -1) ? S_OK : DV_E_LINDEX;
         else if (pfmtetc->cfFormat == CF_TEXT)
            hr = (pfmtetc->lindex == -1) ? S_OK : DV_E_LINDEX;
         else if (pfmtetc->cfFormat == g_cfFileGroupDescriptor)
            hr = (pfmtetc->lindex == -1) ? S_OK : DV_E_LINDEX;
         else if (pfmtetc->cfFormat == g_cfFileContents)
            hr = (! pfmtetc->lindex) ? S_OK : DV_E_LINDEX;
         else
            hr = DV_E_FORMATETC;
      }
      else
         hr = DV_E_TYMED;
   }
   else
      hr = DV_E_DVASPECT;

   if (hr == S_OK)
      TRACE_OUT(("InternetShortcut::QueryGetData(): Clipboard format %s supported.",
                 GetClipboardFormatNameString(pfmtetc->cfFormat)));
   else
      TRACE_OUT(("InternetShortcut::QueryGetData(): Clipboard format %s not supported.",
                 GetClipboardFormatNameString(pfmtetc->cfFormat)));

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::QueryGetData, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::GetCanonicalFormatEtc(
                                                         PFORMATETC pfmtetcIn,
                                                         PFORMATETC pfmtetcOut)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::GetCanonicalFormatEtc);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRUCT_PTR(pfmtetcIn, CFORMATETC));
   ASSERT(IS_VALID_WRITE_PTR(pfmtetcOut, FORMATETC));

   hr = QueryGetData(pfmtetcIn);

   if (hr == S_OK)
   {
      *pfmtetcOut = *pfmtetcIn;

      if (pfmtetcIn->ptd == NULL)
         hr = DATA_S_SAMEFORMATETC;
      else
      {
         pfmtetcIn->ptd = NULL;
         ASSERT(hr == S_OK);
      }
   }
   else
      ZeroMemory(pfmtetcOut, sizeof(*pfmtetcOut));

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(FAILED(hr) ||
          IS_VALID_STRUCT_PTR(pfmtetcOut, CFORMATETC));

   DebugExitHRESULT(InternetShortcut::GetCanonicalFormatEtc, hr);

   return(hr);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE InternetShortcut::SetData(PFORMATETC pfmtetc,
                                                    PSTGMEDIUM pstgmed,
                                                    BOOL bRelease)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::SetData);

   // bRelease may be any value.

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
   ASSERT(IS_VALID_STRUCT_PTR(pstgmed, CSTGMEDIUM));

   hr = DV_E_FORMATETC;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::SetData, hr);

   return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


HRESULT STDMETHODCALLTYPE InternetShortcut::EnumFormatEtc(
                                                      DWORD dwDirFlags,
                                                      PIEnumFORMATETC *ppiefe)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::EnumFormatEtc);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(FLAGS_ARE_VALID(dwDirFlags, ALL_DATADIR_FLAGS));
   ASSERT(IS_VALID_WRITE_PTR(ppiefe, PIEnumFORMATETC));

   *ppiefe = NULL;

   if (dwDirFlags == DATADIR_GET)
   {
      FORMATETC rgfmtetc[] =
      {
         { 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
         { 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
         { 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
         { 0, NULL, DVASPECT_CONTENT,  0, TYMED_HGLOBAL }
      };
      PEnumFormatEtc pefe;

      rgfmtetc[0].cfFormat = (CLIPFORMAT)g_cfURL;
      rgfmtetc[1].cfFormat = CF_TEXT;
      rgfmtetc[2].cfFormat = (CLIPFORMAT)g_cfFileGroupDescriptor;
      rgfmtetc[3].cfFormat = (CLIPFORMAT)g_cfFileContents;

      pefe = new ::EnumFormatEtc(rgfmtetc, ARRAY_ELEMENTS(rgfmtetc));

      if (pefe)
      {
         hr = pefe->Status();

         if (hr == S_OK)
            *ppiefe = pefe;
         else
         {
            delete pefe;
            pefe = NULL;
         }
      }
      else
         hr = E_OUTOFMEMORY;
   }
   else
      // FEATURE: Implement IDataObject::SetData() and add support for
      // DATADIR_SET here.
      hr = E_NOTIMPL;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT((hr == S_OK &&
           IS_VALID_INTERFACE_PTR(*ppiefe, IEnumFORMATETC)) ||
          (FAILED(hr) &&
           ! *ppiefe));

   DebugExitHRESULT(InternetShortcut::EnumFormatEtc, hr);

   return(hr);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE InternetShortcut::DAdvise(PFORMATETC pfmtetc,
                                                    DWORD dwAdviseFlags,
                                                    PIAdviseSink piadvsink,
                                                    PDWORD pdwConnection)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::DAdvise);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
   ASSERT(FLAGS_ARE_VALID(dwAdviseFlags, ALL_ADVISE_FLAGS));
   ASSERT(IS_VALID_INTERFACE_PTR(piadvsink, IAdviseSink));
   ASSERT(IS_VALID_WRITE_PTR(pdwConnection, DWORD));

   *pdwConnection = 0;
   hr = OLE_E_ADVISENOTSUPPORTED;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT((hr == S_OK &&
           *pdwConnection) ||
          (FAILED(hr) &&
           ! *pdwConnection));

   DebugExitHRESULT(InternetShortcut::DAdvise, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::DUnadvise(DWORD dwConnection)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::DUnadvise);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(dwConnection);

   hr = OLE_E_ADVISENOTSUPPORTED;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::DUnadvise, hr);

   return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


HRESULT STDMETHODCALLTYPE InternetShortcut::EnumDAdvise(PIEnumSTATDATA *ppiesd)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::EnumDAdvise);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_WRITE_PTR(ppiesd, PIEnumSTATDATA));

   *ppiesd = NULL;
   hr = OLE_E_ADVISENOTSUPPORTED;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT((hr == S_OK &&
           IS_VALID_INTERFACE_PTR(*ppiesd, IEnumSTATDATA)) ||
          (FAILED(hr) &&
           ! *ppiesd));

   DebugExitHRESULT(InternetShortcut::EnumDAdvise, hr);

   return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\dllinit.cpp ===
/*
 * dllinit.cpp - Initialization and termination routines.
 */


/* Headers
 **********/

#include "project.hpp"
#pragma hdrstop

#include "autodial.hpp"
#include "inetcpl.h"
#include "init.h"

#ifdef _X86_
BOOL g_bRunningOnNT = FALSE;
#endif

/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL MyAttachProcess(HMODULE hmod);
PRIVATE_CODE BOOL MyDetachProcess(HMODULE hmod);


/* Global Variables
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

/* serialization control structure */

PUBLIC_DATA CSERIALCONTROL g_cserctrl =
{
   MyAttachProcess,
   MyDetachProcess,
   NULL,
   NULL
};

#pragma data_seg()

#ifdef DEBUG

#pragma data_seg(DATA_SEG_READ_ONLY)

/* .ini file name and section used by inifile.c!SetIniSwitches() */

PUBLIC_DATA PCSTR g_pcszIniFile = "ohare.ini";
PUBLIC_DATA PCSTR g_pcszIniSection = "URLDebugOptions";

/* module name used by debspew.c!SpewOut() */

PUBLIC_DATA PCSTR g_pcszSpewModule = "URL";

#pragma data_seg()

#endif


/***************************** Private Functions *****************************/


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

PRIVATE_CODE BOOL MyAttachProcess(HMODULE hmod)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hmod, MODULE));

   DebugEntry(MyAttachProcess);

   bResult = (InitDataObjectModule());

#ifdef _X86_
   // Remember whether we're running on NT or not
   g_bRunningOnNT = (0 == (GetVersion() & 0x80000000));
#endif

#ifndef DEBUG

   // We don't need to get called on DLL_THREAD_ATTACH, etc.  This
   // is for perf gains.
   DisableThreadLibraryCalls(hmod);

#endif

   ASSERT(NULL == g_cserctrl.AttachThread &&
          NULL == g_cserctrl.DetachThread);

   DebugExitBOOL(MyAttachProcess, bResult);

   return(bResult);
}


PRIVATE_CODE BOOL MyDetachProcess(HMODULE hmod)
{
   BOOL bResult = TRUE;

   ASSERT(IS_VALID_HANDLE(hmod, MODULE));

   DebugEntry(MyDetachProcess);

   ExitInternetCPLModule();

   ExitDataObjectModule();

   DebugExitBOOL(MyDetachProcess, bResult);

   return(bResult);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/****************************** Public Functions *****************************/


#ifdef DEBUG

PUBLIC_CODE BOOL SetAllIniSwitches(void)
{
   BOOL bResult;

   bResult = SetDebugModuleIniSwitches();
   bResult = SetSerialModuleIniSwitches() && bResult;

   return(bResult);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\enumfmte.cpp ===
/*
 * enumfmte.cpp - EnumFormatEtc class implementation.
 */


/* Headers
 **********/

#include "project.hpp"
#pragma hdrstop

#include "enumfmte.hpp"


/***************************** Private Functions *****************************/


#ifdef DEBUG

PRIVATE_CODE BOOL IsValidArrayOfFORMATETCs(CFORMATETC rgcfmtetc[],
                                           ULONG ulcFormats)
{
   BOOL bResult = TRUE;
   ULONG ul;

   for (ul = 0; ul < ulcFormats; ul++)
      bResult = (EVAL(IS_VALID_STRUCT_PTR(&(rgcfmtetc[ul]), CFORMATETC)) &&
                 bResult);

   return(bResult);
}


PRIVATE_CODE BOOL IsValidPCEnumFormatEtc(PCEnumFormatEtc pcefe)
{
   return(IS_VALID_READ_PTR(pcefe, CEnumFormatEtc) &&
          EVAL(IsValidArrayOfFORMATETCs(pcefe->m_pfmtetc, pcefe->m_ulcFormats)) &&
          EVAL(pcefe->m_uliCurrent <= pcefe->m_ulcFormats) &&
          IS_VALID_STRUCT_PTR((PCRefCount)pcefe, CRefCount) &&
          IS_VALID_INTERFACE_PTR((PCIEnumFORMATETC)pcefe, IEnumFORMATETC));
}

#endif


/********************************** Methods **********************************/


EnumFormatEtc::EnumFormatEtc(CFORMATETC rgcfmtetc[], ULONG ulcFormats)
{
   DebugEntry(EnumFormatEtc::EnumFormatEtc);

   // Don't validate this until after construction.

   ASSERT(IsValidArrayOfFORMATETCs(rgcfmtetc, ulcFormats));

   m_pfmtetc = new(FORMATETC[ulcFormats]);

   if (m_pfmtetc)
   {
      CopyMemory(m_pfmtetc, rgcfmtetc, ulcFormats * sizeof(rgcfmtetc[0]));
      m_ulcFormats = ulcFormats;
   }
   else
      m_ulcFormats = 0;

   m_uliCurrent = 0;

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   DebugExitVOID(EnumFormatEtc::EnumFormatEtc);

   return;
}


EnumFormatEtc::~EnumFormatEtc(void)
{
   DebugEntry(EnumFormatEtc::~EnumFormatEtc);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   if (m_pfmtetc)
   {
      delete m_pfmtetc;
      m_pfmtetc = NULL;
   }

   m_ulcFormats = 0;
   m_uliCurrent = 0;

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   DebugExitVOID(EnumFormatEtc::~EnumFormatEtc);

   return;
}


ULONG STDMETHODCALLTYPE EnumFormatEtc::AddRef(void)
{
   ULONG ulcRef;

   DebugEntry(EnumFormatEtc::AddRef);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   ulcRef = RefCount::AddRef();

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   DebugExitULONG(EnumFormatEtc::AddRef, ulcRef);

   return(ulcRef);
}


ULONG STDMETHODCALLTYPE EnumFormatEtc::Release(void)
{
   ULONG ulcRef;

   DebugEntry(EnumFormatEtc::Release);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   ulcRef = RefCount::Release();

   DebugExitULONG(EnumFormatEtc::Release, ulcRef);

   return(ulcRef);
}


HRESULT STDMETHODCALLTYPE EnumFormatEtc::QueryInterface(REFIID riid,
                                                       PVOID *ppvObject)
{
   HRESULT hr = S_OK;

   DebugEntry(EnumFormatEtc::QueryInterface);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));
   ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   if (riid == IID_IEnumFORMATETC)
   {
      *ppvObject = (PIEnumFORMATETC)this;
      ASSERT(IS_VALID_INTERFACE_PTR((PIEnumFORMATETC)*ppvObject, IEnumFORMATETC));
      TRACE_OUT(("EnumFormatEtc::QueryInterface(): Returning IEnumFORMATETC."));
   }
   else if (riid == IID_IUnknown)
   {
      *ppvObject = (PIUnknown)this;
      ASSERT(IS_VALID_INTERFACE_PTR((PIUnknown)*ppvObject, IUnknown));
      TRACE_OUT(("EnumFormatEtc::QueryInterface(): Returning IUnknown."));
   }
   else
   {
      *ppvObject = NULL;
      hr = E_NOINTERFACE;
      TRACE_OUT(("EnumFormatEtc::QueryInterface(): Called on unknown interface."));
   }

   if (hr == S_OK)
      AddRef();

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));
#ifndef MAINWIN
// INTERFACE is changed to CINTERFACE which is not defined ??
// LOOK AT THIS LATER.
   ASSERT(FAILED(hr) ||
          IS_VALID_INTERFACE_PTR(*ppvObject, INTERFACE));
#endif

   DebugExitHRESULT(EnumFormatEtc::QueryInterface, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE EnumFormatEtc::Next(ULONG ulcToFetch,
                                              PFORMATETC pfmtetc,
                                              PULONG pulcFetched)
{
   HRESULT hr = S_FALSE;
   ULONG ulcFetched;

   DebugEntry(EnumFormatEtc::Next);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   if (m_uliCurrent < m_ulcFormats)
   {
      ULONG ulcCanFetch = m_ulcFormats - m_uliCurrent;

      ulcFetched = min(ulcCanFetch, ulcToFetch);

      CopyMemory(pfmtetc, &(m_pfmtetc[m_uliCurrent]),
                 ulcFetched * sizeof(*pfmtetc));

      m_uliCurrent += ulcFetched;
   }
   else
      // End of the list.
      ulcFetched = 0;

   if (pulcFetched)
      *pulcFetched = ulcFetched;
   else
      ASSERT(ulcToFetch == 1);

   if (ulcFetched < ulcToFetch)
      hr = S_FALSE;
   else
   {
      ASSERT(ulcFetched == ulcToFetch);
      hr = S_OK;
   }

   TRACE_OUT(("EnumFormatEtc::Next(): Fetched %lu FORMATETCs.",
              ulcFetched));

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));
   ASSERT((((hr == S_OK &&
             EVAL((! pulcFetched &&
                   ulcToFetch == 1) ||
                  *pulcFetched == ulcToFetch)) ||
            (hr == S_FALSE &&
             EVAL((! pulcFetched &&
                   ulcToFetch == 1) ||
                  *pulcFetched < ulcToFetch))) &&
            EVAL((! pulcFetched &&
                  IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC)) ||
                 IsValidArrayOfFORMATETCs(pfmtetc, *pulcFetched))) ||
          (FAILED(hr) &&
           EVAL((! pulcFetched &&
                 ulcToFetch == 1) ||
                ! *pulcFetched)));

   DebugExitHRESULT(EnumFormatEtc::Next, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE EnumFormatEtc::Skip(ULONG ulcToSkip)
{
   HRESULT hr;

   DebugEntry(EnumFormatEtc::Skip);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   if (ulcToSkip <= m_ulcFormats - m_uliCurrent)
   {
      m_uliCurrent += ulcToSkip;
      hr = S_OK;

      TRACE_OUT(("EnumFormatEtc::Skip(): Skipped %lu FORMATETCs, as requested.",
                 ulcToSkip));
   }
   else
   {
      TRACE_OUT(("EnumFormatEtc::Skip(): Skipped %lu of %lu FORMATETCs.",
                 m_ulcFormats - m_uliCurrent,
                 ulcToSkip));

      m_uliCurrent = m_ulcFormats;
      hr = S_FALSE;
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));
   ASSERT((hr == S_OK &&
           m_uliCurrent <= m_ulcFormats) ||
          (hr == S_FALSE &&
           m_uliCurrent == m_ulcFormats));

   DebugExitHRESULT(EnumFormatEtc::Skip, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE EnumFormatEtc::Reset(void)
{
   HRESULT hr;

   DebugEntry(EnumFormatEtc::Reset);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   m_uliCurrent = 0;
   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));
   ASSERT(hr == S_OK &&
          ! m_uliCurrent);

   DebugExitHRESULT(EnumFormatEtc::Reset, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE EnumFormatEtc::Clone(PIEnumFORMATETC *ppiefe)
{
   HRESULT hr;
   PEnumFormatEtc pefe;

   DebugEntry(EnumFormatEtc::Clone);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   pefe = new EnumFormatEtc(m_pfmtetc, m_ulcFormats);

   if (pefe)
   {
      hr = pefe->Status();

      if (hr == S_OK)
      {
         hr = pefe->Skip(m_uliCurrent);

         if (hr == S_OK)
            *ppiefe = pefe;
         else
            hr = E_UNEXPECTED;
      }

      if (hr != S_OK)
      {
         delete pefe;
         pefe = NULL;
      }
   }
   else
      hr = E_OUTOFMEMORY;

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));
   ASSERT((hr == S_OK &&
           IS_VALID_INTERFACE_PTR(*ppiefe, IEnumFORMATETC)) ||
          (FAILED(hr) &&
           ! *ppiefe));

   DebugExitHRESULT(EnumFormatEtc::Clone, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE EnumFormatEtc::Status(void)
{
   HRESULT hr;

   DebugEntry(EnumFormatEtc::Status);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   hr = (m_pfmtetc ? S_OK : E_OUTOFMEMORY);

   ASSERT(IS_VALID_STRUCT_PTR(this, CEnumFormatEtc));

   DebugExitHRESULT(EnumFormatEtc::Status, hr);

   return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\dialmsg.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//	DIALMSG.H - window messages for dial monitor app
//			
//

//	HISTORY:
//	
//	4/19/95		jeremys		Created.
//

#ifndef _DIALMSG_H_
#define _DIALMSG_H_

#define WM_DIALMON_FIRST	WM_USER+100

// message sent to dial monitor app window indicating that there has been
// winsock activity and dial monitor should reset its idle timer
#define WM_WINSOCK_ACTIVITY		WM_DIALMON_FIRST + 0

// message sent to dial monitor app window when user changes timeout through
// UI, indicating that timeout value or status has changed
#define WM_REFRESH_SETTINGS		WM_DIALMON_FIRST + 1

// message sent to dial monitor app window to set the name of the connectoid
// to monitor and eventually disconnect.  lParam should be an LPSTR that
// points to the name of the connectoid.
#define WM_SET_CONNECTOID_NAME	WM_DIALMON_FIRST + 2

// message sent to dial monitor app window when app exits
#define WM_IEXPLORER_EXITING		WM_DIALMON_FIRST + 3

#endif // _DIALMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\extricon.h ===
/*
 * extricon.h - IExtractIcon implementation description.
 */


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Global Constants
 *******************/

/* extricon.cpp */

extern const char g_cszURLProtocolHandlersKey[];
extern const char g_cszURLDefaultIconKey[];
extern const HKEY g_hkeyURLSettings;


/* Prototypes
 *************/

/* extricon.cpp */

extern int StringToInt(PCSTR pcsz);
extern BOOL IsWhiteSpace(char ch);
extern BOOL AnyMeat(PCSTR pcsz);
extern HRESULT CopyURLProtocol(PCSTR pcszURL, PSTR *ppszProtocol);
extern HRESULT CopyURLSuffix(PCSTR pcszURL, PSTR *ppszSuffix);
extern HRESULT GetProtocolKey(PCSTR pcszProtocol, PCSTR pcszSubKey, PSTR *pszKey);
extern HRESULT GetURLKey(PCSTR pcszURL, PCSTR pcszSubKey, PSTR *pszKey);


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\extricon.cpp ===
/*
 * extricon.cpp - IExtractIcon implementation for URL class.
 */


/* Headers
 **********/

#include "project.hpp"
#pragma hdrstop

#include "assoc.h"


/* Global Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

extern const char g_cszURLDefaultIconKey[]         = "InternetShortcut\\DefaultIcon";

extern const HKEY g_hkeyURLSettings                = HKEY_LOCAL_MACHINE;

#pragma data_seg()


/* Module Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

PRIVATE_DATA const char s_cszDefaultIconSubKey[]   = "DefaultIcon";

PRIVATE_DATA const char s_cszGenericURLIconFile[]  = "url.dll";
PRIVATE_DATA const int s_ciGenericURLIcon          = 0;

// IExtractIcon::GetIconLocation() flag combinations

PRIVATE_DATA const int ALL_GIL_IN_FLAGS            = (GIL_OPENICON |
                                                      GIL_FORSHELL);

PRIVATE_DATA const int ALL_GIL_OUT_FLAGS           = (GIL_SIMULATEDOC |
                                                      GIL_PERINSTANCE |
                                                      GIL_PERCLASS |
                                                      GIL_NOTFILENAME |
                                                      GIL_DONTCACHE);

#pragma data_seg()


/***************************** Private Functions *****************************/


/*
** ParseIconEntry()
**
**
**
** Arguments:
**
** Returns:       S_OK if icon entry parsed successfully.
**                E_FAIL if not.
**
** Side Effects:  The contents of pszIconEntry are destroyed.
**
** pszIconEntry and pszIconFile may be the same.
*/
PRIVATE_CODE HRESULT ParseIconEntry(PSTR pszIconEntry, PSTR pszIconFile,
                                    UINT ucbIconFileBufLen, PINT pniIcon)
{
   HRESULT hr;
   PSTR pszComma;

   ASSERT(IS_VALID_STRING_PTR(pszIconEntry, STR));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszIconFile, STR, ucbIconFileBufLen));
   ASSERT(IS_VALID_WRITE_PTR(pniIcon, INT));

   pszComma = StrChr(pszIconEntry, ',');

   if (pszComma)
   {
      *pszComma++ = '\0';
      TrimWhiteSpace(pszComma);
      *pniIcon = StringToInt(pszComma);
   }
   else
   {
      *pniIcon = 0;

      WARNING_OUT(("ParseIconEntry(): No icon index in entry %s.  Using icon index 0.",
                   pszIconEntry));
   }

   TrimWhiteSpace(pszIconEntry);

   if ((UINT)lstrlen(pszIconEntry) < ucbIconFileBufLen)
   {
      lstrcpy(pszIconFile, pszIconEntry);
      hr = S_OK;

      TRACE_OUT(("ParseIconEntry(): Parsed icon file %s, index %d.",
                 pszIconFile,
                 *pniIcon));
   }
   else
   {
      hr = S_FALSE;

      // (+ 1) for null terminator.

      WARNING_OUT(("ParseIconEntry(): Icon file buffer too small for icon file %s (%u bytes supplied, %lu bytes required).",
                   pszIconEntry,
                   ucbIconFileBufLen,
                   lstrlen(pszIconEntry) + 1));
   }

   ASSERT(IsValidIconIndex(hr, pszIconFile, ucbIconFileBufLen, *pniIcon));

   return(hr);
}


/*
** GetURLIcon()
**
**
**
** Arguments:
**
** Returns:       S_OK if icon information retrieved successfully.
**                S_FALSE if no icon entry for this URL.
**                Otherwise error.
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT GetURLIcon(HKEY hkey, PCSTR pcszKey, PSTR pszIconFile,
                                UINT ucbIconFileBufLen, PINT pniIcon)
{
   HRESULT hr;
   DWORD dwcbLen = ucbIconFileBufLen;

   ASSERT(IS_VALID_HANDLE(hkey, KEY));
   ASSERT(IS_VALID_STRING_PTR(pcszKey, CSTR));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszIconFile, STR, ucbIconFileBufLen));
   ASSERT(IS_VALID_WRITE_PTR(pniIcon, INT));

   if (GetDefaultRegKeyValue(hkey, pcszKey, pszIconFile, &dwcbLen)
       == ERROR_SUCCESS)
      hr = ParseIconEntry(pszIconFile, pszIconFile, ucbIconFileBufLen,
                          pniIcon);
   else
   {
      // No protocol handler.

      hr = S_FALSE;

      TRACE_OUT(("GetURLIcon(): Couldn't get default value for key %s.",
                 pcszKey));
   }

   ASSERT(IsValidIconIndex(hr, pszIconFile, ucbIconFileBufLen, *pniIcon));

   return(hr);
}


/*
** GetFallBackGenericURLIcon()
**
**
**
** Arguments:
**
** Returns:       S_OK if fallback generic icon information retrieved
**                successfully.
**                E_FAIL if not.
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT GetFallBackGenericURLIcon(PSTR pszIconFile,
                                               UINT ucbIconFileBufLen,
                                               PINT pniIcon)
{
   HRESULT hr;

   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszIconFile, STR, ucbIconFileBufLen));
   ASSERT(IS_VALID_WRITE_PTR(pniIcon, INT));

   // Fall back to first icon in this module.

   if (ucbIconFileBufLen >= sizeof(s_cszGenericURLIconFile))
   {
      lstrcpy(pszIconFile, s_cszGenericURLIconFile);
      *pniIcon = s_ciGenericURLIcon;

      hr = S_OK;

      TRACE_OUT(("GetFallBackGenericURLIcon(): Using generic URL icon file %s, index %d.",
                 s_cszGenericURLIconFile,
                 s_ciGenericURLIcon));
   }
   else
   {
      hr = E_FAIL;

      WARNING_OUT(("GetFallBackGenericURLIcon(): Icon file buffer too small for generic icon file %s (%u bytes supplied, %lu bytes required).",
                   s_cszGenericURLIconFile,
                   ucbIconFileBufLen,
                   sizeof(s_cszGenericURLIconFile)));
   }

   ASSERT(IsValidIconIndex(hr, pszIconFile, ucbIconFileBufLen, *pniIcon));

   return(hr);
}


/*
** GetGenericURLIcon()
**
**
**
** Arguments:
**
** Returns:       S_OK if generic icon information retrieved successfully.
**                Otherwise error.
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT GetGenericURLIcon(PSTR pszIconFile,
                                       UINT ucbIconFileBufLen, PINT pniIcon)
{
   HRESULT hr;

   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszIconFile, STR, ucbIconFileBufLen));
   ASSERT(IS_VALID_WRITE_PTR(pniIcon, INT));

   hr = GetURLIcon(g_hkeyURLProtocols, g_cszURLDefaultIconKey, pszIconFile,
                   ucbIconFileBufLen, pniIcon);

   if (hr == S_FALSE)
      hr = GetFallBackGenericURLIcon(pszIconFile, ucbIconFileBufLen, pniIcon);

   ASSERT(IsValidIconIndex(hr, pszIconFile, ucbIconFileBufLen, *pniIcon));

   return(hr);
}


/****************************** Public Functions *****************************/


/*
** StringToInt()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** Stops at first non-digit character encountered.
*/
PUBLIC_CODE int StringToInt(PCSTR pcsz)
{
   int nResult = 0;
   BOOL bNegative;
#ifdef DEBUG
   PCSTR pcszStart = pcsz;
#endif

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   if (*pcsz == '-')
   {
      bNegative = TRUE;
      pcsz++;
   }
   else
      bNegative = FALSE;

   while (IsDigit(*pcsz))
   {
      ASSERT(nResult <= INT_MAX / 10);
      nResult *= 10;
      ASSERT(nResult <= INT_MAX - (*pcsz - '0'));
      nResult += *pcsz++ - '0';
   }

   if (*pcsz) {
      WARNING_OUT(("StringToInt(): Stopped at non-digit character %c in string %s.",
                   *pcsz,
                   pcszStart));
   }

   // nResult may be any value.

   return(bNegative ? - nResult : nResult);
}


PUBLIC_CODE BOOL IsWhiteSpace(char ch)
{
   return((ch && StrChr(g_cszWhiteSpace, ch)) ? TRUE : FALSE);
}


PUBLIC_CODE BOOL AnyMeat(PCSTR pcsz)
{
   ASSERT(! pcsz ||
          IS_VALID_STRING_PTR(pcsz, CSTR));

   return(pcsz ? StrSpn(pcsz, g_cszWhiteSpace) < lstrlen(pcsz) : FALSE);
}


PUBLIC_CODE HRESULT CopyURLProtocol(PCSTR pcszURL, PSTR *ppszProtocol)
{
   HRESULT hr;
   PARSEDURL pu;

   ASSERT(IS_VALID_STRING_PTR(pcszURL, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszProtocol, PSTR));

   *ppszProtocol = NULL;

   pu.cbSize = sizeof(pu);
   hr = ParseURL(pcszURL, &pu);

   if (hr == S_OK)
   {
      // (+ 1) for null terminator.
      *ppszProtocol = new(char[pu.cchProtocol + 1]);

      if (*ppszProtocol)
      {
         // (+ 1) for null terminator.
         lstrcpyn(*ppszProtocol, pu.pszProtocol, pu.cchProtocol + 1);
         ASSERT((UINT)lstrlen(*ppszProtocol) == pu.cchProtocol);
      }
      else
         hr = E_OUTOFMEMORY;
   }

   ASSERT(FAILED(hr) ||
          (hr == S_OK &&
           IS_VALID_STRING_PTR(*ppszProtocol, STR)));

   return(hr);
}


PUBLIC_CODE HRESULT CopyURLSuffix(PCSTR pcszURL, PSTR *ppszSuffix)
{
   HRESULT hr;
   PARSEDURL pu;

   ASSERT(IS_VALID_STRING_PTR(pcszURL, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszSuffix, PSTR));

   *ppszSuffix = NULL;

   hr = ParseURL(pcszURL, &pu);

   if (hr == S_OK)
   {
      // (+ 1) for null terminator.
      *ppszSuffix = new(char[pu.cchSuffix + 1]);

      if (*ppszSuffix)
      {
         // (+ 1) for null terminator.
         lstrcpyn(*ppszSuffix, pu.pszSuffix, pu.cchSuffix + 1);
         ASSERT((UINT)lstrlen(*ppszSuffix) == pu.cchSuffix);

         hr = S_OK;
      }
      else
         hr = E_OUTOFMEMORY;
   }

   ASSERT(FAILED(hr) ||
          IS_VALID_STRING_PTR(*ppszSuffix, STR));

   return(hr);
}


PUBLIC_CODE HRESULT GetProtocolKey(PCSTR pcszProtocol, PCSTR pcszSubKey,
                                   PSTR *ppszKey)
{
   HRESULT hr;
   ULONG ulcbKeyLen;

   ASSERT(IS_VALID_STRING_PTR(pcszProtocol, STR));
   ASSERT(IS_VALID_STRING_PTR(pcszSubKey, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszKey, PSTR));

   // (+ 1) for possible separator.
   // (+ 1) for null terminator.
   ulcbKeyLen = lstrlen(pcszProtocol) + 1 + lstrlen(pcszSubKey) + 1;

   *ppszKey = new(char[ulcbKeyLen]);

   if (*ppszKey)
   {
      lstrcpy(*ppszKey, pcszProtocol);
      PathAppend(*ppszKey, pcszSubKey);

      ASSERT((UINT)lstrlen(*ppszKey) < ulcbKeyLen);

      hr = S_OK;
   }
   else
      hr = E_OUTOFMEMORY;

   ASSERT((hr == S_OK &&
             IS_VALID_STRING_PTR(*ppszKey, STR)) ||
          hr == E_OUTOFMEMORY);

   return(hr);
}


PUBLIC_CODE HRESULT GetURLKey(PCSTR pcszURL, PCSTR pcszSubKey, PSTR *pszKey)
{
   HRESULT hr;
   PSTR pszProtocol;

   ASSERT(IS_VALID_STRING_PTR(pcszURL, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszSubKey, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pszKey, PSTR));

   *pszKey = NULL;

   hr = CopyURLProtocol(pcszURL, &pszProtocol);

   if (hr == S_OK)
   {
      hr = GetProtocolKey(pszProtocol, pcszSubKey, pszKey);

      delete pszProtocol;
      pszProtocol = NULL;
   }

   ASSERT((hr == S_OK &&
           IS_VALID_STRING_PTR(*pszKey, STR)) ||
          FAILED(hr));

   return(hr);
}


/********************************** Methods **********************************/


HRESULT STDMETHODCALLTYPE InternetShortcut::GetIconLocation(
                                                      UINT uInFlags,
                                                      PSTR pszIconFile,
                                                      UINT ucbIconFileBufLen,
                                                      PINT pniIcon,
                                                      PUINT puOutFlags)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::GetIconLocation);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(FLAGS_ARE_VALID(uInFlags, ALL_GIL_IN_FLAGS));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszIconFile, STR, ucbIconFileBufLen));
   ASSERT(IS_VALID_WRITE_PTR(pniIcon, INT));
   ASSERT(IS_VALID_WRITE_PTR(puOutFlags, UINT));

   if (IS_FLAG_CLEAR(uInFlags, GIL_OPENICON))
   {
      hr = GetIconLocation(pszIconFile, ucbIconFileBufLen, pniIcon);

      if (hr != S_OK)
      {
         if (m_pszURL)
         {
            PSTR pszDefaultIconKey;

            // Look up URL icon based on protocol handler.

            hr = GetURLKey(m_pszURL, s_cszDefaultIconSubKey,
                           &pszDefaultIconKey);

            if (hr == S_OK)
            {
               hr = GetURLIcon(g_hkeyURLProtocols, pszDefaultIconKey,
                               pszIconFile, ucbIconFileBufLen, pniIcon);

               delete pszDefaultIconKey;
               pszDefaultIconKey = NULL;
            }
         }
         else
            hr = S_FALSE;

         if (hr == S_FALSE)
         {
            // Use generic URL icon.

            hr = GetGenericURLIcon(pszIconFile, ucbIconFileBufLen, pniIcon);

            if (hr == S_OK) {
               TRACE_OUT(("InternetShortcut::GetIconLocation(): Using generic URL icon."));
            }
         }

         if (hr == S_OK)
         {
            char rgchFullPath[MAX_PATH_LEN];

            hr = FullyQualifyPath(pszIconFile, rgchFullPath,
                                  sizeof(rgchFullPath));

            if (hr == S_OK)
            {
               if ((UINT)lstrlen(rgchFullPath) < ucbIconFileBufLen)
                  lstrcpy(pszIconFile, rgchFullPath);
               else
                  hr = E_FAIL;
            }
         }
      }
   }
   else
      // No "open look" icon.
      hr = S_FALSE;

   if (hr != S_OK)
   {
      if (ucbIconFileBufLen > 0)
         *pszIconFile = '\0';

      *pniIcon = 0;
   }

   *puOutFlags = 0;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IsValidIconIndex(hr, pszIconFile, ucbIconFileBufLen, *pniIcon) &&
          FLAGS_ARE_VALID(*puOutFlags, ALL_GIL_OUT_FLAGS));

   DebugExitHRESULT(InternetShortcut::GetIconLocation, hr);

   return(hr);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE InternetShortcut::Extract(PCSTR pcszIconFile,
                                                    UINT uiIcon,
                                                    PHICON phiconLarge,
                                                    PHICON phiconSmall,
                                                    UINT ucIconSize)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::Extract);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRING_PTR(pcszIconFile, CSTR));
   ASSERT(IsValidIconIndex(S_OK, pcszIconFile, MAX_PATH_LEN, uiIcon));
   ASSERT(IS_VALID_WRITE_PTR(phiconLarge, HICON));
   ASSERT(IS_VALID_WRITE_PTR(phiconSmall, HICON));
   // FEATURE: Validate ucIconSize here.

   *phiconLarge = NULL;
   *phiconSmall = NULL;

   // Use caller's default implementation of ExtractIcon().

   hr = S_FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT((hr == S_OK &&
           IS_VALID_HANDLE(*phiconLarge, ICON) &&
           IS_VALID_HANDLE(*phiconSmall, ICON)) ||
          (hr != S_OK &&
           ! *phiconLarge &&
           ! *phiconSmall));

   DebugExitHRESULT(InternetShortcut::Extract, hr);

   return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\debspew.h ===
/*
 * debspew.h - Debug macros and their retail translations.
 */


/* Macros
 *********/

/* debug output macros */

/*
 * Do not call SPEW_OUT directly.  Instead, call TRACE_OUT, WARNING_OUT,
 * ERROR_OUT, or FATAL_OUT.
 */

/*
 * call like printf(), but with an extra pair of parentheses:
 *
 * ERROR_OUT(("'%s' too big by %d bytes.", pszName, nExtra));
 */

#ifdef DEBUG

#define SPEW_OUT(args) \
   ((void)(g_pcszSpewFile = __FILE__, \
           g_uSpewLine = __LINE__, \
           SpewOut args, \
           g_pcszSpewFile = NULL, \
           g_uSpewLine = 0, \
           g_uSpewSev = 0, \
           g_dwSpewFlags = 0, \
           0))

#define PLAIN_TRACE_OUT(args) \
   (g_dwSpewFlags = 0, \
    g_uSpewSev = SPEW_TRACE, \
    SPEW_OUT(args))

#define TRACE_OUT(args) \
   (g_dwSpewFlags = SPEW_FL_SPEW_PREFIX, \
    g_uSpewSev = SPEW_TRACE, \
    SPEW_OUT(args))

#define WARNING_OUT(args) \
   (g_dwSpewFlags = SPEW_FL_SPEW_PREFIX | SPEW_FL_SPEW_LOCATION, \
    g_uSpewSev = SPEW_WARNING, \
    SPEW_OUT(args))

#define ERROR_OUT(args) \
   (g_dwSpewFlags = SPEW_FL_SPEW_PREFIX | SPEW_FL_SPEW_LOCATION, \
    g_uSpewSev = SPEW_ERROR, \
    SPEW_OUT(args))

#define FATAL_OUT(args) \
   (g_dwSpewFlags = SPEW_FL_SPEW_PREFIX | SPEW_FL_SPEW_LOCATION, \
    g_uSpewSev = SPEW_FATAL, \
    SPEW_OUT(args))

#else

#define PLAIN_TRACE_OUT(args)
#define TRACE_OUT(args)
#define WARNING_OUT(args)
#define ERROR_OUT(args)
#define FATAL_OUT(args)

#endif

/* parameter validation macros */

/*
 * call as:
 *
 * bPTwinOK = IS_VALID_READ_PTR(ptwin, CTWIN);
 *
 * bHTwinOK = IS_VALID_HANDLE(htwin, TWIN);
 */

#ifdef DEBUG

#define IS_VALID_READ_PTR(ptr, type) \
   (IsBadReadPtr((ptr), sizeof(type)) ? \
    (ERROR_OUT(("invalid %s read pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_PTR(ptr, type) \
   (IsBadWritePtr((PVOID)(ptr), sizeof(type)) ? \
    (ERROR_OUT(("invalid %s write pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTR(ptr, type) \
   (IsBadStringPtr((ptr), (UINT)-1) ? \
    (ERROR_OUT(("invalid %s pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_CODE_PTR(ptr, type) \
   (IsBadCodePtr((FARPROC)(ptr)) ? \
    (ERROR_OUT(("invalid %s code pointer - %#08lx", (PCSTR)#type, (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_READ_BUFFER_PTR(ptr, type, len) \
   (IsBadReadPtr((ptr), len) ? \
    (ERROR_OUT(("invalid %s read pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_BUFFER_PTR(ptr, type, len) \
   (IsBadWritePtr((ptr), len) ? \
    (ERROR_OUT(("invalid %s write pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? \
    (ERROR_OUT(("invalid flags set - %#08lx", ((dwFlags) & (~(dwAllFlags))))), FALSE) : \
    TRUE)

#else

#define IS_VALID_READ_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_WRITE_PTR(ptr, type) \
   (! IsBadWritePtr((PVOID)(ptr), sizeof(type)))

#define IS_VALID_STRING_PTR(ptr, type) \
   (! IsBadStringPtr((ptr), (UINT)-1))

#define IS_VALID_CODE_PTR(ptr, type) \
   (! IsBadCodePtr((FARPROC)(ptr)))

#define IS_VALID_READ_BUFFER_PTR(ptr, type, len) \
   (! IsBadReadPtr((ptr), len))

#define IS_VALID_WRITE_BUFFER_PTR(ptr, type, len) \
   (! IsBadWritePtr((ptr), len))

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? FALSE : TRUE)

#endif

/* handle validation macros */

#ifdef DEBUG

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd) ? \
    TRUE : \
    (ERROR_OUT(("invalid H" #type " - %#08lx", (hnd))), FALSE))

#else

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd))

#endif

/* structure validation macros */

#ifdef VSTF

#ifdef DEBUG

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr) ? \
    TRUE : \
    (ERROR_OUT(("invalid %s pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE))

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr))

#endif

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#endif

/* OLE interface validation macro */

#define IS_VALID_INTERFACE_PTR(ptr, iface) \
   IS_VALID_STRUCT_PTR(ptr, C##iface)

/* debug break */

#ifdef DEBUG

#define DebugBreak() \
   __try \
   { \
      DebugBreak(); \
   } __except (EXCEPTION_CONTINUE_EXECUTION) {}

#else

#define DebugBreak()

#endif

/* debug exported function entry */

#ifdef DEBUG

#define DebugEntry(szFunctionName) \
   (TRACE_OUT((#szFunctionName "() entered.")), \
    StackEnter())

#else

#define DebugEntry(szFunctionName)

#endif

/* debug exported function exit */

#ifdef DEBUG

#define DebugExit(szFunctionName, szResult) \
   (StackLeave(), \
    TRACE_OUT(("%s() exiting, returning %s.", #szFunctionName, szResult)))

#define DebugExitBOOL(szFunctionName, bool) \
   DebugExit(szFunctionName, GetBOOLString(bool))

#define DebugExitCOMPARISONRESULT(szFunctionName, cr) \
   DebugExit(szFunctionName, GetCOMPARISONRESULTString(cr))

#define DebugExitDWORD(szFunctionName, dw) \
   DebugExitULONG(szFunctionName, dw)

#define DebugExitHRESULT(szFunctionName, hr) \
   DebugExit(szFunctionName, GetHRESULTString(hr))

#define DebugExitINT(szFunctionName, n) \
   DebugExit(szFunctionName, GetINTString(n))

#define DebugExitULONG(szFunctionName, ul) \
   DebugExit(szFunctionName, GetULONGString(ul))

#define DebugExitVOID(szFunctionName) \
   (StackLeave(), \
    TRACE_OUT(("%s() exiting.", #szFunctionName)))

#else

#define DebugExit(szFunctionName, szResult)
#define DebugExitBOOL(szFunctionName, bool)
#define DebugExitCOMPARISONRESULT(szFunctionName, cr)
#define DebugExitDWORD(szFunctionName, dw)
#define DebugExitHRESULT(szFunctionName, hr)
#define DebugExitINT(szFunctionName, n)
#define DebugExitULONG(szFunctionName, ul)
#define DebugExitVOID(szFunctionName)

#endif


/* Types
 ********/

/* g_dwSpewFlags flags */

typedef enum _spewflags
{
   SPEW_FL_SPEW_PREFIX        = 0x0001,

   SPEW_FL_SPEW_LOCATION      = 0x0002,

   ALL_SPEW_FLAGS             = (SPEW_FL_SPEW_PREFIX |
                                 SPEW_FL_SPEW_LOCATION)
}
SPEWFLAGS;

/* g_uSpewSev values */

typedef enum _spewsev
{
   SPEW_TRACE,

   SPEW_WARNING,

   SPEW_ERROR,

   SPEW_FATAL
}
SPEWSEV;


/* Prototypes
 *************/

/* debspew.c */

#ifdef DEBUG

extern BOOL SetDebugModuleIniSwitches(void);
extern BOOL InitDebugModule(void);
extern void ExitDebugModule(void);
extern void StackEnter(void);
extern void StackLeave(void);
extern ULONG GetStackDepth(void);
extern void SpewOut(PCSTR pcszFormat, ...);

#endif


/* Global Variables
 *******************/

#ifdef DEBUG

/* debspew.c */

extern DWORD g_dwSpewFlags;
extern UINT g_uSpewSev;
extern UINT g_uSpewLine;
extern PCSTR g_pcszSpewFile;

/* defined by client */

extern PCSTR g_pcszSpewModule;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\enumfmte.hpp ===
/*
 * enumfmte.hpp - EnumFormatEtc class description.
 */


/* Classes
 **********/

class EnumFormatEtc : public RefCount,
                      public IEnumFORMATETC
{
private:
   PFORMATETC m_pfmtetc;
   ULONG m_ulcFormats;   
   ULONG m_uliCurrent;

public:
   EnumFormatEtc(CFORMATETC rgcfmtetc[], ULONG ulcFormats);
   ~EnumFormatEtc(void);

   // IEnumFormatEtc methods

   HRESULT STDMETHODCALLTYPE Next(ULONG ulcToFetch, PFORMATETC pfmtetc, PULONG pulcFetched);
   HRESULT STDMETHODCALLTYPE Skip(ULONG ulcToSkip);
   HRESULT STDMETHODCALLTYPE Reset(void);
   HRESULT STDMETHODCALLTYPE Clone(PIEnumFORMATETC *ppiefe);

   // IUnknown methods

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);
   HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);

   // other methods

   HRESULT STDMETHODCALLTYPE Status(void);

   // friends

#ifdef DEBUG

   friend BOOL IsValidPCEnumFormatEtc(const EnumFormatEtc *pcefe);

#endif

};
DECLARE_STANDARD_TYPES(EnumFormatEtc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\guids.cpp ===
/*
 * guids.cpp - GUID definitions.
 */


/* Headers
 **********/

#include "project.hpp"
#pragma hdrstop


/* GUIDs
 ********/

#pragma data_seg(DATA_SEG_READ_ONLY)

#include <initguid.h>

#define NO_INTSHCUT_GUIDS
#include <shlguid.h>

#include "ftps.hpp"
#include "inetps.hpp"

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\ftps.hpp ===
/*
 * ftps.hpp - File Types property sheet implementation for MIME types
 *            description.
 */


/* GUIDs
 ********/

DEFINE_GUID(CLSID_MIMEFileTypesPropSheetHook,   0xFBF23B41L, 0xE3F0, 0x101B, 0x84, 0x88, 0x00, 0xAA, 0x00, 0x3E, 0x56, 0xF8);

#ifdef __cplusplus

/* Types
 ********/

// MIME File Types property sheet hook

class MIMEHook : public RefCount,
                 public IShellExtInit,
                 public IShellPropSheetExt
{
public:
   MIMEHook(void);
   ~MIMEHook(void);

   // IShellExtInit methods

   HRESULT STDMETHODCALLTYPE Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);

   // IShellPropSheetExt methods

   HRESULT STDMETHODCALLTYPE AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
   HRESULT STDMETHODCALLTYPE ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam);

   // IUnknown methods

   HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);
   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);

   // friends

#ifdef DEBUG

   friend BOOL IsValidPCMIMEHook(const MIMEHook *pcmimehk);

#endif

};
DECLARE_STANDARD_TYPES(MIMEHook);

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\ftps.cpp ===
/*
 * ftps.cpp - File Types property sheet implementation for MIME types.
 */


/* Headers
 **********/

#include "project.hpp"
#pragma hdrstop

#include <mluisupp.h>

#include <ispriv.h>

#include "clsfact.h"
extern "C"
{
#include "filetype.h"
}
#include "ftps.hpp"
#include "resource.h"
#include "urlshell.h"

#ifdef WINNT
#include <shlguidp.h>
#else
#include <shlguid.h>
#endif


/****************************** Public Functions *****************************/


#ifdef DEBUG

PUBLIC_CODE BOOL IsValidPCMIMEHook(PCMIMEHook pcmimehk)
{
   return(IS_VALID_READ_PTR(pcmimehk, CMIMEHook) &&
          IS_VALID_STRUCT_PTR((PCRefCount)pcmimehk, CRefCount) &&
          IS_VALID_INTERFACE_PTR((PCIShellExtInit)pcmimehk, IShellExtInit) &&
          IS_VALID_INTERFACE_PTR((PCIShellPropSheetExt)pcmimehk, IShellPropSheetExt));
}

#endif


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

PRIVATE_CODE UINT CALLBACK MIMEFileTypesPSCallback(HWND hwnd, UINT uMsg,
                                                   LPPROPSHEETPAGE ppsp)
{
   UINT uResult = TRUE;

   // uMsg may be any value.

   ASSERT(! hwnd ||
          IS_VALID_HANDLE(hwnd, WND));
   ASSERT(IS_VALID_STRUCT_PTR(ppsp, CPROPSHEETPAGE));

   switch (uMsg)
   {
      case PSPCB_CREATE:
         TRACE_OUT(("MIMEFileTypesPSCallback(): Received PSPCB_CREATE."));
         break;

      case PSPCB_RELEASE:
         TRACE_OUT(("MIMEFileTypesPSCallback(): Received PSPCB_RELEASE."));
         delete (PFILETYPESDIALOGINFO)(ppsp->lParam);
         ppsp->lParam = NULL;
         break;

      default:
         TRACE_OUT(("MIMEFileTypesPSCallback(): Unhandled message %u.",
                    uMsg));
         break;
   }

   return(uResult);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/********************************** Methods **********************************/


MIMEHook::MIMEHook(void)
{
   DebugEntry(MIMEHook::MIMEHook);

   // Don't validate this until after construction.

   ASSERT(IS_VALID_STRUCT_PTR(this, CMIMEHook));

   DebugExitVOID(MIMEHook::MIMEHook);

   return;
}


MIMEHook::~MIMEHook(void)
{
   DebugEntry(MIMEHook::~MIMEHook);

   ASSERT(IS_VALID_STRUCT_PTR(this, CMIMEHook));

   DebugExitVOID(MIMEHook::~MIMEHook);

   return;
}


ULONG STDMETHODCALLTYPE MIMEHook::AddRef(void)
{
   ULONG ulcRef;

   DebugEntry(MIMEHook::AddRef);

   ASSERT(IS_VALID_STRUCT_PTR(this, CMIMEHook));

   ulcRef = RefCount::AddRef();

   ASSERT(IS_VALID_STRUCT_PTR(this, CMIMEHook));

   DebugExitULONG(MIMEHook::AddRef, ulcRef);

   return(ulcRef);
}


ULONG STDMETHODCALLTYPE MIMEHook::Release(void)
{
   ULONG ulcRef;

   DebugEntry(MIMEHook::Release);

   ASSERT(IS_VALID_STRUCT_PTR(this, CMIMEHook));

   ulcRef = RefCount::Release();

   DebugExitULONG(MIMEHook::Release, ulcRef);

   return(ulcRef);
}


HRESULT STDMETHODCALLTYPE MIMEHook::QueryInterface(REFIID riid,
                                                   PVOID *ppvObject)
{
   HRESULT hr = S_OK;

   DebugEntry(MIMEHook::QueryInterface);

   ASSERT(IS_VALID_STRUCT_PTR(this, CMIMEHook));
   ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   if (riid == IID_IShellPropSheetExt)
   {
      *ppvObject = (PIShellPropSheetExt)this;
      TRACE_OUT(("MIMEHook::QueryInterface(): Returning IShellPropSheetExt."));
   }
   else if (riid == IID_IShellExtInit)
   {
      *ppvObject = (PIShellExtInit)this;
      TRACE_OUT(("MIMEHook::QueryInterface(): Returning IShellExtInit."));
   }
   else if (riid == IID_IUnknown)
   {
      *ppvObject = (PIUnknown)(PIShellPropSheetExt)this;
      TRACE_OUT(("MIMEHook::QueryInterface(): Returning IUnknown."));
   }
   else
   {
      TRACE_OUT(("MIMEHook::QueryInterface(): Called on unknown interface."));
      *ppvObject = NULL;
      hr = E_NOINTERFACE;
   }

   if (hr == S_OK)
      AddRef();

   ASSERT(IS_VALID_STRUCT_PTR(this, CMIMEHook));

   DebugExitHRESULT(MIMEHook::QueryInterface, hr);

   return(hr);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE MIMEHook::Initialize(LPCITEMIDLIST pidlFolder, 
                                               IDataObject *pdtobj, 
                                               HKEY hkeyProgID)
{
   HRESULT hr;

   DebugEntry(MIMEHook::Initialize);

   ASSERT(IS_VALID_STRUCT_PTR(this, CMIMEHook));

   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CMIMEHook));

   DebugExitHRESULT(MIMEHook::Initialize, hr);

   return(hr);
}

#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE MIMEHook::AddPages(LPFNADDPROPSHEETPAGE pfnAddPage,
                                             LPARAM lparam)
{
   HRESULT hr;

   DebugEntry(MIMEHook::AddPages);

   // lparam may be any value.

   ASSERT(IS_VALID_STRUCT_PTR(this, CMIMEHook));
   ASSERT(IS_VALID_CODE_PTR(pfnAddPage, LPFNADDPROPSHEETPAGE));

   hr = E_FAIL;

   ASSERT(IS_VALID_STRUCT_PTR(this, CMIMEHook));

   DebugExitHRESULT(MIMEHook::AddPages, hr);

   return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


HRESULT STDMETHODCALLTYPE MIMEHook::ReplacePage(
                                          UINT uPageID,
                                          LPFNADDPROPSHEETPAGE pfnReplaceWith,
                                          LPARAM lparam)
{
   HRESULT hr;

   DebugEntry(MIMEHook::ReplacePage);

   // lparam may be any value.
   // uPageID is checked below.

   ASSERT(IS_VALID_STRUCT_PTR(this, CMIMEHook));
   ASSERT(IS_VALID_CODE_PTR(pfnReplaceWith, LPFNADDPROPSHEETPAGE));

   if (EVAL(uPageID == EXPPS_FILETYPES))
   {
      TRACE_OUT(("MIMEHook::ReplacePage(): Replacing File Types property sheet."));

      hr = AddMIMEFileTypesPS(pfnReplaceWith, lparam);
   }
   else
   {
      TRACE_OUT(("MIMEHook::ReplacePage(): Not replacing unknown property sheet %u.",
                 uPageID));

      hr = E_FAIL;
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CMIMEHook));

   DebugExitHRESULT(MIMEHook::ReplacePage, hr);

   return(hr);
}


/***************************** Exported Functions ****************************/


INTSHCUTPRIVAPI HRESULT WINAPI AddMIMEFileTypesPS(LPFNADDPROPSHEETPAGE pfnAddPage,
                                                  LPARAM lparam)
{
   HRESULT hr = E_OUTOFMEMORY;
   PFILETYPESDIALOGINFO pFTDInfo;
   IShellPropSheetExt* pspse;

   // Try to bind to shell32 to gain the file types box, if this works then we
   // don't need to give them our ANSI implementation.  

   hr = SHCoCreateInstance(NULL, &CLSID_FileTypes, NULL, IID_IShellPropSheetExt, (LPVOID*)&pspse);

   if (SUCCEEDED(hr))
   {
        hr = pspse->AddPages(pfnAddPage, lparam);
        pspse->Release();
   }
   else
   {
       // lparam may be any value.

       ASSERT(IS_VALID_CODE_PTR(pfnAddPage, LPFNADDPROPSHEETPAGE));

       pFTDInfo = new(FILETYPESDIALOGINFO);

       if (pFTDInfo)
       {
          PROPSHEETPAGE psp;
          HPROPSHEETPAGE hpsp;

          ZeroMemory(pFTDInfo, sizeof(*pFTDInfo));

          psp.dwSize = sizeof(psp);
          psp.dwFlags = (PSP_DEFAULT | PSP_USECALLBACK | PSP_USEREFPARENT);
          psp.hInstance = MLGetHinst();
          psp.pszTemplate = MAKEINTRESOURCE(DLG_FILETYPEOPTIONS);
          psp.hIcon = NULL;
          psp.pszTitle = NULL;
          psp.pfnDlgProc = &FT_DlgProc;
          psp.lParam = (LPARAM)pFTDInfo;
          psp.pfnCallback = &MIMEFileTypesPSCallback;
          psp.pcRefParent = (PUINT)GetDLLRefCountPtr();

          ASSERT(IS_VALID_STRUCT_PTR(&psp, CPROPSHEETPAGE));

          hpsp = CreatePropertySheetPage(&psp);

          if (hpsp)
          {
             if ((*pfnAddPage)(hpsp, lparam))
             {
                hr = S_OK;
                TRACE_OUT(("AddMIMEFileTypesPS(): Added MIME File Types property sheet."));
             }
             else
             {
                DestroyPropertySheetPage(hpsp);

                hr = E_FAIL;
                WARNING_OUT(("AddMIMEFileTypesPS(): Callback to add property sheet failed."));
             }
          }

          if (hr != S_OK)
          {
             LocalFree(pFTDInfo);
             pFTDInfo = NULL;
          }
       }
   }

   return(hr);
}


extern "C"
STDAPI CreateInstance_MIMEHook(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    HRESULT hres;

    *ppvOut = NULL;

    if (punkOuter)
        return CLASS_E_NOAGGREGATION;

    MIMEHook *phook = new(MIMEHook);
    if (phook) 
    {
        hres = phook->QueryInterface(riid, ppvOut);
        phook->Release();
    }
    else
        hres = E_OUTOFMEMORY;

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\filetype.h ===
//================================================================
//
//  (C) Copyright MICROSOFT Corp., 1994
//
//  TITLE:       FILETYPE.H
//  VERSION:     1.0
//  DATE:        5/10/94
//  AUTHOR:      Vince Roggero (vincentr)
//
//================================================================
//
//  CHANGE LOG:
//
//  DATE         REV DESCRIPTION
//  -----------  --- ---------------------------------------------
//               VMR Original version
//================================================================

//================================================================
//  File Types Control Panel Applet
//================================================================
#ifndef _INC_FILETYPE_
#define _INC_FILETYPE_

#ifdef FILETYPE_CPL
#define INC_OLE2
//#define _SHSEMIP_H_
#include <windows.h>
#include <commctrl.h>
#include <commdlg.h>
#include <cpl.h>
#include <stdarg.h>
#include <shlobj.h>
#include "rcids.h"
#include "cstrings.h"
#include "shell.h"

#define IDI_FILETYPES				103
#define STR_DESKTOPCLASS "Progman"
#endif

//================================================================
// defines
//================================================================
#define FILETYPESHEETS          1
#define MAXTEXTLEN		32
#define NUMITEMS		7
#define NUMCOLUMNS		2
#define MAXCOLUMNHDG            64
#define MAXEXTSIZE              (PATH_CCH_EXT+2)
#define FTD_EDIT		1
#define FTD_EXT			2
#define FTD_COMMAND		3
#define FTD_DOCICON		4
#ifdef MIME
#define FTD_MIME        5
#endif   /* MIME */
#define WM_CTRL_SETFOCUS	WM_USER + 1
#define SHELLEXEICONINDEX   2
#define SHELLDEFICONINDEX   44


// File Type Attributes key's bitmap values (HKEY_CLASSES_ROOT\filetype,Attributes)
#define FTA_Exclude       0x00000001 //  1. used to exclude types like drvfile
#define FTA_Show          0x00000002 //  2. used to show types like folder that don't have associations
#define FTA_HasExtension  0x00000004 //  3. type has assoc extension
#define FTA_NoEdit        0x00000008 //  4. no editing of file type
#define FTA_NoRemove      0x00000010 //  5. no deling of the file type
#define FTA_NoNewVerb     0x00000020 //  6. no adding of verbs
#define FTA_NoEditVerb    0x00000040 //  7. no editing of predefined verbs
#define FTA_NoRemoveVerb  0x00000080 //  8. no deling of predefined verbs
#define FTA_NoEditDesc    0x00000100 //  9. no editing of file type description
#define FTA_NoEditIcon    0x00000200 // 10. no editing of doc icon
#define FTA_NoEditDflt    0x00000400 // 11. no changing of default verb
#define FTA_NoEditVerbCmd 0x00000800 // 12. no editing of the verbs command
#define FTA_NoEditVerbExe 0x00001000 // 13. no editing of the verbs exe
#define FTA_NoDDE         0x00002000 // 14. no editing of the DDE fields
#define FTA_ExtShellOpen  0x00004000 // 15. old style type: HKCR/.ext/shell/open/command
#ifdef MIME
#define FTA_NoEditMIME    0x00008000 // 16. no editing of the Content Type or Default Extension fields
#define FTA_OpenIsSafe    0x00010000 // 17. the file class's open verb may be safely invoked for downloaded files
#endif   /* MIME */

#define FTAV_UserDefVerb  0x00000001 // 1. identifies verb as being user defined (!predefined)

//================================================================
// typedef's
//================================================================

#ifdef MIME

typedef enum mimeflags
{
   /* The Content Type combo box drop down has been filled with MIME types. */

   MIME_FL_CONTENT_TYPES_ADDED   = 0x0001,

   /* flag combinations */

   ALL_MIME_FLAGS                = MIME_FL_CONTENT_TYPES_ADDED
}
MIMEFLAGS;

#endif

typedef struct tagFILETYPESINFO
{
	char szId[MAX_PATH];			// file type identifier		mmmfile
	char szDesc[MAX_PATH];			// file type description	Animation
	char szDefaultAction[MAX_PATH];		// default verb				mmmfile\shell = (szDefaultAction=open)
	DWORD dwAttributes;			// Optional attributes for type;	mmmfile\Attributes
	HICON hIconDoc;				// Large icon for doc
	HICON hIconOpen;			// Large icon for exe
	HKEY hkeyFT;				// HKEY for this file type
	HDPA hDPAExt;				// dynamic pointer array for list of extensions
#ifdef MIME
        DWORD dwMIMEFlags;                      // flags from MIMEFLAGS
	char szOriginalMIMEType[MAX_PATH];      // original MIME type
#endif   /* MIME */
} FILETYPESINFO, *PFILETYPESINFO;

typedef struct tagFILETYPESCOMMANDINFO
{
	char szId[MAX_PATH];			// file type identifier	mmmfile
	char szActionKey[MAX_PATH];		// action verb			mmmfile\shell\open (szAction=open)
	char szActionValue[MAX_PATH];		// action verb			mmmfile\shell\open=Open (szAction=open)
	char szCommand[MAX_PATH];		// app to execute		mmmfile\shell\open\command = szCommand (C:\FOO.EXE %1)
	char szDDEMsg[MAX_PATH];		// DDE message			mmmfile\shell\open\ddeexec = szDDEMsg
	char szDDEApp[MAX_PATH];		// DDE application		mmmfile\shell\open\ddeexec\application = szDDEApp
	char szDDEAppNot[MAX_PATH];		// DDE application !run	mmmfile\shell\open\ddeexec\ifexec = szDDEAppNot
	char szDDETopic[MAX_PATH];		// DDE topic			mmmfile\shell\open\ddeexec\topic = szDDETopic
	DWORD dwVerbAttributes;			// Optional attributes for verb;	mmmfile\shell\verb -> Attributes=dwVerbAttributes
} FILETYPESCOMMANDINFO, *PFILETYPESCOMMANDINFO;

typedef struct tagFILETYPESDIALOGINFO
{
	HWND hPropDialog;
	HWND hEditDialog;
	HWND hCmdDialog;
	HWND hwndDocIcon;
	HWND hwndOpenIcon;
	HWND hwndEditDocIcon;
	HWND hwndDocExt;
#ifdef MIME
        HWND hwndContentTypeComboBox;
        HWND hwndDefExtensionComboBox;
#endif   /* MIME */
	HWND hwndLVFT;
	HWND hwndLVFTEdit;
	HIMAGELIST himlFT;
	HIMAGELIST himlLarge;			// System image list large icons
	HIMAGELIST himlSmall;			// System image list small icons
	HANDLE hThread;
	DWORD dwCommand;				// Edit or New
	DWORD dwCommandEdit;			// Edit or New
	INT iItem;						// File Type ListView's item
	INT iEditItem;					// Edit ListView's item
	char szId[MAX_PATH];			// file type identifier	mmmfile
	char szIconPath[MAX_PATH];
	INT iIconIndex;
    HFONT hfReg;
    HFONT hfBold;
	PFILETYPESINFO pFTInfo;
	PFILETYPESCOMMANDINFO pFTCInfo;
} FILETYPESDIALOGINFO, *PFILETYPESDIALOGINFO;

//================================================================
// Prototypes
//================================================================
INT_PTR CALLBACK FT_DlgProc(HWND hDialog, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK FTEdit_DlgProc(HWND hDialog, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK FTCmd_DlgProc(HWND hDialog, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK EditExtSubClassProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK ListViewCompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

VOID FileTypesProperties(HWND hwndOwner);
BOOL FT_InitListViewCols(HWND hwndLV);
BOOL FTEdit_InitListViewCols(HWND hwndLV);
BOOL FT_InitListView(PFILETYPESDIALOGINFO pFTDInfo);
int FTEdit_InitListView(PFILETYPESDIALOGINFO pFTDInfo);
BOOL FTEdit_AddInfoToLV(PFILETYPESDIALOGINFO pFTDInfo, LPSTR szActionKey, LPSTR szActionValue, LPSTR szId, HKEY hk);
BOOL FT_AddInfoToLV(PFILETYPESDIALOGINFO pFTDInfo, HKEY hkey, LPSTR szExt, LPSTR szDesc, LPSTR szId, DWORD dwAttributes);
VOID AddExtDot(LPSTR pszExt, UINT iExt);
VOID ExtToShellCommand(HKEY hkeyFT, LPSTR pszName, UINT uName);
VOID VerbToExe(HKEY hkeyFT, LPSTR pszVerb, LPSTR pszExe, DWORD *pdwExe);
BOOL FindDDEOptions(PFILETYPESDIALOGINFO pFTDInfo);
HICON GetDefaultIcon(HKEY *hkeyFT, LPSTR pszId, DWORD dwIconType);
BOOL DefaultAction(HKEY hkeyFT, LPSTR pszDefaultAction, DWORD *dwDefaultAction);
VOID FT_Cleanup(PFILETYPESDIALOGINFO pFTDInfo);
VOID FTEdit_Cleanup(PFILETYPESDIALOGINFO pFTDInfo);
DWORD GetFileTypeAttributes(HKEY hkeyFT);
DWORD SetVerbAttributes(HKEY hkeyFT, LPSTR pszVerb, DWORD dwAttibutes);
DWORD GetVerbAttributes(HKEY hkeyFT, LPSTR pszVerb);
VOID FT_MergeDuplicates(HWND hwndLV);
LONG SaveFileTypeData(DWORD dwName, PFILETYPESDIALOGINFO pFTDInfo);
VOID ResizeCommandDlg(HWND hDialog, BOOL bFlag);
LONG RemoveAction(PFILETYPESDIALOGINFO pFTDInfo, HKEY hk, LPCSTR szKey, LPSTR szAction);
LONG RemoveFileType(PFILETYPESDIALOGINFO pFTDInfo);
LPSTR StripRStr(LPSTR pszFirst, LPCSTR pszSrch);
BOOL ExtToTypeNameAndId(LPSTR pszExt, LPSTR pszDesc, DWORD *dwName, LPSTR pszId, DWORD *dwId);
VOID StrRemoveChar(LPSTR pszSrc, LPSTR pszDest, char ch);
BOOL SetDefaultAction(PFILETYPESDIALOGINFO pFTDInfo);
BOOL IsDefaultAction(PFILETYPESDIALOGINFO pFTDInfo, LPSTR pszAction);
HKEY GetHkeyFT(LPSTR pszId);
BOOL ActionExeIsValid(HWND hDialog, BOOL bFlag);
BOOL ActionIsEntered(HWND hDialog, BOOL bFlag);
BOOL ValidExtension(HWND hDialog, PFILETYPESDIALOGINFO pFTDInfo);
VOID DisplayDocObjects(PFILETYPESDIALOGINFO pFTDInfo, HWND hDialog);
VOID DisplayOpensWithObjects(PFILETYPESDIALOGINFO pFTDInfo, HWND hDialog);
VOID OkToClose_NoCancel(HWND hDialog);

int  ParseIconLocation(LPSTR pszIconFile);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\filetype.c ===
/* Look for BUILDBUILD to find build hacks. */

/* BUILDBUILD: My hacks to get this to build. */

#include "project.h"
#pragma hdrstop

#include "urlshell.h"           /* BUILDBUILD */

#include <mluisupp.h>

#pragma warning(disable:4001) /* "single line comment" warning */
#include <windowsx.h>
#include <contxids.h>
#include "resource.h"
#pragma warning(default:4001) /* "single line comment" warning */
#include "assoc.h"
#include "clsfact.h"

#define DATASEG_READONLY   DATA_SEG_READ_ONLY
#define hinstCabinet       GetThisModulesHandle()
#define IDI_SYSFILE        154   /* from cabinet\rcids.h: Icon index in shell32 for default icon; used by filetypes */

PRIVATE_DATA HIMAGELIST s_himlSysSmall = NULL;
PRIVATE_DATA HIMAGELIST s_himlSysLarge = NULL;

extern BOOL  lPathIsExeA(LPCSTR);
extern LONG  lRegDeleteKeyA(HKEY, LPCSTR);
extern int   lShell_GetCachedImageIndexA(LPCSTR pszIconPath, int iIconIndex, UINT uIconFlags);

#define Shell_GetCachedImageIndex   lShell_GetCachedImageIndexA
#define PathIsExe                   lPathIsExeA
#undef RegDeleteKey
#define RegDeleteKey                lRegDeleteKeyA

#pragma data_seg(DATA_SEG_READ_ONLY)

CCHAR c_szCommand[]              = "command";
CCHAR c_szDDEAppNot[]            = "ifexec";
CCHAR c_szDDEApp[]               = "Application";
CCHAR c_szDDEExec[]              = "ddeexec";
CCHAR c_szDDETopic[]             = "topic";
CCHAR c_szDefaultIcon[]          = "DefaultIcon";
CCHAR c_szEditFlags[]            = "EditFlags";
CCHAR c_szExefileOpenCommand[]   = "\"%1\"";
CCHAR c_szFile[]                 = "file";
CCHAR c_szNULL[]                 = "";
CCHAR c_szNew[]                  = "New";
CCHAR c_szOpen[]                 = "open";
CCHAR c_szShell2[]               = "shell32.dll";
CCHAR c_szShellOpenCommand[]     = "shell\\open\\command";
CCHAR c_szShell[]                = "Shell";
CCHAR c_szShellexIconHandler[]   = "shellex\\IconHandler";
CCHAR c_szShowExt[]              = "AlwaysShowExt";
CCHAR c_szSpPercentOne[]         = " %1";
CCHAR c_szSpaceFile[]            = " File";
CCHAR c_szSpace[]                = " ";
CCHAR c_szCLSID[]                = "CLSID";

#pragma data_seg()

#pragma warning(disable:4001) /* "single line comment" warning */

/******************************************************************************
                     Original Shell32.dll code starts here.
******************************************************************************/

//================================================================
//
//  (C) Copyright MICROSOFT Corp., 1994
//
//  TITLE:       FILETYPE.C
//  VERSION:     1.0
//  DATE:        5/10/94
//  AUTHOR:      Vince Roggero (vincentr)
//
//================================================================
//
//  CHANGE LOG:
//
//  DATE         REV DESCRIPTION
//  -----------  --- ---------------------------------------------
//               VMR Original version
//================================================================

//================================================================
//  View.Options.File Types
//================================================================

// FEATURE - need to be able to handle case where user enters exe without an ext during EditCommand Dialog

#if 0 /* BUILDBUILD */
#include "cabinet.h"
#endif
#include "filetype.h"
#if 0 /* BUILDBUILD */
#include "rcids.h"
#endif
#if 0 /* BUILDBUILD */
#include "..\..\inc\help.h" // Help IDs
#else
#undef NO_HELP  /* BUILDBUILD */
#include <help.h>
#endif

#if DEBUG
#define FT_DEBUG 0
#else
#define FT_DEBUG 0        // allways leave as 0 for retail
#endif  /* DEBUG */

#pragma data_seg(".text", "CODE")
const char c_szTemplateSS[] = "%s\\%s";
const char c_szTemplateSSS[] = "%s\\%s\\%s";
#pragma data_seg()


// PathProcessCommand is present in SUR (and probably Nashville), it is required to
// fix the use of LFN in registry entries, as it may not be present we must late
// bind to it.

LONG UrlPathProcessCommand( LPCTSTR lpSrc, LPTSTR lpDest, int iMax, DWORD dwFlags );
LONG UrlPathProcessCommand2( LPCTSTR lpSrc, LPTSTR lpDest, int iDestMax, DWORD dwFlags );

typedef LONG (*P_PathProcessCommand)(LPCTSTR lpSrc, LPTSTR lpDest, int iMax, DWORD dwFlags);

P_PathProcessCommand lpPathProcessCommand = NULL;

// Fix the registry functions for WinNT so that we do the right thing
// and expand REG_STRING_SZ variables.

#ifdef RegQueryValue
#undef RegQueryValue
#endif

#define RegQueryValue(hkey, pszSubkey, pvValue, pcbSize)    SHGetValue(hkey, pszSubkey, NULL, NULL, pvValue, pcbSize)


// ================================================================
VOID FT_CleanupOne(PFILETYPESDIALOGINFO pFTDInfo, PFILETYPESINFO pFTInfo)
{
#ifdef FT_DEBUG
    DebugMsg(DM_TRACE, "FT_CleanupOne");
#endif
    if (pFTDInfo->pFTInfo == pFTInfo)
        pFTDInfo->pFTInfo = NULL;

    if(pFTInfo->hIconDoc)
        DestroyIcon(pFTInfo->hIconDoc);
    if(pFTInfo->hIconOpen)
        DestroyIcon(pFTInfo->hIconOpen);
    if(pFTInfo->hkeyFT)
        RegCloseKey(pFTInfo->hkeyFT);
    if(pFTInfo->hDPAExt)
    {
        int iCnt;
        int i;

        iCnt = DPA_GetPtrCount(pFTInfo->hDPAExt);
        for(i = 0; i < iCnt; i++)
            LocalFree((HANDLE)DPA_FastGetPtr(pFTInfo->hDPAExt, i));
        DPA_Destroy(pFTInfo->hDPAExt);
    }
    LocalFree((HANDLE)pFTInfo);
}

// ================================================================
// ================================================================

#ifdef MIME

/* MIME Types
 *************/

typedef BOOL (CALLBACK *ENUMPROC)(PCSTR pcsz, LPARAM lparam);

typedef struct enumdata
{
   ENUMPROC enumproc;

   LPARAM lparam;
}
ENUMDATA;
DECLARE_STANDARD_TYPES(ENUMDATA);

typedef struct mimeenumdata
{
   ENUMPROC enumproc;

   LPARAM lparam;

   PCSTR pcszMIMEType;
}
MIMEENUMDATA;
DECLARE_STANDARD_TYPES(MIMEENUMDATA);

typedef struct bufferdata
{
   PSTR pszBuf;

   UINT ucBufLen;
}
BUFFERDATA;
DECLARE_STANDARD_TYPES(BUFFERDATA);


/*************************** Private MIME Functions **************************/


/* Debug Validation Functions
 *****************************/


#ifdef DEBUG

PRIVATE_CODE IsValidPCENUMDATA(PCENUMDATA pcenumdata)
{
   /* lparam may be any value. */
   return(IS_VALID_READ_PTR(pcenumdata, CENUMDATA) &&
          IS_VALID_CODE_PTR(pcenumdata->enumproc, ENUMPROC));
}


PRIVATE_CODE IsValidPCMIMEENUMDATA(PCMIMEENUMDATA pcmimeenumdata)
{
   /* lparam may be any value. */
   return(IS_VALID_READ_PTR(pcmimeenumdata, CMIMEENUMDATA) &&
          IS_VALID_CODE_PTR(pcmimeenumdata->enumproc, ENUMPROC) &&
          IS_VALID_STRING_PTR(pcmimeenumdata->pcszMIMEType, CSTR));
}


PRIVATE_CODE IsValidPCBUFFERDATA(PCBUFFERDATA pcbufdata)
{
   return(IS_VALID_READ_PTR(pcbufdata, CBUFFERDATA) &&
          EVAL(pcbufdata->ucBufLen > 0) &&
          IS_VALID_WRITE_BUFFER_PTR(pcbufdata->pszBuf, STR, pcbufdata->ucBufLen));
}

#endif   /* DEBUG */


/* Windows Control Functions
 ****************************/


/*
** AddStringToComboBox()
**
** Adds a string to a combo box.  Does not check to see if the string has
** already been added.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL AddStringToComboBox(HWND hwndComboBox, PCSTR pcsz)
{
   BOOL bResult;
   LRESULT lAddStringResult;

   ASSERT(IS_VALID_HANDLE(hwndComboBox, WND));
   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   lAddStringResult = SendMessage(hwndComboBox, CB_ADDSTRING, 0, (LPARAM)pcsz);

   bResult = (lAddStringResult != CB_ERR &&
              lAddStringResult != CB_ERRSPACE);

   if (bResult)
      TRACE_OUT(("AddStringToComboBox(): Added string %s to combo box.",
                 pcsz));
   else
      WARNING_OUT(("AddStringToComboBox(): Failed to add string %s to combo box.",
                   pcsz));

   return(bResult);
}


/*
** SafeAddStringToComboBox()
**
** Adds a string to a combo box.  Checks to see if the string has already been
** added.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL SafeAddStringToComboBox(HWND hwndComboBox, PCSTR pcsz)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hwndComboBox, WND));
   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   if (SendMessage(hwndComboBox, CB_FINDSTRINGEXACT, 0, (LPARAM)pcsz) == CB_ERR)
      bResult = AddStringToComboBox(hwndComboBox, pcsz);
   else
   {
      bResult = TRUE;

      TRACE_OUT(("SafeAddStringToComboBox(): String %s already added to combo box.",
                 pcsz));
   }

   return(bResult);
}


/*
** SafeAddStringsToComboBox()
**
** Adds a list of strings to a combo box.  Does not check to see if the strings
** have already been added.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL SafeAddStringsToComboBox(HDPA hdpa, HWND hwndComboBox)
{
   BOOL bResult;
   int ncStrings;
   int i;

   ASSERT(IS_VALID_HANDLE(hwndComboBox, WND));

   ncStrings = DPA_GetPtrCount(hdpa);

   for (i = 0; i < ncStrings; i++)
   {
      PCSTR pcsz;

      pcsz = DPA_FastGetPtr(hdpa, i);
      ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

      bResult = SafeAddStringToComboBox(hwndComboBox, pcsz);

      if (! bResult)
         break;
   }

   return(bResult);
}


/*
** AddAndSetComboBoxCurrentSelection()
**
** Adds a string to a combo box, and sets it as the current selection.  Does
** not check to see if the string has already been added.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL AddAndSetComboBoxCurrentSelection(HWND hwndComboBox,
                                                    PCSTR pcszText)
{
   BOOL bResult;
   LRESULT liSel;

   liSel = SendMessage(hwndComboBox, CB_ADDSTRING, 0, (LPARAM)pcszText);

   bResult = (liSel != CB_ERR &&
              liSel != CB_ERRSPACE &&
              SendMessage(hwndComboBox, CB_SETCURSEL, liSel, 0) != CB_ERR);

   if (bResult)
      TRACE_OUT(("AddAndSetComboBoxCurrentSelection(): Current combo box selection set to %s.",
                 pcszText));

   return(bResult);
}


/* Enumeration Callback Functions
 *********************************/


/*
** ExtensionEnumerator()
**
** Enumeration callback function to enumerate extensions.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CALLBACK ExtensionEnumerator(PCSTR pcsz, LPARAM lparam)
{
   BOOL bContinue;

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));
   ASSERT(IS_VALID_STRUCT_PTR((PCENUMDATA)lparam, CENUMDATA));

   if (*pcsz == PERIOD)
   {
      PCENUMDATA pcenumdata = (PCENUMDATA)lparam;

      bContinue = (*(pcenumdata->enumproc))(pcsz, pcenumdata->lparam);
   }
   else
      bContinue = TRUE;

   return(bContinue);
}


/*
** MIMETypeEnumerator()
**
** Enumeration callback function to enumerate MIME types.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CALLBACK MIMETypeEnumerator(PCSTR pcsz, LPARAM lparam)
{
   BOOL bContinue;
   char szMIMEType[MAX_PATH];
   DWORD dwcbContentTypeLen = sizeof(szMIMEType);

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));
   ASSERT(IS_VALID_STRUCT_PTR((PCENUMDATA)lparam, CENUMDATA));

   if (GetRegKeyStringValue(HKEY_CLASSES_ROOT, pcsz, g_cszContentType,
                            szMIMEType, &dwcbContentTypeLen)
       == ERROR_SUCCESS)
   {
      PCENUMDATA pcenumdata = (PCENUMDATA)lparam;

      TRACE_OUT(("MIMETypeEnumerator(): MIME type %s registered for extension %s.",
                 szMIMEType,
                 pcsz));

      bContinue = (*(pcenumdata->enumproc))(szMIMEType, pcenumdata->lparam);
   }
   else
      bContinue = TRUE;

   return(bContinue);
}


/*
** MIMETypeExtensionEnumerator()
**
** Enumeration callback function to enumerate extensions registered as a given
** MIME type.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CALLBACK MIMETypeExtensionEnumerator(PCSTR pcsz,
                                                       LPARAM lparam)
{
   BOOL bContinue = TRUE;
   char szMIMEType[MAX_PATH];
   DWORD dwcbContentTypeLen = sizeof(szMIMEType);

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));
   ASSERT(IS_VALID_STRUCT_PTR((PCMIMEENUMDATA)lparam, CMIMEENUMDATA));

   if (GetRegKeyStringValue(HKEY_CLASSES_ROOT, pcsz, g_cszContentType,
                            szMIMEType, &dwcbContentTypeLen)
       == ERROR_SUCCESS)
   {
      PCMIMEENUMDATA pcmimeenumdata = (PCMIMEENUMDATA)lparam;

      if (! lstrcmpi(szMIMEType, pcmimeenumdata->pcszMIMEType))
      {
         TRACE_OUT(("MIMETypeEnumerator(): Found extension %s registered for MIME type %s.",
                    pcsz,
                    szMIMEType));

         bContinue = (*(pcmimeenumdata->enumproc))(pcsz, pcmimeenumdata->lparam);
      }
   }

   return(bContinue);
}


/*
** AddStringToComboBoxEnumerator()
**
** Enumeration callback function to add strings to a combo box.  Does not check
** to see if the strings have already been added.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CALLBACK AddStringToComboBoxEnumerator(PCSTR pcsz,
                                                         LPARAM lparam)
{
   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));
   ASSERT(IS_VALID_HANDLE((HWND)lparam, WND));

   return(AddStringToComboBox((HWND)lparam, pcsz));
}


/*
** AddHandledMIMETypeEnumerator()
**
** Enumeration callback function to enumerate MIME types with registered open
** verb application handlers.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CALLBACK AddHandledMIMETypeEnumerator(PCSTR pcsz,
                                                        LPARAM lparam)
{
   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));
   ASSERT(IS_VALID_HANDLE((HWND)lparam, WND));

   /* Only add MIME types with registered applications. */

   return(MIME_IsExternalHandlerRegistered(pcsz)
          ? SafeAddStringToComboBox((HWND)lparam, pcsz)
          : TRUE);
}


/*
** ReplacementDefExtensionEnumerator()
**
** Enumeration callback function to find a default extension for a MIME type.
** Returns the first extension in alphabetical order.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CALLBACK ReplacementDefExtensionEnumerator(PCSTR pcsz,
                                                             LPARAM lparam)
{
   PBUFFERDATA pbufdata = (PBUFFERDATA)lparam;

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));
   ASSERT(IS_VALID_STRUCT_PTR((PCBUFFERDATA)lparam, CBUFFERDATA));

   if (! *(pbufdata->pszBuf) ||
       lstrcmpi(pcsz, pbufdata->pszBuf) < 0)
   {
      if ((UINT)lstrlen(pcsz) < pbufdata->ucBufLen)
         lstrcpy(pbufdata->pszBuf, pcsz);
      else
         WARNING_OUT(("ReplacementDefExtensionEnumerator(): %u byte buffer too small to hold %d byte extension %s.",
                      pcsz,
                      lstrlen(pcsz),
                      pbufdata->ucBufLen));
   }

   return(TRUE);
}


/* Registry Enumeration Functions
 *********************************/


/*
** EnumSubKeys()
**
** Enumerates direct child sub keys of a given registry key.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE LRESULT EnumSubKeys(HKEY hkeyParent, ENUMPROC enumproc,
                                 LPARAM lparam)
{
   LONG lResult;
   DWORD dwi;
   char szSubKey[MAX_PATH];
   DWORD dwcbSubKeyLen = sizeof(szSubKey);

   /* lparam may be any value. */
   ASSERT(IS_VALID_HANDLE(hkeyParent, KEY));
   ASSERT(IS_VALID_CODE_PTR(enumproc, ENUMPROC));

   TRACE_OUT(("EnumSubKeys(): Enumerating sub keys."));

   for (dwi = 0;
        (lResult = RegEnumKeyEx(hkeyParent, dwi, szSubKey, &dwcbSubKeyLen,
                                NULL, NULL, NULL, NULL)) == ERROR_SUCCESS;
        dwi++)
   {
      if (! (*enumproc)(szSubKey, lparam))
      {
         TRACE_OUT(("EnumSubKeys(): Callback aborted at sub key %s, index %lu.",
                    szSubKey,
                    dwi));
         lResult = ERROR_CANCELLED;
         break;
      }

      dwcbSubKeyLen = sizeof(szSubKey);
   }

   if (lResult == ERROR_NO_MORE_ITEMS)
   {
      TRACE_OUT(("EnumSubKeys(): Enumerated %lu sub keys.",
                 dwi));

      lResult = ERROR_SUCCESS;
   }
   else
      TRACE_OUT(("EnumSubKeys(): Stopped after enumerating %lu sub keys.",
                 dwi));

   return(lResult);
}


/*
** EnumExtensions()
**
** Enumerates extensions listed in the registry under HKEY_CLASSES_ROOT.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE LRESULT EnumExtensions(ENUMPROC enumproc, LPARAM lparam)
{
   ENUMDATA enumdata;

   /* lparam may be any value. */
   ASSERT(IS_VALID_CODE_PTR(enumproc, ENUMPROC));

   TRACE_OUT(("EnumExtensions(): Enumerating extensions."));

   enumdata.enumproc = enumproc;
   enumdata.lparam = lparam;

   return(EnumSubKeys(HKEY_CLASSES_ROOT, &ExtensionEnumerator, (LPARAM)&enumdata));
}


/*
** EnumMIMETypes()
**
** Enumerates MIME types registered to extensions under HKEY_CLASSES_ROOT.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE LRESULT EnumMIMETypes(ENUMPROC enumproc, LPARAM lparam)
{
   ENUMDATA enumdata;

   /* lparam may be any value. */
   ASSERT(IS_VALID_CODE_PTR(enumproc, ENUMPROC));

   TRACE_OUT(("EnumMIMETypes(): Enumerating MIME types."));

   enumdata.enumproc = enumproc;
   enumdata.lparam = lparam;

   return(EnumExtensions(&MIMETypeEnumerator, (LPARAM)&enumdata));
}


/*
** EnumExtensionsOfMIMEType()
**
** Enumerates extensions registered as a given MIME type under
** HKEY_CLASSES_ROOT.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE LRESULT EnumExtensionsOfMIMEType(ENUMPROC enumproc, LPARAM lparam,
                                              PCSTR pcszMIMEType)
{
   MIMEENUMDATA mimeenumdata;

   /* lparam may be any value. */
   ASSERT(IS_VALID_CODE_PTR(enumproc, ENUMPROC));
   ASSERT(IS_VALID_STRING_PTR(pcszMIMEType, CSTR));

   ASSERT(*pcszMIMEType);

   TRACE_OUT(("EnumExtensionsOfMIMEType(): Enumerating extensions registered as MIME type %s.",
              pcszMIMEType));

   mimeenumdata.enumproc = enumproc;
   mimeenumdata.lparam = lparam;
   mimeenumdata.pcszMIMEType = pcszMIMEType;

   return(EnumExtensions(&MIMETypeExtensionEnumerator, (LPARAM)&mimeenumdata));
}


/* MIME Registry Functions
 **************************/


/*
** FindMIMETypeOfExtensionList()
**
** Finds the MIME type of the first extension in a list of extensions that has
** a registered MIME type.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL FindMIMETypeOfExtensionList(HDPA hdpaExtensions,
                                              PSTR pszMIMETypeBuf,
                                              UINT ucMIMETypeBufLen)
{
   BOOL bFound = FALSE;
   int ncExtensions;
   int i;

   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszMIMETypeBuf, STR, ucMIMETypeBufLen));

   ncExtensions = DPA_GetPtrCount(hdpaExtensions);

   for (i = 0; i < ncExtensions; i++)
   {
      PCSTR pcszExtension;

      pcszExtension = DPA_FastGetPtr(hdpaExtensions, i);
      ASSERT(IsValidExtension(pcszExtension));

      bFound = MIME_GetMIMETypeFromExtension(pcszExtension, pszMIMETypeBuf,
                                             ucMIMETypeBufLen);

      if (bFound)
         break;
   }

   if (! bFound)
   {
      if (ucMIMETypeBufLen > 0)
         *pszMIMETypeBuf = '\0';
   }

   ASSERT(! ucMIMETypeBufLen ||
          (IS_VALID_STRING_PTR(pszMIMETypeBuf, STR) &&
           (UINT)lstrlen(pszMIMETypeBuf) < ucMIMETypeBufLen));
   ASSERT(bFound ||
          ! ucMIMETypeBufLen ||
          ! *pszMIMETypeBuf);

   return(bFound);
}


/*
** RegisterContentTypeForArrayOfExtensions()
**
** Registers the given MIME type for each extension in a list of extensions.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL RegisterContentTypeForArrayOfExtensions(PCSTR pcszMIMEType,
                                                          HDPA hdpaExtensions)
{
   BOOL bResult = TRUE;
   int ncExtensions;
   int i;

   ASSERT(IS_VALID_STRING_PTR(pcszMIMEType, CSTR));

   ncExtensions = DPA_GetPtrCount(hdpaExtensions);

   for (i = 0; i < ncExtensions; i++)
   {
      PCSTR pcszExtension;

      pcszExtension = DPA_FastGetPtr(hdpaExtensions, i);
      ASSERT(IsValidExtension(pcszExtension));

      bResult = RegisterMIMETypeForExtension(pcszExtension, pcszMIMEType);

      if (bResult)
         TRACE_OUT(("RegisterContentTypeForArrayOfExtensions(): Registered MIME type %s for extension %s.",
                    pcszMIMEType,
                    pcszExtension));
      else
      {
         WARNING_OUT(("RegisterContentTypeForArrayOfExtensions(): Failed to register MIME type %s for extension %s.",
                      pcszMIMEType,
                      pcszExtension));
         break;
      }
   }

   return(bResult);
}


/*
** UnregisterContentTypeForArrayOfExtensions()
**
** Unregisters the MIME type association of each extension in a list of
** extensions.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL UnregisterContentTypeForArrayOfExtensions(HDPA hdpaExtensions)
{
   BOOL bResult = TRUE;
   int ncExtensions;
   int i;

   ncExtensions = DPA_GetPtrCount(hdpaExtensions);

   for (i = 0; i < ncExtensions; i++)
   {
      PCSTR pcszExtension;

      pcszExtension = DPA_FastGetPtr(hdpaExtensions, i);
      ASSERT(IsValidExtension(pcszExtension));

      if (! UnregisterMIMETypeForExtension(pcszExtension))
         bResult = FALSE;

      if (bResult)
         TRACE_OUT(("UnregisterContentTypeForArrayOfExtensions(): Unregistered MIME type for extension %s.",
                    pcszExtension));
      else
         WARNING_OUT(("UnregisterContentTypeForArrayOfExtensions(): Failed to unregister MIME type for extension %s.",
                      pcszExtension));
   }

   return(bResult);
}


/*
** ExtensionSearchCmp()
**
** Callback function to perform case-insensitive string comparison.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE int CALLBACK ExtensionSearchCmp(PVOID pvFirst, PVOID pvSecond,
                                             LPARAM lparam)
{
   ASSERT(IS_VALID_STRING_PTR(pvFirst, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pvSecond, CSTR));
   ASSERT(! lparam);

   return(lstrcmpi(pvFirst, pvSecond));
}


/*
** NeedReplacementDefExtension()
**
** Determines whether or not the default extension of the given MIME type is in
** the given list of extensions.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL NeedReplacementDefExtension(HDPA hdpaExtension,
                                              PCSTR pcszOriginalMIMEType)
{
   BOOL bNeedReplacementDefExtension;
   char szDefExtension[MAX_PATH];

   ASSERT(IS_VALID_STRING_PTR(pcszOriginalMIMEType, CSTR));

   ASSERT(*pcszOriginalMIMEType);

   /* Is there a default extension specified for the MIME type? */

   if (MIME_GetExtension(pcszOriginalMIMEType, szDefExtension, sizeof(szDefExtension)))
   {
      /* Yes.  Is that default extension in the list of extensions? */

      bNeedReplacementDefExtension = (DPA_Search(hdpaExtension, szDefExtension,
                                                 0, &ExtensionSearchCmp, 0, 0)
                                      != -1);

      if (bNeedReplacementDefExtension)
         TRACE_OUT(("NeedReplacementDefExtension(): Previous default extension %s for MIME type %s removed.",
                    szDefExtension,
                    pcszOriginalMIMEType));
      else
         TRACE_OUT(("NeedReplacementDefExtension(): Previous default extension %s for MIME type %s remains registered.",
                    szDefExtension,
                    pcszOriginalMIMEType));
   }
   else
   {
      /* No.  Choose a new default extension. */

      bNeedReplacementDefExtension = TRUE;

      WARNING_OUT(("NeedReplacementDefExtension(): No default extension registered for MIME type %s.  Choosing default extension.",
                   pcszOriginalMIMEType));
   }

   return(bNeedReplacementDefExtension);
}


/*
** FindReplacementDefExtension()
**
** Finds a suitable default extension for the given MIME type.  Selects the
** first extension in alphabetical order that is registered as the given MIME
** type.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL FindReplacementDefExtension(HDPA hdpaExtension,
                                        PCSTR pcszOriginalMIMEType,
                                        PSTR pszDefExtensionBuf, UINT ucDefExtensionBufLen)
{
   BOOL bFound;
   BUFFERDATA bufdata;

   ASSERT(IS_VALID_STRING_PTR(pcszOriginalMIMEType, CSTR));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszDefExtensionBuf, STR, ucDefExtensionBufLen));

   ASSERT(*pcszOriginalMIMEType);

   if (EVAL(*pcszOriginalMIMEType) &&
       EVAL(ucDefExtensionBufLen > 1))
   {
      /* Any extensions still registered as the given MIME type? */

      *pszDefExtensionBuf = '\0';

      bufdata.pszBuf = pszDefExtensionBuf;
      bufdata.ucBufLen = ucDefExtensionBufLen;

      EVAL(EnumExtensionsOfMIMEType(&ReplacementDefExtensionEnumerator,
                                    (LPARAM)&bufdata, pcszOriginalMIMEType)
           == ERROR_SUCCESS);

      bFound = (*pszDefExtensionBuf != '\0');
   }
   else
      bFound = FALSE;

   if (bFound)
      TRACE_OUT(("FindReplacementDefExtension(): Extension %s remains registered as MIME type %s.",
                 pszDefExtensionBuf,
                 pcszOriginalMIMEType));
   else
      TRACE_OUT(("FindReplacementDefExtension(): No extensions remain registered as MIME type %s.",
                 pcszOriginalMIMEType));

   ASSERT(! bFound ||
          (IsValidExtension(pszDefExtensionBuf) &&
           (UINT)lstrlen(pszDefExtensionBuf) < ucDefExtensionBufLen));
   ASSERT(bFound ||
          ! ucDefExtensionBufLen ||
          ! *pszDefExtensionBuf);

   return(bFound);
}


/*
** RegisterNewDefExtension()
**
** Registers a new default extension for the given MIME type, assuming that the
** MIME types associated with the given list of extensions has changed.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL RegisterNewDefExtension(HDPA hdpaExtension,
                                              PCSTR pcszOriginalMIMEType)
{
   BOOL bResult = TRUE;

   ASSERT(IS_VALID_STRING_PTR(pcszOriginalMIMEType, CSTR));

   /* Was there originally a MIME type specified? */

   if (*pcszOriginalMIMEType)
   {
      /*
       * Yes.  Was the previous default extension for the MIME type just
       * removed?
       */

      if (NeedReplacementDefExtension(hdpaExtension, pcszOriginalMIMEType))
      {
         char szDefExtension[MAX_PATH];

         /*
          * Yes.  Are there any remaining extensions registered as the MIME
          * type?
          */

         if (FindReplacementDefExtension(hdpaExtension, pcszOriginalMIMEType,
                                         szDefExtension,
                                         sizeof(szDefExtension)))
            /*
             * Yes.  Set one of them as the new default extension for the MIME
             * type.
             */
            bResult = RegisterExtensionForMIMEType(szDefExtension,
                                                   pcszOriginalMIMEType);
         else
            /* No.  Remove the MIME type. */
            bResult = UnregisterExtensionForMIMEType(pcszOriginalMIMEType);
      }
   }
   else
      /* No.  Nothing to clean up. */
      TRACE_OUT(("RegisterNewDefExtension(): No original MIME type, no new default extension"));

   return(bResult);
}


/*
** AddMIMETypeInfo()
**
** Registers the given MIME type for the given list of extensions.  Registers
** the given default extension for the given MIME type.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL AddMIMETypeInfo(PFILETYPESDIALOGINFO pFTDInfo,
                                  PCSTR pcszOldMIMEType, PCSTR pcszNewMIMEType,
                                  PCSTR pcszDefExtension)
{
   BOOL bMIMEResult;
   BOOL bOldDefExtensionResult;
   BOOL bNewDefExtensionResult;

   ASSERT(IS_VALID_STRING_PTR(pcszOldMIMEType, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszNewMIMEType, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszDefExtension, CSTR));

   /* Register MIME type for extensions. */

   bMIMEResult = RegisterContentTypeForArrayOfExtensions(pcszNewMIMEType,
                                                         pFTDInfo->pFTInfo->hDPAExt);

   /* Pick new default extension for old MIME type. */

   if (*pcszOldMIMEType &&
       lstrcmpi(pcszOldMIMEType, pcszNewMIMEType) != 0)
      bOldDefExtensionResult = RegisterNewDefExtension(pFTDInfo->pFTInfo->hDPAExt,
                                                       pcszOldMIMEType);
   else
      bOldDefExtensionResult = TRUE;

   /* Register default extension for MIME type. */

   bNewDefExtensionResult = RegisterExtensionForMIMEType(pcszDefExtension,
                                                         pcszNewMIMEType);

   return(bMIMEResult &&
          bOldDefExtensionResult &&
          bNewDefExtensionResult);
}


/*
** RemoveMIMETypeInfo()
**
** Removes the MIME type association for the given list of extensions.
** Registers a new default extension for the given MIME type.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL RemoveMIMETypeInfo(PFILETYPESDIALOGINFO pFTDInfo,
                                     PCSTR pcszOldMIMEType)
{
   BOOL bMIMEResult;
   BOOL bDefExtensionResult;

   ASSERT(IS_VALID_STRING_PTR(pcszOldMIMEType, CSTR));

   /* Unregister MIME type for extensions. */

   bMIMEResult = UnregisterContentTypeForArrayOfExtensions(pFTDInfo->pFTInfo->hDPAExt);

   /* Pick new default extension for old MIME type. */

   bDefExtensionResult = RegisterNewDefExtension(pFTDInfo->pFTInfo->hDPAExt,
                                                 pcszOldMIMEType);

   return(bMIMEResult &&
          bDefExtensionResult);
}


/* Utility Functions
 ********************/


/*
** GetFirstString()
**
** Finds the first string in alphabetical order in the given list of strings.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL GetFirstString(HDPA hdpa, PSTR pszBuf, UINT ucBufLen)
{
   BOOL bFound = FALSE;
   int ncStrings;
   int iFirst = 0;
   int i;

   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszBuf, STR, ucBufLen));

   ncStrings = DPA_GetPtrCount(hdpa);

   for (i = 0; i < ncStrings; i++)
   {
      PCSTR pcsz;

      pcsz = DPA_FastGetPtr(hdpa, i);
      ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

      if (EVAL((UINT)lstrlen(pcsz) < ucBufLen) &&
          (! bFound ||
           lstrcmpi(pcsz, DPA_FastGetPtr(hdpa, iFirst)) < 0))
      {
         iFirst = i;
         bFound = TRUE;
      }
   }

   if (bFound)
      lstrcpy(pszBuf, DPA_FastGetPtr(hdpa, iFirst));
   else
   {
      if (ucBufLen > 0)
         *pszBuf = '\0';
   }

   ASSERT(! ucBufLen ||
          IS_VALID_STRING_PTR(pszBuf, STR));
   ASSERT(bFound ||
          ! ucBufLen ||
          ! *pszBuf);

   return(bFound);
}


/*
** IsListOfExtensions()
**
** Determines whether or not a list of strings contains any strings that are
** not extensions.  Returns FALSE for empty list.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsListOfExtensions(HDPA hdpa)
{
   BOOL bNoRogues = TRUE;
   BOOL bAnyExtensions = FALSE;
   int ncStrings;
   int i;

   ncStrings = DPA_GetPtrCount(hdpa);

   for (i = 0; i < ncStrings; i++)
   {
      PCSTR pcsz;

      pcsz = DPA_FastGetPtr(hdpa, i);
      ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

      if (*pcsz == PERIOD)
      {
         bAnyExtensions = TRUE;

         TRACE_OUT(("IsListOfExtensions(): Found extension %s.",
                    pcsz));
      }
      else
      {
         bNoRogues = FALSE;

         TRACE_OUT(("IsListOfExtensions(): Found non-extension %s.",
                    pcsz));
      }
   }

   TRACE_OUT(("IsListOfExtensions(): This %s a list of extensions.",
              (bAnyExtensions && bNoRogues) ? "is" : "is not"));

   return(bAnyExtensions && bNoRogues);
}


/* New/Edit Dialog MIME Control Functions
 *****************************************/


/*
** InitContentTypeEditControl()
**
** Fills the edit control of the Content Type combo box with the MIME Type of
** the list of extensions.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL InitContentTypeEditControl(HWND hdlg)
{
   BOOL bResult;
   PFILETYPESDIALOGINFO pFTDInfo;
   char szMIMEType[MAX_PATH];

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   pFTDInfo = (PFILETYPESDIALOGINFO)GetWindowLongPtr(hdlg, DWLP_USER);

   EVAL(SendMessage(pFTDInfo->hwndContentTypeComboBox, CB_RESETCONTENT, 0, 0));

   if (FindMIMETypeOfExtensionList(pFTDInfo->pFTInfo->hDPAExt, szMIMEType,
                                   sizeof(szMIMEType)) &&
       *szMIMEType)
      bResult = AddAndSetComboBoxCurrentSelection(pFTDInfo->hwndContentTypeComboBox,
                                                  szMIMEType);
   else
      bResult = TRUE;

   return(bResult);
}


/*
** FillContentTypeListBox()
**
** Fills the list box of the Content Type combo box with MIME types with
** registered handlers.  Only fills list box once.  Does not reset content of
** Content Type combo box before filling.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL FillContentTypeListBox(HWND hdlg)
{
   BOOL bResult;
   PFILETYPESDIALOGINFO pFTDInfo;

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   pFTDInfo = (PFILETYPESDIALOGINFO)GetWindowLongPtr(hdlg, DWLP_USER);

   if (IS_FLAG_CLEAR(pFTDInfo->pFTInfo->dwMIMEFlags, MIME_FL_CONTENT_TYPES_ADDED))
   {
      SET_FLAG(pFTDInfo->pFTInfo->dwMIMEFlags, MIME_FL_CONTENT_TYPES_ADDED);

      bResult = (EnumMIMETypes(&AddHandledMIMETypeEnumerator,
                               (LPARAM)(pFTDInfo->hwndContentTypeComboBox))
                 == ERROR_SUCCESS);
   }
   else
   {
      TRACE_OUT(("FillContentTypeListBox(): Content Type combo box already filled."));

      bResult = TRUE;
   }

   return(bResult);
}


/*
** GetAssociatedExtension()
**
** Returns the contents of the Associated Extension edit control as a valid
** extension.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL GetAssociatedExtension(HWND hdlg, PSTR pszAssocExtensionBuf,
                                         UINT ucAssocExtensionBufLen)
{
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_HANDLE(hdlg, WND));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszAssocExtensionBuf, STR, ucAssocExtensionBufLen));

   if (EVAL(ucAssocExtensionBufLen > 2))
   {
      PFILETYPESDIALOGINFO pFTDInfo;

      pFTDInfo = (PFILETYPESDIALOGINFO)GetWindowLongPtr(hdlg, DWLP_USER);

      /* Leave room for possible leading period. */

      GetWindowText(pFTDInfo->hwndDocExt, pszAssocExtensionBuf + 1,
                    ucAssocExtensionBufLen - 1);

      if (pszAssocExtensionBuf[1])
      {
         /* Prepend period if necessary. */

         if (pszAssocExtensionBuf[1] == PERIOD)
            /* (+ 1) for null terminator. */
            MoveMemory(pszAssocExtensionBuf, pszAssocExtensionBuf + 1,
                       lstrlen(pszAssocExtensionBuf + 1) + 1);
         else
            pszAssocExtensionBuf[0] = PERIOD;

         bResult = TRUE;
      }
   }

   if (! bResult)
   {
      if (ucAssocExtensionBufLen > 0)
         *pszAssocExtensionBuf = '\0';
   }

   if (bResult)
      TRACE_OUT(("GetAssociatedExtension(): Associated Extension is %s.",
                 pszAssocExtensionBuf));
   else
      TRACE_OUT(("GetAssociatedExtension(): No Associated Extension."));

   ASSERT(! bResult ||
          (IsValidExtension(pszAssocExtensionBuf) &&
           (UINT)lstrlen(pszAssocExtensionBuf) < ucAssocExtensionBufLen));
   ASSERT(bResult ||
          ! ucAssocExtensionBufLen ||
          ! *pszAssocExtensionBuf);

   return(bResult);
}


/*
** FillDefExtensionListBox()
**
** Fills the list box of the Default Extension combo box with extensions
** registered as the current MIME type.  Also adds either the Associated
** Extension extension (New File Type dialog), or the list of extensions being
** edited (Edit File Type dialog).  Fills list box every time.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL FillDefExtensionListBox(HWND hdlg)
{
   BOOL bResult = FALSE;
   PFILETYPESDIALOGINFO pFTDInfo;
   char szMIMEType[MAX_PATH];
   LRESULT liSel;

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   pFTDInfo = (PFILETYPESDIALOGINFO)GetWindowLongPtr(hdlg, DWLP_USER);

   EVAL(SendMessage(pFTDInfo->hwndDefExtensionComboBox, CB_RESETCONTENT, 0, 0));

   GetWindowText(pFTDInfo->hwndContentTypeComboBox, szMIMEType,
                 sizeof(szMIMEType));

   if (*szMIMEType)
   {
      char szDefExtension[MAX_PATH];

      /* Add extensions registered as given MIME type, if any. */

      bResult = (EnumExtensionsOfMIMEType(&AddStringToComboBoxEnumerator,
                                          (LPARAM)(pFTDInfo->hwndDefExtensionComboBox),
                                          szMIMEType)
                 == ERROR_SUCCESS);

      /*
       * Add the extension from the Associated Extension edit control in the
       * New File Type Dialog, or the list of extensions in the Edit File Type
       * dialog.
       */

       if (pFTDInfo->dwCommand == IDC_FT_PROP_NEW)
         /* New File Type dialog. */
         bResult = (GetAssociatedExtension(hdlg, szDefExtension,
                                           sizeof(szDefExtension)) &&
                    SafeAddStringToComboBox(pFTDInfo->hwndDefExtensionComboBox,
                                            szDefExtension) &&
                    bResult);
      else
         /* Edit File Type dialog. */
         bResult = (SafeAddStringsToComboBox(pFTDInfo->pFTInfo->hDPAExt,
                                             pFTDInfo->hwndDefExtensionComboBox) &&
                    bResult);

      /*
       * Set default extension as registered default extension, or first
       * extension in list.
       */

      if (*szMIMEType &&
          MIME_GetExtension(szMIMEType, szDefExtension, sizeof(szDefExtension)))
      {
         liSel = SendMessage(pFTDInfo->hwndDefExtensionComboBox,
                             CB_FINDSTRINGEXACT, 0, (LPARAM)szDefExtension);

         if (liSel == CB_ERR)
            liSel = 0;
      }
      else
         liSel = 0;

      /* There may be no entries in the combo box here. */

      SendMessage(pFTDInfo->hwndDefExtensionComboBox, CB_SETCURSEL, liSel, 0);
   }

   return(bResult);
}


/*
** SetDefExtensionComboBoxState()
**
** Enables or disables the Default Extension text and edit control based upon:
**    1) FTA_NoEditMIME setting
**    2) contents of Content Type combo box edit control
**    3) contents of Associated Extension edit control (New File Type dialog
**       only)
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void SetDefExtensionComboBoxState(HWND hdlg, PCSTR pcszMIMEType)
{
   PFILETYPESDIALOGINFO pFTDInfo;

   ASSERT(IS_VALID_HANDLE(hdlg, WND));
   ASSERT(IS_VALID_STRING_PTR(pcszMIMEType, CSTR));

   pFTDInfo = (PFILETYPESDIALOGINFO)GetWindowLongPtr(hdlg, DWLP_USER);

   if (IS_FLAG_CLEAR(pFTDInfo->pFTInfo->dwAttributes, FTA_NoEditMIME))
   {
      char szAssocExtension[MAX_PATH];
      BOOL bEnable;

      bEnable = (*pcszMIMEType != '\0');

       if (pFTDInfo->dwCommand == IDC_FT_PROP_NEW)
         /* New File Type dialog. */
         bEnable = (bEnable &&
                    GetAssociatedExtension(hdlg, szAssocExtension,
                                           sizeof(szAssocExtension)));

      EnableWindow(pFTDInfo->hwndDefExtensionComboBox, bEnable);

      TRACE_OUT(("EnableDefExtensionComboBox(): Default extension combo box %s.",
                 bEnable ? "enabled" : "disabled"));
   }

   return;
}


/*
** SetDefExtension()
**
** Fills the read-only edit control of the Default Extension combo box with the
** default extension of the given MIME type.  If there is no default extension
** for the given MIME type, falls back to:
**    - the contents of the Associated Extension edit control in the New File
**      Type dialog
**    - the first extension in alphabetical order in the list of extensions
**      being edited in the Edit File Type dialog
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL SetDefExtension(HWND hdlg, PCSTR pcszMIMEType)
{
   BOOL bResult;
   PFILETYPESDIALOGINFO pFTDInfo;

   ASSERT(IS_VALID_HANDLE(hdlg, WND));
   ASSERT(IS_VALID_STRING_PTR(pcszMIMEType, CSTR));

   pFTDInfo = (PFILETYPESDIALOGINFO)GetWindowLongPtr(hdlg, DWLP_USER);

   EVAL(SendMessage(pFTDInfo->hwndDefExtensionComboBox, CB_RESETCONTENT, 0, 0));

   /* Any MIME type? */

   if (*pcszMIMEType)
   {
      char szDefExtension[MAX_PATH];

      /*
       * Yes.  Use the registered default extension, or the first extension in
       * the list of extensions.
       */

      bResult = MIME_GetExtension(pcszMIMEType, szDefExtension, sizeof(szDefExtension));

      if (! bResult)
      {
          if (pFTDInfo->dwCommand == IDC_FT_PROP_NEW)
            /* New File Type dialog. */
            bResult = GetAssociatedExtension(hdlg, szDefExtension,
                                             sizeof(szDefExtension));
         else
            /* Edit File Type dialog. */
            bResult = GetFirstString(pFTDInfo->pFTInfo->hDPAExt, szDefExtension,
                                     sizeof(szDefExtension));
      }

      if (bResult)
         bResult = AddAndSetComboBoxCurrentSelection(pFTDInfo->hwndDefExtensionComboBox,
                                                     szDefExtension);
   }
   else
      /* No.  No default extension. */
      bResult = TRUE;

   return(bResult);
}


/*
** FillDefExtensionEditControlFromSelection()
**
** Fills the read-only edit control of the Default Extension combo box based
** upon the current selection of list box of the Content Type combo box.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL FillDefExtensionEditControlFromSelection(HWND hdlg)
{
   BOOL bResult = TRUE;
   PFILETYPESDIALOGINFO pFTDInfo;
   char szMIMEType[MAX_PATH];
   LRESULT liSel;

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   pFTDInfo = (PFILETYPESDIALOGINFO)GetWindowLongPtr(hdlg, DWLP_USER);

   liSel = SendMessage(pFTDInfo->hwndContentTypeComboBox, CB_GETCURSEL, 0, 0);

   if (liSel != CB_ERR)
   {
      bResult = (SendMessage(pFTDInfo->hwndContentTypeComboBox, CB_GETLBTEXT,
                             liSel, (LPARAM)szMIMEType) != CB_ERR &&
                 SetDefExtension(hdlg, szMIMEType));

      SetDefExtensionComboBoxState(hdlg, szMIMEType);
   }
   else
      TRACE_OUT(("FillDefExtensionEditControlFromSelection(): No MIME type selection."));

   return(bResult);
}


/*
** FillDefExtensionEditControlFromEditControl()
**
** Fills the read-only edit control of the Default Extension combo box based
** upon the contents of the edit control of the Content Type combo box.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL FillDefExtensionEditControlFromEditControl(HWND hdlg)
{
   PFILETYPESDIALOGINFO pFTDInfo;
   char szMIMEType[MAX_PATH];

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   pFTDInfo = (PFILETYPESDIALOGINFO)GetWindowLongPtr(hdlg, DWLP_USER);

   GetWindowText(pFTDInfo->hwndContentTypeComboBox, szMIMEType,
                 sizeof(szMIMEType));

   SetDefExtensionComboBoxState(hdlg, szMIMEType);

   return(SetDefExtension(hdlg, szMIMEType));
}


/*
** SetMIMEControlState()
**
** Enables or disables the MIME controls:
**    1) the Content Type combo box
**    2) the Default Extension combo box
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void SetMIMEControlState(HWND hdlg, BOOL bEnable)
{
   PFILETYPESDIALOGINFO pFTDInfo;

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   pFTDInfo = (PFILETYPESDIALOGINFO)GetWindowLongPtr(hdlg, DWLP_USER);

    EnableWindow(pFTDInfo->hwndContentTypeComboBox, bEnable);
   EnableWindow(pFTDInfo->hwndDefExtensionComboBox, bEnable);

   return;
}


/*************************** Public MIME Functions ***************************/


/*
** InitMIMEControls()
**
** Initializes contents of Content Type combo box and Default Extension combo
** box.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL InitMIMEControls(HWND hdlg)
{
   BOOL bResult;
   PFILETYPESDIALOGINFO pFTDInfo;

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   pFTDInfo = (PFILETYPESDIALOGINFO)GetWindowLongPtr(hdlg, DWLP_USER);

   EVAL(SendMessage(pFTDInfo->hwndContentTypeComboBox, CB_LIMITTEXT, MAX_PATH, 0));
   EVAL(SendMessage(pFTDInfo->hwndDefExtensionComboBox, CB_LIMITTEXT, MAX_PATH, 0));

    if (pFTDInfo->dwCommand == IDC_FT_PROP_NEW)
   {
      /* New File Type dialog. */

      CLEAR_FLAG(pFTDInfo->pFTInfo->dwAttributes, FTA_NoEditMIME);

      *(pFTDInfo->pFTInfo->szOriginalMIMEType) = '\0';

      bResult = TRUE;

      TRACE_OUT(("InitMIMEControls(): Cleared MIME controls for New File Type dialog box."));
   }
   else
   {
      /* Edit File Type dialog. */

      /*
       * Disable MIME controls if requested, and when editing non-extension
       * types.
       */

      if (IS_FLAG_CLEAR(pFTDInfo->pFTInfo->dwAttributes, FTA_NoEditMIME))
      {
         if (! IsListOfExtensions(pFTDInfo->pFTInfo->hDPAExt))
         {
            SET_FLAG(pFTDInfo->pFTInfo->dwAttributes, FTA_NoEditMIME);

            TRACE_OUT(("InitMIMEControls(): Disabling MIME controls for non-extension type."));
         }
      }
      else
         TRACE_OUT(("InitMIMEControls(): Disabling MIME controls, as requested."));

      if (IS_FLAG_CLEAR(pFTDInfo->pFTInfo->dwAttributes, FTA_NoEditMIME))
      {
         /* Initialize contents of MIME controls for extensions. */

         bResult = InitContentTypeEditControl(hdlg);
         bResult = (FillDefExtensionEditControlFromSelection(hdlg) &&
                    bResult);

         /*
          * Don't call FillContentTypeListBox() and
          * FillDefExtensionListBox() here.  Wait until user drops them
          * down.
          */

         TRACE_OUT(("InitMIMEControls(): Initialized MIME controls for Edit File Type dialog box."));
      }
      else
      {
         /* Disable MIME controls. */

         SetMIMEControlState(hdlg, FALSE);

         bResult = TRUE;
      }
   }

   SetDefExtensionComboBoxState(hdlg, pFTDInfo->pFTInfo->szOriginalMIMEType);

   return(bResult);
}


/*
** OnContentTypeSelectionChange()
**
** Updates MIME controls after selection change in the list box of the Content
** Type combo box.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL OnContentTypeSelectionChange(HWND hdlg)
{
   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   return(FillDefExtensionEditControlFromSelection(hdlg));
}


/*
** OnContentTypeEditChange()
**
** Updates MIME controls after edit change in the edit control of the Content
** Type combo box.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL OnContentTypeEditChange(HWND hdlg)
{
   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   return(FillDefExtensionEditControlFromEditControl(hdlg));
}


/*
** OnContentTypeDropDown()
**
** Updates MIME controls after drop down of the list box of the Content Type
** combo box.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL OnContentTypeDropDown(HWND hdlg)
{
   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   return(FillContentTypeListBox(hdlg));
}


/*
** OnDefExtensionDropDown()
**
** Updates MIME controls after drop down of the list box of the Default
** Extension combo box.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL OnDefExtensionDropDown(HWND hdlg)
{
   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   return(FillDefExtensionListBox(hdlg));
}


/*
** RegisterMIMEInformation()
**
** Registers current MIME information at close of New File Type dialog or Edit
** File Type dialog.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL RegisterMIMEInformation(PFILETYPESDIALOGINFO pFTDInfo)
{
   BOOL bResult;

   if (IS_FLAG_CLEAR(pFTDInfo->pFTInfo->dwAttributes, FTA_NoEditMIME))
   {
       char szMIMEType[MAX_PATH];
      char szDefExtension[MAX_PATH];

       GetWindowText(pFTDInfo->hwndContentTypeComboBox, szMIMEType,
                    sizeof(szMIMEType));

       GetWindowText(pFTDInfo->hwndDefExtensionComboBox, szDefExtension,
                    sizeof(szDefExtension));

      if (*szMIMEType)
      {
         /*
          * Yes.  Register the MIME type for each extension in the list,
          * and set the default extension for the MIME type.
          */

         ASSERT(lstrlen(szDefExtension) > 0);

         bResult = AddMIMETypeInfo(pFTDInfo,
                                   pFTDInfo->pFTInfo->szOriginalMIMEType,
                                   szMIMEType, szDefExtension);
      }
      else
      {
         /*
          * No.  Clear the MIME type for each extension in the list, and
          * choose a new default extension for the MIME type.
          */

         ASSERT(! lstrlen(szDefExtension));

         bResult = RemoveMIMETypeInfo(pFTDInfo,
                                      pFTDInfo->pFTInfo->szOriginalMIMEType);
      }
   }
   else
   {
      bResult = TRUE;

      TRACE_OUT(("RegisterMIMEInformation(): Not registering MIME information, as requested."));
   }

   return(bResult);
}

#endif   /* MIME */

//================================================================
//================================================================
BOOL FT_OnInitDialog(HWND hDialog, LPARAM lParam)
{
    HMODULE hShellDll = NULL;

    PFILETYPESDIALOGINFO pFTDInfo;
    BOOL bRC = FALSE;
    DECLAREWAITCURSOR;
#ifdef FT_DEBUG
    DebugMsg(DM_TRACE, "FT: WM_INITDIALOG");
#endif

    SetWaitCursor();

   Shell_GetImageLists(&s_himlSysLarge, &s_himlSysSmall);

    pFTDInfo = (PFILETYPESDIALOGINFO)((LPPROPSHEETPAGE)lParam)->lParam;
    SetWindowLongPtr(hDialog, DWLP_USER, (LPARAM)pFTDInfo);
    pFTDInfo->hPropDialog = hDialog;
    pFTDInfo->pFTInfo = (PFILETYPESINFO)NULL;

    if((pFTDInfo->hwndLVFT = GetDlgItem(hDialog, IDC_FT_PROP_LV_FILETYPES)) != (HWND)NULL)
    {
                SendMessage(pFTDInfo->hwndLVFT, WM_SETREDRAW, FALSE, 0);
        pFTDInfo->hwndDocIcon = GetDlgItem(hDialog, IDC_FT_PROP_DOCICON);
        pFTDInfo->hwndOpenIcon = GetDlgItem(hDialog, IDC_FT_PROP_OPENICON);
        if(FT_InitListViewCols(pFTDInfo->hwndLVFT))
        {
            if(FT_InitListView(pFTDInfo))
            {    // macro needs brackets
                ListView_SetItemState(pFTDInfo->hwndLVFT, 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED); // Set listview to item 0
                bRC = TRUE;
            }
        }
            SendMessage(pFTDInfo->hwndLVFT, WM_SETREDRAW, TRUE, 0);
    }

   // Attempt to bind to the ordinal for shell32!PathProcessCommand

    hShellDll = GetModuleHandle( c_szShell2 );

    if ( hShellDll )
    {
        lpPathProcessCommand = (P_PathProcessCommand)GetProcAddress(hShellDll, (LPCSTR)653);
    }

    ResetWaitCursor();

    return(bRC);
}

//================================================================
//================================================================
VOID FT_OnLVN_ItemChanged(PFILETYPESDIALOGINFO pFTDInfo, HWND hDialog, LPARAM lParam)
{
    LV_ITEM LVItem;

    if((((NM_LISTVIEW *)lParam)->uChanged & LVIF_STATE) &&
        ((NM_LISTVIEW *)lParam)->uNewState & (LVIS_FOCUSED | LVIS_SELECTED))
    {
#ifdef FT_DEBUG
        DebugMsg(DM_TRACE, "FT: WM_NOTIFY - LVN_ITEMCHANGED");
#endif

        // Get FILETYPESINFO from LVItem's lParam
        LVItem.mask = LVIF_PARAM;
        LVItem.iItem = pFTDInfo->iItem = ((NM_LISTVIEW *)lParam)->iItem;
        LVItem.iSubItem = 0;
        ListView_GetItem(pFTDInfo->hwndLVFT, &LVItem);  // lParam points to file type info
        pFTDInfo->pFTInfo = (PFILETYPESINFO)LVItem.lParam;

        DisplayDocObjects(pFTDInfo, hDialog);

        DisplayOpensWithObjects(pFTDInfo, hDialog);

        EnableWindow(GetDlgItem(hDialog, IDC_FT_PROP_EDIT), !(pFTDInfo->pFTInfo->dwAttributes & FTA_NoEdit));
        EnableWindow(GetDlgItem(hDialog, IDC_FT_PROP_REMOVE), !(pFTDInfo->pFTInfo->dwAttributes & FTA_NoRemove));
    }
}

//================================================================
//================================================================
VOID FT_OnLVN_GetDispInfo(PFILETYPESDIALOGINFO pFTDInfo, LPARAM lParam)
{
    LV_ITEM LVItem;
    int iImageIndex;
    HICON hIcon;
    SHFILEINFO sfi;
    LV_DISPINFO *pnmv;

#ifdef FT_DEBUG
    DebugMsg(DM_TRACE, "FT: WM_NOTIFY - LVN_GETDISPINFO");
#endif
    pnmv = (LV_DISPINFO *)lParam;

    if(pnmv->item.mask & LVIF_IMAGE)
    {
        if(((PFILETYPESINFO)(pnmv->item.lParam))->dwAttributes & FTA_HasExtension)
        {
            if(SHGetFileInfo(DPA_FastGetPtr(((PFILETYPESINFO)(pnmv->item.lParam))->hDPAExt,0),
                    FILE_ATTRIBUTE_NORMAL,
                    &sfi, sizeof(SHFILEINFO),
                    SHGFI_ICON | SHGFI_SMALLICON | SHGFI_USEFILEATTRIBUTES))
                hIcon = sfi.hIcon;
         else
                hIcon = NULL;     /* BUILDBUILD: Added. */
#ifdef FT_DEBUG
            DebugMsg(DM_TRACE, "LVN_GETDISPINFO SHGetFileInfo szFile=%s hIcon=0x%x",
                DPA_FastGetPtr(((PFILETYPESINFO)(pnmv->item.lParam))->hDPAExt,0), hIcon);
#endif
        }
        else
            hIcon = GetDefaultIcon(&(((PFILETYPESINFO)(pnmv->item.lParam))->hkeyFT), ((PFILETYPESINFO)(pnmv->item.lParam))->szId, SHGFI_SMALLICON);

        if(hIcon == (HICON)NULL)  // use default shell icon in case above calls fail to find an icon
        {
            UINT iIndex = Shell_GetCachedImageIndex(c_szShell2, II_DOCNOASSOC, 0);
            hIcon = ImageList_ExtractIcon(hinstCabinet, s_himlSysSmall, iIndex);
        }

        if(hIcon != (HICON)NULL)
        {
#if FT_DEBUG
            HDC hdc = GetDC(NULL);
            DrawIcon(hdc,200, 0, hIcon);
            ReleaseDC(NULL, hdc);
#endif

            if((iImageIndex = ImageList_AddIcon(pFTDInfo->himlFT, hIcon)) != (-1))
            {
                ZeroMemory(&LVItem, sizeof(LV_ITEM));
                LVItem.mask        = LVIF_IMAGE;
                LVItem.iItem       = pnmv->item.iItem;
                LVItem.iImage      = iImageIndex;
                ListView_SetItem(pFTDInfo->hwndLVFT, &LVItem);

                pnmv->item.iImage = iImageIndex;

            }
            DestroyIcon(hIcon);
        }
    }

}

//================================================================
//================================================================
BOOL FT_OnNotify(PFILETYPESDIALOGINFO pFTDInfo, HWND hDialog, LPARAM lParam)
{
    LPNMHDR pnm = (NMHDR*)lParam;
#ifdef FT_DEBUG
    DebugMsg(DM_TRACE, "FT: WM_NOTIFY code=0x%x =%d", ((NMHDR *) lParam)->code, ((NMHDR *) lParam)->code);
#endif

    // Process ListView notifications
    if (IDC_FT_PROP_LV_FILETYPES == pnm->idFrom) {
        PFILETYPESINFO pFTInfo;

        switch(((LV_DISPINFO *)lParam)->hdr.code)
        {
        case NM_DBLCLK:
            if(!(pFTDInfo->pFTInfo->dwAttributes & FTA_NoEdit))
                PostMessage(hDialog, WM_COMMAND, (WPARAM)IDC_FT_PROP_EDIT, 0);
            break;

        case LVN_ITEMCHANGED:
            FT_OnLVN_ItemChanged(pFTDInfo, hDialog, lParam);
            break;

        case LVN_GETDISPINFO:
            FT_OnLVN_GetDispInfo(pFTDInfo, lParam);
            break;

        case LVN_DELETEITEM:
            pFTInfo = (PFILETYPESINFO)(((NM_LISTVIEW*)lParam)->lParam);

            if (pFTInfo) {
                FT_CleanupOne(pFTDInfo, pFTInfo);
            }
            break;
        }
    }
    return(FALSE);
}

//================================================================
//================================================================
VOID FT_OnCommand(PFILETYPESDIALOGINFO pFTDInfo, HWND hDialog, WPARAM wParam, LPARAM lParam)
{
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);
    char   szMsg[MAX_PATH];
    char   szTitle[MAX_PATH];
            

#ifdef FT_DEBUG
    DebugMsg(DM_TRACE, "FT: WM_COMMAND");
#endif

    switch(idCmd)
    {
        case IDC_FT_PROP_NEW:
        case IDC_FT_PROP_EDIT:
            pFTDInfo->dwCommand = idCmd;
            DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(DLG_FILETYPEOPTIONSEDIT), hDialog, FTEdit_DlgProc, (LPARAM)pFTDInfo);
            DisplayOpensWithObjects(pFTDInfo, hDialog);
                        DisplayDocObjects(pFTDInfo, hDialog);
            break;

        case IDC_FT_PROP_REMOVE:
            // Tell user that this extension is already in use

            MLLoadStringA(IDS_FT_MB_REMOVETYPE, szMsg, ARRAYSIZE(szMsg));
            MLLoadStringA(IDS_FT, szTitle, ARRAYSIZE(szTitle));
            
            if(ShellMessageBox(MLGetHinst(), hDialog,
                               szMsg,
                               szTitle,
                               MB_YESNO | MB_ICONEXCLAMATION) == IDYES)
            {
                RemoveFileType(pFTDInfo);
                PropSheet_CancelToClose(GetParent(hDialog));
            }
            break;
    }
}

//================================================================
//================================================================
#pragma data_seg(DATASEG_READONLY)
const static DWORD aFileTypeOptionsHelpIDs[] = {  // Context Help IDs
    IDC_GROUPBOX,                 IDH_COMM_GROUPBOX,
    IDC_FT_PROP_LV_FILETYPES,     IDH_FCAB_FT_PROP_LV_FILETYPES,
    IDC_FT_PROP_NEW,              IDH_FCAB_FT_PROP_NEW,
    IDC_FT_PROP_REMOVE,           IDH_FCAB_FT_PROP_REMOVE,
    IDC_FT_PROP_EDIT,             IDH_FCAB_FT_PROP_EDIT,
    IDC_FT_PROP_EDIT,             IDH_FCAB_FT_PROP_EDIT,
    IDC_FT_PROP_DOCICON,          IDH_FILETYPE_EXTENSION,
    IDC_FT_PROP_DOCEXTRO_TXT,     IDH_FILETYPE_EXTENSION,
    IDC_FT_PROP_DOCEXTRO,         IDH_FILETYPE_EXTENSION,
#ifdef MIME
    IDC_FT_PROP_CONTTYPERO_TXT,   IDH_FILETYPE_CONTENT_TYPE,
    IDC_FT_PROP_CONTTYPERO,       IDH_FILETYPE_CONTENT_TYPE,
#endif   /* MIME */
    IDC_FT_PROP_OPENICON,         IDH_FILETYPE_OPENS_WITH,
    IDC_FT_PROP_OPENEXE_TXT,      IDH_FILETYPE_OPENS_WITH,
    IDC_FT_PROP_OPENEXE,          IDH_FILETYPE_OPENS_WITH,
    0, 0
};
#ifdef MIME
CONST char s_cszMIMEHelpFile[] = "IExplore.hlp";
#endif   /* MIME */
#pragma data_seg()
//================================================================
//================================================================

#ifdef MIME

/*
** FT_GetHelpFileFromControl()
**
** Determines whether to use the MIME help file or the default Win95 help file
** for context-sensitive help for a given control.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
/*
 * HACKHACK: We depend upon the group box in the File Types property sheet
 * occurring after the controls inside it in the parent dialog's child window
 * order.  This ordering is set up under Win95 by declaring the group box
 * after the other controls in the dialog's resource definition.
 */
PRIVATE_CODE PCSTR FT_GetHelpFileFromControl(HWND hwndControl)
{
   PCSTR pcszHelpFile = NULL;
   int nControlID = 0;

   ASSERT(! hwndControl ||
          IS_VALID_HANDLE(hwndControl, WND));

   if (hwndControl)
   {
      nControlID = GetDlgCtrlID(hwndControl);

      switch (nControlID)
      {
         case IDC_FT_PROP_DOCICON:
         case IDC_FT_PROP_DOCEXTRO_TXT:
         case IDC_FT_PROP_DOCEXTRO:

         case IDC_FT_PROP_CONTTYPERO_TXT:
         case IDC_FT_PROP_CONTTYPERO:

         case IDC_FT_PROP_OPENICON:
         case IDC_FT_PROP_OPENEXE_TXT:
         case IDC_FT_PROP_OPENEXE:

         case IDC_FT_COMBO_CONTTYPETEXT:
         case IDC_FT_COMBO_CONTTYPE:

         case IDC_FT_COMBO_DEFEXTTEXT:
         case IDC_FT_COMBO_DEFEXT:

         case IDC_FT_EDIT_CONFIRM_OPEN:
         case IDC_BROWSEINPLACE:

            /* MIME help comes from the MIME help file. */
            pcszHelpFile = s_cszMIMEHelpFile;
            break;

         default:
            /* Other help is taken from the default Win95 help file. */
            break;
      }
   }

   TRACE_OUT(("FT_GetHelpFileFromControl(): Using %s for control %d (HWND %#lx).",
              pcszHelpFile ? pcszHelpFile : "default Win95 help file",
              nControlID,
              hwndControl));

   ASSERT(! pcszHelpFile ||
          IS_VALID_STRING_PTR(pcszHelpFile, CSTR));

   return(pcszHelpFile);
}

#endif   /* MIME */

INT_PTR CALLBACK FT_DlgProc(HWND hDialog, UINT message, WPARAM wParam, LPARAM lParam)
{
    PFILETYPESDIALOGINFO pFTDInfo = (PFILETYPESDIALOGINFO)GetWindowLongPtr(hDialog, DWLP_USER);

#ifdef FT_DEBUG
    DebugMsg(DM_TRACE, "FileTypesDialogProc wParam=0x%x lParam=0x%x", wParam, lParam);
#endif

    switch(message)
    {
        case WM_INITDIALOG:
            return(FT_OnInitDialog(hDialog, lParam));

        case WM_NOTIFY:
            return(FT_OnNotify(pFTDInfo, hDialog, lParam));

        case WM_DESTROY:
            if (pFTDInfo->hThread) {
                HANDLE hThread = pFTDInfo->hThread;
                pFTDInfo->hThread = 0;        // signal thread that we are done if still running
                if(WaitForSingleObject(hThread, 2000) == WAIT_TIMEOUT)
                    TerminateThread(hThread, 0);
            }

            // Tidy up the function pointers we aquired into shelldll.

            lpPathProcessCommand = NULL;
            break;

        case WM_COMMAND:
            FT_OnCommand(pFTDInfo, hDialog, wParam, lParam);
            break;

        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle,
#ifdef MIME
                    FT_GetHelpFileFromControl((HWND)(((LPHELPINFO)lParam)->hItemHandle)),
#else
                    NULL,
#endif   /* MIME */
                    HELP_WM_HELP, (DWORD_PTR)(LPSTR)aFileTypeOptionsHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
        {
            POINT pt;

            if ((int)SendMessage(hDialog, WM_NCHITTEST, 0, lParam) != HTCLIENT)
               return FALSE;   // don't process it

            LPARAM_TO_POINT(lParam, pt);
            EVAL(ScreenToClient(hDialog, &pt));

               SHWinHelpOnDemandWrap((HWND)wParam,
#ifdef MIME
                    FT_GetHelpFileFromControl(ChildWindowFromPoint(hDialog, pt)),
#else
                    NULL,
#endif   /* MIME */
                    HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)aFileTypeOptionsHelpIDs);
            return TRUE;
        }
    }

    return(FALSE);
}

//================================================================
//================================================================

#ifdef MIME

BOOL FTEdit_ConfirmOpenAfterDownload(PFILETYPESDIALOGINFO pFTDInfo)
{
   return(! ClassIsSafeToOpen(pFTDInfo->pFTInfo->szId));
}

BOOL FTEdit_SetConfirmOpenAfterDownload(PFILETYPESDIALOGINFO pFTDInfo,
                                        BOOL bConfirm)
{
   return(SetClassEditFlags(pFTDInfo->pFTInfo->szId, FTA_OpenIsSafe,
                            ! bConfirm));
}

// Defined originally in shdocvw
#define BROWSEHACK_DONTINPLACENAVIGATE     0x00000008

void 
FTEdit_InitBrowseInPlace(
    HWND hdlg,
    PFILETYPESDIALOGINFO pFTDInfo)
{
    HWND hwndCtl = GetDlgItem(hdlg, IDC_BROWSEINPLACE);
    TCHAR sz[MAX_PATH];

    wsprintf(sz, TEXT("%s\\DocObject"), pFTDInfo->pFTInfo->szId);

    // Does the class\DocObject key exist?
    if (NO_ERROR == SHGetValue(HKEY_CLASSES_ROOT, sz, NULL, NULL, NULL, NULL))
    {
        // Yes
        DWORD dwValue;
        DWORD cbSize;

        EnableWindow(hwndCtl, TRUE);

        cbSize = sizeof(dwValue);
        if (NO_ERROR == SHGetValue(HKEY_CLASSES_ROOT, pFTDInfo->pFTInfo->szId, 
                                   TEXT("BrowserFlags"), NULL, &dwValue,
                                   &cbSize))
        {
            Button_SetCheck(hwndCtl, IS_FLAG_CLEAR(dwValue, BROWSEHACK_DONTINPLACENAVIGATE));
        }
        else
        {
            Button_SetCheck(hwndCtl, TRUE);
        }
    }
}


void
FTEdit_SetBrowseInPlace(
    PFILETYPESDIALOGINFO pFTDInfo,
    BOOL bSet)
{
    DWORD dwValue;
    DWORD cbSize;

    cbSize = sizeof(dwValue);
    if (NO_ERROR == SHGetValue(HKEY_CLASSES_ROOT, pFTDInfo->pFTInfo->szId, 
                               TEXT("BrowserFlags"), NULL, &dwValue,
                               &cbSize))
    {
        // We store the "boolean not" of bSet
        if (bSet)
            CLEAR_FLAG(dwValue, BROWSEHACK_DONTINPLACENAVIGATE);
        else
            SET_FLAG(dwValue, BROWSEHACK_DONTINPLACENAVIGATE);
    }
    else
    {
        dwValue = bSet ? 0 : BROWSEHACK_DONTINPLACENAVIGATE;
    }
    
    // If the value of BrowserFlags is 0, just delete the value altogether.
    if (0 == dwValue)
        SHDeleteValue(HKEY_CLASSES_ROOT, pFTDInfo->pFTInfo->szId, 
                      TEXT("BrowserFlags"));
    else
        SHSetValue(HKEY_CLASSES_ROOT, pFTDInfo->pFTInfo->szId, 
                   TEXT("BrowserFlags"), REG_DWORD, &dwValue, sizeof(dwValue));
}

#endif   /* MIME */

//================================================================
VOID FTEdit_EnableButtonsPerAction(PFILETYPESDIALOGINFO pFTDInfo, HWND hDialog, int iItem)
{
        LV_ITEM LVItem;

           // Get FILETYPESINFO from LVItem's lParam
           LVItem.mask = LVIF_PARAM;
           LVItem.iItem = iItem;
           LVItem.iSubItem = 0;
           LVItem.lParam = 0;
           ListView_GetItem(pFTDInfo->hwndLVFTEdit, &LVItem);

           if(LVItem.lParam == 0)
        {
            // If this fails to get information, we will assume
            // that there are no commands, so disable Edit and remove...
            EnableWindow(GetDlgItem(hDialog, IDC_FT_EDIT_EDIT),FALSE);
            EnableWindow(GetDlgItem(hDialog, IDC_FT_EDIT_REMOVE), FALSE);
            EnableWindow(GetDlgItem(hDialog, IDC_FT_EDIT_DEFAULT), FALSE);
               return;
        }

           pFTDInfo->pFTCInfo = (PFILETYPESCOMMANDINFO)LVItem.lParam;

           pFTDInfo->pFTCInfo->dwVerbAttributes = GetVerbAttributes(pFTDInfo->pFTInfo->hkeyFT, pFTDInfo->pFTCInfo->szActionKey);
           EnableWindow(GetDlgItem(hDialog, IDC_FT_EDIT_EDIT),
               !((pFTDInfo->pFTInfo->dwAttributes & FTA_NoEditVerb) &&
               (!(pFTDInfo->pFTCInfo->dwVerbAttributes & FTAV_UserDefVerb))));
           EnableWindow(GetDlgItem(hDialog, IDC_FT_EDIT_REMOVE),
               !((pFTDInfo->pFTInfo->dwAttributes & FTA_NoRemoveVerb) &&
               (!(pFTDInfo->pFTCInfo->dwVerbAttributes & FTAV_UserDefVerb))));
           EnableWindow(GetDlgItem(hDialog, IDC_FT_EDIT_DEFAULT),
               !((pFTDInfo->pFTInfo->dwAttributes & FTA_NoEditDflt)));
}

//================================================================
//================================================================
BOOL FTEdit_IsExtShowable(PFILETYPESDIALOGINFO pFTDInfo)
{
    char szShowExt[MAX_PATH];
    DWORD dwType;
    DWORD dwShowExt;
    // First see if the type has a FileViews Sub key.
    dwShowExt = sizeof(szShowExt);
    return(RegQueryValueEx(pFTDInfo->pFTInfo->hkeyFT, c_szShowExt, NULL, &dwType, (LPSTR)szShowExt, &dwShowExt)
        == ERROR_SUCCESS);
}

//================================================================
//================================================================
void FTEdit_SetShowExt(PFILETYPESDIALOGINFO pFTDInfo, BOOL bShowExt)
{
    if (bShowExt)
        RegSetValueEx(pFTDInfo->pFTInfo->hkeyFT, (LPSTR)c_szShowExt, 0, REG_SZ, c_szNULL, 0);
    else
        RegDeleteValue(pFTDInfo->pFTInfo->hkeyFT, (LPSTR)c_szShowExt);
}

//================================================================

#ifdef FEATURE_INTL
// International support

typedef struct
{
    HFONT hfontNew;
    HFONT hfontOld;
    BOOL  bStock;
}
DLGFONTDATA, *LPDLGFONTDATA;

#define DLGATOM_FONTDATA 0x100       // for window prop.

BOOL CALLBACK SetfontChildProc(HWND hwnd, LPARAM lparam)
{
    char szClass[32];
    if (GetClassName(hwnd, szClass, sizeof(szClass)))
    {
        if ( !lstrcmpi(szClass, "Edit")
    || !lstrcmpi(szClass, "ComboBox")
    || !lstrcmpi(szClass, "Button")
    || !lstrcmpi(szClass, "ListBox") )
        {
            // the first one is enough to store the font handle.
            if(((DLGFONTDATA *)lparam)->bStock == FALSE
              && ((DLGFONTDATA *)lparam)->hfontOld == NULL)
                ((DLGFONTDATA *)lparam)->hfontOld = GetWindowFont(hwnd);

            SetWindowFont(hwnd, ((DLGFONTDATA *)lparam)->hfontNew, FALSE);
        }
    }
    return TRUE;
}

int CALLBACK MyEnumFontFamProc(
    ENUMLOGFONTEX FAR*  lpelf,    // address of logical-font data
    NEWTEXTMETRIC FAR*  lpntm,    // address of physical-font data
    int  FontType,    // type of font
    LPARAM  lParam     // address of application-defined data
   )
{
    LOGFONT *pLogfont = (LOGFONT*)lParam;

    *pLogfont = lpelf->elfLogFont;

    return;

}

void SetShellFont(HWND hwnd)
{
    LOGFONT    lfGui, lfDlg;
    HFONT   hfont=NULL;
    LPDLGFONTDATA pDfd;

    if ( GetProp(hwnd, MAKEINTATOM(DLGATOM_FONTDATA)) )
        return; // don't do this twice otherwise leaks resource.


    if (!(hfont=GetWindowFont(hwnd)))
    {
        hfont=GetStockObject(SYSTEM_FONT);
    }
    GetObject(hfont, sizeof(LOGFONT), &lfDlg);

    if ( (hfont = GetStockObject(DEFAULT_GUI_FONT)) == FALSE )
    {
        // NT 3.51 case
        LOGFONT *pLogfont;
        HDC hDC = GetDC(hwnd);

        if( !(pLogfont = LocalAlloc(GPTR, sizeof(LOGFONT))) )
        {
            ReleaseDC(hwnd, hDC);
            return;
        }
        GetProfileString("FontSubstitutes","MS Shell Dlg",pLogfont->lfFaceName,
                                   lfGui.lfFaceName,sizeof(lfGui.lfFaceName) );
        EnumFontFamilies(hDC,lfGui.lfFaceName,(FONTENUMPROC)MyEnumFontFamProc,
                                                             (LPARAM)pLogfont);
        lfGui = *pLogfont;
        LocalFree(pLogfont);
        ReleaseDC(hwnd, hDC);

    }
    else
        GetObject(hfont, sizeof(LOGFONT), &lfGui);

    if (!(pDfd = (LPDLGFONTDATA)LocalAlloc(GPTR, sizeof(DLGFONTDATA))))
    {
        return;
    }


    if ( (lfGui.lfHeight != lfDlg.lfHeight) || (hfont == FALSE) )
    {
        lfGui.lfHeight = lfDlg.lfHeight;
        lfGui.lfWidth = lfDlg.lfWidth;
        hfont=CreateFontIndirect(&lfGui);
        pDfd->bStock = FALSE;
    }
    else
        pDfd->bStock = TRUE;

    pDfd->hfontNew = hfont;
    pDfd->hfontOld = NULL;


    EnumChildWindows(hwnd, SetfontChildProc, (LPARAM)pDfd);

    // Set this so that we can delete it at termination.
    if (pDfd->bStock == FALSE)
        SetProp(hwnd, MAKEINTATOM(DLGATOM_FONTDATA), (HANDLE)pDfd);
    else
        // We won't use this if we were able to use stock font.
        LocalFree((HANDLE)pDfd);
}

void DeleteShellFont(HWND hwnd)
{
    DLGFONTDATA *pDfd;

    if (pDfd=(DLGFONTDATA *)GetProp(hwnd, MAKEINTATOM(DLGATOM_FONTDATA)))
    {
        pDfd->hfontNew = pDfd->hfontOld;
        pDfd->hfontOld = NULL;

        EnumChildWindows(hwnd, SetfontChildProc, (LPARAM)pDfd);
        RemoveProp(hwnd, MAKEINTATOM(DLGATOM_FONTDATA));

        // SetfontChildProc should return the original font handle.
        if (pDfd->hfontOld && !pDfd->bStock)
            DeleteObject(pDfd->hfontOld);

        LocalFree((HANDLE)pDfd);
    }
}

#endif


//================================================================
BOOL FTEdit_OnInitDialog(HWND hDialog, WPARAM wParam, LPARAM lParam)
{
    DWORD dwItemCnt;
    LOGFONT lf;
    PFILETYPESDIALOGINFO pFTDInfo;

#ifdef FT_DEBUG
    DebugMsg(DM_TRACE, "FT Edit: WM_INITDIALOG wParam=0x%x lParam=0x%x ", wParam, lParam);
#endif
#ifdef FEATURE_INTL
    if (GetACP() != 1252)
            SetShellFont(hDialog);
#endif

    pFTDInfo = (PFILETYPESDIALOGINFO)lParam;
    SetWindowLongPtr(hDialog, DWLP_USER, (LPARAM)pFTDInfo);
    pFTDInfo->hEditDialog = hDialog;
    pFTDInfo->pFTCInfo = (PFILETYPESCOMMANDINFO)NULL;
    pFTDInfo->szIconPath[0] = 0;

    pFTDInfo->hwndLVFTEdit = GetDlgItem(hDialog, IDC_FT_EDIT_LV_CMDS);

    switch (pFTDInfo->dwCommand)
    {
    case IDC_FT_PROP_EDIT:
        // these guys are already hidden
        // IDC_FT_EDIT_EXTTEXT, IDC_FT_EDIT_EXT

        // Display DOC Icon
        pFTDInfo->hwndEditDocIcon = GetDlgItem(hDialog, IDC_FT_EDIT_DOCICON);
        SendMessage(pFTDInfo->hwndEditDocIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM)pFTDInfo->pFTInfo->hIconDoc);

        // Set edit control with file type description
        SetDlgItemText(hDialog, IDC_FT_EDIT_DESC, pFTDInfo->pFTInfo->szDesc);

        // Init and fill list view with action verbs
        if(pFTDInfo->hwndLVFTEdit != (HWND)NULL)
        {
            if(FTEdit_InitListViewCols(pFTDInfo->hwndLVFTEdit))
            {
                if((dwItemCnt = FTEdit_InitListView((PFILETYPESDIALOGINFO)lParam)) == (-1))
                {
                    return(FALSE);
                }
            }
            else
                return(FALSE);
        }

        // Set listview to item 0
        ListView_SetItemState(pFTDInfo->hwndLVFTEdit, 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);

        lstrcpy(pFTDInfo->szId, pFTDInfo->pFTInfo->szId);  // used for when we are adding a verb to an existing filetype
        EnableWindow(GetDlgItem(hDialog, IDC_FT_EDIT_NEW), !(pFTDInfo->pFTInfo->dwAttributes & FTA_NoNewVerb));
        EnableWindow(GetDlgItem(hDialog, IDC_FT_EDIT_DESC), !(pFTDInfo->pFTInfo->dwAttributes & FTA_NoEditDesc));
        EnableWindow(GetDlgItem(hDialog, IDC_FT_EDIT_CHANGEICON), !(pFTDInfo->pFTInfo->dwAttributes & FTA_NoEditIcon));

        FTEdit_EnableButtonsPerAction(pFTDInfo, hDialog, 0);
        if (pFTDInfo->pFTInfo->hkeyFT)
            // Get rid of old handle
            RegCloseKey(pFTDInfo->pFTInfo->hkeyFT);
        pFTDInfo->pFTInfo->hkeyFT = GetHkeyFT(pFTDInfo->szId);

#ifdef MIME
        CheckDlgButton(hDialog, IDC_FT_EDIT_CONFIRM_OPEN, FTEdit_ConfirmOpenAfterDownload(pFTDInfo));

        FTEdit_InitBrowseInPlace(hDialog, pFTDInfo);
#endif   /* MIME */

        if (FTEdit_IsExtShowable(pFTDInfo))
            CheckDlgButton(hDialog, IDC_FT_EDIT_SHOWEXT, TRUE);
        break;

    case IDC_FT_PROP_NEW:
        {
        char szTitle[256];
        if(!FTEdit_InitListViewCols(pFTDInfo->hwndLVFTEdit))
            return(FALSE);

        MLLoadStringA(IDS_ADDNEWFILETYPE, szTitle, ARRAYSIZE(szTitle));
        SetWindowText(hDialog, szTitle);

        // Make extension text and edit control visible
        pFTDInfo->hwndDocExt = GetDlgItem(hDialog, IDC_FT_EDIT_EXTTEXT);
        ShowWindow(pFTDInfo->hwndDocExt, SW_SHOW);
        pFTDInfo->hwndDocExt = GetDlgItem(hDialog, IDC_FT_EDIT_EXT);
        ShowWindow(pFTDInfo->hwndDocExt, SW_SHOW);
        SetFocus(pFTDInfo->hwndDocExt);
        *pFTDInfo->szId = '\0';
        *pFTDInfo->szIconPath = '\0';


        pFTDInfo->hwndEditDocIcon = GetDlgItem(hDialog, IDC_FT_EDIT_DOCICON);

        EnableWindow(GetDlgItem(hDialog, IDC_FT_EDIT_EDIT), FALSE);
        EnableWindow(GetDlgItem(hDialog, IDC_FT_EDIT_REMOVE), FALSE);
        EnableWindow(GetDlgItem(hDialog, IDC_FT_EDIT_DEFAULT), FALSE);
#ifdef MIME
        CheckDlgButton(hDialog, IDC_FT_EDIT_CONFIRM_OPEN, TRUE);
#endif   /* MIME */
        }
        break;
    }

    // Get the font used in the dialogue box
    pFTDInfo->hfReg = (HFONT)SendMessage( hDialog, WM_GETFONT, 0, 0L );

    if ( NULL == pFTDInfo ->hfReg )
        pFTDInfo->hfReg = GetStockObject( SYSTEM_FONT );

    // Create a bold version of if for default verbs
    GetObject( pFTDInfo->hfReg, SIZEOF(lf), &lf );
    lf.lfWeight = FW_BOLD;
    pFTDInfo->hfBold = CreateFontIndirect(&lf);
#ifdef MIME
   pFTDInfo->pFTInfo->dwMIMEFlags = 0;
   pFTDInfo->hwndContentTypeComboBox = GetDlgItem(hDialog, IDC_FT_COMBO_CONTTYPE);
   pFTDInfo->hwndDefExtensionComboBox = GetDlgItem(hDialog, IDC_FT_COMBO_DEFEXT);
   InitMIMEControls(hDialog);
#endif   /* MIME */
    return(TRUE);    // Successful initdialog
}

//================================================================
//================================================================
#if 0
VOID ChangeDefaultButtonText(HWND hDialog, DWORD dwIDS)
{
    char szStr[256];

    if(MLLoadStringA(dwIDS, szStr, sizeof(szStr)))
        SetWindowText(GetDlgItem(hDialog, IDC_FT_EDIT_DEFAULT), szStr);
}
#endif
//================================================================
//================================================================
#define lpdis ((LPDRAWITEMSTRUCT)lParam)
BOOL FTEdit_OnDrawItem(PFILETYPESDIALOGINFO pFTDInfo, WPARAM wParam, LPARAM lParam)
{
    LV_ITEM LVItem;
        char szActionValue[MAX_PATH];

#ifdef FT_DEBUG
    DebugMsg(DM_TRACE, "FT Edit: WM_DRAWITEM wParam=0x%x lParam=0x%x", wParam, lParam);
#endif

    if (lpdis->CtlType == ODT_LISTVIEW)
    {
        DRAWITEMSTRUCT *lpdi = (LPDRAWITEMSTRUCT)lParam;
        PFILETYPESCOMMANDINFO pFTCInfo;

        LVItem.mask = LVIF_PARAM;
        LVItem.iItem = lpdi->itemID;
        LVItem.iSubItem = 0;
        ListView_GetItem(pFTDInfo->hwndLVFTEdit, &LVItem);  // lParam points to file type info                    pFTInfo = (PFILETYPESINFO)LVItem.lParam;
        pFTCInfo = (PFILETYPESCOMMANDINFO)LVItem.lParam;

        if((pFTDInfo->hwndLVFTEdit == GetFocus()) && ((lpdi->itemState & ODS_FOCUS) && (lpdi->itemState & ODS_SELECTED)))
        {
            SetBkColor(lpdi->hDC, GetSysColor(COLOR_HIGHLIGHT));
            SetTextColor(lpdi->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        }
        else
        {
            SetBkColor(lpdi->hDC, GetSysColor(COLOR_WINDOW));
            SetTextColor(lpdi->hDC, GetSysColor(COLOR_WINDOWTEXT));
        }

        // Use Bold font for default action
        if(IsDefaultAction(pFTDInfo, pFTCInfo->szActionKey))
        {
            SelectObject(lpdi->hDC, pFTDInfo->hfBold);
//            ChangeDefaultButtonText(pFTDInfo->hEditDialog, IDS_CLEARDEFAULT);
        }
        else
        {
            SelectObject(lpdi->hDC, pFTDInfo->hfReg);
//            ChangeDefaultButtonText(pFTDInfo->hEditDialog, IDS_SETDEFAULT);
        }

                StrRemoveChar(pFTCInfo->szActionValue, szActionValue, '&');
        ExtTextOut(lpdi->hDC,
            lpdi->rcItem.left,lpdi->rcItem.top,
            ETO_OPAQUE, &lpdi->rcItem,
            szActionValue, lstrlen(szActionValue),
            NULL);

        // Draw the focus rect if this is the selected or it has focus!
        if ( ( lpdi->itemState & ODS_FOCUS ) || ( lpdi->itemState & ODS_SELECTED ) )
            DrawFocusRect(lpdi->hDC, &lpdi->rcItem);

        return(TRUE);
    }
    return(FALSE);
}
//================================================================
//================================================================
#define lpmis ((LPMEASUREITEMSTRUCT)lParam)
BOOL FTEdit_OnMeasureItem(WPARAM wParam, LPARAM lParam)
{
    LOGFONT lf;

#ifdef FT_DEBUG
    DebugMsg(DM_TRACE, "FT Edit: WM_MEASUREITEM wParam=0x%x lParam=0x%x", wParam, lParam);
#endif

    if (lpmis->CtlType == ODT_LISTVIEW)
    {
        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
//        hfReg = CreateFontIndirect(&lf);
//        lf.lfWeight = FW_BOLD;
//        hfBold = CreateFontIndirect(&lf);
        ((MEASUREITEMSTRUCT *)lParam)->itemHeight = lf.lfHeight;
        ((MEASUREITEMSTRUCT *)lParam)->itemHeight = 14;
        return(TRUE);
    }
    return(FALSE);
}

//================================================================
VOID FTEdit_OnNotify(PFILETYPESDIALOGINFO pFTDInfo, HWND hDialog, WPARAM wParam, LPARAM lParam)
{
#ifdef FT_DEBUG
    DebugMsg(DM_TRACE, "FT Edit: WM_NOTIFY wParam=0x%x lParam=0x%x", wParam, lParam);
#endif
    // Process ListView notifications
    switch(((LV_DISPINFO *)lParam)->hdr.code)
    {
        case NM_DBLCLK:
#ifdef FT_DEBUG
            DebugMsg(DM_TRACE, "FT Edit: WM_NOTIFY - NM_DBLCLK");
#endif
            if(ListView_GetItemCount(pFTDInfo->hwndLVFTEdit))
            {
                if(!(pFTDInfo->pFTInfo->dwAttributes & FTA_NoEditVerb))
                    PostMessage(hDialog, WM_COMMAND, (WPARAM)IDC_FT_EDIT_EDIT, 0);
            }
            break;

        case NM_SETFOCUS:
        case NM_KILLFOCUS:
            // update list view
            ListView_RedrawItems(pFTDInfo->hwndLVFTEdit, 0, ListView_GetItemCount(pFTDInfo->hwndLVFTEdit));
            UpdateWindow(pFTDInfo->hwndLVFTEdit);
            break;

        case LVN_ITEMCHANGED:
#ifdef FT_DEBUG
            DebugMsg(DM_TRACE, "FT Edit: WM_NOTIFY - LVN_ITEMCHANGED");
#endif

            if((((NM_LISTVIEW *)lParam)->uChanged & LVIF_STATE) &&
            ((NM_LISTVIEW *)lParam)->uNewState & (LVIS_FOCUSED | LVIS_SELECTED))
            {
                            FTEdit_EnableButtonsPerAction(pFTDInfo, hDialog,
                           pFTDInfo->iEditItem = ((NM_LISTVIEW *)lParam)->iItem);
            }
            break;
                case LVN_DELETEITEM:
                        // We were notified that an item was deleted.
                        // so delete the underlying data that it is pointing
                        // to.
                        if (((NM_LISTVIEW*)lParam)->lParam)
                                LocalFree((HANDLE)((NM_LISTVIEW*)lParam)->lParam);
                        break;

    }    // switch(((LV_DISPINFO *)lParam)->hdr.code)
}

//================================================================
//================================================================
BOOL FTEdit_OnOK(PFILETYPESDIALOGINFO pFTDInfo, HWND hDialog)
{
    LV_ITEM LVItem;
    char szExt[MAX_PATH];
    char szDesc[MAX_PATH];

    if(pFTDInfo->dwCommand == IDC_FT_PROP_NEW)
        {
        GetDlgItemText(hDialog, IDC_FT_EDIT_EXT, szExt, sizeof(szExt));

                // We need to do some cleanup here to make it work properly
                // in the cases where ther user types in something like
                // *.foo or .foo
                // This is real crude
                StrRemoveChar(szExt, NULL, '*');
        }
    else
        lstrcpy(szExt, DPA_FastGetPtr(pFTDInfo->pFTInfo->hDPAExt,0));

    // Validate file type description
    GetDlgItemText(hDialog, IDC_FT_EDIT_DESC, szDesc, sizeof(szDesc));
    if(!(*szDesc))
    {
        lstrcpy(szDesc, CharUpper((szExt[0] == '.' ? &szExt[1] : szExt)));
        if (lstrlen(szDesc)+lstrlen(c_szSpaceFile) < ARRAYSIZE(szDesc))
        {
            lstrcat(szDesc, c_szSpaceFile);
        }
    }

    // Save extension when new type is selected
    if(pFTDInfo->dwCommand == IDC_FT_PROP_NEW)
    {
        if(!ValidExtension(hDialog, pFTDInfo))
            return(FALSE);
        AddExtDot(CharLower(szExt), sizeof(szExt));
        if(pFTDInfo->hwndLVFT != (HWND)NULL)
        {
            HKEY hkeyFT = GetHkeyFT(pFTDInfo->szId);
            FT_AddInfoToLV(pFTDInfo, hkeyFT, szExt, szDesc, pFTDInfo->szId, 0);
            pFTDInfo->pFTInfo->dwAttributes = FTA_HasExtension;
        }
        SaveFileTypeData(FTD_EXT, pFTDInfo);
    }

    lstrcpy(pFTDInfo->pFTInfo->szDesc, szDesc);
    SetDlgItemText(hDialog, IDC_FT_EDIT_DESC, szDesc);

    // Save file type id, description, and default action
    SaveFileTypeData(FTD_EDIT, pFTDInfo);

    // Save Doc icon if a change was made
    if(*pFTDInfo->szIconPath)
    {
        SaveFileTypeData(FTD_DOCICON, pFTDInfo);

        // Get the image index from the list view item
        LVItem.mask        = LVIF_IMAGE;
        LVItem.iItem       = pFTDInfo->iItem;
        LVItem.iSubItem    = 0;
        ListView_GetItem(pFTDInfo->hwndLVFT, &LVItem);

        // replace the icon in the image list
        if(pFTDInfo->himlFT && (LVItem.iImage >= 0) && pFTDInfo->pFTInfo->hIconDoc)
            if(ImageList_ReplaceIcon(pFTDInfo->himlFT, LVItem.iImage, pFTDInfo->pFTInfo->hIconDoc) != (-1))
                ListView_SetItem(pFTDInfo->hwndLVFT, &LVItem);
    }
    if(pFTDInfo->dwCommand == IDC_FT_PROP_EDIT)
    {
        // Tell prev dialog to update new values
        LVItem.mask       = LVIF_TEXT;
        LVItem.iItem      = pFTDInfo->iItem;
        LVItem.iSubItem   = 0;
        LVItem.pszText    = pFTDInfo->pFTInfo->szDesc;
        ListView_SetItem(pFTDInfo->hwndLVFT, &LVItem);
    }

#ifdef MIME
        FTEdit_SetConfirmOpenAfterDownload(pFTDInfo, IsDlgButtonChecked(hDialog, IDC_FT_EDIT_CONFIRM_OPEN));

        if (IsWindowEnabled(GetDlgItem(hDialog, IDC_BROWSEINPLACE)))
            FTEdit_SetBrowseInPlace(pFTDInfo, IsDlgButtonChecked(hDialog, IDC_BROWSEINPLACE));
#endif   /* MIME */

    FTEdit_SetShowExt(pFTDInfo, IsDlgButtonChecked(hDialog,
            IDC_FT_EDIT_SHOWEXT));

    if(pFTDInfo->dwCommand == IDC_FT_PROP_NEW)
    {
        if(pFTDInfo->hwndLVFT != (HWND)NULL)
        {
            int iItem;
            LV_FINDINFO LV_FindInfo;

            ListView_SetItemState(pFTDInfo->hwndLVFT, pFTDInfo->iItem, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
            ListView_SortItems(pFTDInfo->hwndLVFT, NULL, 0);
            LV_FindInfo.flags = LVFI_PARAM;
            LV_FindInfo.lParam = (LPARAM)pFTDInfo->pFTInfo;
            if((iItem = ListView_FindItem(pFTDInfo->hwndLVFT, -1, &LV_FindInfo)) != -1)
                pFTDInfo->iItem = iItem;
            else
                pFTDInfo->iItem = 0;
            ListView_EnsureVisible(pFTDInfo->hwndLVFT, pFTDInfo->iItem, FALSE);
            PostMessage(pFTDInfo->hwndLVFT, WM_SETFOCUS, (WPARAM)0, (LPARAM)0);
        }
    }

#ifdef MIME
    SaveFileTypeData(FTD_MIME, pFTDInfo);
#endif   /* MIME */

    // This may be overkill but for now, have it refresh the
    // windows...
    SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);

    return(TRUE);
}

//================================================================
//================================================================
VOID FTEdit_OnRemove(PFILETYPESDIALOGINFO pFTDInfo, HWND hDialog)
{
    char    szMsg[MAX_PATH];
    char    szTitle[MAX_PATH];
    
    // HKEY_CLASSES_ROOT\filetype\shell\action key

    MLLoadStringA(IDS_FT_MB_REMOVEACTION, szMsg, ARRAYSIZE(szMsg));
    MLLoadStringA(IDS_FT, szTitle, ARRAYSIZE(szTitle));
    
    if(ShellMessageBox(MLGetHinst(), hDialog,
        szMsg,
        szTitle,MB_YESNO | MB_ICONQUESTION) == IDNO)
        return;

    Assert(pFTDInfo->pFTInfo->hkeyFT);
    RemoveAction(pFTDInfo, pFTDInfo->pFTInfo->hkeyFT, c_szShell,
                pFTDInfo->pFTCInfo->szActionKey);

    if(ListView_GetItemCount(pFTDInfo->hwndLVFTEdit) == 0)
    {
        EnableWindow(GetDlgItem(hDialog, IDC_FT_EDIT_EDIT), FALSE);
        EnableWindow(GetDlgItem(hDialog, IDC_FT_EDIT_REMOVE), FALSE);
        EnableWindow(GetDlgItem(hDialog, IDC_FT_EDIT_DEFAULT), FALSE);
    }

    OkToClose_NoCancel(hDialog);
    PropSheet_CancelToClose(GetParent(pFTDInfo->hPropDialog));
}
//================================================================
//================================================================


// Helper function to query a key value, returning if the key has been queried
// and the result was non-zero.
// REARCHITECT (scotth): we already have helper functions that do this.
//                  this needs cleaning

static BOOL do_query_value( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValue, LONG lSize )
{
    LONG err = lSize;

    err = RegQueryValue( hKey, lpSubKey, lpValue, &err );

    return ( err == ERROR_SUCCESS && *lpValue );
}


// Given a sub key attempt to find it in in the classes section of the registry:

static BOOL find_sub_key( LPCTSTR lpExt, LPCTSTR lpSubKey, LPTSTR lpValue, LONG iSize )
{
    BOOL bResult = FALSE;
    TCHAR szProgId[MAX_PATH];
    TCHAR szTemp[MAX_PATH * 3 ];
    TCHAR szCLSID[ MAX_PATH ];
    HKEY hKey = NULL;

    // Attempt to get our root key, check for a ProgId, otherwise leave it at the extension
    if ( do_query_value( HKEY_CLASSES_ROOT, lpExt, szProgId, SIZEOF(szProgId) ) )
        RegOpenKey( HKEY_CLASSES_ROOT, szProgId, &hKey );
    else
        RegOpenKey( HKEY_CLASSES_ROOT, lpExt, &hKey );

    // If we aquired the key then check for the sub-key
    if ( hKey )
    {
        bResult = do_query_value( hKey, lpSubKey, lpValue, iSize );

        // Didn't find it, so check for the CLSID and look under that
        if ( !bResult && do_query_value( hKey, c_szCLSID, szCLSID, SIZEOF(szCLSID) ) )
        {
            wsprintf( szTemp, c_szTemplateSSS, c_szCLSID, szCLSID, lpSubKey );
            bResult = do_query_value( HKEY_CLASSES_ROOT, szTemp, lpValue, iSize );
        }

        RegCloseKey( hKey );
    }

    return bResult;
}


// Handle displaying the icon picker for the givne extension, follow the same icon
// rules as the Explorer.

VOID FTEdit_OnChangeIcon(PFILETYPESDIALOGINFO pFTDInfo, HWND hDialog)
{
    SHFILEINFO sfi;
    HICON hIcon;
    char szBuf[MAX_PATH-2];

    if(pFTDInfo->dwCommand == IDC_FT_PROP_NEW)
    {
        lstrcpy(sfi.szDisplayName, c_szShell2);
        sfi.iIcon = -(IDI_SYSFILE);
    }
    else
    {
        LPTSTR pszExt = (LPTSTR)DPA_FastGetPtr(pFTDInfo->pFTInfo->hDPAExt,0);

        sfi.szDisplayName[0]='\0';              // no initial string
        sfi.iIcon = 0;                          // default to first icon

        // If we have an extension then attempt to look up a suitable icon for it.
        if ( *pszExt )
        {
            // check for a DefaultIcon, if found the convert into something useful
            if ( find_sub_key( pszExt, c_szDefaultIcon, sfi.szDisplayName, SIZEOF(sfi.szDisplayName) ) )
            {
                sfi.iIcon = ParseIconLocation( sfi.szDisplayName );
            }
            else
            {
                // Otherwise take the ShellOpen command and work wit that
                find_sub_key( pszExt, c_szShellOpenCommand, sfi.szDisplayName, SIZEOF(sfi.szDisplayName) );
            }
        }
        else
        {
            // Some objects don't have extensions, therefore we must attempt to use the key
            // we were given when invoked.

            if ( do_query_value( pFTDInfo->pFTInfo->hkeyFT, c_szDefaultIcon, sfi.szDisplayName, SIZEOF(sfi.szDisplayName) ) )
                                 sfi.iIcon = ParseIconLocation( sfi.szDisplayName );

        }
    }

    if( *sfi.szDisplayName )
    {
        // Fix up the name we have so that we can display the PickIcon dlg, this includes
        // resolve the relative item, and striping arguments.  Should this fail then we
        // strip the string of arguments and pass it in, letting PickIcon do its worst!

        if ( UrlPathProcessCommand( sfi.szDisplayName, sfi.szDisplayName, SIZEOF(sfi.szDisplayName), PPCF_NODIRECTORIES ) == -1 )
        {
            PathQuoteSpaces( sfi.szDisplayName );
            PathRemoveArgs( sfi.szDisplayName );
            PathRemoveBlanks( sfi.szDisplayName );
            PathUnquoteSpaces( sfi.szDisplayName );
        }

        if(lstrcmp(sfi.szDisplayName, c_szExefileOpenCommand) == 0)
            *sfi.szDisplayName = TEXT('\0');
        else
        {
            if(PathIsRelative(sfi.szDisplayName))
                PathFindOnPath(sfi.szDisplayName, NULL);        // search for exe
        }
    }

#ifdef FT_DEBUG
    DebugMsg(DM_TRACE, "FTEdit_OnChangeIcon RegQueryValue szIcon=%s iIndex=%d hkeyFT=0x%x",
            sfi.szDisplayName, sfi.iIcon, pFTDInfo->pFTInfo->hkeyFT);
#endif

    if (RUNNING_NT)
        MultiByteToWideChar(CP_ACP, 0, sfi.szDisplayName, -1,
                    (LPWSTR)szBuf, sizeof(szBuf));
    else
        lstrcpy(szBuf, sfi.szDisplayName);

    if(PickIconDlg(hDialog, (LPWSTR)szBuf, sizeof(szBuf), &sfi.iIcon))  // (LPWSTR) so it builds, but only works downlevel
    {
        if (RUNNING_NT)
            WideCharToMultiByte(CP_ACP, 0, (LPWSTR)szBuf, -1,
                    pFTDInfo->szIconPath,sizeof(szBuf), NULL, NULL);
        else
            lstrcpy(pFTDInfo->szIconPath, szBuf);

        pFTDInfo->iIconIndex = sfi.iIcon;
        hIcon = ExtractIcon(hinstCabinet, pFTDInfo->szIconPath, pFTDInfo->iIconIndex);
        if(hIcon != (HICON)NULL)
        {
            if((pFTDInfo->hwndEditDocIcon = GetDlgItem(hDialog, IDC_FT_EDIT_DOCICON)) != (HWND)NULL)
                SendMessage(pFTDInfo->hwndEditDocIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
            if(pFTDInfo->pFTInfo->hIconDoc != (HICON)NULL)
                DestroyIcon(pFTDInfo->pFTInfo->hIconDoc);
            pFTDInfo->pFTInfo->hIconDoc = hIcon;
        }

        // OK -> Close and Disable Cancel
        if(pFTDInfo->dwCommand == IDC_FT_PROP_EDIT)
        {
            OkToClose_NoCancel(hDialog);
            PropSheet_CancelToClose(GetParent(pFTDInfo->hPropDialog));
        }
    }
}

//================================================================
//================================================================
VOID FTEdit_OnCommand(PFILETYPESDIALOGINFO pFTDInfo, HWND hDialog, WPARAM wParam, LPARAM lParam)
{
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);

#ifdef FT_DEBUG
    DebugMsg(DM_TRACE, "FT Edit: WM_COMMAND wParam hi=0x%04x lo=0x%04x lParam=0x%x", HIWORD(wParam), LOWORD(wParam), lParam);
#endif

    switch(idCmd)
    {
        case IDOK:
            if(!FTEdit_OnOK(pFTDInfo, hDialog))
                break;
            // Fall through...
        case IDCANCEL:
            DeleteObject(pFTDInfo->hfBold);
            EndDialog(hDialog, (idCmd == IDOK));
            break;

        case IDC_FT_EDIT_NEW:
        {
            int iPrevEditItem = pFTDInfo->iEditItem;

            if(pFTDInfo->dwCommand == IDC_FT_PROP_NEW)
            {
                if(!ValidExtension(hDialog, pFTDInfo))
                    break;
            }
            pFTDInfo->dwCommandEdit = idCmd;
            pFTDInfo->iEditItem = ListView_GetItemCount(pFTDInfo->hwndLVFTEdit) + 1;
            if(DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(DLG_FILETYPEOPTIONSCMD), hDialog, FTCmd_DlgProc, (LPARAM)pFTDInfo))
            {
                OkToClose_NoCancel(hDialog);
                PropSheet_CancelToClose(GetParent(pFTDInfo->hPropDialog));
            }
            else
                pFTDInfo->iEditItem = iPrevEditItem;

            // We need to again see if the commands for edit
            // and remove should be enabled...
            //
            FTEdit_EnableButtonsPerAction(pFTDInfo, hDialog, pFTDInfo->iEditItem);

            break;
        }

        case IDC_FT_EDIT_EDIT:
            pFTDInfo->dwCommandEdit = idCmd;
            if(DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(DLG_FILETYPEOPTIONSCMD), hDialog, FTCmd_DlgProc, (LPARAM)pFTDInfo))
            {
                OkToClose_NoCancel(hDialog);
                PropSheet_CancelToClose(GetParent(pFTDInfo->hPropDialog));
            }
            break;

        case IDC_FT_EDIT_REMOVE:
            FTEdit_OnRemove(pFTDInfo, hDialog);
            break;

        case IDC_FT_EDIT_CHANGEICON:
            FTEdit_OnChangeIcon(pFTDInfo, hDialog);
            break;

        case IDC_FT_EDIT_DEFAULT:
            SetDefaultAction(pFTDInfo);    // set default action for current item

            // update list view
            ListView_RedrawItems(pFTDInfo->hwndLVFTEdit, 0, ListView_GetItemCount(pFTDInfo->hwndLVFTEdit));
            UpdateWindow(pFTDInfo->hwndLVFTEdit);

            OkToClose_NoCancel(hDialog);
            PropSheet_CancelToClose(GetParent(pFTDInfo->hPropDialog));
            break;

#ifdef MIME
      case IDC_FT_COMBO_CONTTYPE:
         switch (GET_WM_COMMAND_CMD(wParam, lParam))
         {
            case CBN_SELCHANGE:
               TRACE_OUT(("FTEdit_OnCommand(): MIME Type selection change."));
               OnContentTypeSelectionChange(hDialog);
               break;
            case CBN_EDITCHANGE:
               TRACE_OUT(("FTEdit_OnCommand(): MIME Type edit change."));
               OnContentTypeEditChange(hDialog);
               break;
            case CBN_DROPDOWN:
               TRACE_OUT(("FTEdit_OnCommand(): MIME Type drop down."));
               OnContentTypeDropDown(hDialog);
               break;
         }
         break;
      case IDC_FT_COMBO_DEFEXT:
         switch (GET_WM_COMMAND_CMD(wParam, lParam))
         {
            case CBN_DROPDOWN:
               TRACE_OUT(("FTEdit_OnCommand(): Default Ext drop down."));
               OnDefExtensionDropDown(hDialog);
               break;
         }
         break;
      case IDC_FT_EDIT_EXT:
         switch (GET_WM_COMMAND_CMD(wParam, lParam))
         {
            case EN_CHANGE:
               TRACE_OUT(("FTEdit_OnCommand(): Associated Ext change."));
               OnContentTypeEditChange(hDialog);
               break;
         }
         break;
#endif   /* MIME */
    }
}

//================================================================
//================================================================
#pragma data_seg(DATASEG_READONLY)
const static DWORD aEditFileTypesHelpIDs[] = {  // Context Help IDs
    IDC_NO_HELP_1,              NO_HELP,
    IDC_FT_EDIT_DOCICON,        IDH_FCAB_FT_EDIT_DOCICON,
    IDC_FT_EDIT_CHANGEICON,     IDH_FCAB_FT_EDIT_CHANGEICON,
    IDC_FT_EDIT_DESCTEXT,       IDH_FCAB_FT_EDIT_DESC,
    IDC_FT_EDIT_DESC,           IDH_FCAB_FT_EDIT_DESC,
    IDC_FT_EDIT_EXTTEXT,        IDH_FCAB_FT_EDIT_EXT,
    IDC_FT_EDIT_EXT,            IDH_FCAB_FT_EDIT_EXT,
#ifdef MIME
    IDC_FT_COMBO_CONTTYPETEXT,  IDH_NEW_FILETYPE_CONTENT_TYPE,
    IDC_FT_COMBO_CONTTYPE,      IDH_NEW_FILETYPE_CONTENT_TYPE,
    IDC_FT_COMBO_DEFEXTTEXT,    IDH_NEWFILETYPE_DEFAULT_EXT,
    IDC_FT_COMBO_DEFEXT,        IDH_NEWFILETYPE_DEFAULT_EXT,
    IDC_FT_EDIT_CONFIRM_OPEN,   IDH_FILETYPE_CONFIRM_OPEN,
    IDC_BROWSEINPLACE,          NO_HELP,
#endif   /* MIME */
    IDC_FT_EDIT_LV_CMDSTEXT,    IDH_FCAB_FT_EDIT_LV_CMDS,
    IDC_FT_EDIT_LV_CMDS,        IDH_FCAB_FT_EDIT_LV_CMDS,
    IDC_FT_EDIT_DEFAULT,        IDH_FCAB_FT_EDIT_DEFAULT,
    IDC_FT_EDIT_NEW,            IDH_FCAB_FT_EDIT_NEW,
    IDC_FT_EDIT_EDIT,           IDH_FCAB_FT_EDIT_EDIT,
    IDC_FT_EDIT_REMOVE,         IDH_FCAB_FT_EDIT_REMOVE,
    IDC_FT_EDIT_SHOWEXT,        IDH_FCAB_FT_EDIT_SHOWEXT,
    0,                          0
};
#pragma data_seg()
//================================================================
//================================================================

INT_PTR CALLBACK FTEdit_DlgProc(HWND hDialog, UINT message, WPARAM wParam, LPARAM lParam)
{
    PFILETYPESDIALOGINFO pFTDInfo = (PFILETYPESDIALOGINFO)GetWindowLongPtr(hDialog, DWLP_USER);

    switch(message)
    {
        case WM_INITDIALOG:
            if(!FTEdit_OnInitDialog(hDialog, wParam, lParam))
            {
                EndDialog(hDialog, FALSE);
                break;
            }
            else
                return(TRUE);

        case WM_DRAWITEM:
            FTEdit_OnDrawItem(pFTDInfo, wParam, lParam);
            break;

        case WM_MEASUREITEM:
            return(FTEdit_OnMeasureItem(wParam, lParam));

        case WM_NOTIFY:
            FTEdit_OnNotify(pFTDInfo, hDialog, wParam, lParam);
            break;

        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle,
#ifdef MIME
                    FT_GetHelpFileFromControl((HWND)(((LPHELPINFO)lParam)->hItemHandle)),
#else
                    NULL,
#endif   /* MIME */
                     HELP_WM_HELP, (DWORD_PTR)(LPSTR)aEditFileTypesHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
        {
            POINT pt;

            if ((int)SendMessage(hDialog, WM_NCHITTEST, 0, lParam) != HTCLIENT)
               return FALSE;   // don't process it

            LPARAM_TO_POINT(lParam, pt);
            EVAL(ScreenToClient(hDialog, &pt));

            SHWinHelpOnDemandWrap((HWND)wParam,
#ifdef MIME
                    FT_GetHelpFileFromControl(ChildWindowFromPoint(hDialog, pt)),
#else
                    NULL,
#endif   /* MIME */
                    HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)aEditFileTypesHelpIDs);

            return TRUE;
        }

        case WM_COMMAND:
            FTEdit_OnCommand(pFTDInfo, hDialog, wParam, lParam);
            break;

        case WM_CTRL_SETFOCUS:
            SetFocus((HWND)lParam);
            SendMessage((HWND)lParam, EM_SETSEL, (WPARAM)0, (LPARAM)MAKELPARAM(0, -1));
            break;
#ifdef FEATURE_INTL

        case WM_DESTROY:
            if (GetACP() != 1252)
                DeleteShellFont(hDialog);
            break;
#endif
    }
    return(FALSE);
}

//================================================================
//================================================================
VOID FTCmd_OnInitDialog(HWND hDialog, WPARAM wParam, LPARAM lParam)
{
    char szPath[MAX_PATH+6];    // 6 = "\shell"
    char szAction[MAX_PATH];
    DWORD dwAction;
    DWORD dwPath;
    char szBuf[256];
    int iLen;
    LONG err;
    PFILETYPESDIALOGINFO pFTDInfo;

#ifdef FT_DEBUG
    DebugMsg(DM_TRACE, "FT Cmd: WM_INITDIALOG wParam=0x%x lParam=0x%x ", wParam, lParam);
#endif

    pFTDInfo = (PFILETYPESDIALOGINFO)lParam;
    SetWindowLongPtr(hDialog, DWLP_USER, (LPARAM)pFTDInfo);
    pFTDInfo->hCmdDialog = hDialog;

    // Limit the extension length
    SendDlgItemMessage(hDialog, IDC_FT_EDIT_EXT, EM_LIMITTEXT, (WPARAM)PATH_CCH_EXT, 0);

    if(pFTDInfo->dwCommandEdit == IDC_FT_EDIT_EDIT)
    {
        // Set window title to show file type description we are editing
        if(MLLoadStringA(IDS_FT_EDITTITLE, szBuf, sizeof(szBuf)))
        {
            lstrcpy(szPath, szBuf);
            GetDlgItemText( GetParent(hDialog), IDC_FT_EDIT_DESC, szBuf, SIZEOF(szBuf) );       // ensures correct title, even if edited!
            lstrcat(szPath, szBuf);
            SetWindowText(hDialog, szPath);
        }

        // Set application field to executable used to perform action shown above
        dwPath = sizeof(pFTDInfo->pFTCInfo->szCommand);
        VerbToExe(pFTDInfo->pFTInfo->hkeyFT, pFTDInfo->pFTCInfo->szActionKey,
            pFTDInfo->pFTCInfo->szCommand, &dwPath);

        // Remove %1 if at end of string
        lstrcpy(szBuf, c_szSpPercentOne);    // StrCmpN modifies LPCSTR's even though that is how its params are declared
        iLen = lstrlen(c_szSpPercentOne);
        if(StrCmpN(&pFTDInfo->pFTCInfo->szCommand[lstrlen(pFTDInfo->pFTCInfo->szCommand)-iLen],
                szBuf, iLen) == 0)
            pFTDInfo->pFTCInfo->szCommand[lstrlen(pFTDInfo->pFTCInfo->szCommand)-iLen] = '\0';

        SetDlgItemText(hDialog, IDC_FT_CMD_EXE, pFTDInfo->pFTCInfo->szCommand);

        // Set command field to action verb keys value
        wsprintf(szPath, c_szTemplateSS, c_szShell, pFTDInfo->pFTCInfo->szActionKey);
        Assert(pFTDInfo->pFTInfo->hkeyFT);
        dwAction = sizeof(szAction);
        err = RegQueryValue(pFTDInfo->pFTInfo->hkeyFT, szPath, szAction, &dwAction);
        if(err == ERROR_SUCCESS && *szAction)
            lstrcpy(pFTDInfo->pFTCInfo->szActionValue, szAction);
                else
            lstrcpy(pFTDInfo->pFTCInfo->szActionValue, pFTDInfo->pFTCInfo->szActionKey);

        SetDlgItemText(hDialog, IDC_FT_CMD_ACTION, pFTDInfo->pFTCInfo->szActionValue);

        if(FindDDEOptions(((PFILETYPESDIALOGINFO)lParam)))
        {
            // Check the Use DDE checkbox
            CheckDlgButton(hDialog, IDC_FT_CMD_USEDDE, TRUE);

            // Set DDE field values
            SetDlgItemText(hDialog, IDC_FT_CMD_DDEMSG,
                pFTDInfo->pFTCInfo->szDDEMsg);
            SetDlgItemText(hDialog, IDC_FT_CMD_DDEAPP,
                pFTDInfo->pFTCInfo->szDDEApp);
            SetDlgItemText(hDialog, IDC_FT_CMD_DDEAPPNOT,
                pFTDInfo->pFTCInfo->szDDEAppNot);
            SetDlgItemText(hDialog, IDC_FT_CMD_DDETOPIC,
                pFTDInfo->pFTCInfo->szDDETopic);
        }

    }

    if(pFTDInfo->dwCommandEdit == IDC_FT_EDIT_NEW)  // enable all controls on New
    {
        pFTDInfo->pFTInfo->dwAttributes &= ((FTA_NoEditVerbCmd|FTA_NoEditVerbExe|FTA_NoDDE) ^ 0xffffffff);
    }

//    // Add items to action combo box
//    SendMessage(GetDlgItem(hDialog, IDC_FT_CMD_ACTION), CB_ADDSTRING, 0, (LPARAM)c_szOpenVerb);
//    SendMessage(GetDlgItem(hDialog, IDC_FT_CMD_ACTION), CB_ADDSTRING, 0, (LPARAM)c_szPrintVerb);

    // Don't allow actions to be edited if not new - bug#9553
    EnableWindow(GetDlgItem(hDialog, IDC_FT_CMD_ACTION),
        !(pFTDInfo->pFTInfo->dwAttributes & FTA_NoEditVerbCmd)&&
                (pFTDInfo->dwCommandEdit != IDC_FT_EDIT_EDIT));

    EnableWindow(GetDlgItem(hDialog, IDC_FT_CMD_EXE),
        !((pFTDInfo->pFTInfo->dwAttributes & FTA_NoEditVerbExe) &&
          (!(pFTDInfo->pFTCInfo->dwVerbAttributes & FTAV_UserDefVerb))));
    EnableWindow(GetDlgItem(hDialog, IDC_FT_CMD_BROWSE),
        !((pFTDInfo->pFTInfo->dwAttributes & FTA_NoEditVerbExe) &&
          (!(pFTDInfo->pFTCInfo->dwVerbAttributes & FTAV_UserDefVerb))));
    ShowWindow(GetDlgItem(hDialog, IDC_FT_CMD_USEDDE),
        (((pFTDInfo->pFTInfo->dwAttributes & FTA_NoDDE) &&
          (!(pFTDInfo->pFTCInfo->dwVerbAttributes & FTAV_UserDefVerb))) ?SW_HIDE :SW_SHOW));

    // Resize Dialog to see/hide DDE controls
    ResizeCommandDlg(hDialog, (pFTDInfo->pFTInfo->dwAttributes & FTA_NoDDE ?0 :IsDlgButtonChecked(hDialog, IDC_FT_CMD_USEDDE)));
}

//====================================================================
//====================================================================
LONG DeleteDDEKeys(LPCSTR pszKey)
{
    char szBuf[MAX_PATH+MAXEXTSIZE+6+8]; // 6 = "\shell", 8 = "\ddeexec"

    // Delete DDEApp keys
    wsprintf(szBuf, c_szTemplateSS, pszKey, c_szDDEExec);
    return(RegDeleteKey(HKEY_CLASSES_ROOT, szBuf));
}

//================================================================
//================================================================
BOOL FTCmd_OnOK(PFILETYPESDIALOGINFO pFTDInfo, HWND hDialog, WPARAM wParam, LPARAM lParam)
{
    char szPath[MAX_PATH];
    char szKey[MAX_PATH+MAXEXTSIZE+7]; // 7 = "\shell\"
    char szAction[MAX_PATH];

    // Validate fields
    if(!ActionIsEntered(hDialog, TRUE))
        return(FALSE);
    if(!ActionExeIsValid(hDialog, TRUE))
        return(FALSE);

    // Get and save edit command dialog text
    GetDlgItemText(hDialog, IDC_FT_CMD_ACTION, szAction, sizeof(szAction));
    if(!(*szAction))  // Must have a value
        return(FALSE);

    if(pFTDInfo->dwCommandEdit == IDC_FT_EDIT_NEW)
    {
        if(!FTEdit_AddInfoToLV(pFTDInfo, NULL, szAction, pFTDInfo->szId, (HKEY)NULL))
            return(FALSE);
        ListView_RedrawItems(pFTDInfo->hwndLVFTEdit, 0, ListView_GetItemCount(pFTDInfo->hwndLVFTEdit));
    }

    if(pFTDInfo->pFTCInfo)
    {
        lstrcpy(pFTDInfo->pFTCInfo->szActionValue, szAction);
        // Get executable field value for this verb
        lstrcpy(szPath, pFTDInfo->pFTCInfo->szCommand);    // save prev val for check below
        GetDlgItemText(hDialog, IDC_FT_CMD_EXE,
            pFTDInfo->pFTCInfo->szCommand, sizeof(pFTDInfo->pFTCInfo->szCommand));

        // Add %1 to end if not already part of command
        lstrcpy(szAction, &c_szSpPercentOne[1]);   // borrow szAction; StrStr mods param 2
        if(StrStr(pFTDInfo->pFTCInfo->szCommand, szAction) == NULL
             && lstrlen(pFTDInfo->pFTCInfo->szCommand) + lstrlen(c_szSpPercentOne)
                      < ARRAYSIZE(pFTDInfo->pFTCInfo->szCommand) )
        {
            lstrcat(pFTDInfo->pFTCInfo->szCommand, c_szSpPercentOne);
        }

        // Get DDE field values
        if(IsDlgButtonChecked(hDialog, IDC_FT_CMD_USEDDE))
        {
            GetDlgItemText(hDialog, IDC_FT_CMD_DDEMSG,
                pFTDInfo->pFTCInfo->szDDEMsg, sizeof(pFTDInfo->pFTCInfo->szDDEMsg));
            GetDlgItemText(hDialog, IDC_FT_CMD_DDEAPP,
                pFTDInfo->pFTCInfo->szDDEApp, sizeof(pFTDInfo->pFTCInfo->szDDEApp));
            GetDlgItemText(hDialog, IDC_FT_CMD_DDEAPPNOT,
                pFTDInfo->pFTCInfo->szDDEAppNot, sizeof(pFTDInfo->pFTCInfo->szDDEAppNot));
            GetDlgItemText(hDialog, IDC_FT_CMD_DDETOPIC,
                pFTDInfo->pFTCInfo->szDDETopic, sizeof(pFTDInfo->pFTCInfo->szDDETopic));
        }
        else
        {
            // HKEY_CLASSES_ROOT\filetype\shell\action key
            wsprintf(szKey, c_szTemplateSSS, pFTDInfo->pFTCInfo->szId, c_szShell,
                                pFTDInfo->pFTCInfo->szActionKey);
            DeleteDDEKeys(szKey);
            *pFTDInfo->pFTCInfo->szDDEMsg = 0;
            *pFTDInfo->pFTCInfo->szDDEApp = 0;
            *pFTDInfo->pFTCInfo->szDDEAppNot = 0;
            *pFTDInfo->pFTCInfo->szDDETopic = 0;
        }
        pFTDInfo->pFTCInfo->dwVerbAttributes = FTAV_UserDefVerb;
        SaveFileTypeData(FTD_COMMAND, pFTDInfo);

        // If exe has changed cause redraw of icon and exe name in prop sheet
        if(lstrcmpi(szPath, pFTDInfo->pFTCInfo->szCommand) != 0)
        {
            HICON hIcon = NULL;


            if(IsDefaultAction(pFTDInfo, pFTDInfo->pFTCInfo->szActionKey))
            {
                     if(pFTDInfo->dwCommand == IDC_FT_PROP_EDIT)
                     {
                         // Cause refind/redraw of Doc and Open icons in main dialog
                         if(pFTDInfo->pFTInfo->hIconDoc != (HICON)NULL)
                         {
                             DestroyIcon(pFTDInfo->pFTInfo->hIconDoc);
                             pFTDInfo->pFTInfo->hIconDoc = (HICON)NULL;
                             SendMessage(pFTDInfo->hwndDocIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM)0);
                         }
                         if(pFTDInfo->pFTInfo->hIconOpen != (HICON)NULL)
                         {
                             DestroyIcon(pFTDInfo->pFTInfo->hIconOpen);
                             pFTDInfo->pFTInfo->hIconOpen = (HICON)NULL;
                             SendMessage(pFTDInfo->hwndOpenIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM)0);
                         }
                     }

                lstrcpy(szPath, pFTDInfo->pFTCInfo->szCommand);
                PathRemoveArgs(szPath);
                PathFindOnPath(szPath, NULL);

                if((pFTDInfo->pFTInfo->dwAttributes & FTA_HasExtension) ||
                   (pFTDInfo->dwCommand == IDC_FT_PROP_NEW))
                {
                    int iImageIndex;

                    // get simulated doc icon
                    iImageIndex = Shell_GetCachedImageIndex(szPath, 0, GIL_SIMULATEDOC);
                    hIcon = ImageList_ExtractIcon(hinstCabinet, s_himlSysLarge, iImageIndex);
                }
                else
                {
                    // special cases like folder and drive
                    if((hIcon = GetDefaultIcon(&pFTDInfo->pFTInfo->hkeyFT, pFTDInfo->szId, SHGFI_LARGEICON)) == (HICON)NULL)
                    {
                        // use default shell icon in case above calls fail to find an icon
                        UINT iIndex = Shell_GetCachedImageIndex(c_szShell2, II_DOCNOASSOC, 0);
                        hIcon = ImageList_ExtractIcon(hinstCabinet, s_himlSysLarge, iIndex);
                    }
                }
                SendMessage(pFTDInfo->hwndEditDocIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
            }
        }
    }

    return(TRUE);
}

//================================================================
//================================================================
VOID FTCmd_OnBrowse(PFILETYPESDIALOGINFO pFTDInfo, HWND hDialog)
{
    /*
     * The problem with NT is that this function is UNICODE-ONLY (see below),
     * and so we must convert all our strings to Unicode before calling, then
     * convert the szPath back to ANSI upon return.
     *
     * BOOL WINAPI GetFileNameFromBrowse(HWND hwnd, LPTSTR szFilePath, UINT cchFilePath,
     *   LPCTSTR szWorkingDir, LPCTSTR szDefExt, LPCTSTR szFilters, LPCTSTR szTitle)
     *
     */
    if (RUNNING_NT)
    {
        WCHAR szuPath[MAX_PATH];
        WCHAR szuTitle[80];
        WCHAR szuExe[16];
        WCHAR szuFilters[MAX_PATH];
        LPWSTR psz;

        szuPath[0] = szuTitle[0] = szuExe[0] = szuFilters[0]= 0;
        MLLoadStringW(IDS_OPENAS, szuTitle, 80);
        MLLoadStringW(IDS_EXE, szuExe, 16);
        MLLoadStringW(IDS_PROGRAMSFILTER, szuFilters, MAX_PATH);
        /* hack up the array... */
        psz = szuFilters;
        while (*psz)
        {
            if (*psz == (WCHAR)('#'))
                *psz = (WCHAR)('\0');
            psz++;
        }

        if (GetFileNameFromBrowse(hDialog, szuPath, MAX_PATH, NULL,
            szuExe, szuFilters, szuTitle))
            {
                /* Specifically UNICODE */
                PathQuoteSpaces((LPSTR)szuPath);
                SetDlgItemTextW(hDialog, IDC_FT_CMD_EXE, szuPath);
            }
    }
    else
    {
        /* leave this here for running on Win95 */
        char szPath[MAX_PATH];
        char szTitle[MAX_PATH];
        char szExe[16];
        char szFilters[MAX_PATH];
        char *psz;

        szPath[0] = szTitle[0] = szExe[0] = szFilters[0]= 0;
        MLLoadStringA(IDS_OPENAS, szTitle, sizeof(szTitle));
        MLLoadStringA(IDS_EXE, szExe, sizeof(szExe));
        MLLoadStringA(IDS_PROGRAMSFILTER, szFilters, sizeof(szFilters));
        psz = szFilters;
        while (*psz)
        {
            if (*psz == (char)('#'))
                *psz = (char)('\0');
            psz++;
        }

        if (GetFileNameFromBrowse(hDialog, (LPWSTR)szPath, sizeof(szPath), NULL,   // (LPWSTR) so it builds, but only works downlevel
            (LPWSTR)szExe, (LPWSTR)szFilters, (LPWSTR)szTitle))
            {
                PathQuoteSpaces(szPath);
                SetDlgItemText(hDialog, IDC_FT_CMD_EXE, szPath);
            }
    }
}

//================================================================
//================================================================
VOID FTCmd_OnCommand(PFILETYPESDIALOGINFO pFTDInfo, HWND hDialog, WPARAM wParam, LPARAM lParam)
{

#ifdef FT_DEBUG
    DebugMsg(DM_TRACE, "FT Cmd: WM_COMMAND wParam 0x%04x 0x%04x", HIWORD(wParam), LOWORD(wParam));
#endif

    switch(LOWORD(wParam))
    {
        case IDOK:
            if(!FTCmd_OnOK(pFTDInfo, hDialog, wParam, lParam))
                break;
            // Fall through...
        case IDCANCEL:
            EndDialog(hDialog, (LOWORD(wParam) == IDOK));
            break;

        case IDC_FT_CMD_BROWSE:
            FTCmd_OnBrowse(pFTDInfo, hDialog);
            break;

        case IDC_FT_CMD_USEDDE:
            // Resize Dialog to see/hide DDE controls
            ResizeCommandDlg(hDialog, IsDlgButtonChecked(hDialog, IDC_FT_CMD_USEDDE));
            break;
    }
}

//================================================================
//================================================================
#pragma data_seg(DATASEG_READONLY)
const static DWORD aEditCommandHelpIDs[] = {  // Context Help IDs
    IDC_FT_PROP_LV_FILETYPES,  IDH_FCAB_FT_PROP_LV_FILETYPES,
    IDC_FT_PROP_NEW,           IDH_FCAB_FT_PROP_NEW,
    IDC_FT_PROP_REMOVE,        IDH_FCAB_FT_PROP_REMOVE,
    IDC_FT_PROP_EDIT,          IDH_FCAB_FT_PROP_EDIT,
    IDC_FT_PROP_DOCICON,       IDH_FCAB_FT_PROP_DETAILS,
    IDC_FT_PROP_DOCEXTRO,      IDH_FCAB_FT_PROP_DETAILS,
    IDC_FT_PROP_OPENICON,      IDH_FCAB_FT_PROP_DETAILS,
    IDC_FT_PROP_OPENEXE,       IDH_FCAB_FT_PROP_DETAILS,
    IDC_FT_CMD_ACTION,         IDH_FCAB_FT_CMD_ACTION,
    IDC_FT_CMD_EXETEXT,        IDH_FCAB_FT_CMD_EXE,
    IDC_FT_CMD_EXE,            IDH_FCAB_FT_CMD_EXE,
    IDC_FT_CMD_BROWSE,         IDH_FCAB_FT_CMD_BROWSE,
    IDC_FT_CMD_DDEGROUP,       IDH_FCAB_FT_CMD_USEDDE,
    IDC_FT_CMD_USEDDE,         IDH_FCAB_FT_CMD_USEDDE,
    IDC_FT_CMD_DDEMSG,         IDH_FCAB_FT_CMD_DDEMSG,
    IDC_FT_CMD_DDEAPP,         IDH_FCAB_FT_CMD_DDEAPP,
    IDC_FT_CMD_DDEAPPNOT,      IDH_FCAB_FT_CMD_DDEAPPNOT,
    IDC_FT_CMD_DDETOPIC,       IDH_FCAB_FT_CMD_DDETOPIC,
    0, 0
};
#pragma data_seg()

//================================================================
//================================================================
INT_PTR CALLBACK FTCmd_DlgProc(HWND hDialog, UINT message, WPARAM wParam, LPARAM lParam)
{
    PFILETYPESDIALOGINFO pFTDInfo = (PFILETYPESDIALOGINFO)GetWindowLongPtr(hDialog, DWLP_USER);

    switch(message)
    {
        case WM_INITDIALOG:
            FTCmd_OnInitDialog(hDialog, wParam, lParam);
            return(TRUE);

        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR) aEditCommandHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
                        if ((int)SendMessage(hDialog, WM_NCHITTEST, 0, lParam) != HTCLIENT)
                            return FALSE;   // don't process it
            SHWinHelpOnDemandWrap((HWND) wParam, NULL, HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) aEditCommandHelpIDs);
            return TRUE;

        case WM_COMMAND:
            FTCmd_OnCommand(pFTDInfo, hDialog, wParam, lParam);
            break;

        case WM_CTRL_SETFOCUS:
            SetFocus((HWND)lParam);
            SendMessage((HWND)lParam, EM_SETSEL, (WPARAM)0, (LPARAM)MAKELPARAM(0, -1));
            break;
    }
    return(FALSE);
}

//================================================================
//================================================================
VOID OkToClose_NoCancel(HWND hDialog)
{
    char szStr1[256];

    if(MLLoadStringA(IDS_FT_CLOSE, szStr1, sizeof(szStr1)))
    {
        SetWindowText(GetDlgItem(hDialog, IDOK), szStr1);
        EnableWindow(GetDlgItem(hDialog, IDCANCEL), FALSE);
    }
}

//================================================================
//================================================================
HICON GetDocIcon(PFILETYPESDIALOGINFO pFTDInfo, LPSTR lpszStr)
{
    SHFILEINFO sfi;
    HICON hIcon = (HICON)NULL;
    int iImageIndex;

    if(pFTDInfo->pFTInfo->dwAttributes & FTA_HasExtension)
    {
        if(*lpszStr == '.')  // is an extension
        {
            if(SHGetFileInfo((LPSTR)lpszStr, FILE_ATTRIBUTE_NORMAL, &sfi, sizeof(SHFILEINFO), SHGFI_ICON | SHGFI_LARGEICON | SHGFI_USEFILEATTRIBUTES))
                hIcon = sfi.hIcon;
        }
        else
        {
            // get simulated doc icon if from exe name
            iImageIndex = Shell_GetCachedImageIndex(lpszStr, 0, GIL_SIMULATEDOC);
            hIcon = ImageList_ExtractIcon(hinstCabinet, s_himlSysLarge, iImageIndex);
        }
    }
    else    // special case for folder, drive etc.
    {
        if((hIcon = GetDefaultIcon(&pFTDInfo->pFTInfo->hkeyFT, pFTDInfo->szId, SHGFI_LARGEICON)) == (HICON)NULL)
        {
            // use default shell icon in case above calls fail to find an icon
            UINT iIndex = Shell_GetCachedImageIndex(c_szShell2, II_DOCNOASSOC, 0);
            hIcon = ImageList_ExtractIcon(hinstCabinet, s_himlSysLarge, iIndex);
        }
    }

    return(hIcon);
}

//================================================================
//================================================================
VOID DisplayDocObjects(PFILETYPESDIALOGINFO pFTDInfo, HWND hDialog)
{
    LV_ITEM LVItem;
    char szFile[MAX_PATH];
    int iCnt;
    int i;

    // Display extensions in read-only edit control
    iCnt = DPA_GetPtrCount(pFTDInfo->pFTInfo->hDPAExt);
    *szFile = '\0';
    for(i = 0; (i < iCnt) && (lstrlen(szFile) < MAX_PATH); i++)
    {
        if(*(LPSTR)(DPA_FastGetPtr(pFTDInfo->pFTInfo->hDPAExt, i)))
        {
                        // Make sure we have enough room left in our string...
                        if ((lstrlen(szFile) +
                                lstrlen((LPSTR)DPA_FastGetPtr(pFTDInfo->pFTInfo->hDPAExt, i)))
                                >= (MAX_PATH - 2))
                            break;
            lstrcat(szFile, (LPSTR)DPA_FastGetPtr(pFTDInfo->pFTInfo->hDPAExt, i) + 1);
            lstrcat(szFile, c_szSpace);
        }
    }
    SetDlgItemText(hDialog, IDC_FT_PROP_DOCEXTRO, CharUpper(szFile));

#ifdef MIME
   // Display MIME type in read-only edit control.
   if (IsListOfExtensions(pFTDInfo->pFTInfo->hDPAExt))
      FindMIMETypeOfExtensionList(pFTDInfo->pFTInfo->hDPAExt, szFile, sizeof(szFile));
   else
      *szFile = '\0';
   SetDlgItemText(hDialog, IDC_FT_PROP_CONTTYPERO, szFile);
   lstrcpy(pFTDInfo->pFTInfo->szOriginalMIMEType, szFile);
#endif   /* MIME */

    // Get doc icon if not already gotten
    if(pFTDInfo->pFTInfo->hIconDoc == (HICON)NULL)
    {
        pFTDInfo->pFTInfo->hIconDoc = GetDocIcon(pFTDInfo, DPA_FastGetPtr(pFTDInfo->pFTInfo->hDPAExt,0));

        // Get the image index from the list view item
        LVItem.mask        = LVIF_IMAGE;
        LVItem.iItem       = pFTDInfo->iItem;
        LVItem.iSubItem    = 0;
        ListView_GetItem(pFTDInfo->hwndLVFT, &LVItem);
        if(ImageList_ReplaceIcon(pFTDInfo->himlFT, LVItem.iImage, pFTDInfo->pFTInfo->hIconDoc) != (-1))
            ListView_SetItem(pFTDInfo->hwndLVFT, &LVItem);
    }

    // Display document object icon
    if(pFTDInfo->pFTInfo->hIconDoc != (HICON)NULL)
        PostMessage(pFTDInfo->hwndDocIcon, STM_SETIMAGE, IMAGE_ICON,
                (LPARAM)pFTDInfo->pFTInfo->hIconDoc);
}

//================================================================
//================================================================
VOID DisplayOpensWithObjects(PFILETYPESDIALOGINFO pFTDInfo, HWND hDialog)
{
    char szFile[MAX_PATH];
    char szFullPath[MAX_PATH];
    SHFILEINFO sfi;

    // Get default action's executable
    //    Search order:
    //    1. FTID\[value-of-FTID\shell-key]\command
    //    2. FTID\open\command
    //    3. FTID\[1st-FTID\shell-subkey]\command
    ExtToShellCommand(pFTDInfo->pFTInfo->hkeyFT, szFile, sizeof(szFile));

    if(*szFile)
    {
        int cbT = lstrlen(c_szExefileOpenCommand);
        if (CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                szFile, cbT, c_szExefileOpenCommand, cbT) == 2)
        {
            // handle types like exefile, comfile, & batfile that don't have exe

            // Get open icon if not already gotten
            pFTDInfo->pFTInfo->hIconOpen = (HICON)NULL;
            PostMessage(pFTDInfo->hwndOpenIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM)NULL);
            MLLoadStringA(IDS_FT_EXEFILE, szFullPath, sizeof(szFullPath));
        }
        else
        {
            if ( UrlPathProcessCommand( szFile, szFile, MAX_PATH, PPCF_NODIRECTORIES ) == -1 )
            {
                PathRemoveArgs(szFile);
                PathRemoveBlanks(szFile);
                PathUnquoteSpaces(szFile);

                if (PathIsRelative(szFile))
                  PathFindOnPath(szFile, NULL);
            }

            lstrcpy(szFullPath, szFile);

            // Get open icon if not already gotten
            if(pFTDInfo->pFTInfo->hIconOpen == (HICON)NULL)
            {
                sfi.hIcon = 0;
#ifdef MIME
            TRACE_OUT(("DisplayOpensWithObjects(): Retrieving icon for %s.",
                       szFullPath));
#endif   /* MIME */
                if(SHGetFileInfo(szFullPath, FILE_ATTRIBUTE_NORMAL, &sfi, sizeof(SHFILEINFO), SHGFI_ICON | SHGFI_LARGEICON | SHGFI_USEFILEATTRIBUTES))
                {
                    if(sfi.hIcon != (HICON)NULL)
                        pFTDInfo->pFTInfo->hIconOpen = sfi.hIcon;
                    else
                    {
                        UINT iIndex = Shell_GetCachedImageIndex(c_szShell2, II_DOCNOASSOC, 0);
                        pFTDInfo->pFTInfo->hIconOpen = ImageList_ExtractIcon(hinstCabinet, s_himlSysLarge, iIndex);
                    }
                }
            }
        }

        // Display open icon
        if(pFTDInfo->pFTInfo->hIconOpen != (HICON)NULL)
            PostMessage(pFTDInfo->hwndOpenIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM)pFTDInfo->pFTInfo->hIconOpen);

        // Display exe name
        lstrcpy(szFile, PathFindFileName(szFullPath));    // Strip off the path
        if(*szFile)
        {
            PathRemoveExtension(szFile);    // Strip off the extension
            SetDlgItemText(hDialog, IDC_FT_PROP_OPENEXE, CharUpper(szFile));
        }
    }
    else
    {
        PostMessage(pFTDInfo->hwndOpenIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM)NULL);
        SetDlgItemText(hDialog, IDC_FT_PROP_OPENEXE, c_szNULL);
    }
}

//================================================================
//================================================================
BOOL ValidExtension(HWND hDialog, PFILETYPESDIALOGINFO pFTDInfo)
{
    BOOL bRC = TRUE;
    char szExt[MAX_PATH];
    char szId[MAX_PATH];
    char szBuf[MAX_PATH];
    char szStr1[256];
    char szStr2[256];
    DWORD dwId;
    HWND hwndButton;
    int iLength;

    // On new types verify that the extension is not already in use.
    GetDlgItemText(hDialog, IDC_FT_EDIT_EXT, szExt, sizeof(szExt));

    iLength = lstrlen(szExt);

    if(iLength != 0 && iLength < MAXEXTSIZE)
    {
        AddExtDot(szExt, sizeof(szExt));

        dwId = sizeof(szId);
        *szId = '\0';
        if((RegQueryValue(HKEY_CLASSES_ROOT, szExt, szId, &dwId) == ERROR_SUCCESS) && *szId)
        {
            // Disable OK button
            hwndButton = GetDlgItem(hDialog, IDOK);
            EnableWindow(hwndButton, FALSE);

            // Tell user that this extension is already in use
            *szBuf = '\0';
            *szStr2 = '\0';
            if(MLLoadStringA(IDS_FT_MB_EXTTEXT, szStr1, sizeof(szStr1)))
            {
                if(MLLoadStringA(IDS_FT, szStr2, sizeof(szStr2)))
                {
                    if(lstrlen(szStr1) + lstrlen(szExt) + lstrlen(szId) < sizeof(szBuf))
                        wsprintf(szBuf, szStr1, szExt, szId);
                }
            }
            MessageBox(hDialog, szBuf, szStr2, MB_OK | MB_ICONSTOP);
            PostMessage(hDialog, WM_CTRL_SETFOCUS, (WPARAM)0, (LPARAM)GetDlgItem(hDialog, IDC_FT_EDIT_EXT));
            EnableWindow(hwndButton, TRUE);  // Enable OK
            bRC = FALSE;
        }
        else if(!(*pFTDInfo->szId))
        {
            HKEY hk;
            int iCnt = 1;
            LPSTR pszExt = szExt;

            if(*pszExt == '.')
                pszExt++;   // remove dot

            // Create unique file type id
            lstrcpy(pFTDInfo->szId, pszExt);
            lstrcat(pFTDInfo->szId, c_szFile);

            while(RegOpenKey(HKEY_CLASSES_ROOT, pFTDInfo->szId, &hk) == ERROR_SUCCESS)
            {
                RegCloseKey(hk);
#pragma data_seg(".text", "CODE")
                wsprintf(pFTDInfo->szId, "%s%s%02d",
                    pszExt, c_szFile, iCnt);
#pragma data_seg()
                iCnt++;
            }
            EnableWindow(GetDlgItem(pFTDInfo->hEditDialog, IDC_FT_EDIT_NEW), TRUE);
        }
    }
    else
    {
        // Tell the use that an extension is required
        *szBuf = '\0';
        *szStr2 = '\0';
        if(MLLoadStringA(IDS_FT_MB_NOEXT, szStr1, sizeof(szStr1)))
        {
            if(MLLoadStringA(IDS_FT, szStr2, sizeof(szStr2)))
            {
                if(lstrlen(szStr1) + lstrlen(szExt) + lstrlen(szId) < sizeof(szBuf))
                    wsprintf(szBuf, szStr1, szExt, szId);
            }
        }
        MessageBox(hDialog, szBuf, szStr2, MB_OK | MB_ICONSTOP);
        PostMessage(hDialog, WM_CTRL_SETFOCUS, (WPARAM)0, (LPARAM)GetDlgItem(hDialog, IDC_FT_EDIT_EXT));
        bRC = FALSE;
    }

    return(bRC);
}

//================================================================
//================================================================
BOOL ActionIsEntered(HWND hDialog, BOOL bMBoxFlag)
{
    BOOL bRC = TRUE;
    char szAction[MAX_PATH];

    // Check for value
    if(!GetDlgItemText(hDialog, IDC_FT_CMD_ACTION, szAction, sizeof(szAction)))
    {
        if(bMBoxFlag)
        {
            // Tell user that this exe is invalid
            ShellMessageBox(hinstCabinet, hDialog,
                MAKEINTRESOURCE(IDS_FT_MB_NOACTION),
                MAKEINTRESOURCE(IDS_FT), MB_OK | MB_ICONSTOP);
            PostMessage(hDialog, WM_CTRL_SETFOCUS, (WPARAM)0,
                (LPARAM)GetDlgItem(hDialog, IDC_FT_CMD_ACTION));
        }
        bRC = FALSE;
    }
    return(bRC);
}

//================================================================
//================================================================
BOOL ActionExeIsValid(HWND hDialog, BOOL bMBoxFlag)
{
    BOOL bRC = TRUE;
    char szPath[MAX_PATH];
        char szFileName[MAX_PATH];

    // Check for valid exe
    GetDlgItemText(hDialog, IDC_FT_CMD_EXE,    szPath, sizeof(szPath));
    PathRemoveArgs(szPath);
        PathUnquoteSpaces(szPath);
        lstrcpy(szFileName, PathFindFileName(szPath));
    if(!(*szPath) || (!(PathIsExe(szPath))) ||
        ((!(PathFileExists(szPath))) && (!(PathFindOnPath(szFileName, NULL)))))
    {
        if(bMBoxFlag)
        {
            // Tell user that this exe is invalid
            ShellMessageBox(hinstCabinet, hDialog, MAKEINTRESOURCE(IDS_FT_MB_EXETEXT),
                MAKEINTRESOURCE(IDS_FT),MB_OK | MB_ICONSTOP);
            PostMessage(hDialog, WM_CTRL_SETFOCUS, (WPARAM)0,
                (LPARAM)GetDlgItem(hDialog, IDC_FT_CMD_EXE));
        }
        bRC = FALSE;
    }
    return(bRC);
}

//================================================================
//================================================================
BOOL FT_InitListViewCols(HWND hwndLV)
{
    LV_COLUMN col = {LVCF_FMT | LVCF_WIDTH, LVCFMT_LEFT};
    RECT rc;

    SetWindowLong(hwndLV, GWL_EXSTYLE,
        GetWindowLong(hwndLV, GWL_EXSTYLE) | WS_EX_CLIENTEDGE);

    // Insert one column
    GetClientRect(hwndLV, &rc);
    col.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL)
        - 2 * GetSystemMetrics(SM_CXEDGE);
    if(ListView_InsertColumn(hwndLV, 0, &col) == (-1))
        return(FALSE);

    return(TRUE);
}

//================================================================
//================================================================
BOOL FTEdit_InitListViewCols(HWND hwndLV)
{
    LV_COLUMN col;
    RECT rc;

    SetWindowLong(hwndLV, GWL_EXSTYLE,
        GetWindowLong(hwndLV, GWL_EXSTYLE) | WS_EX_CLIENTEDGE);

    // Insert one column
    GetClientRect(hwndLV, &rc);
    ZeroMemory(&col, sizeof(LV_COLUMN));
    col.mask = LVCF_FMT | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.cx = rc.right - GetSystemMetrics(SM_CXBORDER);
    if(ListView_InsertColumn(hwndLV, 0, &col) == (-1))
        return(FALSE);

    return(TRUE);
}

//================================================================
//================================================================
void CALLBACK FTListViewEnumItems(PFILETYPESDIALOGINFO pFTDInfo, int i, int iEnd, HANDLE *pfShouldLive)
{
    LV_ITEM item;

#ifdef FT_DEBUG
    DebugMsg(DM_TRACE, "FTListViewThread created.");
#endif

    item.iSubItem = 0;
    item.mask = LVIF_IMAGE;        // This should be the only slow part

    if (iEnd == -1 ) {
        iEnd = ListView_GetItemCount(pFTDInfo->hwndLVFT);
    }

    for (; (!pfShouldLive || *pfShouldLive) && i < iEnd; i++)
    {
        item.iItem = i;
        ListView_GetItem(pFTDInfo->hwndLVFT, &item);
    }
}

//================================================================
//================================================================
DWORD CALLBACK FTListViewThread(PFILETYPESDIALOGINFO pFTDInfo)
{
    HANDLE hThread = pFTDInfo->hThread;
    FTListViewEnumItems(pFTDInfo, 10, -1, &pFTDInfo->hThread);
    CloseHandle(hThread);
    pFTDInfo->hThread = 0;
    return 0;
}

//================================================================
//================================================================
VOID CreateListViewThread(PFILETYPESDIALOGINFO pFTDInfo)
{
    // Create background thread to force list view to draw items
    DWORD idThread;

    if (pFTDInfo->hThread)
        return;

    pFTDInfo->hThread = CreateThread(NULL, 0, FTListViewThread, pFTDInfo, 0, &idThread);
    if(pFTDInfo->hThread)
        SetThreadPriority(pFTDInfo->hThread, THREAD_PRIORITY_BELOW_NORMAL);
}

//================================================================
//================================================================
BOOL FT_InitListView(PFILETYPESDIALOGINFO pFTDInfo)
{
    DWORD dwSubKey = 0;
    char szDesc[MAX_PATH];
    char szClass[MAX_PATH];
    char szClassesKey[MAX_PATH];    // string containing the classes key
    char szId[MAX_PATH];
    char szShellCommandValue[MAX_PATH];
    DWORD dwName;
    DWORD dwClass;
    DWORD dwId;
    DWORD dwClassesKey;
    DWORD dwAttributes;
    FILETIME ftLastWrite;
    BOOL bRC = TRUE;
    BOOL bRC1;
    LONG err;
    HKEY hkeyFT = NULL;

    if((pFTDInfo->himlFT = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
            GetSystemMetrics(SM_CYSMICON), TRUE, 0, 8)) == (HIMAGELIST)NULL)
        return(FALSE);
    ListView_SetImageList(pFTDInfo->hwndLVFT, pFTDInfo->himlFT, LVSIL_SMALL);

    // Enumerate extensions from registry to get file types
    dwClassesKey = sizeof(szClassesKey);
    dwClass = sizeof(szClass);
    while(RegEnumKeyEx(HKEY_CLASSES_ROOT, dwSubKey, szClassesKey, &dwClassesKey,
            NULL, szClass, &dwClass, &ftLastWrite) != ERROR_NO_MORE_ITEMS)
    {
        *szId = '\0';
        dwAttributes = 0;

        // find the file type identifier and description from the extension
        if(*szClassesKey == '.')
        {
            dwName = sizeof(szDesc);
            dwId = sizeof(szId);
            bRC1 = ExtToTypeNameAndId(szClassesKey, szDesc, &dwName, szId, &dwId);

            if(RegOpenKey(HKEY_CLASSES_ROOT, szId, &hkeyFT) != ERROR_SUCCESS)
                hkeyFT = NULL;
            else
            {
                dwAttributes = GetFileTypeAttributes(hkeyFT);
                if(!(dwAttributes & FTA_Exclude))
                    dwAttributes |= FTA_HasExtension;

                if(!bRC1)
                {
                    // see if there is a HKEY_CLASSES_ROOT\[.Ext]\Shell\Open\Command value
                    err = sizeof(szShellCommandValue);
                    err = RegQueryValue(hkeyFT, c_szShellOpenCommand, szShellCommandValue, &err);
                    if (err != ERROR_SUCCESS || !(*szShellCommandValue))
                    {
                        dwAttributes = FTA_Exclude;
                        RegCloseKey(hkeyFT);
                        hkeyFT = NULL;
                    }
                    else
                    {
                        dwAttributes |= FTA_ExtShellOpen;
                    }
                }
            }
        }
        else
        {
            if(RegOpenKey(HKEY_CLASSES_ROOT, szClassesKey, &hkeyFT) != ERROR_SUCCESS)
                hkeyFT = NULL;
            if((dwAttributes = GetFileTypeAttributes(hkeyFT)) & FTA_Show)
            {
                lstrcpy(szId, szClassesKey);
                dwName = sizeof(szDesc);
                err = RegQueryValue(hkeyFT, NULL, szDesc, &dwName);
                if(err != ERROR_SUCCESS || !*szDesc)
                    lstrcpy(szDesc, szClassesKey);
                *szClassesKey = '\0';
            }
        }

#ifdef FT_DEBUG
        DebugMsg(DM_TRACE, "FT RegEnum HKCR szClassKey=%s szId=%s dwAttributes=%d",    szClassesKey, szId, dwAttributes);
#endif

        if((!(dwAttributes & FTA_Exclude)) && ((dwAttributes & FTA_Show) || (dwAttributes & FTA_HasExtension) || (dwAttributes & FTA_ExtShellOpen)))
        {
            if(!FT_AddInfoToLV(pFTDInfo, hkeyFT, szClassesKey, szDesc, szId, dwAttributes))
            {
                RegCloseKey(hkeyFT);
                bRC = FALSE;
                break;
            }
        }
        else
            RegCloseKey(hkeyFT);

        dwSubKey++;
        dwClassesKey = sizeof(szClassesKey);
        dwClass = sizeof(szClass);
    }

    ListView_SortItems(pFTDInfo->hwndLVFT, NULL, 0);
    FT_MergeDuplicates(pFTDInfo->hwndLVFT);

    FTListViewEnumItems(pFTDInfo, 0, 10, NULL);
    CreateListViewThread(pFTDInfo);

    return(bRC);
}

//================================================================
//================================================================
int FTEdit_InitListView(PFILETYPESDIALOGINFO pFTDInfo)
{
    char szClass[MAX_PATH];
    char szAction[MAX_PATH];
    DWORD dwClass;
    DWORD dwAction;
    int iSubKey;
    FILETIME ftLastWrite;
    HKEY hk;

    // See if we have a default action verb
    iSubKey = sizeof(pFTDInfo->pFTInfo->szDefaultAction);
    DefaultAction(pFTDInfo->pFTInfo->hkeyFT, pFTDInfo->pFTInfo->szDefaultAction, &iSubKey);

    // Enumerate action verbs
    iSubKey = 0;
    if(RegOpenKeyEx(pFTDInfo->pFTInfo->hkeyFT, c_szShell, 0,
                    KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE, &hk) == ERROR_SUCCESS)
    {
        dwClass = sizeof(szClass);
        dwAction = sizeof(szAction);
        // add verbs to list view
        while(RegEnumKeyEx(hk, iSubKey, szAction, &dwAction, NULL, szClass,
                           &dwClass, &ftLastWrite) == ERROR_SUCCESS)
        {
            if(!FTEdit_AddInfoToLV(pFTDInfo, szAction, NULL, pFTDInfo->pFTInfo->szId, hk))
            {
                iSubKey = (-1);
                break;
            }

            dwClass = sizeof(szClass);
            dwAction = sizeof(szAction);
            iSubKey++;
        }
        RegCloseKey(hk);
    }

    return(iSubKey);
}

//================================================================
//================================================================
BOOL IsIconPerInstance(HKEY hkeyFT)
{
    LONG err;
    char szDefaultIcon[MAX_PATH];
    BOOL bRC = FALSE;

    Assert(hkeyFT != NULL);

    err = sizeof(szDefaultIcon);
    err = RegQueryValue(hkeyFT, c_szDefaultIcon, szDefaultIcon, &err);
    if (err == ERROR_SUCCESS && *szDefaultIcon)
    {
        int cbT = lstrlen(c_szSpPercentOne) - 1;
        if (CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                szDefaultIcon, cbT, &c_szSpPercentOne[1], cbT) == 2)
            bRC = TRUE;
    }
    return(bRC);
}

//================================================================
//================================================================
BOOL HasIconHandler(HKEY hkeyFT)
{
    char szBuf[MAX_PATH];
    DWORD dwBuf;

    Assert(hkeyFT != NULL);

    // Don't allow icon to be changed if type has an icon handler
    dwBuf = sizeof(szBuf);
    return(RegQueryValue(hkeyFT, c_szShellexIconHandler, szBuf, &dwBuf) == ERROR_SUCCESS);
}

//================================================================
//================================================================
BOOL FT_AddInfoToLV(PFILETYPESDIALOGINFO pFTDInfo, HKEY hkeyFT, LPSTR szExt,
                    LPSTR szDesc, LPSTR szId, DWORD dwAttributes)
{
    BOOL bRC = FALSE;
    LV_ITEM LVItem;
    LPSTR pszExt;

    Assert(hkeyFT != (HKEY)NULL);

    if((pFTDInfo->pFTInfo = LocalAlloc(GPTR, sizeof(FILETYPESINFO))) != NULL)
    {
        // create dynamic pointer array for FILETYPESINFO dpaExt member
        if((pFTDInfo->pFTInfo->hDPAExt = DPA_Create(4)) != (HDPA)NULL)    
        {
            if((pszExt = LocalAlloc(GPTR, lstrlen(szExt)+1)) != NULL)
            {
                lstrcpy(pszExt, szExt);
                if(DPA_InsertPtr(pFTDInfo->pFTInfo->hDPAExt, 0x7FFF, (LPVOID)pszExt) == 0)
                {
                    lstrcpy(pFTDInfo->pFTInfo->szDesc, szDesc);
                    lstrcpy(pFTDInfo->pFTInfo->szId, szId);
                    pFTDInfo->pFTInfo->dwAttributes = dwAttributes;
                    if(HasIconHandler(hkeyFT) || IsIconPerInstance(hkeyFT))
                        pFTDInfo->pFTInfo->dwAttributes |= FTA_NoEditIcon;
                    pFTDInfo->pFTInfo->hkeyFT = hkeyFT;

                    LVItem.mask        = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                    LVItem.iItem       = 0x7FFF;
                    LVItem.iSubItem    = 0;
                    LVItem.pszText     = szDesc;
                        LVItem.iImage      = I_IMAGECALLBACK;
                    LVItem.lParam      = (LPARAM)pFTDInfo->pFTInfo;

                    if ((pFTDInfo->iItem = ListView_InsertItem(pFTDInfo->hwndLVFT, &LVItem)) != (-1))
                        bRC = TRUE;
                }
            }
        }
    }
    return(bRC);
}

//================================================================
//================================================================
BOOL FTEdit_AddInfoToLV(PFILETYPESDIALOGINFO pFTDInfo, LPSTR szActionKey,
        LPSTR szActionValue, LPSTR szId, HKEY hk)
{
    BOOL bRC = FALSE;
    int iIndex = 0;
    LV_ITEM LVItem;

    if((pFTDInfo->pFTCInfo = LocalAlloc(LPTR, sizeof(FILETYPESCOMMANDINFO))) != NULL)
    {
        lstrcpy(pFTDInfo->pFTCInfo->szId, szId);

                if (szActionKey)
                {
            lstrcpy(pFTDInfo->pFTCInfo->szActionKey, szActionKey);
            lstrcpy(pFTDInfo->pFTCInfo->szActionValue, szActionKey);

                    if (hk != NULL)
                    {
                        DWORD dwSize;
                        char szTemp[MAX_PATH];

                        // See if there is nice text for the action...
                        dwSize = sizeof(szTemp);
                        if ((RegQueryValue(hk, szActionKey, szTemp, &dwSize) == ERROR_SUCCESS)
                                && (dwSize > 1))
                        {
                      lstrcpy(pFTDInfo->pFTCInfo->szActionValue, szTemp);
                        }
                    }
                }

                else
                {
                    // Special case if user typed in something like:
                    // print=My Print to take the print off to be
                    // its own special char...
                    LPSTR pszT = StrChr(szActionValue, '=');

                    if (pszT)
                    {
                        *pszT++ = '\0';
                  StrRemoveChar(szActionValue, pFTDInfo->pFTCInfo->szActionKey, '&');
                 lstrcpy(szActionValue, pszT);
                    }
                    else
                    {
                        // We want to remove the & of the command as well as convert blanks into _s
                        // as default command processing has problems with processing of blanks
                 StrRemoveChar(szActionValue, pFTDInfo->pFTCInfo->szActionKey, '&');
                        for (pszT = pFTDInfo->pFTCInfo->szActionKey; *pszT; pszT = CharNext(pszT))
                        {
                            if (*pszT == ' ')
                                *pszT = '_';
                        }
                    }
            lstrcpy(pFTDInfo->pFTCInfo->szActionValue, szActionValue);


                }


        LVItem.mask        = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
        LVItem.iItem       = iIndex++;
        LVItem.iSubItem    = 0;
        LVItem.pszText     = pFTDInfo->pFTCInfo->szActionValue;
        LVItem.lParam      = (LPARAM)pFTDInfo->pFTCInfo;

        if(ListView_InsertItem(pFTDInfo->hwndLVFTEdit, &LVItem) != (-1))
        {
            // Enable the remove button
            EnableWindow(GetDlgItem(pFTDInfo->hEditDialog, IDC_FT_EDIT_REMOVE), TRUE);
            bRC = TRUE;
        }
    }
    return(bRC);
}

//================================================================
//================================================================
VOID AddExtDot(LPSTR pszExt, UINT iExt)
{
    UINT iLength;

    PathRemoveBlanks(pszExt);       // remove 1st and last blank
    StrRemoveChar(pszExt, NULL, TEXT('.')); // remove all dots

    iLength = lstrlen(pszExt);      // How much left?
    if (iLength < iExt-1)
    {
        hmemcpy(pszExt+1, pszExt, (lstrlen(pszExt)+1)*SIZEOF(TCHAR)); // make room for dot
        *pszExt = TEXT('.');    // insert dot
    }
}

//================================================================
//================================================================
DWORD GetFileTypeAttributes(HKEY hkeyFT)
{
    LONG err;
    DWORD dwType;
    DWORD dwAttributeValue = 0;
    DWORD dwAttributeSize;

    if (hkeyFT == NULL)
        return 0;

    dwAttributeSize = sizeof(dwAttributeValue);
    err = RegQueryValueEx(hkeyFT, (LPTSTR)c_szEditFlags, NULL, &dwType, (LPBYTE)&dwAttributeValue, &dwAttributeSize);

    if (err != ERROR_SUCCESS ||
        dwType != REG_BINARY ||
        dwAttributeSize != sizeof(dwAttributeValue))
    {
        dwAttributeValue = 0;
    }

    return(dwAttributeValue);
}

//================================================================
//================================================================
DWORD SetVerbAttributes(HKEY hkeyFT, LPSTR pszVerb, DWORD dwAttributes)
{
    HKEY hk;
    LONG err;
    char szVerbKey[MAX_PATH+6];    // 6 = "\shell"
    DWORD dwSize;

    wsprintf(szVerbKey, c_szTemplateSS, c_szShell, pszVerb);
    if((hkeyFT != NULL) &&
        (RegOpenKeyEx(hkeyFT, szVerbKey, 0, KEY_SET_VALUE, &hk) == ERROR_SUCCESS))
    {
        dwSize = sizeof(dwAttributes);
        err = RegSetValueEx(hk, c_szEditFlags, 0, REG_BINARY,
                            (LPBYTE)&dwAttributes, dwSize);
        if (err != ERROR_SUCCESS)
            dwAttributes= 0;
        RegCloseKey(hk);
    }

    return(dwAttributes);
}

//================================================================
//================================================================
DWORD GetVerbAttributes(HKEY hkeyFT, LPSTR pszVerb)
{
    HKEY hk;
    LONG err;
    char szVerbKey[MAX_PATH+6];    // 6 = "\shell"
    DWORD dwType;
    DWORD dwAttributes = 1;
    DWORD dwSize;

    wsprintf(szVerbKey, c_szTemplateSS, c_szShell, pszVerb);
    if((hkeyFT != NULL) && (RegOpenKeyEx(hkeyFT, szVerbKey, 0, KEY_QUERY_VALUE, &hk) == ERROR_SUCCESS))
    {
        dwSize = sizeof(dwAttributes);
                err = RegQueryValueEx(hk, (LPTSTR)c_szEditFlags, NULL, &dwType, (LPBYTE)&dwAttributes, &dwSize);
                if (err != ERROR_SUCCESS ||
                    dwType != REG_BINARY ||
                    dwSize != sizeof(dwAttributes))
                {
                        dwAttributes = 0;
                }
        RegCloseKey(hk);
    }

    return(dwAttributes);
}

//================================================================
//================================================================
VOID FT_MergeDuplicates(HWND hwndLV)
{
    int i;
    int iCnt;
    LV_ITEM LVItem;
    PFILETYPESINFO pFTInfo1;
    PFILETYPESINFO pFTInfo2;

    LVItem.mask = LVIF_PARAM;
        LVItem.iItem = 0;
    LVItem.iSubItem = 0;
    ListView_GetItem(hwndLV, &LVItem);  // Get item 0

    iCnt = ListView_GetItemCount(hwndLV);
    pFTInfo1 = (PFILETYPESINFO)LVItem.lParam;
    for(i = 1; i < iCnt; i++)
    {
        LVItem.iItem = i;
        ListView_GetItem(hwndLV, &LVItem);  // LVItem.lParam points to file type info
        pFTInfo2 = (PFILETYPESINFO)LVItem.lParam;
        if(lstrcmpi(pFTInfo1->szId, pFTInfo2->szId) == 0)    // we have a match
        {
            // add extension in pFTInfo1's hDPAExt
            DPA_InsertPtr(pFTInfo1->hDPAExt, 0x7fff, (LPVOID)DPA_FastGetPtr(pFTInfo2->hDPAExt,0));
                        DPA_DeletePtr(pFTInfo2->hDPAExt, 0);
            ListView_DeleteItem(hwndLV, i);
            i--;
            iCnt--;
        }
        else
        {
            pFTInfo1 = pFTInfo2;
        }
    }

}

//================================================================
//================================================================
VOID ExtToShellCommand(HKEY hkeyFT, LPSTR pszName, UINT uName)
{
    char szIdValue[MAX_PATH];
    char szShellCommand[MAX_PATH+MAX_PATH+7];  // 7 = "\shell\"
    char szShellCommandValue[MAX_PATH];
    char szClass[MAX_PATH];
    char szShellKey[MAX_PATH];
    DWORD dwClass;
    DWORD dwShellKey;
    DWORD dwSubKey;
    FILETIME ftLastWrite;
    LONG err = E_INVALIDARG;    // For proper handling of no hkey
    HKEY hk = (HKEY)NULL;

    if(hkeyFT)
    {
        // see if there is a HKEY_CLASSES_ROOT\[szId]\Shell value
        err = sizeof(szIdValue);
        err = RegQueryValue(hkeyFT, c_szShell, szIdValue, &err);
        if (err == ERROR_SUCCESS && *szIdValue)
        {
            // see if there is a HKEY_CLASSES_ROOT\[szId]\Shell\[szIdValue]\Command value
            wsprintf(szShellCommand, c_szTemplateSSS, c_szShell, szIdValue, c_szCommand);
            err = sizeof(szShellCommand);
            err = RegQueryValue(hkeyFT, szShellCommand, szShellCommandValue, &err);
        }
        else
        {
            // see if there is a HKEY_CLASSES_ROOT\[szId]\Shell\Open\Command value
            err = sizeof(szShellCommandValue);
            err = RegQueryValue(hkeyFT, c_szShellOpenCommand, szShellCommandValue, &err);
            if (err != ERROR_SUCCESS || !*szShellCommandValue)
            {
                // see if there is a HKEY_CLASSES_ROOT\[szId]\Shell\[1st Key]\Command value
                if(RegOpenKeyEx(hkeyFT, c_szShell, 0, KEY_READ, &hk) == ERROR_SUCCESS)
                {
                    dwClass = sizeof(szClass);
                    dwShellKey = sizeof(szShellKey);
                    dwSubKey = 0;
                    if(RegEnumKeyEx(hk, dwSubKey, szShellKey, &dwShellKey, NULL, szClass, &dwClass, &ftLastWrite) == ERROR_SUCCESS)
                    {
                        wsprintf(szShellCommand, c_szTemplateSS, szShellKey, c_szCommand);
                        err = sizeof(szShellCommandValue);
                        err = RegQueryValue(hk, szShellCommand, szShellCommandValue, &err);
                    }
                }
            }
        }
    }

    if(hk != (HKEY)NULL)
        RegCloseKey(hk);

    if(err == ERROR_SUCCESS)
        lstrcpyn(pszName, szShellCommandValue, uName);
    else
        *pszName ='\0';
}

//================================================================
//  This function returns non-zero value only if the specified type
// has an associated icon specified by "DefaultIcon=" key.
//================================================================
HICON GetDefaultIcon(HKEY *hkeyFT, LPSTR pszId, DWORD dwIconType)
{
    HICON hicon = (HICON)NULL;
    LONG err;
    char szDefaultIcon[MAX_PATH];
    int iIconIndex;
    int iImage;

    Assert(hkeyFT != NULL);

    if(*hkeyFT == NULL)
        *hkeyFT = GetHkeyFT(pszId);

    if(*hkeyFT != (HKEY)NULL)
    {
        err = sizeof(szDefaultIcon);
        err = RegQueryValue(*hkeyFT, c_szDefaultIcon, szDefaultIcon, &err);
        if (err == ERROR_SUCCESS && *szDefaultIcon)
        {
            iIconIndex = ParseIconLocation(szDefaultIcon);
            PathRemoveArgs(szDefaultIcon);
            iImage = Shell_GetCachedImageIndex(szDefaultIcon, iIconIndex, 0);
            hicon = ImageList_ExtractIcon(hinstCabinet, (dwIconType == SHGFI_LARGEICON ? s_himlSysLarge : s_himlSysSmall), iImage);
        }
    }

#ifdef FT_DEBUG
    DebugMsg(DM_TRACE, "FT GetDefaultIcon szIcon=%s iIndex=%d hIcon=0x%x hkeyFT=0x%x",
        szDefaultIcon, iIconIndex, hicon, *hkeyFT);
#endif

    return(hicon);
}

//================================================================
//================================================================
BOOL FindDDEOptions(PFILETYPESDIALOGINFO pFTDInfo)
{
    BOOL bRC = FALSE;
    char ach[MAX_PATH+8];  // 8 = "\ddeexec"
    LONG err;
    HKEY hkDDE;

    // see if we have a DDE Message key and value
    if(pFTDInfo->pFTInfo->hkeyFT)
    {
        wsprintf(ach, c_szTemplateSSS, c_szShell, pFTDInfo->pFTCInfo->szActionKey, c_szDDEExec);
        err = sizeof(pFTDInfo->pFTCInfo->szDDEMsg);
        err = RegQueryValue(pFTDInfo->pFTInfo->hkeyFT, ach, pFTDInfo->pFTCInfo->szDDEMsg, &err);
        if(err == ERROR_SUCCESS && *pFTDInfo->pFTCInfo->szDDEMsg)
        {
            bRC = TRUE;
            if(RegOpenKey(pFTDInfo->pFTInfo->hkeyFT, ach, &hkDDE) == ERROR_SUCCESS)
            {
                    // see if we have a DDE Application key and value
                err = sizeof(pFTDInfo->pFTCInfo->szDDEApp);
                RegQueryValue(hkDDE, c_szDDEApp, pFTDInfo->pFTCInfo->szDDEApp, &err);

                // see if we have a DDE Application Not Running key and value
                err = sizeof(pFTDInfo->pFTCInfo->szDDEAppNot);
                RegQueryValue(hkDDE, c_szDDEAppNot, pFTDInfo->pFTCInfo->szDDEAppNot, &err);

                // see if we have a DDE Topic key and value
                err = sizeof(pFTDInfo->pFTCInfo->szDDETopic);
                RegQueryValue(hkDDE, c_szDDETopic, pFTDInfo->pFTCInfo->szDDETopic, &err);

                RegCloseKey(hkDDE);
            }
        }
    }
    return(bRC);
}

//====================================================================
//====================================================================
BOOL DefaultAction(HKEY hkeyFT, LPSTR pszDefaultAction, DWORD *dwDefaultAction)
{
    LONG err;

    err = RegQueryValue(hkeyFT, c_szShell, pszDefaultAction, dwDefaultAction);
    if (err == ERROR_SUCCESS && *pszDefaultAction)
        return(TRUE);

    return(FALSE);
}

//====================================================================
//====================================================================
VOID VerbToExe(HKEY hkeyFT, LPSTR pszVerb, LPSTR pszExe, DWORD *pdwExe)
{
    // caller is responsible to setting pdwExe
    char ach[MAX_PATH+MAX_PATH+7]; // 7 = "\shell\"
    LONG err;

    wsprintf(ach, c_szTemplateSSS, c_szShell, pszVerb, c_szCommand);
    err = RegQueryValue(hkeyFT, ach, pszExe, pdwExe);
    if (err != ERROR_SUCCESS || !*pszExe)
        {
        *pdwExe = 0;
        }
}

//====================================================================
//====================================================================
LONG SaveFileTypeData(DWORD dwName, PFILETYPESDIALOGINFO pFTDInfo)
{
    LONG lRC = ERROR_SUCCESS;
    HKEY hk;
    HKEY hk2;
    char szBuf[MAX_PATH+MAX_PATH+12];    // 12 = "\defaulticon"
    char szAction[MAX_PATH];

    switch(dwName)
    {
        case FTD_EDIT:
            // Save file type id and description
            if(RegSetValue(HKEY_CLASSES_ROOT, pFTDInfo->pFTInfo->szId, REG_SZ, pFTDInfo->pFTInfo->szDesc,
                    sizeof(pFTDInfo->pFTInfo->szDesc)) != ERROR_SUCCESS)
                lRC = !ERROR_SUCCESS;

            // Save default action key and value
            wsprintf(szBuf, c_szTemplateSS, pFTDInfo->pFTInfo->szId, c_szShell);
            if(RegSetValue(HKEY_CLASSES_ROOT, szBuf, REG_SZ, pFTDInfo->pFTInfo->szDefaultAction,
                    sizeof(szAction)) != ERROR_SUCCESS)
                lRC = !ERROR_SUCCESS;
            break;
        case FTD_DOCICON:
            wsprintf(szBuf, c_szTemplateSS, pFTDInfo->pFTInfo->szId, c_szDefaultIcon);
#pragma data_seg(".text", "CODE")
            wsprintf(szAction, "%s,%d", pFTDInfo->szIconPath, pFTDInfo->iIconIndex);
#pragma data_seg()
            if(RegSetValue(HKEY_CLASSES_ROOT, szBuf, REG_SZ, szAction,
                    sizeof(szAction)) != ERROR_SUCCESS)
                lRC = !ERROR_SUCCESS;
            break;
        case FTD_EXT:
            // Save extension and file type id
            if(RegSetValue(HKEY_CLASSES_ROOT,
                    DPA_FastGetPtr(pFTDInfo->pFTInfo->hDPAExt,0),
                    REG_SZ, pFTDInfo->pFTInfo->szId,
                    sizeof(pFTDInfo->pFTInfo->szId)) != ERROR_SUCCESS)
                lRC = !ERROR_SUCCESS;
            break;
#ifdef MIME
        case FTD_MIME:
            // Save MIME type.
                        if (! RegisterMIMEInformation(pFTDInfo))
                lRC = !ERROR_SUCCESS;
            break;
#endif   /* MIME */
        case FTD_COMMAND:
            // Create/Open HKEY_CLASSES_ROOT\filetype\shell\action key
            wsprintf(szBuf, c_szTemplateSSS,
                pFTDInfo->pFTCInfo->szId, c_szShell, pFTDInfo->pFTCInfo->szActionKey);
            if(RegCreateKey(HKEY_CLASSES_ROOT, szBuf, &hk) == ERROR_SUCCESS)
            {
                // Tag as user defined verb
                if(pFTDInfo->pFTCInfo->dwVerbAttributes)
                    SetVerbAttributes(pFTDInfo->pFTInfo->hkeyFT, pFTDInfo->pFTCInfo->szActionKey, pFTDInfo->pFTCInfo->dwVerbAttributes);

                // Save action verb key and value if string has accelerator
                if(lstrcmp(pFTDInfo->pFTCInfo->szActionKey,
                                        pFTDInfo->pFTCInfo->szActionValue) != 0)
                {
                    if(RegSetValue(hk, NULL, REG_SZ, pFTDInfo->pFTCInfo->szActionValue,
                            sizeof(pFTDInfo->pFTCInfo->szActionValue)) != ERROR_SUCCESS)
                        lRC = !ERROR_SUCCESS;
                }

                // Save action command key and value
                if(RegSetValue(hk, c_szCommand, REG_SZ, pFTDInfo->pFTCInfo->szCommand,
                        sizeof(pFTDInfo->pFTCInfo->szCommand)) != ERROR_SUCCESS)
                    lRC = !ERROR_SUCCESS;

                if(IsDlgButtonChecked(pFTDInfo->hCmdDialog, IDC_FT_CMD_USEDDE))
                {
                    // Save DDE Message key and value
                    if(*pFTDInfo->pFTCInfo->szDDEMsg)
                    {
                        if(RegSetValue(hk, c_szDDEExec, REG_SZ, pFTDInfo->pFTCInfo->szDDEMsg,
                                sizeof(pFTDInfo->pFTCInfo->szDDEMsg)) != ERROR_SUCCESS)
                            lRC = !ERROR_SUCCESS;
                    }

                           if(RegCreateKey(hk, c_szDDEExec, &hk2) == ERROR_SUCCESS)
                    {
                            // Save DDEApp key and value
                            if(*pFTDInfo->pFTCInfo->szDDEApp)
                            {
                                if(RegSetValue(hk2, c_szDDEApp, REG_SZ, pFTDInfo->pFTCInfo->szDDEApp,
                                        sizeof(pFTDInfo->pFTCInfo->szDDEApp)) != ERROR_SUCCESS)
                                    lRC = !ERROR_SUCCESS;
                            }

                            // Save DDEAppNot key and value
                            if(*pFTDInfo->pFTCInfo->szDDEAppNot)
                            {
                                if(RegSetValue(hk2, c_szDDEAppNot, REG_SZ, pFTDInfo->pFTCInfo->szDDEAppNot,
                                        sizeof(pFTDInfo->pFTCInfo->szDDEAppNot)) != ERROR_SUCCESS)
                                    lRC = !ERROR_SUCCESS;
                            }

                            // Save DDETopic key and value
                            if(*pFTDInfo->pFTCInfo->szDDETopic)
                            {
                                if(RegSetValue(hk2, c_szDDETopic, REG_SZ, pFTDInfo->pFTCInfo->szDDETopic,
                                        sizeof(pFTDInfo->pFTCInfo->szDDETopic)) != ERROR_SUCCESS)
                                    lRC = !ERROR_SUCCESS;
                            }
                            RegCloseKey(hk2);
                        }
                    }
                    else
                        DeleteDDEKeys(szBuf);

                RegCloseKey(hk);
            }
            else
                lRC = !ERROR_SUCCESS;
            break;
    }

    return(lRC);
}

//====================================================================
//====================================================================
VOID ResizeCommandDlg(HWND hDialog, BOOL bFlag)
{
    RECT rcDialog;
    RECT rcControl;

    GetWindowRect(hDialog, &rcDialog);

    if(bFlag)    // resize to show dde group
        GetWindowRect(GetDlgItem(hDialog, IDC_FT_CMD_DDEGROUP), &rcControl);
    else        // resize to hide dde group
        GetWindowRect(GetDlgItem(hDialog, IDC_FT_CMD_USEDDE), &rcControl);

    ShowWindow(GetDlgItem(hDialog, IDC_FT_CMD_DDEMSG), bFlag);
    ShowWindow(GetDlgItem(hDialog, IDC_FT_CMD_DDEAPP), bFlag);
    ShowWindow(GetDlgItem(hDialog, IDC_FT_CMD_DDEAPPNOT), bFlag);
    ShowWindow(GetDlgItem(hDialog, IDC_FT_CMD_DDETOPIC), bFlag);
    ShowWindow(GetDlgItem(hDialog, IDC_FT_CMD_DDEGROUP), bFlag);
    SetWindowPos(GetDlgItem(hDialog, IDC_FT_CMD_USEDDE), HWND_TOPMOST, 0,0,0,0,SWP_NOMOVE|SWP_NOSIZE|SWP_SHOWWINDOW);

    MoveWindow(hDialog, rcDialog.left, rcDialog.top, rcDialog.right - rcDialog.left,
        (rcControl.bottom - rcDialog.top) + 10, TRUE);

    SetFocus(GetDlgItem(hDialog, IDC_FT_CMD_USEDDE));
}

//====================================================================
//====================================================================
LONG RemoveAction(PFILETYPESDIALOGINFO pFTDInfo, HKEY hk, LPCSTR pszKey, LPSTR szAction)
{
    LONG lRC = ERROR_SUCCESS;
    HKEY hk1;
    int iNext;

    // Remove keys from the registry
    if(RegOpenKeyEx(hk, pszKey, 0, KEY_ALL_ACCESS, &hk1) == ERROR_SUCCESS)
    {
        if(RegDeleteKey(hk1, szAction) != ERROR_SUCCESS)
            lRC = !ERROR_SUCCESS;
        RegCloseKey(hk1);
    }

    // Remove the item from the list view, and ensure that the relative item
    // is selected, eg. if we deleted the last item then the last item remains
    // selected - this used to be completely bogus.

    iNext = ListView_GetNextItem(pFTDInfo->hwndLVFTEdit, pFTDInfo->iEditItem, LVNI_BELOW );
    if ( iNext == -1 )
        iNext = ListView_GetNextItem(pFTDInfo->hwndLVFTEdit, pFTDInfo->iEditItem, LVNI_ABOVE );

    ListView_DeleteItem(pFTDInfo->hwndLVFTEdit, pFTDInfo->iEditItem);
    ListView_SetItemState(pFTDInfo->hwndLVFTEdit, iNext, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
    SetFocus(pFTDInfo->hwndLVFTEdit);

    if(pFTDInfo->pFTInfo->hIconOpen != (HICON)NULL)
    {
        DestroyIcon(pFTDInfo->pFTInfo->hIconOpen);
        pFTDInfo->pFTInfo->hIconOpen = (HICON)NULL;
        SendMessage(pFTDInfo->hwndOpenIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM)pFTDInfo->pFTInfo->hIconOpen);
    }

    return(lRC);
}

//====================================================================
//====================================================================
LONG RemoveFileType(PFILETYPESDIALOGINFO pFTDInfo)
{
    LONG lRC = ERROR_SUCCESS;
    LV_ITEM LVItem;
    int i;
    int iCnt;
    LPSTR pszExt;
    char szKey[MAX_PATH];
    char szBuf[2];
    HKEY hk;

    // Remove filetype and keys from the registry
    if(*pFTDInfo->pFTInfo->szId)
        if(RegDeleteKey(HKEY_CLASSES_ROOT, pFTDInfo->pFTInfo->szId) != ERROR_SUCCESS)
                lRC = !ERROR_SUCCESS;

    // Free allocated memory &
    // Remove extension(s) and their keys from the registry
    LVItem.mask = LVIF_PARAM;
    LVItem.iItem = pFTDInfo->iItem;
    LVItem.iSubItem = 0;

    ListView_GetItem(pFTDInfo->hwndLVFT, &LVItem);
    if(pFTDInfo->pFTInfo = (PFILETYPESINFO)LVItem.lParam)
    {
        if(pFTDInfo->pFTInfo->hDPAExt != (HDPA)NULL)
        {
#ifdef MIME
         if (! RemoveMIMETypeInfo(pFTDInfo, pFTDInfo->pFTInfo->szOriginalMIMEType))
              lRC = !ERROR_SUCCESS;
#endif   /* MIME */
         iCnt = DPA_GetPtrCount(pFTDInfo->pFTInfo->hDPAExt);
            for(i = 0; i < iCnt; i++)
            {
                if(pszExt = DPA_FastGetPtr(pFTDInfo->pFTInfo->hDPAExt, i))
                {
                    if(*pszExt)
                    {
                        // Don't delete extension if it has a ShellNew key, just remove filetype
#pragma data_seg(".text", "CODE")
                        wsprintf(szKey, "%s\\%s%s", pszExt, c_szShell, c_szNew);
#pragma data_seg()
                        if(RegOpenKey(HKEY_CLASSES_ROOT, szKey, &hk) == ERROR_SUCCESS)
                        {
                            RegCloseKey(hk);
                            *szBuf = '\0';  // remove the filetype assoc
                            RegSetValue(HKEY_CLASSES_ROOT, pszExt,
                                    REG_SZ, szBuf, sizeof(szBuf));
                        }
                        else
                        {
                            if(RegDeleteKey(HKEY_CLASSES_ROOT, pszExt) != ERROR_SUCCESS)
                                lRC = !ERROR_SUCCESS;
                                                }
                    }
                }
            }
        }
                pFTDInfo->pFTInfo = NULL;   // don't attempt to go through deleted pointer
    }

    // Remove item from list view
    ListView_DeleteItem(pFTDInfo->hwndLVFT, pFTDInfo->iItem);

    // We need to case if we delete the last item as than we must
    // select the previous item not the same number...
    iCnt = ListView_GetItemCount(pFTDInfo->hwndLVFT);
    if (pFTDInfo->iItem >= iCnt)
        pFTDInfo->iItem--;
    ListView_SetItemState(pFTDInfo->hwndLVFT, pFTDInfo->iItem, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
    ListView_RedrawItems(pFTDInfo->hwndLVFT, 0, iCnt);
    ListView_EnsureVisible(pFTDInfo->hwndLVFT, pFTDInfo->iItem, FALSE);
    PostMessage(pFTDInfo->hwndLVFT, WM_SETFOCUS, (WPARAM)0, (LPARAM)0);

    SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);

    return(lRC);
}

//====================================================================
//====================================================================
// taken from fstreex.c
BOOL ExtToTypeNameAndId(LPSTR pszExt, LPSTR pszDesc, DWORD *pdwDesc, LPSTR pszId, DWORD *pdwId)
{
    LONG err;
    DWORD dwNm;
    BOOL bRC = TRUE;

    err = RegQueryValue(HKEY_CLASSES_ROOT, pszExt, pszId, pdwId);
    if (err == ERROR_SUCCESS && *pszId)
    {
        dwNm = *pdwDesc;    // if we fail we will still have name size to use
        err = RegQueryValue(HKEY_CLASSES_ROOT, pszId, pszDesc, &dwNm);
        if (err != ERROR_SUCCESS || !*pszDesc)
            goto Error;
        *pdwDesc = dwNm;
    }
    else
    {
           char szExt[MAX_PATH];    // "TXT"
           char szTemplate[128];   // "%s File"
        char szRet[MAX_PATH+20];        // "TXT File"
Error:
        bRC = FALSE;

        lstrcpy(pszId, pszExt);

        pszExt++;
        lstrcpy(szExt, pszExt);
        AnsiUpper(szExt);
        MLLoadStringA(IDS_EXTTYPETEMPLATE, szTemplate, ARRAYSIZE(szTemplate));
        wsprintf(szRet, szTemplate, szExt);
        lstrcpyn(pszDesc, szRet, *pdwDesc);
        *pdwDesc = lstrlen(pszDesc);
    }
    return(bRC);
}

//================================================================
//================================================================
VOID StrRemoveChar(LPSTR pszSrc, LPSTR pszDest, char ch)
{
    LPSTR pSrc = pszSrc;
    LPSTR pDest = (pszDest ?pszDest :pszSrc);

    Assert(pSrc);
    Assert(pDest);

    if(pSrc && pDest)
    {
        while(*pSrc)
        {
            if(*pSrc != ch)
                *(pDest++) = *pSrc;
            pSrc++;
        }
        *pDest = '\0';
    }
}

//================================================================
//================================================================
// This code should be in PATH.C
// in/out:
//    pszIconFile    location string
//            "progman.exe,3" -> "progman.exe"
//
// returns:
//    icon index (zero based) ready for ExtractIcon
//
int ParseIconLocation(LPSTR pszIconFile)
{
    int iIndex = 0;
    LPSTR pszComma = StrChr(pszIconFile, ',');

    if (pszComma) {
        *pszComma++ = 0;        // terminate the icon file name.

        while(*pszComma==' ')   // remove any white space
            pszComma++;

        iIndex = StrToInt(pszComma);
    }
    PathRemoveBlanks(pszIconFile);
    return iIndex;
}

//================================================================
//================================================================
BOOL IsDefaultAction(PFILETYPESDIALOGINFO pFTDInfo, LPSTR pszAction)
{
    return((lstrcmpi(pFTDInfo->pFTInfo->szDefaultAction, pszAction) == 0) ||
       (!(*pFTDInfo->pFTInfo->szDefaultAction) && (lstrcmpi(pszAction, c_szOpen) == 0)));
}

//================================================================
//================================================================
BOOL SetDefaultAction(PFILETYPESDIALOGINFO pFTDInfo)
{
    char szFile[MAX_PATH];
    LV_ITEM LVItem;

    if(IsDefaultAction(pFTDInfo, pFTDInfo->pFTCInfo->szActionKey))
        *pFTDInfo->pFTInfo->szDefaultAction = '\0';
    else
        lstrcpy(pFTDInfo->pFTInfo->szDefaultAction, pFTDInfo->pFTCInfo->szActionKey);

    // This will cause the new icon and exe to be reretreived and displayed when select in prop sheet
    if(pFTDInfo->pFTInfo->hIconOpen != (HICON)NULL)
    {
        DestroyIcon(pFTDInfo->pFTInfo->hIconOpen);
        pFTDInfo->pFTInfo->hIconOpen = (HICON)NULL;
        SendMessage(pFTDInfo->hwndOpenIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM)0);
    }

    if(pFTDInfo->pFTInfo->hIconDoc != (HICON)NULL)
    {
        DestroyIcon(pFTDInfo->pFTInfo->hIconDoc);
        pFTDInfo->pFTInfo->hIconDoc = (HICON)NULL;
        SendMessage(pFTDInfo->hwndDocIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM)0);
    }

    // Save default action
    SaveFileTypeData(FTD_EDIT, pFTDInfo);
///    if(IsDefaultAction(pFTDInfo, szAction))
///    {
        ExtToShellCommand(pFTDInfo->pFTInfo->hkeyFT, szFile, sizeof(szFile));
        PathRemoveArgs(szFile);
        PathRemoveBlanks(szFile);
        if(PathIsRelative(szFile))
            PathFindOnPath(szFile, NULL);    // search for exe

        //
        //  First, try to get the icon based of "DefaultIcon=" key.
        // If it fails, then we'll get the document icon from the
        // newly specified exe file.
        //
        pFTDInfo->pFTInfo->hIconDoc = GetDefaultIcon(&pFTDInfo->pFTInfo->hkeyFT, pFTDInfo->szId, SHGFI_LARGEICON);
        if (pFTDInfo->pFTInfo->hIconDoc==NULL) {
            pFTDInfo->pFTInfo->hIconDoc = GetDocIcon(pFTDInfo, szFile);
        }

        SendMessage(pFTDInfo->hwndEditDocIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM)pFTDInfo->pFTInfo->hIconDoc);

        // Get the image index from the list view item
        LVItem.mask        = LVIF_IMAGE;
        LVItem.iItem       = pFTDInfo->iItem;
        LVItem.iSubItem    = 0;
        ListView_GetItem(pFTDInfo->hwndLVFT, &LVItem);

        // replace the icon in the image list
        if(pFTDInfo->himlFT && (LVItem.iImage >= 0) && pFTDInfo->pFTInfo->hIconDoc)
            if(ImageList_ReplaceIcon(pFTDInfo->himlFT, LVItem.iImage, pFTDInfo->pFTInfo->hIconDoc) != (-1))
                ListView_SetItem(pFTDInfo->hwndLVFT, &LVItem);
///    }

    return(TRUE);
}

//================================================================
//================================================================
HKEY GetHkeyFT(LPSTR pszId)
{
    HKEY hkeyFT;

    if(RegCreateKey(HKEY_CLASSES_ROOT, pszId, &hkeyFT) != ERROR_SUCCESS)
        hkeyFT = NULL;

    return(hkeyFT);
}



//================================================================================================//

//
// We make use of a newer API in shelldll.  However this is a private API introduced in SUR.
//
// Therefore this code attempts to do the right thing, first we check to see if we have
// found the exported entry from SHELLDLL.  If we have then we call that, but, this however may
// required thunking.
//
// If we didn't bind to the export, then we call our own version of the call.
//

LONG UrlPathProcessCommand( LPCTSTR lpSrc, LPTSTR lpDest, int iMax, DWORD dwFlags )
{
    LONG lResult = 0;
    LPWSTR lpwSrc=NULL;
    LPWSTR lpwDest=NULL;
    int iLen;

    if ( lpPathProcessCommand )
    {
        if (RUNNING_NT)
        {
            iLen =     MultiByteToWideChar(CP_ACP, 0, lpSrc, -1, NULL, 0);

            lpwSrc = (LPWSTR)LocalAlloc(LPTR, SIZEOF(WCHAR)*iLen);
            lpwDest = (LPWSTR)LocalAlloc(LPTR, SIZEOF(WCHAR)*iMax);

            if ( lpwSrc && lpwDest )
            {
                MultiByteToWideChar(CP_ACP, 0, lpSrc, -1, lpwSrc, iLen);

                lResult = lpPathProcessCommand( (LPTSTR)lpwSrc, (LPTSTR)lpwDest, iMax, dwFlags );

                if ( lResult != -1 )
                    WideCharToMultiByte(CP_ACP, 0, lpwDest, -1, lpDest, iMax, NULL, NULL);
            }
        }
        else
            lResult = lpPathProcessCommand( lpSrc, lpDest, iMax, dwFlags );
    }
    else
    {
        lResult = UrlPathProcessCommand2( lpSrc, lpDest, iMax, dwFlags );
    }

    if ( lpwSrc )
        LocalFree(lpwSrc);
    if ( lpwDest )
        LocalFree(lpwDest);

    return lResult;
}

//
// PathProcessCommand implementation as found in path.c (shelldll).
//

LONG UrlPathProcessCommand2( LPCTSTR lpSrc, LPTSTR lpDest, int iDestMax, DWORD dwFlags )
{
    TCHAR szName[MAX_PATH];
    LPTSTR lpBuffer, lpBuffer2;
    LPCTSTR lpArgs = NULL;
    DWORD dwAttrib;
    LONG i, iTotal;
    LONG iResult = -1;
    BOOL bAddQuotes = FALSE;
    BOOL bQualify = FALSE;
    BOOL bFound = FALSE;
    BOOL bHitSpace = FALSE;

    // Process the given source string, attempting to find what is that path, and what is its
    // arguments.

    if ( lpSrc )
    {
        // Extract the sub string, if its is realative then resolve (if required).

        if ( *lpSrc == TEXT('\"') )
        {
            for ( lpSrc++, i=0 ; i<MAX_PATH && *lpSrc && *lpSrc!=TEXT('\"') ; i++, lpSrc++ )
                szName[i] = *lpSrc;

            szName[i] = TEXT('\0');

            if ( *lpSrc )
                lpArgs = lpSrc+1;

            if ( ((dwFlags & PPCF_FORCEQUALIFY) || PathIsRelative( szName ))
                    && !( dwFlags & PPCF_NORELATIVEOBJECTQUALIFY ) )
            {
                if ( !PathResolve( (LPWSTR)szName, NULL, PRF_TRYPROGRAMEXTENSIONS ) )  // (LPWSTR) so it builds, but only works downlevel
                    goto exit_gracefully;
            }

            bFound = TRUE;
        }
        else
        {
            // Is this a relative object, and then take each element upto a seperator
            // and see if we hit an file system object.  If not then we can

            bQualify = PathIsRelative( lpSrc ) || ((dwFlags & PPCF_FORCEQUALIFY) != 0);

            for ( i=0; i < MAX_PATH ; i++ )
            {
                szName[i] = lpSrc[i];

                // If we hit a space then the string either contains a LFN or we have
                // some arguments.  Therefore attempt to get the attributes for the string
                // we have so far, if we are unable to then we can continue
                // checking, if we hit then we know that the object exists and the
                // trailing string are its arguments.

                if ( !szName[i] || szName[i] == TEXT(' ') )
                {
                    szName[i] = TEXT('\0');

                    while ( TRUE )
                    {
                        if ( bQualify && !PathResolve( (LPWSTR)szName, NULL, PRF_TRYPROGRAMEXTENSIONS ) )  // (LPWSTR) so it builds, but only works downlevel
                            break;

                        dwAttrib = GetFileAttributes( szName );

                        if ( dwAttrib == -1 || ( ( dwAttrib & FILE_ATTRIBUTE_DIRECTORY ) && dwFlags & PPCF_NODIRECTORIES ) )
                            break;

                        if ( bQualify && ( dwFlags & PPCF_NORELATIVEOBJECTQUALIFY ) )
                            *lstrcpyn( szName, lpSrc, i ) = TEXT(' ');

                        bFound = TRUE;                  // success
                        lpArgs = &lpSrc[i];

                        goto exit_gracefully;
                    }

                    if ( bQualify )
                        hmemcpy( szName, lpSrc, (i+1)*SIZEOF(TCHAR) );
                    else
                        szName[i]=lpSrc[i];

                    bHitSpace = TRUE;
                }

                if ( !szName[i] )
                    break;
            }
        }
    }

exit_gracefully:

    // Work out how big the temporary buffer should be, allocate it and
    // build the returning string into it.  Then compose the string
    // to be returned.

    if ( bFound )
    {
        if ( StrChr( szName, TEXT(' ') ) )
            bAddQuotes = dwFlags & PPCF_ADDQUOTES;

        iTotal  = lstrlen(szName) + 1;                // for terminator
        iTotal += bAddQuotes ? 2 : 0;
        iTotal += (dwFlags & PPCF_ADDARGUMENTS) && lpArgs ? lstrlen(lpArgs) : 0;

        if ( lpDest )
        {
            if ( iTotal <= iDestMax )
            {
                lpBuffer = lpBuffer2 = (LPTSTR)LocalAlloc( LMEM_FIXED, SIZEOF(TCHAR)*iTotal );

                if ( lpBuffer )
                {
                    // First quote if required
                    if ( bAddQuotes )
                        *lpBuffer2++ = TEXT('\"');

                    // Matching name
                    lstrcpy( lpBuffer2, szName );

                    // Closing quote if required
                    if ( bAddQuotes )
                        lstrcat( lpBuffer2, TEXT("\"") );

                    // Arguments (if requested)
                    if ( (dwFlags & PPCF_ADDARGUMENTS) && lpArgs )
                        lstrcat( lpBuffer2, lpArgs );

                    // Then copy into callers buffer, and free out temporary buffer
                    lstrcpy( lpDest, lpBuffer );
                    LocalFree( (HGLOBAL)lpBuffer );

                    // Return the length of the resulting string
                    iResult = iTotal;
                }
            }
        }
        else
        {
            // Resulting string is this big, although nothing returned (allows them to allocate a buffer)
            iResult = iTotal;
        }
    }

    return iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\hash.c ===
//
// Copyright (c) Microsoft Corporation 1991-1993
//
// File: Hash.c
//
// Comments:
//      This file contains functions that are roughly equivelent to the
//      kernel atom function.  There are two main differences.  The first
//      is that in 32 bit land the tables are maintined in our shared heap,
//      which makes it shared between all of our apps.  The second is that
//      we can assocate a long pointer with each of the items, which in many
//      cases allows us to keep from having to do a secondary lookup from
//      a different table
//
// History:
//  09/08/93 - Created  KurtE
//
//---------------------------------------------------------------------------

#ifdef STRICT
#undef STRICT
#endif
#define NO_SHELL_HEAP_ALLOCATOR  //Kludge to get around new mem heaps in nt

#define NO_SHELL_VALIDATION

// to fix assert problem
#ifdef ASSERT
#undef ASSERT
#endif

#include "project.h"
#include "urlshell.h"
#include <platform.h>


//--------------------------------------------------------------------------
// First define a data structure to use to maintain the list

#define PRIME   37

// NOTE a PHASHITEM is defined as a LPCSTR externaly (for old code to work)
#undef PHASHITEM
typedef struct _HashItem FAR * PHASHITEM;

typedef struct _HashItem
{
    PHASHITEM   phiNext;        //
    UINT        wCount;         // Usage count
    BYTE        cbLen;          // Length of name in characters.
    char        szName[1];      // name
} HASHITEM;

typedef struct _HashTable
{
    UINT    wBuckets;           // Number of buckets
    UINT    wcbExtra;           // Extra bytes per item
    BOOL    fUpperCase;         // Uppercase names
    PHASHITEM phiLast;          // Pointer to the last item we worked with
    PHASHITEM ahiBuckets[EMPTY_SIZE];    // Set of buckets for the table
} HASHTABLE, FAR * PHASHTABLE;

#define HIFROMSZ(sz)  ((PHASHITEM)((BYTE*)(sz) - FIELDOFFSET(HASHITEM, szName)))
#define HIDATAPTR(sz) ((DWORD UNALIGNED *)((BYTE*)(sz) + HIFROMSZ(sz)->cbLen+1))

#define  LOOKUPHASHITEM     0
#define  ADDHASHITEM        1
#define  DELETEHASHITEM     2

static PHASHTABLE g_pHashTable = NULL;

PHASHTABLE NEAR PASCAL GetGlobalHashTable();

//--------------------------------------------------------------------------
// This function looks up the name in the hash table and optionally does
// things like add it, or delete it.
//

//// FEATURE
// we will need to serialize this eventually.

LPCSTR NEAR PASCAL LookupItemInHashTable(PHASHTABLE pht, LPCSTR pszName, int iOp)
{
    // First thing to do is calculate the hash value for the item
    DWORD   dwHash = 0;
    UINT    wBucket;
    BYTE    cbName = 0;
    BYTE    c;
    PHASHITEM phi, phiPrev;
    LPCSTR psz = pszName;

    if (pht == NULL) {
        pht = GetGlobalHashTable();
    }

    if (pht)
    {
        while (*psz)
        {
            // Same type of hash like HashItem manager
            c = *psz++;

            if (pht->fUpperCase && ( c >= 'a') && (c <= 'z'))
                c = c - 'a' + 'A';
            dwHash += (c << 1) + (c >> 1) + c;
            cbName++;
            ASSERT(cbName);

            if (cbName == 0)
                return(NULL);       // Length to long!
        }

        // now search for the item in the buckets.
        phiPrev = NULL;
        ENTERCRITICAL;
        phi = pht->ahiBuckets[wBucket = (UINT)(dwHash % pht->wBuckets)];

        while (phi)
        {
            if (phi->cbLen == cbName)
            {
                if (pht->fUpperCase)
                {
                    if (!lstrcmpi(pszName, phi->szName))
                        break;      // Found match
                }
                else
                {
                    if (!lstrcmp(pszName, phi->szName))
                        break;      // Found match
                }
            }
            phiPrev = phi;      // Keep the previous item
            phi = phi->phiNext;
        }

        //
        // Sortof gross, but do the work here
        //
        switch (iOp)
        {
        case ADDHASHITEM:
            if (phi)
            {
                // Simply increment the reference count
    #ifdef HITTRACE
                DebugMsg(DM_TRACE, "Add Hit on '%s'", pszName);
    #endif
                phi->wCount++;
            }
            else
            {
    #ifdef HITTRACE
                DebugMsg(DM_TRACE, "Add MISS on '%s'", pszName);
    #endif
                // Not Found, try to allocate it out of the heap
                phi = (PHASHITEM)Alloc(sizeof(HASHITEM) + cbName + pht->wcbExtra);

                if (phi != NULL)
                {
                    // Initialize it
                    phi->wCount = 1;        // One use of it
                    phi->cbLen = cbName;        // The length of it;
                    lstrcpy(phi->szName, pszName);

                    // And link it in to the right bucket
                    phi->phiNext = pht->ahiBuckets[wBucket];
                    pht->ahiBuckets[wBucket] = phi;
                }
            }
            pht->phiLast = phi;
            break;

        case DELETEHASHITEM:
            if (phi)
            {
                phi->wCount--;
                if (phi->wCount == 0)
                {
                    // Useage count went to zero so unlink it and delete it
                    if (phiPrev != NULL)
                        phiPrev->phiNext = phi->phiNext;
                    else
                        pht->ahiBuckets[wBucket] = phi->phiNext;

                    // And delete it
                    Free(phi);

                    phi = NULL;
                }
            }
        
            case LOOKUPHASHITEM:
                pht->phiLast = phi;
                break;
        }

        LEAVECRITICAL;
    }
    else
    {
        phi = NULL;
    }
    
    // If find was passed in simply return it.
    return phi ? (LPCSTR)phi->szName : NULL;
}

//--------------------------------------------------------------------------

LPCSTR WINAPI AddHashItem(PHASHTABLE pht, LPCSTR lpszStr)
{
    return LookupItemInHashTable(pht, lpszStr, ADDHASHITEM);
}

//--------------------------------------------------------------------------

LPCSTR WINAPI DeleteHashItem(PHASHTABLE pht, LPCSTR lpszStr)
{
    return LookupItemInHashTable(pht, lpszStr, DELETEHASHITEM);
}

//======================================================================

PHASHTABLE WINAPI CreateHashItemTable(UINT wBuckets, UINT wExtra, BOOL fCaseSensitive)
{
    PHASHTABLE pht;

    if (wBuckets == 0)
        wBuckets = 71;

    pht = (PHASHTABLE)Alloc(sizeof(HASHTABLE) + wBuckets * sizeof(PHASHITEM));

    if (pht) {
        pht->fUpperCase = !fCaseSensitive;
        pht->wBuckets = wBuckets;
        pht->wcbExtra = wExtra;
    }
    
    return pht;    
}

//======================================================================

PHASHTABLE NEAR PASCAL GetGlobalHashTable()
{
    if (g_pHashTable == NULL) {
        g_pHashTable = CreateHashItemTable(71, 0, FALSE);
    }
    return g_pHashTable;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\inetcpl.c ===
/*
 * inetcpl.c - Indirect calls to inetcpl.cpl.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "inetcpl.h"


/* Types
 ********/

/* Internet CPL vtable */

typedef struct internetcplvtbl
{
   HRESULT (WINAPI *AddInternetPropertySheets)(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lparam, PUINT pucRefCount, LPFNPSPCALLBACK pfnCallback);
}
INTERNETCPLVTBL;
DECLARE_STANDARD_TYPES(INTERNETCPLVTBL);


/* Module Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

PRIVATE_DATA CCHAR s_cszInternetCPL[]               = "inetcpl.cpl";
PRIVATE_DATA CCHAR s_cszAddInternetPropertySheets[] = "AddInternetPropertySheets";

#pragma data_seg()


/* Module Variables
 *******************/

/* Internet CPL reference count */
PRIVATE_DATA UINT s_ucRef = 0;

PRIVATE_DATA HINSTANCE s_hinstInternetCPL    = NULL;

/* Internet CPL vtable */

PRIVATE_DATA PINTERNETCPLVTBL s_pinetcplvtbl = NULL;


/***************************** Private Functions *****************************/


#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCINTERNETCPLVTBL(PCINTERNETCPLVTBL pcinetcplctbl)
{
   return(IS_VALID_READ_PTR(pcinetcplctbl, CINTERNETCPLVTBL) &&
          IS_VALID_CODE_PTR(pcinetcplctbl->AddInternetPropertySheets, AddInternetPropertySheets));
}


PRIVATE_CODE BOOL InternetCPLNotLoadedStateOK(void)
{
   return(! s_hinstInternetCPL &&
          ! s_pinetcplvtbl);
}


PRIVATE_CODE BOOL InternetCPLLoadedStateOK(void)
{
   return(IS_VALID_HANDLE(s_hinstInternetCPL, INSTANCE) &&
          IS_VALID_STRUCT_PTR(s_pinetcplvtbl, CINTERNETCPLVTBL));
}


PRIVATE_CODE BOOL InternetCPLStateOK(void)
{
   return(InternetCPLNotLoadedStateOK() ||
          InternetCPLLoadedStateOK());
}

#endif   /* DEBUG */


PRIVATE_CODE BOOL IsInternetCPLLoaded(void)
{
   ASSERT(InternetCPLStateOK());

   return(s_hinstInternetCPL != NULL);
}


PRIVATE_CODE BOOL GetInternetCPLProc(PCSTR pcszProc, FARPROC *pfp)
{
   ASSERT(IS_VALID_STRING_PTR(pcszProc, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pfp, FARPROC));

   ASSERT(IS_VALID_HANDLE(s_hinstInternetCPL, INSTANCE));

   *pfp = GetProcAddress(s_hinstInternetCPL, pcszProc);

   if (*pfp)
      TRACE_OUT(("GetInternetCPLProc(): Got address of %s!%s.",
                 s_cszInternetCPL,
                 pcszProc));
   else
      WARNING_OUT(("GetOLEProc(): Failed to get address of %s!%s.",
                   s_cszInternetCPL,
                   pcszProc));

   ASSERT(! *pfp ||
          IS_VALID_CODE_PTR(*pfp, FARPROC));

   return(*pfp != NULL);
}


PRIVATE_CODE BOOL FillInternetCPLVTable(void)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(s_hinstInternetCPL, INSTANCE));

   if (AllocateMemory(sizeof(*s_pinetcplvtbl), &s_pinetcplvtbl))
   {
      bResult = GetInternetCPLProc(s_cszAddInternetPropertySheets,
                                   &(FARPROC)(s_pinetcplvtbl->AddInternetPropertySheets));

      if (bResult)
         TRACE_OUT(("FillInternetCPLVTable(): Internet CPL vtable filled successfully."));
      else
      {
         FreeMemory(s_pinetcplvtbl);
         s_pinetcplvtbl = NULL;
      }
   }
   else
      bResult = FALSE;

   ASSERT(! bResult ||
          InternetCPLLoadedStateOK());

   return(bResult);
}


PRIVATE_CODE BOOL LoadInternetCPL(void)
{
   BOOL bResult;

   bResult = IsInternetCPLLoaded();

   if (! bResult)
   {
      s_hinstInternetCPL = LoadLibrary(s_cszInternetCPL);

      if (s_hinstInternetCPL)
      {
         bResult = FillInternetCPLVTable();

         if (bResult)
            TRACE_OUT(("LoadInternetCPL(): %s loaded.",
                       s_cszInternetCPL));
      }
      else
         WARNING_OUT(("LoadInternetCPL(): LoadLibrary(%s) failed.",
                      s_cszInternetCPL));

      if (! bResult)
         UnloadInternetCPL();
   }

   ASSERT(InternetCPLStateOK());

   return(bResult);
}


/****************************** Public Functions *****************************/



PUBLIC_CODE void UnloadInternetCPL(void)
{
    if (s_pinetcplvtbl)
    {
        FreeMemory(s_pinetcplvtbl);
        s_pinetcplvtbl = NULL;

        TRACE_OUT(("UnloadInternetCPL(): Freed %s vtable.",
                   s_cszInternetCPL));
    }

    if (s_hinstInternetCPL)
    {
        FreeLibrary(s_hinstInternetCPL);
        s_hinstInternetCPL = NULL;

        TRACE_OUT(("UnloadInternetCPL(): Freed %s.",
                   s_cszInternetCPL));
    }


    return;
}


HRESULT InternetCPLCanUnloadNow(void)
{
    return ((s_ucRef > 0) ? S_FALSE : S_OK);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */
PUBLIC_CODE HRESULT WINAPI AddInternetPropertySheets(
                                             LPFNADDPROPSHEETPAGE pfnAddPage,
                                             LPARAM lparam, PUINT pucRefCount,
                                             LPFNPSPCALLBACK pfnCallback)
{
    HRESULT hr;

    /*
     * Increment the Internet CPL's reference count around this call it so that
     * it is not unloaded during the call.
     */

    if (LoadInternetCPL())
        hr = s_pinetcplvtbl->AddInternetPropertySheets(pfnAddPage, lparam,
                                                       &s_ucRef,
                                                       pfnCallback);
    else
        hr = E_FAIL;

    return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\fsassoc.c ===
/* Look for BUILDBUILD to find build hacks. */

/* BUILDBUILD: My hacks to get this to build. */

#pragma warning(disable:4001) /* "single line comment" warning */

#include "project.h"
#pragma hdrstop

#include "urlshell.h"
#include <windowsx.h>

#include <mluisupp.h>

#undef NO_HELP
#include <help.h>
#pragma pack(1)
//#include <newexe.h>             // newexe.h is broken with pack()!!!
#pragma pack()
#ifdef STRICT
#undef STRICT
#endif
#define NO_SHELL_HEAP_ALLOCATOR  //Kludge to get around new mem heaps in nt

#define NO_MULTIMON         // BUILDBUILD (scotth): no multimon stub functions
#define NO_SHELL_VALIDATION
#include <newexe.h>         // BUILDBUILD: added this from shellprv.h
#include "resource.h"       // BUILDBUILD: use local resource IDs

#ifdef RegQueryValue
#undef RegQueryValue
#endif

#define RegQueryValue(hkey, pszSubkey, pvValue, pcbSize)    SHGetValue(hkey, pszSubkey, NULL, NULL, pvValue, pcbSize)

// BUILDBUILD: add from shsemip.h
#define SIZEOF(a)       sizeof(a)

// BUILDBUILD: was from cstrings.h
extern CCHAR c_szNULL[];

#include "openas.h"

#undef HINST_THISDLL
#define HINST_THISDLL            (GetThisModulesHandle())

#undef ASSERTNONCRITICAL
#define ASSERTNONCRITICAL        ASSERT(! AccessIsExclusive());

#define MZMAGIC         ((WORD)'M'+((WORD)'Z'<<8))
#define LEMAGIC         ((WORD)'L'+((WORD)'E'<<8))

#define FCC(c0,c1,c2,c3) ((DWORD)(c0)|((DWORD)(c1)<<8)|((DWORD)(c2)<<16)|((DWORD)(c3)<<24))

#define COM_FILE        FCC('.', 'c', 'o', 'm')
#define BAT_FILE        FCC('.', 'b', 'a', 't')
#define EXE_FILE        FCC('.', 'e', 'x', 'e')

#define hinstCabinet       GetThisModulesHandle()
BOOL GetClassDescription(HKEY hkClasses, LPCSTR pszClass, LPSTR szDisplayName, int cbDisplayName, UINT uFlags);

/* needed because the NT shell only understands unicode for these
 * functions...
 */

/* define the local versions */
extern BOOL  lPathIsExeA(LPCSTR);
extern int   lShell_GetCachedImageIndexA(LPCSTR, int, UINT);
extern BOOL  lPathYetAnotherMakeUniqueNameA(LPSTR,LPCSTR,LPCSTR,LPCSTR);
extern LONG  lRegDeleteKeyA(HKEY, LPCSTR);

/***********************************************************
 * Needed because under NT, deleting a subkey will fail.
 *
 * Stolen from the SDK:
 *   Windows 95: The RegDeleteKey function deletes a key and 
 *               all its descendents.
 *   Windows NT: The RegDeleteKey function deletes the specified
 *               key. This function cannot delete a key that has
 *               subkeys. 
 **********************************************************/
// On Win95, RegDeleteKey deletes the key and all subkeys.  On NT, RegDeleteKey 
// fails if there are any subkeys.  On NT, we'll make shell code that assumes 
// the Win95 behavior work by mapping SHRegDeleteKey to a helper function that
// does the recursive delete.
// The reason we do it here, instead of calling the shell is so that we don't
// have any bogus dynalinks for the X86 version, which must also run on W95.

LONG ShRegDeleteKey(HKEY hKey, LPCSTR lpSubKey)
{
    LONG    lResult;
    HKEY    hkSubKey;
    DWORD   dwIndex;
    char    szSubKeyName[MAX_PATH + 1];
    DWORD   cchSubKeyName = ARRAYSIZE(szSubKeyName);
    char    szClass[MAX_PATH];
    DWORD   cbClass = ARRAYSIZE(szClass);
    DWORD   dwDummy1, dwDummy2, dwDummy3, dwDummy4, dwDummy5, dwDummy6;
    FILETIME ft;

    // Open the subkey so we can enumerate any children
    lResult = RegOpenKeyExA(hKey, lpSubKey, 0, KEY_ALL_ACCESS, &hkSubKey);
    if (ERROR_SUCCESS == lResult)
    {
    // I can't just call RegEnumKey with an ever-increasing index, because
    // I'm deleting the subkeys as I go, which alters the indices of the
    // remaining subkeys in an implementation-dependent way.  In order to
    // be safe, I have to count backwards while deleting the subkeys.

    // Find out how many subkeys there are
    lResult = RegQueryInfoKey(hkSubKey, 
                  szClass, 
                  &cbClass, 
                  NULL, 
                  &dwIndex, // The # of subkeys -- all we need
                  &dwDummy1,
                  &dwDummy2,
                  &dwDummy3,
                  &dwDummy4,
                  &dwDummy5,
                  &dwDummy6,
                  &ft);

    if (ERROR_SUCCESS == lResult)
    {
        // dwIndex is now the count of subkeys, but it needs to be 
        // zero-based for RegEnumKey, so I'll pre-decrement, rather
        // than post-decrement.
        while (ERROR_SUCCESS == RegEnumKey(hkSubKey, --dwIndex, szSubKeyName, cchSubKeyName))
        {
        ShRegDeleteKey(hkSubKey, szSubKeyName);
        }
    }

// APPCOMPAT
// Issue with shellprv.  For some reason someone commented out the definition of SHRegCloseKey
// SHRegCloseKey is not in Win95.  Doing an undef here puts it back to RegCloseKey
// Works now on both NT and Win95
//
#undef  RegCloseKey
    RegCloseKey(hkSubKey);

    lResult = RegDeleteKey(hKey, lpSubKey);
    }
    
    return lResult;
}


LONG lRegDeleteKeyA(HKEY hKey, LPCSTR lpSubKey)
{
    if (RUNNING_NT)
        return(ShRegDeleteKey(hKey, lpSubKey));
    else
        return(RegDeleteKey(hKey, lpSubKey));
}

// in:
//      pszPath         directory to do this into or full dest path
//                      if pszShort is NULL
//      pszShort        file name (short version) if NULL assumes
//                      pszPath is both path and spec
//      pszFileSpec     file name (long version)
//
// out:
//      pszUniqueName
//
// returns:
//      TRUE    success, name can be used

BOOL lPathYetAnotherMakeUniqueNameA(LPSTR  pszUniqueName,
                 LPCSTR pszPath,
                 LPCSTR pszShort,
                 LPCSTR pszFileSpec)
{
    if (RUNNING_NT)
    {
        LPSTR lpPath,lpShort,lpFileSpec;
        WCHAR tmpBuf[MAX_PATH];
        WCHAR tmpPath[MAX_PATH];
        WCHAR tmpShort[MAX_PATH];
        WCHAR tmpFileSpec[MAX_PATH];
        BOOL retVal;

        if((lpPath = (LPSTR)pszPath)!= NULL)
        {
            lpPath = (LPSTR)tmpPath;
            MultiByteToWideChar(CP_ACP, 0, pszPath, -1, (LPWSTR)lpPath,
                ARRAYSIZE(tmpPath));
        }

        if((lpShort = (LPSTR)pszShort)!= NULL)
        {
            lpShort = (LPSTR)tmpShort;
            MultiByteToWideChar(CP_ACP, 0, pszShort, -1, (LPWSTR)lpShort,
                ARRAYSIZE(tmpShort));
        }

        if((lpFileSpec = (LPSTR)pszFileSpec)!= NULL)
        {
            lpFileSpec = (LPSTR)tmpFileSpec;
            MultiByteToWideChar(CP_ACP, 0, pszFileSpec, -1, (LPWSTR)lpFileSpec,
                ARRAYSIZE(tmpFileSpec));
        }

        MultiByteToWideChar(CP_ACP, 0, pszUniqueName, -1, tmpBuf,
            ARRAYSIZE(tmpBuf));

        retVal = PathYetAnotherMakeUniqueName(tmpBuf, (LPWSTR)lpPath, 
                                            (LPWSTR)lpShort, (LPWSTR)lpFileSpec);  // (LPWSTR) so it builds, but works downlevel
        if(retVal)
            WideCharToMultiByte(CP_ACP, 0, tmpBuf, -1, 
                pszUniqueName, ARRAYSIZE(tmpBuf), 
                NULL, NULL);
        return(retVal);
    }
    else
        return(PathYetAnotherMakeUniqueName((LPWSTR)pszUniqueName, (LPWSTR)pszPath, 
                                            (LPWSTR)pszShort, (LPWSTR)pszFileSpec));  // (LPWSTR) so it builds, but works downlevel
}

////////////////////////////////////////////////////////////////
//
// in:
//      pszIconPath     file to get icon from (eg. cabinet.exe)
//      iIconIndex      icon index in pszIconPath to get
//      uIconFlags      GIL_ values indicating simulate doc icon, etc.

int lShell_GetCachedImageIndexA(LPCSTR pszIconPath, int iIconIndex, UINT uIconFlags)
{
    if (RUNNING_NT)
    {
        WCHAR uPath[MAX_PATH];

        MultiByteToWideChar(CP_ACP, 0, pszIconPath, -1, uPath,
            ARRAYSIZE(uPath));

        return Shell_GetCachedImageIndex(uPath, iIconIndex, uIconFlags);
    }
    else
        return Shell_GetCachedImageIndex((LPWSTR)pszIconPath, iIconIndex, uIconFlags);  // (LPWSTR) so it builds, but works downlevel
}


// determine if a path is a program by looking at the extension
//
BOOL lPathIsExeA(LPCSTR szFile)
{
    if (RUNNING_NT)
    {
        WCHAR uPath[MAX_PATH];

        MultiByteToWideChar(CP_ACP, 0, szFile, -1, uPath,
            ARRAYSIZE(uPath));

        return (PathIsExe(uPath));
    }
    else
        return PathIsExe((LPWSTR)szFile);  // (LPWSTR) so it builds, but works downlevel
}

/*
 * BUILDBUILD: Replacements for shell32.dll critical section functions for
 * shell32.dll!hash.c.
 */

void Shell_EnterCriticalSection(void)
{
    BeginExclusiveAccess();

    return;
}

void Shell_LeaveCriticalSection(void)
{
    EndExclusiveAccess();

    return;
}

#define DATA_SEG_READ_ONLY       ".text"

#pragma data_seg(DATA_SEG_READ_ONLY)

/*
 * They meant to use const char arrays here, rather than char
 * const arrays.  Arrays are implicitly const.  But this is how these array are
 * declared in shell32.dll!cstrings.h.
 */

char const c_szPercentOne[]         = "%1";
char const c_szPercentl[]           = "%l";
char const c_szPercentL[]           = "%L";
char const c_szRunDll[]             = "rundll32.exe";
char const c_szShellOpenCmd[]       = "shell\\open\\command";
char const c_szShellOpenDDEExec[]   = "shell\\open\\ddeexec";
char const c_szSlashCommand[]       = "\\command";
char const c_szSlashDDEExec[]       = "\\ddeexec";
char const c_szStar[]               = "*";

#pragma data_seg()

char g_szFileTypeName[32] = " ";  // First char is blank such that can append...

/* BUILDBUILD: LVUtil_GetLParam() swiped from shell32.dll!lvutil.c. */

//
// Note that it returns NULL, if iItem is -1.
//
LPARAM PASCAL LVUtil_GetLParam(HWND hwndLV, int i)
{
    LV_ITEM item;

    item.mask = LVIF_PARAM;
    item.iItem = i;
    item.iSubItem = 0;
    item.lParam = 0;
    if (i != -1)
    {
    ListView_GetItem(hwndLV, &item);
    }

    return item.lParam;
}

/* BUILDBUILD: App_IsLFNAware() swiped from shell32.dll!shlexec.c. */

//----------------------------------------------------------------------------
#define PEMAGIC         ((WORD)'P'+((WORD)'E'<<8))
#if 0
/* BUILDBUILD: NEMAGIC is defined in newexe.h, #included for GetExeType(). */
#define NEMAGIC         ((WORD)'N'+((WORD)'E'<<8))
#endif
//----------------------------------------------------------------------------
// Returns TRUE is app is LFN aware.
// NB This simply assumes all Win4.0 and all Win32 apps are LFN aware.
BOOL App_IsLFNAware(LPCSTR pszFile)
{
    DWORD dw;

    ASSERT(pszFile);
    ASSERT(*pszFile);

    // Assume Win 4.0 apps and Win32 apps are LFN aware.
    dw = GetExeType(pszFile);
    // DebugMsg(DM_TRACE, "s.aila: %s %s %x", lpszFile, szFile, dw);
    if ((LOWORD(dw) == PEMAGIC) || ((LOWORD(dw) == NEMAGIC) && (HIWORD(dw) >= 0x0400)))
    {
    return TRUE;
    }
    else
    {
    return FALSE;
    }
}

/* BUILDBUILD: SendMessageD() swiped from shell32.dll!init.c. */

#ifdef DEBUG
LRESULT
WINAPI
SendMessageD(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam)
{
    ASSERTNONCRITICAL;
    return SendMessageA(hWnd, Msg, wParam, lParam);
}
#endif // DEBUG

/* BUILDBUILD: HasExtension() swiped from shell32.dll!extract.c. */

DWORD HasExtension(LPCSTR pszPath)
{
    LPCSTR p = PathFindExtension(pszPath);

    if (*p == '.')
        return *((UNALIGNED DWORD *)p) | 0x20202000;  // make lower case
    else
        return 0;
}

/* BUILDBUILD: GetExeType() swiped from shell32.dll!extract.c. */

/****************************************************************************
 * GetExeType   - get the EXE type of the passed file (DOS, Win16, Win32)
 *
 *  returns:
 *      0 = not a exe of any type.
 *
 *      if a windows app
 *          LOWORD = NE or PE
 *          HIWORD = windows version 3.0, 3.5, 4.0
 *
 *      if a DOS app (or a .com or batch file)
 *          LOWORD = MZ
 *          HIWORD = 0
 *
 *      if a Win32 console app
 *          LOWORD = PE
 *          HIWORD = 0
 *
 *  APPCOMPAT this is so similar to the Win32 API GetBinaryType() too bad Win95
 *  kernel does not support it.
 *
 ****************************************************************************/

DWORD WINAPI GetExeType(LPCSTR szFile)
{
    HANDLE      fh;
    DWORD       dw;
    struct exe_hdr exehdr;
    struct new_exe newexe;
    FILETIME ftAccess;
    DWORD dwRead;

    //
    //  check for special extensions, and fail quick
    //
    switch (HasExtension(szFile))
    {
    case COM_FILE:
    case BAT_FILE:
        return MAKELONG(MZMAGIC, 0);  // DOS exe

    case EXE_FILE:                   // we need to open it.
        break;

    default:
        return 0;                    // not a exe, or if it is we dont care
    }

    newexe.ne_expver = 0;

    fh = CreateFile(szFile, GENERIC_READ | FILE_WRITE_ATTRIBUTES,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        0, OPEN_EXISTING, 0, 0);

    if (fh == INVALID_HANDLE_VALUE)
    {
    return 0;
    }

    // preserve the access time

    if (GetFileTime(fh, NULL, &ftAccess, NULL))
    SetFileTime(fh, NULL, &ftAccess, NULL);

    if (!ReadFile(fh, &exehdr, sizeof(exehdr), &dwRead, NULL) ||
        (dwRead != sizeof(exehdr)))
    goto error;

    if (exehdr.e_magic != EMAGIC)
        goto error;

    SetFilePointer(fh, exehdr.e_lfanew, NULL, FILE_BEGIN);
    ReadFile(fh,&newexe, sizeof(newexe), &dwRead, NULL);

    if (newexe.ne_magic == PEMAGIC)
    {
    // read the SubsystemVersion
    SetFilePointer(fh, exehdr.e_lfanew+18*4, NULL, FILE_BEGIN);
    ReadFile(fh,&dw,4, &dwRead, NULL);
    newexe.ne_expver = LOBYTE(LOWORD(dw)) << 8 | LOBYTE(HIWORD(dw));

    // read the Subsystem
    SetFilePointer(fh, exehdr.e_lfanew+23*4, NULL, FILE_BEGIN);
    ReadFile(fh,&dw,4, &dwRead, NULL);

    // if it is not a Win32 GUI app return a version of 0
    if (LOWORD(dw) != 2) // IMAGE_SUBSYSTEM_WINDOWS_GUI
        newexe.ne_expver = 0;

    goto exit;
    }
    else if (newexe.ne_magic == LEMAGIC)
    {
    newexe.ne_magic = MZMAGIC;      // just a DOS exe
    newexe.ne_expver = 0;
    }
    else if (newexe.ne_magic == NEMAGIC)
    {
    //
    //  we found a 'NE' it still might not be a windows
    //  app, it could be.....
    //
    //      a OS/2 app      ne_exetyp==NE_OS2
    //      a DOS4 app      ne_exetyp==NE_DOS4
    //      a VxD           ne_exetyp==DEV386
    //
    //      only treat it as a Windows app if the exetype
    //      is NE_WINDOWS or NE_UNKNOWN
    //
    if (newexe.ne_exetyp != NE_WINDOWS && newexe.ne_exetyp != NE_UNKNOWN)
    {
        newexe.ne_magic = MZMAGIC;      // just a DOS exe
        newexe.ne_expver = 0;
    }

    //
    //  if could also have a bogus expected windows version
    //  (treat 0 as invalid)
    //
    if (newexe.ne_expver == 0)
    {
        newexe.ne_magic = MZMAGIC;      // just a DOS exe
        newexe.ne_expver = 0;
    }
    }
    else // if (newexe.ne_magic != NEMAGIC)
    {
    newexe.ne_magic = MZMAGIC;      // just a DOS exe
    newexe.ne_expver = 0;
    }

exit:
    CloseHandle(fh);
    return MAKELONG(newexe.ne_magic, newexe.ne_expver);

error:
    CloseHandle(fh);
    return 0;
}

/******************************************************************************
             Original Shell32.dll code starts here.
******************************************************************************/

#if 0

/* BUILDBUILD: Remove old headers. */

#include "..\..\inc\help.h"
#include "views.h"
#include "ids.h"
#include "lvutil.h"

#endif

// REARCHITECT: duplicate strings as in cstrings.c
#pragma data_seg(".text", "CODE")
char const c_szSSlashS[] = "%s\\%s";
#pragma data_seg()

extern char g_szFileTypeName[];     // used to build type name...
extern BOOL App_IsLFNAware(LPCSTR pszFile);

void _GenerateAssociateNotify(LPSTR pszExt)
{
    char szFakePath[MAX_PATH];
    LPITEMIDLIST pidl;
    //
    // This is a real hack, but for now we generate an idlist that looks
    // something like: C:\*.ext which is the extension for the IDList.
    // We use the simple IDList as to not hit the disk...
    //
    // All I do is make an ANSI string, and then jam the unicode
    // version into the skinny-char buffer. Saves on stack.
    if (RUNNING_NT)
    {
        char tmpBuf[20];

        lstrcpy(tmpBuf, "c:\\");
        lstrcat(tmpBuf, c_szStar);
        lstrcat(tmpBuf, pszExt);
        MultiByteToWideChar(CP_ACP, 0, tmpBuf, -1, (LPWSTR)szFakePath, 
            sizeof(szFakePath)/sizeof(WCHAR));
    }
    else
    {
        PathBuildRoot(szFakePath, 2);   // (c:\)
        lstrcat(szFakePath, c_szStar);
        lstrcat(szFakePath, pszExt);
    }
    pidl = SHSimpleIDListFromPath((LPWSTR)szFakePath);  // (LPWSTR) so it builds, but works downlevel

    // Now call off to the notify function.
    SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, pidl, NULL);
    ILFree(pidl);
}

// Given a class key returns the shell\open\command string in szValue
// and the number of chars copied in cbMaxValue. cbMaxValue should
// be initialised to the max siz eof szValue.
void GetCmdLine(LPCSTR szKey, LPSTR szValue, LONG cbValue)
{
    char szTemp[MAX_PATH+40];   // Leave room for both extension plus junk on at end...

    wsprintf(szTemp, c_szSSlashS, szKey, c_szShellOpenCmd);

    szValue[0] = 0;
    RegQueryValue(HKEY_CLASSES_ROOT, szTemp, szValue, &cbValue);
}

// uFlags GCD_ flags from GetClassDescription uFlags

void FillListWithClasses(HWND hwnd, BOOL fComboBox, UINT uFlags)
{
    int i;
    char szClass[CCH_KEYMAX];
    char szDisplayName[CCH_KEYMAX];
    LONG lcb;

    SendMessage(hwnd, fComboBox ? CB_RESETCONTENT : LB_RESETCONTENT, 0, 0L);

    if (uFlags & GCD_MUSTHAVEEXTASSOC)
    {
    char szExt[CCH_KEYMAX];

    // The caller stated that they only want those classes that
    // have have at least one extension associated with it.
    //
    for (i = 0; RegEnumKey(HKEY_CLASSES_ROOT, i, szClass, sizeof(szClass)) == ERROR_SUCCESS; i++)
    {
        // Is this an extension
        if (szClass[0] != '.')
        continue;   // go process the next one...

        // Get the class name
        lstrcpy(szExt, szClass);
        lcb = sizeof(szClass);
        if ((RegQueryValue(HKEY_CLASSES_ROOT, szExt, szClass, &lcb) != ERROR_SUCCESS) || (lcb == 0))
        continue;   // Again we are not interested.

        // use uFlags passed in to filter
        if (GetClassDescription(HKEY_CLASSES_ROOT, szClass, szDisplayName, sizeof(szDisplayName), uFlags))
        {
        int iItem;

        // Now make sure it is not already in the list...
        if ((int)SendMessage(hwnd, fComboBox ? CB_FINDSTRINGEXACT : LB_FINDSTRINGEXACT,
                     (WPARAM)-1, (LPARAM)(LPSTR)szDisplayName) >= 0)
            continue;       // allready in the list.

        // sorted
        iItem = (int)SendMessage(hwnd, fComboBox ? CB_ADDSTRING : LB_ADDSTRING,
                     0, (LPARAM)(LPSTR)szDisplayName);

        if (iItem >= 0)
            SendMessage(hwnd, fComboBox ? CB_SETITEMDATA : LB_SETITEMDATA, iItem, (LPARAM)AddHashItem(NULL, szClass));

        }
    }


    }
    else
    {
    for (i = 0; RegEnumKey(HKEY_CLASSES_ROOT, i, szClass, sizeof(szClass)) == ERROR_SUCCESS; i++)
    {
        // use uFlags passed in to filter
        if (GetClassDescription(HKEY_CLASSES_ROOT, szClass, szDisplayName, sizeof(szDisplayName), uFlags))
        {
        // sorted
        int iItem = (int)SendMessage(hwnd, fComboBox ? CB_ADDSTRING : LB_ADDSTRING,
                         0, (LPARAM)(LPSTR)szDisplayName);

        if (iItem >= 0)
            SendMessage(hwnd, fComboBox ? CB_SETITEMDATA : LB_SETITEMDATA, iItem, (LPARAM)AddHashItem(NULL, szClass));

        }
    }
    }
}

// get the displayable name for file types "classes"
//
//
// uFlags:
//     GCD_MUSTHAVEOPENCMD  only returns things with open verbs
//     GCD_ADDEXETODISPNAME append the name of the ext that is in the open cmd
//              (GCD_MUSTHAVEOPENCMD)
//     GCD_ALLOWPSUDEOCLASSES   return psudeo classes, those with stuff haning
//              off the .ext key

BOOL GetClassDescription(HKEY hkClasses, LPCSTR pszClass, LPSTR szDisplayName, int cbDisplayName, UINT uFlags)
{
    char szExe[MAX_PATH];
    char szClass[CCH_KEYMAX];
    LPSTR pszExeFile;
    LONG lcb;

    // Skip things that aren't classes (extensions).

    if (pszClass[0] == '.')
    {
    if (uFlags & GCD_ALLOWPSUDEOCLASSES)
    {
    lcb = sizeof(szClass);
        if ((RegQueryValue(hkClasses, pszClass, szClass, &lcb) != ERROR_SUCCESS) || (lcb == 0))
    {
        // look for .ext\shel\open\command directly (hard wired association)
        // if this extenstion does not name a real class

        GetCmdLine(pszClass, szExe, sizeof(szExe));
        if (szExe[0]) {
        lstrcpyn(szDisplayName, PathFindFileName(szExe), cbDisplayName);
        return TRUE;
        }

        return FALSE;
    }
    pszClass = szClass;
    }
    else
    {
    return FALSE;   // don't return psudeo class
    }
    }

    // REVIEW: we should really special case the OLE junk here.  if pszClass is
    // CLSID, Interface, TypeLib, etc we should skip it

    // REVIEW: we really need to verify that some extension points at this type to verfy
    // that it is valid.  perhaps the existance of a "shell" key is enough.

    // get the classes displayable name
    lcb = cbDisplayName;
    if (RegQueryValue(hkClasses, pszClass, szDisplayName, &lcb) != ERROR_SUCCESS || (lcb < 2))
    return FALSE;

    if (uFlags & GCD_MUSTHAVEOPENCMD)
    {
    // verify that it has an open command
    GetCmdLine(pszClass, szExe, sizeof(szExe));
    if (!szExe[0])
    return FALSE;

    // WARNING: currently this is dead functionallity
    if (uFlags & GCD_ADDEXETODISPNAME)
    {
        PathRemoveArgs(szExe);

        // eliminate per instance type things (programs, pif, etc)
        // Skip things that aren't relevant ot the shell.
        if (szExe[0] == '%')
        return FALSE;

        // skip things with per-instance type associations
        pszExeFile = PathFindFileName(szExe);

        if (lstrlen(szDisplayName) + lstrlen(pszExeFile) + 2 < cbDisplayName)
        {
#pragma data_seg(".text", "CODE")
        wsprintf(szDisplayName + lstrlen(szDisplayName), " (%s)", pszExeFile);
#pragma data_seg()
        }
    }
    }
    return TRUE;
}

void DeleteListAttoms(HWND hwnd, BOOL fComboBox)
{
    int cItems;
    PHASHITEM phiClass;
    int iGetDataMsg;

    iGetDataMsg = fComboBox ? CB_GETITEMDATA : LB_GETITEMDATA;

    cItems = (int)SendMessage(hwnd, fComboBox ? CB_GETCOUNT : LB_GETCOUNT, 0, 0) - 1;

    /* clean out them atoms except for "(none)".
     */
    for (; cItems >= 0; cItems--)
    {
    phiClass = (PHASHITEM)SendMessage(hwnd, iGetDataMsg, cItems, 0L);
    if (phiClass != (PHASHITEM)LB_ERR && phiClass)
    DeleteHashItem(NULL, phiClass);
    }
}

// BEGIN new stuff

typedef struct {    // oad
    // params
    HWND hwnd;
    POPENASINFO poainfo;
    // local data
    int idDlg;
    HWND hDlg;
    HWND hwndList;
    LPSTR lpszExt;
    LPCSTR lpcszClass;
    HRESULT hr;
    char szTypeName[CCH_KEYMAX]; // type name
    char szDescription[CCH_KEYMAX]; // type description
} OPENAS_DATA, *POPENAS_DATA;

typedef struct {
    UINT bHasQuote;             // Did we find a quote around param? "%1"
    char szApp[MAX_PATH+2];     // May need room for quotes
} APPINFO;

#define HASQUOTE_NO     0
#define HASQUOTE_MAYBE  1
#define HASQUOTE_YES    3

BOOL QuotesAroundArg(PCSTR pcszCmdLine)
{
    BOOL bQuotes = FALSE;
    PCSTR pcsz;

    /* Is there a %1, %l, or %L on the command line? */

    if ((pcsz = StrStr(pcszCmdLine, c_szPercentOne)) != NULL ||
    (pcsz = StrStr(pcszCmdLine, c_szPercentl))   != NULL ||
    (pcsz = StrStr(pcszCmdLine, c_szPercentL))   != NULL)
    {
    /* Yes.  Is it preceded by double quotes? */

    if (*(pcsz - 1) == '"')
        /* Yes. */
        bQuotes = TRUE;
    }

    return(bQuotes);
}

void FillListWithApps(HWND hwndList)
{
    int i, iMax;
    char szClass[CCH_KEYMAX];
    char szKey[CCH_KEYMAX];
    char szValue[MAX_PATH];
    APPINFO *paiLast;
    LV_ITEM item;
    int iLast;
    BOOL fLastExists = FALSE;

    for (i = 0; RegEnumKey(HKEY_CLASSES_ROOT, i, szClass, sizeof(szClass)) == ERROR_SUCCESS; i++)
    {
    LONG lTmp;

    wsprintf(szKey, c_szSSlashS, szClass, c_szShellOpenCmd);
    lTmp = sizeof(szValue);
    if (RegQueryValue(HKEY_CLASSES_ROOT, szKey, szValue, &lTmp) == ERROR_SUCCESS)
    {
    // filter out stuff we know is bogus
    // strings that start with: %1, "%1"
    // strings that contain: rundll
    //

        if ((szValue[0] != '%') &&
        ((szValue[0] != '"') || (szValue[1] != '%')) &&
        (StrStr(szValue, c_szRunDll) == NULL))
        {
        APPINFO *pai = (APPINFO *)LocalAlloc(LPTR, sizeof(APPINFO));
        if (pai)
        {
            if (QuotesAroundArg(szValue))
            pai->bHasQuote = HASQUOTE_YES;
            else
            {
            char szDDEExecValue[MAX_PATH];

            wsprintf(szKey, c_szSSlashS, szClass,
                 c_szShellOpenDDEExec);
            lTmp = sizeof(szDDEExecValue);
            if (RegQueryValue(HKEY_CLASSES_ROOT, szKey,
                      szDDEExecValue, &lTmp)
                == ERROR_SUCCESS)
            {
                if (QuotesAroundArg(szDDEExecValue))
                pai->bHasQuote = HASQUOTE_YES;
            }
            }

            PathRemoveArgs(szValue);
            lstrcpy(pai->szApp, szValue);

            item.mask = LVIF_TEXT|LVIF_IMAGE|LVIF_PARAM;
            item.iItem = 0x7FFF;
            item.iSubItem = 0;
            item.state = 0;
            item.iImage = I_IMAGECALLBACK;
            PathRemoveExtension(szValue);
            item.pszText = PathFindFileName(szValue);
            item.lParam = (LPARAM)pai;
            ListView_InsertItem(hwndList, &item);
        }
        }
    }
    }

    // punt dups
    ListView_SortItems(hwndList, NULL, 0);
    paiLast = NULL;

    // szKey will hold the lpszLast's display name
    for (i = 0, iMax = ListView_GetItemCount(hwndList); i < iMax; i++)
    {
    APPINFO *pai;

    item.mask = LVIF_TEXT | LVIF_PARAM;
    item.iItem = i;
    item.iSubItem = 0;
    item.pszText = szValue;
    item.cchTextMax = sizeof(szValue);
    // get the text string
    ListView_GetItem(hwndList, &item);
    pai = (APPINFO *)item.lParam;

    if (paiLast && (!lstrcmpi(szKey, szValue))) {
        int iDelete = i;

        // if they are different in path, delete the one that doesn't exit (or the new one if they both do)
        if (lstrcmpi(paiLast->szApp, pai->szApp)) {
        if (!fLastExists && !(fLastExists = PathFileExists(pai->szApp))) {
            if (paiLast->bHasQuote > pai->bHasQuote)
            pai->bHasQuote = paiLast->bHasQuote;
            iDelete = iLast;
        }
        }

        // Will assume that if either item has quote set that it will work...
        if (pai->bHasQuote > paiLast->bHasQuote)
        paiLast->bHasQuote =pai->bHasQuote;

        ListView_DeleteItem(hwndList, iDelete);
        i--; iMax--;

        // we deleted the iLast, we need to set a new iLast
        if (iDelete == iLast)
        goto NewLastExe;

    } else {

NewLastExe:
        iLast = i;

        paiLast = pai;
        lstrcpy(szKey, szValue);
        fLastExists = TRUE;
    }
    }

    // Lets set the focus to first item, but not the focus as some users
    // have made the mistake and type in the name and hit return and it
    // runs the first guy in the list which in the current cases tries to
    // run the backup app...
    ListView_SetItemState(hwndList, 0, LVNI_FOCUSED, LVNI_FOCUSED | LVNI_SELECTED);
    SetFocus(hwndList);
}

void _InitOpenAsDlg(POPENAS_DATA poad)
{
    char szFormat[200];
    char szFileName[MAX_PATH];
    char szTemp[MAX_PATH + sizeof(szFormat)];
    BOOL fDisableAssociate;
    HIMAGELIST himlLarge = NULL;
    HIMAGELIST himlSmall = NULL;
    LV_COLUMN col = {LVCF_FMT | LVCF_WIDTH, LVCFMT_LEFT};
    RECT rc;

    // Don't let the file name go beyond the width of one line...
    GetDlgItemText(poad->hDlg, IDD_TEXT, szFormat, sizeof(szFormat));
    lstrcpy(szFileName, PathFindFileName(poad->poainfo->pcszFile));
    GetClientRect(GetDlgItem(poad->hDlg, IDD_TEXT), &rc);

    PathCompactPath(NULL, szFileName, rc.right - 4 * GetSystemMetrics(SM_CXBORDER));

    wsprintf(szTemp, szFormat, szFileName);
    SetDlgItemText(poad->hDlg, IDD_TEXT, szTemp);

    // Don't allow associations to be made for things we consider exes...
    fDisableAssociate = (! (poad->poainfo->dwInFlags & OPENASINFO_FL_ALLOW_REGISTRATION) ||
             lPathIsExeA(poad->poainfo->pcszFile));

    if (poad->idDlg == DLG_OPENAS_NOTYPE) {
    GetDlgItemText(poad->hDlg, IDD_DESCRIPTIONTEXT, szFormat, sizeof(szFormat));
    wsprintf(szTemp, szFormat, poad->lpcszClass);
    SetDlgItemText(poad->hDlg, IDD_DESCRIPTIONTEXT, szTemp);

    // Default to Set the association here if we do not know what
    // the file is...
    if (!fDisableAssociate)
        CheckDlgButton(poad->hDlg, IDD_MAKEASSOC, TRUE);
    }

    if (fDisableAssociate)
    EnableWindow(GetDlgItem(poad->hDlg, IDD_MAKEASSOC), FALSE);

    poad->hwndList = GetDlgItem(poad->hDlg, IDD_APPLIST);
    Shell_GetImageLists(&himlLarge, &himlSmall);
    if(himlLarge != NULL)
        ListView_SetImageList(poad->hwndList, himlLarge, LVSIL_NORMAL);
    if(himlSmall != NULL)
        ListView_SetImageList(poad->hwndList, himlSmall, LVSIL_SMALL);
    SetWindowLong(poad->hwndList, GWL_EXSTYLE,
        GetWindowLong(poad->hwndList, GWL_EXSTYLE) | WS_EX_CLIENTEDGE);

    GetClientRect(poad->hwndList, &rc);
    col.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL)
        - 4 * GetSystemMetrics(SM_CXEDGE);
    ListView_InsertColumn(poad->hwndList, 0, &col);
    FillListWithApps(poad->hwndList);

    // and initialize the OK button
    EnableWindow(GetDlgItem(poad->hDlg, IDOK),
        (ListView_GetNextItem(poad->hwndList, -1, LVNI_SELECTED) != -1));
}

void RunAs(POPENAS_DATA poad)
{
    SHELLEXECUTEINFO ExecInfo;

    // If this run created a new type we should use it, otherwise we should
    // construct a command using the exe that we selected...
    if (*poad->lpszExt && IsDlgButtonChecked(poad->hDlg, IDD_MAKEASSOC))
    {
    FillExecInfo(ExecInfo, poad->hwnd, NULL, poad->poainfo->pcszFile, NULL, NULL, SW_NORMAL);
    }
    else
    {
    char szApp[MAX_PATH];
    char szQuotedFile[MAX_PATH+2];
    APPINFO *pai;
    int iItemFocus = ListView_GetNextItem(poad->hwndList, -1, LVNI_SELECTED);
    pai = (APPINFO *)LVUtil_GetLParam(poad->hwndList, iItemFocus);
    lstrcpy(szQuotedFile, poad->poainfo->pcszFile);

    lstrcpy(szApp, pai->szApp);
    PathUnquoteSpaces(szApp);

    // Try to intellegently quote blanks or not...
    if (!App_IsLFNAware(szApp))
    {
        // We better also make sure that this a short path name
        // pass off to the application...
        char tmpBuf[MAX_PATH];

        GetShortPathName(szQuotedFile, tmpBuf, SIZECHARS(tmpBuf));
        lstrcpy(szQuotedFile, tmpBuf);
    }
    else
    {
        // Either maybe or yes is we should quote
        if (pai->bHasQuote)
        PathQuoteSpaces(szQuotedFile);
    }

    FillExecInfo(ExecInfo, poad->hwnd, NULL, szApp, szQuotedFile, NULL, SW_NORMAL);
    }
    ShellExecuteEx(&ExecInfo);
}

void OpenAsOther(POPENAS_DATA poad)
{
    char szText[MAX_PATH];
    BOOL retval;

#if 0
    /*
     * BUILDBUILD: There is no IDD_COMMAND control in DLG_OPENAS or
     * DLG_OPENAS_NOTYPE.
     */
    GetDlgItemText(poad->hDlg, IDD_COMMAND, szText, sizeof(szText));
#else
    *szText = '\0\0';
#endif
    // now it will work on NT: unicode 
    // do a file open browse
    if (RUNNING_NT)
    {
        WCHAR szuPath[MAX_PATH];
        WCHAR szuExe[16];
        WCHAR szuFilters[MAX_PATH];
        WCHAR szuTitle[80];
        LPWSTR psz;

        szuPath[0] = szuTitle[0] = szuExe[0] = szuFilters[0]= 0;
        MLLoadStringW(IDS_OPENAS, szuTitle, 80);
        MLLoadStringW(IDS_EXE, szuExe, 16);
        MLLoadStringW(IDS_PROGRAMSFILTER, szuFilters, MAX_PATH);

        /* hack up the array... */ 
        psz = szuFilters;
        while (*psz)
        {
            if (*psz == (WCHAR)('#'))
                *psz = (WCHAR)('\0');
            psz++;
        }

        retval = GetFileNameFromBrowse(poad->hDlg, szuPath, 
                        ARRAYSIZE(szuPath), NULL, szuExe, 
                        szuFilters, szuTitle);
        /* make certain we convert back to ANSI chars! */
        if (retval)
            WideCharToMultiByte(CP_ACP,0,szuPath,-1,szText,
                ARRAYSIZE(szuPath),NULL,NULL);
    }
    else
    {
        CHAR szExe[16];
        CHAR szFilters[MAX_PATH];
        CHAR szTitle[80];
        LPSTR psz;

        szTitle[0] = szExe[0] = szFilters[0]= 0;
        MLLoadStringA(IDS_OPENAS, szTitle, 80);
        MLLoadStringA(IDS_EXE, szExe, 16);
        MLLoadStringA(IDS_PROGRAMSFILTER, szFilters, MAX_PATH);

        /* hack up the array... */ 
        psz = szFilters;
        while (*psz)
        {
            if (*psz == (CHAR)('#'))
                *psz = (CHAR)('\0');
            psz++;
        }

        retval = GetFileNameFromBrowse(poad->hDlg, (LPWSTR)szText, 
                    sizeof(szText), NULL,
                    (LPWSTR)szExe, (LPWSTR)szFilters, (LPWSTR)szTitle);  // (LPWSTR) so it builds, but works downlevel
    }
    if (retval)
    {
    // then add it to the list view and select it.
    APPINFO *pai = (APPINFO *)LocalAlloc(LPTR, sizeof(APPINFO));
    if (pai)
    {
        LV_ITEM item;
        int i;
        int iItem;
        APPINFO *paiT;


        pai->bHasQuote = HASQUOTE_MAYBE;
        lstrcpy(pai->szApp, szText);
        PathQuoteSpaces(pai->szApp);

        item.mask = LVIF_TEXT|LVIF_IMAGE|LVIF_PARAM;
        item.iItem = 0x7FFF;
        item.iSubItem = 0;
        item.state = 0;
        item.iImage = I_IMAGECALLBACK;
        PathRemoveExtension(szText);
        item.pszText = PathFindFileName(szText);
        item.lParam = (LPARAM)pai;
        i = ListView_InsertItem(poad->hwndList, &item);
        ListView_SetItemState(poad->hwndList, i, LVNI_SELECTED | LVNI_FOCUSED, LVNI_SELECTED | LVNI_FOCUSED);
        ListView_EnsureVisible(poad->hwndList, i, FALSE);
        SetFocus(poad->hwndList);

        // We also want to see if we find another entry in the listview for the
        // application.  We do this such that we can see if the app supports
        // quotes or not.
        for (iItem = ListView_GetItemCount(poad->hwndList) - 1; iItem >= 0; iItem--)
        {
        if (iItem == i)
            continue;
        item.mask = LVIF_PARAM;
        item.iItem = iItem;
        item.iSubItem = 0;
        ListView_GetItem(poad->hwndList, &item);
        paiT = (APPINFO *)item.lParam;
        if (lstrcmpi(pai->szApp, paiT->szApp) == 0)
        {
            pai->bHasQuote = paiT->bHasQuote;
            break;
        }
        }
    }
    }
}

// return true if ok to continue
BOOL OpenAsMakeAssociation(POPENAS_DATA poad)
{
    UINT err;

    // See if we should make an association or not...
    if (!IsDlgButtonChecked(poad->hDlg, IDD_MAKEASSOC))
    return(TRUE);

    if (poad->idDlg == DLG_OPENAS_NOTYPE) {
    GetDlgItemText(poad->hDlg, IDD_DESCRIPTION, poad->szDescription, sizeof poad->szDescription);
    if (*poad->szDescription == '\0') {
        // Another place to make sure Ivans tests don't catch...
        /* BUILDBUILD: Load IDS_FILETYPENAME here. */
        if (lstrlen(g_szFileTypeName) <2)
        {
            MLLoadStringA(IDS_FILETYPENAME,
                   g_szFileTypeName+1, sizeof(g_szFileTypeName)-1);
        }
        lstrcpyn(poad->szDescription, AnsiNext(poad->lpszExt),
            ARRAYSIZE(poad->szDescription) - lstrlen(g_szFileTypeName) -1);
        AnsiUpper(poad->szDescription);

        // Likewise we add a blank at start for appending for FOO Files..
        lstrcat(poad->szDescription, g_szFileTypeName);
    }

#pragma data_seg(".text", "CODE")
    lstrcpyn(poad->szTypeName, poad->lpszExt+1, sizeof(poad->szTypeName)
        - sizeof("_auto_file"));
    lstrcat(poad->szTypeName, "_auto_file");
#pragma data_seg()

    err = RegSetValueA(HKEY_CLASSES_ROOT, poad->lpszExt, REG_SZ, poad->szTypeName, 0L);
    err |= RegSetValueA(HKEY_CLASSES_ROOT, poad->szTypeName, REG_SZ, poad->szDescription, 0L);
    ASSERT(err == ERROR_SUCCESS);
    if (err != ERROR_SUCCESS)
    {
        MessageBeep(MB_ICONEXCLAMATION);
        return(FALSE);
    }
    }

    if (*poad->lpszExt) {
    char szTemp[MAX_PATH];
    char szCommand[MAX_PATH + 10];
    int iItemFocus = ListView_GetNextItem(poad->hwndList, -1, LVNI_FOCUSED);
    APPINFO *pai = (APPINFO *)LVUtil_GetLParam(poad->hwndList, iItemFocus);

#pragma data_seg(".text", "CODE")
    // We need to set the open commands value to empty to take care of cases
    // that have something like: open=&Merge
    wsprintf(szTemp, "%s\\shell\\open", poad->szTypeName);
    err = RegSetValueA(HKEY_CLASSES_ROOT, szTemp, REG_SZ, c_szNULL, 0L);
    lstrcat(szTemp, c_szSlashCommand);

    if ((pai->bHasQuote == HASQUOTE_YES) ||
        ((pai->bHasQuote == HASQUOTE_MAYBE) && App_IsLFNAware(pai->szApp)))
        wsprintf(szCommand, "%s \"%%1\"", pai->szApp);
    else
        wsprintf(szCommand, "%s %%1", pai->szApp);

    err = RegSetValueA(HKEY_CLASSES_ROOT, szTemp, REG_SZ, szCommand, 0L);
    ASSERT(err == ERROR_SUCCESS);
    if (err != ERROR_SUCCESS)
    {
        MessageBeep(MB_ICONEXCLAMATION);
        return(FALSE);
    }

    // Need to delete any ddeexec information that might also exist...
    PathRemoveFileSpec(szTemp);     // Remove the command (last component)
    lstrcat(szTemp, c_szSlashDDEExec);
    lRegDeleteKeyA(HKEY_CLASSES_ROOT, szTemp);
#pragma data_seg()
    // notify views
    _GenerateAssociateNotify(poad->lpszExt);
    }

    return TRUE;
}


#pragma data_seg(DATASEG_READONLY)
const static DWORD aOpenAsHelpIDs[] = {  // Context Help IDs
    IDD_TEXT,             IDH_FCAB_OPENAS_DESCRIPTION,
    IDD_DESCRIPTIONTEXT,  IDH_FCAB_OPENAS_DESCRIPTION,
    IDD_DESCRIPTION,      IDH_FCAB_OPENAS_DESCRIPTION,
    IDD_APPLIST,          IDH_FCAB_OPENAS_APPLIST,
    IDD_MAKEASSOC,        IDH_FCAB_OPENAS_MAKEASSOC,
    IDD_OTHER,            IDH_FCAB_OPENAS_OTHER,

    0, 0
};
#pragma data_seg()

INT_PTR CALLBACK OpenAsDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    POPENAS_DATA poad = (POPENAS_DATA)GetWindowLongPtr(hDlg, DWLP_USER);
    APPINFO *pai;
    int iItemFocus;

    switch (wMsg) {

    case WM_INITDIALOG:
    SetWindowLongPtr(hDlg, DWLP_USER, lParam);
    poad = (POPENAS_DATA)lParam;
    poad->hDlg = hDlg;
    _InitOpenAsDlg(poad);
    break;

    case WM_HELP:
    SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
        HELP_WM_HELP, (DWORD_PTR)(LPSTR) aOpenAsHelpIDs);
    break;

    case WM_CONTEXTMENU:
    if ((int)SendMessage(hDlg, WM_NCHITTEST, 0, lParam) != HTCLIENT)
        return FALSE;   // don't process it
    SHWinHelpOnDemandWrap((HWND) wParam, NULL, HELP_CONTEXTMENU,
        (DWORD_PTR)(LPVOID)aOpenAsHelpIDs);
    break;

   case WM_NOTIFY:

    switch (((LPNMHDR)lParam)->code)
    {
    case LVN_GETDISPINFO:
    {
#define pdi ((LV_DISPINFO *)lParam)
        char szApp[MAX_PATH];
        APPINFO *pai = (APPINFO *)pdi->item.lParam;
        lstrcpy(szApp, pai->szApp);
        PathUnquoteSpaces(szApp);
        pdi->item.iImage = lShell_GetCachedImageIndexA(szApp, 0, 0);
        if (pdi->item.iImage == -1)
        pdi->item.iImage = II_APPLICATION;
        break;
#undef pdi
    }

    case LVN_DELETEITEM:
        LocalFree((HLOCAL)((NM_LISTVIEW *)lParam)->lParam);
        break;

    case LVN_ITEMCHANGED:
        EnableWindow(GetDlgItem(hDlg, IDOK),
    (ListView_GetNextItem(poad->hwndList, -1, LVNI_SELECTED) != -1));
        break;

    case NM_DBLCLK:
        if (IsWindowEnabled(GetDlgItem(hDlg, IDOK)))
        PostMessage(hDlg, WM_COMMAND, GET_WM_COMMAND_MPS(IDOK, hDlg, 0));
        break;
    }
    break;

    case WM_COMMAND:
    ASSERT(poad);
    switch (GET_WM_COMMAND_ID(wParam, lParam)) {
    case IDD_OTHER:
        OpenAsOther(poad);
        break;

    case IDOK:
        /* Register association if requested. */

        // The NT URL has this commented out...
        if (//(poad->poainfo->dwInFlags & OPENASINFO_FL_REGISTER_EXT) &&
        ! OpenAsMakeAssociation(poad))
        break;

        /* Copy name of associated application. */

        iItemFocus = ListView_GetNextItem(poad->hwndList, -1, LVNI_SELECTED);
        pai = (APPINFO *)LVUtil_GetLParam(poad->hwndList, iItemFocus);
        lstrcpyn(poad->poainfo->szApp, pai->szApp, sizeof(poad->poainfo->szApp));
        PathUnquoteSpaces(poad->poainfo->szApp);

        /* Did we register the association? */

        poad->hr = IsDlgButtonChecked(poad->hDlg, IDD_MAKEASSOC) ? S_OK : S_FALSE;

        /* Exec if requested. */

        if (poad->poainfo->dwInFlags & OPENASINFO_FL_EXEC)
        {
        RunAs(poad);
        SHAddToRecentDocs(RUNNING_NT ? SHARD_PATHA : SHARD_PATH, 
                            poad->poainfo->pcszFile);
        }

        EndDialog(hDlg, TRUE);
        break;

    case IDCANCEL:
        poad->hr = E_ABORT;
        EndDialog(hDlg, FALSE);
        break;

    }
    break;

    default:
    return FALSE;
    }
    return TRUE;
}

// external API version

HRESULT MyOpenAsDialog(HWND hwnd, POPENASINFO poainfo)
{
    OPENAS_DATA oad;
    int idDlg;

    oad.hwnd = hwnd;
    oad.poainfo = poainfo;
    oad.szDescription[0] = 0;
    oad.szTypeName[0] = 0;

    TRACE_OUT(("Enter OpenAs for %s", oad.poainfo->pcszFile));

    oad.lpszExt = PathFindExtension(oad.poainfo->pcszFile);
    oad.lpcszClass = poainfo->pcszClass ? poainfo->pcszClass : oad.lpszExt;
    if (*oad.lpszExt) {
    LONG lTmp = sizeof(oad.szTypeName);

    if ((RegQueryValue(HKEY_CLASSES_ROOT, oad.lpszExt, oad.szTypeName, &lTmp) == ERROR_SUCCESS)
        && (lTmp != 0) && (*oad.szTypeName)) {
        idDlg = DLG_OPENAS;
    } else
        idDlg = DLG_OPENAS_NOTYPE;
    } else {
    idDlg = DLG_OPENAS;
    }
    oad.idDlg = idDlg;
    return((DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(idDlg), hwnd,
               OpenAsDlgProc, (LPARAM)(POPENAS_DATA)&oad) != -1)
       ? oad.hr : E_OUTOFMEMORY);
}

#if 0

/* BUILDBUILD: Not used in url.dll.  Restore if added to shell32.dll. */

void WINAPI OpenAs_RunDLL(HWND hwnd, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    OPENASINFO oainfo;

    TRACE_OUT(("OpenAs_RunDLL is called with (%s)", lpszCmdLine));

    oainfo.pcszFile = lpszCmdLine;
    oainfo.pcszClass = NULL;
    oainfo.dwInFlags = (OPENASINFO_FL_ALLOW_REGISTRATION |
            OPENASINFO_FL_REGISTER_EXT |
            OPENASINFO_FL_EXEC);

    MyOpenAsDialog(hwnd, &oainfo);
}

#ifdef DEBUG
//
// Type checking
//
static RUNDLLPROC lpfnRunDLL = OpenAs_RunDLL;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\inetcpl.h ===
/*
 * inetcpl.h - Indirect calls to inetcpl.cpl description.
 */


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Prototypes
 *************/

/* inetcpl.c */
#define ExitInternetCPLModule() UnloadInternetCPL()
	
extern PULONG GetInternetCPLRefCountPtr(void);
extern HRESULT InternetCPLCanUnloadNow(void);
extern void UnloadInternetCPL(void);
extern BOOL InitInternetCPLModule(void);
extern HRESULT WINAPI AddInternetPropertySheets(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lparam, PUINT pucRefCount, LPFNPSPCALLBACK pfnCallback);


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\inetps.hpp ===
/*
 * inetps.hpp - Property sheet implementation for Internet class.
 */


/* GUIDs
 ********/

#ifndef UNIX
// IEUNIX : conflicts with ..\..\inc\shguidp.h
DEFINE_GUID(CLSID_Internet, 0xFBF23B42L, 0xE3F0, 0x101B, 0x84, 0x88, 0x00, 0xAA, 0x00, 0x3E, 0x56, 0xF8);
#endif

#ifdef __cplusplus

/* Types
 ********/

// Internet property sheet

class Internet : public RefCount,
                 public IShellExtInit,
                 public IShellPropSheetExt
{
public:
   Internet(void);
   ~Internet(void);

   // IShellExtInit methods

   HRESULT STDMETHODCALLTYPE Initialize(PCITEMIDLIST pcidlFolder, PIDataObject pidobj, HKEY hkeyProgID);

   // IShellPropSheetExt methods

   HRESULT STDMETHODCALLTYPE AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
   HRESULT STDMETHODCALLTYPE ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam);

   // IUnknown methods

   HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);
   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);

   // friends

#ifdef DEBUG

   friend BOOL IsValidPCInternet(const Internet *pcmimehk);

#endif

};
DECLARE_STANDARD_TYPES(Internet);

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\inetps.cpp ===
/*
 * inetps.cpp - Property sheet implementation for Internet class.
 */


/* Headers
 **********/

#include "project.hpp"
#pragma hdrstop

#include "clsfact.h"
#include "inetcpl.h"
#include "inetps.hpp"


/***************************** Private Functions *****************************/


PRIVATE_CODE HRESULT AddInternetPS(LPFNADDPROPSHEETPAGE pfnAddPage,
                                   LPARAM lparam)
{
   // lparam may be any value.

   ASSERT(IS_VALID_CODE_PTR(pfnAddPage, LPFNADDPROPSHEETPAGE));

   return(AddInternetPropertySheets(pfnAddPage, lparam, NULL, NULL));
}


/****************************** Public Functions *****************************/


#ifdef DEBUG

PUBLIC_CODE BOOL IsValidPCInternet(PCInternet pcinet)
{
   return(IS_VALID_READ_PTR(pcinet, CInternet) &&
          IS_VALID_STRUCT_PTR((PCRefCount)pcinet, CRefCount) &&
          IS_VALID_INTERFACE_PTR((PCIShellExtInit)pcinet, IShellExtInit) &&
          IS_VALID_INTERFACE_PTR((PCIShellPropSheetExt)pcinet, IShellPropSheetExt));
}

#endif


/********************************** Methods **********************************/


#pragma warning(disable:4705) /* "statement has no effect" warning - cl bug, see KB Q98989 */

Internet::Internet()
{
   DebugEntry(Internet::Internet);

   // Don't validate this until after construction.

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternet));

   DebugExitVOID(Internet::Internet);

   return;
}

#pragma warning(default:4705) /* "statement has no effect" warning - cl bug, see KB Q98989 */


Internet::~Internet(void)
{
   DebugEntry(Internet::~Internet);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternet));

   DebugExitVOID(Internet::~Internet);

   return;
}


ULONG STDMETHODCALLTYPE Internet::AddRef(void)
{
   ULONG ulcRef;

   DebugEntry(Internet::AddRef);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternet));

   ulcRef = RefCount::AddRef();

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternet));

   DebugExitULONG(Internet::AddRef, ulcRef);

   return(ulcRef);
}


ULONG STDMETHODCALLTYPE Internet::Release(void)
{
   ULONG ulcRef;

   DebugEntry(Internet::Release);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternet));

   ulcRef = RefCount::Release();

   DebugExitULONG(Internet::Release, ulcRef);

   return(ulcRef);
}


HRESULT STDMETHODCALLTYPE Internet::QueryInterface(REFIID riid,
                                                   PVOID *ppvObject)
{
   HRESULT hr = S_OK;

   DebugEntry(Internet::QueryInterface);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternet));
   ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   if (riid == IID_IShellExtInit)
   {
      *ppvObject = (PIShellExtInit)this;
      TRACE_OUT(("Internet::QueryInterface(): Returning IShellExtInit."));
   }
   else if (riid == IID_IShellPropSheetExt)
   {
      *ppvObject = (PIShellPropSheetExt)this;
      TRACE_OUT(("Internet::QueryInterface(): Returning IShellPropSheetExt."));
   }
   else if (riid == IID_IUnknown)
   {
      *ppvObject = (PIUnknown)(PIShellPropSheetExt)this;
      TRACE_OUT(("Internet::QueryInterface(): Returning IUnknown."));
   }
   else
   {
      TRACE_OUT(("Internet::QueryInterface(): Called on unknown interface."));
      *ppvObject = NULL;
      hr = E_NOINTERFACE;
   }

   if (hr == S_OK)
      AddRef();

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternet));

   DebugExitHRESULT(Internet::QueryInterface, hr);

   return(hr);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE Internet::Initialize(PCITEMIDLIST pcidlFolder,
                                               PIDataObject pido,
                                               HKEY hkeyProgID)
{
   HRESULT hr;

   DebugEntry(Internet::Initialize);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternet));
   ASSERT(! pcidlFolder ||
          IS_VALID_STRUCT_PTR(pcidlFolder, CITEMIDLIST));
   ASSERT(IS_VALID_INTERFACE_PTR(pido, IDataObject));
   ASSERT(IS_VALID_HANDLE(hkeyProgID, KEY));

   // An Internet doesn't care where it lives in the name space.

   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternet));

   DebugExitHRESULT(Internet::Initialize, hr);

   return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


HRESULT STDMETHODCALLTYPE Internet::AddPages(LPFNADDPROPSHEETPAGE pfnAddPage,
                                             LPARAM lparam)
{
   HRESULT hr;

   DebugEntry(Internet::AddPages);

   // lparam may be any value.

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternet));
   ASSERT(IS_VALID_CODE_PTR(pfnAddPage, LPFNADDPROPSHEETPAGE));

   hr = AddInternetPS(pfnAddPage, lparam);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternet));

   DebugExitHRESULT(Internet::AddPages, hr);

   return(hr);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE Internet::ReplacePage(
                                          UINT uPageID,
                                          LPFNADDPROPSHEETPAGE pfnReplaceWith,
                                          LPARAM lparam)
{
   HRESULT hr;

   DebugEntry(Internet::ReplacePage);

   // lparam may be any value.
   // uPageID may be any value.

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternet));
   ASSERT(IS_VALID_CODE_PTR(pfnReplaceWith, LPFNADDPROPSHEETPAGE));

   // No pages to replace.

   hr = E_NOTIMPL;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternet));

   DebugExitHRESULT(Internet::ReplacePage, hr);

   return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


extern "C"
STDAPI CreateInstance_Internet(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    HRESULT hres;

    *ppvOut = NULL;

    if (punkOuter)
        return CLASS_E_NOAGGREGATION;

    Internet *pinet = new(Internet);
    if (pinet) 
    {
        hres = pinet->QueryInterface(riid, ppvOut);
        pinet->Release();
    }
    else
        hres = E_OUTOFMEMORY;

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\init.cpp ===
/*
 * init.c - DLL startup routines module.
 */

/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "shlwapi.h"
#include "shlobj.h"
#include "ieguidp.h"

#include "init.h"
#include "clsfact.h"
#include "inetcpl.h"
#include "refcount.hpp"
#include "shlstock.h"
#include "olestock.h"
#include "ftps.hpp"     /* for CLSID_MIMEFileTypesPropSheetHook */
#include "inetps.hpp"   /* for CLSID_Internet */
#include "shguidp.h"    // for CLSID_URLExecHook
#include "cfmacros.h"   // static class factory macros

#define MLUI_INIT
#include <mluisupp.h>

/****************************** Public Functions *****************************/

/* Declare _main() so we can link with the CRT lib, but not have to
** use the DllMainCRTStartup entry point.
*/
void
_cdecl
main(void)
    {
    }


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

#ifdef MAINWIN
BOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, PVOID pvReserved);

extern "C" BOOL url_DllMain(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    )
{
  return DllMain(DllHandle,Reason,Reserved);
}

#endif

/*
** DllMain()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason,
                                PVOID pvReserved)
{
   BOOL bResult;

   DebugEntry(DllMain);

   /* Validate dwReason below. */
   /* pvReserved may be any value. */

   ASSERT(IS_VALID_HANDLE(hModule, MODULE));

   switch (dwReason)
   {
      case DLL_PROCESS_ATTACH:
         MLLoadResources(hModule, TEXT("urllc.dll"));
         bResult = AttachProcess(hModule);
         break;

      case DLL_PROCESS_DETACH:
         MLFreeResources(hModule);
         bResult = DetachProcess(hModule);
         break;

      case DLL_THREAD_ATTACH:
         bResult = AttachThread(hModule);
         break;

      case DLL_THREAD_DETACH:
         bResult = DetachThread(hModule);
         break;

      default:
         ERROR_OUT(("LibMain() called with unrecognized dwReason %lu.",
                    dwReason));
         bResult = FALSE;
         break;
   }

   DebugExitBOOL(DllMain, bResult);

   return(bResult);
}


UINT 
WhichPlatform(void)
{
    HINSTANCE hinst;

    //
    // in retail we cache this info
    // in debug we always re-fetch it (so people can switch)
    //
#ifdef DEBUG
    UINT uInstall = PLATFORM_UNKNOWN;
#else
    static UINT uInstall = PLATFORM_UNKNOWN;

    if (uInstall != PLATFORM_UNKNOWN)
        return uInstall;
#endif

    hinst = GetModuleHandle(TEXT("SHDOCVW.DLL"));
    if (hinst)
    {
        // NOTE: GetProcAddress always takes ANSI strings!
        DLLGETVERSIONPROC pfnGetVersion =
            (DLLGETVERSIONPROC)GetProcAddress(hinst, "DllGetVersion");

        if (pfnGetVersion)
        {
            DLLVERSIONINFO info;

            info.cbSize = sizeof(info);
            if (SUCCEEDED(pfnGetVersion(&info)))
            {
                if (4 <= info.dwMajorVersion &&
                    71 <= info.dwMinorVersion &&
                    429 <= info.dwBuildNumber)
                {
                    uInstall = PLATFORM_INTEGRATED;
                }
                else
                    uInstall = PLATFORM_IE3;
            }
        }

#ifdef DEBUG
        // To allow easier debugging, we can override the platform by 
        // setting InstallPlatform value in ccshell.ini.
        {
            UINT uInstallT = GetPrivateProfileInt(TEXT("urldebugoptions"),
                                                  TEXT("InstallPlatform"),
                                                  PLATFORM_UNKNOWN, 
                                                  TEXT("ohare.ini"));
            if (PLATFORM_UNKNOWN != uInstallT)
            {
                TRACE_OUT(("  ***Overriding real platform installation***\r\n"));
                uInstall = uInstallT;
            }
        }        

        switch (uInstall)
        {
        case PLATFORM_IE3:
            TRACE_OUT(("  ***Assuming IE3***\r\n"));
            break;

        case PLATFORM_INTEGRATED:
            TRACE_OUT(("  ***Assuming Nashville***\r\n"));
            break;
        }
#endif
    }

    return uInstall;
}


#pragma data_seg(DATA_SEG_PER_INSTANCE)

// DLL reference count == number of class factories +
//                        number of URLs +
//                        LockServer() count

PRIVATE_DATA ULONG s_ulcDLLRef   = 0;

#pragma data_seg()


PUBLIC_CODE ULONG DLLAddRef(void)
{
   ULONG ulcRef;

   ASSERT(s_ulcDLLRef < ULONG_MAX);

   ulcRef = ++s_ulcDLLRef;

   TRACE_OUT(("DLLAddRef(): DLL reference count is now %lu.",
              ulcRef));

   return(ulcRef);
}


PUBLIC_CODE ULONG DLLRelease(void)
{
   ULONG ulcRef;

   if (EVAL(s_ulcDLLRef > 0))
      s_ulcDLLRef--;

   ulcRef = s_ulcDLLRef;

   TRACE_OUT(("DLLRelease(): DLL reference count is now %lu.",
              ulcRef));

   return(ulcRef);
}


PUBLIC_CODE PULONG GetDLLRefCountPtr(void)
{
   // REARCHITECT: this is dangerous.  Shouldn't be used like this.

   return(&s_ulcDLLRef);
}


typedef HRESULT (CALLBACK* DLLGETCLASSOBJECTPROC)(REFCLSID, REFIID, void**);

STDMETHODIMP_(BOOL)
PatchForNashville(
    REFCLSID rclsid, 
    REFIID riid, 
    void **ppv,
    HRESULT * phres)
{
    BOOL bRet = FALSE;

    *phres = CLASS_E_CLASSNOTAVAILABLE;       // assume error

    if (IsEqualIID(rclsid, CLSID_InternetShortcut) &&
        PLATFORM_INTEGRATED == WhichPlatform())
    {
        HINSTANCE hinst;

        // Normally we can just patch the registry.  But there is a valid
        // case where url.dll is the InprocServer, and that is when the
        // user has chosen to uninstall IE 4.0 and we haven't restarted 
        // the machine yet.  In this case, we don't want to patch the
        // registry.  Use the "MayChangeDefaultMenu" as an indication
        // of whether we should really patch it or not.

        // Are we uninstalling IE 4.0?
        if (NO_ERROR == SHGetValue(HKEY_CLASSES_ROOT, 
                                   TEXT("CLSID\\{FBF23B40-E3F0-101B-8488-00AA003E56F8}\\shellex\\MayChangeDefaultMenu"),
                                   TEXT(""),
                                   NULL, NULL, NULL))
        {
            // No; patch the registry so shdocvw is the handler again
            SetRegKeyValue(HKEY_CLASSES_ROOT, 
                           "CLSID\\{FBF23B40-E3F0-101B-8488-00AA003E56F8}\\InProcServer32",
                           NULL,
                           REG_SZ,
                           (PCBYTE)"shdocvw.dll", sizeof("shdocvw.dll"));

            // Now call shdocvw's DllGetClassObject
            hinst = GetModuleHandle(TEXT("SHDOCVW.DLL"));
            if (hinst)
            {
                DLLGETCLASSOBJECTPROC pfn = 
                    (DLLGETCLASSOBJECTPROC)GetProcAddress(hinst, "DllGetClassObject");

                if (pfn)
                    {
                    *phres = pfn(rclsid, riid, ppv);
                    bRet = TRUE;
                    }
            }
        }
    }
    return bRet;
}


STDAPI CreateInstance_Intshcut(IUnknown *punkOuter, REFIID riid, void **ppvOut);
STDAPI CreateInstance_MIMEHook(IUnknown *punkOuter, REFIID riid, void **ppvOut);
STDAPI CreateInstance_Internet(IUnknown *punkOuter, REFIID riid, void **ppvOut);
STDAPI CreateInstance_URLExec(IUnknown *punkOuter, REFIID riid, void **ppvOut);

//
// ClassFactory methods.
// 

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (void *)GET_ICLASSFACTORY(this);
        DLLAddRef();
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return DLLAddRef();
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    return DLLRelease();
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvObject)
{
    CObjectInfo *localthis = (CObjectInfo*)(this);
    return localthis->pfnCreate(punkOuter, riid, ppvObject);
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DLLAddRef();
    else
        DLLRelease();
    return S_OK;
}

//
// we always do a linear search here so put your most often used things first
//

CF_TABLE_BEGIN(c_clsmap)

    CF_TABLE_ENTRY(&CLSID_URLExecHook, CreateInstance_URLExec) 
    CF_TABLE_ENTRY(&CLSID_InternetShortcut, CreateInstance_Intshcut)
    CF_TABLE_ENTRY(&CLSID_MIMEFileTypesPropSheetHook, CreateInstance_MIMEHook)
    CF_TABLE_ENTRY(&CLSID_Internet, CreateInstance_Internet)

CF_TABLE_END(c_clsmap)

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    HRESULT hres = CLASS_E_CLASSNOTAVAILABLE;
    
    *ppv = NULL;        // assume error

    if (IsEqualIID(riid, IID_IClassFactory))
    {
        // Under Nashville, the internet shortcuts are handled by shdocvw.
        // It is possible that the user installed Netscape after installing
        // Nashville, which would cause url.dll to be the handler again
        // for internet shortcuts.  This patches the registry and calls
        // shdocvw's DllGetClassObject if we're in that scenario.

        // Did we patch for nashville?
        if ( !PatchForNashville(rclsid, riid, ppv, &hres) )
        {
            // No; carry on...
            const CObjectInfo *pcls;
            for (pcls = c_clsmap; pcls->pclsid; pcls++)
            {
                if (IsEqualIID(rclsid, *(pcls->pclsid)))
                {
                    *ppv = (void *)GET_ICLASSFACTORY(pcls);
                    DLLAddRef();        // creation of the CF, CF holds DLL Ref count
                    return NOERROR;
                }
            }
        }
    }

    return hres;
}

STDAPI DllCanUnloadNow(void)
{
    if (s_ulcDLLRef > 0)
        return S_FALSE;

    return InternetCPLCanUnloadNow();
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\init.h ===
/*
 * init.h - DLL startup routines module description.
 */


/* Prototypes
 *************/

/* functions to be provided by client */
#ifdef __cplusplus
extern "C" {
#endif

#ifndef UNIX
extern BOOL AttachProcess(HANDLE);
extern BOOL DetachProcess(HANDLE);
extern BOOL AttachThread(HANDLE);
extern BOOL DetachThread(HANDLE);
#else
extern BOOL AttachProcess(HMODULE);
extern BOOL DetachProcess(HMODULE);
extern BOOL AttachThread(HMODULE);
extern BOOL DetachThread(HMODULE);
#endif /* UNIX */

#define PLATFORM_UNKNOWN     0
#define PLATFORM_IE3         1
#define PLATFORM_INTEGRATED  2

UINT _WhichPlatform(void);
#define WhichPlatform _WhichPlatform

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\inifile.h ===
/*
 * inifile.h - Initialization file processing module description.
 */


/* Types
 ********/

#ifdef DEBUG

/* .ini switch types */

typedef enum _iniswitchtype
{
   IST_BOOL,
   IST_DEC_INT,
   IST_UNS_DEC_INT
}
INISWITCHTYPE;
DECLARE_STANDARD_TYPES(INISWITCHTYPE);

/* boolean .ini switch */

typedef struct _booliniswitch
{
   INISWITCHTYPE istype;      /* must be IST_BOOL */

   PCSTR pcszKeyName;

   PDWORD pdwParentFlags;

   DWORD dwFlag;
}
BOOLINISWITCH;
DECLARE_STANDARD_TYPES(BOOLINISWITCH);

/* decimal integer .ini switch */

typedef struct _decintiniswitch
{
   INISWITCHTYPE istype;      /* must be IST_DEC_INT */

   PCSTR pcszKeyName;

   PINT pnValue;
}
DECINTINISWITCH;
DECLARE_STANDARD_TYPES(DECINTINISWITCH);

/* unsigned decimal integer .ini switch */

typedef struct _unsdecintiniswitch
{
   INISWITCHTYPE istype;      /* must be IST_UNS_DEC_INT */

   PCSTR pcszKeyName;

   PUINT puValue;
}
UNSDECINTINISWITCH;
DECLARE_STANDARD_TYPES(UNSDECINTINISWITCH);

#endif


/* Global Variables
 *******************/

#ifdef DEBUG

/* defined by client */

extern PCSTR g_pcszIniFile;
extern PCSTR g_pcszIniSection;

#endif


/* Prototypes
 *************/

#ifdef DEBUG

/* inifile.c */

extern BOOL SetIniSwitches(const PCVOID *, UINT);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\inifile.c ===
/*
 * inifile.c - Initialization file processing module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


#ifdef DEBUG

/* Constants
 ************/

/* maximum length of .ini switch RHS */

#define MAX_INI_SWITCH_RHS_LEN      MAX_PATH_LEN


/* Module Variables
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

/* Boolean TRUE strings used by IsIniYes() (comparison is case-insensitive) */

PRIVATE_DATA const PCSTR s_rgcszTrue[] =
{
   "1",
   "On",
   "True",
   "Y",
   "Yes"
};

/* Boolean FALSE strings used by IsIniYes() (comparison is case-insensitive) */

PRIVATE_DATA const PCSTR s_rgcszFalse[] =
{
   "0",
   "Off",
   "False",
   "N",
   "No"
};

#pragma data_seg()

#endif


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

#ifdef DEBUG

PRIVATE_CODE BOOL SetBOOLIniSwitch(PCBOOLINISWITCH);
PRIVATE_CODE BOOL SetDecimalIntIniSwitch(PCDECINTINISWITCH);
PRIVATE_CODE BOOL SetIniSwitch(PCVOID);
PRIVATE_CODE BOOL IsYesString(PCSTR);
PRIVATE_CODE BOOL IsNoString(PCSTR);
PRIVATE_CODE BOOL IsStringInList(PCSTR, const PCSTR *, UINT);
PRIVATE_CODE BOOL IsValidPCBOOLINISWITCH(PCBOOLINISWITCH);
PRIVATE_CODE BOOL IsValidPCDECINTINISWITCH(PCDECINTINISWITCH);
PRIVATE_CODE BOOL IsValidPCUNSDECINTINISWITCH(PCUNSDECINTINISWITCH);

#endif


#ifdef DEBUG

/*
** SetBOOLIniSwitch()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL SetBOOLIniSwitch(PCBOOLINISWITCH pcbis)
{
   DWORD dwcbKeyLen;
   char rgchRHS[MAX_INI_SWITCH_RHS_LEN];

   ASSERT(IS_VALID_STRUCT_PTR(pcbis, CBOOLINISWITCH));

   /* Set boolean .ini switch. */

   dwcbKeyLen = GetPrivateProfileString(g_pcszIniSection, pcbis->pcszKeyName,
                                        "", rgchRHS, sizeof(rgchRHS),
                                        g_pcszIniFile);

   /* Is the .ini switch set? */

   if (rgchRHS[0])
   {
      /* Yes.  Set or clear flag? */

      if (IsYesString(rgchRHS))
      {
         /* Set flag. */

         if (IS_FLAG_CLEAR(*(pcbis->pdwParentFlags), pcbis->dwFlag))
         {
            SET_FLAG(*(pcbis->pdwParentFlags), pcbis->dwFlag);

            WARNING_OUT(("SetBOOLIniSwitch(): %s set in %s![%s].",
                         pcbis->pcszKeyName,
                         g_pcszIniFile,
                         g_pcszIniSection));
         }
      }
      else if (IsNoString(rgchRHS))
      {
         /* Clear flag. */

         if (IS_FLAG_SET(*(pcbis->pdwParentFlags), pcbis->dwFlag))
         {
            CLEAR_FLAG(*(pcbis->pdwParentFlags), pcbis->dwFlag);

            WARNING_OUT(("SetBOOLIniSwitch(): %s cleared in %s![%s].",
                         pcbis->pcszKeyName,
                         g_pcszIniFile,
                         g_pcszIniSection));
         }
      }
      else
         /* Unknown flag. */
         WARNING_OUT(("SetBOOLIniSwitch(): Found unknown Boolean RHS %s for %s in %s![%s].",
                      rgchRHS,
                      pcbis->pcszKeyName,
                      g_pcszIniFile,
                      g_pcszIniSection));
   }

   return(TRUE);
}


/*
** SetDecimalIntIniSwitch()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL SetDecimalIntIniSwitch(PCDECINTINISWITCH pcdiis)
{
   INT nNewValue;

   ASSERT(IS_VALID_STRUCT_PTR(pcdiis, CDECINTINISWITCH));

   /* Get decimal integer .ini switch. */

   nNewValue = GetPrivateProfileInt(g_pcszIniSection, pcdiis->pcszKeyName,
                                    *(pcdiis->pnValue), g_pcszIniFile);

   /* New value? */

   if (nNewValue != *(pcdiis->pnValue))
   {
      /* Yes. */

      *(pcdiis->pnValue) = nNewValue;

      WARNING_OUT(("SetDecimalIntIniSwitch(): %s set to %d in %s![%s].",
                   pcdiis->pcszKeyName,
                   *(pcdiis->pnValue),
                   g_pcszIniFile,
                   g_pcszIniSection));
   }

   return(TRUE);
}


/*
** SetUnsignedDecimalIntIniSwitch()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL SetUnsignedDecimalIntIniSwitch(PCUNSDECINTINISWITCH pcudiis)
{
   INT nNewValue;

   ASSERT(IS_VALID_STRUCT_PTR(pcudiis, CUNSDECINTINISWITCH));

   /* Get unsigned decimal integer .ini switch as signed decimal integer. */

   ASSERT(*(pcudiis->puValue) <= INT_MAX);

   nNewValue = GetPrivateProfileInt(g_pcszIniSection, pcudiis->pcszKeyName,
                                    *(pcudiis->puValue), g_pcszIniFile);

   if (nNewValue >= 0)
   {
      if ((UINT)nNewValue != *(pcudiis->puValue))
      {
         /* New non-negative value. */

         *(pcudiis->puValue) = nNewValue;

         WARNING_OUT(("SetUnsignedDecimalIntIniSwitch(): %s set to %u in %s![%s].",
                      pcudiis->pcszKeyName,
                      *(pcudiis->puValue),
                      g_pcszIniFile,
                      g_pcszIniSection));
      }
   }
   else
      /* Negative value. */
      WARNING_OUT(("SetUnsignedDecimalIntIniSwitch(): Unsigned value %s set to %d in %s![%s].  Ignored.",
                   pcudiis->pcszKeyName,
                   nNewValue,
                   g_pcszIniFile,
                   g_pcszIniSection));

   return(TRUE);
}


/*
** SetIniSwitch()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL SetIniSwitch(PCVOID pcvIniSwitch)
{
   BOOL bResult;

   ASSERT(IS_VALID_READ_PTR((PCINISWITCHTYPE)pcvIniSwitch, CINISWITCHTYPE));

   /* Set .ini switch based upon type. */

   switch (*(PCINISWITCHTYPE)pcvIniSwitch)
   {
      case IST_BOOL:
         bResult = SetBOOLIniSwitch(pcvIniSwitch);
         break;

      case IST_DEC_INT:
         bResult = SetDecimalIntIniSwitch(pcvIniSwitch);
         break;

      case IST_UNS_DEC_INT:
         bResult = SetUnsignedDecimalIntIniSwitch(pcvIniSwitch);
         break;

      default:
         ERROR_OUT(("SetIniSwitch(): Unrecognized .ini switch type %d.",
                    *(PCINISWITCHTYPE)pcvIniSwitch));
         bResult = FALSE;
         break;
   }

   return(bResult);
}


/*
** IsYesString()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsYesString(PCSTR pcsz)
{
   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   return(IsStringInList(pcsz, s_rgcszTrue, ARRAY_ELEMENTS(s_rgcszTrue)));
}


/*
** IsNoString()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsNoString(PCSTR pcsz)
{
   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   return(IsStringInList(pcsz, s_rgcszFalse, ARRAY_ELEMENTS(s_rgcszFalse)));
}


/*
** IsStringInList()
**
** Determines whether or not a given string matches a string in a list of
** strings.
**
** Arguments:     pcsz - pointer to string to be checked
**
** Returns:       
**
** Side Effects:  none
**
** N.b., string comparison is case-insensitive.
*/
PRIVATE_CODE BOOL IsStringInList(PCSTR pcsz, const PCSTR *pcpcszList,
                                 UINT ucbStrings)
{
   UINT u;
   BOOL bFound = FALSE;

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));
   ASSERT(IS_VALID_READ_BUFFER_PTR(pcpcszList, PCSTR, ucbStrings * sizeof(*pcpcszList)));

   /* Search the list for the given string. */

   for (u = 0; u < ucbStrings; u++)
   {
      ASSERT(IS_VALID_STRING_PTR(pcpcszList[u], CSTR));

      if (! lstrcmpi(pcsz, pcpcszList[u]))
      {
         bFound = TRUE;
         break;
      }
   }

   return(bFound);
}


/*
** IsValidPCBOOLINIKEY()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCBOOLINISWITCH(PCBOOLINISWITCH pcbis)
{
   return(IS_VALID_READ_PTR(pcbis, CBOOLINISWITCH) &&
          EVAL(pcbis->istype == IST_BOOL) &&
          IS_VALID_STRING_PTR(pcbis->pcszKeyName, CSTR) &&
          IS_VALID_WRITE_PTR(pcbis->pdwParentFlags, DWORD) &&
          EVAL(pcbis->dwFlag));
}


/*
** IsValidPCDECINTINISWITCH()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCDECINTINISWITCH(PCDECINTINISWITCH pcdiis)
{
   return(IS_VALID_READ_PTR(pcdiis, CDECINTINISWITCH) &&
          EVAL(pcdiis->istype == IST_DEC_INT) &&
          IS_VALID_STRING_PTR(pcdiis->pcszKeyName, CSTR) &&
          IS_VALID_WRITE_PTR(pcdiis->pnValue, INT));
}


/*
** IsValidPCUNSDECINTINISWITCH()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCUNSDECINTINISWITCH(PCUNSDECINTINISWITCH pcudiis)
{
   return(IS_VALID_READ_PTR(pcudiis, CUNSDECINTINISWITCH) &&
          EVAL(pcudiis->istype == IST_UNS_DEC_INT) &&
          IS_VALID_STRING_PTR(pcudiis->pcszKeyName, CSTR) &&
          IS_VALID_WRITE_PTR(pcudiis->puValue, UINT));
}

#endif


/****************************** Public Functions *****************************/


#ifdef DEBUG

/*
** SetIniSwitches()
**
** Set flags from initialization file.
**
** Arguments:     ppcvIniSwitches - pointer to array of pointers to .ini switch
**                                  structures describing .ini switches to set
**                ucSwitches - number of .ini switch pointers in
**                             ppcvIniSwitches array
**
** Returns:       TRUE if .ini switch processing is successful.  FALSE if not.
**
** Side Effects:  none
**
** N.b, the global variables g_pcszIniFile and g_pcszIniSection must be filled in
** before calling SetIniSwitches().
*/
PUBLIC_CODE BOOL SetIniSwitches(const PCVOID *pcpcvIniSwitches, UINT ucSwitches)
{
   BOOL bResult = TRUE;
   UINT u;

   ASSERT(IS_VALID_READ_BUFFER_PTR(pcpcvIniSwitches, const PCVOID, ucSwitches * sizeof(*pcpcvIniSwitches)));

   /* Process .ini switches. */

   for (u = 0; u < ucSwitches; u++)
      bResult = SetIniSwitch(pcpcvIniSwitches[u]) && bResult;

   return(bResult);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\inline.hpp ===
/*
 * inline.hpp - Inline function definitions.
 */


/* Inline Functions
 *******************/

INLINE BOOL IsDigit(char ch)
{
   return(ch >= '0' && ch <= '9');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\intshcut.hpp ===
/*
 * intshcut.hpp - Internet Shortcut class implementation description.
 */


/* Types
 ********/

// InternetShortcut flags

typedef enum _intshcutflags
{
   INTSHCUT_FL_DIRTY    = 0x0001,

   ALL_INTSHCUT_FLAGS   = INTSHCUT_FL_DIRTY
}
INTSHCUTFLAGS;

// InternetShortcut Shell extension

class InternetShortcut : public RefCount,
                         public IDataObject,
                         public IExtractIcon,
                         public INewShortcutHook,
                         public IPersistFile,
                         public IPersistStream,
                         public IShellExecuteHook,
                         public IShellExtInit,
                         public IShellLink,
                         public IShellPropSheetExt,
                         public IUniformResourceLocator
{
private:
   DWORD m_dwFlags;
   PSTR m_pszFile;
   PSTR m_pszURL;
   PSTR m_pszIconFile;
   int m_niIcon;
   PSTR m_pszWorkingDirectory;
   int m_nShowCmd;
   PSTR m_pszFolder;
   WORD m_wHotkey;

   // data transfer methods

   DWORD STDMETHODCALLTYPE GetFileContentsSize(void);
   HRESULT STDMETHODCALLTYPE TransferUniformResourceLocator(PFORMATETC pfmtetc, PSTGMEDIUM pstgmed);
   HRESULT STDMETHODCALLTYPE TransferText(PFORMATETC pfmtetc, PSTGMEDIUM pstgmed);
   HRESULT STDMETHODCALLTYPE TransferFileGroupDescriptor(PFORMATETC pfmtetc, PSTGMEDIUM pstgmed);
   HRESULT STDMETHODCALLTYPE TransferFileContents(PFORMATETC pfmtetc, PSTGMEDIUM pstgmed);

   // protocol registration methods

   HRESULT STDMETHODCALLTYPE RegisterProtocolHandler(HWND hwndParent, PSTR pszAppBuf, UINT ucAppBufLen);

public:
   InternetShortcut(void);
   ~InternetShortcut(void);

   // IDataObject methods

   HRESULT STDMETHODCALLTYPE GetData(PFORMATETC pfmtetcIn, PSTGMEDIUM pstgmed);
   HRESULT STDMETHODCALLTYPE GetDataHere(PFORMATETC pfmtetc, PSTGMEDIUM pstgpmed);
   HRESULT STDMETHODCALLTYPE QueryGetData(PFORMATETC pfmtetc);
   HRESULT STDMETHODCALLTYPE GetCanonicalFormatEtc(PFORMATETC pfmtetcIn, PFORMATETC pfmtetcOut);
   HRESULT STDMETHODCALLTYPE SetData(PFORMATETC pfmtetc, PSTGMEDIUM pstgmed, BOOL bRelease);
   HRESULT STDMETHODCALLTYPE EnumFormatEtc(DWORD dwDirection, PIEnumFORMATETC *ppienumFormatEtc);
   HRESULT STDMETHODCALLTYPE DAdvise(PFORMATETC pfmtetc, DWORD dwAdviseFlags, PIAdviseSink piadvsink, PDWORD pdwConnection);
   HRESULT STDMETHODCALLTYPE DUnadvise(DWORD dwConnection);
   HRESULT STDMETHODCALLTYPE EnumDAdvise(PIEnumSTATDATA *ppienumStatData);

   // IExtractIcon methods

   HRESULT STDMETHODCALLTYPE GetIconLocation(UINT uFlags, PSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags);
   HRESULT STDMETHODCALLTYPE Extract(PCSTR pcszFile, UINT uIconIndex, PHICON phiconLarge, PHICON phiconSmall, UINT ucIconSize);

   // INewShortcutHook methods

   HRESULT STDMETHODCALLTYPE SetReferent(PCSTR pcszReferent, HWND hwndParent);
   HRESULT STDMETHODCALLTYPE GetReferent(PSTR pszReferent, int ncReferentBufLen);
   HRESULT STDMETHODCALLTYPE SetFolder(PCSTR pcszFolder);
   HRESULT STDMETHODCALLTYPE GetFolder(PSTR pszFolder, int ncFolderBufLen);
   HRESULT STDMETHODCALLTYPE GetName(PSTR pszName, int ncNameBufLen);
   HRESULT STDMETHODCALLTYPE GetExtension(PSTR pszExtension, int ncExtensionBufLen);

   // IPersist methods

   HRESULT STDMETHODCALLTYPE GetClassID(PCLSID pclsid);

   // IPersistFile methods

   HRESULT STDMETHODCALLTYPE IsDirty(void);
   HRESULT STDMETHODCALLTYPE Save(LPCOLESTR pcwszFileName, BOOL bRemember);
   HRESULT STDMETHODCALLTYPE SaveCompleted(LPCOLESTR pcwszFileName);
   HRESULT STDMETHODCALLTYPE Load(LPCOLESTR pcwszFileName, DWORD dwMode);
   HRESULT STDMETHODCALLTYPE GetCurFile(LPOLESTR *ppwszFileName);

   // IPersistStream methods

   HRESULT STDMETHODCALLTYPE Save(PIStream pistr, BOOL bClearDirty);
   HRESULT STDMETHODCALLTYPE Load(PIStream pistr);
   HRESULT STDMETHODCALLTYPE GetSizeMax(PULARGE_INTEGER pcbSize);

   // IShellExecuteHook methods

   HRESULT STDMETHODCALLTYPE Execute(PSHELLEXECUTEINFO pei);

   // IShellExtInit methods

   HRESULT STDMETHODCALLTYPE Initialize(PCITEMIDLIST pcidlFolder, PIDataObject pidobj, HKEY hkeyProgID);

   // IShellLink methods

   HRESULT STDMETHODCALLTYPE SetPath(PCSTR pcszPath);
   HRESULT STDMETHODCALLTYPE GetPath(PSTR pszFile, int ncFileBufLen, PWIN32_FIND_DATA pwfd, DWORD dwFlags);
   HRESULT STDMETHODCALLTYPE SetRelativePath(PCSTR pcszRelativePath, DWORD dwReserved);
   HRESULT STDMETHODCALLTYPE SetIDList(LPCITEMIDLIST pcidl);
   HRESULT STDMETHODCALLTYPE GetIDList(LPITEMIDLIST *ppidl);
   HRESULT STDMETHODCALLTYPE SetDescription(PCSTR pcszDescription);
   HRESULT STDMETHODCALLTYPE GetDescription(PSTR pszDescription, int ncDesciptionBufLen);
   HRESULT STDMETHODCALLTYPE SetArguments(PCSTR pcszArgs);
   HRESULT STDMETHODCALLTYPE GetArguments(PSTR pszArgs, int ncArgsBufLen);
   HRESULT STDMETHODCALLTYPE SetWorkingDirectory(PCSTR pcszWorkingDirectory);
   HRESULT STDMETHODCALLTYPE GetWorkingDirectory(PSTR pszWorkingDirectory, int ncbLen);
   HRESULT STDMETHODCALLTYPE SetHotkey(WORD wHotkey);
   HRESULT STDMETHODCALLTYPE GetHotkey(PWORD pwHotkey);
   HRESULT STDMETHODCALLTYPE SetShowCmd(int nShowCmd);
   HRESULT STDMETHODCALLTYPE GetShowCmd(PINT pnShowCmd);
   HRESULT STDMETHODCALLTYPE SetIconLocation(PCSTR pcszIconFile, int niIcon);
   HRESULT STDMETHODCALLTYPE GetIconLocation(PSTR pszIconFile, int ncbLen, PINT pniIcon);
   HRESULT STDMETHODCALLTYPE Resolve(HWND hwnd, DWORD dwFlags);

   // IShellPropSheetExt methods

   HRESULT STDMETHODCALLTYPE AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
   HRESULT STDMETHODCALLTYPE ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam);

   // IUniformResourceLocator methods

   HRESULT STDMETHODCALLTYPE SetURL(PCSTR pcszURL, DWORD dwFlags);
   HRESULT STDMETHODCALLTYPE GetURL(PSTR *ppszURL);
   HRESULT STDMETHODCALLTYPE InvokeCommand(PURLINVOKECOMMANDINFO purlici);

   // IUnknown methods

   HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);
   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);

   // other methods

   HRESULT STDMETHODCALLTYPE SaveToFile(PCSTR pcszFile, BOOL bRemember);
   HRESULT STDMETHODCALLTYPE LoadFromFile(PCSTR pcszFile, BOOL bRemember);
   HRESULT STDMETHODCALLTYPE GetCurFile(PSTR pszFile, UINT ucbLen);
   HRESULT STDMETHODCALLTYPE Dirty(BOOL bDirty);

#ifdef DEBUG

   void STDMETHODCALLTYPE Dump(void);

#endif

   // friends

#ifdef DEBUG

   friend BOOL IsValidPCInternetShortcut(const InternetShortcut *pcintshcut);

#endif

};
DECLARE_STANDARD_TYPES(InternetShortcut);


/* Global Constants
 *******************/

// intshcut.cpp

extern const int g_nDefaultShowCmd;


/* Prototypes
 *************/

// intshcut.cpp

extern HRESULT IsProtocolRegistered(PCSTR pcszProtocol);
extern HRESULT ValidateURL(PCSTR pcszURL);
extern HRESULT ValidateWorkingDirectory(PCSTR pcszWorkingDirectory);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\isguids.c ===
/*
 * isguids.c - Internet Shortcut GUID definitions.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/* GUIDs
 ********/

#pragma data_seg(DATA_SEG_READ_ONLY)

#pragma warning(disable:4001) /* "single line comment" warning */
#include <initguid.h>

#define NO_SHELL_GUIDS
#include <isguids.h>

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\intshcut.cpp ===
/*
 * intshcut.cpp - IUnknown implementation for InternetShortcut class.
 */


/* Headers
 **********/

#include "project.hpp"
#pragma hdrstop

#include "assoc.h"
#include "clsfact.h"


/* Global Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

PUBLIC_DATA const int g_nDefaultShowCmd  = SW_NORMAL;

#pragma data_seg()


/****************************** Public Functions *****************************/


PUBLIC_CODE HRESULT IsProtocolRegistered(PCSTR pcszProtocol)
{
   HRESULT hr;
   PSTR pszKey;

   ASSERT(IS_VALID_STRING_PTR(pcszProtocol, CSTR));

   hr = GetProtocolKey(pcszProtocol, EMPTY_STRING, &pszKey);

   if (hr == S_OK)
   {
      hr = (GetRegKeyValue(g_hkeyURLProtocols, pszKey, g_cszURLProtocol, NULL,
                           NULL, NULL) == ERROR_SUCCESS)
           ? S_OK
           : URL_E_UNREGISTERED_PROTOCOL;

      delete pszKey;
      pszKey = NULL;
   }

   if (hr != S_OK) {
      TRACE_OUT(("IsProtocolRegistered(): Protocol \"%s\" is not registered.",
                 pcszProtocol));
   }

   return(hr);
}


PUBLIC_CODE HRESULT ValidateURL(PCSTR pcszURL)
{
   HRESULT hr;
   PSTR pszProtocol;

   ASSERT(IS_VALID_STRING_PTR(pcszURL, CSTR));

   hr = CopyURLProtocol(pcszURL, &pszProtocol);

   if (hr == S_OK)
   {
      hr = IsProtocolRegistered(pszProtocol);

      delete pszProtocol;
      pszProtocol = NULL;
   }

   return(hr);
}


PUBLIC_CODE HRESULT ValidateWorkingDirectory(PCSTR pcszWorkingDirectory)
{
   ASSERT(IS_VALID_STRING_PTR(pcszWorkingDirectory, CSTR));

   return(IsPathDirectory(pcszWorkingDirectory) ? S_OK : E_PATH_NOT_FOUND);
}


#ifdef DEBUG

PUBLIC_CODE BOOL IsValidPCInternetShortcut(PCInternetShortcut pcintshcut)
{
   return(IS_VALID_READ_PTR(pcintshcut, CInternetShortcut) &&
          FLAGS_ARE_VALID(pcintshcut->m_dwFlags, ALL_INTSHCUT_FLAGS) &&
          (! pcintshcut->m_pszFile ||
           IS_VALID_STRING_PTR(pcintshcut->m_pszFile, STR)) &&
          (! pcintshcut->m_pszURL ||
           IS_VALID_STRING_PTR(pcintshcut->m_pszURL, STR)) &&
          ((! pcintshcut->m_pszIconFile &&
            ! pcintshcut->m_niIcon) ||
           EVAL(IsValidIconIndex(S_OK, pcintshcut->m_pszIconFile, MAX_PATH_LEN, pcintshcut->m_niIcon))) &&
          (! pcintshcut->m_pszWorkingDirectory ||
           EVAL(IsFullPath(pcintshcut->m_pszWorkingDirectory))) &&
          EVAL(IsValidShowCmd(pcintshcut->m_nShowCmd)) &&
          EVAL(! pcintshcut->m_pszFolder ||
               IsValidPath(pcintshcut->m_pszFolder)) &&
          EVAL(! pcintshcut->m_wHotkey ||
               IsValidHotkey(pcintshcut->m_wHotkey)) &&
          IS_VALID_STRUCT_PTR((PCRefCount)pcintshcut, CRefCount) &&
          IS_VALID_INTERFACE_PTR((PCIDataObject)pcintshcut, IDataObject) &&
          IS_VALID_INTERFACE_PTR((PCIExtractIcon)pcintshcut, IExtractIcon) &&
          IS_VALID_INTERFACE_PTR((PCINewShortcutHook)pcintshcut, INewShortcutHook) &&
          IS_VALID_INTERFACE_PTR((PCIPersistFile)pcintshcut, IPersistFile) &&
          IS_VALID_INTERFACE_PTR((PCIPersistStream)pcintshcut, IPersistStream) &&
          IS_VALID_INTERFACE_PTR((PCIShellExecuteHook)pcintshcut, IShellExecuteHook) &&
          IS_VALID_INTERFACE_PTR((PCIShellExtInit)pcintshcut, IShellExtInit) &&
          IS_VALID_INTERFACE_PTR((PCIShellLink)pcintshcut, IShellLink) &&
          IS_VALID_INTERFACE_PTR((PCIShellPropSheetExt)pcintshcut, IShellPropSheetExt) &&
          IS_VALID_INTERFACE_PTR((PCIUniformResourceLocator)pcintshcut, IUniformResourceLocator));
}

#endif


/********************************** Methods **********************************/


#pragma warning(disable:4705) /* "statement has no effect" warning - cl bug, see KB Q98989 */

InternetShortcut::InternetShortcut()
{
   DebugEntry(InternetShortcut::InternetShortcut);

   // Don't validate this until after construction.

   m_dwFlags = 0;
   m_pszFile = NULL;
   m_pszURL = NULL;
   m_pszIconFile = NULL;
   m_niIcon = 0;
   m_pszWorkingDirectory = NULL;
   m_nShowCmd = g_nDefaultShowCmd;
   m_pszFolder = NULL;
   m_wHotkey = 0;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitVOID(InternetShortcut::InternetShortcut);

   return;
}

#pragma warning(default:4705) /* "statement has no effect" warning - cl bug, see KB Q98989 */


InternetShortcut::~InternetShortcut(void)
{
   DebugEntry(InternetShortcut::~InternetShortcut);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   if (m_pszFile)
   {
      delete m_pszFile;
      m_pszFile = NULL;
   }

   if (m_pszURL)
   {
      delete m_pszURL;
      m_pszURL = NULL;
   }

   if (m_pszIconFile)
   {
      delete m_pszIconFile;
      m_pszIconFile = NULL;
      m_niIcon = 0;
   }

   if (m_pszWorkingDirectory)
   {
      delete m_pszWorkingDirectory;
      m_pszWorkingDirectory = NULL;
   }

   if (m_pszFolder)
   {
      delete m_pszFolder;
      m_pszFolder = NULL;
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitVOID(InternetShortcut::~InternetShortcut);

   return;
}


ULONG STDMETHODCALLTYPE InternetShortcut::AddRef(void)
{
   ULONG ulcRef;

   DebugEntry(InternetShortcut::AddRef);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   ulcRef = RefCount::AddRef();

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitULONG(InternetShortcut::AddRef, ulcRef);

   return(ulcRef);
}


ULONG STDMETHODCALLTYPE InternetShortcut::Release(void)
{
   ULONG ulcRef;

   DebugEntry(InternetShortcut::Release);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   ulcRef = RefCount::Release();

   DebugExitULONG(InternetShortcut::Release, ulcRef);

   return(ulcRef);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::QueryInterface(REFIID riid,
                                                           PVOID *ppvObject)
{
   HRESULT hr = S_OK;

   DebugEntry(InternetShortcut::QueryInterface);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   if (riid == IID_IDataObject)
   {
      *ppvObject = (PIDataObject)this;
      TRACE_OUT(("InternetShortcut::QueryInterface(): Returning IDataObject."));
   }
   else if (riid == IID_IExtractIcon)
   {
      *ppvObject = (PIExtractIcon)this;
      TRACE_OUT(("InternetShortcut::QueryInterface(): Returning IExtractIcon."));
   }
   else if (riid == IID_INewShortcutHook)
   {
      *ppvObject = (PINewShortcutHook)this;
      TRACE_OUT(("InternetShortcut::QueryInterface(): Returning INewShortcutHook."));
   }
   else if (riid == IID_IPersist)
   {
      *ppvObject = (PIPersist)(PIPersistStream)this;
      TRACE_OUT(("InternetShortcut::QueryInterface(): Returning IPersist."));
   }
   else if (riid == IID_IPersistFile)
   {
      *ppvObject = (PIPersistFile)this;
      TRACE_OUT(("InternetShortcut::QueryInterface(): Returning IPersistFile."));
   }
   else if (riid == IID_IPersistStream)
   {
      *ppvObject = (PIPersistStream)this;
      TRACE_OUT(("InternetShortcut::QueryInterface(): Returning IPersistStream."));
   }
   else if (riid == IID_IShellExecuteHook)
   {
      *ppvObject = (PIShellExecuteHook)this;
      TRACE_OUT(("InternetShortcut::QueryInterface(): Returning IShellExecuteHook."));
   }
   else if (riid == IID_IShellExtInit)
   {
      *ppvObject = (PIShellExtInit)this;
      TRACE_OUT(("InternetShortcut::QueryInterface(): Returning IShellExtInit."));
   }
   else if (riid == IID_IShellLink)
   {
      *ppvObject = (PIShellLink)this;
      TRACE_OUT(("InternetShortcut::QueryInterface(): Returning IShellLink."));
   }
   else if (riid == IID_IShellPropSheetExt)
   {
      *ppvObject = (PIShellPropSheetExt)this;
      TRACE_OUT(("InternetShortcut::QueryInterface(): Returning IShellPropSheetExt."));
   }
   else if (riid == IID_IUniformResourceLocator)
   {
      *ppvObject = (PIUniformResourceLocator)this;
      TRACE_OUT(("InternetShortcut::QueryInterface(): Returning IUniformResourceLocator."));
   }
   else if (riid == IID_IUnknown)
   {
      *ppvObject = (PIUnknown)(PIUniformResourceLocator)this;
      TRACE_OUT(("InternetShortcut::QueryInterface(): Returning IUnknown."));
   }
   else
   {
      TRACE_OUT(("InternetShortcut::QueryInterface(): Called on unknown interface."));
      *ppvObject = NULL;
      hr = E_NOINTERFACE;
   }

   if (hr == S_OK)
      AddRef();

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::QueryInterface, hr);

   return(hr);
}


extern "C"
STDAPI CreateInstance_Intshcut(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    HRESULT hres;

    *ppvOut = NULL;

    if (punkOuter)
        return CLASS_E_NOAGGREGATION;

    InternetShortcut *pintshcut = new(InternetShortcut);
    if (pintshcut) 
    {
        hres = pintshcut->QueryInterface(riid, ppvOut);
        pintshcut->Release();
    }
    else
        hres = E_OUTOFMEMORY;

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\ispriv.h ===
/*
 * ispriv.h - url.dll APIs.
 */


#ifndef __ISPRIV_H__
#define __ISPRIV_H__


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Constants
 ************/

/* Define API decoration for direct import of DLL functions. */

#ifdef _INTSHCUT_
#define INTSHCUTPRIVAPI
#else
#define INTSHCUTPRIVAPI             DECLSPEC_IMPORT
#endif


/* Prototypes
 *************/

/******************************************************************************

@doc INTERNAL

@func HRESULT | AddMIMEFileTypesPS | Adds the MIME-enabled File Types property
sheet to a set of property sheets to a list of property sheets.

@parm LPFNADDPROPSHEETPAGE | pfnAddPage | Callback function to be called to add
the property sheet.

@parm LPARAM | lparam | Data to be passed to callback function.

@rdesc Returns one of the following return codes on success:

@flag S_OK | Pages added.

otherwise returns one of the following return codes on error:

@flag E_ABORT | pfnAddPage callback failed.

@flag E_OUTOFMEMORY | There is not enough memory to complete the operation.

******************************************************************************/

INTSHCUTPRIVAPI HRESULT WINAPI AddMIMEFileTypesPS(LPFNADDPROPSHEETPAGE pfnAddPage,
                                                  LPARAM lparam);


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */


#endif   /* ! __ISPRIV_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\mapi.h ===
/*
 *  M A P I . H
 *
 *  Messaging Applications Programming Interface.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 *
 *  Purpose:
 *
 *    This file defines the structures and constants used by that
 *    subset of the Messaging Applications Programming Interface
 *    which is supported under Windows by Microsoft Mail for PC
 *    Networks version 3.x.
 */


#ifndef MAPI_H
#define MAPI_H


/*
 *  Types.
 */


#ifdef __cplusplus
extern "C" {
#endif

typedef unsigned long FAR * LPULONG;
typedef unsigned long       FLAGS;

#ifndef __LHANDLE
#define __LHANDLE
typedef unsigned long       LHANDLE, FAR * LPLHANDLE;
#endif

typedef unsigned char FAR * LPBYTE;

#define    lhSessionNull    ((LHANDLE)0)

typedef struct
{
    ULONG ulReserved;            /* Reserved for future use (must be 0)     */
    ULONG flFlags;               /* Flags                                   */
    ULONG nPosition;             /* character in text to be replaced by attachment */
    LPSTR lpszPathName;          /* Full path name of attachment file       */
    LPSTR lpszFileName;          /* Original file name (optional)           */
    LPVOID lpFileType;           /* Attachment file type (can be lpMapiFileTagExt) */
} MapiFileDescA, FAR * lpMapiFileDescA;

#ifdef  WIN32
typedef struct
{
    ULONG ulReserved;            /* Reserved for future use (must be 0)     */
    ULONG flFlags;               /* Flags                                   */
    ULONG nPosition;             /* character in text to be replaced by attachment */
    LPWSTR lpszPathName;         /* Full path name of attachment file       */
    LPWSTR lpszFileName;         /* Original file name (optional)           */
    LPVOID lpFileType;           /* Attachment file type (can be lpMapiFileTagExt) */
} MapiFileDescW, FAR * lpMapiFileDescW;
#endif  /* WIN32 */

#ifdef  UNICODE
#define MapiFileDesc MapiFileDescW
#define lpMapiFileDesc lpMapiFileDescW
#else
#define MapiFileDesc MapiFileDescA
#define lpMapiFileDesc lpMapiFileDescA
#endif  

#define MAPI_OLE                0x00000001
#define MAPI_OLE_STATIC         0x00000002


typedef struct
{
    ULONG ulReserved;           /* Reserved, must be zero.                  */
    ULONG cbTag;                /* Size (in bytes) of                       */
    LPBYTE lpTag;               /* X.400 OID for this attachment type       */
    ULONG cbEncoding;           /* Size (in bytes) of                       */
    LPBYTE lpEncoding;          /* X.400 OID for this attachment's encoding */
} MapiFileTagExt, FAR *lpMapiFileTagExt;


typedef struct
{
    ULONG ulReserved;           /* Reserved for future use                  */
    ULONG ulRecipClass;         /* Recipient class                          */
                                /* MAPI_TO, MAPI_CC, MAPI_BCC, MAPI_ORIG    */
    LPSTR lpszName;             /* Recipient name                           */
    LPSTR lpszAddress;          /* Recipient address (optional)             */
    ULONG ulEIDSize;            /* Count in bytes of size of pEntryID       */
    LPVOID lpEntryID;           /* System-specific recipient reference      */
} MapiRecipDescA, FAR * lpMapiRecipDescA;

#ifdef  WIN32
typedef struct
{
    ULONG ulReserved;           /* Reserved for future use                  */
    ULONG ulRecipClass;         /* Recipient class                          */
                                /* MAPI_TO, MAPI_CC, MAPI_BCC, MAPI_ORIG    */
    LPWSTR lpszName;            /* Recipient name                           */
    LPWSTR lpszAddress;         /* Recipient address (optional)             */
    ULONG ulEIDSize;            /* Count in bytes of size of pEntryID       */
    LPVOID lpEntryID;           /* System-specific recipient reference      */
} MapiRecipDescW, FAR * lpMapiRecipDescW;
#endif  /* WIN32 */

#ifdef  UNICODE
#define MapiRecipDesc MapiRecipDescW
#define lpMapiRecipDesc lpMapiRecipDescW
#else
#define MapiRecipDesc MapiRecipDescA
#define lpMapiRecipDesc lpMapiRecipDescA
#endif  

#ifndef MAPI_ORIG               /* also defined in mapix.h */
#define MAPI_ORIG   0           /* Recipient is message originator          */
#define MAPI_TO     1           /* Recipient is a primary recipient         */
#define MAPI_CC     2           /* Recipient is a copy recipient            */
#define MAPI_BCC    3           /* Recipient is blind copy recipient        */
#define MAPI_DISCRETE 0x10000000/* Recipient is a P1 resend recipient       */
#endif

typedef struct
{
    ULONG ulReserved;             /* Reserved for future use (M.B. 0)       */
    LPSTR lpszSubject;            /* Message Subject                        */
    LPSTR lpszNoteText;           /* Message Text                           */
    LPSTR lpszMessageType;        /* Message Class                          */
    LPSTR lpszDateReceived;       /* in YYYY/MM/DD HH:MM format             */
    LPSTR lpszConversationID;     /* conversation thread ID                 */
    FLAGS flFlags;                /* unread,return receipt                  */
    lpMapiRecipDesc lpOriginator; /* Originator descriptor                  */
    ULONG nRecipCount;            /* Number of recipients                   */
    lpMapiRecipDesc lpRecips;     /* Recipient descriptors                  */
    ULONG nFileCount;             /* # of file attachments                  */
    lpMapiFileDesc lpFiles;       /* Attachment descriptors                 */
} MapiMessageA, FAR * lpMapiMessageA;

#ifdef  WIN32
typedef struct
{
    ULONG ulReserved;             /* Reserved for future use (M.B. 0)       */
    LPWSTR lpszSubject;           /* Message Subject                        */
    LPWSTR lpszNoteText;          /* Message Text                           */
    LPWSTR lpszMessageType;       /* Message Class                          */
    LPWSTR lpszDateReceived;      /* in YYYY/MM/DD HH:MM format             */
    LPWSTR lpszConversationID;    /* conversation thread ID                 */
    FLAGS flFlags;                /* unread,return receipt                  */
    lpMapiRecipDesc lpOriginator; /* Originator descriptor                  */
    ULONG nRecipCount;            /* Number of recipients                   */
    lpMapiRecipDesc lpRecips;     /* Recipient descriptors                  */
    ULONG nFileCount;             /* # of file attachments                  */
    lpMapiFileDesc lpFiles;       /* Attachment descriptors                 */
} MapiMessageW, FAR * lpMapiMessageW;
#endif  /* WIN32 */

#ifdef  UNICODE
#define MapiMessage MapiMessageW
#define lpMapiMessage lpMapiMessageW
#else
#define MapiMessage MapiMessageA
#define lpMapiMessage lpMapiMessageA
#endif  

#define MAPI_UNREAD             0x00000001
#define MAPI_RECEIPT_REQUESTED  0x00000002
#define MAPI_SENT               0x00000004


/*
 *  Entry points.
 */

/*
 *  flFlags values for Simple MAPI entry points. All documented flags are
 *  shown for each call. Duplicates are commented out but remain present
 *  for every call.
 */

/* MAPILogon() flags.       */

#define MAPI_LOGON_UI           0x00000001  /* Display logon UI             */
#ifndef MAPI_PASSWORD_UI
#define MAPI_PASSWORD_UI        0x00020000  /* prompt for password only     */
#endif
#define MAPI_NEW_SESSION        0x00000002  /* Don't use shared session     */
#define MAPI_FORCE_DOWNLOAD     0x00001000  /* Get new mail before return   */
#define MAPI_ALLOW_OTHERS       0x00000008  /* Make this a shared session   */
#define MAPI_EXPLICIT_PROFILE   0x00000010  /* Don't use default profile    */
#define MAPI_EXTENDED           0x00000020  /* Extended MAPI Logon          */
#define MAPI_USE_DEFAULT        0x00000040  /* Use default profile in logon */

#define MAPI_SIMPLE_DEFAULT (MAPI_LOGON_UI | MAPI_FORCE_DOWNLOAD | MAPI_ALLOW_OTHERS)
#define MAPI_SIMPLE_EXPLICIT (MAPI_NEW_SESSION | MAPI_FORCE_DOWNLOAD | MAPI_EXPLICIT_PROFILE)

/* MAPILogoff() flags.      */

#define MAPI_LOGOFF_SHARED      0x00000001  /* Close all shared sessions    */
#define MAPI_LOGOFF_UI          0x00000002  /* It's OK to present UI        */

/* MAPISendMail() flags.    */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */

#ifndef MAPI_DIALOG             /* also defined in property.h */
#define MAPI_DIALOG             0x00000008  /* Display a send note UI       */
#endif
/*# define MAPI_USE_DEFAULT     0x00000040     Use default profile in logon */

/* MAPIFindNext() flags.    */

#define MAPI_UNREAD_ONLY        0x00000020  /* Only unread messages         */
#define MAPI_GUARANTEE_FIFO     0x00000100  /* use date order               */
#define MAPI_LONG_MSGID         0x00004000  /* allow 512 char returned ID   */

/* MAPIReadMail() flags.    */

#define MAPI_PEEK               0x00000080  /* Do not mark as read.         */
#define MAPI_SUPPRESS_ATTACH    0x00000800  /* header + body, no files      */
#define MAPI_ENVELOPE_ONLY      0x00000040  /* Only header information      */
#define MAPI_BODY_AS_FILE       0x00000200

/* MAPISaveMail() flags.    */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */
/* #define MAPI_LONG_MSGID      0x00004000  /* allow 512 char returned ID   */

/* MAPIAddress() flags.     */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */

/* MAPIDetails() flags.     */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */
#define MAPI_AB_NOMODIFY        0x00000400  /* Don't allow mods of AB entries */

/* MAPIResolveName() flags. */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */
/* #define MAPI_DIALOG          0x00000008     Prompt for choices if ambiguous */
/* #define MAPI_AB_NOMODIFY     0x00000400     Don't allow mods of AB entries */

#ifndef MAPILogon

typedef ULONG (FAR PASCAL MAPILOGONA)(
    ULONG ulUIParam,
    LPSTR lpszProfileName,
    LPSTR lpszPassword,
    FLAGS flFlags,
    ULONG ulReserved,
    LPLHANDLE lplhSession
);
typedef MAPILOGONA FAR *LPMAPILOGONA;

MAPILOGONA MAPILogonA;

#ifdef WIN32
typedef ULONG (FAR PASCAL MAPILOGONW)(
    ULONG ulUIParam,
    LPWSTR lpszProfileName,
    LPWSTR lpszPassword,
    FLAGS flFlags,
    ULONG ulReserved,
    LPLHANDLE lplhSession
);
typedef MAPILOGONW FAR *LPMAPILOGONW;

MAPILOGONW MAPILogonW;
#endif

#ifdef UNICODE
#define MAPILogon MAPILogonW
#else
#define MAPILogon MAPILogonA
#endif

#endif  /* MAPILogon */

ULONG FAR PASCAL MAPILogoff(LHANDLE lhSession, ULONG ulUIParam, FLAGS flFlags,
                            ULONG ulReserved);

ULONG FAR PASCAL MAPISendMailA(LHANDLE lhSession, ULONG ulUIParam,
                              lpMapiMessageA lpMessage, FLAGS flFlags,
                              ULONG ulReserved);

#ifdef  WIN32
ULONG FAR PASCAL MAPISendMailW(LHANDLE lhSession, ULONG ulUIParam,
                              lpMapiMessageW lpMessage, FLAGS flFlags,
                              ULONG ulReserved);
#endif  

#ifdef UNICODE
#define MAPISendMail MAPISendMailW
#else
#define MAPISendMail MAPISendMailA
#endif

ULONG FAR PASCAL MAPISendDocumentsA(ULONG ulUIParam, LPSTR lpszDelimChar,
                                   LPSTR lpszFilePaths, LPSTR lpszFileNames,
                                   ULONG ulReserved);

#ifdef  WIN32
ULONG FAR PASCAL MAPISendDocumentsW(ULONG ulUIParam, LPWSTR lpszDelimChar,
                                   LPWSTR lpszFilePaths, LPWSTR lpszFileNames,
                                   ULONG ulReserved);
#endif  

#ifdef  UNICODE
#define MAPISendDocuments MAPISendDocumentsW
#else
#define MAPISendDocuments MAPISendDocumentsA
#endif  

ULONG FAR PASCAL MAPIFindNextA(LHANDLE lhSession, ULONG ulUIParam,
                              LPSTR lpszMessageType, LPSTR lpszSeedMessageID,
                              FLAGS flFlags, ULONG ulReserved,
                              LPSTR lpszMessageID);

#ifdef  WIN32
ULONG FAR PASCAL MAPIFindNextW(LHANDLE lhSession, ULONG ulUIParam,
                              LPWSTR lpszMessageType, LPWSTR lpszSeedMessageID,
                              FLAGS flFlags, ULONG ulReserved,
                              LPWSTR lpszMessageID);
#endif  

#ifdef  UNICODE
#define MAPIFindNext MAPIFindNextW
#else
#define MAPIFindNext MAPIFindNextA
#endif  

ULONG FAR PASCAL MAPIReadMailA(LHANDLE lhSession, ULONG ulUIParam,
                              LPSTR lpszMessageID, FLAGS flFlags,
                              ULONG ulReserved, lpMapiMessageA FAR *lppMessage);

#ifdef  WIN32
ULONG FAR PASCAL MAPIReadMailW(LHANDLE lhSession, ULONG ulUIParam,
                              LPWSTR lpszMessageID, FLAGS flFlags,
                              ULONG ulReserved, lpMapiMessageW FAR *lppMessage);
#endif  

#ifdef  UNICODE
#define MAPIReadMail MAPIReadMailW
#else
#define MAPIReadMail MAPIReadMailA
#endif  

ULONG FAR PASCAL MAPISaveMailA(LHANDLE lhSession, ULONG ulUIParam,
                              lpMapiMessageA lpMessage, FLAGS flFlags,
                              ULONG ulReserved, LPSTR lpszMessageID);

#ifdef  WIN32
ULONG FAR PASCAL MAPISaveMailW(LHANDLE lhSession, ULONG ulUIParam,
                              lpMapiMessageW lpMessage, FLAGS flFlags,
                              ULONG ulReserved, LPWSTR lpszMessageID);
#endif  

#ifdef  UNICODE
#define MAPISaveMail MAPISaveMailW
#else
#define MAPISaveMail MAPISaveMailA
#endif  

ULONG FAR PASCAL MAPIDeleteMailA(LHANDLE lhSession, ULONG ulUIParam,
                                LPSTR lpszMessageID, FLAGS flFlags,
                                ULONG ulReserved);

#ifdef  WIN32
ULONG FAR PASCAL MAPIDeleteMailW(LHANDLE lhSession, ULONG ulUIParam,
                                LPWSTR lpszMessageID, FLAGS flFlags,
                                ULONG ulReserved);
#endif  

#ifdef  UNICODE
#define MAPIDeleteMail MAPIDeleteMailW
#else
#define MAPIDeleteMail MAPIDeleteMailA
#endif  

ULONG FAR PASCAL MAPIFreeBuffer(LPVOID pv);

ULONG FAR PASCAL MAPIAddressA(LHANDLE lhSession, ULONG ulUIParam,
                    LPSTR lpszCaption, ULONG nEditFields,
                    LPSTR lpszLabels, ULONG nRecips,
                    lpMapiRecipDescA lpRecips, FLAGS flFlags, ULONG ulReserved,
                    LPULONG lpnNewRecips, lpMapiRecipDescA FAR *lppNewRecips);

#ifdef  WIN32
ULONG FAR PASCAL MAPIAddressW(LHANDLE lhSession, ULONG ulUIParam,
                    LPWSTR lpszCaption, ULONG nEditFields,
                    LPWSTR lpszLabels, ULONG nRecips,
                    lpMapiRecipDescW lpRecips, FLAGS flFlags, ULONG ulReserved,
                    LPULONG lpnNewRecips, lpMapiRecipDescW FAR *lppNewRecips);
#endif  

#ifdef  UNICODE
#define MAPIAddress MAPIAddressW
#else
#define MAPIAddress MAPIAddressA
#endif  

ULONG FAR PASCAL MAPIDetailsA(LHANDLE lhSession, ULONG ulUIParam,
                    lpMapiRecipDescA lpRecip, FLAGS flFlags, ULONG ulReserved);

#ifdef  WIN32
ULONG FAR PASCAL MAPIDetailsW(LHANDLE lhSession, ULONG ulUIParam,
                    lpMapiRecipDescW lpRecip, FLAGS flFlags, ULONG ulReserved);
#endif  

#ifdef  UNICODE
#define MAPIDetails MAPIDetailsW
#else
#define MAPIDetails MAPIDetailsA
#endif  

ULONG FAR PASCAL MAPIResolveNameA(LHANDLE lhSession, ULONG ulUIParam,
                        LPSTR lpszName, FLAGS flFlags,
                        ULONG ulReserved, lpMapiRecipDescA FAR *lppRecip);

#ifdef  WIN32
ULONG FAR PASCAL MAPIResolveNameW(LHANDLE lhSession, ULONG ulUIParam,
                        LPWSTR lpszName, FLAGS flFlags,
                        ULONG ulReserved, lpMapiRecipDescW FAR *lppRecip);
#endif  

#ifdef  UNICODE
#define MAPIResolveName MAPIResolveNameW
#else
#define MAPIResolveName MAPIResolveNameA
#endif  


#ifndef SUCCESS_SUCCESS
#define SUCCESS_SUCCESS                 0
#endif
#define MAPI_USER_ABORT                 1
#define MAPI_E_USER_ABORT               MAPI_USER_ABORT
#define MAPI_E_FAILURE                  2
#define MAPI_E_LOGON_FAILURE            3
#define MAPI_E_LOGIN_FAILURE            MAPI_E_LOGON_FAILURE
#define MAPI_E_DISK_FULL                4
#define MAPI_E_INSUFFICIENT_MEMORY      5
#define MAPI_E_ACCESS_DENIED            6
#define MAPI_E_TOO_MANY_SESSIONS        8
#define MAPI_E_TOO_MANY_FILES           9
#define MAPI_E_TOO_MANY_RECIPIENTS      10
#define MAPI_E_ATTACHMENT_NOT_FOUND     11
#define MAPI_E_ATTACHMENT_OPEN_FAILURE  12
#define MAPI_E_ATTACHMENT_WRITE_FAILURE 13
#define MAPI_E_UNKNOWN_RECIPIENT        14
#define MAPI_E_BAD_RECIPTYPE            15
#define MAPI_E_NO_MESSAGES              16
#define MAPI_E_INVALID_MESSAGE          17
#define MAPI_E_TEXT_TOO_LARGE           18
#define MAPI_E_INVALID_SESSION          19
#define MAPI_E_TYPE_NOT_SUPPORTED       20
#define MAPI_E_AMBIGUOUS_RECIPIENT      21
#define MAPI_E_AMBIG_RECIP              MAPI_E_AMBIGUOUS_RECIPIENT
#define MAPI_E_MESSAGE_IN_USE           22
#define MAPI_E_NETWORK_FAILURE          23
#define MAPI_E_INVALID_EDITFIELDS       24
#define MAPI_E_INVALID_RECIPS           25
#define MAPI_E_NOT_SUPPORTED            26

#ifdef  __cplusplus
}       /*  extern "C" */
#endif

#endif /* MAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\oharestr.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//	OHARESTR.H - string defines for O'Hare components
//			
//

//	HISTORY:
//	
//	3/10/95		jeremys		Created.
//


#ifndef _OHARESTR_H_
#define _OHARESTR_H_

// path to RNA values (under HKEY_CURRENT_USER)
#define REGSTR_PATH_REMOTEACCESS	"RemoteAccess"

// string value under HKCU\REGSTR_PATH_REMOTEACCESS that contains name of
// connectoid used to connect to internet
#define REGSTR_VAL_INTERNETPROFILE	"InternetProfile"
#define REGSTR_VAL_BKUPINTERNETPROFILE	"BackupInternetProfile"

// path to global internet settings (also under HKEY_CURRENT_USER)
#define REGSTR_PATH_INTERNET_SETTINGS REGSTR_PATH_SETUP "\\Internet Settings"

// values under HKCY\REGSTR_PATH_INTERNET_SETTINGS

// 4-byte REG_BINARY, autodialing is enabled if this value is present and
// non-zero, disabled otherwise
#define REGSTR_VAL_ENABLEAUTODIAL 		"EnableAutodial"
#define REGSTR_VAL_ENABLEAUTODISCONNECT	"EnableAutodisconnect"
#define REGSTR_VAL_ENABLESECURITYCHECK	"EnableSecurityCheck"

// 4-byte REG_BINARY containing number of minutes of idle time to allow
// before autodisconnect.  Autodisconnect is disabled if this value is zero
// or not present.
#define REGSTR_VAL_DISCONNECTIDLETIME	"DisconnectIdleTime"

// class name for window to receive Winsock activity messages
#define AUTODIAL_MONITOR_CLASS_NAME	"MS_AutodialMonitor"

// name of connectoid-specific autodial handler dll and function
#define REGSTR_VAL_AUTODIALDLLNAME		"AutodialDllName"
#define REGSTR_VAL_AUTODIALFCNNAME		"AutodialFcnName"

// proxy settings
#define REGSTR_VAL_PROXYENABLE          "ProxyEnable"
#define REGSTR_VAL_PROXYSERVER          "ProxyServer"
#define REGSTR_VAL_PROXYOVERRIDE        "ProxyOverride"

// access medium (modem, LAN, [etc?])
#define REGSTR_VAL_ACCESSMEDIUM			"AccessMedium"

// access type (MSN, other)
#define REGSTR_VAL_ACCESSTYPE			"AccessType"

#endif // _OHARESTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\newshk.cpp ===
/*
 * newshk.cpp - INewShortcutHook implementation for URL class.
 */


/* Headers
 **********/

#include "project.hpp"
#pragma hdrstop

#include "resource.h"

#include <mluisupp.h>

extern "C"{
extern BOOL  lPathYetAnotherMakeUniqueNameA(LPSTR,LPCSTR,LPCSTR,LPCSTR);
}

/********************************** Methods **********************************/


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE InternetShortcut::SetReferent(PCSTR pcszReferent,
                                                        HWND hwndParent)
{
   HRESULT hr;
   PSTR pszTranslatedURL;

   DebugEntry(InternetShortcut::SetReferent);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRING_PTR(pcszReferent, CSTR));
   ASSERT(IS_VALID_HANDLE(hwndParent, WND));

   hr = TranslateURL(pcszReferent, TRANSLATEURL_FL_GUESS_PROTOCOL,
                     &pszTranslatedURL);

   if (SUCCEEDED(hr))
   {
      PCSTR pcszURLToUse;

      pcszURLToUse = (hr == S_OK) ? pszTranslatedURL : pcszReferent;

      hr = ValidateURL(pcszURLToUse);

      if (hr == S_OK)
         hr = SetURL(pcszURLToUse, 0);

      if (pszTranslatedURL)
      {
         LocalFree(pszTranslatedURL);
         pszTranslatedURL = NULL;
      }
   }

   if (hr == S_OK)
      TRACE_OUT(("InternetShortcut::SetReferent(): Set referent %s as URL %s.",
                 pcszReferent,
                 m_pszURL));
   else
   {
      ASSERT(FAILED(hr));

      switch (hr)
      {
         case URL_E_INVALID_SYNTAX:
         case URL_E_UNREGISTERED_PROTOCOL:
            hr = S_FALSE;
            break;

         default:
            break;
      }

      TRACE_OUT(("InternetShortcut::SetReferent(): Failed to set referent to %s.",
                 pcszReferent));
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::SetReferent, hr);

   return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


HRESULT STDMETHODCALLTYPE InternetShortcut::GetReferent(PSTR pszReferent,
                                                        int ncReferentBufLen)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::GetReferent);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszReferent, STR, ncReferentBufLen));

   if (m_pszURL)
   {
      if (lstrlen(m_pszURL) < ncReferentBufLen)
      {
         lstrcpy(pszReferent, m_pszURL);

         hr = S_OK;

         TRACE_OUT(("InternetShortcut::GetReferent(): Returning referent %s.",
                    pszReferent));
      }
      else
         hr = E_FAIL;
   }
   else
      hr = S_FALSE;

   if (hr != S_OK)
   {
      if (ncReferentBufLen > 0)
         *pszReferent = '\0';
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT((hr == S_OK &&
           IS_VALID_STRING_PTR(pszReferent, STR) &&
           EVAL(lstrlen(pszReferent) < ncReferentBufLen)) ||
          ((hr == S_FALSE ||
            hr == E_FAIL) &&
           EVAL(! ncReferentBufLen ||
                ! *pszReferent)));

   DebugExitHRESULT(InternetShortcut::GetReferent, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::SetFolder(PCSTR pcszFolder)
{
   HRESULT hr;
   PSTR pszFolderCopy;

   DebugEntry(InternetShortcut::SetFolder);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IsPathDirectory(pcszFolder));

   // (+ 1) for null terminator.
   pszFolderCopy = new(char[lstrlen(pcszFolder) + 1]);

   if (pszFolderCopy)
   {
      lstrcpy(pszFolderCopy, pcszFolder);

      if (m_pszFolder)
         delete m_pszFolder;

      m_pszFolder = pszFolderCopy;

      hr = S_OK;

      TRACE_OUT(("InternetShortcut::SetFolder(): Set folder to %s.",
                 m_pszFolder));
   }
   else
      hr = E_OUTOFMEMORY;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::SetFolder, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::GetFolder(PSTR pszFolder,
                                                      int ncFolderBufLen)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::GetFolder);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszFolder, STR, ncFolderBufLen));

   if (m_pszFolder)
   {
      if (lstrlen(m_pszFolder) < ncFolderBufLen)
      {
         lstrcpy(pszFolder, m_pszFolder);

         hr = S_OK;

         TRACE_OUT(("InternetShortcut::GetFolder(): Returning folder %s.",
                    pszFolder));
      }
      else
         hr = E_FAIL;
   }
   else
      hr = S_FALSE;

   if (hr != S_OK)
   {
      if (ncFolderBufLen > 0)
         *pszFolder = '\0';
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT((hr == S_OK &&
           IS_VALID_STRING_PTR(pszFolder, STR) &&
           EVAL(lstrlen(pszFolder) < ncFolderBufLen)) ||
          ((hr == S_FALSE ||
            hr == E_FAIL) &&
           EVAL(! ncFolderBufLen ||
                ! *pszFolder)));

   DebugExitHRESULT(InternetShortcut::GetFolder, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::GetName(PSTR pszName,
                                                    int ncNameBufLen)
{
   HRESULT hr = E_FAIL;
   char rgchShortName[MAX_PATH_LEN];

   DebugEntry(InternetShortcut::GetName);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszName, STR, ncNameBufLen));

   hr = E_FAIL;

   if (MLLoadStringA(IDS_SHORT_NEW_INTERNET_SHORTCUT,
                  rgchShortName, sizeof(rgchShortName)))
   {
      char rgchLongName[MAX_PATH_LEN];

      if (MLLoadStringA(IDS_NEW_INTERNET_SHORTCUT,
                     rgchLongName, sizeof(rgchLongName)))
      {
         char rgchCurDir[MAX_PATH_LEN];
         PCSTR pcszFolderToUse;

         // Use current directory if m_pszFolder has not been set.

         pcszFolderToUse = m_pszFolder;

         if (! pcszFolderToUse)
         {
            if (GetCurrentDirectory(sizeof(rgchCurDir), rgchCurDir) > 0)
               pcszFolderToUse = rgchCurDir;
         }

         if (pcszFolderToUse)
         {
            char rgchUniqueName[MAX_PATH_LEN];

            if (lPathYetAnotherMakeUniqueNameA(rgchUniqueName, pcszFolderToUse,
                                             rgchShortName, rgchLongName))
            {
               PSTR pszFileName;
               PSTR pszRemoveExt;

               pszFileName = (PSTR)ExtractFileName(rgchUniqueName);
               pszRemoveExt = (PSTR)ExtractExtension(pszFileName);
               *pszRemoveExt = '\0';

               if (lstrlen(pszFileName) < ncNameBufLen)
               {
                  lstrcpy(pszName, pszFileName);

                  hr = S_OK;
               }
            }
         }
      }
   }

   if (hr == S_OK) {
      TRACE_OUT(("InternetShortcut::GetName(): Returning %s.",
                 pszName));
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT((hr == S_OK &&
           IS_VALID_STRING_PTR(pszName, STR) &&
           EVAL(lstrlen(pszName) < ncNameBufLen)) ||
          (hr == E_FAIL &&
           (! ncNameBufLen ||
            ! *pszName)));

   DebugExitHRESULT(InternetShortcut::GetName, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::GetExtension(PSTR pszExtension,
                                                         int ncExtensionBufLen)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::GetExtension);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszExtension, STR, ncExtensionBufLen));

   if (lstrlen(g_cszURLExt) < ncExtensionBufLen)
   {
      lstrcpy(pszExtension, g_cszURLExt);

      hr = S_OK;

      TRACE_OUT(("InternetShortcut::GetExtension(): Returning extension %s.",
                 pszExtension));
   }
   else
   {
      if (ncExtensionBufLen > 0)
         *pszExtension = '\0';

      hr = E_FAIL;
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT((hr == S_OK &&
           IS_VALID_STRING_PTR(pszExtension, STR) &&
           EVAL(lstrlen(pszExtension) < ncExtensionBufLen)) ||
          (hr == E_FAIL &&
           EVAL(! ncExtensionBufLen ||
                ! *pszExtension)));

   DebugExitHRESULT(InternetShortcut::GetExtension, hr);

   return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\olevalid.c ===
/*
 * olevalid.c - OLE validation functions module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include <intshcut.h>

#include "olestock.h"
#include "olevalid.h"

#ifdef DEBUG


/****************************** Public Functions *****************************/


PUBLIC_CODE BOOL IsValidPCGUID(PCGUID pcguid)
{
   /* All values are valid GUIDs. */

   return(IS_VALID_READ_PTR(pcguid, CGUID));
}


PUBLIC_CODE BOOL IsValidPCCLSID(PCCLSID pcclsid)
{
   return(IS_VALID_STRUCT_PTR(pcclsid, CGUID));
}


PUBLIC_CODE BOOL IsValidPCIID(PCIID pciid)
{
   return(IS_VALID_STRUCT_PTR(pciid, CGUID));
}


PUBLIC_CODE BOOL IsValidPCDVTARGETDEVICE(PCDVTARGETDEVICE pcdvtd)
{
   /* FEATURE: Validate remaining fields here. */

   return(IS_VALID_READ_PTR(&(pcdvtd->tdSize), DWORD) &&
          IS_VALID_READ_BUFFER_PTR(pcdvtd, DVTARGETDEVICE, pcdvtd->tdSize));
}


PUBLIC_CODE BOOL IsValidPCFORMATETC(PCFORMATETC pcfe)
{
   /* FEATURE: Validate structure fields. */

   return(IS_VALID_READ_PTR(pcfe, CFORMATETC));
}


PUBLIC_CODE BOOL IsValidStgMediumType(DWORD tymed)
{
   BOOL bResult;

   switch (tymed)
   {
      case TYMED_HGLOBAL:
      case TYMED_FILE:
      case TYMED_ISTREAM:
      case TYMED_ISTORAGE:
      case TYMED_GDI:
      case TYMED_MFPICT:
      case TYMED_ENHMF:
      case TYMED_NULL:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT(("IsValidStgMediumType(): Invalid storage medium type %lu.",
                    tymed));
         break;
   }

   return(bResult);
}


PUBLIC_CODE BOOL IsValidPCSTGMEDIUM(PCSTGMEDIUM pcstgmed)
{
   /* FEATURE: Validate u union field. */

   return(IS_VALID_READ_PTR(pcstgmed, CSTGMEDIUM) &&
          IsValidStgMediumType(pcstgmed->tymed) &&
          (! pcstgmed->pUnkForRelease ||
           IS_VALID_INTERFACE_PTR(pcstgmed->pUnkForRelease, IUnknown)));
}


PUBLIC_CODE BOOL IsValidREFIID(REFIID riid)
{
   return(IS_VALID_STRUCT_PTR(riid, CIID));
}


PUBLIC_CODE BOOL IsValidREFCLSID(REFCLSID rclsid)
{
   return(IS_VALID_STRUCT_PTR(rclsid, CCLSID));
}


PUBLIC_CODE BOOL IsValidPCINTERFACE(PCVOID pcvi)
{
   return(IS_VALID_READ_PTR((FARPROC *)pcvi, FARPROC) &&
          IS_VALID_CODE_PTR(*((FARPROC *)pcvi), Method));
}


PUBLIC_CODE BOOL IsValidPCIAdviseSink(PCIAdviseSink pcias)
{
   return(IS_VALID_READ_PTR(pcias, CIAdviseSink) &&
          IS_VALID_READ_PTR(pcias->lpVtbl, sizeof(*(pcias->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcias, IUnknown) &&
          IS_VALID_METHOD(pcias, OnDataChange) &&
          IS_VALID_METHOD(pcias, OnViewChange) &&
          IS_VALID_METHOD(pcias, OnRename) &&
          IS_VALID_METHOD(pcias, OnSave) &&
          IS_VALID_METHOD(pcias, OnClose));
}


PUBLIC_CODE BOOL IsValidPCIClassFactory(PCIClassFactory pcicf)
{
   return(IS_VALID_READ_PTR(pcicf, CIClassFactory) &&
          IS_VALID_READ_PTR(pcicf->lpVtbl, sizeof(*(pcicf->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcicf, IUnknown) &&
          IS_VALID_METHOD(pcicf, CreateInstance) &&
          IS_VALID_METHOD(pcicf, LockServer));
}


PUBLIC_CODE BOOL IsValidPCIDataObject(PCIDataObject pcido)
{
   return(IS_VALID_READ_PTR(pcido, CIDataObject) &&
          IS_VALID_READ_PTR(pcido->lpVtbl, sizeof(*(pcido->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcido, IUnknown) &&
          IS_VALID_METHOD(pcido, GetData) &&
          IS_VALID_METHOD(pcido, GetDataHere) &&
          IS_VALID_METHOD(pcido, QueryGetData) &&
          IS_VALID_METHOD(pcido, GetCanonicalFormatEtc) &&
          IS_VALID_METHOD(pcido, SetData) &&
          IS_VALID_METHOD(pcido, EnumFormatEtc) &&
          IS_VALID_METHOD(pcido, DAdvise) &&
          IS_VALID_METHOD(pcido, DUnadvise) &&
          IS_VALID_METHOD(pcido, EnumDAdvise));
}


PUBLIC_CODE BOOL IsValidPCIDropSource(PCIDropSource pcids)
{
   return(IS_VALID_READ_PTR(pcids, CIDataObject) &&
          IS_VALID_READ_PTR(pcids->lpVtbl, sizeof(*(pcids->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcids, IUnknown) &&
          IS_VALID_METHOD(pcids, QueryContinueDrag) &&
          IS_VALID_METHOD(pcids, GiveFeedback));
}


PUBLIC_CODE BOOL IsValidPCIDropTarget(PCIDropTarget pcidt)
{
   return(IS_VALID_READ_PTR(pcidt, CIDataObject) &&
          IS_VALID_READ_PTR(pcidt->lpVtbl, sizeof(*(pcidt->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcidt, IUnknown) &&
          IS_VALID_METHOD(pcidt, DragEnter) &&
          IS_VALID_METHOD(pcidt, DragOver) &&
          IS_VALID_METHOD(pcidt, DragLeave) &&
          IS_VALID_METHOD(pcidt, Drop));
}


PUBLIC_CODE BOOL IsValidPCIEnumFORMATETC(PCIEnumFORMATETC pciefe)
{
   return(IS_VALID_READ_PTR(pciefe, CIEnumFORMATETC) &&
          IS_VALID_READ_PTR(pciefe->lpVtbl, sizeof(*(pciefe->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pciefe, IUnknown) &&
          IS_VALID_METHOD(pciefe, Next) &&
          IS_VALID_METHOD(pciefe, Skip) &&
          IS_VALID_METHOD(pciefe, Reset) &&
          IS_VALID_METHOD(pciefe, Clone));
}


PUBLIC_CODE BOOL IsValidPCIEnumSTATDATA(PCIEnumSTATDATA pciesd)
{
   return(IS_VALID_READ_PTR(pciesd, CIDataObject) &&
          IS_VALID_READ_PTR(pciesd->lpVtbl, sizeof(*(pciesd->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pciesd, IUnknown) &&
          IS_VALID_METHOD(pciesd, Next) &&
          IS_VALID_METHOD(pciesd, Skip) &&
          IS_VALID_METHOD(pciesd, Reset) &&
          IS_VALID_METHOD(pciesd, Clone));
}


PUBLIC_CODE BOOL IsValidPCIMalloc(PCIMalloc pcimalloc)
{
   return(IS_VALID_READ_PTR(pcimalloc, CIMalloc) &&
          IS_VALID_READ_PTR(pcimalloc->lpVtbl, sizeof(*(pcimalloc->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcimalloc, IUnknown) &&
          IS_VALID_METHOD(pcimalloc, Alloc) &&
          IS_VALID_METHOD(pcimalloc, Realloc) &&
          IS_VALID_METHOD(pcimalloc, Free) &&
          IS_VALID_METHOD(pcimalloc, GetSize) &&
          IS_VALID_METHOD(pcimalloc, DidAlloc) &&
          IS_VALID_METHOD(pcimalloc, HeapMinimize));
}


PUBLIC_CODE BOOL IsValidPCIMoniker(PCIMoniker pcimk)
{
   return(IS_VALID_READ_PTR(pcimk, CIMoniker) &&
          IS_VALID_READ_PTR(pcimk->lpVtbl, sizeof(*(pcimk->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIPersistStream)pcimk, IPersistStream) &&
          IS_VALID_METHOD(pcimk, BindToObject) &&
          IS_VALID_METHOD(pcimk, BindToStorage) &&
          IS_VALID_METHOD(pcimk, Reduce) &&
          IS_VALID_METHOD(pcimk, ComposeWith) &&
          IS_VALID_METHOD(pcimk, Enum) &&
          IS_VALID_METHOD(pcimk, IsEqual) &&
          IS_VALID_METHOD(pcimk, Hash) &&
          IS_VALID_METHOD(pcimk, IsRunning) &&
          IS_VALID_METHOD(pcimk, GetTimeOfLastChange) &&
          IS_VALID_METHOD(pcimk, Inverse) &&
          IS_VALID_METHOD(pcimk, CommonPrefixWith) &&
          IS_VALID_METHOD(pcimk, RelativePathTo) &&
          IS_VALID_METHOD(pcimk, GetDisplayName) &&
          IS_VALID_METHOD(pcimk, ParseDisplayName) &&
          IS_VALID_METHOD(pcimk, IsSystemMoniker));
}


PUBLIC_CODE BOOL IsValidPCIPersist(PCIPersist pcip)
{
   return(IS_VALID_READ_PTR(pcip, CIUnknown) &&
          IS_VALID_READ_PTR(pcip->lpVtbl, sizeof(*(pcip->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcip, IUnknown) &&
          IS_VALID_METHOD(pcip, GetClassID));
}


PUBLIC_CODE BOOL IsValidPCIPersistFile(PCIPersistFile pcipfile)
{
   return(IS_VALID_READ_PTR(pcipfile, CIPersistFile) &&
          IS_VALID_READ_PTR(pcipfile->lpVtbl, sizeof(*(pcipfile->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIPersist)pcipfile, IPersist) &&
          IS_VALID_METHOD(pcipfile, IsDirty) &&
          IS_VALID_METHOD(pcipfile, Load) &&
          IS_VALID_METHOD(pcipfile, Save) &&
          IS_VALID_METHOD(pcipfile, SaveCompleted) &&
          IS_VALID_METHOD(pcipfile, GetCurFile));
}


PUBLIC_CODE BOOL IsValidPCIPersistStorage(PCIPersistStorage pcipstg)
{
   return(IS_VALID_READ_PTR(pcipstg, CIPersistStorage) &&
          IS_VALID_READ_PTR(pcipstg->lpVtbl, sizeof(*(pcipstg->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIPersist)pcipstg, IPersist) &&
          IS_VALID_METHOD(pcipstg, IsDirty) &&
          IS_VALID_METHOD(pcipstg, InitNew) &&
          IS_VALID_METHOD(pcipstg, Load) &&
          IS_VALID_METHOD(pcipstg, Save) &&
          IS_VALID_METHOD(pcipstg, SaveCompleted) &&
          IS_VALID_METHOD(pcipstg, HandsOffStorage));
}


PUBLIC_CODE BOOL IsValidPCIPersistStream(PCIPersistStream pcipstr)
{
   return(IS_VALID_READ_PTR(pcipstr, CIPersistStream) &&
          IS_VALID_READ_PTR(pcipstr->lpVtbl, sizeof(*(pcipstr->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIPersist)pcipstr, IPersist) &&
          IS_VALID_METHOD(pcipstr, IsDirty) &&
          IS_VALID_METHOD(pcipstr, Load) &&
          IS_VALID_METHOD(pcipstr, Save) &&
          IS_VALID_METHOD(pcipstr, GetSizeMax));
}


PUBLIC_CODE BOOL IsValidPCIStorage(PCIStorage pcistg)
{
   return(IS_VALID_READ_PTR(pcistg, CIStorage) &&
          IS_VALID_READ_PTR(pcistg->lpVtbl, sizeof(*(pcistg->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcistg, IUnknown) &&
          IS_VALID_METHOD(pcistg, CreateStream) &&
          IS_VALID_METHOD(pcistg, OpenStream) &&
          IS_VALID_METHOD(pcistg, CreateStorage) &&
          IS_VALID_METHOD(pcistg, OpenStorage) &&
          IS_VALID_METHOD(pcistg, CopyTo) &&
          IS_VALID_METHOD(pcistg, MoveElementTo) &&
          IS_VALID_METHOD(pcistg, Commit) &&
          IS_VALID_METHOD(pcistg, Revert) &&
          IS_VALID_METHOD(pcistg, EnumElements) &&
          IS_VALID_METHOD(pcistg, DestroyElement) &&
          IS_VALID_METHOD(pcistg, RenameElement) &&
          IS_VALID_METHOD(pcistg, SetElementTimes) &&
          IS_VALID_METHOD(pcistg, SetClass) &&
          IS_VALID_METHOD(pcistg, SetStateBits) &&
          IS_VALID_METHOD(pcistg, Stat));
}


PUBLIC_CODE BOOL IsValidPCIStream(PCIStream pcistr)
{
   return(IS_VALID_READ_PTR(pcistr, CIStorage) &&
          IS_VALID_READ_PTR(pcistr->lpVtbl, sizeof(*(pcistr->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcistr, IUnknown) &&
          IS_VALID_METHOD(pcistr, Read) &&
          IS_VALID_METHOD(pcistr, Write) &&
          IS_VALID_METHOD(pcistr, Seek) &&
          IS_VALID_METHOD(pcistr, SetSize) &&
          IS_VALID_METHOD(pcistr, CopyTo) &&
          IS_VALID_METHOD(pcistr, Commit) &&
          IS_VALID_METHOD(pcistr, Revert) &&
          IS_VALID_METHOD(pcistr, LockRegion) &&
          IS_VALID_METHOD(pcistr, UnlockRegion) &&
          IS_VALID_METHOD(pcistr, Stat) &&
          IS_VALID_METHOD(pcistr, Clone));
}


PUBLIC_CODE BOOL IsValidPCIUnknown(PCIUnknown pciunk)
{
   return(IS_VALID_READ_PTR(pciunk, CIUnknown) &&
          IS_VALID_READ_PTR(pciunk->lpVtbl, sizeof(*(pciunk->lpVtbl))) &&
          IS_VALID_METHOD(pciunk, QueryInterface) &&
          IS_VALID_METHOD(pciunk, AddRef) &&
          IS_VALID_METHOD(pciunk, Release));
}


#ifdef __INTSHCUT_H__

PUBLIC_CODE BOOL IsValidPCIUniformResourceLocator(
                                             PCIUniformResourceLocator pciurl)
{
   return(IS_VALID_READ_PTR(pciurl, CIUniformResourceLocator) &&
          IS_VALID_READ_PTR(pciurl->lpVtbl, sizeof(*(pciurl->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pciurl, IUnknown) &&
          IS_VALID_METHOD(pciurl, SetURL) &&
          IS_VALID_METHOD(pciurl, GetURL) &&
          IS_VALID_METHOD(pciurl, InvokeCommand));
}

#endif   /* __INTSHCUT_H__ */

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\olestock.h ===
/*
 * olestock.h - Stock OLE header file.
 */


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Types
 ********/

/* IDs */

DECLARE_STANDARD_TYPES(GUID);
DECLARE_STANDARD_TYPES(CLSID);
DECLARE_STANDARD_TYPES(IID);

typedef FARPROC *Interface;
DECLARE_STANDARD_TYPES(Interface);

/* interfaces */

DECLARE_STANDARD_TYPES(IAdviseSink);
DECLARE_STANDARD_TYPES(IBindCtx);
DECLARE_STANDARD_TYPES(IClassFactory);
DECLARE_STANDARD_TYPES(IDataObject);
DECLARE_STANDARD_TYPES(IDropSource);
DECLARE_STANDARD_TYPES(IDropTarget);
DECLARE_STANDARD_TYPES(IEnumFORMATETC);
DECLARE_STANDARD_TYPES(IEnumSTATDATA);
DECLARE_STANDARD_TYPES(IMalloc);
DECLARE_STANDARD_TYPES(IMoniker);
DECLARE_STANDARD_TYPES(IPersist);
DECLARE_STANDARD_TYPES(IPersistFile);
DECLARE_STANDARD_TYPES(IPersistStorage);
DECLARE_STANDARD_TYPES(IPersistStream);
DECLARE_STANDARD_TYPES(IStorage);
DECLARE_STANDARD_TYPES(IStream);
DECLARE_STANDARD_TYPES(IUnknown);

/* structures */

DECLARE_STANDARD_TYPES(DVTARGETDEVICE);
DECLARE_STANDARD_TYPES(FORMATETC);
DECLARE_STANDARD_TYPES(STGMEDIUM);

/* advise flags */

typedef enum advise_flags
{
   ALL_ADVISE_FLAGS   = (ADVF_NODATA |
                         ADVF_PRIMEFIRST |
                         ADVF_ONLYONCE |
                         ADVF_DATAONSTOP |
                         ADVFCACHE_NOHANDLER |
                         ADVFCACHE_FORCEBUILTIN |
                         ADVFCACHE_ONSAVE)
}
ADVISE_FLAGS;

/* data transfer direction flags */

typedef enum datadir_flags
{
   ALL_DATADIR_FLAGS   = (DATADIR_GET |
                          DATADIR_SET)
}
DATADIR_FLAGS;

/* drop effects */

typedef enum drop_effects
{
   ALL_DROPEFFECT_FLAGS   = (DROPEFFECT_NONE |
                             DROPEFFECT_COPY |
                             DROPEFFECT_MOVE |
                             DROPEFFECT_LINK |
                             DROPEFFECT_SCROLL)
}
DROP_EFFECTS;

/* mouse message key states */

typedef enum mk_flags
{
   ALL_KEYSTATE_FLAGS      = (MK_LBUTTON |
                              MK_RBUTTON |
                              MK_SHIFT |
                              MK_CONTROL |
                              MK_MBUTTON)
}
MK_FLAGS;

/* medium types */

typedef enum tymeds
{
   ALL_TYMED_FLAGS         = (TYMED_HGLOBAL |
                              TYMED_FILE |
                              TYMED_ISTREAM |
                              TYMED_ISTORAGE |
                              TYMED_GDI |
                              TYMED_MFPICT |
                              TYMED_ENHMF)
}
TYMEDS;


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\pchcpp.cpp ===
/*
 * pchcpp.cpp - Precompiled header file source for URL Shell extension DLL.
 */


#include "project.hpp"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\pch.c ===
/*
 * pch.c - Precompiled header file source for URL Shell extension DLL.
 */


#include "project.h"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\olevalid.h ===
/*
 * olevalid.h - OLE validation functions description.
 */


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Macros
 *********/

/* method validation macro */

#define IS_VALID_METHOD(piface, mthd) \
   IS_VALID_CODE_PTR((piface)->lpVtbl->mthd, mthd)


/* Prototypes
 *************/

/* olevalid.c */

#ifdef DEBUG

extern BOOL IsValidPCGUID(PCGUID);
extern BOOL IsValidPCCLSID(PCCLSID);
extern BOOL IsValidPCIID(PCIID);
extern BOOL IsValidPCDVTARGETDEVICE(PCDVTARGETDEVICE);
extern BOOL IsValidPCFORMATETC(PCFORMATETC);
extern BOOL IsValidStgMediumType(DWORD);
extern BOOL IsValidPCSTGMEDIUM(PCSTGMEDIUM);
extern BOOL IsValidREFIID(REFIID);
extern BOOL IsValidREFCLSID(REFCLSID);
extern BOOL IsValidPCINTERFACE(PCVOID);
extern BOOL IsValidPCIAdviseSink(PCIAdviseSink);
extern BOOL IsValidPCIClassFactory(PCIClassFactory);
extern BOOL IsValidPCIDataObject(PCIDataObject);
extern BOOL IsValidPCIDropSource(PCIDropSource);
extern BOOL IsValidPCIDropTarget(PCIDropTarget);
extern BOOL IsValidPCIEnumFORMATETC(PCIEnumFORMATETC);
extern BOOL IsValidPCIEnumSTATDATA(PCIEnumSTATDATA);
extern BOOL IsValidPCIMalloc(PCIMalloc);
extern BOOL IsValidPCIMoniker(PCIMoniker);
extern BOOL IsValidPCIPersist(PCIPersist);
extern BOOL IsValidPCIPersistFile(PCIPersistFile);
extern BOOL IsValidPCIPersistStorage(PCIPersistStorage);
extern BOOL IsValidPCIPersistStream(PCIPersistStream);
extern BOOL IsValidPCIStorage(PCIStorage);
extern BOOL IsValidPCIStream(PCIStream);
extern BOOL IsValidPCIUnknown(PCIUnknown);

#ifdef __INTSHCUT_H__

extern BOOL IsValidPCIUniformResourceLocator(PCIUniformResourceLocator);

#endif   /* __INTSHCUT_H__ */

#endif   /* DEBUG */


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\openas.h ===
/*
 * openas.h - MyOpenAsDialog() definitions.
 */

#include "shellp.h"

/* Types
 ********/

/* OPENASINFO flags */

typedef enum openasinfo_flags
{
    /* Allow association registration. */

    OPENASINFO_FL_ALLOW_REGISTRATION   = 0x0001,

    /* Register extension. */

    OPENASINFO_FL_REGISTER_EXT         = 0x0002,

    /* Execute file after registering association. */

    OPENASINFO_FL_EXEC                 = 0x0004,

    /* flag combinations */

    ALL_OPENASINFO_FLAGS               = (OPENASINFO_FL_ALLOW_REGISTRATION |
                                          OPENASINFO_FL_REGISTER_EXT |
                                          OPENASINFO_FL_EXEC)
}
OPENASINFO_FLAGS;

DECLARE_STANDARD_TYPES(OPENASINFO);

/* Prototypes
 *************/

/* fsassoc.c */

/*
 * Success:
 *      S_OK            user requested file type be registered
 *      S_FALSE         user requested file type not be registered (one-shot)
 *
 * Failure:
 *      E_ABORT         user cancelled
 *      E_OUTOFMEMORY   out of memory
 */
extern HRESULT MyOpenAsDialog(HWND hwnd, POPENASINFO poainfo);

/* assoc.c. */

#ifdef DEBUG

extern BOOL IsValidPCOPENASINFO(PCOPENASINFO pcoainfo);

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\persist.cpp ===
/*
 * persist.cpp - IPersist, IPersistFile, and IPersistStream implementations for
 *               URL class.
 */


/* Headers
 **********/

#include "project.hpp"
#pragma hdrstop

#include "resource.h"

#include <mluisupp.h>

/* Global Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

extern const UINT g_ucMaxURLLen                    = 1024;

extern const char g_cszURLPrefix[]                 = "url:";
extern const UINT g_ucbURLPrefixLen                = sizeof(g_cszURLPrefix) - 1;

extern const char g_cszURLExt[]                    = ".url";
extern const char g_cszURLDefaultFileNamePrompt[]  = "*.url";

extern const char g_cszCRLF[]                      = "\r\n";

#pragma data_seg()


/* Module Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

// case-insensitive

PRIVATE_DATA const char s_cszInternetShortcutSection[] = "InternetShortcut";

PRIVATE_DATA const char s_cszURLKey[]              = "URL";
PRIVATE_DATA const char s_cszIconFileKey[]         = "IconFile";
PRIVATE_DATA const char s_cszIconIndexKey[]        = "IconIndex";
PRIVATE_DATA const char s_cszHotkeyKey[]           = "Hotkey";
PRIVATE_DATA const char s_cszWorkingDirectoryKey[] = "WorkingDirectory";
PRIVATE_DATA const char s_cszShowCmdKey[]          = "ShowCommand";

PRIVATE_DATA const UINT s_ucMaxIconIndexLen        = 1 + 10 + 1; // -2147483647
PRIVATE_DATA const UINT s_ucMaxHotkeyLen           = s_ucMaxIconIndexLen;
PRIVATE_DATA const UINT s_ucMaxShowCmdLen          = s_ucMaxIconIndexLen;

#pragma data_seg()


/***************************** Private Functions *****************************/


PRIVATE_CODE BOOL DeletePrivateProfileString(PCSTR pcszSection, PCSTR pcszKey,
                                             PCSTR pcszFile)
{
   ASSERT(IS_VALID_STRING_PTR(pcszSection, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszKey, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));

   return(WritePrivateProfileString(pcszSection, pcszKey, NULL, pcszFile));
}

#define SHDeleteIniString(pcszSection, pcszKey, pcszFile) \
           SHSetIniString(pcszSection, pcszKey, NULL, pcszFile)

PRIVATE_CODE HRESULT MassageURL(PSTR pszURL)
{
   HRESULT hr = E_FAIL;

   ASSERT(IS_VALID_STRING_PTR(pszURL, STR));

   TrimWhiteSpace(pszURL);

   PSTR pszBase = pszURL;
   PSTR psz;

   // Skip over any "url:" prefix.

   if (! lstrnicmp(pszBase, g_cszURLPrefix, g_ucbURLPrefixLen))
      pszBase += g_ucbURLPrefixLen;

   lstrcpy(pszURL, pszBase);
   hr = S_OK;

   TRACE_OUT(("MassageURL(): Massaged URL to %s.",
              pszURL));

   ASSERT(FAILED(hr) ||
          IS_VALID_STRING_PTR(pszURL, STR));

   return(hr);
}


PRIVATE_CODE HRESULT ReadURLFromFile(PCSTR pcszFile, PSTR *ppszURL)
{
   HRESULT hr;
   PSTR pszNewURL;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszURL, PSTR));

   *ppszURL = NULL;

   pszNewURL = new(char[g_ucMaxURLLen]);

   if (pszNewURL)
   {
      DWORD dwcValueLen;

      dwcValueLen = SHGetIniString(s_cszInternetShortcutSection,
                                   s_cszURLKey,
                                   pszNewURL, g_ucMaxURLLen, pcszFile);

      if (dwcValueLen > 0)
      {
         hr = MassageURL(pszNewURL);

         if (hr == S_OK)
         {
            PSTR pszShorterURL;

            // (+ 1) for null terminator.

            if (ReallocateMemory(pszNewURL, lstrlen(pszNewURL) + 1,
                                 (PVOID *)&pszShorterURL))
            {
               *ppszURL = pszShorterURL;

               hr = S_OK;
            }
            else
               hr = E_OUTOFMEMORY;
         }
      }
      else
      {
         hr = S_FALSE;

         WARNING_OUT(("ReadURLFromFile: No URL found in file %s.",
                      pcszFile));
      }
   }
   else
      hr = E_OUTOFMEMORY;

   if (FAILED(hr) ||
       hr == S_FALSE)
   {
      if (pszNewURL)
      {
         delete pszNewURL;
         pszNewURL = NULL;
      }
   }

   ASSERT((hr == S_OK &&
           IS_VALID_STRING_PTR(*ppszURL, STR)) ||
          (hr != S_OK &&
           ! *ppszURL));

   return(hr);
}


PRIVATE_CODE HRESULT WriteURLToFile(PCSTR pcszFile, PCSTR pcszURL)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(! pcszURL ||
          IS_VALID_STRING_PTR(pcszURL, CSTR));

   if (AnyMeat(pcszURL))
   {
      int ncbLen;

      ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
      ASSERT(IS_VALID_STRING_PTR(pcszURL, PSTR));

      hr = (SHSetIniString(s_cszInternetShortcutSection, s_cszURLKey, pcszURL, pcszFile))
           ? S_OK
           : E_FAIL;
   }
   else
      hr = (SHDeleteIniString(s_cszInternetShortcutSection, s_cszURLKey, pcszFile))
           ? S_OK
           : E_FAIL;

   return(hr);
}


PRIVATE_CODE HRESULT ReadIconLocationFromFile(PCSTR pcszFile,
                                              PSTR *ppszIconFile, PINT pniIcon)
{
   HRESULT hr;
   char rgchNewIconFile[MAX_PATH_LEN];
   DWORD dwcValueLen;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszIconFile, PSTR));
   ASSERT(IS_VALID_WRITE_PTR(pniIcon, INT));

   *ppszIconFile = NULL;
   *pniIcon = 0;

   dwcValueLen = SHGetIniString(s_cszInternetShortcutSection,
                                s_cszIconFileKey,
                                rgchNewIconFile,
                                sizeof(rgchNewIconFile), pcszFile);

   if (dwcValueLen > 0)
   {
      char rgchNewIconIndex[s_ucMaxIconIndexLen];

      dwcValueLen = GetPrivateProfileString(s_cszInternetShortcutSection,
                                            s_cszIconIndexKey,
                                            EMPTY_STRING, rgchNewIconIndex,
                                            sizeof(rgchNewIconIndex),
                                            pcszFile);

      if (dwcValueLen > 0)
      {
         int niIcon;

         if (StrToIntEx(rgchNewIconIndex, 0, &niIcon))
         {
            // (+ 1) for null terminator.

            *ppszIconFile = new(char[lstrlen(rgchNewIconFile) + 1]);

            if (*ppszIconFile)
            {
               lstrcpy(*ppszIconFile, rgchNewIconFile);
               *pniIcon = niIcon;

               hr = S_OK;
            }
            else
               hr = E_OUTOFMEMORY;
         }
         else
         {
            hr = S_FALSE;

            WARNING_OUT(("ReadIconLocationFromFile(): Bad icon index \"%s\" found in file %s.",
                         rgchNewIconIndex,
                         pcszFile));
         }
      }
      else
      {
         hr = S_FALSE;

         WARNING_OUT(("ReadIconLocationFromFile(): No icon index found in file %s.",
                      pcszFile));
      }
   }
   else
   {
      hr = S_FALSE;

      TRACE_OUT(("ReadIconLocationFromFile(): No icon file found in file %s.",
                 pcszFile));
   }

   ASSERT(IsValidIconIndex(hr, *ppszIconFile, MAX_PATH_LEN, *pniIcon));

   return(hr);
}


PRIVATE_CODE HRESULT WriteIconLocationToFile(PCSTR pcszFile,
                                             PCSTR pcszIconFile,
                                             int niIcon)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(! pcszIconFile ||
          IS_VALID_STRING_PTR(pcszIconFile, CSTR));
   ASSERT(IsValidIconIndex((pcszIconFile ? S_OK : S_FALSE), pcszIconFile, MAX_PATH_LEN, niIcon));

   if (AnyMeat(pcszIconFile))
   {
      char rgchIconIndexRHS[s_ucMaxIconIndexLen];
      int ncLen;

      ncLen = wsprintf(rgchIconIndexRHS, "%d", niIcon);
      ASSERT(ncLen > 0);
      ASSERT(ncLen < sizeof(rgchIconIndexRHS));
      ASSERT(ncLen == lstrlen(rgchIconIndexRHS));

      hr = (SHSetIniString(s_cszInternetShortcutSection,
                           s_cszIconFileKey, pcszIconFile,
                           pcszFile) &&
            WritePrivateProfileString(s_cszInternetShortcutSection,
                                      s_cszIconIndexKey, rgchIconIndexRHS,
                                      pcszFile))
           ? S_OK
           : E_FAIL;
   }
   else
      hr = (SHDeleteIniString(s_cszInternetShortcutSection,
                              s_cszIconFileKey, pcszFile) &&
            DeletePrivateProfileString(s_cszInternetShortcutSection,
                                       s_cszIconIndexKey, pcszFile))
           ? S_OK
           : E_FAIL;

   return(hr);
}


PRIVATE_CODE HRESULT ReadHotkeyFromFile(PCSTR pcszFile, PWORD pwHotkey)
{
   HRESULT hr = S_FALSE;
   char rgchHotkey[s_ucMaxHotkeyLen];
   DWORD dwcValueLen;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pwHotkey, WORD));

   *pwHotkey = 0;

   dwcValueLen = GetPrivateProfileString(s_cszInternetShortcutSection,
                                         s_cszHotkeyKey, EMPTY_STRING,
                                         rgchHotkey, sizeof(rgchHotkey),
                                         pcszFile);

   if (dwcValueLen > 0)
   {
      UINT uHotkey;

      if (StrToIntEx(rgchHotkey, 0, (int *)&uHotkey))
      {
         *pwHotkey = (WORD)uHotkey;

         hr = S_OK;
      }
      else
         WARNING_OUT(("ReadHotkeyFromFile(): Bad hotkey \"%s\" found in file %s.",
                      rgchHotkey,
                      pcszFile));
   }
   else
      WARNING_OUT(("ReadHotkeyFromFile(): No hotkey found in file %s.",
                   pcszFile));

   ASSERT((hr == S_OK &&
           IsValidHotkey(*pwHotkey)) ||
          (hr == S_FALSE &&
           ! *pwHotkey));

   return(hr);
}


PRIVATE_CODE HRESULT WriteHotkeyToFile(PCSTR pcszFile, WORD wHotkey)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(! wHotkey ||
          IsValidHotkey(wHotkey));

   if (wHotkey)
   {
      char rgchHotkeyRHS[s_ucMaxHotkeyLen];
      int ncLen;

      ncLen = wsprintf(rgchHotkeyRHS, "%u", (UINT)wHotkey);
      ASSERT(ncLen > 0);
      ASSERT(ncLen < sizeof(rgchHotkeyRHS));
      ASSERT(ncLen == lstrlen(rgchHotkeyRHS));

      hr = WritePrivateProfileString(s_cszInternetShortcutSection,
                                     s_cszHotkeyKey, rgchHotkeyRHS,
                                     pcszFile)
           ? S_OK
           : E_FAIL;
   }
   else
      hr = DeletePrivateProfileString(s_cszInternetShortcutSection,
                                      s_cszHotkeyKey, pcszFile)
           ? S_OK
           : E_FAIL;

   return(hr);
}


PRIVATE_CODE HRESULT ReadWorkingDirectoryFromFile(PCSTR pcszFile,
                                                  PSTR *ppszWorkingDirectory)
{
   HRESULT hr;
   char rgchDirValue[MAX_PATH_LEN];
   DWORD dwcValueLen;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszWorkingDirectory, PSTR));

   *ppszWorkingDirectory = NULL;

   dwcValueLen = SHGetIniString(s_cszInternetShortcutSection,
                                s_cszWorkingDirectoryKey,
                                rgchDirValue,
                                sizeof(rgchDirValue), pcszFile);

   if (dwcValueLen > 0)
   {
      char rgchFullPath[MAX_PATH_LEN];
      PSTR pszFileName;

      if (GetFullPathName(rgchDirValue, sizeof(rgchFullPath), rgchFullPath,
                          &pszFileName) > 0)
      {
         // (+ 1) for null terminator.

         *ppszWorkingDirectory = new(char[lstrlen(rgchFullPath) + 1]);

         if (*ppszWorkingDirectory)
         {
            lstrcpy(*ppszWorkingDirectory, rgchFullPath);

            hr = S_OK;
         }
         else
            hr = E_OUTOFMEMORY;
      }
      else
         hr = E_FAIL;
   }
   else
   {
      hr = S_FALSE;

      TRACE_OUT(("ReadWorkingDirectoryFromFile: No working directory found in file %s.",
                 pcszFile));
   }

   ASSERT(IsValidPathResult(hr, *ppszWorkingDirectory, MAX_PATH_LEN));

   return(hr);
}


PRIVATE_CODE HRESULT WriteWorkingDirectoryToFile(PCSTR pcszFile,
                                                 PCSTR pcszWorkingDirectory)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(! pcszWorkingDirectory ||
          IS_VALID_STRING_PTR(pcszWorkingDirectory, CSTR));

   if (AnyMeat(pcszWorkingDirectory))
      hr = (SHSetIniString(s_cszInternetShortcutSection,
                           s_cszWorkingDirectoryKey,
                           pcszWorkingDirectory, pcszFile))
           ? S_OK
           : E_FAIL;
   else
      hr = (SHDeleteIniString(s_cszInternetShortcutSection,
                              s_cszWorkingDirectoryKey, pcszFile))
           ? S_OK
           : E_FAIL;

   return(hr);
}


PRIVATE_CODE HRESULT ReadShowCmdFromFile(PCSTR pcszFile, PINT pnShowCmd)
{
   HRESULT hr;
   char rgchNewShowCmd[s_ucMaxShowCmdLen];
   DWORD dwcValueLen;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pnShowCmd, INT));

   *pnShowCmd = g_nDefaultShowCmd;

   dwcValueLen = GetPrivateProfileString(s_cszInternetShortcutSection,
                                         s_cszShowCmdKey, EMPTY_STRING,
                                         rgchNewShowCmd,
                                         sizeof(rgchNewShowCmd), pcszFile);

   if (dwcValueLen > 0)
   {
      int nShowCmd;

      if (StrToIntEx(rgchNewShowCmd, 0, &nShowCmd))
      {
         *pnShowCmd = nShowCmd;

         hr = S_OK;
      }
      else
      {
         hr = S_FALSE;

         WARNING_OUT(("ReadShowCmdFromFile: Invalid show command \"%s\" found in file %s.",
                      rgchNewShowCmd,
                      pcszFile));
      }
   }
   else
   {
      hr = S_FALSE;

      TRACE_OUT(("ReadShowCmdFromFile: No show command found in file %s.",
                 pcszFile));
   }

   ASSERT((hr == S_OK &&
           EVAL(IsValidShowCmd(*pnShowCmd))) ||
          (hr == S_FALSE &&
           EVAL(*pnShowCmd == g_nDefaultShowCmd)));

   return(hr);
}


PRIVATE_CODE HRESULT WriteShowCmdToFile(PCSTR pcszFile, int nShowCmd)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IsValidShowCmd(nShowCmd));

   if (nShowCmd != g_nDefaultShowCmd)
   {
      char rgchShowCmdRHS[s_ucMaxShowCmdLen];
      int ncLen;

      ncLen = wsprintf(rgchShowCmdRHS, "%d", nShowCmd);
      ASSERT(ncLen > 0);
      ASSERT(ncLen < sizeof(rgchShowCmdRHS));
      ASSERT(ncLen == lstrlen(rgchShowCmdRHS));

      hr = (WritePrivateProfileString(s_cszInternetShortcutSection,
                                      s_cszShowCmdKey, rgchShowCmdRHS,
                                      pcszFile))
           ? S_OK
           : E_FAIL;
   }
   else
      hr = (DeletePrivateProfileString(s_cszInternetShortcutSection,
                                       s_cszShowCmdKey, pcszFile))
           ? S_OK
           : E_FAIL;

   return(hr);
}


/****************************** Public Functions *****************************/


PUBLIC_CODE HRESULT UnicodeToANSI(LPCOLESTR pcwszUnicode, PSTR *ppszANSI)
{
   HRESULT hr;
   int ncbLen;

   // FEATURE: Need OLESTR validation function to validate pcwszUnicode here.
   ASSERT(IS_VALID_WRITE_PTR(ppszANSI, PSTR));

   *ppszANSI = NULL;

   // Get length of translated string.

   ncbLen = WideCharToMultiByte(CP_ACP, 0, pcwszUnicode, -1, NULL, 0, NULL,
                                NULL);

   if (ncbLen > 0)
   {
      PSTR pszNewANSI;

      // (+ 1) for null terminator.

      pszNewANSI = new(char[ncbLen]);

      if (pszNewANSI)
      {
         // Translate string.

         if (WideCharToMultiByte(CP_ACP, 0, pcwszUnicode, -1, pszNewANSI,
                                 ncbLen, NULL, NULL) > 0)
         {
            *ppszANSI = pszNewANSI;
            hr = S_OK;
         }
         else
         {
            delete pszNewANSI;
            pszNewANSI = NULL;

            hr = E_UNEXPECTED;

            WARNING_OUT(("UnicodeToANSI(): Failed to translate Unicode string to ANSI."));
         }
      }
      else
         hr = E_OUTOFMEMORY;
   }
   else
   {
      hr = E_UNEXPECTED;

      WARNING_OUT(("UnicodeToANSI(): Failed to get length of translated ANSI string."));
   }

   ASSERT(FAILED(hr) ||
          IS_VALID_STRING_PTR(*ppszANSI, STR));

   return(hr);
}


PUBLIC_CODE HRESULT ANSIToUnicode(PCSTR pcszANSI, LPOLESTR *ppwszUnicode)
{
   HRESULT hr;
   int ncbWideLen;

   ASSERT(IS_VALID_STRING_PTR(pcszANSI, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppwszUnicode, LPOLESTR));

   *ppwszUnicode = NULL;

   // Get length of translated string.

   ncbWideLen = MultiByteToWideChar(CP_ACP, 0, pcszANSI, -1, NULL, 0);

   if (ncbWideLen > 0)
   {
      PWSTR pwszNewUnicode;

      // (+ 1) for null terminator.

      pwszNewUnicode = new(WCHAR[ncbWideLen]);

      if (pwszNewUnicode)
      {
         // Translate string.

         if (MultiByteToWideChar(CP_ACP, 0, pcszANSI, -1, pwszNewUnicode,
                                 ncbWideLen) > 0)
         {
            *ppwszUnicode = pwszNewUnicode;
            hr = S_OK;
         }
         else
         {
            delete pwszNewUnicode;
            pwszNewUnicode = NULL;

            hr = E_UNEXPECTED;

            WARNING_OUT(("ANSIToUnicode(): Failed to translate ANSI path string to Unicode."));
         }
      }
      else
         hr = E_OUTOFMEMORY;
   }
   else
   {
      hr = E_UNEXPECTED;

      WARNING_OUT(("ANSIToUnicode(): Failed to get length of translated Unicode string."));
   }

   // FEATURE: Need OLESTR validation function to validate *ppwszUnicode here.

   return(hr);
}


/********************************** Methods **********************************/


HRESULT STDMETHODCALLTYPE InternetShortcut::SaveToFile(PCSTR pcszFile,
                                                       BOOL bRemember)
{
   HRESULT hr;
   PSTR pszURL;

   DebugEntry(InternetShortcut::SaveToFile);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));

   hr = GetURL(&pszURL);

   if (SUCCEEDED(hr))
   {
      hr = WriteURLToFile(pcszFile, pszURL);

      if (pszURL)
      {
         SHFree(pszURL);
         pszURL = NULL;
      }

      if (hr == S_OK)
      {
         char rgchBuf[MAX_PATH_LEN];
         int niIcon;

         hr = GetIconLocation(rgchBuf, sizeof(rgchBuf), &niIcon);

         if (SUCCEEDED(hr))
         {
            hr = WriteIconLocationToFile(pcszFile, rgchBuf, niIcon);

            if (hr == S_OK)
            {
               WORD wHotkey;

               hr = GetHotkey(&wHotkey);

               if (SUCCEEDED(hr))
               {
                  hr = WriteHotkeyToFile(pcszFile, wHotkey);

                  if (hr == S_OK)
                  {
                     hr = GetWorkingDirectory(rgchBuf, sizeof(rgchBuf));

                     if (SUCCEEDED(hr))
                     {
                        hr = WriteWorkingDirectoryToFile(pcszFile, rgchBuf);

                        if (hr == S_OK)
                        {
                           int nShowCmd;

                           GetShowCmd(&nShowCmd);

                           hr = WriteShowCmdToFile(pcszFile, nShowCmd);

                           if (hr == S_OK)
                           {
                              /* Remember file if requested. */

                              if (bRemember)
                              {
                                 PSTR pszFileCopy;

                                 if (StringCopy(pcszFile, &pszFileCopy))
                                 {
                                    if (m_pszFile)
                                       delete m_pszFile;

                                    m_pszFile = pszFileCopy;

                                    TRACE_OUT(("InternetShortcut::SaveToFile(): Remembering file %s, as requested.",
                                               m_pszFile));
                                 }
                                 else
                                    hr = E_OUTOFMEMORY;
                              }

                              if (hr == S_OK)
                              {
                                 Dirty(FALSE);

                                 SHChangeNotify(SHCNE_UPDATEITEM,
                                                (SHCNF_PATH | SHCNF_FLUSH), pcszFile,
                                                NULL);

#ifdef DEBUG
                                 TRACE_OUT(("InternetShortcut::SaveToFile(): Internet Shortcut saved to file %s:",
                                            pcszFile));
                                 Dump();
#endif
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::SaveToFile, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::LoadFromFile(PCSTR pcszFile,
                                                         BOOL bRemember)
{
   HRESULT hr;
   PSTR pszURL;

   DebugEntry(InternetShortcut::LoadFromFile);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));

   hr = ReadURLFromFile(pcszFile, &pszURL);

   if (SUCCEEDED(hr))
   {
      hr = SetURL(pszURL, (IURL_SETURL_FL_GUESS_PROTOCOL |
                           IURL_SETURL_FL_USE_DEFAULT_PROTOCOL));

      if (pszURL)
      {
         delete pszURL;
         pszURL = NULL;
      }

      if (hr == S_OK)
      {
         PSTR pszIconFile;
         int niIcon;

         hr = ReadIconLocationFromFile(pcszFile, &pszIconFile, &niIcon);

         if (SUCCEEDED(hr))
         {
            hr = SetIconLocation(pszIconFile, niIcon);

            if (pszIconFile)
            {
               delete pszIconFile;
               pszIconFile = NULL;
            }

            if (hr == S_OK)
            {
               WORD wHotkey;

               hr = ReadHotkeyFromFile(pcszFile, &wHotkey);

               if (SUCCEEDED(hr))
               {
                  hr = SetHotkey(wHotkey);

                  if (hr == S_OK)
                  {
                     PSTR pszWorkingDirectory;

                     hr = ReadWorkingDirectoryFromFile(pcszFile,
                                                       &pszWorkingDirectory);

                     if (SUCCEEDED(hr))
                     {
                        hr = SetWorkingDirectory(pszWorkingDirectory);

                        if (pszWorkingDirectory)
                        {
                           delete pszWorkingDirectory;
                           pszWorkingDirectory = NULL;
                        }

                        if (hr == S_OK)
                        {
                           int nShowCmd;

                           hr = ReadShowCmdFromFile(pcszFile, &nShowCmd);

                           if (SUCCEEDED(hr))
                           {
                              /* Remember file if requested. */

                              if (bRemember)
                              {
                                 PSTR pszFileCopy;

                                 if (StringCopy(pcszFile, &pszFileCopy))
                                 {
                                    if (m_pszFile)
                                       delete m_pszFile;

                                    m_pszFile = pszFileCopy;

                                    TRACE_OUT(("InternetShortcut::LoadFromFile(): Remembering file %s, as requested.",
                                               m_pszFile));
                                 }
                                 else
                                    hr = E_OUTOFMEMORY;
                              }

                              if (SUCCEEDED(hr))
                              {
                                 SetShowCmd(nShowCmd);

                                 Dirty(FALSE);

                                 hr = S_OK;

#ifdef DEBUG
                                 TRACE_OUT(("InternetShortcut::LoadFromFile(): Internet Shortcut loaded from file %s:",
                                            pcszFile));
                                 Dump();
#endif
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::LoadFromFile, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::GetCurFile(PSTR pszFile,
                                                       UINT ucbLen)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::GetCurFile);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszFile, STR, ucbLen));

   if (m_pszFile)
   {
      lstrcpyn(pszFile, m_pszFile, ucbLen);

      TRACE_OUT(("InternetShortcut::GetCurFile(): Current file name is %s.",
                 pszFile));

      hr = S_OK;
   }
   else
      hr = S_FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRING_PTR(pszFile, STR) &&
          EVAL((UINT)lstrlen(pszFile) < ucbLen));
   ASSERT(hr == S_OK ||
          hr == S_FALSE);

   DebugExitHRESULT(InternetShortcut::GetCurFile, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::Dirty(BOOL bDirty)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::Dirty);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   if (bDirty)
   {
      if (IS_FLAG_CLEAR(m_dwFlags, INTSHCUT_FL_DIRTY)) {
         TRACE_OUT(("InternetShortcut::Dirty(): Now dirty."));
      }

      SET_FLAG(m_dwFlags, INTSHCUT_FL_DIRTY);
   }
   else
   {
      if (IS_FLAG_SET(m_dwFlags, INTSHCUT_FL_DIRTY)) {
         TRACE_OUT(("InternetShortcut::Dirty(): Now clean."));
      }

      CLEAR_FLAG(m_dwFlags, INTSHCUT_FL_DIRTY);
   }

   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(hr == S_OK);

   DebugExitVOID(InternetShortcut::Dirty);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::GetClassID(PCLSID pclsid)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::GetClassID);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRUCT_PTR(pclsid, CCLSID));

   *pclsid = CLSID_InternetShortcut;
   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(FAILED(hr) ||
          IS_VALID_STRUCT_PTR(pclsid, CCLSID));

   DebugExitHRESULT(InternetShortcut::GetClassID, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::IsDirty(void)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::IsDirty);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   if (IS_FLAG_SET(m_dwFlags, INTSHCUT_FL_DIRTY))
      hr = S_OK;
   else
      hr = S_FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::IsDirty, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::Save(LPCOLESTR pcwszFile,
                                                 BOOL bRemember)
{
   HRESULT hr;
   PSTR pszFile;

   DebugEntry(InternetShortcut::Save);

   // bRemember may be any value.

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   // FEATURE: Need OLESTR validation function to validate pcwszFile here.

   if (pcwszFile)
   {
      hr = UnicodeToANSI(pcwszFile, &pszFile);

      if (hr == S_OK)
      {
         hr = SaveToFile(pszFile, bRemember);

         delete pszFile;
         pszFile = NULL;
      }
   }
   else if (m_pszFile)
      // Ignore bRemember.
      hr = SaveToFile(m_pszFile, FALSE);
   else
      hr = E_FAIL;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::Save, hr);

   return(hr);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE InternetShortcut::SaveCompleted(LPCOLESTR pcwszFile)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::SaveCompleted);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   // FEATURE: Need OLESTR validation function to validate pcwszFile here.

   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::SaveCompleted, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::Load(LPCOLESTR pcwszFile,
                                                 DWORD dwMode)
{
   HRESULT hr;
   PSTR pszFile;

   DebugEntry(InternetShortcut::Load);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   // FEATURE: Need OLESTR validation function to validate pcwszFile here.
   // FEATURE: Validate dwMode here.

   // FEAUTRE: Implement dwMode flag support.

   hr = UnicodeToANSI(pcwszFile, &pszFile);

   if (hr == S_OK)
   {
      hr = LoadFromFile(pszFile, TRUE);

      delete pszFile;
      pszFile = NULL;
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::Load, hr);

   return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


HRESULT STDMETHODCALLTYPE InternetShortcut::GetCurFile(LPOLESTR *ppwszFile)
{
   HRESULT hr;
   LPOLESTR pwszTempFile;

   DebugEntry(InternetShortcut::GetCurFile);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_WRITE_PTR(ppwszFile, LPOLESTR));

   if (m_pszFile)
   {
      hr = ANSIToUnicode(m_pszFile, &pwszTempFile);

      if (hr == S_OK) {
         TRACE_OUT(("InternetShortcut::GetCurFile(): Current file name is %s.",
                    m_pszFile));
      }
   }
   else
   {
      hr = ANSIToUnicode(g_cszURLDefaultFileNamePrompt, &pwszTempFile);

      if (hr == S_OK)
      {
         hr = S_FALSE;

         TRACE_OUT(("InternetShortcut::GetCurFile(): No current file name.  Returning default file name prompt %s.",
                    g_cszURLDefaultFileNamePrompt));
      }
   }

   if (SUCCEEDED(hr))
   {
      // We should really call OleGetMalloc() to get the process IMalloc here.
      // Use SHAlloc() here instead to avoid loading ole32.dll.
      // SHAlloc() / SHFree() turn in to IMalloc::Alloc() and IMalloc::Free()
      // once ole32.dll is loaded.

      // N.b., lstrlenW() returns the length of the given string in characters,
      // not bytes.

      // (+ 1) for null terminator.
      *ppwszFile = (LPOLESTR)SHAlloc((lstrlenW(pwszTempFile) + 1) *
                                     sizeof(*pwszTempFile));

      if (*ppwszFile)
         lstrcpyW(*ppwszFile, pwszTempFile);
      else
         hr = E_OUTOFMEMORY;

      delete pwszTempFile;
      pwszTempFile = NULL;
   }

   // FEATURE: Need OLESTR validation function to validate *ppwszFile here.

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::GetCurFile, hr);

   return(hr);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE InternetShortcut::Load(PIStream pistr)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::Load);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_INTERFACE_PTR(pistr, IStream));

   hr = E_NOTIMPL;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::Load, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::Save(PIStream pistr,
                                                 BOOL bClearDirty)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::Save);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_INTERFACE_PTR(pistr, IStream));

   // APPCOMPAT: Yes, this is an awful hack, but that's what we get when
   // no one implements a needed interface and we need to get a product
   // shipped.  (Actually, the hack isn't that bad, as it's what happens in
   // TransferFileContents, except we're writing to a stream and not memory).
   
   const static TCHAR s_cszNewLine[] = TEXT("\r\n");
   const static TCHAR s_cszPrefix[] = TEXT("[InternetShortcut]\r\nURL=");
   LPTSTR pszBuf;
   DWORD cb;

   pszBuf = (LPTSTR)LocalAlloc(LPTR, lstrlen(m_pszURL) + lstrlen(s_cszPrefix) + lstrlen(s_cszNewLine) + 1);

   if (pszBuf)
   {
       wsprintf(pszBuf, TEXT("%s%s%s"), s_cszPrefix, m_pszURL ? m_pszURL : TEXT("") , s_cszNewLine);
      
       hr = pistr->Write(pszBuf, lstrlen(pszBuf), &cb);

       LocalFree(pszBuf);
   }
   else
   {
       hr = E_OUTOFMEMORY;
   }
   
   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::Save, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::GetSizeMax(PULARGE_INTEGER pcbSize)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::GetSizeMax);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_WRITE_PTR(pcbSize, ULARGE_INTEGER));

   hr = E_NOTIMPL;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::GetSizeMax, hr);

   return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


DWORD STDMETHODCALLTYPE InternetShortcut::GetFileContentsSize(void)
{
   DWORD dwcbLen;

   DebugEntry(InternetShortcut::GetFileContentsSize);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   // Section length.

   // (- 1) for each null terminator.

   HRESULT hr = CreateURLFileContents(m_pszURL, NULL);

   // REARCHITECT: (DavidDi 3/29/95) We need to save more than just the URL string
   // here, i.e., icon file and index, working directory, and show command.

   dwcbLen = SUCCEEDED(hr) ? hr : 0;

   dwcbLen++;       // + 1 for final null terminator

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitDWORD(InternetShortcut::GetFileContentsSize, dwcbLen);

   return(dwcbLen);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::TransferUniformResourceLocator(
                                                            PFORMATETC pfmtetc,
                                                            PSTGMEDIUM pstgmed)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::TransferUniformResourceLocator);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
   ASSERT(IS_VALID_WRITE_PTR(pstgmed, STGMEDIUM));

   ASSERT(pfmtetc->dwAspect == DVASPECT_CONTENT);
   ASSERT(pfmtetc->lindex == -1);

   ZeroMemory(pstgmed, sizeof(*pstgmed));

   if (IS_FLAG_SET(pfmtetc->tymed, TYMED_HGLOBAL))
   {
      if (m_pszURL)
      {
         HGLOBAL hgURL;

         hr = E_OUTOFMEMORY;

         // (+ 1) for null terminator.
         hgURL = GlobalAlloc(0, lstrlen(m_pszURL) + 1);

         if (hgURL)
         {
            PSTR pszURL;

            pszURL = (PSTR)GlobalLock(hgURL);

            if (EVAL(pszURL))
            {
               lstrcpy(pszURL, m_pszURL);

               pstgmed->tymed = TYMED_HGLOBAL;
               pstgmed->hGlobal = hgURL;
               ASSERT(! pstgmed->pUnkForRelease);

               hr = S_OK;

               GlobalUnlock(hgURL);
               pszURL = NULL;
            }

            if (hr != S_OK)
            {
               GlobalFree(hgURL);
               hgURL = NULL;
            }
         }
      }
      else
         hr = DV_E_FORMATETC;
   }
   else
      hr = DV_E_TYMED;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT((hr == S_OK &&
           IS_VALID_STRUCT_PTR(pstgmed, CSTGMEDIUM)) ||
          (FAILED(hr) &&
           (EVAL(pstgmed->tymed == TYMED_NULL) &&
            EVAL(! pstgmed->hGlobal) &&
            EVAL(! pstgmed->pUnkForRelease))));

   DebugExitHRESULT(InternetShortcut::TransferUniformResourceLocator, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::TransferText(PFORMATETC pfmtetc,
                                                         PSTGMEDIUM pstgmed)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::TransferText);

   // Assume InternetShortcut::TransferUniformResourceLocator() will perform
   // input and output validation.

   hr = TransferUniformResourceLocator(pfmtetc, pstgmed);

   DebugExitHRESULT(InternetShortcut::TransferText, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::TransferFileGroupDescriptor(
                                                            PFORMATETC pfmtetc,
                                                            PSTGMEDIUM pstgmed)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::TransferFileGroupDescriptor);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
   ASSERT(IS_VALID_WRITE_PTR(pstgmed, STGMEDIUM));

   ASSERT(pfmtetc->dwAspect == DVASPECT_CONTENT);
   ASSERT(pfmtetc->lindex == -1);

   pstgmed->tymed = TYMED_NULL;
   pstgmed->hGlobal = NULL;
   pstgmed->pUnkForRelease = NULL;

   if (IS_FLAG_SET(pfmtetc->tymed, TYMED_HGLOBAL))
   {
      HGLOBAL hgFileGroupDesc;

      hr = E_OUTOFMEMORY;

      hgFileGroupDesc = GlobalAlloc(GMEM_ZEROINIT,
                                    sizeof(FILEGROUPDESCRIPTOR));

      if (hgFileGroupDesc)
      {
         PFILEGROUPDESCRIPTOR pfgd;

         pfgd = (PFILEGROUPDESCRIPTOR)GlobalLock(hgFileGroupDesc);

         if (EVAL(pfgd))
         {
            PFILEDESCRIPTOR pfd = &(pfgd->fgd[0]);

            // Do we already have a file name to use?

            if (m_pszFile)
            {
               lstrcpyn(pfd->cFileName, ExtractFileName(m_pszFile),
                        SIZECHARS(pfd->cFileName));

               hr = S_OK;
            }
            else
            {
               if (EVAL(MLLoadStringA(
                                   IDS_NEW_INTERNET_SHORTCUT, pfd->cFileName,
                                   sizeof(pfd->cFileName))))
                  hr = S_OK;
            }

            if (hr == S_OK)
            {
               pfd->dwFlags = (FD_FILESIZE |
                               FD_LINKUI);
               pfd->nFileSizeHigh = 0;
               pfd->nFileSizeLow = GetFileContentsSize();

               pfgd->cItems = 1;

               pstgmed->tymed = TYMED_HGLOBAL;
               pstgmed->hGlobal = hgFileGroupDesc;
               ASSERT(! pstgmed->pUnkForRelease);
            }

            GlobalUnlock(hgFileGroupDesc);
            pfgd = NULL;
         }

         if (hr != S_OK)
         {
            GlobalFree(hgFileGroupDesc);
            hgFileGroupDesc = NULL;
         }
      }
   }
   else
      hr = DV_E_TYMED;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT((hr == S_OK &&
           IS_VALID_STRUCT_PTR(pstgmed, CSTGMEDIUM)) ||
          (FAILED(hr) &&
           (EVAL(pstgmed->tymed == TYMED_NULL) &&
            EVAL(! pstgmed->hGlobal) &&
            EVAL(! pstgmed->pUnkForRelease))));

   DebugExitHRESULT(InternetShortcut::TransferFileGroupDescriptor, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::TransferFileContents(
                                                            PFORMATETC pfmtetc,
                                                            PSTGMEDIUM pstgmed)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::TransferFileContents);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRUCT_PTR(pfmtetc, CFORMATETC));
   ASSERT(IS_VALID_WRITE_PTR(pstgmed, STGMEDIUM));

   ASSERT(pfmtetc->dwAspect == DVASPECT_CONTENT);
   ASSERT(! pfmtetc->lindex);

   pstgmed->tymed = TYMED_NULL;
   pstgmed->hGlobal = NULL;
   pstgmed->pUnkForRelease = NULL;

   if (IS_FLAG_SET(pfmtetc->tymed, TYMED_HGLOBAL))
   {
      HGLOBAL hgFileContents;
      hr = CreateURLFileContents(m_pszURL, (LPSTR *)&hgFileContents);

      if (SUCCEEDED(hr))
      {
         // Note some apps don't pay attention to the nFileSizeLow
         // field; fortunately, CreateURLFileContents adds a final
         // null terminator to prevent trailing garbage.

         pstgmed->tymed = TYMED_HGLOBAL;
         pstgmed->hGlobal = hgFileContents;
         ASSERT(! pstgmed->pUnkForRelease);

         hr = S_OK;
      }
      else
         hr = E_OUTOFMEMORY;
   }
   else
      hr = DV_E_TYMED;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT((hr == S_OK &&
           IS_VALID_STRUCT_PTR(pstgmed, CSTGMEDIUM)) ||
          (FAILED(hr) &&
           (EVAL(pstgmed->tymed == TYMED_NULL) &&
            EVAL(! pstgmed->hGlobal) &&
            EVAL(! pstgmed->pUnkForRelease))));

   DebugExitHRESULT(InternetShortcut::TransferFileContents, hr);

   return(hr);
}


#ifdef DEBUG

void STDMETHODCALLTYPE InternetShortcut::Dump(void)
{
   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   PLAIN_TRACE_OUT(("%sm_dwFlags = %#08lx",
                    INDENT_STRING,
                    m_dwFlags));
   PLAIN_TRACE_OUT(("%sm_pszFile = \"%s\"",
                    INDENT_STRING,
                    CHECK_STRING(m_pszFile)));
   PLAIN_TRACE_OUT(("%sm_pszURL = \"%s\"",
                    INDENT_STRING,
                    CHECK_STRING(m_pszURL)));
   PLAIN_TRACE_OUT(("%sm_pszIconFile = \"%s\"",
                    INDENT_STRING,
                    CHECK_STRING(m_pszIconFile)));
   PLAIN_TRACE_OUT(("%sm_niIcon = %d",
                    INDENT_STRING,
                    m_niIcon));
   PLAIN_TRACE_OUT(("%sm_wHotkey = %#04x",
                    INDENT_STRING,
                    (UINT)m_wHotkey));
   PLAIN_TRACE_OUT(("%sm_pszWorkingDirectory = \"%s\"",
                    INDENT_STRING,
                    CHECK_STRING(m_pszWorkingDirectory)));
   PLAIN_TRACE_OUT(("%sm_nShowCmd = %d",
                    INDENT_STRING,
                    m_nShowCmd));

   return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\project.hpp ===
/*
 * project.hpp - Shell project header file for Internet Shortcut Shell
 *               extension DLL.
 */


/* Common Headers
 *****************/

#include "project.h"


/* System Headers
 *****************/

#include <stdio.h>

#include <prsht.h>

#define _INTSHCUT_               /* for intshcut.h */
#include <intshcut.h>
#include <intshctp.h>


/* Project Headers
 ******************/

/* The order of the following include files is significant. */

#include "olestock.h"
#include "olevalid.h"
#include "shlstock.h"
#include "shlvalid.h"
#include "inline.hpp"
#include "comcpp.hpp"
#include "refcount.hpp"
#include "intshcut.hpp"
#include "dataobj.hpp"
#include "persist.hpp"
#include "extricon.h"
#include "propsht.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\persist.hpp ===
/*
 * persist.hpp - IPersist, IPersistFile, and IPersistStream implementation
 *               description.
 */


/* Global Constants
 *******************/

// persist.cpp

extern const UINT g_ucMaxURLLen;
extern const char g_cszURLLeftDelimiter[];
extern const char g_cszURLRightDelimiter[];
extern const char g_cszURLPrefix[];
extern const UINT g_ucbURLPrefixLen;
extern const char g_cszURLExt[];
extern const char g_cszURLDefaultFileNamePrompt[];
extern const char g_cszCRLF[];


/* Prototypes
 *************/

// persist.cpp

extern HRESULT UnicodeToANSI(LPCOLESTR pcwszUnicode, PSTR *ppszANSI);
extern HRESULT ANSIToUnicode(PCSTR pcszANSI, LPOLESTR *ppwszUnicode);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\propsht.cpp ===
/*
 * propsht.cpp - IPropSheetExt implementation for URL class.
 */


/* Headers
 **********/

#include "project.hpp"
#pragma hdrstop

#undef NO_HELP              // for help.h

#include <help.h>

#undef IDH_COMM_GROUPBOX    // for addon.h
#include <addon.h>

#include "resource.h"

#include <mluisupp.h>


/* Types
 ********/

/* Internet Shortcut property sheet data */

typedef struct _isps
{
   PROPSHEETPAGE psp;

   PInternetShortcut pintshcut;

   char rgchIconFile[MAX_PATH_LEN];

   int niIcon;
}
ISPS;
DECLARE_STANDARD_TYPES(ISPS);


/* Module Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

// Tray notification window class

PRIVATE_DATA const char s_cszTrayNotificationClass[]  = WNDCLASS_TRAYNOTIFY;

// HACKHACK: WMTRAY_SCREGISTERHOTKEY and WMTRAY_SCUNREGISTERHOTKEY are stolen
// from shelldll\link.c.

PRIVATE_DATA CUINT WMTRAY_SCREGISTERHOTKEY            = (WM_USER + 233);
PRIVATE_DATA CUINT WMTRAY_SCUNREGISTERHOTKEY             = (WM_USER + 234);

// show commands - N.b., the order of these constants must match the order of
// the corresponding IDS_ string table constants.

PRIVATE_DATA const UINT s_ucMaxShowCmdLen             = MAX_PATH_LEN;

PRIVATE_DATA const int s_rgnShowCmds[] =
{
   SW_SHOWNORMAL,
   SW_SHOWMINNOACTIVE,
   SW_SHOWMAXIMIZED
};

// help files

PRIVATE_DATA const char s_cszPlusHelpFile[]           = "Plus!.hlp";

// help topics

PRIVATE_DATA const DWORD s_rgdwHelpIDs[] =
{
   IDD_LINE_1,          NO_HELP,
   IDD_LINE_2,          NO_HELP,
   IDD_ICON,            IDH_FCAB_LINK_ICON,
   IDD_NAME,            IDH_FCAB_LINK_NAME,
   IDD_URL_TEXT,        IDH_INTERNET_SHORTCUT_TARGET,
   IDD_URL,             IDH_INTERNET_SHORTCUT_TARGET,
   IDD_HOTKEY_TEXT,     IDH_FCAB_LINK_HOTKEY,
   IDD_HOTKEY,          IDH_FCAB_LINK_HOTKEY,
   IDD_START_IN_TEXT,   IDH_FCAB_LINK_WORKING,
   IDD_START_IN,        IDH_FCAB_LINK_WORKING,
   IDD_SHOW_CMD,        IDH_FCAB_LINK_RUN,
   IDD_CHANGE_ICON,     IDH_FCAB_LINK_CHANGEICON,
   0,                   0
};

#pragma data_seg()


/***************************** Private Functions *****************************/


#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCISPS(PCISPS pcisps)
{
   return(IS_VALID_READ_PTR(pcisps, CISPS) &&
      IS_VALID_STRUCT_PTR(&(pcisps->psp), CPROPSHEETPAGE) &&
      IS_VALID_STRUCT_PTR(pcisps->pintshcut, CInternetShortcut) &&
      EVAL(IsValidIconIndex(*(pcisps->rgchIconFile) ? S_OK : S_FALSE, pcisps->rgchIconFile, sizeof(pcisps->rgchIconFile), pcisps->niIcon)));
}

#endif


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

PRIVATE_CODE UINT CALLBACK ISPSCallback(HWND hwnd, UINT uMsg,
                    LPPROPSHEETPAGE ppsp)
{
   UINT uResult = TRUE;
   PISPS pisps = (PISPS)ppsp;

   // uMsg may be any value.

   ASSERT(! hwnd ||
      IS_VALID_HANDLE(hwnd, WND));
   ASSERT(IS_VALID_STRUCT_PTR((PCISPS)ppsp, CISPS));

   switch (uMsg)
   {
      case PSPCB_CREATE:
     TRACE_OUT(("ISPSCallback(): Received PSPCB_CREATE."));
     break;

      case PSPCB_RELEASE:
     TRACE_OUT(("ISPSCallback(): Received PSPCB_RELEASE."));
     pisps->pintshcut->Release();
     break;

      default:
     TRACE_OUT(("ISPSCallback(): Unhandled message %u.",
            uMsg));
     break;
   }

   return(uResult);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


PRIVATE_CODE void SetISPSIcon(HWND hdlg, HICON hicon)
{
   HICON hiconOld;

   ASSERT(IS_VALID_HANDLE(hdlg, WND));
   ASSERT(IS_VALID_HANDLE(hicon, ICON));

   hiconOld = (HICON)SendDlgItemMessage(hdlg, IDD_ICON, STM_SETICON,
                    (WPARAM)hicon, 0);

   if (hiconOld)
      DestroyIcon(hiconOld);

   TRACE_OUT(("SetISPSIcon(): Set property sheet icon to %#lx.",
          hicon));

   return;
}


PRIVATE_CODE void SetISPSFileNameAndIcon(HWND hdlg)
{
   HRESULT hr;
   PInternetShortcut pintshcut;
   char rgchFile[MAX_PATH_LEN];

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   pintshcut = ((PISPS)GetWindowLongPtr(hdlg, DWLP_USER))->pintshcut;
   ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CInternetShortcut));

   hr = pintshcut->GetCurFile(rgchFile, sizeof(rgchFile));

   if (hr == S_OK)
   {
      SHFILEINFO shfi;
      DWORD_PTR dwResult;

      dwResult = SHGetFileInfo(rgchFile, 0, &shfi, sizeof(shfi),
                   (SHGFI_DISPLAYNAME | SHGFI_ICON));

      if (dwResult)
      {
     PSTR pszFileName;

     pszFileName = (PSTR)ExtractFileName(shfi.szDisplayName);

     EVAL(SetDlgItemText(hdlg, IDD_NAME, pszFileName));

     TRACE_OUT(("SetISPSFileNameAndIcon(): Set property sheet file name to \"%s\".",
            pszFileName));

     SetISPSIcon(hdlg, shfi.hIcon);
      }
      else
      {
     hr = E_FAIL;

     TRACE_OUT(("SetISPSFileNameAndIcon(): SHGetFileInfo() failed, returning %lu.",
            dwResult));
      }
   }
   else
      TRACE_OUT(("SetISPSFileNameAndIcon(): GetCurFile() failed, returning %s.",
         GetHRESULTString(hr)));

   if (hr != S_OK)
      EVAL(SetDlgItemText(hdlg, IDD_NAME, EMPTY_STRING));

   return;
}


PRIVATE_CODE void SetISPSURL(HWND hdlg)
{
   PInternetShortcut pintshcut;
   HRESULT hr;
   PSTR pszURL;

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   pintshcut = ((PISPS)GetWindowLongPtr(hdlg, DWLP_USER))->pintshcut;
   ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CInternetShortcut));

   hr = pintshcut->GetURL(&pszURL);

   if (hr == S_OK)
   {
      EVAL(SetDlgItemText(hdlg, IDD_URL, pszURL));

      TRACE_OUT(("SetISPSURL(): Set property sheet URL to \"%s\".",
         pszURL));

      SHFree(pszURL);
      pszURL = NULL;
   }
   else
      EVAL(SetDlgItemText(hdlg, IDD_URL, EMPTY_STRING));

   return;
}


PRIVATE_CODE void SetISPSWorkingDirectory(HWND hdlg)
{
   PInternetShortcut pintshcut;
   HRESULT hr;
   char rgchWorkingDirectory[MAX_PATH_LEN];

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   pintshcut = ((PISPS)GetWindowLongPtr(hdlg, DWLP_USER))->pintshcut;
   ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CInternetShortcut));

   hr = pintshcut->GetWorkingDirectory(rgchWorkingDirectory,
                       sizeof(rgchWorkingDirectory));

   if (hr == S_OK)
   {
      EVAL(SetDlgItemText(hdlg, IDD_START_IN, rgchWorkingDirectory));

      TRACE_OUT(("SetISPSWorkingDirectory(): Set property sheet working directory to \"%s\".",
         rgchWorkingDirectory));
   }
   else
   {
      TRACE_OUT(("SetISPSWorkingDirectory(): GetWorkingDirectory() failed, returning %s.",
         GetHRESULTString(hr)));

      EVAL(SetDlgItemText(hdlg, IDD_START_IN, EMPTY_STRING));
   }

   return;
}


PRIVATE_CODE void InitISPSHotkey(HWND hdlg)
{
   PInternetShortcut pintshcut;
   WORD wHotkey;
   HRESULT hr;

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   // Set hotkey combinations.

   SendDlgItemMessage(hdlg, IDD_HOTKEY, HKM_SETRULES,
              (HKCOMB_NONE | HKCOMB_A | HKCOMB_C | HKCOMB_S),
              (HOTKEYF_CONTROL | HOTKEYF_ALT));

   // Set current hotkey.

   pintshcut = ((PISPS)GetWindowLongPtr(hdlg, DWLP_USER))->pintshcut;
   ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CInternetShortcut));

   hr = pintshcut->GetHotkey(&wHotkey);
   SendDlgItemMessage(hdlg, IDD_HOTKEY, HKM_SETHOTKEY, wHotkey, 0);

   return;
}


PRIVATE_CODE void InitISPSShowCmds(HWND hdlg)
{
   int niShowCmd;

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   for (niShowCmd = IDS_SHOW_NORMAL;
    niShowCmd <= IDS_SHOW_MAXIMIZED;
    niShowCmd++)
   {
      char rgchShowCmd[s_ucMaxShowCmdLen];

      if (MLLoadStringA(niShowCmd, rgchShowCmd,
             sizeof(rgchShowCmd)))
      {
     SendDlgItemMessage(hdlg, IDD_SHOW_CMD, CB_ADDSTRING, 0,
                (LPARAM)rgchShowCmd);

     TRACE_OUT(("InitISPSShowCmds(): Added show command \"%s\".",
            rgchShowCmd));
      }
      else
     ERROR_OUT(("InitISPSShowCmds(): Unable to load string %d.",
            niShowCmd));
   }

   return;
}


PRIVATE_CODE void SetISPSShowCmd(HWND hdlg)
{
   PInternetShortcut pintshcut;
   int nShowCmd;
   int i;

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   pintshcut = ((PISPS)GetWindowLongPtr(hdlg, DWLP_USER))->pintshcut;
   ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CInternetShortcut));

   pintshcut->GetShowCmd(&nShowCmd);

   for (i = 0; i < ARRAY_ELEMENTS(s_rgnShowCmds); i++)
   {
      if (s_rgnShowCmds[i] == nShowCmd)
     break;
   }

   if (i >= ARRAY_ELEMENTS(s_rgnShowCmds))
   {
      ASSERT(i == ARRAY_ELEMENTS(s_rgnShowCmds));

      WARNING_OUT(("SetISPSShowCmd(): Unrecognized show command %d.  Defaulting to normal.",
           nShowCmd));

      i = 0;
   }

   SendDlgItemMessage(hdlg, IDD_SHOW_CMD, CB_SETCURSEL, i, 0);

   TRACE_OUT(("SetISPSShowCmd(): Set property sheet show command to index %d.",
          i));

   return;
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

PRIVATE_CODE BOOL ISPS_InitDialog(HWND hdlg, WPARAM wparam, LPARAM lparam)
{
   PInternetShortcut pintshcut;

   // wparam may be any value.

   ASSERT(IS_VALID_HANDLE(hdlg, WND));
   ASSERT(IS_VALID_STRUCT_PTR((PCISPS)lparam, CISPS));

   SetWindowLongPtr(hdlg, DWLP_USER, lparam);

   pintshcut = ((PISPS)lparam)->pintshcut;
   ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CInternetShortcut));

   // Initialize control contents.

   SetISPSFileNameAndIcon(hdlg);

   SendDlgItemMessage(hdlg, IDD_URL, EM_LIMITTEXT, g_ucMaxURLLen - 1, 0);
   SetISPSURL(hdlg);

   SendDlgItemMessage(hdlg, IDD_START_IN, EM_LIMITTEXT, MAX_PATH_LEN - 1, 0);
   SetISPSWorkingDirectory(hdlg);

   InitISPSHotkey(hdlg);

   InitISPSShowCmds(hdlg);
   SetISPSShowCmd(hdlg);

   return(TRUE);
}


PRIVATE_CODE BOOL ISPS_Destroy(HWND hdlg, WPARAM wparam, LPARAM lparam)
{
   PInternetShortcut pintshcut;

   // wparam may be any value.
   // lparam may be any value.

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   pintshcut = ((PISPS)GetWindowLongPtr(hdlg, DWLP_USER))->pintshcut;
   ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CInternetShortcut));

   SetWindowLongPtr(hdlg, DWLP_USER, NULL);

   return(TRUE);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


PRIVATE_CODE void ISPSChanged(HWND hdlg)
{
   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   PropSheet_Changed(GetParent(hdlg), hdlg);

   return;
}


PRIVATE_CODE HRESULT ChooseIcon(HWND hdlg)
{
   HRESULT hr;
   PISPS pisps;
   PInternetShortcut pintshcut;
   char rgchTempIconFile[MAX_PATH_LEN];
   int niIcon;
   UINT uFlags;

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   pisps = (PISPS)GetWindowLongPtr(hdlg, DWLP_USER);
   ASSERT(IS_VALID_STRUCT_PTR(pisps, CISPS));
   pintshcut = pisps->pintshcut;
   ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CInternetShortcut));

   if (pintshcut->GetIconLocation(0, rgchTempIconFile,
                  sizeof(rgchTempIconFile), &niIcon, &uFlags)
       != S_OK)
   {
      rgchTempIconFile[0] = '\0';
      niIcon = 0;
   }

   ASSERT(lstrlen(rgchTempIconFile) < sizeof(rgchTempIconFile));
   if (RUNNING_NT)
   {
        WCHAR uTempIconFile[MAX_PATH_LEN];

        MultiByteToWideChar(CP_ACP, 0, rgchTempIconFile, -1,
                    uTempIconFile, MAX_PATH_LEN);

        if (PickIconDlg(hdlg, uTempIconFile, MAX_PATH_LEN, &niIcon))
        {
            WideCharToMultiByte(CP_ACP, 0, uTempIconFile, -1, pisps->rgchIconFile,
                                 MAX_PATH_LEN, NULL, NULL);

            pisps->niIcon = niIcon;

            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;

            TRACE_OUT(("ChooseIcon(NT): PickIconDlg() failed."));
        }
   }
   else
   {
       if (PickIconDlg(hdlg, (LPWSTR)rgchTempIconFile, sizeof(rgchTempIconFile), &niIcon))  // (LPWSTR) so it builds, but works downlevel
       {
          ASSERT(lstrlen(rgchTempIconFile) < sizeof(pisps->rgchIconFile));
          lstrcpy(pisps->rgchIconFile, rgchTempIconFile);
          pisps->niIcon = niIcon;

          hr = S_OK;
       }
       else
       {
          hr = E_FAIL;

          TRACE_OUT(("ChooseIcon(): PickIconDlg() failed."));
       }
   }

   return(hr);
}


PRIVATE_CODE void UpdateISPSIcon(HWND hdlg)
{
   PISPS pisps;
   HICON hicon;

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   pisps = (PISPS)GetWindowLongPtr(hdlg, DWLP_USER);
   ASSERT(IS_VALID_STRUCT_PTR(pisps, CISPS));
   ASSERT(pisps->rgchIconFile[0]);

   // This icon does not have the link arrow overlayed.  shell32.dll's
   // Shortcut property sheet has the same bug.

   hicon = ExtractIcon(GetThisModulesHandle(), pisps->rgchIconFile,
               pisps->niIcon);

   if (hicon)
      SetISPSIcon(hdlg, hicon);
   else
      WARNING_OUT(("UpdateISPSIcon(): ExtractIcon() failed for icon %d in file %s.",
           pisps->niIcon,
           pisps->rgchIconFile));

   return;
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

PRIVATE_CODE BOOL ISPS_Command(HWND hdlg, WPARAM wparam, LPARAM lparam)
{
   BOOL bMsgHandled = FALSE;
   WORD wCmd;

   // wparam may be any value.
   // lparam may be any value.

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   wCmd = HIWORD(wparam);

   switch (LOWORD(wparam))
   {
      case IDD_URL:
      case IDD_HOTKEY:
      case IDD_START_IN:
     if (wCmd == EN_CHANGE)
     {
        ISPSChanged(hdlg);

        bMsgHandled = TRUE;
     }
     break;

      case IDD_SHOW_CMD:
     if (wCmd == LBN_SELCHANGE)
     {
        ISPSChanged(hdlg);

        bMsgHandled = TRUE;
     }
     break;

      case IDD_CHANGE_ICON:
     // Ignore return value.
     if (ChooseIcon(hdlg) == S_OK)
     {
        UpdateISPSIcon(hdlg);
        ISPSChanged(hdlg);
     }
     bMsgHandled = TRUE;
     break;

      default:
     break;
   }

   return(bMsgHandled);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


PRIVATE_CODE HRESULT ComplainAboutURL(HWND hwndParent, PCSTR pcszURL,
                      HRESULT hrError)
{
   HRESULT hr;
   int nResult;

   // Validate hrError below.

   ASSERT(IS_VALID_HANDLE(hwndParent, WND));
   ASSERT(IS_VALID_STRING_PTR(pcszURL, CSTR));

   switch (hrError)
   {
      case URL_E_UNREGISTERED_PROTOCOL:
      {
     PSTR pszProtocol;

     hr = CopyURLProtocol(pcszURL, &pszProtocol);

     if (hr == S_OK)
     {
        if (MyMsgBox(hwndParent, MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
             MAKEINTRESOURCE(IDS_UNREGISTERED_PROTOCOL),
             (MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION),
             &nResult, pszProtocol))
        {
           switch (nResult)
           {
          case IDYES:
             hr = S_OK;
             TRACE_OUT(("ComplainAboutURL(): Allowing URL %s despite unregistered protocol %s, by request.",
                pcszURL,
                pszProtocol));
             break;

          default:
             ASSERT(nResult == IDNO);
             hr = E_FAIL;
             TRACE_OUT(("ComplainAboutURL(): Not allowing URL %s because of unregistered protocol %s, as directed.",
                pcszURL,
                pszProtocol));
             break;
           }
        }

        delete pszProtocol;
        pszProtocol = NULL;
     }

     break;
      }

      default:
     ASSERT(hrError == URL_E_INVALID_SYNTAX);

     if (MyMsgBox(hwndParent, MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
              MAKEINTRESOURCE(IDS_INVALID_URL_SYNTAX),
              (MB_OK | MB_ICONEXCLAMATION), &nResult, pcszURL)) {
        ASSERT(nResult == IDOK);
     }

     hr = E_FAIL;

     TRACE_OUT(("ComplainAboutURL(): Not allowing URL %s because of invalid syntax.",
            pcszURL));

     break;
   }

   return(hr);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

PRIVATE_CODE HRESULT ComplainAboutWorkingDirectory(HWND hwndParent,
                           PCSTR pcszWorkingDirectory,
                           HRESULT hrError)
{
   int nResult;

   ASSERT(IS_VALID_HANDLE(hwndParent, WND));
   ASSERT(IS_VALID_STRING_PTR(pcszWorkingDirectory, CSTR));
   ASSERT(hrError == E_PATH_NOT_FOUND);

   if (MyMsgBox(hwndParent, MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
        MAKEINTRESOURCE(IDS_WORKING_DIR_NOT_FOUND),
        (MB_OK | MB_ICONEXCLAMATION), &nResult, pcszWorkingDirectory)) {
      ASSERT(nResult == IDOK);
   }

   TRACE_OUT(("ComplainAboutWorkingDirectory(): Not allowing non-existent working directory %s.",
          pcszWorkingDirectory));

   return(E_FAIL);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


PRIVATE_CODE HRESULT InjectISPSData(HWND hdlg)
{
   HRESULT hr;
   PISPS pisps;
   PInternetShortcut pintshcut;
   PSTR pszURL;

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   pisps = (PISPS)GetWindowLongPtr(hdlg, DWLP_USER);
   ASSERT(IS_VALID_STRUCT_PTR(pisps, CISPS));
   pintshcut = pisps->pintshcut;
   ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CInternetShortcut));

   hr = CopyDlgItemText(hdlg, IDD_URL, &pszURL);

   if (SUCCEEDED(hr))
   {
      PCSTR pcszURLToUse;
      PSTR pszTranslatedURL;

      pcszURLToUse = pszURL;

      if (hr == S_OK)
      {
     hr = TranslateURL(pszURL, (TRANSLATEURL_FL_GUESS_PROTOCOL |
                    TRANSLATEURL_FL_USE_DEFAULT_PROTOCOL),
               &pszTranslatedURL);

     if (SUCCEEDED(hr))
     {
        if (hr == S_OK)
           pcszURLToUse = pszTranslatedURL;
        else
           ASSERT(hr == S_FALSE);

        hr = ValidateURL(pcszURLToUse);

        if (FAILED(hr))
        {
           hr = ComplainAboutURL(hdlg, pcszURLToUse, hr);

           if (FAILED(hr))
          SetEditFocus(GetDlgItem(hdlg, IDD_URL));
        }
     }
      }
      else
      {
     // A blank URL is OK.

     ASSERT(hr == S_FALSE);

     pszTranslatedURL = NULL;
      }

      if (SUCCEEDED(hr))
      {
     hr = pintshcut->SetURL(pcszURLToUse, 0);

     if (hr == S_OK)
     {
        WORD wHotkey;
        WORD wOldHotkey;

        // Refresh URL in case it was changed by TranslateURL().

        SetISPSURL(hdlg);

        wHotkey = (WORD)SendDlgItemMessage(hdlg, IDD_HOTKEY, HKM_GETHOTKEY,
                           0, 0);

        hr = pintshcut->GetHotkey(&wOldHotkey);

        if (hr == S_OK)
        {
           hr = pintshcut->SetHotkey(wHotkey);

           if (hr == S_OK)
           {
          char szFile[MAX_PATH_LEN];

          hr = pintshcut->GetCurFile(szFile, sizeof(szFile));

          if (hr == S_OK)
          {
             if (RegisterGlobalHotkey(wOldHotkey, wHotkey, szFile))
             {
            PSTR pszWorkingDirectory;

            hr = CopyDlgItemText(hdlg, IDD_START_IN,
                         &pszWorkingDirectory);

            if (SUCCEEDED(hr))
            {
               if (hr == S_OK)
               {
                  hr = ValidateWorkingDirectory(pszWorkingDirectory);

                  if (FAILED(hr))
                 hr = ComplainAboutWorkingDirectory(hdlg,
                                    pszWorkingDirectory,
                                    hr);

                  if (FAILED(hr))
                 SetEditFocus(GetDlgItem(hdlg, IDD_START_IN));
               }

               if (SUCCEEDED(hr))
               {
                  hr = pintshcut->SetWorkingDirectory(pszWorkingDirectory);

                  if (hr == S_OK)
                  {
                 // Refresh working directory in case it was changed by
                 // SetWorkingDirectory().

                 SetISPSWorkingDirectory(hdlg);

                 if (pisps->rgchIconFile[0])
                    hr = pintshcut->SetIconLocation(pisps->rgchIconFile,
                                    pisps->niIcon);

                 if (hr == S_OK)
                 {
                    INT_PTR iShowCmd;

                    iShowCmd = SendDlgItemMessage(hdlg,
                                  IDD_SHOW_CMD,
                                  CB_GETCURSEL,
                                  0, 0);

                    if (iShowCmd >= 0 &&
                    iShowCmd < ARRAY_ELEMENTS(s_rgnShowCmds))
                       pintshcut->SetShowCmd(s_rgnShowCmds[iShowCmd]);
                    else
                       hr = E_UNEXPECTED;
                 }
                  }
               }

               if (pszWorkingDirectory)
               {
                  delete pszWorkingDirectory;
                  pszWorkingDirectory = NULL;
               }
            }
             }
             else
            hr = E_FAIL;
          }
           }
        }
     }
      }

      if (pszURL)
      {
     delete pszURL;
     pszURL = NULL;
      }

      if (pszTranslatedURL)
      {
     LocalFree(pszTranslatedURL);
     pszTranslatedURL = NULL;
      }
   }

   if (hr == S_OK)
      TRACE_OUT(("InjectISPSData(): Injected property sheet data into Internet Shortcut successfully."));
   else
      WARNING_OUT(("InjectISPSData(): Failed to inject property sheet data into Internet Shortcut, returning %s.",
           GetHRESULTString(hr)));

   return(hr);
}


PRIVATE_CODE HRESULT ISPSSave(HWND hdlg)
{
   HRESULT hr;
   PInternetShortcut pintshcut;

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   pintshcut = ((PISPS)GetWindowLongPtr(hdlg, DWLP_USER))->pintshcut;
   ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CInternetShortcut));

   if (pintshcut->IsDirty() == S_OK)
   {
      hr = pintshcut->Save((LPCOLESTR)NULL, FALSE);

      if (hr == S_OK)
     TRACE_OUT(("ISPSSave(): Saved Internet Shortcut successfully."));
      else
     WARNING_OUT(("ISPSSave(): Save() failed, returning %s.",
              GetHRESULTString(hr)));
   }
   else
   {
      TRACE_OUT(("ISPSSave(): Internet Shortcut unchanged.  No save required."));

      hr = S_OK;
   }

   return(hr);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

PRIVATE_CODE BOOL ISPS_Notify(HWND hdlg, WPARAM wparam, LPARAM lparam)
{
   BOOL bMsgHandled = FALSE;

   // wparam may be any value.
   // lparam may be any value.

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   switch (((PNMHDR)lparam)->code)
   {
      case PSN_APPLY:
     SetWindowLongPtr(hdlg, DWLP_MSGRESULT, ISPSSave(hdlg) == S_OK ?
                        PSNRET_NOERROR :
                        PSNRET_INVALID_NOCHANGEPAGE);
     bMsgHandled = TRUE;
     break;

      case PSN_KILLACTIVE:
     SetWindowLongPtr(hdlg, DWLP_MSGRESULT, FAILED(InjectISPSData(hdlg)));
     bMsgHandled = TRUE;
     break;

      default:
     break;
   }

   return(bMsgHandled);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


PRIVATE_CODE PCSTR ISPS_GetHelpFileFromControl(HWND hwndControl)
{
   PCSTR pcszHelpFile = NULL;
   int nControlID = 0;

   ASSERT(! hwndControl ||
      IS_VALID_HANDLE(hwndControl, WND));

   if (hwndControl)
   {
      nControlID = GetDlgCtrlID(hwndControl);

      switch (nControlID)
      {
     case IDD_URL_TEXT:
     case IDD_URL:
        // URL help comes from the Plus! Pack help file.
        pcszHelpFile = s_cszPlusHelpFile;
        break;

     default:
        // Other help is borrowed from the default Win95 help file.
        break;
      }
   }

   TRACE_OUT(("ISPS_GetHelpFileFromControl(): Using %s for control %d (HWND %#lx).",
          pcszHelpFile ? pcszHelpFile : "default Win95 help file",
          nControlID,
          hwndControl));

   ASSERT(! pcszHelpFile ||
      IS_VALID_STRING_PTR(pcszHelpFile, CSTR));

   return(pcszHelpFile);
}


PRIVATE_CODE INT_PTR CALLBACK ISPS_DlgProc(HWND hdlg, UINT uMsg, WPARAM wparam,
                    LPARAM lparam)
{
   INT_PTR bMsgHandled = FALSE;

   // uMsg may be any value.
   // wparam may be any value.
   // lparam may be any value.

   ASSERT(IS_VALID_HANDLE(hdlg, WND));

   switch (uMsg)
   {
      case WM_INITDIALOG:
     bMsgHandled = ISPS_InitDialog(hdlg, wparam, lparam);
     break;

      case WM_DESTROY:
     bMsgHandled = ISPS_Destroy(hdlg, wparam, lparam);
     break;

      case WM_COMMAND:
     bMsgHandled = ISPS_Command(hdlg, wparam, lparam);
     break;

      case WM_NOTIFY:
     bMsgHandled = ISPS_Notify(hdlg, wparam, lparam);
     break;

      case WM_HELP:
         SHWinHelpOnDemandWrap((HWND)(((LPHELPINFO)lparam)->hItemHandle),
         ISPS_GetHelpFileFromControl((HWND)(((LPHELPINFO)lparam)->hItemHandle)),
         HELP_WM_HELP, (DWORD_PTR)(PVOID)s_rgdwHelpIDs);
     bMsgHandled = TRUE;
     break;

      case WM_CONTEXTMENU:
      {
     POINT pt;

     LPARAM_TO_POINT(lparam, pt);
     EVAL(ScreenToClient(hdlg, &pt));

         SHWinHelpOnDemandWrap((HWND)wparam,
         ISPS_GetHelpFileFromControl(ChildWindowFromPoint(hdlg, pt)),
         HELP_CONTEXTMENU, (DWORD_PTR)(PVOID)s_rgdwHelpIDs);
     bMsgHandled = TRUE;
     break;
      }

      default:
    break;
   }

   return(bMsgHandled);
}


PRIVATE_CODE HRESULT AddISPS(PInternetShortcut pintshcut,
                 LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lparam)
{
   HRESULT hr;
   ISPS isps;
   HPROPSHEETPAGE hpsp;

   // lparam may be any value.

   ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CInternetShortcut));
   ASSERT(IS_VALID_CODE_PTR(pfnAddPage, LPFNADDPROPSHEETPAGE));

   ZeroMemory(&isps, sizeof(isps));

   isps.psp.dwSize = sizeof(isps);
   isps.psp.dwFlags = (PSP_DEFAULT | PSP_USECALLBACK);
   isps.psp.hInstance = MLGetHinst();
   isps.psp.pszTemplate = MAKEINTRESOURCE(DLG_INTERNET_SHORTCUT_PROP_SHEET);
   isps.psp.pfnDlgProc = &ISPS_DlgProc;
   isps.psp.pfnCallback = &ISPSCallback;

   isps.pintshcut = pintshcut;

   ASSERT(IS_VALID_STRUCT_PTR(&isps, CISPS));

   hpsp = CreatePropertySheetPage(&(isps.psp));

   if (hpsp)
   {
      if ((*pfnAddPage)(hpsp, lparam))
      {
     pintshcut->AddRef();
     hr = S_OK;
     TRACE_OUT(("AddISPS(): Added Internet Shortcut property sheet."));
      }
      else
      {
     DestroyPropertySheetPage(hpsp);

     hr = E_FAIL;
     WARNING_OUT(("AddISPS(): Callback to add property sheet failed."));
      }
   }
   else
      hr = E_OUTOFMEMORY;

   return(hr);
}


/****************************** Public Functions *****************************/


PUBLIC_CODE void SetEditFocus(HWND hwnd)
{
   ASSERT(IS_VALID_HANDLE(hwnd, WND));

   SetFocus(hwnd);
   SendMessage(hwnd, EM_SETSEL, 0, -1);

   return;
}


PUBLIC_CODE BOOL ConstructMessageString(PCSTR pcszFormat, PSTR *ppszMsg,
                    va_list *ArgList)
{
   BOOL bResult;
   char rgchFormat[MAX_MSG_LEN];

   // ArgList may be any value.

   ASSERT(! HIWORD(pcszFormat) ||
      IS_VALID_STRING_PTR(pcszFormat, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszMsg, PSTR));

   if (IS_INTRESOURCE(pcszFormat))
   {
      MLLoadStringA(LOWORD(PtrToUlong(pcszFormat)), rgchFormat,
         sizeof(rgchFormat));

      pcszFormat = rgchFormat;
   }

   bResult = FormatMessage((FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_FROM_STRING), pcszFormat, 0, 0,
               (PSTR)ppszMsg, 0, ArgList);

   ASSERT(! bResult ||
      IS_VALID_STRING_PTR(*ppszMsg, STR));

   return(bResult);
}


PUBLIC_CODE BOOL __cdecl MyMsgBox(HWND hwndParent, PCSTR pcszTitle,
                  PCSTR pcszMsgFormat, DWORD dwMsgBoxFlags,
                  PINT pnResult, ...)
{
   BOOL bResult;
   va_list ArgList;
   PSTR pszMsg;

   ASSERT(IS_VALID_HANDLE(hwndParent, WND));
   ASSERT(IS_INTRESOURCE(pcszTitle) ||
      IS_VALID_STRING_PTR(pcszTitle, CSTR));
   ASSERT(IS_INTRESOURCE(pcszMsgFormat) ||
      IS_VALID_STRING_PTR(pcszMsgFormat, CSTR));
   ASSERT(FLAGS_ARE_VALID(dwMsgBoxFlags, ALL_MSG_BOX_FLAGS));
   ASSERT(IS_VALID_WRITE_PTR(pnResult, INT));

   *pnResult = 0;

   va_start(ArgList, pnResult);

   bResult = ConstructMessageString(pcszMsgFormat, &pszMsg, &ArgList);

   va_end(ArgList);

   if (bResult)
   {
      char rgchTitle[MAX_MSG_LEN];

      if (! HIWORD(pcszTitle))
      {
          MLLoadStringA(LOWORD(PtrToUlong(pcszTitle)), rgchTitle,
            sizeof(rgchTitle));

          pcszTitle = rgchTitle;
      }

      *pnResult = MessageBox(hwndParent, pszMsg, pcszTitle, dwMsgBoxFlags);

      bResult = (*pnResult != 0);

      LocalFree(pszMsg);
      pszMsg = NULL;
   }

   return(bResult);
}


PUBLIC_CODE HRESULT CopyDlgItemText(HWND hdlg, int nControlID, PSTR *ppszText)
{
   HRESULT hr;
   HWND hwndControl;

   // nContolID may be any value.

   ASSERT(IS_VALID_HANDLE(hdlg, WND));
   ASSERT(IS_VALID_WRITE_PTR(ppszText, PSTR));

   *ppszText = NULL;

   hwndControl = GetDlgItem(hdlg, nControlID);

   if (hwndControl)
   {
      int ncchTextLen;

      ncchTextLen = GetWindowTextLength(hwndControl);

      if (ncchTextLen > 0)
      {
     PSTR pszText;

     ASSERT(ncchTextLen < INT_MAX);
     ncchTextLen++;
     ASSERT(ncchTextLen > 0);

     pszText = new(char[ncchTextLen]);

     if (pszText)
     {
        int ncchCopiedLen;

        ncchCopiedLen = GetWindowText(hwndControl, pszText, ncchTextLen);
        ASSERT(ncchCopiedLen == ncchTextLen - 1);

        if (EVAL(ncchCopiedLen > 0))
        {
           if (AnyMeat(pszText))
           {
          *ppszText = pszText;

          hr = S_OK;
           }
           else
          hr = S_FALSE;
        }
        else
           hr = E_FAIL;

        if (hr != S_OK)
        {
           delete pszText;
           pszText = NULL;
        }
     }
     else
        hr = E_OUTOFMEMORY;
      }
      else
     // No text.
     hr = S_FALSE;
   }
   else
      hr = E_FAIL;

   return(hr);
}


PUBLIC_CODE BOOL RegisterGlobalHotkey(WORD wOldHotkey, WORD wNewHotkey,
                      PCSTR pcszPath)
{
   BOOL bResult;
   HWND hwndTray;

   ASSERT(! wOldHotkey ||
      IsValidHotkey(wOldHotkey));
   ASSERT(! wNewHotkey ||
      IsValidHotkey(wNewHotkey));
   ASSERT(IsValidPath(pcszPath));

   hwndTray = FindWindow(s_cszTrayNotificationClass, 0);

   if (hwndTray)
   {
      if (wOldHotkey)
      {
          SendMessage(hwndTray, WMTRAY_SCUNREGISTERHOTKEY, wOldHotkey, 0);

          TRACE_OUT(("RegisterGlobalHotkey(): Unregistered old hotkey %#04x for %s.",
              wOldHotkey,
              pcszPath));
      }

      if (wNewHotkey)
      {
        if (RUNNING_NT)
        {
            ATOM atom = GlobalAddAtom(pcszPath);
            ASSERT(atom);
            if (atom)
            {
                SendMessage(hwndTray, WMTRAY_SCREGISTERHOTKEY, wNewHotkey, (LPARAM)atom);
                GlobalDeleteAtom(atom);
            }
        }
        else
        {
            SendMessage(hwndTray, WMTRAY_SCREGISTERHOTKEY, wNewHotkey,
                        (LPARAM)pcszPath);
        }

          TRACE_OUT(("RegisterGlobalHotkey(): Registered new hotkey %#04x for %s.",
              wNewHotkey,
              pcszPath));
      }

      bResult = TRUE;
   }
   else
   {
      bResult = FALSE;

      WARNING_OUT(("RegisterGlobalHotkey(): Unable to find Tray window of class %s to notify.",
           s_cszTrayNotificationClass));
   }

   return(bResult);
}

/********************************** Methods **********************************/


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE InternetShortcut::Initialize(
                              PCITEMIDLIST pcidlFolder,
                              PIDataObject pido,
                              HKEY hkeyProgID)
{
   HRESULT hr;
   FORMATETC fmtetc = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
   STGMEDIUM stgmed;

   DebugEntry(InternetShortcut::Initialize);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(! pcidlFolder ||
      IS_VALID_STRUCT_PTR(pcidlFolder, CITEMIDLIST));
   ASSERT(IS_VALID_INTERFACE_PTR(pido, IDataObject));
   ASSERT(IS_VALID_HANDLE(hkeyProgID, KEY));

   hr = pido->GetData(&fmtetc, &stgmed);

   if (hr == S_OK)
   {
      UINT ucbPathLen;
      PSTR pszFile;

      // (+ 1) for null terminator.

      ucbPathLen = DragQueryFile((HDROP)(stgmed.hGlobal), 0, NULL, 0) + 1;
      ASSERT(ucbPathLen > 0);

      pszFile = new(char[ucbPathLen]);

      if (pszFile)
      {
     EVAL(DragQueryFile((HDROP)(stgmed.hGlobal), 0, pszFile, ucbPathLen) == ucbPathLen - 1);
     ASSERT(IS_VALID_STRING_PTR(pszFile, STR));
     ASSERT((UINT)lstrlen(pszFile) == ucbPathLen - 1);

     hr = LoadFromFile(pszFile, TRUE);

     delete pszFile;
     pszFile = NULL;
      }
      else
     hr = E_OUTOFMEMORY;

      if (stgmed.tymed != TYMED_NULL)
         MyReleaseStgMedium(&stgmed);
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::Initialize, hr);

   return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


HRESULT STDMETHODCALLTYPE InternetShortcut::AddPages(
                         LPFNADDPROPSHEETPAGE pfnAddPage,
                         LPARAM lparam)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::AddPages);

   // lparam may be any value.

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_CODE_PTR(pfnAddPage, LPFNADDPROPSHEETPAGE));

   hr = AddISPS(this, pfnAddPage, lparam);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::AddPages, hr);

   return(hr);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE InternetShortcut::ReplacePage(
                      UINT uPageID,
                      LPFNADDPROPSHEETPAGE pfnReplaceWith,
                      LPARAM lparam)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::ReplacePage);

   // lparam may be any value.
   // uPageID may be any value.

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_CODE_PTR(pfnReplaceWith, LPFNADDPROPSHEETPAGE));

   hr = E_NOTIMPL;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::ReplacePage, hr);

   return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\refcount.hpp ===
/*
 * refcount.hpp - RefCount class description.
 */


/* Types
 ********/

/* Classes
 **********/

class RefCount
{
private:
   ULONG m_ulcRef;

public:
   RefCount(void);
   // Virtual destructor defers to destructor of derived class.
   virtual ~RefCount(void);

   // IUnknown methods

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);

   // friends

#ifdef DEBUG

   friend BOOL IsValidPCRefCount(const RefCount *pcrefcnt);

#endif

};
DECLARE_STANDARD_TYPES(RefCount);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\project.h ===
/*
 * project.h - Common project header file for URL Shell extension DLL.
 */


/* System Headers
 *****************/

#define INC_OLE2              /* for windows.h */
#define CONST_VTABLE          /* for objbase.h */

#pragma warning(disable:4514) /* "unreferenced __inlinefunction" warning */

#pragma warning(disable:4001) /* "single line comment" warning */
#pragma warning(disable:4115) /* "named type definition in parentheses" warning */
#pragma warning(disable:4201) /* "nameless struct/union" warning */
#pragma warning(disable:4209) /* "benign typedef redefinition" warning */
#pragma warning(disable:4214) /* "bit field types other than int" warning */
#pragma warning(disable:4218) /* "must specify at least a storage class or type" warning */

#ifndef WIN32_LEAN_AND_MEAN   /* NT builds define this for us */
#define WIN32_LEAN_AND_MEAN   /* for windows.h */
#endif                        /*  WIN32_LEAN_AND_MEAN  */

#include <windows.h>
#pragma warning(disable:4001) /* "single line comment" warning - windows.h enabled it */
#include <shlwapi.h>
#include <shlwapip.h>

#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shellp.h>
#include <comctrlp.h>
#include <shlobjp.h>
#include <shlapip.h>

#pragma warning(default:4218) /* "must specify at least a storage class or type" warning */
#pragma warning(default:4214) /* "bit field types other than int" warning */
#pragma warning(default:4209) /* "benign typedef redefinition" warning */
#pragma warning(default:4201) /* "nameless struct/union" warning */
#pragma warning(default:4115) /* "named type definition in parentheses" warning */

#include <limits.h>

#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */

#include <crtfree.h>        // Use intrinsic functions to avoid CRT

// StrChr is provided by SHLWAPI
#define strchr      StrChr

// Avoid name conflicts with Nashville commctrl
#define StrToIntExW         UrlStrToIntExW
#define StrToIntExA         UrlStrToIntExA
#define StrSpnW             UrlStrSpnW
#define StrSpnA             UrlStrSpnA
#define StrPBrkW            UrlStrPBrkW
#define StrPBrkA            UrlStrPBrkA

#define strpbrk             StrPBrk

// Avoid name conflicts with shlwapi
#undef GetMIMETypeSubKey
#undef RegisterMIMETypeForExtension
#undef UnregisterMIMETypeForExtension
#undef RegisterExtensionForMIMEType
#undef UnregisterExtensionForMIMEType
#undef MIME_GetExtension

__inline BOOL AllocateMemory(DWORD dwcbSize, PVOID *ppvNew)
{
   *ppvNew = GlobalAlloc(GPTR, dwcbSize);
   return(*ppvNew != NULL);
}

__inline BOOL ReallocateMemory(PVOID pvOld, DWORD dwcbNewSize, PVOID *ppvNew)
{
   *ppvNew = GlobalReAlloc(pvOld, dwcbNewSize, GMEM_MOVEABLE);
   return(*ppvNew != NULL);
}


__inline void FreeMemory(PVOID pv)
{
   GlobalFree(pv);
   return;
}

__inline DWORD MemorySize(PVOID pv)
{
   return(DWORD)(GlobalSize(pv));
}

/* Project Headers
 ******************/

/* The order of the following include files is significant. */

#ifdef NO_HELP
#undef NO_HELP
#endif

#include "stock.h"
#include "serial.h"

#ifdef DEBUG

#include "inifile.h"
#include "resstr.h"

#endif

#include "debbase.h"
#include "debspew.h"
#include "valid.h"
#include "util.h"
#include "comc.h"

#if defined(_X86_)
extern BOOL g_bRunningOnNT;

#define RUNNING_NT  g_bRunningOnNT
#else
#define RUNNING_NT  1
#endif

/* Constants
 ************/

/*
 * constants to be used with #pragma data_seg()
 *
 * These section names must be given the associated attributes in the project's
 * module definition file.
 */

#define DATA_SEG_READ_ONLY       ".text"
#define DATA_SEG_PER_INSTANCE    ".data"
#define DATA_SEG_SHARED          ".shared"

#ifdef DEBUG

#define INDENT_STRING            "    "

#endif


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\propsht.hpp ===
/*
 * propsht.hpp - IPropSheetExt implementation description.
 */


/* Types
 ********/

/* User MessageBox() flags */

typedef enum msg_box_flags
{
   ALL_MSG_BOX_FLAGS    = (MB_OK |
                           MB_OKCANCEL |
                           MB_ABORTRETRYIGNORE |
                           MB_YESNOCANCEL |
                           MB_YESNO |
                           MB_RETRYCANCEL |
                           MB_ICONHAND |
                           MB_ICONQUESTION |
                           MB_ICONEXCLAMATION |
                           MB_ICONASTERISK |
                           MB_DEFBUTTON1 |
                           MB_DEFBUTTON2 |
                           MB_DEFBUTTON3 |
                           MB_DEFBUTTON4 |
                           MB_APPLMODAL |
                           MB_SYSTEMMODAL |
                           MB_TASKMODAL |
                           MB_HELP |
                           MB_RIGHT |
                           MB_RTLREADING |
                           MB_NOFOCUS |
                           MB_SETFOREGROUND |
                           MB_DEFAULT_DESKTOP_ONLY |
                           MB_USERICON)
}
MSG_BOX_FLAGS;


/* Prototypes
 *************/

// propsht.cpp

extern void SetEditFocus(HWND hwnd);
extern BOOL ConstructMessageString(PCSTR pcszFormat, PSTR *ppszMsg, va_list *ArgList);
extern BOOL __cdecl MyMsgBox(HWND hwndParent, PCSTR pcszTitle, PCSTR pcszMsgFormat, DWORD dwMsgBoxFlags, PINT pnResult, ...);
extern HRESULT CopyDlgItemText(HWND hdlg, int nControlID, PSTR *ppszText);
extern BOOL RegisterGlobalHotkey(WORD wOldHotkey, WORD wNewHotkey, PCSTR pcszPath);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by url.rc
//
#define IDS_SHOW_NORMAL                 1
#define IDS_SHOW_MINIMIZED              2
#define IDS_SHOW_MAXIMIZED              3
#define IDS_INVALID_URL_SYNTAX          4
#define IDS_UNREGISTERED_PROTOCOL       5
#define IDS_SHORTCUT_ERROR_TITLE        6
#define IDS_WORKING_DIR_NOT_FOUND       7
#define IDS_EXEC_OUT_OF_MEMORY          8
#define IDS_EXEC_INVALID_SYNTAX         9
#define IDS_EXEC_UNREGISTERED_PROTOCOL  10
#define IDS_MAPI_LOADLIBRARY_FAILED     11
#define DLG_FILETYPEOPTIONS             11
#define DLG_FILETYPEOPTIONSEDIT         12
#define IDS_MAPI_GETPROCADDRESS_FAILED  13
#define DLG_FILETYPEOPTIONSCMD          14
#define IDS_MAPI_MAPISENDMAIL_FAILED    15
#define IDS_LOADFROMFILE_FAILED         16
#define IDS_SHORT_NEW_INTERNET_SHORTCUT 17
#define IDS_NEW_INTERNET_SHORTCUT       18
#define IDS_INTERNET_SHORTCUT           19
#define IDS_TELNET_APP_NOT_FOUND        25
#define IDS_OPEN_INTSHCUT_OUT_OF_MEMORY 26
#define IDS_TELNET_EXEC_FAILED          27
#define IDS_NO_MAPI_PROVIDER            28
#define IDS_SHELLEXECUTE_FAILED         29
#define IDS_NEWS_LOADLIBRARY_FAILED     30
#define IDS_NEWS_GETPROCADDRESS_FAILED  31
#define IDS_EXEC_FAILED                 32
#define IDI_WEB_DOCUMENT                102
#define IDI_WEB_NEWS                    103
#define IDI_WEB_MAILTO                  104
#define IDI_WEB_VRML                    105
#define IDI_WEB_SPLAT                   106
#define IDD_NAME                        200
#define IDC_GROUPBOX                    300
#define IDC_NO_HELP_1                   650
#define IDC_FT_PROP_LV_FILETYPES        800
#define IDC_FT_PROP_DOCICON             801
#define IDC_FT_PROP_DOCEXTRO            802
#define IDC_FT_PROP_OPENICON            803
#define IDC_FT_PROP_OPENEXE             804
#define IDC_FT_PROP_NEW                 805
#define IDC_FT_PROP_REMOVE              806
#define IDC_FT_PROP_EDIT                808
#define IDC_FT_EDIT_DOCICON             809
#define IDC_FT_EDIT_CHANGEICON          810
#define IDC_FT_EDIT_DESC                811
#define IDC_FT_EDIT_EXTTEXT             812
#define IDC_FT_EDIT_EXT                 813
#define IDC_FT_EDIT_LV_CMDSTEXT         814
#define IDC_FT_EDIT_LV_CMDS             815
#define IDC_FT_EDIT_NEW                 816
#define IDC_FT_EDIT_EDIT                817
#define IDC_FT_EDIT_REMOVE              818
#define IDC_FT_EDIT_DEFAULT             819
#define IDC_FT_EDIT_SHOWEXT             821
#define IDC_FT_CMD_ACTION               822
#define IDC_FT_COMBO_DEFEXTTEXT         822
#define IDC_FT_CMD_EXETEXT              823
#define IDC_FT_CMD_EXE                  824
#define IDC_FT_CMD_BROWSE               825
#define IDC_FT_CMD_USEDDE               826
#define IDC_FT_CMD_DDEAPP               827
#define IDC_FT_CMD_DDEAPPNOT            828
#define IDC_FT_CMD_DDEMSG               829
#define IDC_FT_CMD_DDETOPIC             830
#define IDC_FT_CMD_DDEGROUP             831
#define IDC_FT_PROP_DOCEXTRO_TXT        832
#define IDC_FT_PROP_OPENEXE_TXT         833
#define IDC_FT_PROP_CONTTYPERO          834
#define IDC_FT_PROP_CONTTYPERO_TXT      835
#define IDC_FT_COMBO_CONTTYPETEXT       837
#define IDC_FT_EDIT_CONFIRM_OPEN        838
#define IDD_HOTKEY                      1000
#define IDC_BROWSEINPLACE               1000
#define IDC_FT_COMBO_DEFEXT             1002
#define IDC_FT_EDIT_DESCTEXT            1003
#define IDC_FT_COMBO_CONTTYPE           1004
#define DLG_INTERNET_SHORTCUT_PROP_SHEET 1040
#define IDD_START_IN                    3002
#define IDD_ICON                        3301
#define IDD_URL                         3302
#define IDD_LINE_1                      3327
#define IDD_LINE_2                      3328
#define IDD_CHANGE_ICON                 3407
#define IDD_SHOW_CMD                    3408
#define IDS_ADDNEWFILETYPE              6900
#define IDS_EXTTYPETEMPLATE             6901
#define IDS_FT                          6902
#define IDS_FT_CLOSE                    6903
#define IDS_FT_EDITTITLE                6904
#define IDS_FT_EXEFILE                  6905
#define IDS_FT_MB_EXETEXT               6906
#define IDS_FT_MB_EXTTEXT               6907
#define IDS_FT_MB_NOACTION              6908
#define IDS_FT_MB_NOEXT                 6909
#define IDS_FT_MB_REMOVEACTION          6910
#define IDS_FT_MB_REMOVETYPE            6911
#define IDS_OPENAS                      6912
#define DLG_OPENAS                      7000
#define IDD_APPLIST                     7001
#define IDD_TEXT                        7002
#define IDD_MAKEASSOC                   7003
#define IDD_OTHER                       7004
#define DLG_OPENAS_NOTYPE               7005
#define IDD_DESCRIPTIONTEXT             7006
#define IDD_DESCRIPTION                 7007
#define IDS_EXE                         7008
#define IDS_PROGRAMSFILTER              7009
#define IDS_FILETYPENAME                7010
#define IDD_URL_TEXT                    7011
#define IDS_URL_DESC_FORMAT             7012
#define IDD_START_IN_TEXT               7013
#define IDD_HOTKEY_TEXT                 7014
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\refcount.cpp ===
/*
 * refcount.cpp - RefCount class implementation.
 */


/* Headers
 **********/

#include "project.hpp"
#pragma hdrstop

#include "clsfact.h"

/****************************** Public Functions *****************************/


#ifdef DEBUG

PUBLIC_CODE BOOL IsValidPCRefCount(PCRefCount pcrefcnt)
{
   // m_ulcRef may be any value.

   return(IS_VALID_READ_PTR(pcrefcnt, CRefCount));
}

#endif


/********************************** Methods **********************************/


RefCount::RefCount(void)
{
   DebugEntry(RefCount::RefCount);

   /* Don't validate this until after initialization. */

   m_ulcRef = 1;
   DLLAddRef();

   ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

   DebugExitVOID(RefCount::RefCount);

   return;
}


RefCount::~RefCount(void)
{
   DebugEntry(RefCount::~RefCount);

   ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

   // m_ulcRef may be any value.

   DLLRelease();

   ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

   DebugExitVOID(RefCount::~RefCount);

   return;
}


ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
   DebugEntry(RefCount::AddRef);

   ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

   ASSERT(m_ulcRef < ULONG_MAX);
   m_ulcRef++;

   ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

   DebugExitULONG(RefCount::AddRef, m_ulcRef);

   return(m_ulcRef);
}


ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
   ULONG ulcRef;

   DebugEntry(RefCount::Release);

   ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

   if (EVAL(m_ulcRef > 0))
      m_ulcRef--;

   ulcRef = m_ulcRef;

   if (! ulcRef)
      delete this;

   DebugExitULONG(RefCount::Release, ulcRef);

   return(ulcRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\resstr.h ===
/*
 * resstr.h - Common return code to string translation routines description.
 */


/* Prototypes
 *************/

/* resstr.c */

#ifdef DEBUG

extern PCSTR GetINTString(int);
extern PCSTR GetULONGString(ULONG);
extern PCSTR GetBOOLString(BOOL);
extern PCSTR GetClipboardFormatNameString(UINT);
extern PCSTR GetCOMPARISONRESULTString(COMPARISONRESULT);

#ifdef INC_OLE2

extern PCSTR GetHRESULTString(HRESULT);

#endif   /* INC_OLE2 */

#ifdef __SYNCENG_H__

extern PCSTR GetTWINRESULTString(TWINRESULT);
extern PCSTR GetCREATERECLISTPROCMSGString(UINT);
extern PCSTR GetRECSTATUSPROCMSGString(UINT);
extern PCSTR GetRECNODESTATEString(RECNODESTATE);
extern PCSTR GetRECNODEACTIONString(RECNODEACTION);

#endif   /* __SYNCENG_H__ */

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\resstr.c ===
/*
 * resstr.c - Return code to string translation routines.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include <intshcut.h>

#ifdef DEBUG


/* Macros
 *********/

/*
 * macro for simplifying result to string translation, assumes result string
 * pointer pcsz
 */

#define STRING_CASE(val)               case val: pcsz = #val; break


/****************************** Public Functions *****************************/


PUBLIC_CODE PCSTR GetINTString(int n)
{
   static char s_rgchINT[] = "-2147483646";

   wsprintf(s_rgchINT, "%d", n);

   ASSERT(IS_VALID_STRING_PTR(s_rgchINT, CSTR));

   return(s_rgchINT);
}


PUBLIC_CODE PCSTR GetULONGString(ULONG ul)
{
   static char s_rgchULONG[] = "4294967295";

   wsprintf(s_rgchULONG, "%lx", ul);

   ASSERT(IS_VALID_STRING_PTR(s_rgchULONG, CSTR));

   return(s_rgchULONG);
}


PUBLIC_CODE PCSTR GetBOOLString(BOOL bResult)
{
   PCSTR pcsz;

   pcsz = bResult ? "TRUE" : "FALSE";

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   return(pcsz);
}


PUBLIC_CODE PCSTR GetClipboardFormatNameString(UINT ucf)
{
   PCSTR pcsz;
   static char s_szCFName[MAX_PATH_LEN];

   switch (ucf)
   {
      STRING_CASE(CF_TEXT);
      STRING_CASE(CF_BITMAP);
      STRING_CASE(CF_METAFILEPICT);
      STRING_CASE(CF_SYLK);
      STRING_CASE(CF_DIF);
      STRING_CASE(CF_TIFF);
      STRING_CASE(CF_OEMTEXT);
      STRING_CASE(CF_DIB);
      STRING_CASE(CF_PALETTE);
      STRING_CASE(CF_PENDATA);
      STRING_CASE(CF_RIFF);
      STRING_CASE(CF_WAVE);
      STRING_CASE(CF_UNICODETEXT);
      STRING_CASE(CF_ENHMETAFILE);
      STRING_CASE(CF_HDROP);
      STRING_CASE(CF_LOCALE);
      STRING_CASE(CF_MAX);
      STRING_CASE(CF_OWNERDISPLAY);
      STRING_CASE(CF_DSPTEXT);
      STRING_CASE(CF_DSPBITMAP);
      STRING_CASE(CF_DSPMETAFILEPICT);
      STRING_CASE(CF_DSPENHMETAFILE);

      default:
         if (! GetClipboardFormatName(ucf, s_szCFName, sizeof(s_szCFName)))
            lstrcpy(s_szCFName, "UNKNOWN CLIPBOARD FORMAT");
         pcsz = s_szCFName;
         break;
   }

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   return(pcsz);
}


PUBLIC_CODE PCSTR GetCOMPARISONRESULTString(COMPARISONRESULT cr)
{
   PCSTR pcsz;

   switch (cr)
   {
      STRING_CASE(CR_FIRST_SMALLER);
      STRING_CASE(CR_FIRST_LARGER);
      STRING_CASE(CR_EQUAL);

      default:
         ERROR_OUT(("GetCOMPARISONRESULTString() called on unknown COMPARISONRESULT %d.",
                    cr));
         pcsz = "UNKNOWN COMPARISONRESULT";
         break;
   }

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   return(pcsz);
}


#ifdef INC_OLE2

PUBLIC_CODE PCSTR GetHRESULTString(HRESULT hr)
{
   PCSTR pcsz;
   static char s_rgchHRESULT[] = "0x12345678";

   switch (hr)
   {
      STRING_CASE(S_OK);
      STRING_CASE(S_FALSE);

      STRING_CASE(DRAGDROP_S_CANCEL);
      STRING_CASE(DRAGDROP_S_DROP);
      STRING_CASE(DRAGDROP_S_USEDEFAULTCURSORS);

      STRING_CASE(E_UNEXPECTED);
      STRING_CASE(E_NOTIMPL);
      STRING_CASE(E_OUTOFMEMORY);
      STRING_CASE(E_INVALIDARG);
      STRING_CASE(E_NOINTERFACE);
      STRING_CASE(E_POINTER);
      STRING_CASE(E_HANDLE);
      STRING_CASE(E_ABORT);
      STRING_CASE(E_FAIL);
      STRING_CASE(E_ACCESSDENIED);

      STRING_CASE(CLASS_E_NOAGGREGATION);

      STRING_CASE(CO_E_NOTINITIALIZED);
      STRING_CASE(CO_E_ALREADYINITIALIZED);
      STRING_CASE(CO_E_INIT_ONLY_SINGLE_THREADED);

      STRING_CASE(DV_E_DVASPECT);
      STRING_CASE(DV_E_LINDEX);
      STRING_CASE(DV_E_TYMED);
      STRING_CASE(DV_E_FORMATETC);

#ifdef __INTSHCUT_H__

      STRING_CASE(E_FLAGS);

      STRING_CASE(URL_E_INVALID_SYNTAX);
      STRING_CASE(URL_E_UNREGISTERED_PROTOCOL);

      STRING_CASE(IS_E_EXEC_FAILED);

      STRING_CASE(E_FILE_NOT_FOUND);
      STRING_CASE(E_PATH_NOT_FOUND);

#endif

      default:
         wsprintf(s_rgchHRESULT, "%#lx", hr);
         pcsz = s_rgchHRESULT;
         break;
   }

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   return(pcsz);
}

#endif   /* INC_OLE2 */

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\serial.c ===
/*
 * serial.c - Access serialization routines module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "init.h"


/* Types
 ********/

/* process information */

typedef struct _processinfo
{
   HANDLE hModule;
}
PROCESSINFO;
DECLARE_STANDARD_TYPES(PROCESSINFO);

#ifdef DEBUG

/* debug flags */

typedef enum _serialdebugflags
{
   SERIAL_DFL_BREAK_ON_PROCESS_ATTACH  = 0x0001,

   SERIAL_DFL_BREAK_ON_THREAD_ATTACH   = 0x0002,

   ALL_SERIAL_DFLAGS                   = (SERIAL_DFL_BREAK_ON_PROCESS_ATTACH |
                                          SERIAL_DFL_BREAK_ON_THREAD_ATTACH)
}
SERIALDEBUGFLAGS;

#endif   /* DEBUG */


/* Module Variables
 *******************/

#pragma data_seg(DATA_SEG_PER_INSTANCE)

/* critical section used for access serialization */

PRIVATE_DATA NONREENTRANTCRITICALSECTION s_nrcs =
{
   { 0 },

#ifdef DEBUG
   INVALID_THREAD_ID,
#endif   /* DEBUG */

   FALSE
};

/* information about current process */

/*
 * Initialize s_pi so it is actually put in the .instanc section instead of the
 * .bss section.
 */

PRIVATE_DATA PROCESSINFO s_pi =
{
   NULL
};

#pragma data_seg()

#ifdef DEBUG

#pragma data_seg(DATA_SEG_SHARED)

/* debug flags */

PRIVATE_DATA DWORD s_dwSerialModuleFlags = 0;

#pragma data_seg(DATA_SEG_READ_ONLY)

/* .ini file switch descriptions */

PRIVATE_DATA CBOOLINISWITCH s_cbisBreakOnProcessAttach =
{
   IST_BOOL,
   "BreakOnProcessAttach",
   &s_dwSerialModuleFlags,
   SERIAL_DFL_BREAK_ON_PROCESS_ATTACH
};

PRIVATE_DATA CBOOLINISWITCH s_cbisBreakOnThreadAttach =
{
   IST_BOOL,
   "BreakOnThreadAttach",
   &s_dwSerialModuleFlags,
   SERIAL_DFL_BREAK_ON_THREAD_ATTACH
};

PRIVATE_DATA const PCVOID s_rgcpcvisSerialModule[] =
{
   &s_cbisBreakOnProcessAttach,
   &s_cbisBreakOnThreadAttach
};

#pragma data_seg()

#endif   /* DEBUG */


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCSERIALCONTROL(PCSERIALCONTROL);
PRIVATE_CODE BOOL IsValidPCPROCESSINFO(PCPROCESSINFO);
PRIVATE_CODE BOOL IsValidPCCRITICAL_SECTION(PCCRITICAL_SECTION);
PRIVATE_CODE BOOL IsValidThreadId(DWORD);
PRIVATE_CODE BOOL IsValidPCNONREENTRANTCRITICALSECTION(PCNONREENTRANTCRITICALSECTION);

#endif


#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCSERIALCONTROL(PCSERIALCONTROL pcserctrl)
{
   return(IS_VALID_READ_PTR(pcserctrl, CSERIALCONTROL) &&
          (! pcserctrl->AttachProcess ||
           IS_VALID_CODE_PTR(pcserctrl->AttachProcess, AttachProcess)) &&
          (! pcserctrl->DetachProcess ||
           IS_VALID_CODE_PTR(pcserctrl->DetachProcess, DetachProcess)) &&
          (! pcserctrl->AttachThread ||
           IS_VALID_CODE_PTR(pcserctrl->AttachThread, AttachThread)) &&
          (! pcserctrl->DetachThread||
           IS_VALID_CODE_PTR(pcserctrl->DetachThread, DetachThread)));
}


PRIVATE_CODE BOOL IsValidPCPROCESSINFO(PCPROCESSINFO pcpi)
{
   return(IS_VALID_READ_PTR(pcpi, CPROCESSINFO) &&
          IS_VALID_HANDLE(pcpi->hModule, MODULE));
}


PRIVATE_CODE BOOL IsValidPCCRITICAL_SECTION(PCCRITICAL_SECTION pccritsec)
{
   return(IS_VALID_READ_PTR(pccritsec, CCRITICAL_SECTION));
}


PRIVATE_CODE BOOL IsValidThreadId(DWORD dwThreadId)
{
   return(dwThreadId != INVALID_THREAD_ID);
}


PRIVATE_CODE BOOL IsValidPCNONREENTRANTCRITICALSECTION(
                                          PCNONREENTRANTCRITICALSECTION pcnrcs)
{
   /* bEntered may be any value. */

   return(IS_VALID_READ_PTR(pcnrcs, CNONREENTRANTCRITICALSECTION) &&
          IS_VALID_STRUCT_PTR(&(pcnrcs->critsec), CCRITICAL_SECTION) &&
          EVAL(pcnrcs->dwOwnerThread == INVALID_THREAD_ID ||
               IsValidThreadId(pcnrcs->dwOwnerThread)));
}

#endif


/****************************** Public Functions *****************************/


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

#ifdef DEBUG

PUBLIC_CODE BOOL SetSerialModuleIniSwitches(void)
{
   BOOL bResult;

   bResult = SetIniSwitches(s_rgcpcvisSerialModule,
                            ARRAY_ELEMENTS(s_rgcpcvisSerialModule));

   ASSERT(FLAGS_ARE_VALID(s_dwSerialModuleFlags, ALL_SERIAL_DFLAGS));

   return(bResult);
}

#endif


PUBLIC_CODE BOOL AttachProcess(HMODULE hmod)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hmod, MODULE));

   InitializeNonReentrantCriticalSection(&s_nrcs);

   bResult = EnterNonReentrantCriticalSection(&s_nrcs);

   if (bResult)
   {

#ifdef DEBUG

      ASSERT(SetAllIniSwitches());

      TRACE_OUT(("AttachProcess(): Called for module %#lx.",
                 hmod));

      if (IS_FLAG_SET(s_dwSerialModuleFlags, SERIAL_DFL_BREAK_ON_PROCESS_ATTACH))
      {
         WARNING_OUT(("AttachProcess(): Breaking on process attach, as requested."));
#ifndef MAINWIN
         DebugBreak();
#endif
      }

#endif   /* DEBUG */

      s_pi.hModule = hmod;

      ASSERT(IS_VALID_STRUCT_PTR(&g_cserctrl, CSERIALCONTROL));

      if (g_cserctrl.AttachProcess)
         bResult = g_cserctrl.AttachProcess(hmod);

      LeaveNonReentrantCriticalSection(&s_nrcs);
   }

   return(bResult);
}


PUBLIC_CODE BOOL DetachProcess(HMODULE hmod)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hmod, MODULE));

   bResult = EnterNonReentrantCriticalSection(&s_nrcs);

   if (bResult)
   {
      ASSERT(hmod == s_pi.hModule);

      TRACE_OUT(("DetachProcess(): Called for module %#lx.",
                 hmod));

      ASSERT(IS_VALID_STRUCT_PTR(&g_cserctrl, CSERIALCONTROL));

      if (g_cserctrl.DetachProcess)
         bResult = g_cserctrl.DetachProcess(hmod);

      LeaveNonReentrantCriticalSection(&s_nrcs);

      DeleteNonReentrantCriticalSection(&s_nrcs);
   }

   return(bResult);
}


PUBLIC_CODE BOOL AttachThread(HMODULE hmod)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hmod, MODULE));

   bResult = EnterNonReentrantCriticalSection(&s_nrcs);

   if (bResult)
   {

#ifdef DEBUG

      ASSERT(SetAllIniSwitches());

      TRACE_OUT(("AttachThread() called for module %#lx, thread ID %#lx.",
                 hmod,
                 GetCurrentThreadId()));

      if (IS_FLAG_SET(s_dwSerialModuleFlags, SERIAL_DFL_BREAK_ON_THREAD_ATTACH))
      {
         WARNING_OUT(("AttachThread(): Breaking on thread attach, as requested."));
#ifndef MAINWIN
         DebugBreak();
#endif 
      }

#endif

      ASSERT(IS_VALID_STRUCT_PTR(&g_cserctrl, CSERIALCONTROL));

      if (g_cserctrl.AttachThread)
         bResult = g_cserctrl.AttachThread(hmod);
      else
         bResult = TRUE;

      LeaveNonReentrantCriticalSection(&s_nrcs);
   }

   return(bResult);
}


PUBLIC_CODE BOOL DetachThread(HMODULE hmod)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hmod, MODULE));

   bResult = EnterNonReentrantCriticalSection(&s_nrcs);

   if (bResult)
   {
      TRACE_OUT(("DetachThread() called for module %#lx, thread ID %#lx.",
                 hmod,
                 GetCurrentThreadId()));

      ASSERT(IS_VALID_STRUCT_PTR(&g_cserctrl, CSERIALCONTROL));

      if (g_cserctrl.DetachThread)
         bResult = g_cserctrl.DetachThread(hmod);
      else
         bResult = TRUE;

      LeaveNonReentrantCriticalSection(&s_nrcs);
   }

   return(bResult);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


PUBLIC_CODE void InitializeNonReentrantCriticalSection(
                                          PNONREENTRANTCRITICALSECTION pnrcs)
{
   ASSERT(IS_VALID_STRUCT_PTR(pnrcs, CNONREENTRANTCRITICALSECTION));

   InitializeCriticalSection(&(pnrcs->critsec));

   pnrcs->bEntered = FALSE;
#ifdef DEBUG
   pnrcs->dwOwnerThread = INVALID_THREAD_ID;
#endif

   return;
}


PUBLIC_CODE BOOL EnterNonReentrantCriticalSection(
                                          PNONREENTRANTCRITICALSECTION pnrcs)
{
   BOOL bEntered;

#ifdef DEBUG

   BOOL bBlocked;

   ASSERT(IS_VALID_STRUCT_PTR(pnrcs, CNONREENTRANTCRITICALSECTION));

   /* Is the critical section already owned by another thread? */

   /* Use pnrcs->bEntered and pnrcs->dwOwnerThread unprotected here. */

   bBlocked = (pnrcs->bEntered &&
               GetCurrentThreadId() != pnrcs->dwOwnerThread);

   if (bBlocked)
      TRACE_OUT(("EnterNonReentrantCriticalSection(): Blocking thread %lx.  Critical section is already owned by thread %#lx.",
                 GetCurrentThreadId(),
                 pnrcs->dwOwnerThread));

#endif

   EnterCriticalSection(&(pnrcs->critsec));

   bEntered = (! pnrcs->bEntered);

   if (bEntered)
   {
      pnrcs->bEntered = TRUE;

#ifdef DEBUG

      pnrcs->dwOwnerThread = GetCurrentThreadId();

      if (bBlocked)
         TRACE_OUT(("EnterNonReentrantCriticalSection(): Unblocking thread %lx.  Critical section is now owned by this thread.",
                    pnrcs->dwOwnerThread));
#endif

   }
   else
   {
      LeaveCriticalSection(&(pnrcs->critsec));

      ERROR_OUT(("EnterNonReentrantCriticalSection(): Thread %#lx attempted to reenter non-reentrant code.",
                 GetCurrentThreadId()));
   }

   return(bEntered);
}


PUBLIC_CODE void LeaveNonReentrantCriticalSection(
                                          PNONREENTRANTCRITICALSECTION pnrcs)
{
   ASSERT(IS_VALID_STRUCT_PTR(pnrcs, CNONREENTRANTCRITICALSECTION));

   if (EVAL(pnrcs->bEntered))
   {
      pnrcs->bEntered = FALSE;
#ifdef DEBUG
      pnrcs->dwOwnerThread = INVALID_THREAD_ID;
#endif

      LeaveCriticalSection(&(pnrcs->critsec));
   }

   return;
}


PUBLIC_CODE void DeleteNonReentrantCriticalSection(
                                          PNONREENTRANTCRITICALSECTION pnrcs)
{
   ASSERT(IS_VALID_STRUCT_PTR(pnrcs, CNONREENTRANTCRITICALSECTION));

   ASSERT(! pnrcs->bEntered);
   ASSERT(pnrcs->dwOwnerThread == INVALID_THREAD_ID);

   DeleteCriticalSection(&(pnrcs->critsec));

   return;
}


#ifdef DEBUG

PUBLIC_CODE BOOL NonReentrantCriticalSectionIsOwned(
                                          PCNONREENTRANTCRITICALSECTION pcnrcs)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcnrcs, CNONREENTRANTCRITICALSECTION));

   return(pcnrcs->bEntered);
}


PUBLIC_CODE DWORD GetNonReentrantCriticalSectionOwner(
                                          PCNONREENTRANTCRITICALSECTION pcnrcs)

{
   ASSERT(IS_VALID_STRUCT_PTR(pcnrcs, CNONREENTRANTCRITICALSECTION));

   return(pcnrcs->dwOwnerThread);
}

#endif


PUBLIC_CODE BOOL BeginExclusiveAccess(void)
{
   return(EnterNonReentrantCriticalSection(&s_nrcs));
}


PUBLIC_CODE void EndExclusiveAccess(void)
{
   LeaveNonReentrantCriticalSection(&s_nrcs);

   return;
}


#ifdef DEBUG

PUBLIC_CODE BOOL AccessIsExclusive(void)
{
   return(NonReentrantCriticalSectionIsOwned(&s_nrcs) &&
          GetNonReentrantCriticalSectionOwner(&s_nrcs) == GetCurrentThreadId());
}

#endif   /* DEBUG */


PUBLIC_CODE HMODULE GetThisModulesHandle(void)
{
   ASSERT(IS_VALID_STRUCT_PTR((PCPROCESSINFO)&s_pi, CPROCESSINFO));

   return(s_pi.hModule);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\shlink.cpp ===
/*
 * shlink.cpp - IShellLink implementation for InternetShortcut class.
 */


/* Headers
 **********/

#include "project.hpp"
#pragma hdrstop


/* Types
 ********/

typedef enum isl_getpath_flags
{
   // flag combinations

   ALL_ISL_GETPATH_FLAGS   = (SLGP_SHORTPATH |
                              SLGP_UNCPRIORITY)
}
ISL_GETPATH_FLAGS;

typedef enum isl_resolve_flags
{
   // flag combinations

   ALL_ISL_RESOLVE_FLAGS   = (SLR_NO_UI |
                              SLR_ANY_MATCH |
                              SLR_UPDATE)
}
ISL_RESOLVE_FLAGS;


/********************************** Methods **********************************/


HRESULT STDMETHODCALLTYPE InternetShortcut::SetPath(PCSTR pcszPath)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::SetPath);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));

   // Treat path as literal URL.

   hr = SetURL(pcszPath, 0);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::SetPath, hr);

   return(hr);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE InternetShortcut::GetPath(PSTR pszFile,
                                                    int ncFileBufLen,
                                                    PWIN32_FIND_DATA pwfd,
                                                    DWORD dwFlags)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::GetPath);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszFile, STR, ncFileBufLen));
   ASSERT(NULL == pwfd || IS_VALID_STRUCT_PTR(pwfd, CWIN32_FIND_DATA));
   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_ISL_GETPATH_FLAGS));

   // Ignore dwFlags.

   if (pwfd)
      ZeroMemory(pwfd, sizeof(*pwfd));

   if (m_pszURL)
   {
      lstrcpyn(pszFile, m_pszURL, ncFileBufLen);

      hr = S_OK;
   }
   else
   {
      // No URL.

      if (ncFileBufLen > 0)
         *pszFile = '\0';

      hr = S_FALSE;
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT((hr == S_OK &&
           (ncFileBufLen < 1 ||
            IS_VALID_STRING_PTR(pszFile, STR))) ||
          (hr == S_FALSE &&
           (ncFileBufLen < 1 ||
            ! *pszFile)));

   DebugExitHRESULT(InternetShortcut::GetPath, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::SetRelativePath(
                                                      PCSTR pcszRelativePath,
                                                      DWORD dwReserved)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::SetRelativePath);

   // dwReserved may be any value.

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRING_PTR(pcszRelativePath, CSTR));

   hr = E_NOTIMPL;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::SetRelativePath, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::SetIDList(LPCITEMIDLIST pcidl)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::SetIDList);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRUCT_PTR(pcidl, CITEMIDLIST));

   hr = E_NOTIMPL;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::SetIDList, hr);

   return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


HRESULT STDMETHODCALLTYPE InternetShortcut::GetIDList(LPITEMIDLIST *ppidl)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::GetIDList);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_WRITE_PTR(ppidl, PITEMIDLIST));

   *ppidl = NULL;

   hr = E_NOTIMPL;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::GetIDList, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::SetDescription(
                                                         PCSTR pcszDescription)
{
   HRESULT hr;
   BOOL bDifferent;
   PSTR pszFileCopy;

   DebugEntry(InternetShortcut::SetDescription);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRING_PTR(pcszDescription, CSTR));

   // Set m_pszFile to description.

   bDifferent = (! m_pszFile ||
                 lstrcmp(pcszDescription, m_pszFile) != 0);

   if (StringCopy(pcszDescription, &pszFileCopy))
   {
      if (m_pszFile)
      {
         delete m_pszFile;
         m_pszFile = NULL;
      }

      m_pszFile = pszFileCopy;

      if (bDifferent)
         Dirty(TRUE);

      hr = S_OK;
   }
   else
      hr = E_OUTOFMEMORY;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::SetDescription, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::GetDescription(
                                                      PSTR pszDescription,
                                                      int ncDesciptionBufLen)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::GetDescription);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszDescription, STR, ncDesciptionBufLen));

   // Get description from m_pszFile.

   if (m_pszFile)
      lstrcpyn(pszDescription, m_pszFile, ncDesciptionBufLen);
   else
   {
      if (ncDesciptionBufLen > 0)
         pszDescription = '\0';
   }

   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(hr == S_OK &&
          (ncDesciptionBufLen <= 0 ||
           (IS_VALID_STRING_PTR(pszDescription, STR) &&
            EVAL(lstrlen(pszDescription) < ncDesciptionBufLen))));

   DebugExitHRESULT(InternetShortcut::GetDescription, hr);

   return(hr);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE InternetShortcut::SetArguments(PCSTR pcszArgs)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::SetArguments);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRING_PTR(pcszArgs, CSTR));

   hr = E_NOTIMPL;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::SetArguments, hr);

   return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


HRESULT STDMETHODCALLTYPE InternetShortcut::GetArguments(PSTR pszArgs,
                                                         int ncArgsBufLen)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::GetArguments);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszArgs, STR, ncArgsBufLen));

   if (ncArgsBufLen > 0)
      *pszArgs = '\0';

   hr = E_NOTIMPL;

   WARNING_OUT(("InternetShortcut::GetArguments(): Arguments not maintained for CLSID_InternetShortcut."));

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::GetArguments, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::SetWorkingDirectory(
                                                   PCSTR pcszWorkingDirectory)
{
   HRESULT hr = S_OK;
   char rgchNewPath[MAX_PATH_LEN];
   BOOL bChanged = FALSE;
   PSTR pszNewWorkingDirectory = NULL;

   DebugEntry(InternetShortcut::SetWorkingDirectory);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(! pcszWorkingDirectory ||
          IS_VALID_STRING_PTR(pcszWorkingDirectory, CSTR));

   if (! AnyMeat(pcszWorkingDirectory))
      pcszWorkingDirectory = NULL;

   if (pcszWorkingDirectory)
   {
      PSTR pszFileName;

      if (GetFullPathName(pcszWorkingDirectory, sizeof(rgchNewPath),
                          rgchNewPath, &pszFileName) > 0)
         pcszWorkingDirectory = rgchNewPath;
      else
         hr = E_PATH_NOT_FOUND;
   }

   if (hr == S_OK)
   {
      bChanged = ! ((! pcszWorkingDirectory && ! m_pszWorkingDirectory) ||
                    (pcszWorkingDirectory && m_pszWorkingDirectory &&
                     ! lstrcmp(pcszWorkingDirectory, m_pszWorkingDirectory)));

      if (bChanged && pcszWorkingDirectory)
      {
         // (+ 1) for null terminator.

         pszNewWorkingDirectory = new(char[lstrlen(pcszWorkingDirectory) + 1]);

         if (pszNewWorkingDirectory)
            lstrcpy(pszNewWorkingDirectory, pcszWorkingDirectory);
         else
            hr = E_OUTOFMEMORY;
      }
   }

   if (hr == S_OK)
   {
      if (bChanged)
      {
         if (m_pszWorkingDirectory)
            delete m_pszWorkingDirectory;

         m_pszWorkingDirectory = pszNewWorkingDirectory;

         Dirty(TRUE);

         TRACE_OUT(("InternetShortcut::SetWorkingDirectory(): Set working directory to %s.",
                    CHECK_STRING(m_pszWorkingDirectory)));
      }
      else
         TRACE_OUT(("InternetShortcut::SetWorkingDirectory(): Working directory already %s.",
                    CHECK_STRING(m_pszWorkingDirectory)));
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(hr == S_OK ||
          hr == E_OUTOFMEMORY ||
          hr == E_PATH_NOT_FOUND);

   DebugExitHRESULT(InternetShortcut::SetWorkingDirectory, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::GetWorkingDirectory(
                                                PSTR pszWorkingDirectory,
                                                int ncbWorkingDirectoryBufLen)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::GetWorkingDirectory);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszWorkingDirectory, STR, ncbWorkingDirectoryBufLen));

   if (m_pszWorkingDirectory)
   {
      lstrcpyn(pszWorkingDirectory, m_pszWorkingDirectory,
                 ncbWorkingDirectoryBufLen);

      hr = S_OK;
   }
   else
   {
      if (ncbWorkingDirectoryBufLen > 0)
         *pszWorkingDirectory = '\0';

      hr = S_FALSE;
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IsValidPathResult(hr, pszWorkingDirectory, ncbWorkingDirectoryBufLen));
   ASSERT(hr == S_OK ||
          hr == S_FALSE);

   DebugExitHRESULT(InternetShortcut::GetWorkingDirectory, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::SetHotkey(WORD wHotkey)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::SetHotkey);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(! wHotkey ||
          EVAL(IsValidHotkey(wHotkey)));

   if (wHotkey != m_wHotkey)
      Dirty(TRUE);

   m_wHotkey = wHotkey;

   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::SetHotkey, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::GetHotkey(PWORD pwHotkey)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::GetHotkey);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_WRITE_PTR(pwHotkey, WORD));

   *pwHotkey = m_wHotkey;

   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(! *pwHotkey ||
          EVAL(IsValidHotkey(*pwHotkey)));

   DebugExitHRESULT(InternetShortcut::GetHotkey, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::SetShowCmd(int nShowCmd)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::SetShowCmd);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IsValidShowCmd(nShowCmd));

   if (nShowCmd != m_nShowCmd)
   {
      m_nShowCmd = nShowCmd;

      Dirty(TRUE);

      TRACE_OUT(("InternetShortcut::SetShowCmd(): Set show command to %d.",
                 m_nShowCmd));
   }
   else
      TRACE_OUT(("InternetShortcut::SetShowCmd(): Show command already %d.",
                 m_nShowCmd));

   hr = S_OK;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(hr == S_OK);

   DebugExitHRESULT(InternetShortcut::SetShowCmd, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::GetShowCmd(PINT pnShowCmd)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::GetShowCmd);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_WRITE_PTR(pnShowCmd, INT));

   *pnShowCmd = m_nShowCmd;

   hr = S_OK;

   ASSERT(IsValidShowCmd(m_nShowCmd));

   DebugExitHRESULT(InternetShortcut::GetShowCmd, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::SetIconLocation(PCSTR pcszIconFile,
                                                            int niIcon)
{
   HRESULT hr = S_OK;
   BOOL bNewMeat;
   char rgchNewPath[MAX_PATH_LEN];

   DebugEntry(InternetShortcut::SetIconLocation);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IsValidIconIndex(pcszIconFile ? S_OK : S_FALSE, pcszIconFile, MAX_PATH_LEN, niIcon));

   bNewMeat = AnyMeat(pcszIconFile);

   if (bNewMeat)
      hr = FullyQualifyPath(pcszIconFile, rgchNewPath, sizeof(rgchNewPath));

   if (hr == S_OK)
   {
      char rgchOldPath[MAX_PATH_LEN];
      int niOldIcon;
      UINT uFlags;

      hr = GetIconLocation(0, rgchOldPath, sizeof(rgchOldPath), &niOldIcon,
                           &uFlags);

      if (SUCCEEDED(hr))
      {
         BOOL bOldMeat;
         BOOL bChanged = FALSE;
         PSTR pszNewIconFile = NULL;
         int niNewIcon = 0;

         bOldMeat = AnyMeat(rgchOldPath);

         ASSERT(! *rgchOldPath ||
                bOldMeat);

         bChanged = ((! bOldMeat && bNewMeat) ||
                     (bOldMeat && ! bNewMeat) ||
                     (bOldMeat && bNewMeat &&
                      (lstrcmp(rgchOldPath, rgchNewPath) != 0 ||
                       niIcon != niOldIcon)));

         if (bChanged && bNewMeat)
         {
            // (+ 1) for null terminator.

            pszNewIconFile = new(char[lstrlen(rgchNewPath) + 1]);

            if (pszNewIconFile)
            {
               lstrcpy(pszNewIconFile, rgchNewPath);
               niNewIcon = niIcon;

               hr = S_OK;
            }
            else
               hr = E_OUTOFMEMORY;
         }
         else
            hr = S_OK;

         if (hr == S_OK)
         {
            if (bChanged)
            {
               if (m_pszIconFile)
                  delete m_pszIconFile;

               m_pszIconFile = pszNewIconFile;
               m_niIcon = niNewIcon;

               Dirty(TRUE);

               TRACE_OUT(("InternetShortcut::SetIconLocation(): Set icon location to %d in %s.",
                          m_niIcon,
                          CHECK_STRING(m_pszIconFile)));
            }
            else
               TRACE_OUT(("InternetShortcut::SetIconLocation(): Icon location already %d in %s.",
                          m_niIcon,
                          CHECK_STRING(m_pszIconFile)));
         }
      }
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(hr == S_OK ||
          hr == E_OUTOFMEMORY ||
          hr == E_FILE_NOT_FOUND);

   DebugExitHRESULT(InternetShortcut::SetIconLocation, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::GetIconLocation(
                                                         PSTR pszIconFile,
                                                         int ncbIconFileBufLen,
                                                         PINT pniIcon)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::GetIconLocation);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszIconFile, STR, ncbIconFileBufLen));
   ASSERT(IS_VALID_WRITE_PTR(pniIcon, int));

   if (m_pszIconFile)
   {
      lstrcpyn(pszIconFile, m_pszIconFile, ncbIconFileBufLen);
      *pniIcon = m_niIcon;

      hr = S_OK;
   }
   else
   {
      if (ncbIconFileBufLen > 0)
         *pszIconFile = '\0';
      *pniIcon = 0;

      hr = S_FALSE;
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IsValidIconIndex(hr, pszIconFile, ncbIconFileBufLen, *pniIcon));

   DebugExitHRESULT(InternetShortcut::GetIconLocation, hr);

   return(hr);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

HRESULT STDMETHODCALLTYPE InternetShortcut::Resolve(HWND hwnd, DWORD dwFlags)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::Resolve);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_HANDLE(hwnd, WND));
   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_ISL_RESOLVE_FLAGS));

   hr = S_OK;

   WARNING_OUT(("InternetShortcut::Resolve(): This method is a NOP for CLSID_InternetShortcut."));

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));

   DebugExitHRESULT(InternetShortcut::Resolve, hr);

   return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\serial.h ===
/*
 * serial.h - Access serialization routines description.
 */


/* Types
 ********/

typedef struct _serialcontrol
{
   BOOL (*AttachProcess)(HMODULE);
   BOOL (*DetachProcess)(HMODULE);
   BOOL (*AttachThread)(HMODULE);
   BOOL (*DetachThread)(HMODULE);
}
SERIALCONTROL;
DECLARE_STANDARD_TYPES(SERIALCONTROL);

typedef struct _nonreentrantcriticalsection
{
   CRITICAL_SECTION critsec;

#ifdef DEBUG
   DWORD dwOwnerThread;
#endif   /* DEBUG */

   BOOL bEntered;
}
NONREENTRANTCRITICALSECTION;
DECLARE_STANDARD_TYPES(NONREENTRANTCRITICALSECTION);


/* Prototypes
 *************/

/* serial.c */

#ifdef DEBUG

extern BOOL SetSerialModuleIniSwitches(void);

#endif   /* DEBUG */

extern void InitializeNonReentrantCriticalSection(PNONREENTRANTCRITICALSECTION);
extern BOOL EnterNonReentrantCriticalSection(PNONREENTRANTCRITICALSECTION);
extern void LeaveNonReentrantCriticalSection(PNONREENTRANTCRITICALSECTION);
extern void DeleteNonReentrantCriticalSection(PNONREENTRANTCRITICALSECTION);

#ifdef DEBUG

extern BOOL NonReentrantCriticalSectionIsOwned(PCNONREENTRANTCRITICALSECTION);
extern DWORD GetNonReentrantCriticalSectionOwner(PCNONREENTRANTCRITICALSECTION);

#endif

extern BOOL BeginExclusiveAccess(void);
extern void EndExclusiveAccess(void);

#ifdef DEBUG

extern BOOL AccessIsExclusive(void);

#endif   /* DEBUG */

extern HMODULE GetThisModulesHandle(void);

/* functions to be provided by client */

#ifdef DEBUG

extern BOOL SetAllIniSwitches(void);

#endif


/* Global Variables
 *******************/

/* serialization control structure */

extern CSERIALCONTROL g_cserctrl;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\shlstock.h ===
/*
 * shlstock.h - Stock Shell header file.
 */


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */

#include <shlapip.h>

/* Types
 ********/

/* interfaces */

DECLARE_STANDARD_TYPES(IExtractIcon);
DECLARE_STANDARD_TYPES(INewShortcutHook);
DECLARE_STANDARD_TYPES(IShellExecuteHook);
DECLARE_STANDARD_TYPES(IShellLink);
DECLARE_STANDARD_TYPES(IShellExtInit);
DECLARE_STANDARD_TYPES(IShellPropSheetExt);

/* structures */

DECLARE_STANDARD_TYPES(DROPFILES);
DECLARE_STANDARD_TYPES(FILEDESCRIPTOR);
DECLARE_STANDARD_TYPES(FILEGROUPDESCRIPTOR);
DECLARE_STANDARD_TYPES(PROPSHEETPAGE);
DECLARE_STANDARD_TYPES(SHELLEXECUTEINFO);
DECLARE_STANDARD_TYPES_U(ITEMIDLIST);  /* WINNT: RISC care about alignment: */
/* WINNT: LPITEMIDLIST+LPCITEMIDLIST declared UNALIGNED in sdk\inc\shlobj.h */

#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\shlexhk.cpp ===
/*
 * shlexhk.cpp - IShellExecuteHook implementation for URL class.
 */


/* Headers
 **********/

#include "project.hpp"
#pragma hdrstop


/* Module Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

PRIVATE_DATA const char s_cszOpenVerb[]   = "open";

#pragma data_seg()


/********************************** Methods **********************************/


HRESULT STDMETHODCALLTYPE InternetShortcut::Execute(PSHELLEXECUTEINFO pei)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::Execute);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRUCT_PTR(pei, CSHELLEXECUTEINFO));

   if (! pei->lpVerb ||
       ! lstrcmpi(pei->lpVerb, s_cszOpenVerb))
   {
      if (pei->lpFile)
      {
         PSTR pszTranslatedURL;

         hr = TranslateURL(pei->lpFile, TRANSLATEURL_FL_GUESS_PROTOCOL,
                           &pszTranslatedURL);

         if (SUCCEEDED(hr))
         {
            PCSTR pcszURLToUse;

            pcszURLToUse = (hr == S_OK) ? pszTranslatedURL : pei->lpFile;

            hr = ValidateURL(pcszURLToUse);

            if (hr == S_OK)
            {
               hr = SetURL(pcszURLToUse, 0);

               if (hr == S_OK)
               {
                  URLINVOKECOMMANDINFO urlici;

                  EVAL(SetShowCmd(pei->nShow) == S_OK);

                  urlici.dwcbSize = sizeof(urlici);
                  urlici.hwndParent = pei->hwnd;
                  urlici.pcszVerb = NULL;

                  urlici.dwFlags = IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB;

                  if (IS_FLAG_CLEAR(pei->fMask, SEE_MASK_FLAG_NO_UI))
                     SET_FLAG(urlici.dwFlags, IURL_INVOKECOMMAND_FL_ALLOW_UI);

                  hr = InvokeCommand(&urlici);

                  if (hr != S_OK)
                  {
                     SET_FLAG(pei->fMask, SEE_MASK_FLAG_NO_UI);

                     TRACE_OUT(("InternetShortcut::Execute(): InternetShortcut::InvokeCommand() failed, returning %s.  Clearing SEE_MASK_FLAG_NO_UI to avoid error ui from ShellExecute().",
                                GetHRESULTString(hr)));
                  }
               }
            }

            if (pszTranslatedURL)
            {
               LocalFree(pszTranslatedURL);
               pszTranslatedURL = NULL;
            }
         }
      }
      else
         // This hook only handles execution of file string, not IDList.
         hr = S_FALSE;
   }
   else
      // Unrecognized verb.
      hr = S_FALSE;

   if (hr == S_OK)
      pei->hInstApp = (HINSTANCE)42;
   else if (FAILED(hr))
   {
      switch (hr)
      {
         case URL_E_INVALID_SYNTAX:
         case URL_E_UNREGISTERED_PROTOCOL:
            hr = S_FALSE;
            break;

         case E_OUTOFMEMORY:
            pei->hInstApp = (HINSTANCE)SE_ERR_OOM;
            hr = E_FAIL;
            break;

         case IS_E_EXEC_FAILED:
            // Translate execution failure into "file not found".
            pei->hInstApp = (HINSTANCE)SE_ERR_FNF;
            hr = E_FAIL;
            break;

         default:
            // pei->lpFile is bogus.  Treat as file not found.
            ASSERT(hr == E_POINTER);
            // We should never get E_FLAGS from TranslateURL() here.
            pei->hInstApp = (HINSTANCE)SE_ERR_FNF;
            hr = E_FAIL;
            break;
      }
   }
   else
      ASSERT(hr == S_FALSE);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRUCT_PTR(pei, CSHELLEXECUTEINFO));
   ASSERT(hr == S_OK ||
          hr == S_FALSE ||
          hr == E_FAIL);

   DebugExitHRESULT(InternetShortcut::Execute, hr);

   return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\shlvalid.h ===
/*
 * shlvalid.h - Shell validation functions description.
 */


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Prototypes
 *************/

/* shlvalid.c */

#ifdef DEBUG

/* interfaces */

extern BOOL IsValidPCIExtractIcon(PCIExtractIcon pciei);
extern BOOL IsValidPCINewShortcutHook(PCINewShortcutHook pcinshhk);
extern BOOL IsValidPCIShellExecuteHook(PCIShellExecuteHook pciseh);
extern BOOL IsValidPCIShellExtInit(PCIShellExtInit pcisei);
extern BOOL IsValidPCIShellLink(PCIShellLink pcisl);
extern BOOL IsValidPCIShellPropSheetExt(PCIShellPropSheetExt pcispse);

/* structures */

extern BOOL IsValidPCITEMIDLIST(PCITEMIDLIST pcidl);
extern BOOL IsValidPCPROPSHEETPAGE(PCPROPSHEETPAGE pcpsp);
extern BOOL IsValidPCSHELLEXECUTEINFO(PCSHELLEXECUTEINFO pcei);

#endif   /* DEBUG */


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\stock.h ===
/*
 * stock.h - Stock header file.
 */


/* Constants
 ************/

#define FOREVER                  for (;;)

#define INVALID_SEEK_POSITION    (0xffffffff)

#define EMPTY_STRING             ""

#ifdef DEBUG
#define NULL_STRING              "(null)"
#endif

#define SLASH_SLASH              "\\\\"

#define ASTERISK                 '*'
#define BACKSLASH                '/'
#define COLON                    ':'
#define COMMA                    ','
#define EQUAL                    '='
#define PERIOD                   '.'
#define POUND                    '#'
#define QMARK                    '?'
#define QUOTE                    '\''
#define QUOTES                   '"'
#define SLASH                    '\\'
#define SPACE                    ' '
#define TAB                      '\t'

/* linkage */

/* #pragma data_seg() doesn't work for variables defined extern. */
#define PUBLIC_CODE
#define PUBLIC_DATA
/* Make private functions and data public for profiling and debugging. */
#define PRIVATE_CODE             PUBLIC_CODE
#define PRIVATE_DATA             PUBLIC_DATA
#ifdef __cplusplus
#define INLINE                   inline
#else
#define INLINE                   __inline
#endif

/* limits */

#define WORD_MAX                 USHRT_MAX
#define DWORD_MAX                ULONG_MAX

/* file system constants */

#define MAX_BUF                  260
#define MAX_PATH_LEN             MAX_PATH
#define MAX_NAME_LEN             MAX_PATH
#define MAX_FOLDER_DEPTH         (MAX_PATH / 2)
#define DRIVE_ROOT_PATH_LEN      (4)

/* ui constants */

#define MAX_MSG_LEN              MAX_PATH_LEN

/* invalid thread ID */

#define INVALID_THREAD_ID        (0xffffffff)

/* no context-sensitive help available */

#define NO_HELP                  ((DWORD)-1)

/* Win32 HRESULTs */

#define E_FILE_NOT_FOUND         MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)
#define E_PATH_NOT_FOUND         MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_PATH_NOT_FOUND)

/* file-related flag combinations */

#define ALL_FILE_ACCESS_FLAGS          (GENERIC_READ |\
                                        GENERIC_WRITE)

#define ALL_FILE_SHARING_FLAGS         (FILE_SHARE_READ |\
                                        FILE_SHARE_WRITE)

#define ALL_FILE_ATTRIBUTES            (FILE_ATTRIBUTE_READONLY |\
                                        FILE_ATTRIBUTE_HIDDEN |\
                                        FILE_ATTRIBUTE_SYSTEM |\
                                        FILE_ATTRIBUTE_DIRECTORY |\
                                        FILE_ATTRIBUTE_ARCHIVE |\
                                        FILE_ATTRIBUTE_NORMAL |\
                                        FILE_ATTRIBUTE_TEMPORARY |\
                                        FILE_ATTRIBUTE_ATOMIC_WRITE |\
                                        FILE_ATTRIBUTE_XACTION_WRITE)

#define ALL_FILE_FLAGS                 (FILE_FLAG_WRITE_THROUGH |\
                                        FILE_FLAG_OVERLAPPED |\
                                        FILE_FLAG_NO_BUFFERING |\
                                        FILE_FLAG_RANDOM_ACCESS |\
                                        FILE_FLAG_SEQUENTIAL_SCAN |\
                                        FILE_FLAG_DELETE_ON_CLOSE |\
                                        FILE_FLAG_BACKUP_SEMANTICS |\
                                        FILE_FLAG_POSIX_SEMANTICS)

#define ALL_FILE_ATTRIBUTES_AND_FLAGS  (ALL_FILE_ATTRIBUTES |\
                                        ALL_FILE_FLAGS)


/* Macros
 *********/

#ifndef DECLARE_STANDARD_TYPES

/*
 * For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
 */

#define DECLARE_STANDARD_TYPES(type)      typedef type *P##type; \
                                          typedef const type C##type; \
                                          typedef const type *PC##type;

#endif

/*
 * For a type "FOO", define the standard derived UNALIGNED types PFOO, CFOO, and PCFOO.
 *  WINNT: RISC boxes care about ALIGNED, intel does not.
 */

#define DECLARE_STANDARD_TYPES_U(type)    typedef UNALIGNED type *P##type; \
                                          typedef UNALIGNED const type C##type; \
                                          typedef UNALIGNED const type *PC##type;


/* character manipulation */

#define IS_SLASH(ch)                      ((ch) == SLASH || (ch) == BACKSLASH)

#ifdef InRange
#undef InRange
#endif
#define InRange(id, idFirst, idLast)      ((UINT)(id-idFirst) <= (UINT)(idLast-idFirst))

/* bit flag manipulation */

#define SET_FLAG(dwAllFlags, dwFlag)      ((dwAllFlags) |= (dwFlag))
#define CLEAR_FLAG(dwAllFlags, dwFlag)    ((dwAllFlags) &= (~dwFlag))

#define IS_FLAG_SET(dwAllFlags, dwFlag)   ((BOOL)((dwAllFlags) & (dwFlag)))
#define IS_FLAG_CLEAR(dwAllFlags, dwFlag) (! (IS_FLAG_SET(dwAllFlags, dwFlag)))

#define SetFlag                           SET_FLAG
#define ClearFlag                         CLEAR_FLAG
#define IsFlagSet                         IS_FLAG_SET
#define IsFlagClear                       IS_FLAG_CLEAR

/* array element count */

#define ARRAY_ELEMENTS(rg)                (sizeof(rg) / sizeof((rg)[0]))
#ifdef SIZECHARS
#undef SIZECHARS
#endif
#define SIZECHARS(rg)                     ARRAY_ELEMENTS(rg)

/* string safety */

#define CHECK_STRING(psz)                 ((psz) ? (psz) : NULL_STRING)

/* file attribute manipulation */

#define IS_ATTR_DIR(attr)                 (IS_FLAG_SET((attr), FILE_ATTRIBUTE_DIRECTORY))
#define IS_ATTR_VOLUME(attr)              (IS_FLAG_SET((attr), FILE_ATTRIBUTE_VOLUME))

/* stuff a point value packed in an LPARAM into a POINT */

#define LPARAM_TO_POINT(lparam, pt)       ((pt).x = (short)LOWORD(lparam), \
                                           (pt).y = (short)HIWORD(lparam))

/* use the Win32 API string equivalents */

#define lstrnicmp(sz1, sz2, cch)          (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE, sz1, cch, sz2, cch) - 2)
#define lstrncmp(sz1, sz2, cch)           (CompareString(LOCALE_USER_DEFAULT, 0, sz1, cch, sz2, cch) - 2)

// Count of characters to count of bytes
//
#define CbFromCchW(cch)                   ((cch)*sizeof(WCHAR))
#define CbFromCchA(cch)                   ((cch)*sizeof(CHAR))
#ifdef UNICODE
#define CbFromCch                         CbFromCchW
#else  // UNICODE
#define CbFromCch                         CbFromCchA
#endif // UNICODE


//
// SAFECAST(obj, type)
//
// This macro is extremely useful for enforcing strong typechecking on other
// macros.  It generates no code.
//
// Simply insert this macro at the beginning of an expression list for
// each parameter that must be typechecked.  For example, for the
// definition of MYMAX(x, y), where x and y absolutely must be integers,
// use:
//
//   #define MYMAX(x, y)    (SAFECAST(x, int), SAFECAST(y, int), ((x) > (y) ? (x) : (y)))
//
//
#define SAFECAST(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))


/* Types
 ********/

typedef const void *PCVOID;
typedef const INT CINT;
typedef const INT *PCINT;
typedef const UINT CUINT;
typedef const UINT *PCUINT;
typedef const LONG CULONG;
typedef const LONG *PCULONG;
typedef const BYTE CBYTE;
typedef const BYTE *PCBYTE;
typedef const WORD CWORD;
typedef const WORD *PCWORD;
typedef const DWORD CDWORD;
typedef const DWORD *PCDWORD;
typedef const CRITICAL_SECTION CCRITICAL_SECTION;
typedef const CRITICAL_SECTION *PCCRITICAL_SECTION;
typedef const FILETIME CFILETIME;
typedef const FILETIME *PCFILETIME;
typedef const BITMAPINFO CBITMAPINFO;
typedef const BITMAPINFO *PCBITMAPINFO;
typedef const POINT CPOINT;
typedef const POINT *PCPOINT;
typedef const POINTL CPOINTL;
typedef const POINTL *PCPOINTL;
typedef const SECURITY_ATTRIBUTES CSECURITY_ATTRIBUTES;
typedef const SECURITY_ATTRIBUTES *PCSECURITY_ATTRIBUTES;
typedef const WIN32_FIND_DATA CWIN32_FIND_DATA;
typedef const WIN32_FIND_DATA *PCWIN32_FIND_DATA;

DECLARE_STANDARD_TYPES(HGLOBAL);
DECLARE_STANDARD_TYPES(HICON);
DECLARE_STANDARD_TYPES(HMENU);
DECLARE_STANDARD_TYPES(HWND);
DECLARE_STANDARD_TYPES(NMHDR);

#ifndef _COMPARISONRESULT_DEFINED_

/* comparison result */

typedef enum _comparisonresult
{
   CR_FIRST_SMALLER = -1,
   CR_EQUAL = 0,
   CR_FIRST_LARGER = +1
}
COMPARISONRESULT;
DECLARE_STANDARD_TYPES(COMPARISONRESULT);

#define _COMPARISONRESULT_DEFINED_

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\shlvalid.c ===
/*
 * shlvalid.c - Shell validation functions module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "olestock.h"
#include "olevalid.h"
#include "shlstock.h"
#include "shlvalid.h"

#ifdef DEBUG


/****************************** Public Functions *****************************/


PUBLIC_CODE BOOL IsValidPCIExtractIcon(PCIExtractIcon pciei)
{
   return(IS_VALID_READ_PTR(pciei, CIExtractIcon) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pciei, IUnknown) &&
          IS_VALID_METHOD(pciei, GetIconLocation) &&
          IS_VALID_METHOD(pciei, Extract));
}


PUBLIC_CODE BOOL IsValidPCINewShortcutHook(PCINewShortcutHook pcinshhk)
{
   return(IS_VALID_READ_PTR(pcinshhk, CINewShortcutHook) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcinshhk, IUnknown) &&
          IS_VALID_METHOD(pcinshhk, SetReferent) &&
          IS_VALID_METHOD(pcinshhk, GetReferent) &&
          IS_VALID_METHOD(pcinshhk, SetFolder) &&
          IS_VALID_METHOD(pcinshhk, GetFolder) &&
          IS_VALID_METHOD(pcinshhk, GetName) &&
          IS_VALID_METHOD(pcinshhk, GetExtension));
}


PUBLIC_CODE BOOL IsValidPCIShellExecuteHook(PCIShellExecuteHook pciseh)
{
   return(IS_VALID_READ_PTR(pciseh, CIShellExecuteHook) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pciseh, IUnknown) &&
          IS_VALID_METHOD(pciseh, Execute));
}


PUBLIC_CODE BOOL IsValidPCIShellExtInit(PCIShellExtInit pcisei)
{
   return(IS_VALID_READ_PTR(pcisei, CIShellExtInit) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcisei, IUnknown) &&
          IS_VALID_METHOD(pcisei, Initialize));
}


PUBLIC_CODE BOOL IsValidPCIShellLink(PCIShellLink pcisl)
{
   return(IS_VALID_READ_PTR(pcisl, CIShellLink) &&
          IS_VALID_READ_PTR(pcisl->lpVtbl, sizeof(*(pcisl->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcisl, IUnknown) &&
          IS_VALID_METHOD(pcisl, SetPath) &&
          IS_VALID_METHOD(pcisl, GetPath) &&
          IS_VALID_METHOD(pcisl, SetRelativePath) &&
          IS_VALID_METHOD(pcisl, SetIDList) &&
          IS_VALID_METHOD(pcisl, GetIDList) &&
          IS_VALID_METHOD(pcisl, SetDescription) &&
          IS_VALID_METHOD(pcisl, GetDescription) &&
          IS_VALID_METHOD(pcisl, SetArguments) &&
          IS_VALID_METHOD(pcisl, GetArguments) &&
          IS_VALID_METHOD(pcisl, SetWorkingDirectory) &&
          IS_VALID_METHOD(pcisl, GetWorkingDirectory) &&
          IS_VALID_METHOD(pcisl, SetHotkey) &&
          IS_VALID_METHOD(pcisl, GetHotkey) &&
          IS_VALID_METHOD(pcisl, SetShowCmd) &&
          IS_VALID_METHOD(pcisl, GetShowCmd) &&
          IS_VALID_METHOD(pcisl, SetIconLocation) &&
          IS_VALID_METHOD(pcisl, GetIconLocation) &&
          IS_VALID_METHOD(pcisl, Resolve));
}


PUBLIC_CODE BOOL IsValidPCIShellPropSheetExt(PCIShellPropSheetExt pcispse)
{
   return(IS_VALID_READ_PTR(pcispse, CIShellPropSheetExt) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcispse, IUnknown) &&
          IS_VALID_METHOD(pcispse, AddPages) &&
          IS_VALID_METHOD(pcispse, ReplacePage));
}


PUBLIC_CODE BOOL IsValidPCITEMIDLIST(PCITEMIDLIST pcidl)
{
   /* FEATURE: Fill me in. */

   return(IS_VALID_READ_PTR(pcidl, CITEMIDLIST));
}


PUBLIC_CODE BOOL IsValidPCPROPSHEETPAGE(PCPROPSHEETPAGE pcpsp)
{
   /* FEATURE: Fill me in. */

   return(IS_VALID_READ_PTR(pcpsp, CPROPSHEETPAGE));
}


PUBLIC_CODE BOOL IsValidPCSHELLEXECUTEINFO(PCSHELLEXECUTEINFO pcei)
{
   /* hInstApp may be any value. */
   /* dwHotKey may be any value. */

   return(IS_VALID_READ_PTR(pcei, CSHELLEXECUTEINFO) &&
          pcei->cbSize >= sizeof(*pcei) &&
          FLAGS_ARE_VALID(pcei->fMask, SEE_MASK_VALID) &&
          (! pcei->hwnd ||
           IS_VALID_HANDLE(pcei->hwnd, WND)) &&
          (! pcei->lpVerb ||
           IS_VALID_STRING_PTR(pcei->lpVerb, CSTR)) &&
          (! pcei->lpFile ||
           IS_VALID_STRING_PTR(pcei->lpFile, CSTR)) &&
          (! pcei->lpParameters ||
           IS_VALID_STRING_PTR(pcei->lpParameters, CSTR)) &&
          (! pcei->lpDirectory ||
           IS_VALID_STRING_PTR(pcei->lpDirectory, CSTR)) &&
          EVAL(IsValidShowCmd(pcei->nShow)) &&
          (IS_FLAG_CLEAR(pcei->fMask, SEE_MASK_IDLIST) ||
           IS_VALID_STRUCT_PTR(pcei->lpIDList, CITEMIDLIST)) &&
          ((pcei->fMask & SEE_MASK_CLASSKEY) == SEE_MASK_CLASSKEY ||
           IS_FLAG_CLEAR(pcei->fMask, SEE_MASK_CLASSNAME) ||
           IS_VALID_STRING_PTR(pcei->lpClass, CSTR)) &&
          (IS_FLAG_CLEAR(pcei->fMask, SEE_MASK_CLASSKEY) ||
           IS_VALID_HANDLE(pcei->hkeyClass, KEY)) &&
          (! pcei->hIcon ||
           IS_VALID_HANDLE(pcei->hIcon, ICON)) &&
          (! pcei->hProcess ||
           IS_VALID_HANDLE(pcei->hProcess, PROCESS)));
}

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\url.inc ===
#
# Common makefile include for this project
#

C_DEFINES       = $(C_DEFINES) \
                  -DEXPV \
                  -DMIME \
                  -DBUILDDLL \
                  -DIEXPLORER_DOESNT_CHECK_HEAP_RETURN_VALUES

!IF !$(FREEBUILD)
C_DEFINES       = $(C_DEFINES) \
                  -DVSTF
!ENDIF

!include $(CCSHELL_DIR)\common.inc

SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc
DELAYLOAD       =  WININET.DLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\unixstuff.cpp ===
#include "project.hpp"

extern "C" void WINAPI NewsProtocolHandler(HWND hwndParent, HINSTANCE hinst, PSTR pszCmdLine, int nShowCmd);
extern "C" void WINAPI MailToProtocolHandler(HWND hwndParent, HINSTANCE hinst, PSTR pszCmdLine, int nShowCmd);
extern "C" void WINAPI TelnetProtocolHandler(HWND hwndParent, HINSTANCE hinst, PSTR pszCmdLine, int nShowCmd);
extern "C" void WINAPI FileProtocolHandler(HWND hwndPanent, HINSTANCE hinst, PSTR pszCmdLine, int nShowCmd);
extern "C" void WINAPI OpenURL(HWND hwndParent, HINSTANCE hinst, PSTR pszCmdLine, int nShowCmd);

extern "C" void WINAPI NewsProtocolHandlerA(HWND hwndParent, HINSTANCE hinst, PSTR pszCmdLine, int nShowCmd)
{
    NewsProtocolHandler(hwndParent, hinst, pszCmdLine, nShowCmd);
}

extern "C" void WINAPI MailToProtocolHandlerA(HWND hwndParent, HINSTANCE hinst, PSTR pszCmdLine, int nShowCmd)
{
   MailToProtocolHandler(hwndParent, hinst, pszCmdLine, nShowCmd);
}

extern "C" void WINAPI TelnetProtocolHandlerA(HWND hwndParent, HINSTANCE hinst, PSTR pszCmdLine, int nShowCmd)
{
   TelnetProtocolHandler(hwndParent, hinst, pszCmdLine, nShowCmd);
}

extern "C" void WINAPI FileProtocolHandlerA(HWND hwndParent, HINSTANCE hinst, PSTR pszCmdLine, int nShowCmd)
{
   FileProtocolHandler(hwndParent, hinst, pszCmdLine, nShowCmd);
}

extern "C" void WINAPI OpenURLA(HWND hwndParent, HINSTANCE hinst, PSTR pszCmdLine, int nShowCmd)
{
   OpenURL(hwndParent, hinst, pszCmdLine, nShowCmd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\url.cpp ===
/*
 * url.cpp - IUniformResourceLocator implementation for InternetShortcut class.
 */


/* Headers
 **********/

#include "project.hpp"
#pragma hdrstop

#include "assoc.h"
#include "resource.h"
#define DECL_CRTFREE
#include <crtfree.h>


/* Module Constants
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

PRIVATE_DATA const char s_cszURLSeparator[]        = ":";

PRIVATE_DATA const char s_cchURLSuffixSlash        = '/';

PRIVATE_DATA const char s_cszURLPrefixesKey[]      = "Software\\Microsoft\\Windows\\CurrentVersion\\URL\\Prefixes";
PRIVATE_DATA const char s_cszDefaultURLPrefixKey[] = "Software\\Microsoft\\Windows\\CurrentVersion\\URL\\DefaultPrefix";

#pragma data_seg()


/***************************** Private Functions *****************************/


PRIVATE_CODE PCSTR SkipLeadingSlashes(PCSTR pcszURL)
{
   PCSTR pcszURLStart;

   ASSERT(IS_VALID_STRING_PTR(pcszURL, CSTR));

   // Skip two leading slashes.

   if (pcszURL[0] == s_cchURLSuffixSlash &&
       pcszURL[1] == s_cchURLSuffixSlash)
   {
      pcszURLStart = CharNext(pcszURL);
      pcszURLStart = CharNext(pcszURLStart);
   }
   else
      pcszURLStart = pcszURL;

   ASSERT(IS_VALID_STRING_PTR(pcszURL, CSTR) &&
          EVAL(IsStringContained(pcszURL, pcszURLStart)));

   return(pcszURLStart);
}


PRIVATE_CODE HRESULT ApplyURLPrefix(PCSTR pcszURL, PSTR *ppszTranslatedURL)
{
   HRESULT hr = S_FALSE;
   HKEY hkeyPrefixes;

   ASSERT(IS_VALID_STRING_PTR(pcszURL, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszTranslatedURL, PSTR));

   *ppszTranslatedURL = NULL;

   if (RegOpenKey(g_hkeyURLSettings, s_cszURLPrefixesKey, &hkeyPrefixes)
       == ERROR_SUCCESS)
   {
      PCSTR pcszURLStart;
      DWORD dwiValue;
      char rgchValueName[MAX_PATH_LEN];
      DWORD dwcbValueNameLen;
      DWORD dwType;
      char rgchPrefix[MAX_PATH_LEN];
      DWORD dwcbPrefixLen;

      pcszURLStart = SkipLeadingSlashes(pcszURL);

      dwcbValueNameLen = sizeof(rgchValueName);
      dwcbPrefixLen = sizeof(rgchPrefix);

      for (dwiValue = 0;
           RegEnumValue(hkeyPrefixes, dwiValue, rgchValueName,
                        &dwcbValueNameLen, NULL, &dwType, (PBYTE)rgchPrefix,
                        &dwcbPrefixLen) == ERROR_SUCCESS;
           dwiValue++)
      {
         if (! lstrnicmp(pcszURLStart, rgchValueName, dwcbValueNameLen))
         {
            DWORD cbUrl = lstrlen(pcszURLStart);

            // If the url==prefix, then we're calling the executable.
            
            if (cbUrl >= dwcbPrefixLen)
            {
                // dwcbPrefixLen includes null terminator.

                *ppszTranslatedURL = new(char[dwcbPrefixLen + cbUrl]);

                if (*ppszTranslatedURL)
                {
                   lstrcpy(*ppszTranslatedURL, rgchPrefix);
                   lstrcat(*ppszTranslatedURL, pcszURLStart);
                   // (+ 1) for null terminator.
                   ASSERT(lstrlen(*ppszTranslatedURL) + 1 == (int)dwcbPrefixLen + lstrlen(pcszURLStart));

                   hr = S_OK;
                }
                else
                   hr = E_OUTOFMEMORY;
            }

            break;
         }

         dwcbValueNameLen = sizeof(rgchValueName);
         dwcbPrefixLen = sizeof(rgchPrefix);
      }

      RegCloseKey(hkeyPrefixes);

      switch (hr)
      {
         case S_OK:
            TRACE_OUT(("ApplyURLPrefix(): Prefix %s prepended to prefix %s of %s to yield URL %s.",
                       rgchValueName,
                       rgchPrefix,
                       pcszURL,
                       *ppszTranslatedURL));
            break;

         case S_FALSE:
            TRACE_OUT(("ApplyURLPrefix(): No matching prefix found for URL %s.",
                       pcszURL));
            break;

         default:
            ASSERT(hr == E_OUTOFMEMORY);
            break;
      }
   }
   else
      TRACE_OUT(("ApplyURLPrefix(): No URL prefixes registered."));

   ASSERT((hr == S_OK &&
           IS_VALID_STRING_PTR(*ppszTranslatedURL, STR)) ||
          ((hr == S_FALSE ||
            hr == E_OUTOFMEMORY) &&
           ! *ppszTranslatedURL));

   return(hr);
}


PRIVATE_CODE HRESULT ApplyDefaultURLPrefix(PCSTR pcszURL,
                                           PSTR *ppszTranslatedURL)
{
   HRESULT hr;
   char rgchDefaultURLPrefix[MAX_PATH_LEN];
   DWORD dwcbDefaultURLPrefixLen;

   ASSERT(IS_VALID_STRING_PTR(pcszURL, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszTranslatedURL, PSTR));

   *ppszTranslatedURL = NULL;

   dwcbDefaultURLPrefixLen = sizeof(rgchDefaultURLPrefix);

   if (GetDefaultRegKeyValue(g_hkeyURLSettings, s_cszDefaultURLPrefixKey,
                             rgchDefaultURLPrefix, &dwcbDefaultURLPrefixLen)
       == ERROR_SUCCESS)
   {
      // (+ 1) for null terminator.

      *ppszTranslatedURL = new(char[dwcbDefaultURLPrefixLen +
                                    lstrlen(pcszURL) + 1]);

      if (*ppszTranslatedURL)
      {
         PCSTR pcszURLStart;

         pcszURLStart = SkipLeadingSlashes(pcszURL);

         lstrcpy(*ppszTranslatedURL, rgchDefaultURLPrefix);
         lstrcat(*ppszTranslatedURL, pcszURLStart);
         // (+ 1) for null terminator.
         ASSERT(lstrlen(*ppszTranslatedURL) + 1 == (int)dwcbDefaultURLPrefixLen + lstrlen(pcszURLStart));

         hr = S_OK;
      }
      else
         hr = E_OUTOFMEMORY;
   }
   else
      hr = S_FALSE;

   switch (hr)
   {
      case S_OK:
         TRACE_OUT(("ApplyDefaultURLPrefix(): Default prefix %s prepended to %s to yield URL %s.",
                    rgchDefaultURLPrefix,
                    pcszURL,
                    *ppszTranslatedURL));
         break;

      case S_FALSE:
         TRACE_OUT(("ApplyDefaultURLPrefix(): No default URL prefix registered."));
         break;

      default:
         ASSERT(hr == E_OUTOFMEMORY);
         break;
   }

   ASSERT((hr == S_OK &&
           IS_VALID_STRING_PTR(*ppszTranslatedURL, STR)) ||
          ((hr == S_FALSE ||
            hr == E_OUTOFMEMORY) &&
           ! *ppszTranslatedURL));

   return(hr);
}


PRIVATE_CODE HRESULT MyTranslateURL(PCSTR pcszURL, DWORD dwFlags,
                                    PSTR *ppszTranslatedURL)
{
   HRESULT hr;
   PARSEDURL pu;

   ASSERT(IS_VALID_STRING_PTR(pcszURL, CSTR));
   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_TRANSLATEURL_FLAGS));
   ASSERT(IS_VALID_WRITE_PTR(ppszTranslatedURL, PSTR));

   // Check URL syntax.

   pu.cbSize = sizeof(pu);
   if (ParseURL(pcszURL, &pu) == S_OK)
   {
      *ppszTranslatedURL = NULL;

      hr = S_FALSE;
   }
   else
   {
      if (IS_FLAG_SET(dwFlags, TRANSLATEURL_FL_GUESS_PROTOCOL))
         hr = ApplyURLPrefix(pcszURL, ppszTranslatedURL);
      else
         hr = S_FALSE;

      if (hr == S_FALSE &&
          IS_FLAG_SET(dwFlags, TRANSLATEURL_FL_USE_DEFAULT_PROTOCOL))
         hr = ApplyDefaultURLPrefix(pcszURL, ppszTranslatedURL);
   }

   ASSERT((hr == S_OK &&
           IS_VALID_STRING_PTR(*ppszTranslatedURL, STR)) ||
          ((hr == S_FALSE ||
            hr == E_OUTOFMEMORY) &&
           ! *ppszTranslatedURL));

   return(hr);
}


#ifdef DEBUG

PRIVATE_CODE IsValidPCURLINVOKECOMMANDINFO(PCURLINVOKECOMMANDINFO pcurlici)
{
   return(IS_VALID_READ_PTR(pcurlici, CURLINVOKECOMMANDINFO) &&
          EVAL(pcurlici->dwcbSize >= sizeof(*pcurlici)) &&
          FLAGS_ARE_VALID(pcurlici->dwFlags, ALL_IURL_INVOKECOMMAND_FLAGS) &&
          (IS_FLAG_CLEAR(pcurlici->dwFlags, IURL_INVOKECOMMAND_FL_ALLOW_UI) ||
           IS_VALID_HANDLE(pcurlici->hwndParent, WND)) &&
          (IS_FLAG_SET(pcurlici->dwFlags, IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB) ||
           IS_VALID_STRING_PTR(pcurlici->pcszVerb, CSTR)));
}

#endif


/********************************** Methods **********************************/


HRESULT STDMETHODCALLTYPE InternetShortcut::RegisterProtocolHandler(
                                                            HWND hwndParent,
                                                            PSTR pszAppBuf,
                                                            UINT ucAppBufLen)
{
   HRESULT hr;
   DWORD dwFlags = 0;

   DebugEntry(InternetShortcut::RegisterProtocolHandler);

   ASSERT(! hwndParent ||
          IS_VALID_HANDLE(hwndParent, WND));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszAppBuf, STR, ucAppBufLen));

   ASSERT(IS_VALID_STRING_PTR(m_pszURL, STR));

   SET_FLAG(dwFlags, URLASSOCDLG_FL_REGISTER_ASSOC);

   if (! m_pszFile)
      SET_FLAG(dwFlags, URLASSOCDLG_FL_USE_DEFAULT_NAME);

   hr = URLAssociationDialog(hwndParent, dwFlags, m_pszFile, m_pszURL,
                             pszAppBuf, ucAppBufLen);

   switch (hr)
   {
      case S_FALSE:
         TRACE_OUT(("InternetShortcut::RegisterProtocolHandler(): One time execution of %s via %s requested.",
                    m_pszURL,
                    pszAppBuf));
         break;

      case S_OK:
         TRACE_OUT(("InternetShortcut::RegisterProtocolHandler(): Protocol handler registered for %s.",
                    m_pszURL));
         break;

      default:
         ASSERT(FAILED(hr));
         break;
   }

   ASSERT(! ucAppBufLen ||
          (IS_VALID_STRING_PTR(pszAppBuf, STR) &&
           (UINT)lstrlen(pszAppBuf) < ucAppBufLen));

   DebugExitHRESULT(InternetShortcut::RegisterProtocolHandler, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::SetURL(PCSTR pcszURL,
                                                   DWORD dwInFlags)
{
   HRESULT hr;
   BOOL bChanged;
   PSTR pszNewURL = NULL;

   DebugEntry(InternetShortcut::SetURL);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(! pcszURL ||
          IS_VALID_STRING_PTR(pcszURL, CSTR));
   ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_IURL_SETURL_FLAGS));

   bChanged = ! ((! pcszURL && ! m_pszURL) ||
                 (pcszURL && m_pszURL &&
                  ! lstrcmp(pcszURL, m_pszURL)));

   if (bChanged && pcszURL)
   {
      DWORD dwTranslateURLFlags;
      PSTR pszTranslatedURL;

      dwTranslateURLFlags = 0;

      if (IS_FLAG_SET(dwInFlags, IURL_SETURL_FL_GUESS_PROTOCOL))
         SET_FLAG(dwTranslateURLFlags, TRANSLATEURL_FL_GUESS_PROTOCOL);

      if (IS_FLAG_SET(dwInFlags, IURL_SETURL_FL_USE_DEFAULT_PROTOCOL))
         SET_FLAG(dwTranslateURLFlags, TRANSLATEURL_FL_USE_DEFAULT_PROTOCOL);

      hr = TranslateURL(pcszURL, dwTranslateURLFlags, &pszTranslatedURL);

      if (SUCCEEDED(hr))
      {
         PCSTR pcszURLToUse;

         // Still different?

         if (hr == S_OK)
         {
            bChanged = (lstrcmp(pszTranslatedURL, m_pszURL) != 0);

            pcszURLToUse = pszTranslatedURL;
         }
         else
         {
            ASSERT(hr == S_FALSE);

            pcszURLToUse = pcszURL;
         }

         if (bChanged)
         {
            PARSEDURL pu;

            // Validate URL syntax.

			pu.cbSize = sizeof(pu);
            hr = ParseURL(pcszURLToUse, &pu);

            if (hr == S_OK)
            {
               pszNewURL = new(char[lstrlen(pcszURLToUse) + 1]);

               if (pszNewURL)
                  lstrcpy(pszNewURL, pcszURLToUse);
               else
                  hr = E_OUTOFMEMORY;
            }
         }
         else
            hr = S_OK;
      }

      if (pszTranslatedURL)
      {
         LocalFree(pszTranslatedURL);
         pszTranslatedURL = NULL;
      }
   }
   else
      hr = S_OK;

   if (hr == S_OK)
   {
      if (bChanged)
      {
         if (m_pszURL)
            delete m_pszURL;

         m_pszURL = pszNewURL;

         Dirty(TRUE);

         TRACE_OUT(("InternetShortcut::SetURL(): Set URL to %s.",
                    CHECK_STRING(m_pszURL)));
      }
      else
         TRACE_OUT(("InternetShortcut::SetURL(): URL already %s.",
                    CHECK_STRING(m_pszURL)));
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(hr == S_OK ||
          hr == E_OUTOFMEMORY ||
          hr == URL_E_INVALID_SYNTAX);

   DebugExitHRESULT(InternetShortcut::SetURL, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::GetURL(PSTR *ppszURL)
{
   HRESULT hr;

   DebugEntry(InternetShortcut::GetURL);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_WRITE_PTR(ppszURL, PSTR));

   *ppszURL = NULL;

   if (m_pszURL)
   {
      // (+ 1) for null terminator.
      *ppszURL = (PSTR)SHAlloc(lstrlen(m_pszURL) + 1);

      if (*ppszURL)
      {
         lstrcpy(*ppszURL, m_pszURL);

         hr = S_OK;

         TRACE_OUT(("InternetShortcut::GetURL(): Got URL %s.",
                    *ppszURL));
      }
      else
         hr = E_OUTOFMEMORY;
   }
   else
      // No URL.
      hr = S_FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT((hr == S_OK &&
           IS_VALID_STRING_PTR(*ppszURL, STR)) ||
          ((hr == S_FALSE ||
            hr == E_OUTOFMEMORY) &&
           ! *ppszURL));

   DebugExitHRESULT(InternetShortcut::GetURL, hr);

   return(hr);
}


HRESULT STDMETHODCALLTYPE InternetShortcut::InvokeCommand(
                                                PURLINVOKECOMMANDINFO purlici)
{
   HRESULT hr = E_INVALIDARG;
   char szOneShotApp[MAX_PATH_LEN];
   BOOL bExecFailedWhine = FALSE;

   DebugEntry(InternetShortcut::InvokeCommand);

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(IS_VALID_STRUCT_PTR(purlici, CURLINVOKECOMMANDINFO));

   if (purlici && EVAL(sizeof(*purlici) == purlici->dwcbSize))
   {
      if (m_pszURL)
      {
         PSTR pszProtocol;

         hr = CopyURLProtocol(m_pszURL, &pszProtocol);

         if (hr == S_OK)
         {
            hr = IsProtocolRegistered(pszProtocol);

            if (hr == URL_E_UNREGISTERED_PROTOCOL &&
                IS_FLAG_SET(purlici->dwFlags, IURL_INVOKECOMMAND_FL_ALLOW_UI))
            {
               TRACE_OUT(("InternetShortcut::InvokeCommand(): Unregistered URL protocol %s.  Invoking URL protocol handler association dialog.",
                          pszProtocol));

               hr = RegisterProtocolHandler(purlici->hwndParent, szOneShotApp,
                                            sizeof(szOneShotApp));
            }

            switch (hr)
            {
               case S_OK:
               {
                  SHELLEXECUTEINFO sei;
                  char szDefaultVerb[MAX_PATH_LEN];

                  // Execute URL via registered protocol handler.

                  ZeroMemory(&sei, sizeof(sei));

                  sei.fMask = (SEE_MASK_CLASSNAME | SEE_MASK_NO_HOOKS);

                  if (IS_FLAG_CLEAR(purlici->dwFlags,
                                    IURL_INVOKECOMMAND_FL_ALLOW_UI))
                     SET_FLAG(sei.fMask, SEE_MASK_FLAG_NO_UI);

                  if (IS_FLAG_CLEAR(purlici->dwFlags,
                                    IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB))
                     sei.lpVerb = purlici->pcszVerb;
                  else
                  {
                     if (GetClassDefaultVerb(pszProtocol, szDefaultVerb,
                                             sizeof(szDefaultVerb)))
                        sei.lpVerb = szDefaultVerb;
                     else
                        ASSERT(! sei.lpVerb);
                  }

                  sei.cbSize = sizeof(sei);
                  sei.hwnd = purlici->hwndParent;
                  sei.lpFile = m_pszURL;
                  sei.lpDirectory = m_pszWorkingDirectory;
                  sei.nShow = m_nShowCmd;
                  sei.lpClass = pszProtocol;

                  TRACE_OUT(("InternetShortcut::InvokeCommand(): Invoking %s verb on URL %s.",
                             sei.lpVerb ? sei.lpVerb : "open",
                             sei.lpFile));

                  hr = ShellExecuteEx(&sei) ? S_OK : IS_E_EXEC_FAILED;

                  if (hr == S_OK)
                     TRACE_OUT(("InternetShortcut::InvokeCommand(): ShellExecuteEx() via registered protcol handler succeeded for %s.",
                                m_pszURL));
                  else
                     WARNING_OUT(("InternetShortcut::InvokeCommand(): ShellExecuteEx() via registered protcol handler failed for %s.",
                                  m_pszURL));

                  break;
               }

               case S_FALSE:
                  hr = MyExecute(szOneShotApp, m_pszURL, 0);
                  switch (hr)
                  {
                     case E_FAIL:
                        bExecFailedWhine = TRUE;
                        hr = IS_E_EXEC_FAILED;
                        break;

                     default:
                        break;
                  }
                  break;

               default:
                  ASSERT(FAILED(hr));
                  break;
            }

            delete pszProtocol;
            pszProtocol = NULL;
         }
      }
      else
         // No URL.  Not an error.
         hr = S_FALSE;

      if (FAILED(hr) &&
          IS_FLAG_SET(purlici->dwFlags, IURL_INVOKECOMMAND_FL_ALLOW_UI))
      {
         int nResult;

         switch (hr)
         {
            case IS_E_EXEC_FAILED:
               if (bExecFailedWhine)
               {
                  ASSERT(IS_VALID_STRING_PTR(szOneShotApp, STR));

                  if (MyMsgBox(purlici->hwndParent,
                               MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                               MAKEINTRESOURCE(IDS_EXEC_FAILED),
                               (MB_OK | MB_ICONEXCLAMATION), &nResult,
                               szOneShotApp)) {
                     ASSERT(nResult == IDOK);
                  }
               }
               break;

            case URL_E_INVALID_SYNTAX:
               ASSERT(IS_VALID_STRING_PTR(m_pszURL, STR));

               if (MyMsgBox(purlici->hwndParent,
                            MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                            MAKEINTRESOURCE(IDS_EXEC_INVALID_SYNTAX),
                            (MB_OK | MB_ICONEXCLAMATION), &nResult, m_pszURL)) {
                  ASSERT(nResult == IDOK);
               }

               break;

            case URL_E_UNREGISTERED_PROTOCOL:
            {
               PSTR pszProtocol;

               ASSERT(IS_VALID_STRING_PTR(m_pszURL, STR));

               if (CopyURLProtocol(m_pszURL, &pszProtocol) == S_OK)
               {
                  if (MyMsgBox(purlici->hwndParent,
                               MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                               MAKEINTRESOURCE(IDS_EXEC_UNREGISTERED_PROTOCOL),
                               (MB_OK | MB_ICONEXCLAMATION), &nResult,
                               pszProtocol)) {
                     ASSERT(nResult == IDOK);
                  }

                  delete pszProtocol;
                  pszProtocol = NULL;
               }

               break;
            }

            case E_OUTOFMEMORY:
               if (MyMsgBox(purlici->hwndParent, MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                            MAKEINTRESOURCE(IDS_EXEC_OUT_OF_MEMORY),
                            (MB_OK | MB_ICONEXCLAMATION), &nResult)) {
                  ASSERT(nResult == IDOK);
               }
               break;

            default:
               ASSERT(hr == E_ABORT);
               break;
         }
      }
   }

   ASSERT(IS_VALID_STRUCT_PTR(this, CInternetShortcut));
   ASSERT(hr == S_OK ||
          hr == E_ABORT ||
          hr == E_OUTOFMEMORY ||
          hr == E_INVALIDARG ||
          hr == URL_E_INVALID_SYNTAX ||
          hr == URL_E_UNREGISTERED_PROTOCOL ||
          hr == IS_E_EXEC_FAILED);

   DebugExitHRESULT(InternetShortcut::InvokeCommand, hr);

   return(hr);
}


/***************************** Exported Functions ****************************/


INTSHCUTAPI HRESULT WINAPI TranslateURLA(PCSTR pcszURL, DWORD dwInFlags,
                                         PSTR *ppszTranslatedURL)
{
   HRESULT hr;

   DebugEntry(TranslateURLA);

   *ppszTranslatedURL = NULL;

#ifdef EXPV
   /* Verify parameters. */

   if (IS_VALID_STRING_PTR(pcszURL, CSTR) &&
       IS_VALID_WRITE_PTR(ppszTranslatedURL, PSTR))
   {
      if (FLAGS_ARE_VALID(dwInFlags, ALL_TRANSLATEURL_FLAGS))
#endif
      {
         PSTR pszTempTranslatedURL;

         hr = MyTranslateURL(pcszURL, dwInFlags, &pszTempTranslatedURL);

         if (hr == S_OK)
         {
            // (+ 1) for null terminator.
            *ppszTranslatedURL = (PSTR)LocalAlloc(
                                            LMEM_FIXED,
                                            lstrlen(pszTempTranslatedURL) + 1);

            if (*ppszTranslatedURL)
            {
               lstrcpy(*ppszTranslatedURL, pszTempTranslatedURL);
               ASSERT(lstrlen(*ppszTranslatedURL) == lstrlen(pszTempTranslatedURL));
            }
            else
               hr = E_OUTOFMEMORY;

            delete pszTempTranslatedURL;
            pszTempTranslatedURL = NULL;
         }
      }
#ifdef EXPV
      else
         hr = E_FLAGS;
   }
   else
      hr = E_POINTER;
#endif

   switch (hr)
   {
      case S_FALSE:
         TRACE_OUT(("TranslateURLA(): URL %s does not require translation.",
                    pcszURL));
         break;

      case S_OK:
         TRACE_OUT(("TranslateURLA(): URL %s translated to URL %s.",
                    pcszURL,
                    *ppszTranslatedURL));
         break;

      default:
         ASSERT(hr == E_OUTOFMEMORY ||
                hr == E_POINTER);
         break;
   }

   ASSERT((hr == S_OK &&
           IS_VALID_STRING_PTR(*ppszTranslatedURL, STR)) ||
          ((hr == S_FALSE ||
            hr == E_OUTOFMEMORY ||
            hr == E_POINTER ||
            hr == E_FLAGS) &&
           ! *ppszTranslatedURL));

   DebugExitHRESULT(TranslateURLA, hr);

   return(hr);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

INTSHCUTAPI HRESULT WINAPI TranslateURLW(PCWSTR pcszURL, DWORD dwInFlags,
                                         PWSTR UNALIGNED *ppszTranslatedURL)
{
   HRESULT hr;

   DebugEntry(TranslateURLW);

   SetLastError(ERROR_NOT_SUPPORTED);
   hr = E_NOTIMPL;

   DebugExitHRESULT(TranslateURLW, hr);

   return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\resdll\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\urlexec.cpp ===
/*
 * urlexec.cpp - IUnknown implementation for Intshcut class.
 */

#include "project.hpp"
#include "urlshell.h"
#include "clsfact.h"
#include "resource.h"

#include <mluisupp.h>

// URL Exec Hook

class CURLExec : public IShellExecuteHookA, public IShellExecuteHookW
{
private:

    ULONG       m_cRef;

    ~CURLExec(void);    // Prevent this class from being allocated on the stack or it will fault.

public:
    CURLExec(void);

    // IShellExecuteHook methods

	// Ansi
    STDMETHODIMP Execute(LPSHELLEXECUTEINFOA pei);
    // Unicode
    STDMETHODIMP Execute(LPSHELLEXECUTEINFOW pei);

    // IUnknown methods
    
    STDMETHODIMP  QueryInterface(REFIID riid, PVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
#ifdef DEBUG
    friend BOOL IsValidPCURLExec(const CURLExec * pue);
#endif
};


#ifdef DEBUG

BOOL IsValidPCURLExec(CURLExec * pue)
{
    return (IS_VALID_READ_PTR(pue, CURLExec));
}

#endif


CURLExec::CURLExec(void) : m_cRef(1)
{
    // CURLExec objects should always be allocated

    ASSERT(IS_VALID_STRUCT_PTR(this, CURLExec));

    DLLAddRef();
}

CURLExec::~CURLExec(void)
{
    ASSERT(IS_VALID_STRUCT_PTR(this, CURLExec));

    DLLRelease();
}


/*----------------------------------------------------------
Purpose: IUnknown::QueryInterface handler for CURLExec

*/
STDMETHODIMP CURLExec::QueryInterface(REFIID riid, PVOID *ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IShellExecuteHookA))
    {
        *ppvObj = SAFECAST(this, IShellExecuteHookA *);
    }
    else if (IsEqualIID(riid, IID_IShellExecuteHookW))
    {
    	*ppvObj = SAFECAST(this, IShellExecuteHookW *);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}


STDMETHODIMP_(ULONG) CURLExec::AddRef()
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CURLExec::Release()
{
    m_cRef--;
    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}


// from shlexec.c
#define SEE_MASK_CLASS (SEE_MASK_CLASSNAME|SEE_MASK_CLASSKEY)
/*----------------------------------------------------------
Purpose: IShellExecuteHook::Execute handler for CURLExec

*/
STDMETHODIMP CURLExec::Execute(LPSHELLEXECUTEINFOA pei)
{
    HRESULT hres;
    
    ASSERT(IS_VALID_STRUCT_PTR(this, CURLExec));
    ASSERT(IS_VALID_READ_PTR(pei, SHELLEXECUTEINFO));
    
    if (! pei->lpVerb ||
        ! lstrcmpi(pei->lpVerb, TEXT("open")))
    {
        if (pei->lpFile)
        {
            LPTSTR pszURL;

            // This should succeed only for real URLs.  We should fail
            // for file paths and let the shell handle those.

            hres = TranslateURL(pei->lpFile, 
                                TRANSLATEURL_FL_GUESS_PROTOCOL | TRANSLATEURL_FL_CANONICALIZE,
                                &pszURL);
            
            if (SUCCEEDED(hres))
            {
                LPCTSTR pszURLToUse;
                
                pszURLToUse = (hres == S_OK) ? pszURL : pei->lpFile;
                
                hres = ValidateURL(pszURLToUse);
                
                if (SUCCEEDED(hres))
                {
                    IUniformResourceLocator * purl;

                    hres = SHCoCreateInstance(NULL, &CLSID_InternetShortcut, NULL, IID_IUniformResourceLocator, (void **)&purl);
                    if (SUCCEEDED(hres))
                    {
                        hres = purl->SetURL(pszURLToUse, 0);
                        if (hres == S_OK)
                        {
                            IShellLink * psl;

                            hres = purl->QueryInterface(IID_IShellLink, (void **)&psl);
                            if (SUCCEEDED(hres))
                            {
                                URLINVOKECOMMANDINFO urlici;

                                EVAL(psl->SetShowCmd(pei->nShow) == S_OK);
                                
                                urlici.dwcbSize = SIZEOF(urlici);
                                urlici.hwndParent = pei->hwnd;
                                urlici.pcszVerb = NULL;
                                
                                urlici.dwFlags = IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB;
                                
                                if (IsFlagClear(pei->fMask, SEE_MASK_FLAG_NO_UI))
                                    SetFlag(urlici.dwFlags, IURL_INVOKECOMMAND_FL_ALLOW_UI);
                                
                                hres = purl->InvokeCommand(&urlici);
                                
                                if (hres != S_OK)
                                    SetFlag(pei->fMask, SEE_MASK_FLAG_NO_UI);

                                psl->Release();
                            }
                        }
                        purl->Release();
                    }
                }

                if (pszURL)
                    LocalFree(pszURL);
            }
        }
        else
            // (scotth): This hook only handles execution of file string, not IDList.
            hres = S_FALSE;
    }
    else
        // Unrecognized verb.
        hres = S_FALSE;
    
    if (hres == S_OK)
        pei->hInstApp = (HINSTANCE)42;  // huh??
    else if (FAILED(hres))
    {
        switch (hres)
        {
        case URL_E_INVALID_SYNTAX:
        case URL_E_UNREGISTERED_PROTOCOL:
            hres = S_FALSE;
            break;
            
        case E_OUTOFMEMORY:
            pei->hInstApp = (HINSTANCE)SE_ERR_OOM;
            hres = E_FAIL;
            break;
            
        case IS_E_EXEC_FAILED:
            // Translate execution failure into "file not found".
            pei->hInstApp = (HINSTANCE)SE_ERR_FNF;
            hres = E_FAIL;
            break;
            
        default:
            // pei->lpFile is bogus.  Treat as file not found.
            ASSERT(hres == E_POINTER);

            pei->hInstApp = (HINSTANCE)SE_ERR_FNF;
            hres = E_FAIL;
            break;
        }
    }
    else
        ASSERT(hres == S_FALSE);
    
    ASSERT(hres == S_OK ||
        hres == S_FALSE ||
        hres == E_FAIL);
    
    return hres;
}

STDMETHODIMP CURLExec::Execute(LPSHELLEXECUTEINFOW pei)
{
	// thunk stuff copied from shlexec.c InvokeShellExecuteHook
	SHELLEXECUTEINFOA seia;
    UINT cchVerb = 0;
    UINT cchFile = 0;
    UINT cchParameters = 0;
    UINT cchDirectory  = 0;
    UINT cchClass = 0;
    LPSTR lpszBuffer;
    HRESULT hres = E_FAIL;

    seia = *(SHELLEXECUTEINFOA*)pei;    // Copy all of the binary data

    if (pei->lpVerb)
    {
        cchVerb = WideCharToMultiByte(CP_ACP,0,
                                      pei->lpVerb, -1,
                                      NULL, 0,
                                      NULL, NULL)+1;
    }

    if (pei->lpFile)
        cchFile = WideCharToMultiByte(CP_ACP,0,
                                      pei->lpFile, -1,
                                      NULL, 0,
                                      NULL, NULL)+1;

    if (pei->lpParameters)
        cchParameters = WideCharToMultiByte(CP_ACP,0,
	                                        pei->lpParameters, -1,
                                            NULL, 0,
                                            NULL, NULL)+1;

    if (pei->lpDirectory)
        cchDirectory = WideCharToMultiByte(CP_ACP,0,
                                           pei->lpDirectory, -1,
                                           NULL, 0,
                                           NULL, NULL)+1;
    if (((pei->fMask & SEE_MASK_CLASS) == SEE_MASK_CLASSNAME) && pei->lpClass)
        cchClass = WideCharToMultiByte(CP_ACP,0,
                                       pei->lpClass, -1,
                                       NULL, 0,
                                       NULL, NULL)+1;

	// what is this (alloca)? InvokeShellExecuteHook is not freeing lpszBuffer
    //lpszBuffer = alloca(cchVerb+cchFile+cchParameters+cchDirectory+cchClass);
    lpszBuffer = (LPSTR)LocalAlloc(LPTR, cchVerb+cchFile+cchParameters+cchDirectory+cchClass);
    if (lpszBuffer)
	{
		LPSTR lpsz = lpszBuffer;
		
    	seia.lpVerb = NULL;
	    seia.lpFile = NULL;
    	seia.lpParameters = NULL;
	    seia.lpDirectory = NULL;
    	seia.lpClass = NULL;

	    //
    	// Convert all of the strings to ANSI
	    //
    	if (pei->lpVerb)
	    {
    	    WideCharToMultiByte(CP_ACP, 0, pei->lpVerb, -1,
        	                    lpszBuffer, cchVerb, NULL, NULL);
	        seia.lpVerb = lpszBuffer;
    	    lpszBuffer += cchVerb;
	    }
    	if (pei->lpFile)
	    {
    	    WideCharToMultiByte(CP_ACP, 0, pei->lpFile, -1,
	                            lpszBuffer, cchFile, NULL, NULL);
    	    seia.lpFile = lpszBuffer;
	        lpszBuffer += cchFile;
    	}
	    if (pei->lpParameters)
    	{
	        WideCharToMultiByte(CP_ACP, 0,
    	                        pei->lpParameters, -1,
	                            lpszBuffer, cchParameters, NULL, NULL);
    	    seia.lpParameters = lpszBuffer;
	        lpszBuffer += cchParameters;
    	}
	    if (pei->lpDirectory)
    	{
	        WideCharToMultiByte(CP_ACP, 0,
    	                        pei->lpDirectory, -1,
	                            lpszBuffer, cchDirectory, NULL, NULL);
    	    seia.lpDirectory = lpszBuffer;
	        lpszBuffer += cchDirectory;
    	}
	    if (((pei->fMask & SEE_MASK_CLASS) == SEE_MASK_CLASSNAME) && pei->lpClass)
    	{
        	WideCharToMultiByte(CP_ACP, 0,
	                            pei->lpClass, -1,
    	                        lpszBuffer, cchClass, NULL, NULL);
	        seia.lpClass = lpszBuffer;
    	}

    	hres = Execute(&seia);
    	// now thunk the possible new stuff back
    	pei->hInstApp = seia.hInstApp;
    	if (pei->fMask & SEE_MASK_NOCLOSEPROCESS)
        	pei->hProcess = seia.hProcess;


    	LocalFree(lpsz);
	}

    return hres;
}

STDAPI CreateInstance_URLExec(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut)
{
    *ppvOut = NULL;

    if (punkOuter)
        return CLASS_E_NOAGGREGATION;

    CURLExec *pue = new(CURLExec);
    if (!pue)
        return E_OUTOFMEMORY;

    HRESULT hres = pue->QueryInterface(riid, ppvOut);
    pue->Release();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\urlshell.h ===
#ifndef _URLSHELL_H_
#define _URLSHELL_H_

// This header is an extraction of private macros and prototypes that
// originally came from shellp.h and shellprv.h.  

#define DATASEG_READONLY   DATA_SEG_READ_ONLY

#ifndef DebugMsg                                                                /* ;Internal */
#define DM_TRACE    0x0001      // Trace messages                               /* ;Internal */
#define DM_WARNING  0x0002      // Warning                                      /* ;Internal */
#define DM_ERROR    0x0004      // Error                                        /* ;Internal */
#define DM_ASSERT   0x0008      // Assertions                                   /* ;Internal */

#define Assert(f)                                                               /* ;Internal */
#define AssertE(f)      (f)                                                     /* ;Internal */
#define AssertMsg   1 ? (void)0 : (void)                                        /* ;Internal */
#define DebugMsg    1 ? (void)0 : (void)                                        /* ;Internal */
#endif                                                                          /* ;Internal */

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#define ENTERCRITICAL   Shell_EnterCriticalSection();
#define LEAVECRITICAL   Shell_LeaveCriticalSection();

void Shell_EnterCriticalSection(void);
void Shell_LeaveCriticalSection(void);

#define CCH_KEYMAX      64          // DOC: max size of a reg key (under shellex)

#define FillExecInfo(_info, _hwnd, _verb, _file, _params, _dir, _show) \
        (_info).hwnd            = _hwnd;        \
        (_info).lpVerb          = _verb;        \
        (_info).lpFile          = _file;        \
        (_info).lpParameters    = _params;      \
        (_info).lpDirectory     = _dir;         \
        (_info).nShow           = _show;        \
        (_info).fMask           = 0;            \
        (_info).cbSize          = SIZEOF(SHELLEXECUTEINFO);

// Define some registry caching apis.  This will allow us to minimize the
// changes needed in the shell code and still try to reduce the number of
// calls that we make to the registry.
LONG SHRegQueryValueA(HKEY hKey,LPCSTR lpSubKey,LPSTR lpValue,PLONG lpcbValue);
LONG SHRegQueryValueExA(HKEY hKey,LPCSTR lpValueName,LPDWORD lpReserved,LPDWORD lpType,LPBYTE lpData,LPDWORD lpcbData);

LONG SHRegQueryValueW(HKEY hKey,LPCWSTR lpSubKey,LPWSTR lpValue,PLONG lpcbValue);
LONG SHRegQueryValueExW(HKEY hKey,LPCWSTR lpValueName,LPDWORD lpReserved,LPDWORD lpType,LPBYTE lpData,LPDWORD lpcbData);

#define GCD_MUSTHAVEOPENCMD     0x0001
#define GCD_ADDEXETODISPNAME    0x0002  // must be used with GCD_MUSTHAVEOPENCMD
#define GCD_ALLOWPSUDEOCLASSES  0x0004  // .ext type extensions

// Only valid when used with FillListWithClasses
#define GCD_MUSTHAVEEXTASSOC    0x0008  // There must be at least one extension assoc

#define DECLAREWAITCURSOR  HCURSOR hcursor_wait_cursor_save
#define SetWaitCursor()   hcursor_wait_cursor_save = SetCursor(LoadCursor(NULL, IDC_WAIT))
#define ResetWaitCursor() SetCursor(hcursor_wait_cursor_save)

// indexes into the shell image lists (Shell_GetImageList) for default images
// If you add to this list, you also need to update II_LASTSYSICON!

#define II_DOCNOASSOC         0         // document (blank page) (not associated)
#define II_APPLICATION        2         // application (exe, com, bat)

WINSHELLAPI BOOL  WINAPI Shell_GetImageLists(HIMAGELIST *phiml, HIMAGELIST *phimlSmall);

extern DWORD WINAPI GetExeType(LPCTSTR pszFile);
WINSHELLAPI void          WINAPI ILFree(LPITEMIDLIST pidl);


//======Hash Item=============================================================
typedef struct _HashTable * PHASHTABLE;
#define PHASHITEM LPCTSTR

typedef void (CALLBACK *HASHITEMCALLBACK)(PHASHTABLE pht, LPCTSTR sz, UINT wUsage, DWORD param);

LPCTSTR      WINAPI FindHashItem  (PHASHTABLE pht, LPCTSTR lpszStr);
LPCTSTR      WINAPI AddHashItem   (PHASHTABLE pht, LPCTSTR lpszStr);
LPCTSTR      WINAPI DeleteHashItem(PHASHTABLE pht, LPCTSTR lpszStr);
LPCTSTR      WINAPI PurgeHashItem (PHASHTABLE pht, LPCTSTR lpszStr);
#define     GetHashItemName(pht, sz, lpsz, cch)  lstrcpyn(lpsz, sz, cch)

PHASHTABLE  WINAPI CreateHashItemTable(UINT wBuckets, UINT wExtra, BOOL fCaseSensitive);
void        WINAPI DestroyHashItemTable(PHASHTABLE pht);

void        WINAPI SetHashItemData(PHASHTABLE pht, LPCTSTR lpszStr, int n, DWORD dwData);
DWORD       WINAPI GetHashItemData(PHASHTABLE pht, LPCTSTR lpszStr, int n);
void *      WINAPI GetHashItemDataPtr(PHASHTABLE pht, LPCTSTR lpszStr);

void        WINAPI EnumHashItems(PHASHTABLE pht, HASHITEMCALLBACK callback, DWORD dwParam);

#ifdef DEBUG
void        WINAPI DumpHashItemTable(PHASHTABLE pht);
#endif

#ifndef SIZEOF
#define SIZEOF(a)                   sizeof(a)
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif

#define PATH_CCH_EXT                64

#endif // _URLSHELL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\util.h ===
/*
 * util.h - Utility routines description.
 */


/* Prototypes
 *************/

/* util .c */

extern BOOL IsPathDirectory(PCSTR);
extern BOOL KeyExists(HKEY, PCSTR);

BOOL 
StrToIntExW(
    LPCWSTR   pwszString,
    DWORD     dwFlags,          // STIF_ bitfield 
    int FAR * piRet);
BOOL 
StrToIntExA(
    LPCSTR    pszString,
    DWORD     dwFlags,          // STIF_ bitfield 
    int FAR * piRet);
#ifdef UNICODE
#define StrToIntEx  StrToIntExW
#else
#define StrToIntEx  StrToIntExA
#endif 

// Avoid conflict with Nashville commctrl
#ifdef STIF_SUPPORT_HEX
#undef STIF_DEFAULT
#undef STIF_SUPPORT_HEX
#endif

// Flags for StrToIntEx
#define STIF_DEFAULT        0x00000000L
#define STIF_SUPPORT_HEX    0x00000001L

int
StrSpnW(
    LPCWSTR psz,
    LPCWSTR pszSet);
int
StrSpnA(
    LPCSTR psz,
    LPCSTR pszSet);
#ifdef UNICODE
#define StrSpn      StrSpnW
#else
#define StrSpn      StrSpnA
#endif 


LPWSTR
StrPBrkW(
    IN LPCWSTR psz,
    IN LPCWSTR pszSet);
LPSTR
StrPBrkA(
    LPCSTR psz,
    LPCSTR pszSet);
#ifdef UNICODE
#define StrPBrk     StrPBrkW
#else
#define StrPBrk     StrPBrkA
#endif 


/* Win95 Kernel only stubs lstrcpyW.  Memphis Kernel supports it.  
** Use SHLWAPI's version.
*/

#define lstrcpyW    StrCpyW


#ifdef DEBUG

extern BOOL IsStringContained(PCSTR, PCSTR);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\valid.h ===
/*
 * valid.h - Validation functions description.
 */


/* Prototypes
 *************/

/* valid.c */

extern BOOL IsValidHWND(HWND);

#ifdef DEBUG

extern BOOL IsValidFileCreationMode(DWORD);
extern BOOL IsValidHANDLE(HANDLE);
extern BOOL IsValidHEVENT(HANDLE);
extern BOOL IsValidHFILE(HANDLE);
extern BOOL IsValidHGLOBAL(HGLOBAL);
extern BOOL IsValidHMENU(HMENU);
extern BOOL IsValidHICON(HICON);
extern BOOL IsValidHINSTANCE(HINSTANCE);
extern BOOL IsValidHKEY(HKEY);
extern BOOL IsValidHMODULE(HMODULE);
extern BOOL IsValidHPROCESS(HANDLE);
extern BOOL IsValidHTEMPLATEFILE(HANDLE);
extern BOOL IsValidIconIndex(HRESULT, PCSTR, UINT, int);
extern BOOL IsValidPCFILETIME(PCFILETIME);
extern BOOL IsValidPCPOINT(PCPOINT);
extern BOOL IsValidPCPOINTL(PCPOINTL);
extern BOOL IsValidPCSECURITY_ATTRIBUTES(PCSECURITY_ATTRIBUTES);
extern BOOL IsValidPCWIN32_FIND_DATA(PCWIN32_FIND_DATA);
extern BOOL IsValidPath(PCSTR);
extern BOOL IsValidPathResult(HRESULT, PCSTR, UINT);
extern BOOL IsValidExtension(PCSTR);
extern BOOL IsValidRegistryValueType(DWORD);
extern BOOL IsValidShowCmd(int);
extern BOOL IsValidHotkey(WORD);

#ifdef _COMPARISONRESULT_DEFINED_

extern BOOL IsValidCOMPARISONRESULT(COMPARISONRESULT);

#endif   /* _COMPARISONRESULT_DEFINED_ */

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\util.c ===
/*
 * util.c - Utility routines.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/****************************** Public Functions *****************************/


#ifdef WINNT

//
//  These are some helper functions for handling Unicode strings
//

/*----------------------------------------------------------
Purpose: This function converts a wide-char string to a multi-byte
         string.

         If pszBuf is non-NULL and the converted string can fit in 
         pszBuf, then *ppszAnsi will point to the given buffer.
         Otherwise, this function will allocate a buffer that can
         hold the converted string.

         If pszWide is NULL, then *ppszAnsi will be freed.  Note
         that pszBuf must be the same pointer between the call
         that converted the string and the call that frees the 
         string.

Returns: TRUE 
         FALSE (if out of memory)

Cond:    --
*/
PRIVATE_CODE 
BOOL 
AnsiFromUnicode(
    LPSTR * ppszAnsi,
    LPCWSTR pwszWide,        // NULL to clean up
    LPSTR pszBuf,
    int cchBuf)
    {
    BOOL bRet;

    // Convert the string?
    if (pwszWide)
        {
        // Yes; determine the converted string length
        int cch;
        LPSTR psz;

        cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, NULL, 0, NULL, NULL);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pszBuf)
            {
            // Yes; allocate space
            cchBuf = cch + 1;
            psz = (LPSTR)LocalAlloc(LPTR, CbFromCchA(cchBuf));
            }
        else
            {
            // No; use the provided buffer
            ASSERT(pszBuf);
            psz = pszBuf;
            }

        if (psz)
            {
            // Convert the string
            cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, psz, cchBuf, NULL, NULL);
            bRet = (0 < cch);
            }
        else
            {
            bRet = FALSE;
            }

        *ppszAnsi = psz;
        }
    else
        {
        // No; was this buffer allocated?
        if (*ppszAnsi && pszBuf != *ppszAnsi)
            {
            // Yes; clean up
            LocalFree((HLOCAL)*ppszAnsi);
            *ppszAnsi = NULL;
            }
        bRet = TRUE;
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Wide-char wrapper for StrToIntExA.

Returns: see StrToIntExA
Cond:    --
*/
PUBLIC_CODE
BOOL 
StrToIntExW(
    LPCWSTR   pwszString,
    DWORD     dwFlags,          // STIF_ bitfield 
    int FAR * piRet)
    {
    CHAR szBuf[MAX_BUF];
    LPSTR pszString;
    BOOL bRet = AnsiFromUnicode(&pszString, pwszString, szBuf, SIZECHARS(szBuf));

    if (bRet)
        {
        bRet = StrToIntExA(pszString, dwFlags, piRet);
        AnsiFromUnicode(&pszString, NULL, szBuf, 0);
        }
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Returns an integer value specifying the length of
         the substring in psz that consists entirely of 
         characters in pszSet.  If psz begins with a character
         not in pszSet, then this function returns 0.

         This is a DBCS-safe version of the CRT strspn().  

Returns: see above
Cond:    --
*/
PUBLIC_CODE
int
StrSpnW(
    LPCWSTR psz,
    LPCWSTR pszSet)
    {
    LPCWSTR pszT;
    LPCWSTR pszSetT;

    ASSERT(psz);
    ASSERT(pszSet);

    // Go thru the string to be inspected 

    for (pszT = psz; *pszT; pszT++)
        {
        // Go thru the char set

        for (pszSetT = pszSet; *pszSetT != *pszT; pszSetT++)
            {
            if (0 == *pszSetT)
                {
                // Reached end of char set without finding a match
                return (int)(pszT - psz);
                }
            }
        }

    return (int)(pszT - psz);
    }


/*----------------------------------------------------------
Purpose: Returns a pointer to the first occurrence of a character
         in psz that belongs to the set of characters in pszSet.
         The search does not include the null terminator.

Returns: see above
Cond:    --
*/
PUBLIC_CODE
LPWSTR
StrPBrkW(
    IN LPCWSTR psz,
    IN LPCWSTR pszSet)
    {
    LPCWSTR pszSetT;

    ASSERT(psz);
    ASSERT(pszSet);

    // Go thru the string to be inspected 

    while (*psz)
        {
        // Go thru the char set

        for (pszSetT = pszSet; *pszSetT; pszSetT++)
            {
            if (*psz == *pszSetT)
                {
                // Found first character that matches
                return (LPWSTR)psz;     // Const -> non-const
                }
            }
        psz++;
        }

    return NULL;
    }

#endif // WINNT


/*----------------------------------------------------------
Purpose: Special verion of atoi.  Supports hexadecimal too.

         If this function returns FALSE, *piRet is set to 0.

Returns: TRUE if the string is a number, or contains a partial number
         FALSE if the string is not a number

Cond:    --
*/
PUBLIC_CODE
BOOL 
StrToIntExA(
    LPCSTR    pszString,
    DWORD     dwFlags,          // STIF_ bitfield 
    int FAR * piRet)
    {
    #define IS_DIGIT(ch)    InRange(ch, '0', '9')

    BOOL bRet;
    int n;
    BOOL bNeg = FALSE;
    LPCSTR psz;
    LPCSTR pszAdj;

    // Skip leading whitespace
    //
    for (psz = pszString; *psz == ' ' || *psz == '\n' || *psz == '\t'; psz = CharNextA(psz))
        ;
      
    // Determine possible explicit signage
    //  
    if (*psz == '+' || *psz == '-')
        {
        bNeg = (*psz == '+') ? FALSE : TRUE;
        psz++;
        }

    // Or is this hexadecimal?
    //
    pszAdj = CharNextA(psz);
    if ((STIF_SUPPORT_HEX & dwFlags) &&
        *psz == '0' && (*pszAdj == 'x' || *pszAdj == 'X'))
        {
        // Yes

        // (Never allow negative sign with hexadecimal numbers)
        bNeg = FALSE;   
        psz = CharNextA(pszAdj);

        pszAdj = psz;

        // Do the conversion
        //
        for (n = 0; ; psz = CharNextA(psz))
            {
            if (IS_DIGIT(*psz))
                n = 0x10 * n + *psz - '0';
            else
                {
                CHAR ch = *psz;
                int n2;

                if (ch >= 'a')
                    ch -= 'a' - 'A';

                n2 = ch - 'A' + 0xA;
                if (n2 >= 0xA && n2 <= 0xF)
                    n = 0x10 * n + n2;
                else
                    break;
                }
            }

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
        }
    else
        {
        // No
        pszAdj = psz;

        // Do the conversion
        for (n = 0; IS_DIGIT(*psz); psz = CharNextA(psz))
            n = 10 * n + *psz - '0';

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
        }

    *piRet = bNeg ? -n : n;

    return bRet;
    }    


/*----------------------------------------------------------
Purpose: Returns an integer value specifying the length of
         the substring in psz that consists entirely of 
         characters in pszSet.  If psz begins with a character
         not in pszSet, then this function returns 0.

         This is a DBCS-safe version of the CRT strspn().  

Returns: see above
Cond:    --
*/
PUBLIC_CODE
int
StrSpnA(
    LPCSTR psz,
    LPCSTR pszSet)
    {
    LPCSTR pszT;
    LPCSTR pszSetT;

    // Go thru the string to be inspected 

    for (pszT = psz; *pszT; pszT = CharNextA(pszT))
        {
        // Go thru the char set

        for (pszSetT = pszSet; *pszSetT; pszSetT = CharNextA(pszSetT))
            {
            if (*pszSetT == *pszT)
                {
                if ( !IsDBCSLeadByte(*pszSetT) )
                    {
                    break;      // Chars match
                    }
                else if (pszSetT[1] == pszT[1])
                    {
                    break;      // Chars match
                    }
                }
            }

        // End of char set?
        if (0 == *pszSetT)
            {
            break;      // Yes, no match on this inspected char
            }
        }

    return (int)(pszT - psz);
    }


/*----------------------------------------------------------
Purpose: Returns a pointer to the first occurrence of a character
         in psz that belongs to the set of characters in pszSet.
         The search does not include the null terminator.

         If psz contains no characters that are in the set of
         characters in pszSet, this function returns NULL.

         This function is DBCS-safe.

Returns: see above
Cond:    --
*/
PUBLIC_CODE
LPSTR
StrPBrkA(
    LPCSTR psz,
    LPCSTR pszSet)
    {
    LPCSTR pszSetT;

    ASSERT(psz);
    ASSERT(pszSet);

    while (*psz)
        {
        for (pszSetT = pszSet; *pszSetT; pszSetT = CharNextA(pszSetT))
            {
            if (*psz == *pszSetT)
                {
                // Found first character that matches
                return (LPSTR)psz;      // Const -> non-const
                }
            }
        psz = CharNextA(psz);
        }

    return NULL;
    }





PUBLIC_CODE BOOL IsPathDirectory(PCSTR pcszPath)
{
   DWORD dwAttr;

   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));

   dwAttr = GetFileAttributes(pcszPath);

   return(dwAttr != -1 &&
          IS_FLAG_SET(dwAttr, FILE_ATTRIBUTE_DIRECTORY));
}


PUBLIC_CODE BOOL KeyExists(HKEY hkeyRoot, PCSTR pcszSubKey)
{
   BOOL bExists;
   HKEY hkey;

   ASSERT(IS_VALID_HANDLE(hkeyRoot, KEY));
   ASSERT(IS_VALID_STRING_PTR(pcszSubKey, CSTR));

   bExists = (RegOpenKey(hkeyRoot, pcszSubKey, &hkey) == ERROR_SUCCESS);

   if (bExists)
      EVAL(RegCloseKey(hkey) == ERROR_SUCCESS);

   return(bExists);
}


#ifdef DEBUG

PUBLIC_CODE BOOL IsStringContained(PCSTR pcszBigger, PCSTR pcszSuffix)
{
   ASSERT(IS_VALID_STRING_PTR(pcszBigger, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszSuffix, CSTR));

   return(pcszSuffix >= pcszBigger &&
          pcszSuffix <= pcszBigger + lstrlen(pcszBigger));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\url\valid.c ===
/*
 * valid.c - Validation functions module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/****************************** Public Functions *****************************/


PUBLIC_CODE BOOL IsValidHWND(HWND hwnd)
{
   /* Ask User if this is a valid window. */

   return(IsWindow(hwnd));
}


#ifdef DEBUG

PUBLIC_CODE BOOL IsValidHANDLE(HANDLE hnd)
{
   return(EVAL(hnd != INVALID_HANDLE_VALUE));
}


PUBLIC_CODE BOOL IsValidHEVENT(HANDLE hevent)
{
   return(IsValidHANDLE(hevent));
}


PUBLIC_CODE BOOL IsValidHFILE(HANDLE hf)
{
   return(IsValidHANDLE(hf));
}


PUBLIC_CODE BOOL IsValidHGLOBAL(HGLOBAL hg)
{
   return(IsValidHANDLE(hg));
}


PUBLIC_CODE BOOL IsValidHMENU(HMENU hmenu)
{
   return(IsValidHANDLE(hmenu));
}


PUBLIC_CODE BOOL IsValidHINSTANCE(HINSTANCE hinst)
{
   return(IsValidHANDLE(hinst));
}


PUBLIC_CODE BOOL IsValidHICON(HICON hicon)
{
   return(IsValidHANDLE(hicon));
}


PUBLIC_CODE BOOL IsValidHKEY(HKEY hkey)
{
   return(IsValidHANDLE(hkey));
}


PUBLIC_CODE BOOL IsValidHMODULE(HMODULE hmod)
{
   return(IsValidHANDLE(hmod));
}


PUBLIC_CODE BOOL IsValidHPROCESS(HANDLE hprocess)
{
   return(IsValidHANDLE(hprocess));
}


PUBLIC_CODE BOOL IsValidPCSECURITY_ATTRIBUTES(PCSECURITY_ATTRIBUTES pcsa)
{
   /* FEATURE: Fill me in. */

   return(IS_VALID_READ_PTR(pcsa, CSECURITY_ATTRIBUTES));
}


PUBLIC_CODE BOOL IsValidFileCreationMode(DWORD dwMode)
{
   BOOL bResult;

   switch (dwMode)
   {
      case CREATE_NEW:
      case CREATE_ALWAYS:
      case OPEN_EXISTING:
      case OPEN_ALWAYS:
      case TRUNCATE_EXISTING:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT(("IsValidFileCreationMode(): Invalid file creation mode %#lx.",
                    dwMode));
         break;
   }

   return(bResult);
}


PUBLIC_CODE BOOL IsValidHTEMPLATEFILE(HANDLE htf)
{
   return(IsValidHANDLE(htf));
}


PUBLIC_CODE BOOL IsValidPCFILETIME(PCFILETIME pcft)
{
   /* dwLowDateTime may be any value. */
   /* dwHighDateTime may be any value. */

   return(IS_VALID_READ_PTR(pcft, CFILETIME));
}


PUBLIC_CODE BOOL IsValidPCPOINT(PCPOINT pcpt)
{

   /* x may be any value. */
   /* y may be any value. */

   return(IS_VALID_READ_PTR(pcpt, CPOINT));
}


PUBLIC_CODE BOOL IsValidPCPOINTL(PCPOINTL pcptl)
{

   /* x may be any value. */
   /* y may be any value. */

   return(IS_VALID_READ_PTR(pcptl, CPOINTL));
}


PUBLIC_CODE BOOL IsValidPCWIN32_FIND_DATA(PCWIN32_FIND_DATA pcwfd)
{
   /* FEATURE: Fill me in. */

   return(IS_VALID_READ_PTR(pcwfd, CWIN32_FIND_DATA));
}


PUBLIC_CODE BOOL IsValidShowCmd(int nShow)
{
   BOOL bResult;

   switch (nShow)
   {
      case SW_HIDE:
      case SW_SHOWNORMAL:
      case SW_SHOWMINIMIZED:
      case SW_SHOWMAXIMIZED:
      case SW_SHOWNOACTIVATE:
      case SW_SHOW:
      case SW_MINIMIZE:
      case SW_SHOWMINNOACTIVE:
      case SW_SHOWNA:
      case SW_RESTORE:
      case SW_SHOWDEFAULT:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT(("IsValidShowCmd(): Invalid show command %d.",
                    nShow));
         break;
   }

   return(bResult);
}


PUBLIC_CODE BOOL IsValidPath(PCSTR pcszPath)
{
   /* FEATURE: Beef up path validation. */

   return(IS_VALID_STRING_PTR(pcszPath, CSTR) &&
          EVAL((UINT)lstrlen(pcszPath) < MAX_PATH_LEN));
}


PUBLIC_CODE BOOL IsValidPathResult(HRESULT hr, PCSTR pcszPath,
                                   UINT ucbPathBufLen)
{
   return((hr == S_OK &&
           EVAL(IsValidPath(pcszPath)) &&
           EVAL((UINT)lstrlen(pcszPath) < ucbPathBufLen)) ||
          (hr != S_OK &&
           EVAL(! ucbPathBufLen ||
                ! pcszPath ||
                ! *pcszPath)));
}


PUBLIC_CODE BOOL IsValidExtension(PCSTR pcszExt)
{
   return(IS_VALID_STRING_PTR(pcszExt, CSTR) &&
          EVAL(lstrlen(pcszExt) < MAX_PATH_LEN) &&
          EVAL(*pcszExt == PERIOD));
}


PUBLIC_CODE BOOL IsValidIconIndex(HRESULT hr, PCSTR pcszIconFile,
                                  UINT ucbIconFileBufLen, int niIcon)
{
   return(EVAL(IsValidPathResult(hr, pcszIconFile, ucbIconFileBufLen)) &&
          EVAL(hr == S_OK ||
               ! niIcon));
}


PUBLIC_CODE BOOL IsValidRegistryValueType(DWORD dwType)
{
   BOOL bResult;

   switch (dwType)
   {
      case REG_NONE:
      case REG_SZ:
      case REG_EXPAND_SZ:
      case REG_BINARY:
      case REG_DWORD:
      case REG_DWORD_BIG_ENDIAN:
      case REG_LINK:
      case REG_MULTI_SZ:
      case REG_RESOURCE_LIST:
      case REG_FULL_RESOURCE_DESCRIPTOR:
      case REG_RESOURCE_REQUIREMENTS_LIST:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT(("IsValidRegistryValueType(): Invalid registry value type %lu.",
                    dwType));
         break;
   }

   return(bResult);
}


PUBLIC_CODE BOOL IsValidHotkey(WORD wHotkey)
{
   /* FEATURE: Beef up hotkey validation. */

   return(wHotkey != 0);
}


#ifdef _COMPARISONRESULT_DEFINED_

PUBLIC_CODE BOOL IsValidCOMPARISONRESULT(COMPARISONRESULT cr)
{
   BOOL bResult;

   switch (cr)
   {
      case CR_FIRST_SMALLER:
      case CR_EQUAL:
      case CR_FIRST_LARGER:
         bResult = TRUE;
         break;

      default:
         WARNING_OUT(("IsValidCOMPARISONRESULT(): Unknown COMPARISONRESULT %d.",
                      cr));
         bResult = FALSE;
         break;
   }

   return(bResult);
}

#endif   /* _COMPARISONRESULT_DEFINED_ */

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\userstub\resource.h ===
#define IDD_InstallStubProgress 10

#define IDS_UNINSTALL   100
#define IDS_DESKTOP     101
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\userstub\debug.c ===
// We don't use the debugging macros ourselves, but we use
// RunInstallUninstallStubs2, which uses IsOS() in stocklib,
// and stocklib uses the debugging macros, so we have to do all this
// stuff to keep the linker happy.
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include <windows.h>
#include <ccstock.h>

// Define some things for debug.h
//
#define SZ_DEBUGINI     "shellext.ini"
#define SZ_DEBUGSECTION "userstub"
#define SZ_MODULE       "USERSTUB"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\apithk.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc

NO_BROWSER_FILE = 1

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

TARGETNAME      = apithk
TARGETPATH      = obj
TARGETTYPE      = LIBRARY

SOURCES         = ..\apithk.c

INCLUDES        = $(INCLUDES);$(INETCORE_INC_PATH);$(DS_INC_PATH);


# We don't use a precompiled header until there are enough files to
# merit it.
#PRECOMPILED_INCLUDE = ..\inetcplp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\apithk.h ===
//
//  APITHK.H
//


#ifndef _APITHK_H_
#define _APITHK_H_

STDAPI_(HPROPSHEETPAGE) Whistler_CreatePropertySheetPageW(LPCPROPSHEETPAGEW a);

#endif // _APITHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\apithk.c ===
//
//  APITHK.C
//
//  This file has API thunks that allow shdocvw to load and run on
//  multiple versions of NT or Win95.  Since this component needs
//  to load on the base-level NT 4.0 and Win95, any calls to system
//  APIs introduced in later OS versions must be done via GetProcAddress.
// 
//  Also, any code that may need to access data structures that are
//  post-4.0 specific can be added here.
//
//  NOTE:  this file does *not* use the standard precompiled header,
//         so it can set _WIN32_WINNT to a later version.
//
#define UNICODE 1

#include "windows.h"       // Don't use precompiled header here
#include "commctrl.h"       // Don't use precompiled header here
#include "prsht.h"
#include "shlwapi.h"
#include <shfusion.h>

HPROPSHEETPAGE Whistler_CreatePropertySheetPageW(LPCPROPSHEETPAGEW a)
{
    LPCPROPSHEETPAGEW ppsp = (LPCPROPSHEETPAGEW)a;
    PROPSHEETPAGEW psp;

    if (g_hActCtx && (a->dwSize<=PROPSHEETPAGE_V2_SIZE))
    {
        memset(&psp, 0, sizeof(psp));
        CopyMemory(&psp, a, a->dwSize);
        psp.dwSize = sizeof(psp);
        ppsp = &psp;
    }
    return CreatePropertySheetPageW(ppsp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\userstub\userstub.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       userstub.cpp
//
//  Contents:   exe to load webcheck
//
//  Classes:
//
//  Functions:
//
//  History:    12-12/96    rayen (Raymond Endres)  Created
//
//----------------------------------------------------------------------------

#define _SHELL32_ // We delayload shell32

#include <windows.h>
#include <debug.h>
#include <docobj.h>
#include <webcheck.h>
#include <shlguid.h>
#include <shlobj.h>
#include <shellp.h>
#include <shlwapi.h>

// if inststub.h is used in userstub, use LoadString() OW use MLLoadString()
#define	USERSTUB	1

//
// NOTE: ActiveSetup relies on our window name and class name
// to shut us down properly in softboot.  Do not change it.
//
//const TCHAR c_szClassName[] = TEXT("userstub");
//const TCHAR c_szWebCheck[] = TEXT("WebCheck");
//const TCHAR c_szWebCheckWindow[] = TEXT("MS_WebcheckMonitor");
//const TCHAR c_szShellReg[] = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad");
//const TCHAR c_szWebcheckKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Webcheck");

typedef struct {
    HINSTANCE   hInstance;          // handle to current instance
    BOOL        fUninstallOnly;     // TRUE -> run uninstall stubs only, then quit
} GLOBALS;

GLOBALS g;

//
// The caller should always GetProcAddress("DllGetVersion"), not
// implicitly link to it.
//

typedef HRESULT (CALLBACK* DLLGETVERSIONPROC)(DLLVERSIONINFO *);



// Code to run install/uninstall stubs, from shell\inc.

#define HINST_THISDLL   g.hInstance
#include "resource.h"
#include <inststub.h>

// need to do this so we can since inststub.h #includes <runonce.c>
BOOL g_fCleanBoot = FALSE;
BOOL g_fEndSession = FALSE;


int WINAPI WinMainT(HINSTANCE, HINSTANCE, LPSTR, int);
BOOL bParseCommandLine(LPSTR lpCmdLine, int nCmdShow);


//----------------------------------------------------------------------------
// ModuleEntry
//----------------------------------------------------------------------------
extern "C" int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
    LPTSTR pszCmdLine;

    pszCmdLine = GetCommandLine();

    // g_hProcessHeap = GetProcessHeap();

    //
    // We don't want the "No disk in drive X:" requesters, so we set
    // the critical error mask such that calls will just silently fail
    //
    SetErrorMode(SEM_FAILCRITICALERRORS);

    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    // Since we now have a way for an extension to tell us when it is finished,
    // we will terminate all processes when the main thread goes away.

    ExitProcess(i);

    // DebugMsg(DM_TRACE, TEXT("c.me: Cabinet main thread exiting without ExitProcess."));
    return i;
}



//----------------------------------------------------------------------------
// WinMain
//----------------------------------------------------------------------------
int WINAPI WinMainT(
    HINSTANCE hInstance,            // handle to current instance
    HINSTANCE hPrevInstance,        // handle to previous instance
    LPSTR lpCmdLine,                // pointer to command line
    int nCmdShow                        // show state of window
   )
{
    // Save the globals
    g.hInstance = hInstance;
    g.fUninstallOnly = FALSE;

    // Parse the command line, for DEBUG options and for uninstall-only switch.
    if (!bParseCommandLine(lpCmdLine, nCmdShow))
        return 0;

    // Run all install/uninstall stubs for browser-only mode.
    // If IE4 has been uninstalled, we'll be run with the -u switch; this
    // means to run install/uninstall stubs only, no webcheck stuff.
    RunInstallUninstallStubs2(NULL);

    // Return the exit code to Windows
    return 0;
}

//----------------------------------------------------------------------------
// bParseCmdLine
//
// Parse the command line
//      -u  run install/uninstall stubs only, then quit
//  DEBUG options:
//      -v  visible window (easy to shutdown)
//      -a  add webcheck to shell service object
//      -r  remove webcheck from shell service object
//      -s  fix shell folders only
//      -?  these options
//----------------------------------------------------------------------------
BOOL bParseCommandLine(LPSTR lpCmdLine, int nCmdShow)
{
    if (!lpCmdLine)
        return TRUE;

    CharUpper(lpCmdLine);   /* easier to parse */
    while (*lpCmdLine)
    {
        if (*lpCmdLine != '-' && *lpCmdLine != '/')
            break;

        lpCmdLine++;

        switch (*(lpCmdLine++))
        {
            case 'U':
                g.fUninstallOnly = TRUE;
                break;
        }

        while (*lpCmdLine == ' ' || *lpCmdLine == '\t') {
            lpCmdLine++;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\cdlabsc.h ===
#ifndef __CDLBSC_INCLUDED__
#define __CDLBSC_INCLUDED__

class CDLAgentBSC : public IBindStatusCallback, public IServiceProvider,
                    public IInternetHostSecurityManager
{
    public:
        CDLAgentBSC(CCDLAgent *pcdlagent, DWORD dwMaxSizeKB, BOOL fSilentOperation, LPWSTR szCDFURL);
        virtual ~CDLAgentBSC();
        HRESULT Abort();
        HRESULT Pause();
        HRESULT Resume();

        // IUnknown methods
        STDMETHODIMP QueryInterface( REFIID ridd, void **ppv );
        STDMETHODIMP_( ULONG ) AddRef();
        STDMETHODIMP_( ULONG ) Release();
    
        // IBindStatusCallback methods
        STDMETHODIMP GetBindInfo(DWORD *grfBINDINFOF, BINDINFO *pbindinfo);
        STDMETHODIMP OnStartBinding(DWORD grfBSCOption, IBinding *pib);
        STDMETHODIMP GetPriority(LONG *pnPriority);
        STDMETHODIMP OnProgress(ULONG ulProgress, ULONG ulProgressMax,
                                ULONG ulStatusCode, LPCWSTR szStatusText);
        STDMETHODIMP OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
                                      FORMATETC *pformatetc,
                                      STGMEDIUM *pstgmed);
        STDMETHODIMP OnObjectAvailable(REFIID riid, IUnknown *punk);
        STDMETHODIMP OnLowResource(DWORD dwReserved);
        STDMETHODIMP OnStopBinding(HRESULT hresult, LPCWSTR szError);

        // IServiceProvider
        STDMETHODIMP QueryService(REFGUID rsid, REFIID riid, void ** ppvObj);

        // IInternetHostSecurityManager
        STDMETHODIMP GetSecurityId(BYTE *pbSecurityId, DWORD *pcbSecurityId,
                                   DWORD_PTR dwReserved);
        
        STDMETHODIMP ProcessUrlAction(DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy,
                                      BYTE *pContext, DWORD cbContext, DWORD dwFlags,
                                      DWORD dwReserved);
        
        STDMETHODIMP QueryCustomPolicy(REFGUID guidKey, BYTE **ppPolicy,
                                       DWORD *pcbPolicy, BYTE *pContext,
                                       DWORD cbContext, DWORD dwReserved);
    
    
    protected:
        IBinding                   *m_pIBinding; // ibinding from code dl'er
        CCDLAgent                  *m_pCdlAgent;
        DWORD                       m_cRef;
        BOOL                        m_fSilentOperation;
        DWORD                       m_dwMaxSize;
        WCHAR                       m_pwzCDFBase[INTERNET_MAX_URL_LENGTH];
        IInternetSecurityManager   *m_pSecMgr;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\cdlabsc.cpp ===
#include "private.h"
#include "cdlabsc.h"

CDLAgentBSC::CDLAgentBSC(CCDLAgent *pCdlAgent, DWORD dwMaxSizeKB, BOOL fSilentOperation,
                         LPWSTR szCDFUrl)
{
    int iLen = 0;

    m_cRef = 1;
    m_pIBinding = NULL;
    m_pCdlAgent = pCdlAgent;
    m_fSilentOperation = fSilentOperation;
    m_dwMaxSize = dwMaxSizeKB*1024;
    m_pSecMgr = NULL;


    iLen = lstrlenW(szCDFUrl) + 1;
    iLen = (int)((iLen < INTERNET_MAX_URL_LENGTH) ? (iLen) : (INTERNET_MAX_URL_LENGTH));
    StrCpyNW(m_pwzCDFBase, szCDFUrl, iLen);

    if (m_pCdlAgent != NULL)
    {
        m_pCdlAgent->AddRef();
    }
}

CDLAgentBSC::~CDLAgentBSC()
{
    if (m_pCdlAgent != NULL)
    {
        m_pCdlAgent->Release();
    }

    if (m_pIBinding != NULL)
    {
        m_pIBinding->Release();
    }

    if (m_pSecMgr) {
        m_pSecMgr->Release();
    }
}

HRESULT CDLAgentBSC::Abort()
{
    if (m_pIBinding != NULL) {

        return m_pIBinding->Abort();
    
    } else {
    
        return S_OK;
    
    }
}

/*
 *
 * IUnknown Methods
 *
 */

STDMETHODIMP CDLAgentBSC::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT          hr = E_NOINTERFACE;

    *ppv = NULL;
    if (riid == IID_IUnknown || riid == IID_IBindStatusCallback)
    {
        *ppv = (IBindStatusCallback *)this;
    }
    else if (riid == IID_IServiceProvider)
    {
        *ppv = (IServiceProvider *) this;
        AddRef();
    }

    if (*ppv != NULL)
    {
        ((IUnknown *)*ppv)->AddRef();
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CDLAgentBSC::QueryService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    HRESULT     hr = NOERROR;
    IServiceProvider        *pIServiceProvider = NULL;

    if (!ppvObj)
        return E_INVALIDARG;

    *ppvObj = 0;

    if (IsEqualGUID(rsid, IID_IInternetHostSecurityManager) &&
        IsEqualGUID(riid, IID_IInternetHostSecurityManager)) {

        if (m_pSecMgr == NULL) {
            hr = CoInternetCreateSecurityManager(NULL, &m_pSecMgr, NULL);
        }
        
        if (m_pSecMgr) {
            *ppvObj = (IInternetHostSecurityManager *)this;
            AddRef();
        }
        else {
            hr = E_NOINTERFACE;
        }
    }
    else {
        hr = E_NOINTERFACE;
        *ppvObj = NULL;
    }
        

    return hr;
}

STDMETHODIMP_(ULONG) CDLAgentBSC::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CDLAgentBSC::Release()
{
    if (0L != --m_cRef)
    {
        return m_cRef;
    }
    delete this;

    return 0;
}

/*
 *
 * IBindStatusCallback Methods
 *
 */

STDMETHODIMP CDLAgentBSC::OnStartBinding(DWORD grfBSCOption, IBinding *pib)
{
    if (m_pIBinding != NULL)
    {
        m_pIBinding->Release();
    }
    m_pIBinding = pib;

    if (m_pIBinding != NULL)
    {
        m_pIBinding->AddRef();
    }

    return S_OK;
}

STDMETHODIMP CDLAgentBSC::OnStopBinding(HRESULT hresult, LPCWSTR szError)
{
    HRESULT         hr = S_OK;
    
    if (m_pCdlAgent != NULL)
    {
        m_pCdlAgent->SetErrorEndText(szError);
        m_pCdlAgent->SetEndStatus(hresult);
        m_pCdlAgent->CleanUp();
    }

    return hr;
}

STDMETHODIMP CDLAgentBSC::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    return S_OK;
}

STDMETHODIMP CDLAgentBSC::GetPriority(LONG *pnPriority)
{
    return S_OK;
}

STDMETHODIMP CDLAgentBSC::OnLowResource(DWORD dwReserved)
{
    return S_OK;
}  

STDMETHODIMP CDLAgentBSC::OnProgress(ULONG ulProgress, ULONG ulProgressMax,
                                    ULONG ulStatusCode,
                                    LPCWSTR szStatusText)
{
    if ((m_dwMaxSize > 0) && (ulStatusCode == BINDSTATUS_DOWNLOADINGDATA)) {

        if (ulProgress > m_dwMaxSize || ulProgressMax > m_dwMaxSize) {
        
           Abort();
        
        }

    }

    return S_OK;
}


STDMETHODIMP CDLAgentBSC::GetBindInfo(DWORD *pgrfBINDF, BINDINFO *pbindInfo)
{
   if (m_fSilentOperation)
   {
       *pgrfBINDF |= BINDF_SILENTOPERATION;
   }
    return S_OK;
}

STDMETHODIMP CDLAgentBSC::OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
                                         FORMATETC *pformatetc,
                                         STGMEDIUM *pstgmed)
{
    return S_OK;
}

HRESULT CDLAgentBSC::Pause()
{
    HRESULT              hr = E_FAIL;
    if (m_pIBinding != NULL)
    {
        hr = m_pIBinding->Suspend();
    }

    return hr;
}

HRESULT CDLAgentBSC::Resume()
{
    HRESULT              hr = E_FAIL;
    if (m_pIBinding != NULL)
    {
        hr = m_pIBinding->Resume();
    }

    return hr;
}

// IInternetHostSecurityManager
STDMETHODIMP CDLAgentBSC::GetSecurityId(BYTE *pbSecurityId, DWORD *pcbSecurityId,
                                        DWORD_PTR dwReserved)
{
    HRESULT                    hr = E_FAIL;

    if (m_pSecMgr) {
        hr = m_pSecMgr->GetSecurityId(m_pwzCDFBase, pbSecurityId,
                                     pcbSecurityId, dwReserved);
    }

    return hr;
}

STDMETHODIMP CDLAgentBSC::ProcessUrlAction(DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy,
                                           BYTE *pContext, DWORD cbContext, DWORD dwFlags,
                                           DWORD dwReserved)
{
    HRESULT                    hr = E_FAIL;

    if (m_pSecMgr) {
        hr = m_pSecMgr->ProcessUrlAction(m_pwzCDFBase, dwAction, pPolicy,
                                        cbPolicy, pContext, cbContext,
                                        dwFlags, dwReserved);
    }

    return hr;
}

STDMETHODIMP CDLAgentBSC::QueryCustomPolicy(REFGUID guidKey, BYTE **ppPolicy,
                                            DWORD *pcbPolicy, BYTE *pContext,
                                            DWORD cbContext, DWORD dwReserved)
{
    HRESULT                    hr = E_FAIL;

    if (m_pSecMgr) {
        hr = m_pSecMgr->QueryCustomPolicy(m_pwzCDFBase, guidKey, ppPolicy,
                                         pcbPolicy, pContext, cbContext,
                                         dwReserved);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\cdfagent.h ===
#ifndef _CDFAGENT_H
#define _CDFAGENT_H

#include "msxml.h"

class CProcessElement;
class CProcessRoot;

class CUrlTrackingCache;

class CRunDeliveryAgentSink
{
public:
    // OnAgentProgress not currently called
    virtual HRESULT OnAgentProgress()
                    { return E_NOTIMPL; }
    // OnAgentEnd called when agent is complete. fSynchronous means that StartAgent call
    //  has not yet returned; hrResult will be returned from StartAgent
    virtual HRESULT OnAgentEnd(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                               long lSizeDownloaded, HRESULT hrResult, LPCWSTR wszResult,
                               BOOL fSynchronous)
                    { return E_NOTIMPL; }
};

class CProcessElementSink
{
public:
    virtual HRESULT OnChildDone(CProcessElement *pChild, HRESULT hr) = 0;
    virtual LPCWSTR GetBaseUrl() = 0;   // Returned pointer doesn't need to get freed
    virtual BOOL    IsGlobalLog() = 0;
};

typedef struct CDF_TIME
{
    WORD   wDay;
    WORD   wHour;
    WORD   wMin;
    WORD   wReserved;
    DWORD  dwConvertedMinutes;      // Day/Hour/Min in Minutes
} CDF_TIME;


//////////////////////////////////////////////////////////////////////////
//
// Channel Agent object
//
//////////////////////////////////////////////////////////////////////////
class CChannelAgent : public CDeliveryAgent,
                      public CUrlDownloadSink,
                      public CProcessElementSink
{
    friend CProcessElement; // for SendUpdateProgress
    friend CProcessRoot;    // for laziness
protected:
// properties
    LPWSTR      m_pwszURL;
    DWORD       m_dwChannelFlags;

// used during updating
    CUrlDownload    *m_pCurDownload;
    IExtractIcon    *m_pChannelIconHelper;

    BOOL            m_fHasInitCookie;   // One time deal, don't try again.

    VARIANT         m_varChange;

    GROUPID         m_llCacheGroupID;
    GROUPID         m_llOldCacheGroupID;

    // other agent flags
    enum {
        FLAG_CDFCHANGED  =  0x80000000  // did the CDF change?
    };

private:
    ~CChannelAgent(void);

public:
    CChannelAgent(void);

    // CUrlDownloadSink
    HRESULT     OnAuthenticate(HWND *phwnd, LPWSTR *ppszUsername, LPWSTR *ppszPassword);
    HRESULT     OnDownloadComplete(UINT iID, int iError);

    // CProcessElementSink
    HRESULT     OnChildDone(CProcessElement *pChild, HRESULT hr);
    LPCWSTR     GetBaseUrl() { return GetUrl(); }
    BOOL        IsGlobalLog() { return FALSE; }

    // virtual functions overriding CDeliveryAgent
    HRESULT     AgentPause(DWORD dwFlags);
    HRESULT     AgentResume(DWORD dwFlags);
    HRESULT     AgentAbort(DWORD dwFlags);
    STDMETHODIMP GetIconLocation(UINT, LPTSTR, UINT, int *, UINT *);
    STDMETHODIMP Extract(LPCTSTR, UINT, HICON *, HICON *, UINT);

    LPCWSTR     GetUrl() { return m_pwszURL; }
    ISubscriptionItem *GetStartItem() { return m_pSubscriptionItem; }

    BOOL        IsChannelFlagSet(DWORD dwFlag) { return dwFlag & m_dwChannelFlags; }

    void        SetScreenSaverURL(LPCWSTR pwszURL);

protected:
    // CDeliveryAgent overrides
    HRESULT     ModifyUpdateEnd(ISubscriptionItem *pEndItem, UINT *puiRes);
    HRESULT     StartOperation();
    HRESULT     StartDownload();
    void        CleanUp();

    // Used during updates
    CProcessRoot   *m_pProcess;
    LPWSTR      m_pwszScreenSaverURL;

public:
    DWORD           m_dwMaxSizeKB;
};

//////////////////////////////////////////////////////////////////////////
//
// CRunDeliveryAgent object
// Will run a delivery agent and host it for you
// Create, call Init, then call StartAgent
// Use static function SafeRelease to safely release this class.
//
//////////////////////////////////////////////////////////////////////////
class CRunDeliveryAgent : public ISubscriptionAgentEvents
{
protected:
    virtual ~CRunDeliveryAgent();

    CRunDeliveryAgentSink *m_pParent;

    ULONG           m_cRef;

    ISubscriptionItem         *m_pItem;
    ISubscriptionAgentControl *m_pAgent;

    HRESULT     m_hrResult;
    BOOL        m_fInStartAgent;

    CLSID       m_clsidDest;

    void        CleanUp();

public:
    CRunDeliveryAgent();

    HRESULT Init(CRunDeliveryAgentSink *pParent, ISubscriptionItem *pItem, REFCLSID rclsidDest);

    void LeaveMeAlone() { m_pParent = NULL; }

inline static void SafeRelease(CRunDeliveryAgent * &pThis)
{ if (pThis) { pThis->m_pParent=NULL; pThis->Release(); pThis=NULL; } }

static HRESULT CreateNewItem(ISubscriptionItem **ppItem, REFCLSID rclsidAgent);

    // StartAgent will return E_PENDING if agent is running. Otherwise it will return
    //  synchronous result code from agent.
    HRESULT     StartAgent();

    HRESULT     AgentPause(DWORD dwFlags);
    HRESULT     AgentResume(DWORD dwFlags);
    HRESULT     AgentAbort(DWORD dwFlags);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **ppunk);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // ISubscriptionAgentEvents members
    STDMETHODIMP UpdateBegin(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie);
    STDMETHODIMP UpdateProgress(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                        long lSizeDownloaded, long lProgressCurrent, long lProgressMax,
                        HRESULT hrStatus, LPCWSTR wszStatus);
    STDMETHODIMP UpdateEnd(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                            long lSizeDownloaded,
                            HRESULT hrResult, LPCWSTR wszResult);
    STDMETHODIMP ReportError(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                             HRESULT hrError, LPCWSTR wszError);
};

class CChannelAgentHolder : public CRunDeliveryAgent,
                            public IServiceProvider
{
protected:
    ~CChannelAgentHolder();

public:
    CChannelAgentHolder(CChannelAgent *pChannelAgent, CProcessElement *pProcess);

    // IUnknown
    STDMETHODIMP        QueryInterface(REFIID riid, void **ppunk);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // ServiceProvider
    STDMETHODIMP        QueryService(REFGUID guidService, REFIID riid, void **ppvObject);

protected:
    CChannelAgent *m_pChannelAgent;
    CProcessElement *m_pProcess;
};


//////////////////////////////////////////////////////////////////////////
//
// Process Element objects
//
// User of this class
//  1) Creates & passes in self & element
//  2) Calls Run
//  3) If E_PENDING, will receive call back "OnChildDone"
//
// The purpose of this class is simply to allow us to save our state of
//  walking the XML OM, so that we can host another deliver agent
//  (webcrawler). This requires us to return out to the thread's message
//  pump after sending the "agent start" to the web crawler.
// The if a webcrawl is initiated the class creates its own sink. Classes
//  also keep references to their spawned enumerations in case of an
//  abort, which comes from the root element (CProcessRoot instance)
//
//////////////////////////////////////////////////////////////////////////
class CProcessElement : public CProcessElementSink, public CRunDeliveryAgentSink
{
public:
    CProcessElement(CProcessElementSink *pParent, CProcessRoot *pRoot, IXMLElement *pEle);
    ~CProcessElement();

    // From CRunDeliveryAgent
    HRESULT OnAgentEnd(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                       long lSizeDownloaded, HRESULT hrResult, LPCWSTR wszResult,
                       BOOL fSynchronous);

    typedef HRESULT (CChannelAgent::*PFNHANDLETAG)(LPCWSTR pwszTagName, IXMLElement *pEle);
    typedef struct
    {
        LPCWSTR         pwszTagName;
        PFNHANDLETAG    pfnHandleTag;
    } TAGTABLE;

    // E_FAIL, E_PENDING, or S_OK
    virtual HRESULT    Run();

    // Called when E_PENDING DoChild returns (from m_pCurChild)
    HRESULT     OnChildDone(CProcessElement *pChild, HRESULT hr);


    HRESULT     Pause(DWORD dwFlags);
    HRESULT     Resume(DWORD dwFlags);
    HRESULT     Abort(DWORD dwFlags);

    IXMLElement *GetCurrentElement() { return m_pChildElement; }

protected:
    // Returns E_PENDING, or S_OK if enumeration complete
    HRESULT     DoEnumeration();

    // E_PENDING if webcrawl pending
    HRESULT     DoChild(CProcessElement *pChild);

    // Should return E_PENDING, or S_OK if processing done
    // Can return E_ABORT to abort entire CDF processing
    virtual HRESULT ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem) = 0;

    // Called by DoEnumeration when it's done. Return value ignored.
    virtual HRESULT EnumerationComplete() { return S_OK; }

    // E_PENDING, or E_FAIL
    HRESULT     DoDeliveryAgent(ISubscriptionItem *pItem, REFCLSID rclsid, LPCWSTR pwszURL=NULL);
    HRESULT     DoWebCrawl(IXMLElement *pItem, LPCWSTR pwszURL=NULL);
    HRESULT     DoSoftDist(IXMLElement *pItem);

    BOOL    ShouldDownloadLogo(IXMLElement *pLogo);

    // If relative url, will combine with most recent base URL
    // *ppwszRetUrl should be NULL & will be LocalAlloced if needed
    HRESULT     CombineWithBaseUrl(LPCWSTR pwszUrl, LPWSTR *ppwszRetUrl);

    // Returned pointer doesn't need to get freed
    LPCWSTR     GetBaseUrl() { return m_pParent->GetBaseUrl(); }
    BOOL        IsGlobalLog() { return m_pParent->IsGlobalLog(); }

    CProcessRoot    *m_pRoot;

    CProcessElement *m_pCurChild;
    IXMLElementCollection *m_pCollection;
    long            m_lIndex;
    long            m_lMax;
    BOOL            m_fStartedEnumeration;
    BOOL            m_fSentEnumerationComplete;

    IXMLElement    *m_pElement;
    IXMLElement    *m_pChildElement;

    CProcessElementSink *m_pParent;

    CRunDeliveryAgent   *m_pRunAgent;
};

class CProcessRoot : public CProcessElement
{
public:
    CProcessRoot(CChannelAgent *pParent, IXMLElement *pRoot);
    ~CProcessRoot();

    CChannelAgent      *m_pChannelAgent;
    DWORD               m_dwCurSizeKB;
    int                 m_iTotalStarted;
    BOOL                m_fMaxSizeExceeded;

protected:
    ISubscriptionItem  *m_pDefaultStartItem;
    CUrlTrackingCache  *m_pTracking;

public:
    HRESULT     CreateStartItem(ISubscriptionItem **ppItem);
    IUnknown   *DefaultStartItem() { return m_pDefaultStartItem; }

    HRESULT     Run();

    // Called when E_PENDING DoChild returns (from m_pCurChild, a CProcessChannel)
    HRESULT     OnChildDone(CProcessElement *pChild, HRESULT hr);
    HRESULT     OnAgentEnd(const SUBSCRIPTIONCOOKIE *, long, HRESULT, LPCWSTR, BOOL);

    BOOL        IsPaused() { return m_pChannelAgent->IsPaused(); }
    BOOL        IsChannelFlagSet(DWORD dw) { return m_pChannelAgent->IsChannelFlagSet(dw); }

//  HRESULT     ProcessLogin(IXMLElement *pElement);
    HRESULT     DoTrackingFromItem(IXMLElement *pItem, LPCWSTR pwszUrl, BOOL fForceLog);
    HRESULT     DoTrackingFromLog(IXMLElement *pItem);

protected:
    HRESULT     ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem);

    LPCWSTR     GetBaseUrl() { return m_pChannelAgent->GetUrl(); }
};

class CProcessChannel : public CProcessElement
{
public:
    CProcessChannel(CProcessElementSink *pParent, CProcessRoot *pRoot, IXMLElement *pItem);
    ~CProcessChannel();
 
    HRESULT     Run();

    void        SetGlobalLogFlag(BOOL flag) { m_fglobalLog = flag; }

protected:
    HRESULT     ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem);

    LPCWSTR     GetBaseUrl() { if (m_bstrBaseUrl) return m_bstrBaseUrl; return m_pParent->GetBaseUrl(); }

    BOOL        IsGlobalLog() { return m_fglobalLog; }

    HRESULT     CheckPreCache();

    BOOL        m_fDownloadedHREF;
    BSTR        m_bstrBaseUrl;
    BOOL        m_fglobalLog;
};

class CProcessItem : public CProcessElement
{
public:
    CProcessItem(CProcessElementSink *pParent, CProcessRoot *pRoot, IXMLElement *pItem);
    ~CProcessItem();

protected:
    HRESULT     ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem);
    HRESULT     EnumerationComplete();

    BSTR        m_bstrAnchorURL;
    BOOL        m_fScreenSaver;
    BOOL        m_fDesktop;
    BOOL        m_fEmail;
};

class CProcessSchedule : public CProcessElement
{
public:
    CProcessSchedule(CProcessElementSink *pParent, CProcessRoot *pRoot, IXMLElement *pItem);
 
    HRESULT     Run();

protected:
    HRESULT     ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem);
    HRESULT     EnumerationComplete();

    CDF_TIME    m_timeInterval;
    CDF_TIME    m_timeEarliest;
    CDF_TIME    m_timeLatest;

    SYSTEMTIME  m_stStartDate;
    SYSTEMTIME  m_stEndDate;

public:
    TASK_TRIGGER m_tt;
};

class CExtractSchedule : public CProcessElement
{
public:
    CExtractSchedule(IXMLElement *pEle, CExtractSchedule *m_pExtractRoot);
    HRESULT     ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem);
    HRESULT     GetTaskTrigger(TASK_TRIGGER *ptt);

    virtual HRESULT    Run();

    TASK_TRIGGER m_tt;
    CExtractSchedule *m_pExtractRoot;

protected:    
    LPCWSTR     GetBaseUrl() { return NULL; }
};

#endif // _CDFAGENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include <windows.h>
#include <ccstock.h>

// Define some things for debug.h
//
#define SZ_DEBUGINI     "shellext.ini"
#define SZ_DEBUGSECTION "webcheck"
#define SZ_MODULE       "WEBCHECK"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\admin.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       admin.cpp
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    
//
//----------------------------------------------------------------------------

#include "private.h"
#include "shguidp.h"
#include "chanmgr.h"
#include "chanmgrp.h"
#include "winineti.h"

#include <mluisupp.h>

// Infodelivery Policies registry locations
#define INFODELIVERY_POLICIES TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery")
// const TCHAR c_szRegKeyRestrictions[]    = INFODELIVERY_POLICIES TEXT("\\Restrictions");
const TCHAR c_szRegKeyModifications[]   = INFODELIVERY_POLICIES TEXT("\\Modifications");
const TCHAR c_szRegKeyCompletedMods[]   = INFODELIVERY_POLICIES TEXT("\\CompletedModifications");
const TCHAR c_szRegKeyIESetup[]         = TEXT("Software\\Microsoft\\IE4\\Setup");

// Wininet cache preload directory
const TCHAR c_szRegKeyCachePreload[]    = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache\\Preload");

// Registry key names of supported Modifications
const TCHAR c_szAddChannels[]               = TEXT("AddChannels");
const TCHAR c_szRemoveChannels[]            = TEXT("RemoveChannels");
const TCHAR c_szRemoveAllChannels[]         = TEXT("RemoveAllChannels");
const TCHAR c_szAddSubscriptions[]          = TEXT("AddSubscriptions");
const TCHAR c_szRemoveSubscriptions[]       = TEXT("RemoveSubscriptions");
const TCHAR c_szAddScheduleGroups[]         = TEXT("AddScheduleGroups");
const TCHAR c_szRemoveScheduleGroups[]      = TEXT("RemoveScheduleGroups");
const TCHAR c_szAddDesktopComponents[]      = TEXT("AddDesktopComponents");
const TCHAR c_szRemoveDesktopComponents[]   = TEXT("RemoveDesktopComponents");

// Registry value names of supported Modifications
const TCHAR c_szURL[]                   = TEXT("URL");
const TCHAR c_szTitle[]                 = TEXT("Title");
const TCHAR c_szLogo[]                  = TEXT("Logo");
const TCHAR c_szWideLogo[]              = TEXT("WideLogo");
const TCHAR c_szIcon[]                  = TEXT("Icon");
const TCHAR c_szCategory[]              = TEXT("Category");
const TCHAR c_szChannelGuide[]          = TEXT("ChannelGuide"); // DO NOTE CHANGE THIS STRING WITHOUT UPDATING CDFVIEW!!!
const TCHAR c_szPreloadURL[]            = TEXT("PreloadURL");
const TCHAR c_szLCID[]                  = TEXT("LangId");       // This must be an LCID despite its name
const TCHAR c_szSoftware[]              = TEXT("Software");
const TCHAR c_szSubscriptionType[]      = TEXT("SubscriptionType");
const TCHAR c_szScheduleGroup[]         = TEXT("ScheduleGroup");
const TCHAR c_szEarliestTime[]          = TEXT("EarliestTime");
const TCHAR c_szIntervalTime[]          = TEXT("IntervalTime");
const TCHAR c_szLatestTime[]            = TEXT("LatestTime");
const TCHAR c_szComponentType[]         = TEXT("DesktopComponentType");
const TCHAR c_szUsername[]              = TEXT("Username");
const TCHAR c_szPassword[]              = TEXT("Password");
const TCHAR c_szOldIEVersion[]          = TEXT("OldIEVersion");
const TCHAR c_szNonActive[]             = TEXT("NonActive");
const TCHAR c_szOffline[]               = TEXT("Offline");
const TCHAR c_szSynchronize[]           = TEXT("Synchronize");

// Names of reserved schedule groups that we support even in localized version
const WCHAR c_szScheduleAuto[]          = L"Auto";
const WCHAR c_szScheduleDaily[]         = L"Daily";
const WCHAR c_szScheduleWeekly[]        = L"Weekly";
const WCHAR c_szScheduleManual[]        = L"Manual";

// Function prototypes for Modification handlers
HRESULT ProcessAddChannels(HKEY hkey);
HRESULT ProcessRemoveChannels(HKEY hkey);
HRESULT ProcessRemoveAllChannels(HKEY hkey);
HRESULT ProcessAddSubscriptions(HKEY hkey);
HRESULT ProcessRemoveSubscriptions(HKEY hkey);
HRESULT ProcessAddScheduleGroups(HKEY hkey);
HRESULT ProcessRemoveScheduleGroups(HKEY hkey);
HRESULT ProcessAddDesktopComponents(HKEY hkey);
HRESULT ProcessRemoveDesktopComponents(HKEY hkey);

HRESULT Channel_GetBasePath(LPTSTR pszPath, int cch);

// Helper functions
void ShowChannelDirectories(BOOL fShow);

// Table of supported Actions and corresponding functions
// NOTE: The table must be ordered appropriately (RemoveAll must come before Add)
typedef HRESULT (*PFNACTION)(HKEY);
typedef struct { LPCTSTR szAction; PFNACTION pfnAction; } ACTIONTABLE;
ACTIONTABLE rgActionTable[] = {
    { c_szRemoveAllChannels,        &ProcessRemoveAllChannels },
    { c_szRemoveSubscriptions,      &ProcessRemoveSubscriptions },
    { c_szRemoveChannels,           &ProcessRemoveChannels },
    { c_szRemoveDesktopComponents,  &ProcessRemoveDesktopComponents },
    { c_szRemoveScheduleGroups,     &ProcessRemoveScheduleGroups },
    { c_szAddChannels,              &ProcessAddChannels },
    { c_szAddDesktopComponents,     &ProcessAddDesktopComponents },
    { c_szAddScheduleGroups,        &ProcessAddScheduleGroups },
    { c_szAddSubscriptions,         &ProcessAddSubscriptions }
};
#define ACTIONTABLECOUNT (sizeof(rgActionTable) / sizeof(ACTIONTABLE))
#define ACTIONTABLE_ADDCHANNELS 5

// Helper class to manipulate registry keys
class CRegKey
{
    HKEY m_hkey;
    DWORD dwIndex;
public:
    CRegKey(void)
    {
        m_hkey = NULL;
        dwIndex = 0;
    }
    ~CRegKey(void)
    {
        if (m_hkey)
        {
            LONG lRet = RegCloseKey(m_hkey);
            ASSERT(ERROR_SUCCESS == lRet);
            m_hkey = NULL;
        }
    }
    void SetKey(HKEY hkey)
    {
        m_hkey = hkey;
    }
    HKEY GetKey(void)
    {
        return m_hkey;
    }
    HRESULT OpenForRead(HKEY hkey, LPCTSTR szSubKey)
    {
        ASSERT(NULL == m_hkey);
        LONG lRet = RegOpenKeyEx(hkey, szSubKey, 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &m_hkey);
        ASSERT((ERROR_SUCCESS == lRet) || !m_hkey);
        return (ERROR_SUCCESS == lRet)?(S_OK):(E_FAIL);
    }
    HRESULT CreateForWrite(HKEY hkey, LPCTSTR szSubKey)
    {
        ASSERT(NULL == m_hkey);
        DWORD dwDisp;
        LONG lRet = RegCreateKeyEx(hkey, szSubKey, 0, TEXT(""), 0, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &m_hkey, &dwDisp);
        ASSERT(ERROR_SUCCESS == lRet);
        return (ERROR_SUCCESS == lRet)?(S_OK):(E_FAIL);
    }
    HRESULT GetSubKeyCount(PDWORD pdwKeys)
    {
        ASSERT(NULL != m_hkey);
        LONG lRet = RegQueryInfoKey(m_hkey, NULL, NULL, NULL, pdwKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        ASSERT(ERROR_SUCCESS == lRet);
        return (ERROR_SUCCESS == lRet)?(S_OK):(E_FAIL);
    }
    HRESULT Next(LPTSTR szSubKey)
    {
        ASSERT(NULL != m_hkey);
        DWORD dwLen = MAX_PATH; // Assumes size of incoming buffer.
        LONG lRet = RegEnumKeyEx(m_hkey, dwIndex, szSubKey, &dwLen, NULL, NULL, NULL, NULL);
        dwIndex++;
        if (ERROR_SUCCESS == lRet)
            return S_OK;
        else if (ERROR_NO_MORE_ITEMS == lRet)
            return S_FALSE;
        else
        {
            ASSERT(FALSE);
            return E_FAIL;
        }
    }
    HRESULT Reset(void)
    {
        dwIndex = 0;
        return S_OK;
    }
    HRESULT SetValue(LPCTSTR szValueName, DWORD dwValue)
    {
        ASSERT(m_hkey);
        LONG lRet = RegSetValueEx(m_hkey, szValueName, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));
        ASSERT(ERROR_SUCCESS == lRet);
        return (ERROR_SUCCESS == lRet)?(S_OK):(E_FAIL);
    }
    HRESULT GetValue(LPCTSTR szValueName, DWORD *pdwValue)
    {
        ASSERT(m_hkey);
        DWORD dwType = REG_DWORD;
        DWORD dwLen = sizeof(DWORD);
        LONG lRet = RegQueryValueEx(m_hkey, szValueName, 0, &dwType, (LPBYTE)pdwValue, &dwLen);
        return (ERROR_SUCCESS == lRet)?(S_OK):(E_FAIL);
    }
    HRESULT GetStringValue(LPCTSTR szValueName, LPTSTR szValue, DWORD dwLen)
    {
        ASSERT(m_hkey);
        DWORD dwType = REG_SZ;
        LONG lRet = RegQueryValueEx(m_hkey, szValueName, 0, &dwType, (LPBYTE)szValue, &dwLen);
        return (ERROR_SUCCESS == lRet)?(S_OK):(E_FAIL);
    }
    HRESULT SetBSTRValue(LPCTSTR szValueName, BSTR bstr)
    {
        ASSERT(m_hkey);
        TCHAR szValue[INTERNET_MAX_URL_LENGTH];
        MyOleStrToStrN(szValue, ARRAYSIZE(szValue), bstr);
        LONG lRet = RegSetValueEx(m_hkey, szValueName, 0, REG_SZ, (LPBYTE)szValue, lstrlen(szValue) + 1);
        ASSERT(ERROR_SUCCESS == lRet);
        return (ERROR_SUCCESS == lRet)?(S_OK):(E_FAIL);
    }
    HRESULT GetBSTRValue(LPCTSTR szValueName, BSTR *pbstr)
    {
        ASSERT(m_hkey);
        *pbstr = NULL;
        TCHAR szValue[INTERNET_MAX_URL_LENGTH];
        DWORD dwType = REG_SZ;
        DWORD dwLen = sizeof(szValue);
        LONG lRet = RegQueryValueEx(m_hkey, szValueName, 0, &dwType, (LPBYTE)szValue, &dwLen);
        if (ERROR_SUCCESS == lRet)
        {
            *pbstr = SysAllocStringLen(NULL, dwLen);    // dwLen includes null terminator
            if (*pbstr)
            {
                MyStrToOleStrN(*pbstr, dwLen, szValue);
                return S_OK;
            }
        }
        return E_FAIL;
    }
};

// Helper class to manage Dynamic Pointer Arrays of HKEYs.
class CRegKeyDPA
{
    HDPA m_hdpa;
    int m_count;
public:
    CRegKeyDPA(void)
    {
        m_hdpa = NULL;
        m_count = 0;
    }
    ~CRegKeyDPA(void)
    {
        if (m_hdpa)
        {
            ASSERT(m_count);
            int i;
            for (i = 0; i < m_count; i++)
                RegCloseKey(GetKey(i));
            DPA_Destroy(m_hdpa);
        }
    }
    int GetCount(void)
    {
        return m_count;
    }
    HKEY GetKey(int i)
    {
        ASSERT(i >= 0 && i < m_count);
        return (HKEY)DPA_GetPtr(m_hdpa, i);
    }
    HRESULT Add(HKEY hkey, LPCTSTR szSubKey)
    {
        if (!m_hdpa)
        {
            m_hdpa = DPA_CreateEx(5, NULL); // Choose arbitrary growth value
            if (!m_hdpa)
                return E_FAIL;
        }
        HKEY hkeyNew;
        LONG lRet = RegOpenKeyEx(hkey, szSubKey, 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hkeyNew);
        if (ERROR_SUCCESS != lRet)
            return E_FAIL;
        if (-1 == DPA_InsertPtr(m_hdpa, DPA_APPEND, hkeyNew))
        {
            RegCloseKey(hkeyNew);
            return E_FAIL;
        }
        m_count++;
        return S_OK;
    }
};

//
// 8/18/98 darrenmi
// Copied (and butchered) from shdocvw\util.cpp so we don't have to load it at startup
//
DWORD WCRestricted2W(BROWSER_RESTRICTIONS rest, LPCWSTR pwzUrl, DWORD dwReserved)
{
    DWORD dwType, dw = 0, dwSize = sizeof(DWORD);

    // we only handle NoChannelUI restriction
    if(rest != REST_NoChannelUI)
    {
        return 0;
    }

    // read registry setting
    SHGetValue(HKEY_CURRENT_USER,
            TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery\\Restrictions"),
            TEXT("NoChannelUI"),
            &dwType, &dw, &dwSize);

    return dw;
}


// ProcessInfodeliveryPolicies
//
// This is the main Admin API for Infodelivery.  It returns E_FAIL for errors,
// S_FALSE for nothing to process, and S_OK for correctly processed items.
//
// Reg key organization     [Modifications]         - the key to process
//                              [GUID1]             - group of actions
//                                  [AddChannels]   - sample action
//                                      [Channel1]  - element of an action
//
HRESULT ProcessInfodeliveryPolicies(void)
{
    HRESULT hr;
    CRegKey regModifications;
    TCHAR   szGUID[MAX_PATH];

    // Check if channels should be hidden.
    if (WCRestricted2W(REST_NoChannelUI, NULL, 0))
    {
        ShowChannelDirectories(FALSE);
    }
    else
    {
        ShowChannelDirectories(TRUE);
    }
    
    // Bail out quickly if there are no Modifications to perform. (Return S_FALSE)
    hr = regModifications.OpenForRead(HKEY_CURRENT_USER, c_szRegKeyModifications);
    if (FAILED(hr))
        return S_FALSE;

    // Prepare to use the CompletedModifications key.
    CRegKey regCompletedMods;
    hr = regCompletedMods.CreateForWrite(HKEY_CURRENT_USER, c_szRegKeyCompletedMods);
    if (FAILED(hr))
        return hr;

    hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Prepare queues of registry keys to actions
    CRegKeyDPA rgKeyQueue[ACTIONTABLECOUNT];

    // Enumerate the GUID keys, skipping the completed ones.
    // Enumerate the Actions beneath them and add them to queues.
    // ignoring errors here too.
    while (S_OK == regModifications.Next(szGUID))
    {
        DWORD dwValue;
        if (FAILED(regCompletedMods.GetValue(szGUID, &dwValue)))
        {
            CRegKey regGUID;
            TCHAR   szAction[MAX_PATH];
            hr = regGUID.OpenForRead(regModifications.GetKey(), szGUID);
            while (S_OK == regGUID.Next(szAction))
            {
                // Search the table to see if it's a key we understand.
                // If so, add it to the queue.
                int i;
                for (i = 0; i < ACTIONTABLECOUNT; i++)
                {
                    if (!StrCmpI(rgActionTable[i].szAction, szAction))
                    {
                        rgKeyQueue[i].Add(regGUID.GetKey(), szAction);
                        break;
                    }
                }
            }
        }
    }

    // Process all the keys we've accumulated.  (Correct order is assumed.)
    int i;
    for (i = 0; i < ACTIONTABLECOUNT; i++)
    {
        if (rgKeyQueue[i].GetCount())
        {
            int iKey;
            for (iKey = 0; iKey < rgKeyQueue[i].GetCount(); iKey++)
            {
                (rgActionTable[i].pfnAction)(rgKeyQueue[i].GetKey(iKey));
            }
        }
    }

    // Walk the GUIDs we've processed and mark them completed with the time.
    // Updating ones we skipped as well will help with garbage collection.
    regModifications.Reset();
    while (S_OK == regModifications.Next(szGUID))
    {
        SYSTEMTIME st;
        FILETIME ft;
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &ft);
        regCompletedMods.SetValue(szGUID, ft.dwHighDateTime);
    }

    // Delete the Actions.  NOTE: NT's RegDeleteKey() doesn't delete sub-keys.
    // This shlwapi API uses KEY_ALL_ACCESS.
    // We probably have to close all the keys here.
    SHDeleteKey(HKEY_CURRENT_USER, c_szRegKeyModifications);

    // If any channels were processed, tell the cache to reload.
    // We should only do this for default channels.
    if (rgKeyQueue[ACTIONTABLE_ADDCHANNELS].GetCount())
    {
        ASSERT(!StrCmpI(rgActionTable[ACTIONTABLE_ADDCHANNELS].szAction, c_szAddChannels));
        LoadUrlCacheContent();
    }

    CoUninitialize();

    return S_OK;
}

//
// ProcessAddChannels_SortCallback - sort in reverse order
//
int ProcessAddChannels_SortCallback(PVOID p1, PVOID p2, LPARAM lparam)
{
    return StrCmpI((LPTSTR)p2, (LPTSTR)p1);
}

//
// ProcessAddChannels
//
HRESULT ProcessAddChannels(HKEY hkey)
{
    // Enumerate the channels in the AddChannels key
    HRESULT hr;
    DWORD dwChannels;
    CRegKey regAdd;
    regAdd.SetKey(hkey);
    hr = regAdd.GetSubKeyCount(&dwChannels);
    if (SUCCEEDED(hr) && dwChannels)
    {
        // Check if the channels are the same code page as the system default.
        BOOL bCodePageMatch = TRUE;
        LCID lcidChannel = 0;
        if (SUCCEEDED(regAdd.GetValue(c_szLCID, &lcidChannel)))
        {
            TCHAR szCodePageSystem[8];
            TCHAR szCodePageChannel[8];
            szCodePageChannel[0] = 0;   // Init in case there's no locale info
            GetLocaleInfo(lcidChannel, LOCALE_IDEFAULTANSICODEPAGE, szCodePageChannel, ARRAYSIZE(szCodePageChannel));
            int iRet = GetLocaleInfo(GetSystemDefaultLCID(), LOCALE_IDEFAULTANSICODEPAGE, szCodePageSystem, ARRAYSIZE(szCodePageSystem));
            ASSERT(iRet);
            if (StrCmpI(szCodePageSystem, szCodePageChannel))
                bCodePageMatch = FALSE;
        }
    
        hr = E_FAIL;
        TCHAR *pch = (TCHAR *)MemAlloc(LMEM_FIXED, dwChannels * MAX_PATH * sizeof(TCHAR));
        if (pch)
        {
            HDPA hdpa = DPA_Create(dwChannels);
            if (hdpa)
            {
                DWORD i;
                TCHAR *pchCur = pch;
                for (i = 0; i < dwChannels; i++)
                {
                    if ((S_OK != regAdd.Next(pchCur)) || (-1 == DPA_InsertPtr(hdpa, DPA_APPEND, pchCur)))
                        break;
                    pchCur += MAX_PATH;
                }
                if (i >= dwChannels)
                {
                    // Sort channels by registry key name,
                    DPA_Sort(hdpa, ProcessAddChannels_SortCallback, 0);
                    // Now create them.
                    for (i = 0; i < dwChannels; i++)
                    {
                        BSTR bstrURL = NULL;
                        BSTR bstrTitle = NULL;
                        BSTR bstrLogo = NULL;
                        BSTR bstrWideLogo = NULL;
                        BSTR bstrIcon = NULL;
                        BSTR bstrPreloadURL = NULL;
                        DWORD dwCategory = 0;       // default to channel
                        DWORD dwChannelGuide = 0;   // default to not a guide
                        DWORD dwSoftware = 0;       // default to non-software channel
                        DWORD dwOffline = 0;
                        DWORD dwSynchronize = 0;
                        CRegKey regChannel;
                        regChannel.OpenForRead(hkey, (LPCTSTR)DPA_GetPtr(hdpa, i));
                        hr = regChannel.GetBSTRValue(c_szURL, &bstrURL);
                        hr = regChannel.GetBSTRValue(c_szTitle, &bstrTitle);
                        hr = regChannel.GetBSTRValue(c_szLogo, &bstrLogo);
                        hr = regChannel.GetBSTRValue(c_szWideLogo, &bstrWideLogo);
                        hr = regChannel.GetBSTRValue(c_szIcon, &bstrIcon);
                        hr = regChannel.GetBSTRValue(c_szPreloadURL, &bstrPreloadURL);
                        hr = regChannel.GetValue(c_szCategory, &dwCategory);
                        hr = regChannel.GetValue(c_szChannelGuide, &dwChannelGuide);
                        hr = regChannel.GetValue(c_szSoftware, &dwSoftware);
                        hr = regChannel.GetValue(c_szOffline, &dwOffline);
                        hr = regChannel.GetValue(c_szSynchronize, &dwSynchronize);
                        if (bstrTitle)
                        {
                            IChannelMgr *pChannelMgr = NULL;
                            hr = CoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER, IID_IChannelMgr, (void**)&pChannelMgr);
                            if (SUCCEEDED(hr))
                            {
                                // See if channel already exists - do nothing if it does (62976)
                                IEnumChannels *pEnumChannels = NULL;
                                if (SUCCEEDED(pChannelMgr->EnumChannels(CHANENUM_ALLFOLDERS, bstrURL, &pEnumChannels)))
                                {
                                    CHANNELENUMINFO Bogus={0};
                                    ULONG cFetched=0;

                                    if ((S_OK == pEnumChannels->Next(1, &Bogus, &cFetched)) && cFetched)
                                    {
                                        // Oops. It exists. Skip all this goo.
                                        hr = E_FAIL;
                                    }
                                }
                                SAFERELEASE(pEnumChannels);
                            }
                            if (SUCCEEDED(hr))
                            {
                                if (dwCategory && bCodePageMatch)
                                {
                                    // create a category (useless if code page doesn't match)
                                    CHANNELCATEGORYINFO csi = {0};
                                    csi.cbSize   = sizeof(csi);
                                    csi.pszURL   = bstrURL;
                                    csi.pszTitle = bstrTitle;
                                    csi.pszLogo  = bstrLogo;
                                    csi.pszIcon  = bstrIcon;
                                    csi.pszWideLogo = bstrWideLogo;
                                    hr = pChannelMgr->AddCategory(&csi);
                                }
                                else if (!dwCategory && bstrURL)
                                {
                                    // update the registry if it's a channel guide
                                    if (dwChannelGuide)
                                    {
                                        CRegKey reg;
                                        hr = reg.CreateForWrite(HKEY_CURRENT_USER, c_szRegKey);
                                        if (SUCCEEDED(hr))
                                            reg.SetBSTRValue(c_szChannelGuide, bstrTitle);
                                    }
                                    // tell wininet if there's preload content
                                    if (bstrPreloadURL)
                                    {
                                        CRegKey reg;
                                        hr = reg.CreateForWrite(HKEY_CURRENT_USER, c_szRegKeyCachePreload);
                                        if (SUCCEEDED(hr))
                                        {
                                            TCHAR szURL[INTERNET_MAX_URL_LENGTH];
                                            MyOleStrToStrN(szURL, ARRAYSIZE(szURL), bstrURL);
                                            reg.SetBSTRValue(szURL, bstrPreloadURL);
                                        }
                                    }
                                    // create a channel (use URL instead of Title if code page doesn't match)
                                    CHANNELSHORTCUTINFO csi = {0};
                                    csi.cbSize   = sizeof(csi);
                                    csi.pszURL   = bstrURL;
                                    if (bCodePageMatch)
                                        csi.pszTitle = bstrTitle;
                                    else
                                        csi.pszTitle = bstrURL;
                                    csi.pszLogo  = bstrLogo;
                                    csi.pszIcon  = bstrIcon;
                                    csi.pszWideLogo = bstrWideLogo;
                                    if (dwSoftware)
                                        csi.bIsSoftware = TRUE;
                                    hr = pChannelMgr->AddChannelShortcut(&csi);
                                }
                            }
                            SAFERELEASE(pChannelMgr);

                            if (dwOffline)
                            {
                                ISubscriptionMgr2 *pSubMgr2 = NULL;
                                hr = CoCreateInstance(CLSID_SubscriptionMgr, 
                                                      NULL, 
                                                      CLSCTX_INPROC_SERVER, 
                                                      IID_ISubscriptionMgr2, 
                                                      (void**)&pSubMgr2);
                                if (SUCCEEDED(hr))
                                {
                                    hr = pSubMgr2->CreateSubscription(NULL, 
                                                                      bstrURL, 
                                                                      bstrTitle, 
                                                                      CREATESUBS_NOUI,
                                                                      SUBSTYPE_CHANNEL, 
                                                                      NULL);

                                    if (dwSynchronize)
                                    {
                                        BOOL bIsSubscribed;
                                        SUBSCRIPTIONCOOKIE cookie;

                                        if (SUCCEEDED(pSubMgr2->IsSubscribed(bstrURL, &bIsSubscribed))
                                            && bIsSubscribed &&
                                            SUCCEEDED(ReadCookieFromInetDB(bstrURL, &cookie)))
                                        {
                                            pSubMgr2->UpdateItems(SUBSMGRUPDATE_MINIMIZE, 1, &cookie);
                                        }
                                    }
                                    pSubMgr2->Release();
                                }
                            }
                        }
                        SAFEFREEBSTR(bstrURL);
                        SAFEFREEBSTR(bstrTitle);
                        SAFEFREEBSTR(bstrLogo);
                        SAFEFREEBSTR(bstrWideLogo);
                        SAFEFREEBSTR(bstrIcon);
                        SAFEFREEBSTR(bstrPreloadURL);
                    }
                }
                DPA_Destroy(hdpa);
            }
            MemFree(pch);
        }
    }
    regAdd.SetKey(NULL);
    return S_OK;
}

//
// ProcessRemoveChannels
//
HRESULT ProcessRemoveChannels(HKEY hkey)
{
    // Enumerate the channel keys in the RemoveChannels key
    HRESULT hr;
    CRegKey reg;
    reg.SetKey(hkey);
    TCHAR szChannel[MAX_PATH];
    while (S_OK == reg.Next(szChannel))
    {
        CRegKey regChannel;
        DWORD dwNonActive = 0;  // default to deleting Active & NonActive channels
        TCHAR szURL[INTERNET_MAX_URL_LENGTH];
        regChannel.OpenForRead(hkey, szChannel);
        regChannel.GetValue(c_szNonActive, &dwNonActive);
        if (SUCCEEDED(regChannel.GetStringValue(c_szURL, szURL, sizeof(szURL))))
        {
            // Check if the channel is Active to determine if we can delete it
            if (dwNonActive)
            {
                CRegKey regPreload;
                if (SUCCEEDED(regPreload.OpenForRead(HKEY_CURRENT_USER, c_szRegKeyCachePreload)))
                {
                    if (SUCCEEDED(regPreload.GetStringValue(szURL, NULL, 0)))
                    {
                        dwNonActive = 0;
                    }
                }
            }

            // Now delete the channel if appropriate
            if (!dwNonActive)
            {
                IChannelMgr *pChannelMgr = NULL;
                hr = CoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER, IID_IChannelMgr, (void**)&pChannelMgr);
                if (SUCCEEDED(hr))
                {
                    BSTR bstrURL;
                    if (SUCCEEDED(regChannel.GetBSTRValue(c_szURL, &bstrURL)))
                    {
                        IEnumChannels *pEnum;
                        hr = pChannelMgr->EnumChannels(CHANENUM_ALLFOLDERS | CHANENUM_PATH, bstrURL, &pEnum);
                        if (SUCCEEDED(hr))
                        {
                            CHANNELENUMINFO info;
                            while (S_OK == pEnum->Next(1, &info, NULL))
                            {
                                hr = pChannelMgr->DeleteChannelShortcut(info.pszPath);
                                ASSERT(SUCCEEDED(hr));
                                CoTaskMemFree(info.pszPath);
                            }
                            pEnum->Release();
                        }
                        SysFreeString(bstrURL);
                    }
                    pChannelMgr->Release();
                }
            }    
        }
    }
    reg.SetKey(NULL);
    return S_OK;
}

//
// IsScheduleGroupReserved
//
HRESULT IsScheduleGroupReserved(LPCWSTR wzName, SUBSCRIPTIONSCHEDULE *pSched)
{
    HRESULT hr = S_OK;
    if (!StrCmpIW(wzName, c_szScheduleAuto))
        *pSched = SUBSSCHED_AUTO;
    else if (!StrCmpIW(wzName, c_szScheduleDaily))
        *pSched = SUBSSCHED_DAILY;
    else if (!StrCmpIW(wzName, c_szScheduleWeekly))
        *pSched = SUBSSCHED_WEEKLY;
    else if (!StrCmpIW(wzName, c_szScheduleManual))
        *pSched = SUBSSCHED_MANUAL;
    else
    {
        *pSched = SUBSSCHED_CUSTOM;
        hr = E_FAIL;
    }
    return hr;
}

//
// FindScheduleGroupFromName
//
HRESULT FindScheduleGroupFromName(LPCWSTR wzName, PNOTIFICATIONCOOKIE pCookie)
{
    // FEATURE: Need to worry about localized names.
    HRESULT hrRet = E_FAIL;
    HRESULT hr;
    INotificationMgr *pNotMgr = NULL;
    hr = CoCreateInstance(CLSID_StdNotificationMgr, NULL, CLSCTX_INPROC_SERVER, IID_INotificationMgr, (void**)&pNotMgr);
    if (SUCCEEDED(hr))
    {
        // what flags?
        IEnumScheduleGroup *pEnumScheduleGroup = NULL;
        hr = pNotMgr->GetEnumScheduleGroup(0, &pEnumScheduleGroup);
        if (SUCCEEDED(hr))
        {
            // Iterate through schedule groups
            for (;;)
            {
                IScheduleGroup *pScheduleGroup = NULL;
                ULONG uFetched;
                hr = pEnumScheduleGroup->Next(1, &pScheduleGroup, &uFetched);
                if (SUCCEEDED(hr) && (1 == uFetched))
                {
                    GROUPINFO info = { 0 };
                    hr = pScheduleGroup->GetAttributes(NULL, NULL, pCookie, &info, NULL, NULL);
                    if (SUCCEEDED(hr))
                    {
                        ASSERT(info.cbSize == SIZEOF(GROUPINFO));
                        ASSERT(info.pwzGroupname != NULL);
                        if (!StrCmpW(info.pwzGroupname, wzName))
                        {
                            // found it
                            hrRet = S_OK;
                            SAFEDELETE(info.pwzGroupname);
                            break;
                        }
                        SAFEDELETE(info.pwzGroupname);
                    }
                    pScheduleGroup->Release();
                }
                else
                {
                    break;
                }
            }
            pEnumScheduleGroup->Release();
        }
        pNotMgr->Release();
    }
    return hrRet;
}

//
// ProcessAddSubscriptions
//
HRESULT ProcessAddSubscriptions(HKEY hkey)
{
    // Enumerate the subscription keys in the AddSubscriptions key
    HRESULT hr;
    CRegKey reg;
    reg.SetKey(hkey);
    TCHAR szSubscription[MAX_PATH];
    while (S_OK == reg.Next(szSubscription))
    {
        // Create the subscription
        // What if there is one already?
        CRegKey regSubscription;
        regSubscription.OpenForRead(hkey, szSubscription);
        BSTR bstrURL, bstrTitle, bstrGroup, bstrUsername, bstrPassword;
        DWORD dwSubType;
        DWORD dwSynchronize = 0;
        hr = regSubscription.GetBSTRValue(c_szURL, &bstrURL);
        hr = regSubscription.GetBSTRValue(c_szTitle, &bstrTitle);
        hr = regSubscription.GetBSTRValue(c_szScheduleGroup, &bstrGroup);
        hr = regSubscription.GetBSTRValue(c_szUsername, &bstrUsername);
        hr = regSubscription.GetBSTRValue(c_szPassword, &bstrPassword);
        hr = regSubscription.GetValue(c_szSynchronize, &dwSynchronize);
        if (bstrURL && bstrTitle && bstrGroup && SUCCEEDED(regSubscription.GetValue(c_szSubscriptionType, &dwSubType)))
        {
            SUBSCRIPTIONINFO si = {0};
            si.cbSize = sizeof(SUBSCRIPTIONINFO);
            si.fUpdateFlags = SUBSINFO_SCHEDULE;
            if (bstrUsername && bstrPassword)
            {
                si.fUpdateFlags |= (SUBSINFO_USER | SUBSINFO_PASSWORD);
                si.bstrUserName = bstrUsername;
                si.bstrPassword = bstrPassword;
            }
            if (dwSubType == SUBSTYPE_CHANNEL || dwSubType == SUBSTYPE_DESKTOPCHANNEL)
            {
                si.fUpdateFlags |= SUBSINFO_CHANNELFLAGS;
                si.fChannelFlags = 0;   //  Notify only.
            }
            hr = IsScheduleGroupReserved(bstrGroup, &si.schedule);
            if (FAILED(hr))
            {
                hr = FindScheduleGroupFromName(bstrGroup, &si.customGroupCookie);
            }

            if (SUCCEEDED(hr))
            {
                ISubscriptionMgr2 *pSubMgr2 = NULL;
                hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr2, (void**)&pSubMgr2);
                if (SUCCEEDED(hr))
                {
                    hr = pSubMgr2->CreateSubscription(NULL, bstrURL, bstrTitle, CREATESUBS_NOUI,
                                                     (SUBSCRIPTIONTYPE)dwSubType, &si);
                    if (dwSynchronize)
                    {
                        BOOL bIsSubscribed;
                        SUBSCRIPTIONCOOKIE cookie;

                        if (SUCCEEDED(pSubMgr2->IsSubscribed(bstrURL, &bIsSubscribed)) && 
                            bIsSubscribed &&
                            SUCCEEDED(ReadCookieFromInetDB(bstrURL, &cookie)))
                        {
                            pSubMgr2->UpdateItems(SUBSMGRUPDATE_MINIMIZE, 1, &cookie);
                        }
                    }

                    pSubMgr2->Release();
                }
            }
        }
        SAFEFREEBSTR(bstrURL);
        SAFEFREEBSTR(bstrTitle);
        SAFEFREEBSTR(bstrGroup);
        SAFEFREEBSTR(bstrUsername);
        SAFEFREEBSTR(bstrPassword);
    }
    reg.SetKey(NULL);
    return S_OK;
}

//
// ProcessRemoveSubscriptions
//
HRESULT ProcessRemoveSubscriptions(HKEY hkey)
{
    // Enumerate the subscription keys in the RemoveSubscriptions key
    HRESULT hr;
    CRegKey reg;
    reg.SetKey(hkey);
    TCHAR szSubscription[MAX_PATH];
    while (S_OK == reg.Next(szSubscription))
    {
        // Find the URL to delete
        CRegKey regSubscription;
        regSubscription.OpenForRead(hkey, szSubscription);
        BSTR bstrURL;
        if (SUCCEEDED(regSubscription.GetBSTRValue(c_szURL, &bstrURL)))
        {
            ISubscriptionMgr *pSubMgr = NULL;
            hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr, (void**)&pSubMgr);
            if (SUCCEEDED(hr))
            {
                hr = pSubMgr->DeleteSubscription(bstrURL, NULL);
                pSubMgr->Release();
            }
            SysFreeString(bstrURL);
        }
    }
    reg.SetKey(NULL);
    return S_OK;
}

//
// PRIVATE VERSION HANDLING CODE - REVIEW THIS CODE SHOULD HAVE BEEN STOLEN 
// FROM SETUP
//
struct MYVERSION
{
    DWORD dw1;  // most sig version number
    DWORD dw2;
    DWORD dw3;
    DWORD dw4;  // least sig version number
};

int CompareDW(DWORD dw1, DWORD dw2)
{
    if (dw1 > dw2)
        return 1;
    if (dw1 < dw2)
        return -1;

    return 0;
}

int CompareVersion(MYVERSION * pv1, MYVERSION * pv2)
{
    int rv;

    rv = CompareDW(pv1->dw1, pv2->dw1);

    if (rv == 0)
    {
        rv = CompareDW(pv1->dw2, pv2->dw2);

        if (rv == 0)
        {
            rv = CompareDW(pv1->dw3, pv2->dw3);

            if (rv == 0)
            {
                rv = CompareDW(pv1->dw4, pv2->dw4);
            }
        }
    }

    return rv;
}

//
// Returns TRUE if an INT was parsed and *pwsz is NOT NULL
// if a . was found
//
BOOL GetDWORDFromStringAndAdvancePtr(DWORD *pdw, LPWSTR *pwsz)
{
    if (!StrToIntExW(*pwsz, 0, (int *)pdw))
        return FALSE;

    *pwsz = StrChrW(*pwsz, L'.');

    if (*pwsz)
        *pwsz = *pwsz +1;

    return TRUE;
}

BOOL GetVersionFromString(MYVERSION *pver, LPWSTR pwsz)
{
    BOOL rv;

    rv = GetDWORDFromStringAndAdvancePtr(&pver->dw1, &pwsz);
    if (!rv || pwsz == NULL)
        return FALSE;

    rv = GetDWORDFromStringAndAdvancePtr(&pver->dw2, &pwsz);
    if (!rv || pwsz == NULL)
        return FALSE;

    rv = GetDWORDFromStringAndAdvancePtr(&pver->dw3, &pwsz);
    if (!rv || pwsz == NULL)
        return FALSE;

    rv = GetDWORDFromStringAndAdvancePtr(&pver->dw4, &pwsz);
    if (!rv)
        return FALSE;

    return TRUE;
}

//
// ProcessRemoveAllChannels
//
HRESULT ProcessRemoveAllChannels(HKEY hkey)
{
    HRESULT hr;
    HINSTANCE hAdvPack = NULL;
    DELNODE pfDELNODE = NULL;
    IChannelMgrPriv *pChannelMgrPriv = NULL;
    CRegKey regAdd;
    regAdd.SetKey(hkey);
    TCHAR szChannelFolder[MAX_PATH];

    hr = CoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER, IID_IChannelMgrPriv, (void**)&pChannelMgrPriv);
    if (FAILED(hr))
    {
        goto Exit;
    }

    if ((hAdvPack = LoadLibrary(TEXT("advpack.dll"))) != NULL) 
    {
        pfDELNODE = (DELNODE)GetProcAddress( hAdvPack, "DelNode");
        if (!pfDELNODE) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // Loop Through Channel Folders to delete
    while (S_OK == regAdd.Next(szChannelFolder))
    {
        DWORD dwSoftware = 0, dwChannelGuide = 0;
        CRegKey regChannelFolder;
 
        CHAR szChannelPath[MAX_PATH];
        TCHAR szChannelPathT[MAX_PATH];
        TCHAR szFavsT[MAX_PATH]; //Retrieve Unicode data from registry

        BSTR bstrOldIEVersion = NULL;
        BOOL bVersion = TRUE;
        regChannelFolder.OpenForRead(hkey, szChannelFolder);
        
        // Check whether old IE version is correct.
        hr = regChannelFolder.GetBSTRValue(c_szOldIEVersion, &bstrOldIEVersion);
        if (SUCCEEDED(hr) && bstrOldIEVersion)
        {
            CRegKey regKeyIESetup;
            hr = regKeyIESetup.OpenForRead(HKEY_LOCAL_MACHINE, c_szRegKeyIESetup);
    
            if (SUCCEEDED(hr))
            {
                BSTR bstrRealOldIEVersion = NULL;
                hr = regKeyIESetup.GetBSTRValue(c_szOldIEVersion, &bstrRealOldIEVersion);
                if (SUCCEEDED(hr) && bstrRealOldIEVersion)
                {
                    MYVERSION verOldIEVersion, verRealOldIEVersion;

                    if (GetVersionFromString(&verOldIEVersion,     bstrOldIEVersion) &&
                        GetVersionFromString(&verRealOldIEVersion, bstrRealOldIEVersion))
                    {
                        //
                        // If the old version of IE that was on this machine (verRealOldIEVersion)
                        // is infact NEWER than the old version number in the CABs that we want to 
                        // delete (verOldIEVersion) then dont blow away old channel folder.
                        // Otherwise default to blow away channels.
                        //
                        if (CompareVersion(&verRealOldIEVersion, &verOldIEVersion) > 0)
                        {
                            bVersion = FALSE;
                        }
                    }

                    SAFEFREEBSTR(bstrRealOldIEVersion);
                }
            }
            SAFEFREEBSTR(bstrOldIEVersion);
        }

        if (!bVersion)
        {
            continue;
        }
        
        hr = regChannelFolder.GetValue(c_szChannelGuide, &dwChannelGuide);
        if (FAILED(hr) || (SUCCEEDED(hr) && !dwChannelGuide))
        {
            if (SUCCEEDED(pChannelMgrPriv->GetChannelFolderPath(szChannelPath, MAX_PATH, IChannelMgrPriv::CF_CHANNEL)))
            {
                // Retrieve Favorites Path from registry
                if (SUCCEEDED(Channel_GetBasePath((LPTSTR)szFavsT, ARRAYSIZE(szFavsT))))
                {   
                    // Convert from ANSI
                    SHAnsiToTChar(szChannelPath, szChannelPathT, ARRAYSIZE(szChannelPathT));
                    // If channel folder doesn't exist, then szChannelPath will contain the Favorites path.
                    // Don't delete the entries.
                    if (StrCmpI(szFavsT, szChannelPathT))
                       pfDELNODE(szChannelPath, ADN_DONT_DEL_DIR);
                }
            }
        }

        hr = regChannelFolder.GetValue(c_szSoftware, &dwSoftware);
        if (FAILED(hr) || (SUCCEEDED(hr) && !dwSoftware))
        {
            if (SUCCEEDED(pChannelMgrPriv->GetChannelFolderPath(szChannelPath, MAX_PATH, IChannelMgrPriv::CF_SOFTWAREUPDATE)))
            {
                pfDELNODE(szChannelPath, ADN_DONT_DEL_DIR);
            }
        }

        hr = S_OK;                        
    }
    regAdd.SetKey(NULL);

Exit:
    SAFERELEASE(pChannelMgrPriv);
    
    if (hAdvPack) {
        FreeLibrary(hAdvPack);
    }

    return hr;
}

//
// ProcessAddScheduleGroups
//
HRESULT ProcessAddScheduleGroups(HKEY hkey)
{
    // Enumerate the schedule group keys in the AddScheduleGroups key
    HRESULT hr;
    CRegKey reg;
    reg.SetKey(hkey);
    TCHAR szScheduleGroup[MAX_PATH];
    while (S_OK == reg.Next(szScheduleGroup))
    {
        // Read the Title and the Earliest, Latest, and Interval times
        // Currently times must be in minutes.
        // FEATURE: Currently we don't look for StartDate or EndDate.
        CRegKey regScheduleGroup;
        regScheduleGroup.OpenForRead(hkey, szScheduleGroup);
        BSTR bstrTitle;
        DWORD dwET, dwIT, dwLT;
        hr = regScheduleGroup.GetBSTRValue(c_szTitle, &bstrTitle);
        if (SUCCEEDED(hr)
            && SUCCEEDED(regScheduleGroup.GetValue(c_szEarliestTime, &dwET))
            && SUCCEEDED(regScheduleGroup.GetValue(c_szIntervalTime, &dwIT))
            && SUCCEEDED(regScheduleGroup.GetValue(c_szLatestTime, &dwLT)))
        {
            INotificationMgr *pNotMgr = NULL;
            hr = CoCreateInstance(CLSID_StdNotificationMgr, NULL, CLSCTX_INPROC_SERVER, IID_INotificationMgr, (void**)&pNotMgr);
            if (SUCCEEDED(hr))
            {
                // Create the schedule group
                IScheduleGroup *pScheduleGroup = NULL;
                NOTIFICATIONCOOKIE cookie;
                hr = pNotMgr->CreateScheduleGroup(0, &pScheduleGroup, &cookie, 0);
                if (SUCCEEDED(hr))
                {
                    TASK_TRIGGER tt;
                    GROUPINFO gi = { 0 };
                    SYSTEMTIME st;
                    GetLocalTime(&st);
                    tt.cbTriggerSize = sizeof(tt);
                    if (SUCCEEDED(ScheduleToTaskTrigger(&tt, &st, NULL, (long)dwIT, (long)dwET, (long)dwLT)))
                    {
                        gi.cbSize = sizeof(GROUPINFO);
                        gi.pwzGroupname = bstrTitle;
                    
                        hr = pScheduleGroup->SetAttributes(&tt, NULL, &cookie, &gi, 0);
                    }
                    pScheduleGroup->Release();
                }
                pNotMgr->Release();
            }
        }
        SAFEFREEBSTR(bstrTitle);
    }
    reg.SetKey(NULL);
    return S_OK;
}

//
// ProcessRemoveScheduleGroups
//
HRESULT ProcessRemoveScheduleGroups(HKEY hkey)
{
    // Enumerate the schedule group keys in the RemoveScheduleGroups key
    HRESULT hr;
    CRegKey reg;
    reg.SetKey(hkey);
    TCHAR szScheduleGroup[MAX_PATH];
    while (S_OK == reg.Next(szScheduleGroup))
    {
        // Find the title to delete
        CRegKey regScheduleGroup;
        regScheduleGroup.OpenForRead(hkey, szScheduleGroup);
        BSTR bstrTitle;
        if (SUCCEEDED(regScheduleGroup.GetBSTRValue(c_szTitle, &bstrTitle)))
        {
            GUID groupCookie;
            if (SUCCEEDED(FindScheduleGroupFromName(bstrTitle, &groupCookie)))
            {
                INotificationMgr *pNotMgr = NULL;
                hr = CoCreateInstance(CLSID_StdNotificationMgr, NULL, CLSCTX_INPROC_SERVER, IID_INotificationMgr, (void**)&pNotMgr);
                if (SUCCEEDED(hr))
                {
                    hr = pNotMgr->RevokeScheduleGroup(&groupCookie, NULL, 0);
                    pNotMgr->Release();
                }
            }
            SysFreeString(bstrTitle);
        }
    }
    reg.SetKey(NULL);
    return S_OK;
}

//
// ProcessAddDesktopComponents
//
HRESULT ProcessAddDesktopComponents(HKEY hkey)
{
    return S_OK;
}

//
// ProcessRemoveDesktopComponents
//
HRESULT ProcessRemoveDesktopComponents(HKEY hkey)
{
    // Enumerate the component keys in the ProcessRemoveDesktopComponents key
    // HRESULT hr;
    CRegKey reg;
    reg.SetKey(hkey);
    TCHAR szComponent[MAX_PATH];
    while (S_OK == reg.Next(szComponent))
    {
        // Find the URL to delete
        CRegKey regComponent;
        regComponent.OpenForRead(hkey, szComponent);
        BSTR bstrURL;
        if (SUCCEEDED(regComponent.GetBSTRValue(c_szURL, &bstrURL)))
        {
            SysFreeString(bstrURL);
        }
    }
    reg.SetKey(NULL);
    return S_OK;
}


//
// NoChannelUI processing.
//

#define SHELLFOLDERS \
   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")


typedef enum _tagXMLDOCTYPE {
    DOC_CHANNEL,
    DOC_SOFTWAREUPDATE
} XMLDOCTYPE;

//
// Get the path to the favorites directory.
//
HRESULT Channel_GetBasePath(LPTSTR pszPath, int cch)
{
    ASSERT(pszPath || 0 == cch);

    HRESULT hr = E_FAIL;

    HKEY hKey;
    DWORD dwLen = cch;

    if (RegOpenKey(HKEY_CURRENT_USER, SHELLFOLDERS, &hKey) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hKey, TEXT("Favorites"), NULL, NULL,
                            (LPBYTE)pszPath, &dwLen) == ERROR_SUCCESS)
        {
            hr = S_OK;
        }
        RegCloseKey(hKey);
    }
    
    return hr;
}

HRESULT Channel_GetFolder(LPTSTR pszPath, XMLDOCTYPE xdt )
{
    TCHAR   szFavs[MAX_PATH];
    TCHAR   szChannel[MAX_PATH];
    HRESULT hr = E_FAIL;

    if (SUCCEEDED(Channel_GetBasePath(szFavs, ARRAYSIZE(szFavs))))
    {
        //
        // Get the potentially localized name of the Channel folder from
        // tack this on the Favorites path 
        //
        MLLoadString(
                   ((xdt == DOC_CHANNEL)? IDS_CHANNEL_FOLDER : IDS_SOFTWAREUPDATE_FOLDER),
                   szChannel, MAX_PATH);
        PathCombine(pszPath, szFavs, szChannel);

        hr = S_OK;
    }
    return hr;
}

//
// Set/Clear the "hidden" attribute of a channel directory.
//

void ShowChannelDirectory(BOOL fShow, XMLDOCTYPE xdt)
{
    TCHAR szPath[MAX_PATH];
    DWORD dwAttributes;

    if (SUCCEEDED(Channel_GetFolder(szPath, xdt)))
    {
        dwAttributes = GetFileAttributes(szPath);
        
        if (0xffffffff != dwAttributes)
        {
            if (fShow && (dwAttributes & FILE_ATTRIBUTE_HIDDEN))
            {
                SetFileAttributes(szPath, dwAttributes & ~FILE_ATTRIBUTE_HIDDEN);
            }
            else if (!fShow && !(dwAttributes & FILE_ATTRIBUTE_HIDDEN))
            {
                SetFileAttributes(szPath, dwAttributes | FILE_ATTRIBUTE_HIDDEN);
            }
        }
    }

    return;
}

//
// Hide or show channel directories
//

void ShowChannelDirectories(BOOL fShow)
{
    ShowChannelDirectory(fShow, DOC_CHANNEL);
    ShowChannelDirectory(fShow, DOC_SOFTWAREUPDATE);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\cdfagent.cpp ===
#include "private.h"
#include "subsmgrp.h"
#include "downld.h"
#include "chanmgr.h"
#include "chanmgrp.h"
#include "helper.h"
#include "shguidp.h"    // IID_IChannelMgrPriv

#undef TF_THISMODULE
#define TF_THISMODULE   TF_CDFAGENT


const int MINUTES_PER_DAY = 24 * 60;


//==============================================================================
// Convert an XML OM to a TaskTrigger by looking for and converting <schedule>
//==============================================================================
// returns S_OK if succeeded. (S_FALSE if succeeded but TASK_TRIGGER was truncated).
// returns E_FAIL if no task trigger retrieved (returned *ptt is invalid TASK_TRIGGER)
//  You Must fill in ptt->cbTriggerSize!!!
// User can pass in Schedule element itself, or any parent element, in pRootEle
HRESULT XMLScheduleElementToTaskTrigger(IXMLElement *pRootEle, TASK_TRIGGER *ptt)
{
    HRESULT hr = E_FAIL;

    if (!pRootEle || !ptt)
        return E_INVALIDARG;

    ASSERT(ptt->cbTriggerSize == sizeof(TASK_TRIGGER));

    CExtractSchedule *pSched = new CExtractSchedule(pRootEle, NULL);

    if (pSched)
    {
        if (SUCCEEDED(pSched->Run()))
        {
            hr = pSched->GetTaskTrigger(ptt);
        }

        delete pSched;
    }

    return hr;
}

// CExtractSchedule doesn't get used during channel update
//  It's just used to traverse the OM and find the first Schedule tag, to
//   parse out the schedule info
CExtractSchedule::CExtractSchedule(IXMLElement *pEle, CExtractSchedule *pExtractRoot) :
        CProcessElement(NULL, NULL, pEle)
{
    m_pExtractRoot = pExtractRoot;
    if (!pExtractRoot)
        m_pExtractRoot = this;
}

HRESULT CExtractSchedule::Run()
{
    // Allow user to pass in Schedule element itself, or Root element
    BSTR bstrItem=NULL;
    HRESULT hr;

    m_pElement->get_tagName(&bstrItem);

    if (bstrItem && *bstrItem && !StrCmpIW(bstrItem, L"Schedule"))
    {
        hr = ProcessItemInEnum(bstrItem, m_pElement);
    }
    else
    {
        hr = CProcessElement::Run();
    }

    SysFreeString(bstrItem);
    return hr;
}

HRESULT CExtractSchedule::ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem)
{
    if (!StrCmpIW(pwszTagName, L"Schedule"))
    {
        CProcessSchedule *pPS = new CProcessSchedule(this, NULL, pItem);
        if (pPS)
        {
            pPS->Run();

            if (pPS->m_tt.cbTriggerSize)
            {
                ASSERT(pPS->m_tt.cbTriggerSize == sizeof(m_tt));
                m_pExtractRoot->m_tt = pPS->m_tt;
            }

            delete pPS;
        }
        return E_ABORT; // abort our enumerations
    }
    else if (!StrCmpIW(pwszTagName, L"Channel"))
    {
        return DoChild(new CExtractSchedule(pItem, m_pExtractRoot));
    }

    return S_OK;    // ignore other tags
}

HRESULT CExtractSchedule::GetTaskTrigger(TASK_TRIGGER *ptt)
{
    if ((0 == m_tt.cbTriggerSize) ||            // No task trigger
        (0 == m_tt.wBeginYear))                 // Invalid task trigger
    {
        return E_FAIL;
    }

    if (m_tt.cbTriggerSize <= ptt->cbTriggerSize)
    {
        *ptt = m_tt;
        return S_OK;
    }

    WORD cbTriggerSize = ptt->cbTriggerSize;

    CopyMemory(ptt, &m_tt, cbTriggerSize);
    ptt->cbTriggerSize = cbTriggerSize;

    return S_FALSE;
}

//==============================================================================
// XML OM Helper functions
//==============================================================================
HRESULT GetXMLAttribute(IXMLElement *pItem, LPCWSTR pwszAttribute, VARIANT *pvRet)
{
    BSTR bstrName=NULL;
    HRESULT hr=E_FAIL;

    pvRet->vt = VT_EMPTY;
    bstrName = SysAllocString(pwszAttribute);
    if (bstrName && SUCCEEDED(pItem->getAttribute(bstrName, pvRet)))
    {
        hr = S_OK;
    }
    SysFreeString(bstrName);
    return hr;
}

HRESULT GetXMLStringAttribute(IXMLElement *pItem, LPCWSTR pwszAttribute, BSTR *pbstrRet)
{
    VARIANT var;
    BSTR bstrName=NULL;
    HRESULT hr=E_FAIL;

    *pbstrRet = NULL;

    var.vt = VT_EMPTY;
    bstrName = SysAllocString(pwszAttribute);
    if (bstrName && SUCCEEDED(pItem->getAttribute(bstrName, &var)))
    {
        if (var.vt == VT_BSTR && var.bstrVal != NULL)
        {
            *pbstrRet = var.bstrVal;

            hr = S_OK;
        }
    }
    SysFreeString(bstrName);
    if (FAILED(hr) && var.vt != VT_EMPTY)
        VariantClear(&var);

    return hr;
}

DWORD GetXMLDwordAttribute(IXMLElement *pItem, LPCWSTR pwszAttribute, DWORD dwDefault)
{
    VARIANT var;

    if (SUCCEEDED(GetXMLAttribute(pItem, pwszAttribute, &var)))
    {
        if (var.vt == VT_I4)
            return var.lVal;

        if (var.vt == VT_I2)
            return var.iVal;

        if (var.vt == VT_BSTR)
        {
            LPCWSTR pwsz = var.bstrVal;
            DWORD   dwRet;

            if (!StrToIntExW(pwsz, 0, (int *)&dwRet))
                dwRet = dwDefault;

            SysFreeString(var.bstrVal);
            return dwRet;
        }

        VariantClear(&var);
    }

    return dwDefault;
}

// If failure return code, *pfRet wasn't changed
HRESULT GetXMLBoolAttribute(IXMLElement *pItem, LPCWSTR pwszAttribute, BOOL *pfRet)
{
    VARIANT var;
    HRESULT hr=E_FAIL;

    if (SUCCEEDED(GetXMLAttribute(pItem, pwszAttribute, &var)))
    {
        if (var.vt == VT_BOOL)
        {
            *pfRet = (var.boolVal == VARIANT_TRUE);
            hr = S_OK;
        }
        else if (var.vt == VT_BSTR)
        {
            if (!StrCmpIW(var.bstrVal, L"YES") ||
                !StrCmpIW(var.bstrVal, L"\"YES\""))
            {
                *pfRet = TRUE;
                hr = S_OK;
            }
            else if (!StrCmpIW(var.bstrVal, L"NO") ||
                     !StrCmpIW(var.bstrVal, L"\"NO\""))
            {
                *pfRet = FALSE;
                hr = S_OK;
            }
        }
        else
            hr = E_FAIL;

        VariantClear(&var);
    }

    return hr;
}

HRESULT GetXMLTimeAttributes(IXMLElement *pItem, CDF_TIME *pTime)
{
    pTime->wReserved = 0;

    pTime->wDay = (WORD)  GetXMLDwordAttribute(pItem, L"DAY", 0);
    pTime->wHour = (WORD) GetXMLDwordAttribute(pItem, L"HOUR", 0);
    pTime->wMin = (WORD)  GetXMLDwordAttribute(pItem, L"MIN", 0);

    pTime->dwConvertedMinutes = (24 * 60 * pTime->wDay) +
                                (     60 * pTime->wHour) +
                                (          pTime->wMin);

    return S_OK;
}

inline BOOL IsNumber(WCHAR x) { return (x >= L'0' && x <= L'9'); }

HRESULT GetXMLTimeZoneAttribute(IXMLElement *pItem, LPCWSTR pwszAttribute, int *piRet)
{
    BSTR    bstrVal;
    HRESULT hrRet = E_FAIL;

    ASSERT(pItem && piRet);

    if (SUCCEEDED(GetXMLStringAttribute(pItem, pwszAttribute, &bstrVal)))
    {
        if(bstrVal && bstrVal[0] &&
            IsNumber(bstrVal[1]) && IsNumber(bstrVal[2]) &&
            IsNumber(bstrVal[3]) && IsNumber(bstrVal[4]))
        {
            *piRet  =   1000*(bstrVal[1] - L'0') +
                         100*(bstrVal[2] - L'0') +
                          10*(bstrVal[3] - L'0') +
                              bstrVal[4] - L'0';

            hrRet = S_OK;
        }
        if(bstrVal[0] == L'-')
            *piRet *= -1;
    }

    SysFreeString(bstrVal);

    return hrRet;
}

//==============================================================================
// TEMP fn to convert ISO 1234:5678 to SYSTEMTIME
// ISODateToSystemTime returns false if there is a parse error
// true if there isn't
//==============================================================================
BOOL ValidateSystemTime(SYSTEMTIME *time)
{
    // IE6 27665. Some incompetent XML file writers provide slightly invalid dates, like 9-31-01. 
    // Everybody knows that September has 30 days. Anyway, we'll do some minimal fix-up here.
    switch (time->wMonth)
    {
    case 2: // February
        // Rule is, every four years is a leap year, except for centuries.
        if ((time->wYear % 4) || ((time->wYear % 100)==0))
        {
            if (time->wDay > 28)
            {
                time->wDay = 28;
            }
        } 
        else if (time->wDay > 29)
        {
            time->wDay = 29;
        }
        break;

    case 1: // January
    case 3: // March
    case 5: // May
    case 7: // July
    case 8: // August
    case 10: // October
    case 12: // December
        if (time->wDay>31)
        {
            time->wDay = 31;
        }
        break;

    default: // the other 4 months. These have 30 days, apparently.
        if (time->wDay>30)
        {
            time->wDay = 30;
        }
        break;
    }

    return TRUE;
}


// yyyy-mm-dd[Thh:mm[+zzzz]]
BOOL ISODateToSystemTime(LPCWSTR string, SYSTEMTIME *time, long *timezone)
{
    if (!string || (lstrlenW(string) < 10) || !time)
        return FALSE;

    ZeroMemory(time, sizeof(SYSTEMTIME));

    if (timezone)
        *timezone = 0;

    if (IsNumber(string[0]) &&
        IsNumber(string[1]) &&
        IsNumber(string[2]) &&
        IsNumber(string[3]) &&
       (string[4] != L'\0') &&
        IsNumber(string[5]) &&
        IsNumber(string[6]) &&
       (string[7] != L'\0') &&
        IsNumber(string[8]) &&
        IsNumber(string[9]))
    {
        time->wYear = 1000*(string[0] - L'0') +
                       100*(string[1] - L'0') +
                        10*(string[2] - L'0') +
                            string[3] - L'0';

        time->wMonth = 10*(string[5] - L'0') + string[6] - L'0';

        time->wDay = 10*(string[8] - L'0') + string[9] - L'0';
    }
    else
    {
        return FALSE;
    }

    if ((string[10]!= L'\0') &&
        IsNumber(string[11]) &&
        IsNumber(string[12]) &&
       (string[13] != L'\0') &&
        IsNumber(string[14]) &&
        IsNumber(string[15]))
    {
        time->wHour   = 10*(string[11] - L'0') + string[12] - L'0';
        time->wMinute = 10*(string[14] - L'0') + string[15] - L'0';

        if (timezone &&
            (string[16]!= L'\0') &&
            IsNumber(string[17]) &&
            IsNumber(string[18]) &&
            IsNumber(string[19]) &&
            IsNumber(string[20]))
        {
            *timezone  =    1000*(string[17] - L'0') +
                            100*(string[18] - L'0') +
                            10*(string[19] - L'0') +
                            string[20] - L'0';

            if(string[16] == L'-')
                *timezone = - *timezone;
        }
    }

    return ValidateSystemTime(time);
}


//==============================================================================
// CProcessElement class provides generic support for sync or async enumeration
//   of an XML OM
//==============================================================================
CProcessElement::CProcessElement(CProcessElementSink *pParent,
                                 CProcessRoot *pRoot,
                                 IXMLElement *pEle)
{
    ASSERT(m_pRunAgent == NULL && m_pCurChild == NULL && m_pCollection == NULL);
        
    m_pElement = pEle; pEle->AddRef();
    m_pRoot = pRoot;
    m_pParent = pParent;
}

CProcessElement::~CProcessElement()
{
    ASSERT(!m_pCurChild);

    CRunDeliveryAgent::SafeRelease(m_pRunAgent);

    SAFERELEASE(m_pCollection);
    SAFERELEASE(m_pElement);
    SAFERELEASE(m_pChildElement);
}

HRESULT CProcessElement::Pause(DWORD dwFlags)
{
    if (m_pCurChild)
        return m_pCurChild->Pause(dwFlags);

    ASSERT(m_pRunAgent);

    if (m_pRunAgent)
        return m_pRunAgent->AgentPause(dwFlags);

    return E_FAIL;
}

HRESULT CProcessElement::Resume(DWORD dwFlags)
{
    if (m_pCurChild)
        return m_pCurChild->Resume(dwFlags);

    if (m_pRunAgent)
        m_pRunAgent->AgentResume(dwFlags);
    else
        DoEnumeration();

    return S_OK;
}

HRESULT CProcessElement::Abort(DWORD dwFlags)
{
    if (m_pCurChild)
    {
        m_pCurChild->Abort(dwFlags);
        SAFEDELETE(m_pCurChild);
    }
    if (m_pRunAgent)
    {
        // Prevent reentrancy into OnAgentEnd
        m_pRunAgent->LeaveMeAlone();
        m_pRunAgent->AgentAbort(dwFlags);
        CRunDeliveryAgent::SafeRelease(m_pRunAgent);
    }

    return S_OK;
}


HRESULT CProcessElement::Run()
{
    ASSERT(!m_pCollection);
    ASSERT(m_lMax == 0);
//  ASSERT(m_fSentEnumerationComplete == FALSE);    // DoEnumeration may have sent this

    m_lIndex = 0;

    if (SUCCEEDED(m_pElement->get_children(&m_pCollection)) && m_pCollection)
    {
        m_pCollection->get_length(&m_lMax);
    }
    else
        m_lMax = 0;

    return DoEnumeration(); // Will call OnChildDone when appropriate
}

HRESULT CProcessElement::OnAgentEnd(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                               long lSizeDownloaded, HRESULT hrResult, LPCWSTR wszResult,
                               BOOL fSynchronous)
{
    // Our delivery agent is done. Continue enumeration
    ASSERT(!m_pCurChild);

    if (lSizeDownloaded > 0)
        m_pRoot->m_dwCurSizeKB += (ULONG) lSizeDownloaded;

    TraceMsg(TF_THISMODULE, "ChannelAgent up to %dkb of %dkb", m_pRoot->m_dwCurSizeKB, m_pRoot->m_pChannelAgent->m_dwMaxSizeKB);

    if ((hrResult == INET_E_AGENT_MAX_SIZE_EXCEEDED) ||
        (hrResult == INET_E_AGENT_CACHE_SIZE_EXCEEDED))
    {
        DBG("CProcessElement got max size or cache size exceeded; not running any more delivery agents");

        m_pRoot->m_fMaxSizeExceeded = TRUE;
        m_pRoot->m_pChannelAgent->SetEndStatus(hrResult);
    }

    CRunDeliveryAgent::SafeRelease(m_pRunAgent);

    if (fSynchronous)
    {
        // we are still in our DoDeliveryAgent call. Let it return out through there.
        return S_OK;
    }

    // Continue enumeration, or start enumeration if we haven't yet.
    if (m_fStartedEnumeration)
        DoEnumeration();
    else
        Run();

    return S_OK;
}

HRESULT CProcessElement::DoEnumeration()
{
    IDispatch   *pDisp;
    IXMLElement *pItem;
    BSTR        bstrTagName;
    VARIANT     vIndex, vEmpty;
    HRESULT     hr = S_OK;
    BOOL        fStarted = FALSE;

    m_fStartedEnumeration = TRUE;

    ASSERT(m_pCollection || !m_lMax);

    if (m_pRoot && m_pRoot->IsPaused())
    {
        DBG("CProcessElement::DoEnumeration returning E_PENDING, we're paused");
        return E_PENDING;
    }

    vEmpty.vt = VT_EMPTY;

    for (; (m_lIndex < m_lMax) && !fStarted && (hr != E_ABORT); m_lIndex++)
    {
        vIndex.vt = VT_UI4;
        vIndex.lVal = m_lIndex;

        if (SUCCEEDED(m_pCollection->item(vIndex, vEmpty, &pDisp)))
        {
            if (SUCCEEDED(pDisp->QueryInterface(IID_IXMLElement, (void **)&pItem)))
            {
                if (SUCCEEDED(pItem->get_tagName(&bstrTagName)) && bstrTagName)
                {
                    SAFERELEASE(m_pChildElement);
                    m_pChildElement=pItem;
                    m_pChildElement->AddRef();

                    hr = ProcessItemInEnum(bstrTagName, pItem);
                    SysFreeString(bstrTagName);
                    if (hr == E_PENDING)
                        fStarted = TRUE;
                }
                pItem->Release();
            }
            pDisp->Release();
        }
    }

    // Tell this instance we're done with enumeration, unless we already have
    if (!fStarted && !m_fSentEnumerationComplete)
    {
        m_fSentEnumerationComplete = TRUE;
        hr = EnumerationComplete();     // WARNING this eats E_ABORT
        if (hr == E_PENDING)
            fStarted = TRUE;
    }

    // Notify our parent if we're done with our enumeration,
    if (!fStarted)
    {
        if (m_pParent)  // Check for CExtractSchedule
            m_pParent->OnChildDone(this, hr); // This may delete us
    }

    if (hr == E_ABORT)
        return E_ABORT;

    return (fStarted) ? E_PENDING : S_OK;
}

HRESULT CProcessElement::OnChildDone(CProcessElement *pChild, HRESULT hr)
{
    ASSERT(pChild && (!m_pCurChild || (pChild == m_pCurChild)));

    if (m_pCurChild)
    {
        // A child returned from async operation.
        SAFEDELETE(m_pCurChild);

        // Continue enumeration. This will call our parent's ChildDone if it
        //  finishes, so it may delete us.
        DoEnumeration();
    }
    else
    {
        // Our child has finished synchronously. Ignore (DoChild() will take care of it).
    }

    return S_OK;
}

HRESULT CProcessElement::DoChild(CProcessElement *pChild)
{
    HRESULT hr;

    ASSERT(m_pCurChild == NULL);

    if (!pChild)
        return E_POINTER;   // FEATURE should call parent's OnChildDone here

    hr = pChild->Run();

    if (hr == E_PENDING)
    {
        // Returned async. Will call back OnChildDone.
        m_pCurChild = pChild;
        return E_PENDING;
    }

    // Synchronously returned. Clean up.
    delete pChild;

    return hr;
}

// E_PENDING if async operation started
HRESULT CProcessElement::DoDeliveryAgent(ISubscriptionItem *pItem, REFCLSID rclsid, LPCWSTR pwszURL)
{
    ASSERT(pItem);

    HRESULT hr=E_FAIL;

    if (m_pRoot->m_fMaxSizeExceeded)
    {
//      DBG("CProcessElement::RunDeliveryAgent failing; exceeded max size.");
        return E_FAIL;
    }

    if (m_pRunAgent)
    {
        DBG_WARN("CProcessElement::DoDeliveryAgent already running!");
        return E_FAIL;
    }

    m_pRunAgent = new CChannelAgentHolder(m_pRoot->m_pChannelAgent, this);

    if (m_pRunAgent)
    {
        hr = m_pRunAgent->Init(this, pItem, rclsid);

        if (SUCCEEDED(hr))
            hr = m_pRunAgent->StartAgent();

        if (hr == E_PENDING)
        {
            m_pRoot->m_pChannelAgent->SendUpdateProgress(pwszURL, ++(m_pRoot->m_iTotalStarted), -1, m_pRoot->m_dwCurSizeKB);
        }
        else
            CRunDeliveryAgent::SafeRelease(m_pRunAgent);
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

HRESULT CProcessElement::DoSoftDist(IXMLElement *pItem)
{
HRESULT hr = S_OK;
ISubscriptionItem *pSubsItem;

    if (SUCCEEDED(m_pRoot->CreateStartItem(&pSubsItem)))
    {
        if (pSubsItem)
        {
            hr = DoDeliveryAgent(pSubsItem, CLSID_CDLAgent);
            pSubsItem->Release();
        }
    }
    return hr;
}

HRESULT CProcessElement::DoWebCrawl(IXMLElement *pItem, LPCWSTR pwszURL /* = NULL */)
{
    BSTR bstrURL=NULL, bstrTmp=NULL;
    HRESULT hr = S_OK;
    ISubscriptionItem *pSubsItem;
    DWORD   dwLevels=0, dwFlags;
    LPWSTR  pwszUrl2=NULL;
    BOOL    fOffline=FALSE;

    if (!pwszURL && SUCCEEDED(GetXMLStringAttribute(pItem, L"HREF", &bstrURL)) && bstrURL)
        pwszURL = bstrURL;

    if (pwszURL)
    {
        SYSTEMTIME  stLastMod;
        long        lTimezone;

        hr = CombineWithBaseUrl(pwszURL, &pwszUrl2);

        if (SUCCEEDED(hr) && pwszUrl2)
            pwszURL = pwszUrl2;     // Got a new URL

        hr = CUrlDownload::IsValidURL(pwszURL);

        if (SUCCEEDED(hr) &&
            SUCCEEDED(GetXMLStringAttribute(m_pElement, L"LastMod", &bstrTmp)) &&
            ISODateToSystemTime(bstrTmp, &stLastMod, &lTimezone))
        {
            // Check Last Modified time
            TCHAR   szThisUrl[INTERNET_MAX_URL_LENGTH];
            char    chBuf[MY_MAX_CACHE_ENTRY_INFO];
            DWORD   dwBufSize = sizeof(chBuf);
            LPINTERNET_CACHE_ENTRY_INFO lpInfo = (LPINTERNET_CACHE_ENTRY_INFO) chBuf;

            MyOleStrToStrN(szThisUrl, INTERNET_MAX_URL_LENGTH, pwszURL);
            hr = GetUrlInfoAndMakeSticky(NULL, szThisUrl, lpInfo, dwBufSize, 0);

            if (SUCCEEDED(hr))
            {
                FILETIME ft;

                if (SystemTimeToFileTime(&stLastMod, &ft))
                {
                    // APPCOMPAT: In an ideal world, all servers would support LastModifiedTime accurately.
                    // In our world, some do not support it and wininet returns a value of zero.
                    // Without maintaining checksums of the files, we have two options: always download
                    // the URL or never update it. Since it would be odd not to update it, we always do.
                    if ((lpInfo->LastModifiedTime.dwHighDateTime || lpInfo->LastModifiedTime.dwLowDateTime)
                        && (lpInfo->LastModifiedTime.dwHighDateTime >= ft.dwHighDateTime)
                        && ((lpInfo->LastModifiedTime.dwHighDateTime > ft.dwHighDateTime)
                         || (lpInfo->LastModifiedTime.dwLowDateTime >= ft.dwLowDateTime)))
                    {
                        // Skip it.
                        TraceMsg(TF_THISMODULE, "Running webcrawl OFFLINE due to Last Modified time URL=%ws", pwszURL);
                        fOffline = TRUE;
                    }
                }
            }

            hr = S_OK;
        }

        SAFEFREEBSTR(bstrTmp);

        if (SUCCEEDED(hr) && SUCCEEDED(m_pRoot->CreateStartItem(&pSubsItem)))
        {
            WriteOLESTR(pSubsItem, c_szPropURL, pwszURL);

            dwLevels = GetXMLDwordAttribute(pItem, L"LEVEL", 0);
            if (dwLevels && m_pRoot->IsChannelFlagSet(CHANNEL_AGENT_PRECACHE_SOME))
            {
                // Note: MaxChannelLevels is stored as N+1 because 0
                // means the restriction is disabled.
                DWORD dwMaxLevels = SHRestricted2W(REST_MaxChannelLevels, NULL, 0);
                if (!dwMaxLevels)
                    dwMaxLevels = MAX_CDF_CRAWL_LEVELS + 1;
                if (dwLevels >= dwMaxLevels)
                    dwLevels = dwMaxLevels - 1;
                WriteDWORD(pSubsItem, c_szPropCrawlLevels, dwLevels);
            }

            if (fOffline)
            {
                if (SUCCEEDED(ReadDWORD(pSubsItem, c_szPropCrawlFlags, &dwFlags)))
                {
                    dwFlags |= CWebCrawler::WEBCRAWL_PRIV_OFFLINE_MODE;
                    WriteDWORD(pSubsItem, c_szPropCrawlFlags, dwFlags);
                }
            }

            hr = DoDeliveryAgent(pSubsItem, CLSID_WebCrawlerAgent, pwszURL);
            
            SAFERELEASE(pSubsItem);
        }
    }

    if (bstrURL)
        SysFreeString(bstrURL);

    if (pwszUrl2)
        MemFree(pwszUrl2);

    return hr;
}

BOOL CProcessElement::ShouldDownloadLogo(IXMLElement *pLogo)
{
    return m_pRoot->IsChannelFlagSet(CHANNEL_AGENT_PRECACHE_SOME);
}

// If relative url, will combine with most recent base URL
// *ppwszRetUrl should be NULL & will be MemAlloced
HRESULT CProcessElement::CombineWithBaseUrl(LPCWSTR pwszUrl, LPWSTR *ppwszRetUrl)
{
    ASSERT(ppwszRetUrl && !*ppwszRetUrl && pwszUrl);

    // Optimization: if pwszURL is absolute, we don't need to do this expensive
    //  combine operation
//  if (*pwszUrl != L'/')   // BOGUS
//  {
//      *ppwszRetUrl = StrDupW(pwszUrl);
//      return S_FALSE;     // Succeeded; pwszUrl is already OK
//  }

    // Find appropriate Base URL to use
    LPCWSTR pwszBaseUrl = GetBaseUrl();

    WCHAR wszUrl[INTERNET_MAX_URL_LENGTH];
    DWORD dwLen = ARRAYSIZE(wszUrl);

    if (SUCCEEDED(UrlCombineW(pwszBaseUrl, pwszUrl, wszUrl, &dwLen, 0)))
    {
        *ppwszRetUrl = StrDupW(wszUrl);
        return (*ppwszRetUrl) ? S_OK : E_OUTOFMEMORY;
    }

    *ppwszRetUrl = NULL;

    return E_FAIL;  // Erg?
}



//==============================================================================
// CProcessElement derived classes, to handle specific CDF tags
//==============================================================================
// CProcessRoot doesn't behave like a normal CProcessElement class. It calls
//  CProcessChannel to process the *same element*
CProcessRoot::CProcessRoot(CChannelAgent *pParent, IXMLElement *pItem) : 
        CProcessElement(pParent, NULL, pItem)
{
    ASSERT(m_pDefaultStartItem == FALSE && m_pTracking == NULL && !m_dwCurSizeKB);

    m_pRoot = this;
    m_pChannelAgent = pParent; pParent->AddRef();
    m_iTotalStarted = 1;
}

CProcessRoot::~CProcessRoot()
{
    SAFEDELETE(m_pTracking);
    SAFERELEASE(m_pChannelAgent);
    SAFERELEASE(m_pDefaultStartItem);
}

// Should never get called. CProcessRoot is an odd duck.
HRESULT CProcessRoot::ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem)
{
    ASSERT(0);
    return E_NOTIMPL;
}

HRESULT CProcessRoot::CreateStartItem(ISubscriptionItem **ppItem)
{
    if (ppItem)
        *ppItem = NULL;

    if (!m_pDefaultStartItem)
    {
        DoCloneSubscriptionItem(m_pChannelAgent->GetStartItem(), NULL, &m_pDefaultStartItem);

        if (m_pDefaultStartItem)
        {
            DWORD   dwTemp;

            // Clear out properties we don't want
            const LPCWSTR pwszPropsToClear[] =
            {
                c_szPropCrawlLevels,
                c_szPropCrawlLocalDest,
                c_szPropCrawlActualSize,
                c_szPropCrawlMaxSize,
                c_szPropCrawlGroupID
            };

            VARIANT varEmpty[ARRAYSIZE(pwszPropsToClear)] = {0};

            ASSERT(ARRAYSIZE(pwszPropsToClear) == ARRAYSIZE(varEmpty));
            m_pDefaultStartItem->WriteProperties(
                ARRAYSIZE(pwszPropsToClear), pwszPropsToClear, varEmpty);

            // Add in properties we do want
            dwTemp = DELIVERY_AGENT_FLAG_NO_BROADCAST |
                     DELIVERY_AGENT_FLAG_NO_RESTRICTIONS;
            WriteDWORD(m_pDefaultStartItem, c_szPropAgentFlags, dwTemp);
            if (FAILED(ReadDWORD(m_pDefaultStartItem, c_szPropCrawlFlags, &dwTemp)))
            {
                WriteDWORD(m_pDefaultStartItem, c_szPropCrawlFlags,
                    WEBCRAWL_GET_IMAGES|WEBCRAWL_LINKS_ELSEWHERE);
            }

            WriteLONGLONG(m_pDefaultStartItem, c_szPropCrawlNewGroupID, m_pChannelAgent->m_llCacheGroupID);
        }
    }

    if (m_pDefaultStartItem && ppItem)
    {
        DoCloneSubscriptionItem(m_pDefaultStartItem, NULL, ppItem);

        if (*ppItem)
        {
            // Add in properties for our new clone
            if ((m_pChannelAgent->m_dwMaxSizeKB > 0) &&
                (m_dwCurSizeKB <= m_pChannelAgent->m_dwMaxSizeKB))

            {
                WriteDWORD(*ppItem, c_szPropCrawlMaxSize, 
                    (m_pChannelAgent->m_dwMaxSizeKB - m_dwCurSizeKB));
            }
        }
    }

    return (ppItem) ? (*ppItem) ? S_OK : E_FAIL :
                      (m_pDefaultStartItem) ? S_OK : E_FAIL;
}

HRESULT CProcessRoot::Run()
{
    if (FAILED(CreateStartItem(NULL)))
        return E_FAIL;

    return DoChild(new CProcessChannel(this, this, m_pElement));
}

HRESULT CProcessRoot::DoTrackingFromItem(IXMLElement *pItem, LPCWSTR pwszUrl, BOOL fForceLog)
{
    HRESULT hr = E_FAIL;

    // if m_pTracking is not created before this call, means no <LogTarget> tag was found or
    // global logging is turned off
    if (m_pTracking)
        hr = m_pTracking->ProcessTrackingInItem(pItem, pwszUrl, fForceLog);
        
    return hr;
}

HRESULT CProcessRoot::DoTrackingFromLog(IXMLElement *pItem)
{
    HRESULT hr = S_OK;

    if (!m_pTracking 
        && !SHRestricted2W(REST_NoChannelLogging, m_pChannelAgent->GetUrl(), 0)
        && !ReadRegDWORD(HKEY_CURRENT_USER, c_szRegKey, c_szNoChannelLogging))
    {
        m_pTracking = new CUrlTrackingCache(m_pChannelAgent->GetStartItem(), m_pChannelAgent->GetUrl());
    }
    
    if (!m_pTracking)
        return E_OUTOFMEMORY;

    hr = m_pTracking->ProcessTrackingInLog(pItem);

    // skip tracking if PostURL is not specified
    if (m_pTracking->get_PostURL() == NULL)
    {
        SAFEDELETE(m_pTracking);
    }

    return hr;
}

// Overload this since we never do enumeration. Call delivery agent if necessary,
//  call m_pParent->OnChildDone if necessary
HRESULT CProcessRoot::OnChildDone(CProcessElement *pChild, HRESULT hr)
{
    ASSERT(pChild && (!m_pCurChild || (pChild == m_pCurChild)));

    // Our processing is done. Now we decide if we'd like to call the post agent.
    BSTR bstrURL=NULL;
    ISubscriptionItem *pStartItem;

    hr = S_OK;

    SAFEDELETE(m_pCurChild);

    ASSERT(m_pDefaultStartItem);
    ReadBSTR(m_pDefaultStartItem, c_szTrackingPostURL, &bstrURL);

    if (bstrURL && *bstrURL)
    {
        TraceMsg(TF_THISMODULE, "ChannelAgent calling post agent posturl=%ws", bstrURL);
        if (SUCCEEDED(m_pRoot->CreateStartItem(&pStartItem)))
        {
            m_pRunAgent = new CChannelAgentHolder(m_pChannelAgent, this);

            if (m_pRunAgent)
            {
                hr = m_pRunAgent->Init(this, pStartItem, CLSID_PostAgent);
                if (SUCCEEDED(hr))
                    hr = m_pRunAgent->StartAgent();
                if (hr != E_PENDING)
                    CRunDeliveryAgent::SafeRelease(m_pRunAgent);
            }
            pStartItem->Release();
        }
    }

    SysFreeString(bstrURL);

    if (hr != E_PENDING)
        m_pParent->OnChildDone(this, hr); // This may delete us

    return hr;
}

// Our delivery agent (post agent) is done running. Tell CDF agent we're done.
HRESULT CProcessRoot::OnAgentEnd(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                               long lSizeDownloaded, HRESULT hrResult, LPCWSTR wszResult,
                               BOOL fSynchronous)
{
    if (!fSynchronous)
        m_pParent->OnChildDone(this, S_OK); // This may delete us

    return S_OK;
}

CProcessChannel::CProcessChannel(CProcessElementSink *pParent,
                                 CProcessRoot *pRoot,
                                 IXMLElement *pItem) :
        CProcessElement(pParent, pRoot, pItem)
{
    m_fglobalLog = FALSE;
}

CProcessChannel::~CProcessChannel()
{
    SAFEFREEBSTR(m_bstrBaseUrl);
}

HRESULT CProcessChannel::CheckPreCache()
{
    BOOL fPreCache;

    if (SUCCEEDED(GetXMLBoolAttribute(m_pElement, L"PreCache", &fPreCache)))
    {
        if (fPreCache)
            return S_OK;
        
        return S_FALSE;
    }

    return S_OK;
}

HRESULT CProcessChannel::Run()
{
    // Process Channel attributes, then any sub elements
    if (0 == m_lIndex)
    {
        m_lIndex ++;

        BSTR bstrURL=NULL;
        LPWSTR pwszUrl=NULL;
        HRESULT hr = S_OK;

        ASSERT(!m_bstrBaseUrl);

        // Get base URL if specified
        GetXMLStringAttribute(m_pElement, L"BASE", &m_bstrBaseUrl);

        if (SUCCEEDED(GetXMLStringAttribute(m_pElement, L"HREF", &bstrURL)) && bstrURL)
            CombineWithBaseUrl(bstrURL, &pwszUrl);

        if (pwszUrl && (m_pRoot==m_pParent))
        {
            // Use this as default "email url"
            WriteOLESTR(m_pRoot->m_pChannelAgent->GetStartItem(), c_szPropEmailURL, pwszUrl);
        }

        if (pwszUrl && m_pRoot->IsChannelFlagSet(CHANNEL_AGENT_PRECACHE_SOME) &&
            (S_OK == CheckPreCache()))
        {
            if (E_PENDING == DoWebCrawl(m_pElement, pwszUrl))
            {
                m_fDownloadedHREF = TRUE;
                hr = E_PENDING;
            }

        }

        // If no URL for this <Channel> log, check if global log exists       
        if (SUCCEEDED(m_pRoot->DoTrackingFromItem(m_pElement, pwszUrl, m_pParent->IsGlobalLog())))
        {
            SetGlobalLogFlag(TRUE);
        }

        SAFELOCALFREE(pwszUrl);
        SAFEFREEBSTR(bstrURL);

        if (hr == E_PENDING)
            return hr;
    }

    // We've processed attributes. Run sub-elements.

    return CProcessElement::Run();
}

HRESULT CProcessChannel::ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem)
{
    HRESULT hr;
    BSTR    bstrTemp;

    if (!StrCmpIW(pwszTagName, L"Logo"))
    {
        if (ShouldDownloadLogo(pItem))
            return DoWebCrawl(pItem);
        else
            return S_OK;
    }
    else if (!StrCmpIW(pwszTagName, L"Item"))
    {
        return DoChild(new CProcessItem(this, m_pRoot, pItem));
    }
    else if (!StrCmpIW(pwszTagName, L"Channel"))
    {
        return DoChild(new CProcessChannel(this, m_pRoot, pItem));
    }
/*
    else if (!StrCmpIW(pwszTagName, L"Login"))
    {
        // No sub-elements to process. Do it here.
        return m_pRoot->ProcessLogin(pItem);
    }
*/
    else if (!StrCmpIW(pwszTagName, L"LOGTARGET"))
    {
        return m_pRoot->DoTrackingFromLog(pItem);
    }
    else if (!StrCmpIW(pwszTagName, L"Schedule"))
    {
        if (m_pRoot->IsChannelFlagSet(CHANNEL_AGENT_DYNAMIC_SCHEDULE))
            return DoChild(new CProcessSchedule(this, m_pRoot, pItem));
        else
            return S_OK;
    }
    else if (!StrCmpIW(pwszTagName, L"SoftPkg"))
    {
        return DoSoftDist(pItem);
    }
    else if (!StrCmpIW(pwszTagName, L"A"))
    {
        // Process Anchor tag
        if (!m_fDownloadedHREF
            && (m_pRoot->IsChannelFlagSet(CHANNEL_AGENT_PRECACHE_SOME) || (m_pRoot==m_pParent))
            && SUCCEEDED(GetXMLStringAttribute(pItem, L"HREF", &bstrTemp))
            && bstrTemp)
        {
            LPWSTR pwszUrl=NULL;

            hr = S_OK;

            CombineWithBaseUrl(bstrTemp, &pwszUrl); // not really necessary (a href)

            if (pwszUrl)
            {
                // Use this as default "email url"
                if (m_pRoot == m_pParent)
                    WriteOLESTR(m_pRoot->m_pChannelAgent->GetStartItem(), c_szPropEmailURL, pwszUrl);

                if (m_pRoot->IsChannelFlagSet(CHANNEL_AGENT_PRECACHE_SOME) &&
                    (S_OK == CheckPreCache()))
                {
                    hr = DoWebCrawl(m_pElement, pwszUrl);

                    if (E_PENDING == hr)
                        m_fDownloadedHREF = TRUE;

                    // Process tracking for this item
                    if (SUCCEEDED(m_pRoot->DoTrackingFromItem(m_pElement, pwszUrl, m_pParent->IsGlobalLog())))
                        SetGlobalLogFlag(TRUE);
                }
            }

            SAFELOCALFREE(pwszUrl);

            SysFreeString(bstrTemp);
            return hr;
        }

        return S_OK;
    }

    return S_OK;
}

CProcessItem::CProcessItem(CProcessElementSink *pParent,
                                 CProcessRoot *pRoot,
                                 IXMLElement *pItem) :
        CProcessElement(pParent, pRoot, pItem)
{
}

CProcessItem::~CProcessItem()
{
    SAFEFREEBSTR(m_bstrAnchorURL);
}

HRESULT CProcessItem::ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem)
{
    if (!StrCmpIW(pwszTagName, L"Logo"))
    {
        if (ShouldDownloadLogo(pItem))
            return DoWebCrawl(pItem);
        else
            return S_OK;
    }
    else if (!StrCmpIW(pwszTagName, L"Usage"))
    {
        // Usage tag found.
        BSTR    bstrValue;

        if (SUCCEEDED(GetXMLStringAttribute(pItem, L"Value", &bstrValue)))
        {
            if (!m_fScreenSaver &&
                (!StrCmpIW(bstrValue, L"ScreenSaver") ||
                 !StrCmpIW(bstrValue, L"SmartScreen"))) // PCN compat only
            {
                m_fScreenSaver = TRUE;
            }
            
            if (!m_fDesktop &&
                !StrCmpIW(bstrValue, L"DesktopComponent"))
            {
                m_fDesktop = TRUE;
            }

            if (!m_fEmail &&
                !StrCmpIW(bstrValue, L"Email"))
            {
                m_fEmail = TRUE;
            }

            SysFreeString(bstrValue);
        }
    }
    else if (!StrCmpIW(pwszTagName, L"A"))
    {
        // Anchor tag found; save URL
        if (!m_bstrAnchorURL)
            GetXMLStringAttribute(pItem, L"HREF", &m_bstrAnchorURL);
    }

    return S_OK;
}

HRESULT CProcessItem::EnumerationComplete()
{
    BOOL fPreCache, fPreCacheValid=FALSE;
    BOOL fDoDownload=FALSE;
    BSTR bstrShow=NULL;
    BSTR bstrURL=NULL;
    HRESULT hr = S_OK;
    LPWSTR pwszUrl=NULL;

    // PCN Compat only - not in spec
    if (SUCCEEDED(GetXMLStringAttribute(m_pElement, L"Show", &bstrShow)) && bstrShow)
    {
        if (!StrCmpIW(bstrShow, L"SmartScreen") &&
            !StrCmpIW(bstrShow, L"ScreenSaver"))
        {
            m_fScreenSaver = TRUE;
        }
        SysFreeString(bstrShow); 
        bstrShow=NULL;
    }
    // End PCN compat

    if (SUCCEEDED(GetXMLBoolAttribute(m_pElement, L"PreCache", &fPreCache)))
    {
        fPreCacheValid = TRUE;
    }

    // Get the URL from our attribute, or from Anchor tag if not available
    if (FAILED(GetXMLStringAttribute(m_pElement, L"HREF", &bstrURL)) || !bstrURL)
    {
        bstrURL = m_bstrAnchorURL;
        m_bstrAnchorURL = NULL;
    }

    // Get the combined URL
    if (bstrURL)
        CombineWithBaseUrl(bstrURL, &pwszUrl);

    if (pwszUrl)
    {
        // Process tracking for this item
        m_pRoot->DoTrackingFromItem(m_pElement, pwszUrl, IsGlobalLog());

        // Find if we should use this url for the Email agent
        if (m_fEmail)
        {
            // Yes, put this url in the end report
            DBG("Using custom email url");
            WriteOLESTR(m_pRoot->m_pChannelAgent->GetStartItem(), c_szPropEmailURL, pwszUrl);
        }

        if (m_fScreenSaver)
        {
            m_pRoot->m_pChannelAgent->SetScreenSaverURL(pwszUrl);
        }

        // Figure out if we should download our "href" based on Usage and Precache tag
        if (fPreCacheValid)
        {
            if (fPreCache)
            {
                if (m_pRoot->IsChannelFlagSet(CHANNEL_AGENT_PRECACHE_SOME))
                    fDoDownload = TRUE;
                else if (m_fScreenSaver && m_pRoot->IsChannelFlagSet(CHANNEL_AGENT_PRECACHE_SCRNSAVER))
                    fDoDownload = TRUE;
            }
        }
        else
        {
            if (m_pRoot->IsChannelFlagSet(CHANNEL_AGENT_PRECACHE_ALL))
                fDoDownload = TRUE;
            else if (m_fScreenSaver && m_pRoot->IsChannelFlagSet(CHANNEL_AGENT_PRECACHE_SCRNSAVER))
                fDoDownload = TRUE;
        }

        // if (m_fDesktop)
        // Do something for desktop components

        if (fDoDownload && pwszUrl)
            hr = DoWebCrawl(m_pElement, pwszUrl);
    } // pwszUrl

    SAFEFREEBSTR(bstrURL);
    SAFELOCALFREE(pwszUrl);

    return hr;
}

CProcessSchedule::CProcessSchedule(CProcessElementSink *pParent,
                                 CProcessRoot *pRoot,
                                 IXMLElement *pItem) :
        CProcessElement(pParent, pRoot, pItem)
{
}

HRESULT CProcessSchedule::Run()
{
    // Get attributes (Start and End date) first
    BSTR    bstr=NULL;
    long    lTimeZone;

    if (FAILED(GetXMLStringAttribute(m_pElement, L"StartDate", &bstr)) ||
        !ISODateToSystemTime(bstr, &m_stStartDate, &lTimeZone))
    {
        GetLocalTime(&m_stStartDate);
    }
    SAFEFREEBSTR(bstr);

    if (FAILED(GetXMLStringAttribute(m_pElement, L"StopDate", &bstr)) ||
        !ISODateToSystemTime(bstr, &m_stEndDate, &lTimeZone))
    {
        ZeroMemory(&m_stEndDate, sizeof(SYSTEMTIME));
    }
    SAFEFREEBSTR(bstr);

    return CProcessElement::Run();
}

HRESULT CProcessSchedule::ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem)
{
    if (!StrCmpIW(pwszTagName, L"IntervalTime"))
    {
        GetXMLTimeAttributes(pItem, &m_timeInterval);
    }
    else if (!StrCmpIW(pwszTagName, L"EarliestTime"))
    {
        GetXMLTimeAttributes(pItem, &m_timeEarliest);
    }
    else if (!StrCmpIW(pwszTagName, L"LatestTime"))
    {
        GetXMLTimeAttributes(pItem, &m_timeLatest);
    }

    return S_OK;
}

HRESULT CProcessSchedule::EnumerationComplete()
{
    DBG("CProcessSchedule::EnumerationComplete");

    int iZone;

    if (FAILED(GetXMLTimeZoneAttribute(m_pElement, L"TimeZone", &iZone)))
        iZone = 9999;

    m_tt.cbTriggerSize = sizeof(m_tt);

    // m_pRoot is null for XMLElementToTaskTrigger call
    // Always run ScheduleToTaskTrigger
    if (SUCCEEDED(ScheduleToTaskTrigger(&m_tt, &m_stStartDate, &m_stEndDate,
            (long) m_timeInterval.dwConvertedMinutes,
            (long) m_timeEarliest.dwConvertedMinutes,
            (long) m_timeLatest.dwConvertedMinutes,
            iZone))
        && m_pRoot)
    {
        SUBSCRIPTIONITEMINFO sii = { sizeof(SUBSCRIPTIONITEMINFO) };
        if (SUCCEEDED(m_pRoot->m_pChannelAgent->GetStartItem()->GetSubscriptionItemInfo(&sii)))
        {
            if (sii.ScheduleGroup != GUID_NULL)
            {
                if (FAILED(UpdateScheduleTrigger(&sii.ScheduleGroup, &m_tt)))
                {
                    DBG_WARN("Failed to update trigger in publisher's recommended schedule.");
                }
            }
            else
                DBG_WARN("No publisher's recommended schedule in sii");
        }
    }

    return S_OK;
}

HRESULT ScheduleToTaskTrigger(TASK_TRIGGER *ptt, SYSTEMTIME *pstStartDate, SYSTEMTIME *pstEndDate,
                              long lInterval, long lEarliest, long lLatest, int iZone/*=9999*/)
{
    // Convert our schedule info to a TASK_TRIGGER struct

    ASSERT(pstStartDate);
    
    int iZoneCorrectionMinutes=0;
    TIME_ZONE_INFORMATION tzi;
    long lRandom;
    
    if ((lInterval == 0) ||
        (lInterval > 366 * MINUTES_PER_DAY))
    {
        DBG_WARN("ScheduleToTaskTrigger: Invalid IntervalTime - failing");
        return E_INVALIDARG;
    }

    if (ptt->cbTriggerSize < sizeof(TASK_TRIGGER))
    {
        DBG_WARN("ScheduleToTaskTrigger: ptt->cbTriggerSize not initialized");
        ASSERT(!"ScheduleToTaskTrigger");
        return E_INVALIDARG;
    }

    // Fix any invalid stuff
    if (lInterval < MINUTES_PER_DAY)
    {
        // ROUND so that dwIntervalMinutes is an even divisor of one day
        lInterval = MINUTES_PER_DAY / (MINUTES_PER_DAY / lInterval);
    }
    else
    {
        // ROUND to nearest day
        lInterval = MINUTES_PER_DAY * ((lInterval + 12*60)/MINUTES_PER_DAY);
    }
    if (lEarliest >= lInterval)
    {
        DBG("Invalid EarliestTime specified. Fixing."); // Earliest >= Interval!
        lEarliest = lInterval-1;
    }
    if (lLatest < lEarliest)
    {
        DBG("Invalid LatestTime specified. Fixing."); // Latest < Earliest!
        lLatest = lEarliest;
    }
    if (lLatest-lEarliest > lInterval)
    {
        DBG("Invalid LatestTime specified. Fixing.");   // Latest > Interval!
        lLatest = lEarliest+lInterval;
    }

    lRandom = lLatest - lEarliest;
    ASSERT(lRandom>=0 && lRandom<=lInterval);

    if (iZone != 9999)
    {
        int iCorrection;
        iCorrection = (60 * (iZone/100)) + (iZone % 100);

        if (iCorrection < -12*60 || iCorrection > 12*60)
        {
            DBG("ScheduleElementToTaskTrigger: Invalid timezone; ignoring");
        }
        else
        {
            if (TIME_ZONE_ID_INVALID != GetTimeZoneInformation(&tzi))
            {
                // tzi.bias has correction from client timezone to UTC (+8 for US west coast)
                // iCorrection has correction from UTC to server time zone (-5 for US east coast)
                // result is correction from server to client time zone (-3 for east to west coast)
                iZoneCorrectionMinutes = - (iCorrection + tzi.Bias + tzi.StandardBias);
                TraceMsg(TF_THISMODULE, "ServerTimeZone = %d, LocalBias = %d min, RelativeCorrection = %d min", iZone, tzi.Bias+tzi.StandardBias, iZoneCorrectionMinutes);
            }
            else
            {
                DBG_WARN("Unable to get local time zone. Not correcting for time zone.");
            }
        }
    }

    TraceMsg(TF_THISMODULE, "StartDate = %d/%d/%d StopDate = %d/%d/%d", (int)(pstStartDate->wMonth),(int)(pstStartDate->wDay),(int)(pstStartDate->wYear),(int)(pstEndDate->wMonth),(int)(pstEndDate->wDay),(int)(pstEndDate->wYear));
    TraceMsg(TF_THISMODULE, "IntervalTime = %6d minutes", (int)lInterval);
    TraceMsg(TF_THISMODULE, "EarliestTime = %6d minutes", (int)lEarliest);
    TraceMsg(TF_THISMODULE, "LatestTime   = %6d minutes", (int)lLatest);
    TraceMsg(TF_THISMODULE, "RandomTime   = %6d minutes", (int)lRandom);

    if (iZoneCorrectionMinutes != 0)
    {
        if (lInterval % 60)
        {
            DBG("Not correcting for time zone ; interval not multiple of 1 hour");
        }
        else
        {
            // Correct Earliest time for time zone
            lEarliest += (iZoneCorrectionMinutes % lInterval);

            if (lEarliest < 0)
                lEarliest += lInterval;

            TraceMsg(TF_THISMODULE, "EarliestTime = %6d minutes (after timezone)", (int)lEarliest);
        }
    }

    ZeroMemory(ptt, sizeof(*ptt));
    ptt->cbTriggerSize = sizeof(*ptt);
    ptt->wBeginYear = pstStartDate->wYear;
    ptt->wBeginMonth = pstStartDate->wMonth;
    ptt->wBeginDay = pstStartDate->wDay;
    if (pstEndDate && pstEndDate->wYear)
    {
        ptt->rgFlags |= TASK_TRIGGER_FLAG_HAS_END_DATE;
        ptt->wEndYear = pstEndDate->wYear;
        ptt->wEndMonth = pstEndDate->wMonth;
        ptt->wEndDay = pstEndDate->wDay;
    }

    // Set up Random period ; difference between Latesttime and Earliesttime
    ptt->wRandomMinutesInterval = (WORD) lRandom;

    ptt->wStartHour = (WORD) (lEarliest / 60);
    ptt->wStartMinute = (WORD) (lEarliest % 60);

    // Set up according to IntervalTime
    if (lInterval < MINUTES_PER_DAY)
    {
        // Less than one day (1/2 day, 1/3 day, 1/4 day, etc)
        ptt->MinutesDuration = MINUTES_PER_DAY - lEarliest;
        ptt->MinutesInterval = lInterval;
        ptt->TriggerType = TASK_TIME_TRIGGER_DAILY;
        ptt->Type.Daily.DaysInterval = 1;
    }
    else
    {
        // Greater than or equal to one day.
        DWORD dwIntervalDays = lInterval / MINUTES_PER_DAY;

        TraceMsg(TF_THISMODULE, "Using %d day interval", dwIntervalDays);

        ptt->TriggerType = TASK_TIME_TRIGGER_DAILY;
        ptt->Type.Daily.DaysInterval = (WORD) dwIntervalDays;
    }

    return S_OK;
}


//==============================================================================
// CRunDeliveryAgent provides generic support for synchronous operation of a
//   delivery agent
// It is aggregatable so that you can add more interfaces to the callback
//==============================================================================
CRunDeliveryAgent::CRunDeliveryAgent()
{
    m_cRef = 1;
}

HRESULT CRunDeliveryAgent::Init(CRunDeliveryAgentSink *pParent,
                                ISubscriptionItem *pItem,
                                REFCLSID rclsidDest)
{
    ASSERT(pParent && pItem);

    if (m_pParent || m_pItem)
        return E_FAIL;  // already initialized. can't reuse an instance.

    if (!pParent || !pItem)
        return E_FAIL;

    m_pParent = pParent;
    m_clsidDest = rclsidDest;

    m_pItem = pItem;
    pItem->AddRef();

    return S_OK;
}

CRunDeliveryAgent::~CRunDeliveryAgent()
{
    CleanUp();
}

//
// IUnknown members
//
STDMETHODIMP_(ULONG) CRunDeliveryAgent::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CRunDeliveryAgent::Release(void)
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CRunDeliveryAgent::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    // Validate requested interface
    if ((IID_IUnknown == riid) ||
        (IID_ISubscriptionAgentEvents == riid))
    {
        *ppv=(ISubscriptionAgentEvents *)this;
    }
    else
        return E_NOINTERFACE;

    // Addref through the interface
    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}

//
// ISubscriptionAgentEvents members
//
STDMETHODIMP CRunDeliveryAgent::UpdateBegin(const SUBSCRIPTIONCOOKIE *)
{
    return S_OK;
}

STDMETHODIMP CRunDeliveryAgent::UpdateProgress(
                const SUBSCRIPTIONCOOKIE *,
                long lSizeDownloaded,
                long lProgressCurrent,
                long lProgressMax,
                HRESULT hrStatus,
                LPCWSTR wszStatus)
{
    if (m_pParent)
        m_pParent->OnAgentProgress();
    return S_OK;
}

STDMETHODIMP CRunDeliveryAgent::UpdateEnd(const SUBSCRIPTIONCOOKIE *pCookie,
                long    lSizeDownloaded,
                HRESULT hrResult,
                LPCWSTR wszResult)
{
    ASSERT((hrResult != INET_S_AGENT_BASIC_SUCCESS) && (hrResult != E_PENDING));

    m_hrResult = hrResult;
    if (hrResult == INET_S_AGENT_BASIC_SUCCESS || hrResult == E_PENDING)
    {
        // Shouldn't happen; let's be robust anyway.
        m_hrResult = S_OK;
    }

    if (m_pParent)
    {
        m_pParent->OnAgentEnd(pCookie, lSizeDownloaded, hrResult, wszResult, m_fInStartAgent);
    }

    CleanUp();

    return S_OK;
}

STDMETHODIMP CRunDeliveryAgent::ReportError(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
        HRESULT hrError, 
        LPCWSTR wszError)
{
    return S_FALSE;
}

HRESULT CRunDeliveryAgent::StartAgent()
{
    HRESULT hr;

    if (!m_pParent || !m_pItem || m_pAgent)
        return E_FAIL;

    AddRef();   // Release before we return from this function
    m_fInStartAgent = TRUE;

    m_hrResult = INET_S_AGENT_BASIC_SUCCESS;

    DBG("Using new interfaces to host agent");

    ASSERT(!m_pAgent);

    hr = CoCreateInstance(m_clsidDest, NULL, CLSCTX_INPROC_SERVER,
                          IID_ISubscriptionAgentControl, (void **)&m_pAgent);

    if (m_pAgent)
    {
        hr = m_pAgent->StartUpdate(m_pItem, (ISubscriptionAgentEvents *)this);
    }

    hr = m_hrResult;

    m_fInStartAgent = FALSE;
    Release();

    if (hr != INET_S_AGENT_BASIC_SUCCESS)
    {
        return hr;
    }

    return E_PENDING;
};

HRESULT CRunDeliveryAgent::AgentPause(DWORD dwFlags)
{
    if (m_pAgent)
        return m_pAgent->PauseUpdate(0);

    DBG_WARN("CRunDeliveryAgent::AgentPause with no running agent!!");
    return S_FALSE;
}

HRESULT CRunDeliveryAgent::AgentResume(DWORD dwFlags)
{
    if (m_pAgent)
        return m_pAgent->ResumeUpdate(0);

    DBG_WARN("CRunDeliveryAgent::AgentResume with no running agent!!");

    return E_FAIL;
}

HRESULT CRunDeliveryAgent::AgentAbort(DWORD dwFlags)
{
    if (m_pAgent)
        return m_pAgent->AbortUpdate(0);

    DBG_WARN("CRunDeliveryAgent::AgentAbort with no running agent!!");
    return S_FALSE;
}

void CRunDeliveryAgent::CleanUp()
{
    SAFERELEASE(m_pItem);
    SAFERELEASE(m_pAgent);
    m_pParent = NULL;
}

// static
#if 0       // unused by us, but do not remove
HRESULT CRunDeliveryAgent::CreateNewItem(ISubscriptionItem **ppItem, REFCLSID rclsidAgent)
{
    ISubscriptionMgrPriv *pSubsMgrPriv=NULL;
    SUBSCRIPTIONITEMINFO info;

    *ppItem = NULL;

    CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
        IID_ISubscriptionMgrPriv, (void**)&pSubsMgrPriv);

    if (pSubsMgrPriv)
    {
        SUBSCRIPTIONCOOKIE cookie;

        info.cbSize = sizeof(info);
        info.dwFlags = SI_TEMPORARY;
        info.dwPriority = 0;
        info.ScheduleGroup = GUID_NULL;
        info.clsidAgent = rclsidAgent;

        pSubsMgrPriv->CreateSubscriptionItem(&info, &cookie, ppItem);

        pSubsMgrPriv->Release();
    }

    return (*ppItem) ? S_OK : E_FAIL;
}
#endif

//////////////////////////////////////////////////////////////////////////
//
// CChannelAgentHolder, derives from CRunDeliveryAgent
//
//////////////////////////////////////////////////////////////////////////
CChannelAgentHolder::CChannelAgentHolder(CChannelAgent *pChannelAgent, CProcessElement *pProcess)
{
    m_pChannelAgent = pChannelAgent;
    m_pProcess = pProcess;
}

CChannelAgentHolder::~CChannelAgentHolder()
{
}

// Won't compile unless we have addref & release here.
STDMETHODIMP_(ULONG) CChannelAgentHolder::AddRef(void)
{
    return CRunDeliveryAgent::AddRef();
}

STDMETHODIMP_(ULONG) CChannelAgentHolder::Release(void)
{
    return CRunDeliveryAgent::Release();
}

STDMETHODIMP CChannelAgentHolder::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    if (IID_IServiceProvider == riid)
    {
        *ppv = (IServiceProvider *)this;
    }   
    else
        return CRunDeliveryAgent::QueryInterface(riid, ppv);

    // Addref through the interface
    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}

// IQueryService
// CLSID_ChannelAgent   IID_ISubscriptionItem       channel agent start item
// CLSID_XMLDocument    IID_IXMLElement             current element
STDMETHODIMP CChannelAgentHolder::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    ASSERT(ppvObject);
    if (!ppvObject)
        return E_INVALIDARG;
    
    if (!m_pChannelAgent || !m_pProcess || !m_pParent)
        return E_FAIL;

    *ppvObject = NULL;

    if (guidService == CLSID_ChannelAgent)
    {
        if (riid == IID_ISubscriptionItem)
        {
            *ppvObject = m_pChannelAgent->GetStartItem();
        }
//      if (riid == IID_IXMLElement)    Root XML document?
    }
    else if (guidService == CLSID_XMLDocument)
    {
        if (riid == IID_IXMLElement)
        {
            *ppvObject = m_pProcess->GetCurrentElement();
        }
    }

    if (*ppvObject)
    {
        ((IUnknown *)*ppvObject)->AddRef();
        return S_OK;
    }

    return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////
//
// CChannelAgent implementation
//
//////////////////////////////////////////////////////////////////////////

CChannelAgent::CChannelAgent()
{
    DBG("Creating CChannelAgent object");

    // Initialize object
    // Many vars are initialized in StartOperation
    m_pwszURL = NULL;
    m_pCurDownload = NULL;
    m_pProcess = NULL;
    m_fHasInitCookie = FALSE;
    m_pChannelIconHelper = NULL;
}

CChannelAgent::~CChannelAgent()
{
//  DBG("Destroying CChannelAgent object");

    if (m_pwszURL)
        CoTaskMemFree(m_pwszURL);
    
    SAFELOCALFREE (m_pBuf);

    ASSERT(!m_pProcess);

    SAFERELEASE(m_pChannelIconHelper);

    SAFELOCALFREE(m_pwszScreenSaverURL);

    DBG("Destroyed CChannelAgent object");
}

void CChannelAgent::CleanUp()
{
    if (m_pCurDownload)
    {
        m_pCurDownload->LeaveMeAlone();     // no more calls from them
        m_pCurDownload->DoneDownloading();
        m_pCurDownload->Release();
        m_pCurDownload = NULL;
    }
    SAFEFREEOLESTR(m_pwszURL);
    SAFEDELETE(m_pProcess);
    SAFELOCALFREE(m_pBuf);

    CDeliveryAgent::CleanUp();
}

void CChannelAgent::SetScreenSaverURL(LPCWSTR pwszURL)
{
    //  We only take the first one
    if (NULL == m_pwszScreenSaverURL)
    {
        m_pwszScreenSaverURL = StrDupW(pwszURL);
    }
}


HRESULT CChannelAgent::StartOperation()
{
    DBG("Channel Agent in StartOperation");
    
    DWORD dwTemp;

    SAFEFREEOLESTR(m_pwszURL);
    if (FAILED(ReadOLESTR(m_pSubscriptionItem, c_szPropURL, &m_pwszURL)) ||
        !CUrlDownload::IsValidURL(m_pwszURL))
    {
        DBG_WARN("Couldn't get valid URL, aborting");
        SetEndStatus(E_INVALIDARG);
        SendUpdateNone();
        return E_INVALIDARG;
    }

    if (FAILED(ReadDWORD(m_pSubscriptionItem, c_szPropChannelFlags, &m_dwChannelFlags)))
        m_dwChannelFlags = 0;
    
    // If we download all, we also download some. Makes assumptions easier.
    if (m_dwChannelFlags & CHANNEL_AGENT_PRECACHE_ALL)
        m_dwChannelFlags |= CHANNEL_AGENT_PRECACHE_SOME;

    // NOTE: We may want REST_NoChannelContent to be similar to the webcrawl version.
    // Probably not though because the headlines are useful in the UI.
    if (SHRestricted2W(REST_NoChannelContent, NULL, 0))
        ClearFlag(m_dwChannelFlags, CHANNEL_AGENT_PRECACHE_ALL | CHANNEL_AGENT_PRECACHE_SOME);

    m_dwMaxSizeKB = SHRestricted2W(REST_MaxChannelSize, NULL, 0);
    if (SUCCEEDED(ReadDWORD(m_pSubscriptionItem, c_szPropCrawlMaxSize, &dwTemp))
        && dwTemp
        && (0 == m_dwMaxSizeKB || dwTemp < m_dwMaxSizeKB))
    {
        m_dwMaxSizeKB = dwTemp;
    }

    if (IsAgentFlagSet(FLAG_CHANGESONLY))
    {
        ClearFlag(m_dwChannelFlags, CHANNEL_AGENT_PRECACHE_ALL|
            CHANNEL_AGENT_PRECACHE_SOME|CHANNEL_AGENT_PRECACHE_SCRNSAVER);
        DBG("Channel agent is in 'changes only' mode.");
    }
    else
    {
        // Read old group ID
        ReadLONGLONG(m_pSubscriptionItem, c_szPropCrawlGroupID, &m_llOldCacheGroupID);

        // Read new ID if present
        m_llCacheGroupID = 0;
        ReadLONGLONG(m_pSubscriptionItem, c_szPropCrawlNewGroupID, &m_llCacheGroupID);
    }

    return CDeliveryAgent::StartOperation();
}

HRESULT CChannelAgent::StartDownload()
{
    ASSERT(!m_pCurDownload);
    TraceMsg(TF_THISMODULE, "Channel agent starting download of CDF: URL=%ws", m_pwszURL);

    m_pCurDownload = new CUrlDownload(this, 0);
    if (!m_pCurDownload)
        return E_OUTOFMEMORY;

    // Change detection
    m_varChange.vt = VT_EMPTY;
    if (IsAgentFlagSet(FLAG_CHANGESONLY))
    {
        // "Changes Only" mode, we have persisted a change detection code
        ReadVariant(m_pSubscriptionItem, c_szPropChangeCode, &m_varChange);
        m_llCacheGroupID = 0;
    }
    else
    {
        // Create new cache group
        if (!m_llCacheGroupID)
        {
            m_llCacheGroupID = CreateUrlCacheGroup(CACHEGROUP_FLAG_NONPURGEABLE, 0);

            ASSERT_MSG(m_llCacheGroupID != 0, "Create cache group failed");
        }
    }

    TCHAR   szUrl[INTERNET_MAX_URL_LENGTH];

    MyOleStrToStrN(szUrl, INTERNET_MAX_URL_LENGTH, m_pwszURL);
    PreCheckUrlForChange(szUrl, &m_varChange, NULL);

    SendUpdateProgress(m_pwszURL, 0, -1, 0);

    // Start download
    return m_pCurDownload->BeginDownloadURL2(
        m_pwszURL, BDU2_URLMON, BDU2_NEEDSTREAM, NULL, m_dwMaxSizeKB<<10);
}

HRESULT CChannelAgent::OnAuthenticate(HWND *phwnd, LPWSTR *ppszUsername, LPWSTR *ppszPassword)
{
    HRESULT hr;
    ASSERT(phwnd && ppszUsername && ppszPassword);
    ASSERT((HWND)-1 == *phwnd && NULL == *ppszUsername && NULL == *ppszPassword);

    hr = ReadOLESTR(m_pSubscriptionItem, c_szPropCrawlUsername, ppszUsername);
    if (SUCCEEDED(hr))
    {
        BSTR bstrPassword = NULL;
        hr = ReadPassword(m_pSubscriptionItem, &bstrPassword);
        if (SUCCEEDED(hr))
        {
            int len = (lstrlenW(bstrPassword) + 1) * sizeof(WCHAR);
            *ppszPassword = (LPWSTR) CoTaskMemAlloc(len);
            if (*ppszPassword)
            {
                CopyMemory(*ppszPassword, bstrPassword, len);
            }
            SAFEFREEBSTR(bstrPassword);
            if (*ppszPassword)
            {
                return S_OK;
            }
        }
    }

    SAFEFREEOLESTR(*ppszUsername);
    SAFEFREEOLESTR(*ppszPassword);
    return E_FAIL;
}

HRESULT CChannelAgent::OnDownloadComplete(UINT iID, int iError)
{
    TraceMsg(TF_THISMODULE, "Channel Agent: OnDownloadComplete(%d)", iError);

    IStream *pStm = NULL;
    HRESULT hr;
    BOOL    fProcessed=FALSE;
    DWORD   dwCDFSizeKB=0, dwResponseCode;
    BSTR    bstrTmp;
    char    chBuf[MY_MAX_CACHE_ENTRY_INFO];
    DWORD   dwBufSize = sizeof(chBuf);

    LPINTERNET_CACHE_ENTRY_INFO lpInfo = (LPINTERNET_CACHE_ENTRY_INFO) chBuf;

    if (iError)
        hr = E_FAIL;
    else
    {
        hr = m_pCurDownload->GetResponseCode(&dwResponseCode);

        if (SUCCEEDED(hr))
        {
            hr = CheckResponseCode(dwResponseCode);
        }
        else
            DBG_WARN("CChannelAgent failed to GetResponseCode");
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pCurDownload->GetStream(&pStm);
        m_pCurDownload->ReleaseStream();
    }

    if (SUCCEEDED(hr))
    {
        TCHAR   szThisUrl[INTERNET_MAX_URL_LENGTH];
        LPWSTR  pwszThisUrl;

        m_pCurDownload->GetRealURL(&pwszThisUrl);

        if (pwszThisUrl)
        {
            MyOleStrToStrN(szThisUrl, INTERNET_MAX_URL_LENGTH, pwszThisUrl);

            LocalFree(pwszThisUrl);

            if (SUCCEEDED(GetUrlInfoAndMakeSticky(
                            NULL,
                            szThisUrl,
                            lpInfo,
                            dwBufSize,
                            m_llCacheGroupID)))
            {
                dwCDFSizeKB = (((LPINTERNET_CACHE_ENTRY_INFO)chBuf)->dwSizeLow+512) >> 10;
                TraceMsg(TF_THISMODULE, "CDF size %d kb", dwCDFSizeKB);

                hr = PostCheckUrlForChange(&m_varChange, lpInfo, lpInfo->LastModifiedTime);
                // If we FAILED, we mark it as changed.
                if (hr == S_OK || FAILED(hr))
                {
                    SetAgentFlag(FLAG_CDFCHANGED);
                    DBG("CDF has changed; will flag channel as changed");
                }

                // "Changes Only" mode, persist change detection code
                if (IsAgentFlagSet(FLAG_CHANGESONLY))
                {
                    WriteVariant(m_pSubscriptionItem, c_szPropChangeCode, &m_varChange);
                }

                hr = S_OK;
            }
        }
    }
    else
    {
        SetEndStatus(E_INVALIDARG);
    }

    // Get an object model on our Channel Description File
    if (SUCCEEDED(hr) && pStm)
    {
        IPersistStreamInit *pPersistStm=NULL;

        CoCreateInstance(CLSID_XMLDocument, NULL, CLSCTX_INPROC,
                         IID_IPersistStreamInit, (void **)&pPersistStm);

        if (pPersistStm)
        {
            pPersistStm->InitNew();
            hr = pPersistStm->Load(pStm);
            if (SUCCEEDED(hr))
            {
                IXMLDocument *pDoc;

                hr = pPersistStm->QueryInterface(IID_IXMLDocument, (void **)&pDoc);
                if (SUCCEEDED(hr) && pDoc)
                {
                    IXMLElement *pRoot;
                    BSTR        bstrCharSet=NULL;

                    if (SUCCEEDED(pDoc->get_charset(&bstrCharSet)) && bstrCharSet)
                    {
                        WriteOLESTR(m_pSubscriptionItem, c_szPropCharSet, bstrCharSet);
                        TraceMsg(TF_THISMODULE, "Charset = \"%ws\"", bstrCharSet);
                        SysFreeString(bstrCharSet);
                    }
                    else
                        WriteEMPTY(m_pSubscriptionItem, c_szPropCharSet);

                    hr = pDoc->get_root(&pRoot);
                    if (SUCCEEDED(hr) && pRoot)
                    {
                        if (SUCCEEDED(pRoot->get_tagName(&bstrTmp)) && bstrTmp)
                        {
                            if (!StrCmpIW(bstrTmp, L"Channel"))
                            {
                                ASSERT(!m_pProcess);
                                m_pProcess = new CProcessRoot(this, pRoot);
                                if (m_pProcess)
                                {
                                    if (IsAgentFlagSet(FLAG_CDFCHANGED))
                                        SetEndStatus(S_OK);
                                    else
                                        SetEndStatus(S_FALSE);
                                     
                                    m_pProcess->m_dwCurSizeKB = dwCDFSizeKB;
                                    WriteEMPTY(m_pSubscriptionItem, c_szPropEmailURL);
            
                                    hr = m_pProcess->Run();     // This will get us cleaned up (now or later)
                                    fProcessed = TRUE;          // So we shouldn't do it ourselves
                                }
                            }
                            else
                                DBG_WARN("Valid XML but invalid CDF");

                            SAFEFREEBSTR(bstrTmp);
                        }
                        pRoot->Release();
                    }
                    pDoc->Release();
                }
            }
            pPersistStm->Release();
        }
    }

    if (!fProcessed || (FAILED(hr) && (hr != E_PENDING)))
    {
        if (INET_S_AGENT_BASIC_SUCCESS == GetEndStatus())
            SetEndStatus(E_FAIL);
        DBG_WARN("Failed to process CDF ; XML load failed?");
        CleanUp();      // CleanUp only if the process failed (otherwise OnChildDone does it)
    }

#ifdef DEBUG
    if (hr == E_PENDING)
        DBG("CChannelAgent::OnDownloadComplete not cleaning up, webcrawl pending");
#endif

    return S_OK;
}

HRESULT CChannelAgent::OnChildDone(CProcessElement *pChild, HRESULT hr)
{
    // Our CProcessRoot has reported that it's done. Clean up.
    DBG("CChannelAgent::OnChildDone cleaning up Channel delivery agent");

    if (m_llOldCacheGroupID)
    {
        DBG("Nuking old cache group.");
        if (!DeleteUrlCacheGroup(m_llOldCacheGroupID, 0, 0))
        {
            DBG_WARN("Failed to delete old cache group!");
        }
    }

    if (SUCCEEDED(GetEndStatus()))
    {
        IChannelMgrPriv2 *pChannelMgrPriv2;
        
        HRESULT hrTmp = CoCreateInstance(CLSID_ChannelMgr, 
                                         NULL, 
                                         CLSCTX_INPROC_SERVER, 
                                         IID_IChannelMgrPriv2, (void**)&pChannelMgrPriv2);
        if (SUCCEEDED(hrTmp))
        {
            ASSERT(NULL != pChannelMgrPriv2);

            hrTmp = pChannelMgrPriv2->WriteScreenSaverURL(m_pwszURL, m_pwszScreenSaverURL);

            pChannelMgrPriv2->Release();
        }
    }
    
    WriteLONGLONG(m_pSubscriptionItem, c_szPropCrawlGroupID, m_llCacheGroupID);

    // Add "total size" property
    m_lSizeDownloadedKB = (long) (m_pProcess->m_dwCurSizeKB);
    WriteDWORD(m_pSubscriptionItem, c_szPropCrawlActualSize, m_lSizeDownloadedKB);

    WriteDWORD(m_pSubscriptionItem, c_szPropActualProgressMax, m_pProcess->m_iTotalStarted);

    CleanUp();
    return S_OK;
}

HRESULT CChannelAgent::AgentPause(DWORD dwFlags)
{
    DBG("CChannelAgent::AgentPause");

    if (m_pProcess)
        m_pProcess->Pause(dwFlags);

    return CDeliveryAgent::AgentPause(dwFlags);
}

HRESULT CChannelAgent::AgentResume(DWORD dwFlags)
{
    DBG("CChannelAgent::AgentResume");

    if (m_pProcess)
        m_pProcess->Resume(dwFlags);

    return CDeliveryAgent::AgentResume(dwFlags);
}

// Forcibly abort current operation
HRESULT CChannelAgent::AgentAbort(DWORD dwFlags)
{
    DBG("CChannelAgent::AgentAbort");

    if (m_pCurDownload)
        m_pCurDownload->DoneDownloading();

    if (m_pProcess)
        m_pProcess->Abort(dwFlags);

    return CDeliveryAgent::AgentAbort(dwFlags);
}

HRESULT CChannelAgent::ModifyUpdateEnd(ISubscriptionItem *pEndItem, UINT *puiRes)
{
    // Customize our end status string
    switch (GetEndStatus())
    {
        case INET_E_AGENT_MAX_SIZE_EXCEEDED :
                              *puiRes = IDS_AGNT_STATUS_SIZELIMIT; break;
        case INET_E_AGENT_CACHE_SIZE_EXCEEDED :
                              *puiRes = IDS_AGNT_STATUS_CACHELIMIT; break;
        case E_FAIL         : *puiRes = IDS_CRAWL_STATUS_NOT_OK; break;
        case S_OK           :
            if (!IsAgentFlagSet(FLAG_CHANGESONLY))
                *puiRes = IDS_CRAWL_STATUS_OK;
            else
                *puiRes = IDS_URL_STATUS_OK;
            break;
        case S_FALSE        :
            if (!IsAgentFlagSet(FLAG_CHANGESONLY))
                *puiRes = IDS_CRAWL_STATUS_UNCHANGED;
            else
                *puiRes = IDS_URL_STATUS_UNCHANGED;
            break;
        case INET_S_AGENT_PART_FAIL : *puiRes = IDS_CRAWL_STATUS_MOSTLYOK; break;
    }

    return CDeliveryAgent::ModifyUpdateEnd(pEndItem, puiRes);
}


const GUID  CLSID_CDFICONHANDLER =
{0xf3ba0dc0, 0x9cc8, 0x11d0, {0xa5, 0x99, 0x0, 0xc0, 0x4f, 0xd6, 0x44, 0x35}};

extern HRESULT LoadWithCookie(LPCTSTR, POOEBuf, DWORD *, SUBSCRIPTIONCOOKIE *);

// IExtractIcon members
STDMETHODIMP CChannelAgent::GetIconLocation(UINT uFlags, LPTSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags)
{
    DWORD   dwSize;
    IChannelMgrPriv*   pIChannelMgrPriv = NULL;
    HRESULT            hr = E_FAIL;
    TCHAR              szPath[MAX_PATH];

    if (!m_pBuf)    {
        m_pBuf = (POOEBuf)MemAlloc(LPTR, sizeof(OOEBuf));
        if (!m_pBuf)
            return E_OUTOFMEMORY;

        HRESULT hr = LoadWithCookie(NULL, m_pBuf, &dwSize, &m_SubscriptionCookie);
        RETURN_ON_FAILURE(hr);
    }

    hr = GetChannelPath(m_pBuf->m_URL, szPath, ARRAYSIZE(szPath), &pIChannelMgrPriv);

    if (SUCCEEDED(hr) && pIChannelMgrPriv)
    {
        IPersistFile* ppf = NULL;
        BOOL          bCoinit = FALSE;
        HRESULT       hr2 = E_FAIL;

        pIChannelMgrPriv->Release();

        hr = CoCreateInstance(CLSID_CDFICONHANDLER, NULL, CLSCTX_INPROC_SERVER,
                          IID_IPersistFile, (void**)&ppf);

        if ((hr == CO_E_NOTINITIALIZED || hr == REGDB_E_IIDNOTREG) &&
            SUCCEEDED(CoInitialize(NULL)))
        {
            bCoinit = TRUE;
            hr = CoCreateInstance(CLSID_CDFICONHANDLER, NULL, CLSCTX_INPROC_SERVER,
                          IID_IPersistFile, (void**)&ppf);
        }

        if (SUCCEEDED(hr))
        {
            
            hr = ppf->QueryInterface(IID_IExtractIcon, (void**)&m_pChannelIconHelper);

            WCHAR wszPath[MAX_PATH];
            MyStrToOleStrN(wszPath, ARRAYSIZE(wszPath), szPath);
            hr2 = ppf->Load(wszPath, 0);

            ppf->Release();
        }

        if (SUCCEEDED(hr) && m_pChannelIconHelper)
        {
            hr = m_pChannelIconHelper->GetIconLocation(uFlags, szIconFile, cchMax, piIndex, pwFlags);
        }

        if (bCoinit)
            CoUninitialize();

    }

    if (m_pChannelIconHelper == NULL)
    {
        WCHAR wszCookie[GUIDSTR_MAX];

        ASSERT (piIndex && pwFlags && szIconFile);

        StringFromGUID2(m_SubscriptionCookie, wszCookie, ARRAYSIZE(wszCookie));
        MyOleStrToStrN(szIconFile, cchMax, wszCookie);
        *piIndex = 0;
        *pwFlags |= GIL_NOTFILENAME | GIL_PERINSTANCE;
        hr = NOERROR;
    }

    return hr;
}

STDMETHODIMP CChannelAgent::Extract(LPCTSTR szIconFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize)
{
    static HICON channelIcon = NULL;

    if (!phiconLarge || !phiconSmall)
        return E_INVALIDARG;

    * phiconLarge = * phiconSmall = NULL;

    if (m_pChannelIconHelper)
    {
        return m_pChannelIconHelper->Extract(szIconFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
    }
    else
    {
        DWORD   dwSize;

        if (!m_pBuf)    {
            m_pBuf = (POOEBuf)MemAlloc(LPTR, sizeof(OOEBuf));
            if (!m_pBuf)
                return E_OUTOFMEMORY;

            HRESULT hr = LoadWithCookie(NULL, m_pBuf, &dwSize, &m_SubscriptionCookie);
            RETURN_ON_FAILURE(hr);
        }

        BYTE    bBuf[MY_MAX_CACHE_ENTRY_INFO];
        LPINTERNET_CACHE_ENTRY_INFO pEntry = (INTERNET_CACHE_ENTRY_INFO *)bBuf;

        dwSize = sizeof(bBuf);
        if (GetUrlCacheEntryInfo(m_pBuf->m_URL, pEntry, &dwSize))   {
            SHFILEINFO  sfi;
            UINT    cbFileInfo = sizeof(sfi), uFlags = SHGFI_ICON | SHGFI_LARGEICON;

            if (NULL != SHGetFileInfo(pEntry->lpszLocalFileName, 0,
                                            &sfi, cbFileInfo, uFlags))
            {
                ASSERT(sfi.hIcon);
                *phiconLarge = *phiconSmall = sfi.hIcon;
                return NOERROR;
            }
        }

        if (channelIcon == NULL) {
            channelIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_CHANNEL));
            ASSERT(channelIcon);
        }

        * phiconLarge = * phiconSmall = channelIcon;
        return NOERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\cdlagent.h ===
#ifndef _CDL_AGENT_HXX_INCLUDED
#define _CDL_AGENT_HXX_INCLUDED

class CDLAgentBSC;

class CCDLAgent : public CDeliveryAgent,
                  public CRunDeliveryAgentSink
{
    private:
        virtual ~CCDLAgent();
    
    public:
        CCDLAgent();

    // virtual functions overriding CDeliveryAgent

    public:
        void        CleanUp();
        HRESULT     AgentAbort(DWORD dwFlags);
        HRESULT     AgentPause(DWORD dwFlags);
        HRESULT     AgentResume(DWORD dwFlags);
   
    protected:
        HRESULT     StartOperation();
        HRESULT     StartDownload();
        HRESULT     ModifyUpdateEnd(ISubscriptionItem *pEndItem, UINT *puiRes);

    public:
        void        SetEndStatus(HRESULT hr) { CDeliveryAgent::SetEndStatus(hr); }
        void        SetErrorEndText(LPCWSTR szErrorText);
        LPWSTR      GetErrorMessage(HRESULT hr);

        HRESULT     StartNextDownload(LPWSTR szCodeBase, DWORD dwSize);
        HRESULT     OnAgentEnd(const SUBSCRIPTIONCOOKIE *, long, HRESULT, LPCWSTR, BOOL);

    private:

        IXMLElement*     m_pSoftDistElement;
        union {
            LPWSTR           m_szCDF;
            LPWSTR           m_szURL;
        };
        LPWSTR           m_szDistUnit;
        SOFTDISTINFO     m_sdi;
        LPWSTR           m_szErrorText;
        DWORD            m_dwVersionMS;
        DWORD            m_dwVersionLS;

        CDLAgentBSC     *m_pCCDLAgentBSC;
        ISoftDistExt    *m_pSoftDistExt;
        
        BOOL             m_bAcceptSoftware;
        BOOL             m_bSendEmail;
        BOOL             m_bSilentMode;

        DWORD            m_dwChannelFlags;
        DWORD            m_dwAgentFlags;
        DWORD            m_dwMaxSizeKB;
        DWORD            m_dwCurSize;
        
        CRunDeliveryAgent *m_pAgent;
};
         
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\cdlagent.cpp ===
#include "private.h"
#include <urlmon.h>
#include <wininet.h>
#include <msxml.h>
#include "cdfagent.h"
#include "cdlabsc.h"
#include "cdlagent.h"
#include <urlmon.h>
#include <subsmgr.h>
#include "subsmgrp.h"

#include <mluisupp.h>

HRESULT GetXMLAttribute(IXMLElement *pItem, LPCWSTR pwszAttribute, VARIANT *pvRet);

HRESULT GetNextChildTag(IXMLElement *pRoot, LPCWSTR szTag, IXMLElement **ppChildReq, int &nLastChild)
{
    BSTR bstrTag = NULL;
    IXMLElementCollection * pChildren = NULL;
    HRESULT hr = S_FALSE;   // assume not found.
    IXMLElement * pChild = NULL;

    //
    // Find the children if they exist
    //
    if (SUCCEEDED(pRoot->get_children(&pChildren)) && pChildren)
    {
        long length = 0;

        if (SUCCEEDED(pChildren->get_length(&length)) && length > 0)
        {
            VARIANT vIndex, vEmpty;
            vIndex.vt = VT_I4;
            vEmpty.vt = VT_EMPTY;

            nLastChild++;

            for (long i=nLastChild; i<length; i++)
            {
                vIndex.lVal = i;
                IDispatch *pDispItem = NULL;
                if (SUCCEEDED(pChildren->item(vIndex, vEmpty, &pDispItem)))
                {

                    if (SUCCEEDED(pDispItem->QueryInterface(IID_IXMLElement, (void **)&pChild)))
                    {
                        // look for first SoftDist tag

                        pChild->get_tagName(&bstrTag);

                        if (StrCmpIW(bstrTag, szTag) == 0) {
                            nLastChild = i;
                            hr = S_OK;
                            goto Exit;
                        }

                        SAFEFREEBSTR(bstrTag);

                        SAFERELEASE(pChild);
                    }

                pDispItem->Release();

                }


            }
        }

    }
    else
    {
        hr = E_FAIL;
    }


Exit:

    *ppChildReq = pChild;

    if (pChildren)
        SAFERELEASE(pChildren);

    SAFEFREEBSTR(bstrTag);

    return hr;
}

HRESULT GetFirstChildTag(IXMLElement *pRoot, LPCWSTR szTag, IXMLElement **ppChildReq)
{
    int nLastChild = -1; // first child, never seen any before this one

    return GetNextChildTag(pRoot, szTag, ppChildReq, nLastChild);
}

CCDLAgent::CCDLAgent()
: m_pCCDLAgentBSC(NULL)
, m_szCDF(NULL)
, m_bAcceptSoftware(FALSE)
{
    m_sdi.cbSize = sizeof(SOFTDISTINFO);
    m_bSilentMode = TRUE;
}

CCDLAgent::~CCDLAgent()
{

    SAFERELEASE(m_pSoftDistElement);
    SAFERELEASE(m_pSoftDistExt);

    CRunDeliveryAgent::SafeRelease(m_pAgent);

    SAFEFREEOLESTR(m_szCDF);
    SAFEFREEBSTR(m_szErrorText);
    SAFEDELETE(m_sdi.szAbstract);
    SAFEDELETE(m_sdi.szTitle);
    SAFEDELETE(m_sdi.szHREF);
    SAFEFREEOLESTR(m_szDistUnit);
}

HRESULT CCDLAgent::StartOperation()
{
    HRESULT                  hr = S_OK, hr2;

    // unknown pointers
    IUnknown                *punk = NULL;
    IServiceProvider        *pSP;
    
    m_pSoftDistElement = NULL;
    if (FAILED(ReadOLESTR(m_pSubscriptionItem, c_szPropURL, &m_szURL)))
    {
        hr = E_INVALIDARG;
        goto Failed;
    }


    hr2 = E_FAIL;

    if (SUCCEEDED(m_pAgentEvents->QueryInterface(IID_IServiceProvider, (void **)&pSP)) && pSP)
    {
        hr2 = pSP->QueryService(CLSID_XMLDocument, IID_IXMLElement, (void **)&punk);
        pSP->Release();
    }

    if (FAILED(hr2) || !punk)
    {
        // We are processing a request to pull a CAB, probably from Web Crawler agent.
        
        if (FAILED(ReadOLESTR(m_pSubscriptionItem, L"DistUnit", &m_szDistUnit)) ||
            FAILED(ReadDWORD(m_pSubscriptionItem, L"VersionMS",&m_dwVersionMS)) ||
            FAILED(ReadDWORD(m_pSubscriptionItem, L"VersionLS", &m_dwVersionLS)))
        {
            hr = E_INVALIDARG;
            goto Failed;
        }

        m_pSoftDistElement = NULL;
    }
    else
    {
        if (FAILED(punk->QueryInterface(IID_IXMLElement, (void **)&m_pSoftDistElement)))
        {
            SAFERELEASE(punk);
            hr = E_INVALIDARG;
            goto Failed;
        }

        SAFERELEASE(punk);

        Assert(m_pSoftDistElement);
    }


    ReadDWORD(m_pSubscriptionItem, c_szPropCrawlMaxSize, &m_dwMaxSizeKB);
    ReadDWORD(m_pSubscriptionItem, c_szPropChannelFlags, &m_dwChannelFlags);
    ReadDWORD(m_pSubscriptionItem, c_szPropAgentFlags, &m_dwAgentFlags);

    hr = CDeliveryAgent::StartOperation();

    return hr;

Failed:
    SetEndStatus(hr);
    SendUpdateNone();

    return hr;
}

HRESULT CCDLAgent::StartDownload()
{
    IBindCtx *pbc = NULL;
    HRESULT hr = S_OK;
    LPWSTR szCodeBase;
    DWORD dwSize;
    BOOL bCleanUpNow = FALSE;
    DWORD dwPolicy = 0;
    DWORD dwContext = 0;
    IInternetSecurityManager * pism = NULL;

    if (FAILED(GetEndStatus())) {
    
        hr = GetEndStatus();
        goto Exit;
    }

    hr = CoCreateInstance(CLSID_SoftDistExt, NULL, CLSCTX_INPROC_SERVER, IID_ISoftDistExt, (void **)&m_pSoftDistExt);

    if (FAILED(hr))
        goto Exit;

    // Process SOFTDIST tag structure if present.
    if (m_pSoftDistElement != NULL) {

        dwPolicy = 0xFFFF0000;

        if (FAILED(CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER, 
                                    IID_IInternetSecurityManager, (void**)&pism)) || !pism)
        {
            hr = E_ACCESSDENIED;
            goto Exit;
        }

        hr = pism->ProcessUrlAction(m_szURL, URLACTION_CHANNEL_SOFTDIST_PERMISSIONS,
                                (BYTE *)&dwPolicy, sizeof(dwPolicy),
                                (BYTE *)&dwContext, sizeof(dwContext), PUAF_NOUI, 0);
        
        pism->Release();

        if (FAILED(hr))
        {
            goto Exit;
        }

        dwPolicy &= 0xFFFF0000;

        if (dwPolicy != URLPOLICY_CHANNEL_SOFTDIST_PROHIBIT
            && dwPolicy != URLPOLICY_CHANNEL_SOFTDIST_PRECACHE
            && dwPolicy != URLPOLICY_CHANNEL_SOFTDIST_AUTOINSTALL)
        {
            hr = E_INVALIDARG;
            goto Exit;
        }

        if (dwPolicy == URLPOLICY_CHANNEL_SOFTDIST_PROHIBIT)
        {
            hr = E_ACCESSDENIED;
            goto Exit;
        }

        hr = m_pSoftDistExt->ProcessSoftDist(m_szCDF, m_pSoftDistElement, &m_sdi);

        if (m_sdi.dwFlags & SOFTDIST_FLAG_DELETE_SUBSCRIPTION) {
            
            ISubscriptionMgr *pSubMgr = NULL;
            hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr, (void**)&pSubMgr);
            if (SUCCEEDED(hr))
            {
                hr = pSubMgr->DeleteSubscription(m_szURL,NULL);
                pSubMgr->Release();
            }
      
            hr = S_FALSE;
        }

        // Send email & update software?
        if (hr == S_OK) {

        
            if (m_sdi.dwFlags) {
                
                m_bSendEmail = TRUE;

            } else {

                // no usage flag and no restriction implies no email.
                m_bSendEmail = FALSE;            
            }

            if (m_sdi.dwFlags & SOFTDIST_FLAG_USAGE_AUTOINSTALL) {
                
                m_bAcceptSoftware = (dwPolicy == URLPOLICY_CHANNEL_SOFTDIST_AUTOINSTALL) ? TRUE : FALSE;
                m_bSilentMode = FALSE;

            } else if (m_sdi.dwFlags & SOFTDIST_FLAG_USAGE_PRECACHE) {

                // to get here, we must have precache or autoinstall policy permissions
                m_bAcceptSoftware = TRUE;
                
            } else {

                m_bAcceptSoftware = FALSE;

            }

        } else {
            m_bSendEmail = FALSE;
            m_bAcceptSoftware = FALSE;
            bCleanUpNow = TRUE;
        }
      
        // Do only code download from here on.
        if (!m_bAcceptSoftware || 
            !((m_dwChannelFlags & CHANNEL_AGENT_PRECACHE_SOME) ||
            (m_dwChannelFlags & CHANNEL_AGENT_PRECACHE_ALL)) ) {

            // No caching allowed, return immediately.
    
            bCleanUpNow = TRUE;
            goto Exit;

         } else {
         
            if (m_dwChannelFlags & CHANNEL_AGENT_PRECACHE_ALL) {
                m_dwMaxSizeKB = 0;
            }
        }
        
    }

    m_pCCDLAgentBSC = new CDLAgentBSC(this, m_dwMaxSizeKB, m_bSilentMode, m_szCDF);
    if (m_pCCDLAgentBSC == NULL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    // attempt to use AsyncInstallDistributionUnit

    hr = CreateBindCtx(0, &pbc);
    if (FAILED(hr)) {
        goto Exit;
    }
    
    hr = RegisterBindStatusCallback(pbc, m_pCCDLAgentBSC, NULL, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (m_pSoftDistElement != NULL) {

        hr = m_pSoftDistExt->AsyncInstallDistributionUnit(pbc, NULL, 0, NULL);

        if (hr == S_OK) {
            SendUpdateNone();
        }
    
    } else {
        
        CODEBASEHOLD *pcbh = new CODEBASEHOLD;
        if (pcbh == NULL) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        pcbh->cbSize = sizeof(CODEBASEHOLD);
        pcbh->szDistUnit = m_szDistUnit;
        pcbh->szCodeBase = m_szURL;
        pcbh->dwVersionMS = m_dwVersionMS;
        pcbh->dwVersionLS = m_dwVersionLS;
        pcbh->dwStyle = 0;

        // Since notification is likely from web crawler and we only support MSICD we
        // don't fire a notification back.
        hr = m_pSoftDistExt->AsyncInstallDistributionUnit(pbc, NULL, 0, pcbh);

        if (hr == S_OK) {
            SendUpdateNone();
        }
        
        SAFEDELETE(pcbh);
        goto Exit;

    }
    
    if (hr != E_NOTIMPL) {
        // May have succeeded or failed, either way, we are out of here.
        goto Exit;
    }

    hr = m_pSoftDistExt->GetFirstCodeBase(&szCodeBase, &dwSize);

    if (SUCCEEDED(hr) && szCodeBase) {

        hr = StartNextDownload(szCodeBase,dwSize);
        SAFEDELETE(szCodeBase);

    } else {

        // no CODEBASE, return OK
        bCleanUpNow = TRUE;
        hr = S_OK;
    }

Exit:
    // In case of SOFTDIST tag we work asychronously and send an END_REPORT back immediately.  If we were called
    // to install a particular CAB then CleanUp is called by CDLABSC::OnStopBinding and report is sent back then.

    SAFERELEASE(pbc);

    if (FAILED(hr) || bCleanUpNow)
    {
        SetEndStatus(hr);
        CleanUp();
    }

    return hr;
}

HRESULT CCDLAgent::StartNextDownload(LPWSTR wzCodeBase, DWORD dwSize)
{
HRESULT hr = E_FAIL;
DWORD dwTemp = 0;
ISubscriptionItem *pItem;

    if (m_dwMaxSizeKB && (dwSize > m_dwMaxSizeKB))
    {
        hr = INET_E_AGENT_MAX_SIZE_EXCEEDED;
        goto Exit;
    }
    else
    {
        // Any other type of INSTALL protocol.

        // Send notification to WebCrawl agent to crawl the codebase.  This should force it in the 
        // case. Only do this if there is any chance the DL will not overflow the cache.
        // Note this will only download the CAB file and not any dependencies inside the CAB.  They
        // should be included as separate CONFIG entries.

        if (m_dwMaxSizeKB && ((m_dwCurSize>>10) > m_dwMaxSizeKB))
        {
            // We've exceeded our maximum download KB limit and can't continue.
            hr = INET_E_AGENT_MAX_SIZE_EXCEEDED;
            goto Exit;
        }

        if (FAILED(hr = DoCloneSubscriptionItem(m_pSubscriptionItem, NULL, &pItem)) || !pItem)
        {
            goto Exit;
        }

        dwTemp = DELIVERY_AGENT_FLAG_NO_BROADCAST;
        WriteDWORD(pItem, c_szPropAgentFlags, dwTemp);
        WriteOLESTR(pItem, c_szPropURL, wzCodeBase);
        if (m_dwMaxSizeKB)
        {
            // KB limit for us to pull.
            WriteDWORD(pItem, c_szPropCrawlMaxSize, m_dwMaxSizeKB - (m_dwCurSize>>10));
        }
        WriteDWORD(pItem, c_szPropCrawlLevels, 0);

        m_dwCurSize += dwSize;

        m_pAgent = new CRunDeliveryAgent();
        if (m_pAgent)
            hr = m_pAgent->Init((CRunDeliveryAgentSink *)this, pItem, CLSID_WebCrawlerAgent);
        pItem->Release();

        if (m_pAgent && SUCCEEDED(hr))
        {
            hr = m_pAgent->StartAgent();
            if (hr == E_PENDING)
            {
                hr = S_OK;
            }
            else
            {
                DBG_WARN("StartNextDownload in CDL agent failed!");
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

Exit:
    return hr;
}

HRESULT CCDLAgent::OnAgentEnd(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                               long lSizeDownloaded, HRESULT hrResult, LPCWSTR wszResult,
                               BOOL fSynchronous)
{
    HRESULT hr = S_OK;
    BOOL fDone = FALSE;
    LPWSTR wzCodeBase = NULL;
    DWORD dwSize;

    ASSERT(m_pAgent != NULL);

    if (fSynchronous)
    {
        // We must have failed. Let StartNextDownload return failure.
        return S_OK;
    }

    CRunDeliveryAgent::SafeRelease(m_pAgent);

    if (SUCCEEDED(hrResult))
    {
        hr = m_pSoftDistExt->GetNextCodeBase(&wzCodeBase, &dwSize);

        if (SUCCEEDED(hr) && wzCodeBase)
        {
            hr = StartNextDownload(wzCodeBase, dwSize);
            SAFEDELETE(wzCodeBase);
            
            if (FAILED(hr)) {
                // we are done
                fDone = TRUE;
            }
            
        } else {

            // no more codebases to crawl
            hr = S_OK;
            fDone = TRUE;
        }
    }
    else
    {
        hr = hrResult;
        fDone = TRUE;
    }

    if (fDone) {
        SetEndStatus(hr);
        CleanUp();
    }

    return hr;
}

void CCDLAgent::CleanUp()
{
    if (m_pCCDLAgentBSC != NULL) {
        m_pCCDLAgentBSC->Release();
    }

    m_pCCDLAgentBSC = NULL;
    CDeliveryAgent::CleanUp();
}

void CCDLAgent::SetErrorEndText(LPCWSTR szErrorText)
{
    if (szErrorText)
        m_szErrorText = SysAllocString(szErrorText);
}

HRESULT CCDLAgent::AgentAbort(DWORD dwFlags)
{
    HRESULT              hr = S_OK;

    if (m_pCCDLAgentBSC != NULL )
    {
        hr = m_pCCDLAgentBSC->Abort();
    }
    
    return hr;
}

HRESULT CCDLAgent::AgentPause(DWORD dwFlags)
{
    HRESULT              hr = S_OK;

    if (m_pCCDLAgentBSC != NULL )
    {
        hr = m_pCCDLAgentBSC->Pause();
    }
    
    return hr;
}

HRESULT CCDLAgent::AgentResume(DWORD dwFlags)
{
    HRESULT              hr = S_OK;

    if (m_pCCDLAgentBSC != NULL )
    {
        hr = m_pCCDLAgentBSC->Resume();
    }
    
    return hr;
}


HRESULT CCDLAgent::ModifyUpdateEnd(ISubscriptionItem *pEndItem, UINT *puiRes)
{
    VARIANT vHref;

    ASSERT(pEndItem);

    // The END_REPORT is sent for both functionalities of CDL agent (SOFTDIST and Pull single CAB).
    // customize our end status string

    switch (GetEndStatus())
    {
        case E_OUTOFMEMORY  : *puiRes = IDS_AGNT_STATUS_SIZELIMIT; break;
        case E_FAIL         : *puiRes = IDS_CRAWL_STATUS_NOT_OK; break;
        case S_FALSE        : *puiRes = IDS_CRAWL_STATUS_UNCHANGED; break;
        case INET_S_AGENT_PART_FAIL : *puiRes = IDS_CRAWL_STATUS_MOSTLYOK; break;

            // This is actually a success code from URLMON
        case HRESULT_FROM_WIN32(ERROR_CANCELLED)
                            : SetEndStatus(S_OK);
                              *puiRes = IDS_CRAWL_STATUS_OK; break;

        case TRUST_E_FAIL   : SetEndStatus(TRUST_E_SUBJECT_NOT_TRUSTED);

        case TRUST_E_SUBJECT_NOT_TRUSTED :
            
        case HRESULT_FROM_WIN32(ERROR_IO_INCOMPLETE) : SetEndStatus(S_OK);
                                // fall through
        case S_OK           : *puiRes = IDS_CRAWL_STATUS_OK; break;
        default             : *puiRes = IDS_CRAWL_STATUS_NOT_OK; break;
                    
            break;
    }

    // force gleam on this channel if we got S_OK on precaching bits
    if (SUCCEEDED(GetEndStatus()) && (GetEndStatus() != S_FALSE)) {
        WriteDWORD(pEndItem, c_szPropEnableShortcutGleam, 1);
    }

    // If we are sending email the status must be S_OK, we incorporate the error 
    // message into the text body for reporting.

    if (m_bSendEmail) {

        VariantInit(&vHref);

        WriteDWORD(pEndItem, c_szPropEmailFlags, MAILAGENT_FLAG_CUSTOM_MSG);

        // This must exist or m_bSendEmail would never have been set in first place.
        GetXMLAttribute(m_pSoftDistElement, L"HREF", &vHref);
    
        WriteOLESTR(pEndItem, c_szPropURL, vHref.bstrVal);
                   
        VariantClear(&vHref);

        if (m_sdi.szTitle) {
            BSTR bstrTitle = SysAllocString(m_sdi.szTitle);

            if (bstrTitle)
                WriteOLESTR(pEndItem, c_szPropEmailTitle, m_sdi.szTitle);

            SAFEFREEBSTR(bstrTitle);
        }

        if (FAILED(GetEndStatus()) && !m_szErrorText) {
            m_szErrorText = GetErrorMessage(GetEndStatus());
        }

        if (m_sdi.szAbstract) {

            BSTR bstrAbstract = SysAllocString(m_sdi.szAbstract);
                       
            if (bstrAbstract != NULL) {
                           
                if (m_szErrorText) {

                    //This is wrecking havoc with the email message, some resource strings
                    //have a 'CR/LF' tacked on the end.  We kill any that exist.
                    DWORD dwLen = lstrlenW(m_szErrorText)-1;
                    while (dwLen > 0 && 
                        (m_szErrorText[dwLen] == 0x0a 
                        || m_szErrorText[dwLen] == 0x0d
                        || m_szErrorText[dwLen] == L'.'))
                    {
                        m_szErrorText[dwLen] = L'\0';
                        dwLen--;
                    }

                    //  BUGBUG - needs cleanup!
                    CHAR szPrefixMsg[MAX_PATH], szFormattedPrefixMsg[MAX_PATH*2];
                    if (MLLoadStringA(IDS_CDLAGENT_ERROR_EMAIL, szPrefixMsg, ARRAYSIZE(szPrefixMsg))>0) {
                                
                        LPWSTR wszNewAbstract = NULL;
                        LPSTR szNewAbstract = NULL;

                        wnsprintfA(szFormattedPrefixMsg, 
                                   ARRAYSIZE(szFormattedPrefixMsg),
                                   szPrefixMsg, 
                                   m_szErrorText);
                        DWORD dwNewLen = lstrlenA(szFormattedPrefixMsg) + lstrlenW(bstrAbstract) + 4;
                        szNewAbstract = (LPSTR)LocalAlloc(0,dwNewLen*sizeof(CHAR));
                        if (szNewAbstract) {
                            wnsprintfA(szNewAbstract, 
                                       dwNewLen*sizeof(CHAR),
                                       "%s%ws", 
                                       szFormattedPrefixMsg, 
                                       bstrAbstract);
                            dwNewLen = lstrlenA(szNewAbstract) + 1;
                            wszNewAbstract = (LPWSTR)LocalAlloc(0,dwNewLen*sizeof(WCHAR));

                            if (wszNewAbstract &&
                                (MultiByteToWideChar(CP_ACP, 0, szNewAbstract, -1, wszNewAbstract, dwNewLen)>0)) {
                                 SAFEFREEBSTR(bstrAbstract);
                                 bstrAbstract = SysAllocString(wszNewAbstract);               
                            }

                            if (wszNewAbstract)
                                LocalFree(wszNewAbstract);

                            LocalFree(szNewAbstract);
                        }    
                                    
                    }
                }
                            
                WriteOLESTR(pEndItem, c_szPropEmailAbstract, bstrAbstract);

                SAFEFREEBSTR(bstrAbstract);
            }
                                            
        }

        // because user is notified of error we don't pass it on anywhere else
        SetEndStatus(S_OK);

        WriteSCODE(pEndItem, c_szPropStatusCode, S_OK);
    }

    ClearAgentFlag(DELIVERY_AGENT_FLAG_NO_BROADCAST);
    
    return CDeliveryAgent::ModifyUpdateEnd(pEndItem, puiRes);
}

LPWSTR CCDLAgent::GetErrorMessage(HRESULT hr)
{
    LPSTR szBuf = NULL;
    LPWSTR wszBuf = NULL;
    DWORD dwLen;
    DWORD dwResource = 0;

    if (SUCCEEDED(hr))
        return NULL;

    dwLen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL,
                          hr, 0, (LPTSTR)&szBuf, 0, NULL);
    if (!dwLen) {

        // NOTE: If out of memory we return NULL.
        if (SUCCEEDED(hr))
            dwResource = IDS_CDLAGENT_SUCCESS;
        else if (hr == TRUST_E_SUBJECT_NOT_TRUSTED)
            dwResource = IDS_CDLAGENT_TRUST_ERROR;
        else 
            dwResource = IDS_CDLAGENT_FAILURE;

        // We know strings will fit into max_path
        WCHAR szTmp[MAX_PATH];
        if (MLLoadStringW(dwResource, szTmp, MAX_PATH)>0) {
            wszBuf = SysAllocString(szTmp);
        }
        
    } else {

        WCHAR wszTemp[MAX_PATH];
        if (MultiByteToWideChar(CP_ACP, 0, szBuf, -1, wszTemp, MAX_PATH)>0) {   
            wszBuf = SysAllocString(wszTemp);
        } else
            wszBuf = NULL;

        SAFEDELETE(szBuf);
    }

    return wszBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\delagent.cpp ===
#include "private.h"
#include "subsmgrp.h"

#include <mluisupp.h>

// These next three are just so we can set the gleam on the channel bar
#include "chanmgr.h"
#include "chanmgrp.h"
#include "shguidp.h"    // IID_IChannelMgrPriv
//

#include "helper.h"
#include "propshts.h"

#include "apithk.h"

#define TF_THISMODULE TF_DELAGENT

CDeliveryAgent::CDeliveryAgent()
{
    // Maintain global count of objects
    DllAddRef();

    // Initialize object
    m_cRef = 1;

#ifdef AGENT_AUTODIAL
    m_iDialerStatus = DIALER_OFFLINE;
#endif

    SetEndStatus(INET_S_AGENT_BASIC_SUCCESS);
}

CDeliveryAgent::~CDeliveryAgent()
{
    DllRelease();

    CleanUp();
}

//
// IUnknown members
//

STDMETHODIMP_(ULONG) CDeliveryAgent::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CDeliveryAgent::Release(void)
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CDeliveryAgent::QueryInterface(REFIID riid, void ** ppv)
{

    *ppv=NULL;

    // Validate requested interface
    if ((IID_IUnknown == riid) ||
        (IID_ISubscriptionAgentControl == riid))
    {
        *ppv=(ISubscriptionAgentControl *)this;
    }
    else if (IID_IShellPropSheetExt == riid)
    {
        *ppv=(IShellPropSheetExt *)this;
    }
#ifdef UNICODE
    else if (IID_IExtractIconA == riid)
    {
        *ppv=(IExtractIconA *)this;
    }
#endif
    else if (IID_IExtractIcon == riid)
    {
        *ppv=(IExtractIcon *)this;
    }
    else if (IID_ISubscriptionAgentShellExt == riid)
    {
        *ppv=(ISubscriptionAgentShellExt *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    // Addref through the interface
    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}

// IShellPropSheetExt members

HRESULT CDeliveryAgent::RemovePages(HWND hdlg)
{
    HRESULT hr = S_OK;

    for (int i = 0; i < ARRAYSIZE(m_hPage); i++)
    {
        if (NULL != m_hPage[i])
        {
            PropSheet_RemovePage(hdlg, 0, m_hPage[i]);
            m_hPage[i] = NULL;
        }
    }
    
    return hr;
}

HRESULT CDeliveryAgent::SaveSubscription()
{
    return SaveBufferChange(m_pBuf, TRUE);
}

HRESULT CDeliveryAgent::URLChange(LPCWSTR pwszNewURL)
{
    return E_NOTIMPL;
}

HRESULT CDeliveryAgent::AddPages(LPFNADDPROPSHEETPAGE lpfn, LPARAM lParam)
{
    HRESULT hr = S_OK;  //  optimistic
    PROPSHEETPAGE psp;

    // initialize propsheet page.
    psp.dwSize          = sizeof(PROPSHEETPAGE);
    psp.dwFlags         = PSP_DEFAULT;
    psp.hInstance       = MLGetHinst();
    psp.pszIcon         = NULL;
    psp.pszTitle        = NULL;
    psp.lParam          = (LPARAM)m_pBuf;

    psp.pszTemplate     = MAKEINTRESOURCE(IDD_SUBSPROPS_SCHEDULE);
    psp.pfnDlgProc      = SchedulePropDlgProc;

    m_hPage[0] = Whistler_CreatePropertySheetPageW(&psp);

    psp.pszTemplate     = MAKEINTRESOURCE((m_pBuf->clsidDest == CLSID_ChannelAgent) ?
                                          IDD_SUBSPROPS_DOWNLOAD_CHANNEL :
                                          IDD_SUBSPROPS_DOWNLOAD_URL);
    psp.pfnDlgProc      = DownloadPropDlgProc;
    m_hPage[1] = Whistler_CreatePropertySheetPageW(&psp);

    if ((NULL != m_hPage[0]) && (NULL != m_hPage[1]))
    {
        for (int i = 0; i < ARRAYSIZE(m_hPage); i++)
        {
            if (!lpfn(m_hPage[i], lParam))
            {
                hr = E_FAIL;
                break;
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }

    if (FAILED(hr))
    {
        for (int i = 0; i < ARRAYSIZE(m_hPage); i++)
        {
            if (NULL != m_hPage[i]) 
            {
                DestroyPropertySheetPage(m_hPage[i]);
                m_hPage[i] = NULL;
            }
        }
    }

    return hr;
}

HRESULT CDeliveryAgent::ReplacePage(UINT pgId, LPFNADDPROPSHEETPAGE lpfn, LPARAM lParam)
{
    return E_NOTIMPL;
}

#ifdef UNICODE
// IExtractIconA members
HRESULT CDeliveryAgent::GetIconLocation(UINT uFlags, LPSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags)
{
    return IExtractIcon_GetIconLocationThunk((IExtractIconW *)this, uFlags, szIconFile, cchMax, piIndex, pwFlags);
}

HRESULT CDeliveryAgent::Extract(LPCSTR pszFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize)
{
    return IExtractIcon_ExtractThunk((IExtractIconW *)this, pszFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
}
#endif

// IExtractIconT members
HRESULT CDeliveryAgent::GetIconLocation(UINT uFlags, LPTSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags)
{
    return E_NOTIMPL;
}

HRESULT CDeliveryAgent::Extract(LPCTSTR pszFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize)
{
    return E_NOTIMPL;
}

HRESULT CDeliveryAgent::Initialize(SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                                   LPCWSTR pwszURL, LPCWSTR pwszName, 
                                   SUBSCRIPTIONTYPE subsType)
{
    HRESULT hr;

    ASSERT(NULL == m_pBuf);

    m_pBuf = (POOEBuf)MemAlloc(LPTR, sizeof(OOEBuf));

    if (NULL != m_pBuf)
    {
        ISubscriptionItem *psi;

        hr = SubscriptionItemFromCookie(FALSE, pSubscriptionCookie, &psi);
        
        if (SUCCEEDED(hr))
        {
            DWORD dwSize;

            m_SubscriptionCookie = *pSubscriptionCookie;

            hr = LoadWithCookie(NULL, m_pBuf, &dwSize, pSubscriptionCookie);
            psi->Release();
        }
        else
        {
            hr = GetDefaultOOEBuf(m_pBuf, subsType);
            MyOleStrToStrN(m_pBuf->m_URL, ARRAYSIZE(m_pBuf->m_URL), pwszURL);
            MyOleStrToStrN(m_pBuf->m_Name, ARRAYSIZE(m_pBuf->m_Name), pwszName);
            m_pBuf->m_Cookie = *pSubscriptionCookie;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


// ISubscriptionAgentControl members
STDMETHODIMP CDeliveryAgent::StartUpdate(IUnknown *pItem, IUnknown *punkAdvise)
{
    HRESULT hr;
    DWORD dwTemp;
    VARIANT_BOOL  fTemp;

    m_lSizeDownloadedKB = -1;

    SAFERELEASE(m_pAgentEvents);
    punkAdvise->QueryInterface(IID_ISubscriptionAgentEvents, (void **)&m_pAgentEvents);

    // For now detect either notification or subscription item
    if (FAILED(pItem->QueryInterface(IID_ISubscriptionItem, (void **)&m_pSubscriptionItem)))
    {
        DBG_WARN("CDeliveryAgent::StartUpdate not an ISubscriptionItem!");
        return E_FAIL;
    }

    // We have a subscription item! Use it.
    TraceMsg(TF_THISMODULE, "CDeliveryAgent::StartUpdate at thread 0x%08x", GetCurrentThreadId());

    ASSERT(!IsAgentFlagSet(FLAG_BUSY));
    if (IsAgentFlagSet(FLAG_BUSY))
        return E_FAIL;

    ASSERT(m_pSubscriptionItem);

    SetEndStatus(INET_S_AGENT_BASIC_SUCCESS);
    m_dwAgentFlags = 0;

    m_pSubscriptionItem->GetCookie(&m_SubscriptionCookie);

    if (SUCCEEDED(ReadDWORD(m_pSubscriptionItem, c_szPropAgentFlags, &dwTemp)))
    {
        ASSERT(!(dwTemp & 0xFFFF0000));
        dwTemp &= 0xFFFF;           // only let them set lower 16 bits
        m_dwAgentFlags |= dwTemp;   // set flags client specifies
    }

    fTemp=FALSE;
    ReadBool(m_pSubscriptionItem, c_szPropCrawlChangesOnly, &fTemp);
    if (fTemp)
    {
        SetAgentFlag(FLAG_CHANGESONLY);
    }

    SetAgentFlag(FLAG_OPSTARTED);
    hr = StartOperation();

    return hr;
}

STDMETHODIMP CDeliveryAgent::PauseUpdate(DWORD dwFlags)
{
    DBG("CDeliveryAgent::PauseUpdate");

    if (!IsAgentFlagSet(FLAG_PAUSED | FLAG_WAITING_FOR_INCREASED_CACHE))
    {
        SetAgentFlag(FLAG_PAUSED);
        return AgentPause(dwFlags);
    }

    return S_FALSE;
}

HRESULT CDeliveryAgent::AgentPause(DWORD dwFlags)
{
    return S_OK;
}

STDMETHODIMP CDeliveryAgent::ResumeUpdate(DWORD dwFlags)
{
    DBG("CDeliveryAgent::ResumeUpdate");

    if (IsAgentFlagSet(FLAG_PAUSED | FLAG_WAITING_FOR_INCREASED_CACHE))
    {
        if (IsAgentFlagSet(FLAG_WAITING_FOR_INCREASED_CACHE))
            dwFlags |= SUBSCRIPTION_AGENT_RESUME_INCREASED_CACHE;

        ClearAgentFlag(FLAG_PAUSED | FLAG_WAITING_FOR_INCREASED_CACHE);
        return AgentResume(dwFlags);
    }

    return S_FALSE;
}

HRESULT CDeliveryAgent::AgentResume(DWORD dwFlags)
{
    return S_OK;
}

STDMETHODIMP CDeliveryAgent::AbortUpdate(DWORD dwFlags)
{
    TraceMsg(TF_THISMODULE, "AbortUpdate at Thread %d", GetCurrentThreadId());

    // Fill in status code if someone else hasn't already
    if (INET_S_AGENT_BASIC_SUCCESS == GetEndStatus())
    {
        if (IsAgentFlagSet(FLAG_WAITING_FOR_INCREASED_CACHE))
        {
            SetEndStatus(INET_E_AGENT_CACHE_SIZE_EXCEEDED);
        }
        else
        {
            SetEndStatus(E_ABORT);
        }
    }

    AddRef();

    // This may release us if the agent cleans itself up
    if (E_PENDING != AgentAbort(dwFlags))
    {
        // Will call "UpdateEnd" if necessary
        CleanUp();
    }

    Release();

    return S_OK;
}

HRESULT CDeliveryAgent::AgentAbort(DWORD dwFlags)
{
    return S_OK;
}

HRESULT CDeliveryAgent::SubscriptionControl(IUnknown *pItem, DWORD dwControl)
{
    if (dwControl & SUBSCRIPTION_AGENT_DELETE)
    {
        // Clean up our cache group
        GROUPID llGroupID;
        ISubscriptionItem *psi=NULL;

        pItem->QueryInterface(IID_ISubscriptionItem, (void **)&psi);
        if (psi)
        {
            if (SUCCEEDED(ReadLONGLONG(psi, c_szPropCrawlGroupID, &llGroupID))
                && (0 != llGroupID))
            {
                if (ERROR_SUCCESS != DeleteUrlCacheGroup(llGroupID, 0, 0))
                {
                    DBG_WARN("Failed to delete subscription cache group!");
                }
            }

            psi->Release();
        }
    }

    return S_OK;
}


#ifdef AGENT_AUTODIAL
HRESULT CDeliveryAgent::OnInetOnline()
{
    HRESULT hr=S_OK;

    if (m_iDialerStatus == DIALER_CONNECTING)
    {
        DBG("Delivery Agent: connection successful, beginning download");

        m_iDialerStatus=DIALER_ONLINE;

        hr = DoStartDownload();
    }

    return hr;
}
#endif

HRESULT CDeliveryAgent::DoStartDownload()
{
    HRESULT hr;

    // Always reset cache browser session. Webcrawler will avoid downloading dups.
    // Reset the cache session to hit the net on urls
    // CUrlDownload will use RESYNCHRONIZE flag if SYNC_MODE is Never
    InternetSetOption(NULL, INTERNET_OPTION_RESET_URLCACHE_SESSION, NULL, 0);

    // Refcount just in case our derived class cleans itself up synchronously, yet
    //  returns failure (cdlagent)
    AddRef();
    
    hr = StartDownload();

    if (FAILED(hr))
    {
        DBG_WARN("DeliveryAgent: StartDownload failed");
        if (GetEndStatus() == INET_S_AGENT_BASIC_SUCCESS)
            SetEndStatus(hr);
        CleanUp();
    }

    Release();

    return hr;
}

#ifdef AGENT_AUTODIAL
HRESULT CDeliveryAgent::OnInetOffline()
{
    DBG("DeliveryAgent: received InetOffline, aborting");

    m_iDialerStatus=DIALER_OFFLINE;

    ASSERT(IsAgentFlagSet(FLAG_BUSY));    // we have send update begin

    SetEndStatus(INET_E_AGENT_CONNECTION_FAILED);

    // we can look at Status from dialer notification here

    AbortUpdate(0);

    return S_OK;
}
#endif // AGENT_AUTODIAL

void CDeliveryAgent::SendUpdateBegin()
{
    ASSERT(!IsAgentFlagSet(FLAG_BUSY));
    ASSERT(m_pAgentEvents);

    if (!IsAgentFlagSet(FLAG_BUSY))
    {
        SetAgentFlag(FLAG_BUSY);

        AddRef();       // Keep an additional reference while "busy"
    }

    // New interface way
    m_pAgentEvents->UpdateBegin(&m_SubscriptionCookie);
}

void CDeliveryAgent::SendUpdateProgress(LPCWSTR pwszURL, long lCurrent, long lMax, long lCurSizeKB)
{
    ASSERT(IsAgentFlagSet(FLAG_BUSY));

    // New interface way
    m_pAgentEvents->UpdateProgress(&m_SubscriptionCookie, lCurSizeKB,
                                        lCurrent, lMax, S_OK, pwszURL);
}

void CDeliveryAgent::SendUpdateEnd()
{
    ASSERT(m_pSubscriptionItem);
    ASSERT(m_pAgentEvents);

    UINT uiRes;
    ISubscriptionItem *pEndItem=NULL;
    LPWSTR pwszEndStatus=NULL;
    TCHAR szEndStatus[MAX_RES_STRING_LEN];
    WCHAR wszEndStatus[MAX_RES_STRING_LEN];

    WriteSCODE(m_pSubscriptionItem, c_szPropStatusCode, GetEndStatus());

    if (SUCCEEDED(GetEndStatus()))
    {
        // Put in end time.
        SYSTEMTIME st;
        DATE dt;

        GetLocalTime(&st);
        if (SystemTimeToVariantTime(&st, &dt))
        {
            // there was no error in GetLocalTime or SystemTimeToVariantTime
            WriteDATE(m_pSubscriptionItem, c_szPropCompletionTime, &dt);
        }
        else
        {
            SetEndStatus(E_FAIL);
        }
    }

    if (GetEndStatus() == INET_S_AGENT_BASIC_SUCCESS)
        SetEndStatus(S_OK);

    switch (GetEndStatus())
    {
    case INET_E_AGENT_MAX_SIZE_EXCEEDED     : uiRes = IDS_AGNT_STATUS_SIZELIMIT; break;
    case INET_E_AGENT_CACHE_SIZE_EXCEEDED   : uiRes = IDS_AGNT_STATUS_CACHELIMIT; break;
    case INET_E_AUTHENTICATION_REQUIRED     : uiRes = IDS_STATUS_AUTHFAILED; break;
    case INET_E_AGENT_CONNECTION_FAILED     : uiRes = IDS_STATUS_DIAL_FAIL; break;
    case E_OUTOFMEMORY                      : uiRes = IDS_STATUS_OUTOFMEMORY; break;
    case E_INVALIDARG                       : uiRes = IDS_STATUS_BAD_URL; break;
    case E_ABORT                            : uiRes = IDS_STATUS_ABORTED; break;
    case S_FALSE                            : uiRes = IDS_STATUS_UNCHANGED; break;
    default:
        if (FAILED(GetEndStatus()))
            uiRes = IDS_STATUS_NOT_OK;
        else
            uiRes = IDS_STATUS_OK;
        break;
    }
    DoCloneSubscriptionItem(m_pSubscriptionItem, NULL, &pEndItem);

    ModifyUpdateEnd(pEndItem, &uiRes);

    // Write returned uiRes string into end report (returned -1 means don't touch it)
    if (uiRes != (UINT)-1)
    {
        if (MLLoadString(uiRes, szEndStatus, ARRAYSIZE(szEndStatus)))
        {
            MyStrToOleStrN(wszEndStatus, ARRAYSIZE(wszEndStatus), szEndStatus);
            if (pEndItem)
                WriteOLESTR(pEndItem, c_szPropStatusString, wszEndStatus);
            WriteOLESTR(m_pSubscriptionItem, c_szPropStatusString, wszEndStatus);
            pwszEndStatus = wszEndStatus;
        }
        else
            WriteEMPTY(m_pSubscriptionItem, c_szPropStatusString);
    }

    // ReportError if our end status is an error
    if (FAILED(GetEndStatus()))
    {
        m_pAgentEvents->ReportError(&m_SubscriptionCookie, GetEndStatus(), pwszEndStatus);
    }

    m_pAgentEvents->UpdateEnd(&m_SubscriptionCookie, 
                    m_lSizeDownloadedKB, GetEndStatus(), pwszEndStatus);

#ifdef AGENTS_AUTODIAL
    // Tell the dialer it can hang up now
    if (m_pConnAgent != NULL)
        NotifyAutoDialer(DIALER_HANGUP);

    m_iDialerStatus = DIALER_OFFLINE;
#endif

    // Check for appropriate behavior on end item. Don't do anything if we're
    //  not a subscription in our own right.
    if (!IsAgentFlagSet(DELIVERY_AGENT_FLAG_NO_BROADCAST))
    {
        if (pEndItem)
            ProcessEndItem(pEndItem);
        else
            ProcessEndItem(m_pSubscriptionItem);
    }

    if (!IsAgentFlagSet(FLAG_HOSTED))
    {
        m_pSubscriptionItem->NotifyChanged();
    }

    SAFERELEASE(pEndItem);

    if (IsAgentFlagSet(FLAG_BUSY))
    {
        ClearAgentFlag(FLAG_BUSY);

        // Release the reference we had to ourself
        Release();
    }
}

// This calls callback and cleans everything up properly
void CDeliveryAgent::SendUpdateNone()
{
    ASSERT(FAILED(GetEndStatus()));  // set this before calling
    ASSERT(!IsAgentFlagSet(FLAG_BUSY));// shouldn't call here if busy

    AddRef();

    if (!IsAgentFlagSet(FLAG_BUSY))
        SendUpdateEnd();

    CleanUp();

    Release();
}

// Process the End Item including all stuff set by the base class
// This has functionality previously in the Tray Agent
// Send email, set gleam, refresh desktop, etc.
HRESULT CDeliveryAgent::ProcessEndItem(ISubscriptionItem *pEndItem)
{
    HRESULT hr;

    if (SUCCEEDED(GetEndStatus()))
    {
        //
        // Special feature for desktop HTML:
        // If we receive an end report with "DesktopComponent=1" in it,
        // let the desktop know that it needs to refresh itself.  We always
        // do this instead of only on "changes detected" because desktop
        // component authors don't want to change their CDFs.
        //
        DWORD dwRet;
        HRESULT hr2 = ReadDWORD(pEndItem, c_szPropDesktopComponent, &dwRet);
        if (SUCCEEDED(hr2) && (dwRet == 1))
        {
            IActiveDesktop *pAD = NULL;
            hr2 = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_IActiveDesktop, (void**)&pAD);
            DBGASSERT(SUCCEEDED(hr2), "Unable to create ActiveDesktop in order to refresh desktop component");
            if (SUCCEEDED(hr2))
            {
                ASSERT(pAD);
                pAD->ApplyChanges(AD_APPLY_FORCE | AD_APPLY_REFRESH | AD_APPLY_BUFFERED_REFRESH);
                pAD->Release();
            }
        }
    }

    //
    // Gleam the Internet Shortcut for the URL if requested.  (EnableShortcutGleam=1)
    // Filter End Reports without changes (S_FALSE)
    //
    if (SUCCEEDED(GetEndStatus()) && (S_FALSE != GetEndStatus()))
    {
        DWORD dwRet;
        hr = ReadDWORD(pEndItem, c_szPropEnableShortcutGleam, &dwRet);
        if (SUCCEEDED(hr) && dwRet)
        {
            LPTSTR strURL = NULL;
            hr = ReadTSTR(pEndItem, c_szPropURL, &strURL);
            if (SUCCEEDED(hr))
            {
                PROPVARIANT propvar;
                PropVariantInit(&propvar);
                hr = IntSiteHelper(strURL, &c_rgPropRead[PROP_FLAGS], &propvar, 1, FALSE);
                if (SUCCEEDED(hr) && (VT_UI4 == propvar.vt))
                {
                    // Set our flag without disturbing the others.
                    propvar.ulVal |= PIDISF_RECENTLYCHANGED;  
                }
                else
                {
                    // Be sure to clear the variant if it wasn't a DWORD.
                    PropVariantClear(&propvar);
                    propvar.vt = VT_UI4;
                    propvar.ulVal = PIDISF_RECENTLYCHANGED;  
                }

                //
                // Update channels (painful).
                //

                hr = ReadDWORD(pEndItem, c_szPropChannel, &dwRet);
                BOOL bChannel = SUCCEEDED(hr) && dwRet;

                //  REARCHITECT -  Once cdfview is fixed, we can fix this.
                
                TCHAR tszChanImgPath[MAX_PATH];
                CHAR szChanImgPath[MAX_PATH];
                CHAR szChanImgHash[MAX_PATH];
                int  iChanImgIndex = 0; // init to keep compiler happy
                UINT uChanImgFlags = 0; // init to keep compiler happy
                int  iChanImgImageIndex = 0; // init to keep compiler happy

                IChannelMgrPriv*   pIChannelMgrPriv = NULL;
                HRESULT            hr2 = E_FAIL;

                if (bChannel)
                {
                    hr2 = GetChannelPath(strURL, tszChanImgPath,
                                         ARRAYSIZE(tszChanImgPath),
                                         &pIChannelMgrPriv);
                    if (SUCCEEDED(hr2))
                    {
                        SHTCharToAnsi(tszChanImgPath, szChanImgPath, ARRAYSIZE(szChanImgPath));
                        hr2 = (pIChannelMgrPriv)->PreUpdateChannelImage(
                                                    szChanImgPath,
                                                    szChanImgHash,
                                                    &iChanImgIndex,
                                                    &uChanImgFlags,
                                                    &iChanImgImageIndex);
                    }
                }

                // Set the gleam in the intsite database
                hr = IntSiteHelper(strURL, &c_rgPropRead[PROP_FLAGS], &propvar, 1, TRUE);
                DBGASSERT(SUCCEEDED(hr), "CTrayAgent::OnNotification - failed to set gleam.");

                if (bChannel && SUCCEEDED(hr2))
                {
                    ASSERT(pIChannelMgrPriv);

                    pIChannelMgrPriv->InvalidateCdfCache();
                    // brilliant - the api requires us to convert their own return value
                    WCHAR wszHash[MAX_PATH];
                    SHAnsiToUnicode(szChanImgHash, wszHash, ARRAYSIZE(wszHash));

                    pIChannelMgrPriv->UpdateChannelImage(
                                                wszHash,
                                                iChanImgIndex,
                                                uChanImgFlags,
                                                iChanImgImageIndex);
                }
                if (pIChannelMgrPriv)
                    pIChannelMgrPriv->Release();
            }
            MemFree(strURL); // Free the string allocated by ReadAnsiSTR().
        }// end setting gleam

        //
        // Send Email to notify the user if requested (EmailNotification=1)
        // NOTE: Updates without changes (S_FALSE) were filtered above.
        //
        hr = ReadDWORD(pEndItem, c_szPropEmailNotf, &dwRet);
        if (SUCCEEDED(hr) && dwRet)
        {
            hr = SendEmailFromItem(pEndItem);
        }
    }

    return S_OK;
}

// Checks the status code after all actions such as authentication and redirections
//  have taken place.
HRESULT CDeliveryAgent::CheckResponseCode(DWORD dwHttpResponseCode)
{
    TraceMsg(TF_THISMODULE, "CDeliveryAgent processing HTTP status code %d", dwHttpResponseCode);

    switch (dwHttpResponseCode / 100)
    {
        case 1 :    DBG("HTTP 1xx response?!?");
        case 2 :
            return S_OK;    // Success

        case 3 :
            if (dwHttpResponseCode == 304)
                return S_OK;    // Not Modified
            SetEndStatus(E_INVALIDARG);
            return E_ABORT;     // Redirection

        case 4 :
            if (dwHttpResponseCode == 401)
            {
                SetEndStatus(INET_E_AUTHENTICATION_REQUIRED);
                return E_ABORT;
            }
            SetEndStatus(E_INVALIDARG);
            return E_ABORT;

        case 5 :
        default:
            SetEndStatus(E_INVALIDARG);
            return E_ABORT;
    }

/*  
    //  Unreachable code
    SetEndStatus(E_FAIL);
    return E_FAIL;

*/
}

//============================================================
//   virtual functions designed to be overridden as necessary
//============================================================

HRESULT CDeliveryAgent::StartOperation()
{
    HRESULT hr = S_OK;

#ifdef AGENT_AUTODIAL
    // We are ready to go. Now we make sure we're actually connected to
    //  the internet and then go for it.
    if (IsAgentFlagSet(DELIVERY_AGENT_FLAG_SILENT_DIAL))
    {
        m_iDialerStatus = DIALER_CONNECTING;

        hr = NotifyAutoDialer(DIALER_START);
    }

    if (SUCCEEDED(hr))
    {
        // Send this whether we're 'dialing' or not
        SendUpdateBegin();
    }
    else
    {
        DBG("NotifyAutoDialer failed, delivery agent aborting.");
        SetEndStatus(E_ACCESSDENIED);
        SendUpdateNone();
        return E_FAIL;
    }

    if (IsAgentFlagSet(DELIVERY_AGENT_FLAG_SILENT_DIAL))
    {
        hr = DoStartDownload();
    }
#else
    SendUpdateBegin();
    hr = DoStartDownload();
#endif

    return hr;
}

HRESULT CDeliveryAgent::ModifyUpdateEnd(ISubscriptionItem *pEndItem, UINT *puiRes)
{
    return S_OK;
}

void CDeliveryAgent::CleanUp()
{
    BOOL fAdded=FALSE;

    if (m_cRef > 0)
    {
        fAdded = TRUE;
        AddRef();
    }

    if (IsAgentFlagSet(FLAG_BUSY))
        SendUpdateEnd();

    SAFERELEASE(m_pAgentEvents);
    SAFERELEASE(m_pSubscriptionItem);

    if (fAdded)
        Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\dialer.cpp ===
#include "private.h"
#include "offline.h"

#undef TF_THISMODULE
#define TF_THISMODULE TF_DIALMON


// prototypes
DIALPROPDATA * InitDialData(void);

//
// uuid for our command target
//
const UUID CGID_ConnCmdGrp = { 0x1dc1fd0, 0xdc49, 0x11d0, {0xaf, 0x95, 0x00, 0xc0, 0x4f, 0xd9, 0x40, 0xbe} };

//
// Registry keys we use to get autodial information
//
                                                                     
// Key name
const TCHAR c_szAutodial[]  = TEXT("EnableAutodial");
const TCHAR c_szProxy[]     = TEXT("ProxyServer");

const TCHAR c_szUnknown[]   = TEXT("<unknown>");

// from schedule.cpp
extern TCHAR szInternetSettings[];
extern TCHAR szProxyEnable[];

// length of general text strings
#define TEXT_LENGTH     200

// our connection agent instance
CConnectionAgent *pAgent = NULL;

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//
//                 Connection Agent class factory helper
//
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

HRESULT CConnectionAgent_CreateInstance(LPUNKNOWN pUnkOuter, IUnknown **ppunk)
{
    IUnknown            *punk, *punkClient = NULL;
    HRESULT             hr;
    CConnClient         *pClient;

    *ppunk = NULL;

    // create new con client instance
    pClient = new CConnClient;

    if(NULL == pClient)
        return E_OUTOFMEMORY;

    // Look for CConnectionAgent in ROT
    hr = GetActiveObject(CLSID_ConnectionAgent, NULL, &punk);
    if (NULL == punk) {
        // Not there - create one
        ASSERT(NULL == pAgent);
        pAgent = new CConnectionAgent;

        if(NULL == pAgent) {
            pClient->Release();
            return E_OUTOFMEMORY;
        }

        // Get an IUnknown on new object
        hr = pAgent->QueryInterface(IID_IUnknown, (LPVOID *)&punk);
        if (FAILED(hr) || NULL == punk) {
            SAFERELEASE(pAgent);
            pClient->Release();
            return E_FAIL;
        }

        // Register new connection agent
        hr = RegisterActiveObject(punk, CLSID_ConnectionAgent,
                    ACTIVEOBJECT_STRONG, &pAgent->m_dwRegisterHandle);
        SAFERELEASE(pAgent);
        if (FAILED(hr))
        {
            DBG_WARN("CConnectionAgentClassFactory RegisterActiveObject failed.");
            pClient->Release();
            punk->Release();
            return hr;
        }
        DBG("New connection agent object created.");
    }
#ifdef DEBUG
    else
    {
        DBG("Using existing connection agent object.");
    }
#endif

    // Now we have pClient and punk.  Tell client who the boss is
    hr = pClient->SetConnAgent(punk);
    punk->Release();
    if(FAILED(hr)) {
        pClient->Release();
        return E_FAIL;
    }

    *ppunk = (IOleCommandTarget *)pClient;

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//
//                          Helper functions
//
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//
//                             Ping Class
//
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// helper stuff
//
#define IS_DIGIT(ch)    InRange(ch, TEXT('0'), TEXT('9'))

void UnloadICMP(void);

long        g_lPingWndReg = 0;
const TCHAR c_szPingWndClass[] = TEXT("PingClass");

#define WM_NAME     (WM_USER)
#define WM_STOP     (WM_USER+1)

class CPing                  
{
protected:
    HANDLE  _hPing;
    HANDLE  _hAsync;
    HWND    _hwnd;
    UINT    _uTimerID;
    BOOL    _fResult;
    UINT    _uTimeoutSec;

    BOOL    EnableAutodial(BOOL fEnable);

public:
    CPing();
    ~CPing();

    BOOL    Init(UINT uTimeoutSec);
    BOOL    PingSite(LPTSTR pszSite);

static LRESULT CPing::WndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

};

CPing::CPing()
{
    _hPing = INVALID_HANDLE_VALUE;
    _hwnd = NULL;
    _hAsync = NULL;
    _uTimeoutSec = 10;
}

CPing::~CPing()
{
    if(_hwnd)
        DestroyWindow(_hwnd);

    if(_hPing)
        IcmpCloseHandle(_hPing);

    UnloadICMP();
}

BOOL
CPing::Init(UINT uTimeoutSec)
{
    // save timeout
    _uTimeoutSec = uTimeoutSec;

    // load ICMP.DLL and get a ping handle
    _hPing = IcmpCreateFile();
    if(INVALID_HANDLE_VALUE == _hPing)
        return FALSE;

    // register window class if necessary
    if(!g_lPingWndReg) {
        g_lPingWndReg++;
        WNDCLASS wc;

        wc.style = 0;
        wc.lpfnWndProc = CPing::WndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = g_hInst;
        wc.hIcon = NULL;
        wc.hCursor = NULL;
        wc.hbrBackground = (HBRUSH)NULL;
        wc.lpszMenuName = NULL;
        wc.lpszClassName = c_szPingWndClass;

        RegisterClass(&wc);
    }

    if(NULL == _hwnd)
        _hwnd = CreateWindow(c_szPingWndClass, NULL, WS_OVERLAPPED,
                CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                NULL, NULL, g_hInst, (LPVOID)this);

    if(NULL == _hwnd)
        return FALSE;

    return TRUE;
}

LRESULT
CPing::WndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    CPing *pping = (CPing *)GetWindowLong(hWnd, GWL_USERDATA);
    LPCREATESTRUCT pcs = NULL;

    switch(Msg) {
    case WM_CREATE:
        pcs = (LPCREATESTRUCT)lParam;
        SetWindowLong(hWnd, GWL_USERDATA, ((LONG) (pcs->lpCreateParams)));
        break;
    case WM_NAME:
        // gethostbyname completed
        if(0 == WSAGETASYNCERROR(lParam))
            pping->_fResult = TRUE;

        // fall through to WM_TIMER

    case WM_TIMER:
        // we ran out of time
        PostMessage(hWnd, WM_STOP, 0, 0);
        break;
    default:
        return DefWindowProc(hWnd, Msg, wParam, lParam);
    }

    return 0;
}

BOOL
CPing::EnableAutodial(BOOL fEnable)
{
    DWORD   dwNewState = 0, dwOldState = 0, dwSize = sizeof(DWORD);
    BOOL    fOldEnable = FALSE;

    if(g_fIsWinNT) {

        //
        // In NT land, 1 means disabled, 0 means enabled
        //

        // Get WinNT autodial state
        _RasGetAutodialParam(RASADP_LoginSessionDisable, &dwOldState, &dwSize);
        if(0 == dwOldState) fOldEnable = TRUE;

        // set new state
        if(FALSE == fEnable) dwNewState = 1;
        _RasSetAutodialParam(RASADP_LoginSessionDisable, &dwNewState, sizeof(DWORD));

    } else {

        //
        // In Win95 land, 1 means enabled, 0 means disabled
        //

        // Get Win95 autodial state
        if(!ReadRegValue(HKEY_CURRENT_USER, szInternetSettings, c_szAutodial,
                    &dwOldState, sizeof(DWORD)))
            dwOldState = 0;
        if(dwOldState) fOldEnable = TRUE;

        // set new state
        if(fEnable) dwNewState = 1;
        WriteRegValue(HKEY_CURRENT_USER, szInternetSettings, c_szAutodial,
            &dwNewState, sizeof(DWORD), REG_BINARY);
    }

    return fOldEnable;
}

BOOL
CPing::PingSite(LPTSTR pszHost)
{
    IPAddr          ipAddress = INADDR_NONE;
    DWORD           dwPingSend = 0xdeadbeef, dwCount;
    WSADATA         wsaData;
    BOOL            fOldState;
    TCHAR           pszWork[1024], *pEnd;
    BYTE            pGetHostBuff[MAXGETHOSTSTRUCT];
    int             iErr;

    // assume failure
    _fResult = FALSE;

    if(INVALID_HANDLE_VALUE == _hPing) {
        DBG("CPing::PingSite no ICMP handle");
        return FALSE;
    }

    // fire up winsock
    if(iErr = WSAStartup(0x0101, &wsaData)) {
        TraceMsg(TF_THISMODULE,"CPing::PingSite WSAStartup failed, iErr=%d", iErr);
        return FALSE;
    }
 
    if(IS_DIGIT(*pszHost)) {
        // try to convert ip address
        ipAddress = inet_addr(pszHost);
    }

    // turn off autodial
    fOldState = EnableAutodial(FALSE);

    if(INADDR_NONE == ipAddress) {

        // strip port (if any) from host name
        lstrcpyn(pszWork, pszHost, ARRAYSIZE(pszWork));
        pEnd = StrChr(pszWork, TEXT(':'));
        if(pEnd)
            *pEnd = 0;

        // start async gethostbyname
        _uTimerID = SetTimer(_hwnd, 1, _uTimeoutSec * 1000, NULL);
        _hAsync = WSAAsyncGetHostByName(_hwnd, WM_NAME, pszWork,
                    (char *)pGetHostBuff, MAXGETHOSTSTRUCT);

        if(_hAsync) {
            // operation started... wait for completion or time out
            MSG msg;
            while(1) {
                GetMessage(&msg, _hwnd, 0, 0);
                if(msg.message == WM_STOP)
                    break;
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            } /* while */

            if(_fResult) {
                // it worked, snarf address
                struct hostent *phe;
                phe = (struct hostent *)pGetHostBuff;
                memcpy(&ipAddress, phe->h_addr, sizeof(IPAddr));
            } else {
                // If we timed out, clean up pending request
                WSACancelAsyncRequest(_hAsync);
            }

#ifdef DEBUG
        } else {
            // operation failed to start
            iErr = WSAGetLastError();
            TraceMsg(TF_THISMODULE, "CPing::PingSite WSAAsyncGetHostByName failed, error=%d", iErr);
#endif
        }

        // kill the timer
        if(_uTimerID) {
            KillTimer(_hwnd, _uTimerID);
            _uTimerID = 0;
        }
    }

    // assume the ping will fail
    _fResult = FALSE;

    if(INADDR_NONE != ipAddress) {
        // try to ping that address
        dwCount = IcmpSendEcho(
            _hPing,
            ipAddress,
            &dwPingSend,           
            sizeof(DWORD),
            NULL,
            pszWork,
            sizeof(pszWork),
            _uTimeoutSec * 1000);

        if(dwCount) {
            // ping succeeded!!
            _fResult = TRUE;
#ifdef DEBUG
        } else {
            // didn't work - spew
            iErr = GetLastError();
            TraceMsg(TF_THISMODULE, "CPing::PingSite IcmpSendEcho failed, error=%x", iErr);
#endif
        }
    }

    // restore autodial
    EnableAutodial(fOldState);

#ifdef DEBUG
    if(_fResult)
        TraceMsg(TF_THISMODULE, "CPing::PingSite ping <%s> success", pszHost);
    else
        TraceMsg(TF_THISMODULE, "CPing::PingSite ping <%s> FAILURE", pszHost);
#endif

    WSACleanup();
    return _fResult;
}

//
// PingProxy - exported function to decide if the proxy is available or not
//
BOOL PingProxy(UINT uTimeoutSec)
{
    BOOL    fRet = FALSE;
    TCHAR   pszProxy[TEXT_LENGTH], *pszHttp, *pszSemi;
    DWORD   dwValue;

    // check for proxy enabled
    if(ReadRegValue(HKEY_CURRENT_USER, szInternetSettings, szProxyEnable,
            &dwValue, sizeof(DWORD))) {
        if(0 == dwValue)
            return FALSE;
    }

    // proxy is enabled in registry.  Ping it to see if it's around.
    if(ReadRegValue(HKEY_CURRENT_USER, szInternetSettings, c_szProxy,
            pszProxy, TEXT_LENGTH)) {

        // if there's an '=' in the proxy string, we'll look for the http= proxy
        if(NULL != StrChr(pszProxy, '=')) {
            pszHttp = StrStrI(pszProxy, TEXT("http="));
            if(NULL == pszHttp)
                // don't understand proxy string
                return FALSE;
            pszHttp += 5;       // 5 chars in "http="

            // remove following entries - they're separated by ;
            pszSemi = StrChr(pszHttp, ';');
            if(pszSemi)
                *pszSemi = 0;
        } else {
            pszHttp = pszProxy;
        }

        // got a proxy, crack the host name out of it
        TCHAR *pszPingSite;
        URL_COMPONENTS comp;
        ZeroMemory(&comp, sizeof(comp));
        comp.dwStructSize = sizeof(comp);
        comp.dwHostNameLength = 1;

        if(InternetCrackUrlA(pszHttp, 0, 0, &comp) && (comp.nScheme != INTERNET_SCHEME_UNKNOWN)) {
            pszPingSite = comp.lpszHostName;
            pszPingSite[comp.dwHostNameLength] = 0;
        } else {
            pszPingSite = pszHttp;
        }

        // ping it
        CPing ping;
        if(ping.Init(uTimeoutSec))
            fRet = ping.PingSite(pszPingSite);
    }

    return fRet;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//
//                      Connection Client object
//
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// Constructor / Destructor
//
CConnClient::CConnClient()
{
    m_cRef = 1;
    m_poctAgent = NULL;
    m_pReport = NULL;
    m_State = CLIENT_NEW;
    m_bstrURL = NULL;
}

//////////////////////////////////////////////////////////////////////////

//
// IUnknown members
//
STDMETHODIMP CConnClient::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    // Validate requested interface
    if ((IID_IUnknown == riid) ||
        (IID_INotificationSink == riid))
    {
        *ppv=(INotificationSink*)this;
    } else if(IID_IOleCommandTarget == riid) {
        *ppv=(IOleCommandTarget*)this;
    } else {
        return E_NOINTERFACE;
    }

    ((LPUNKNOWN)*ppv)->AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG) CConnClient::AddRef(void)
{
    TraceMsg(TF_THISMODULE, "CConnClient::Addref (%08x) m_cRef=%d", this, m_cRef+1);
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CConnClient::Release(void)
{
    TraceMsg(TF_THISMODULE, "CConnClient::Release (%08x) m_cRef=%d", this, m_cRef-1);
    if( 0L != --m_cRef )
        return m_cRef;

    DBG("CConClient::Release Bye Bye");

    // Make sure we're disconnected
    Disconnect();

    m_poctAgent->Release();

    if(m_bstrURL)
        SysFreeString(m_bstrURL);

    delete this;
    return 0L;
}

//////////////////////////////////////////////////////////////////////////

//
// CConClient helper functions
//
HRESULT CConnClient::SetConnAgent(IUnknown *punk)
{
    return punk->QueryInterface(IID_IOleCommandTarget, (void **)&m_poctAgent);
}

HRESULT CConnClient::Connect()
{
    HRESULT     hr;
    VARIANTARG  vin, vout;

    m_State = CLIENT_CONNECTING;

    // tell agent we want to connect
    vin.vt = VT_UNKNOWN;
    vin.punkVal = (IOleCommandTarget *)this;
    VariantInit(&vout);
    hr = m_poctAgent->Exec(&CGID_ConnCmdGrp, AGENT_CONNECT, 0, &vin, &vout);
    if(SUCCEEDED(hr)) {
        ASSERT(vout.vt == VT_I4);
        m_iCookie = vout.lVal;
    }

    return hr;
}

HRESULT CConnClient::Disconnect()
{
    HRESULT     hr;
    VARIANTARG  vin;

    if(CLIENT_DISCONNECTED == m_State)
        return S_OK;

    m_State = CLIENT_DISCONNECTED;

    // tell agent we want to disconnect
    vin.vt = VT_I4;
    vin.ulVal = m_iCookie;
    hr = m_poctAgent->Exec(&CGID_ConnCmdGrp, AGENT_DISCONNECT, 0, &vin, NULL);

    // done with report pointer
    SAFERELEASE(m_pReport);

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// INotificationSink members
//
STDMETHODIMP CConnClient::OnNotification(
        LPNOTIFICATION         pNotification,
        LPNOTIFICATIONREPORT   pNotificationReport,
        DWORD                  dwReserved
        )
{
    NOTIFICATIONTYPE    nt;
    HRESULT             hr = S_OK;

    hr = pNotification->GetNotificationInfo(&nt, NULL,NULL,NULL,0);

    if(FAILED(hr)) {
        DBG_WARN("CConnClient::OnNotification failed to get not type!");
        return E_INVALIDARG;
    }

    if(IsEqualGUID(nt, NOTIFICATIONTYPE_AGENT_START)) {

        DBG("CConnClient::OnNotification AGENT_START");

        if(CLIENT_NEW == m_State) {

            // Must have a report pointer!
            if(NULL == pNotificationReport) {
                DBG("CConnClient::OnNotification no report on START!");
                return E_UNEXPECTED;
            }

            // save report pointer
            TraceMsg(TF_THISMODULE, "CConClient::OnNotification (%08x) addreffing report pointer", this);
            m_pReport = pNotificationReport;
            m_pReport->AddRef();

            // get the URL
            hr = ReadBSTR(pNotification, NULL, c_szPropURL, &m_bstrURL);

            // convert to ansi and log url connection request
            TCHAR pszURL[INTERNET_MAX_URL_LENGTH];

            MyOleStrToStrN(pszURL, INTERNET_MAX_URL_LENGTH, m_bstrURL);
            LogEvent("Connecting for <%s>", pszURL);

            // Tell agent to connect
            Connect();

        } else {
            DBG("CConnClient::OnNotification unexpected connect");
            return E_UNEXPECTED;
        }

    } else if(IsEqualGUID(nt, NOTIFICATIONTYPE_TASKS_COMPLETED)) {
        DBG("CConnClient::OnNotification TASKS_COMPLETED");

        // convert url to ansi
        TCHAR pszURL[INTERNET_MAX_URL_LENGTH];
        MyOleStrToStrN(pszURL, INTERNET_MAX_URL_LENGTH, m_bstrURL);

        switch(m_State) {
        case CLIENT_CONNECTING:
            m_State = CLIENT_ABORT;

            // log connection abort
            LogEvent("Aborting connection for <%s>", pszURL);

            break;
        case CLIENT_CONNECTED:
            // log disconnect
            LogEvent("Disconnecting for <%s>", pszURL);

            Disconnect();
            break;
        default:
            DBG("CConnClient::OnNotification unexpected disconnect");
            return E_UNEXPECTED;
        }
    } else {
        DBG("CConnClient::OnNotification unknown type");
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// IOleCommandTarget members
//
STDMETHODIMP CConnClient::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds,
                                    OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    if (IsEqualGUID(*pguidCmdGroup, CGID_ConnCmdGrp)) {
        return S_OK;
    }

    return OLECMDERR_E_UNKNOWNGROUP;
}

STDMETHODIMP CConnClient::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
                             DWORD nCmdexecopt, VARIANTARG *pvaIn,
                             VARIANTARG *pvaOut)
{
    HRESULT hr = E_NOTIMPL;

    if (pguidCmdGroup &&  IsEqualGUID(*pguidCmdGroup, CGID_ConnCmdGrp))
    {
        switch(nCmdID) {
        case AGENT_NOTIFY:
            if(VT_ERROR == pvaIn->vt) {
                hr = DeliverProgressReport(pvaIn->scode, NULL);
            } else {
                hr = E_INVALIDARG;
            }
            break;
        }
    }
    
    return hr;
}

//////////////////////////////////////////////////////////////////////////

//
// Other methods
//
HRESULT CConnClient::DeliverProgressReport(SCODE scode, BSTR bstrErrorText)
{
    HRESULT             hr = S_OK;
    INotificationMgr    *pMgr;
    INotification       *pStatus;

    switch(m_State) {
    case CLIENT_CONNECTING:
        // Get Notification manager
        hr = CoCreateInstance(CLSID_StdNotificationMgr, NULL,
                CLSCTX_INPROC_SERVER, IID_INotificationMgr, (void**)&pMgr);
        if(FAILED(hr))
            return hr;

        // create notification to deliver
        hr = pMgr->CreateNotification(NOTIFICATIONTYPE_PROGRESS_REPORT,
            (NOTIFICATIONFLAGS)0, NULL, &pStatus, 0);
        pMgr->Release();
        if(FAILED(hr))
            return hr;

        // stick result and string in progress report
//      WriteOLESTR(pStatus, NULL, c_szPropStatusString, bstrErrorText);
        WriteSCODE(pStatus, NULL, c_szPropStatusCode, scode);

        // deliver notification
        hr = m_pReport->DeliverUpdate(pStatus, 0, 0);
        pStatus->Release();

        if(SUCCEEDED(scode)) {
            m_State = CLIENT_CONNECTED;
        } else {
            Disconnect();
        }
        break;
    case CLIENT_ABORT:
        Disconnect();
        break;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//
//                          Connection agent
//
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// Constructor and destructor
//
CConnectionAgent::CConnectionAgent()
{
    m_pData = NULL;
    m_cRef = 1;
    m_dwRegisterHandle = 0;

    m_lConnectionCount = 0;
    m_dwFlags = 0;
    m_hdpaClient = NULL;

    // Get the notification manager
    m_pMgr = NULL;
    CoCreateInstance(CLSID_StdNotificationMgr, NULL,
                CLSCTX_INPROC_SERVER, IID_INotificationMgr, (void**)&m_pMgr);
}

CConnectionAgent::~CConnectionAgent()
{
    SAFERELEASE(m_pMgr);
    SAFELOCALFREE(m_pData);

    if(IsFlagSet(m_dwFlags, CA_LOADED_RAS))
        UnloadRasDLL();
}

//
// Clean - clean up strong lock and ref count
//
void
CConnectionAgent::Clean(void)
{
    DWORD   dwHandle = m_dwRegisterHandle;
    int     iCurReport, i;
    CLIENTINFO *pClient;

    // don't do anything if there are outstanding connections
    if(m_lConnectionCount)
        return;

    // clean up client dpa
    if(m_hdpaClient) {
        iCurReport = DPA_GetPtrCount(m_hdpaClient);
        for(i=0; i<iCurReport; i++) {
            pClient = (CLIENTINFO *)(DPA_GetPtr(m_hdpaClient, i));
            if(pClient)
                delete pClient;
        }
        DPA_Destroy(m_hdpaClient);
        m_hdpaClient = NULL;
    }

    // release our strong registration
    DBG("CConnectionAgent::Clean revoking connection agent object");
    m_dwRegisterHandle = 0;
    RevokeActiveObject(dwHandle, NULL);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// Connect - entry point to connect
//
void
CConnectionAgent::Connect(void)
{
    BOOL            fDone = FALSE;
    TCHAR           pszText[TEXT_LENGTH];

    //
    // increment connection count
    //
    m_lConnectionCount ++;
    TraceMsg(TF_THISMODULE, "CConnectionAgent::Connect ref count now %d", m_lConnectionCount);

    //
    // Store offline state if we haven't already and go online
    //
    if(FALSE == IsFlagSet(m_dwFlags, CA_OFFLINE_STATE_READ)) {

        if(IsGlobalOffline())
            SetFlag(m_dwFlags, CA_OFFLINE);

        // make sure we're online
        SetGlobalOffline(FALSE);

        SetFlag(m_dwFlags, CA_OFFLINE_STATE_READ);
    }

    //
    // check for pending dialup connection
    //
    if(IsFlagSet(m_dwFlags, CA_CONNECTING_NOW)) {
        // already working on a connection
        DBG("CConnectionAgent::Connect already trying to connect");
        return;
    }

    //
    // check to see if we can dial to get a connection
    //
    if(FALSE == IsDialPossible()) {

        //
        // can't dial - better have a direct connection
        //
        DBG("CConnectionAgent::Connect guessing connected");
        if(!MLLoadString(IDS_DIAL_DIRECT, pszText, TEXT_LENGTH))
            lstrcpy(pszText, "direct");
        Notify(S_OK, pszText);
        return;
    }

    //
    // check for an existing dialup connection
    //

    if(FALSE == IsFlagSet(m_dwFlags, CA_LOADED_RAS)) {
        SetFlag(m_dwFlags, CA_LOADED_RAS);
        LoadRasDLL();
    }

    if(IsDialExisting()) {
        DBG("CConnectionAgent::Connect already connected");
        if(!MLLoadString(IDS_DIAL_ALREADY_CONNECTED, pszText, TEXT_LENGTH))
            lstrcpy(pszText, "success");
        Notify(S_OK, pszText);
        return;
    }

#ifdef COOL_MODEM_ACTION
    // since we assume connected for direct connect, no proxy check is
    // necessary.  If this check is put in, cool behavior results: It uses
    // the proxy server if it can find it, otherwise it autodials.

    // Autodial needs to be made consistant with this before it gets turned
    // on

    //
    // check for a proxy connection
    //
    if(PingProxy(5)) {
        // Dial is possible but proxy is available! Turn off autodial and
        // flag to turn it back on when we're done
        CPing::EnableAutodial(FALSE);
        SetFlag(m_dwFlags, CA_AUTODIAL_OFF);

        // Using proxy
        DBG("CConnectionAgent::Connect using proxy");
        if(!MLLoadString(IDS_DIAL_PROXY, pszText, TEXT_LENGTH))
            lstrcpy(pszText, "proxy");
        Notify(S_OK, pszText);
        return;
    }
#endif

    /////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////

    //
    // Ensure we can dial without user intervention
    //
    BOOL fContinue = TRUE;

    if(SHRestricted2W(REST_NoUnattendedDialing, NULL, 0))
        // dialing restricted
        fContinue = FALSE;

    //
    // No existing connection but we can dial.  do it now.
    //
    SetFlag(m_dwFlags, CA_CONNECTING_NOW);

    
    DWORD dwRetCode;
    if(fContinue)
    {
        dwRetCode = ERROR_SUCCESS;
        if(!InternetAutodial((INTERNET_AUTODIAL_FORCE_ONLINE | 
                                        INTERNET_AUTODIAL_FORCE_UNATTENDED | 
                                        INTERNET_AUTODIAL_FAILIFSECURITYCHECK), 0))
        {
            dwRetCode = GetLastError();
        }
                
    }
                                        
    if (fContinue && (ERROR_SUCCESS == dwRetCode)) {
        // successful connection made
        SetFlag(m_dwFlags, CA_DIALED);
        if(!MLLoadString(IDS_DIAL_SUCCESS, pszText, TEXT_LENGTH))
            lstrcpy(pszText, "success");
        Notify(S_OK, pszText);
    } else {
        //UINT uID;
        HRESULT hrDialResult;
        // unable to dial
        if(ERROR_INTERNET_FAILED_DUETOSECURITYCHECK == dwRetCode)
        {
            hrDialResult = E_ABORT;
            // uID = IDS_STRING_E_SECURITYCHECK; not needed - since MLLoadString below is commented out
        }
        else
        {
            hrDialResult = E_INVALIDARG;
            // uID = IDS_STRING_E_CONFIG;not needed - since MLLoadString below is commented out
        }
        
     // if(!MLLoadString(uID, pszText, TEXT_LENGTH)) // Don't bother : This is ignored anyway
        lstrcpy(pszText, "Connection Not Made");
        Notify(hrDialResult, pszText);
    }

    ClearFlag(m_dwFlags, CA_CONNECTING_NOW);
}

//
// Disconnect - entry point to disconnect
//
void
CConnectionAgent::Disconnect(void)
{
    // If we're the last connection, hang up
    m_lConnectionCount --;
    TraceMsg(TF_THISMODULE, "CConnectionAgent::Disconnect ref count now %d", m_lConnectionCount);

    if(0 == m_lConnectionCount) {

        // If we dialed this connection, hang it up
        if(IsFlagSet(m_dwFlags, CA_DIALED)) {
            LogEvent(TEXT("EVT: Hanging up"));
            InternetAutodialHangup(0);
        }

#ifdef COOL_MODEM_ACTION
        if(IsFlagSet(m_dwFlags, CA_AUTODIAL_OFF)) {
            // we turned autodial off - turn it back on
            CPing::EnableAutodial(TRUE);

            // tell wininet we've changed it
            InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
        }
#endif

        // restore original offline state
        SetGlobalOffline(IsFlagSet(m_dwFlags, CA_OFFLINE));

        // revoke our object
        Clean();
    }
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// IsDialPossible - search around and make sure all necessary info
// is available to connect.  If fQuiet is false, may bring up dialogs
// to get necessary info
//
BOOL
CConnectionAgent::IsDialPossible()
{
    BOOL    fPossible = TRUE;

    // Refresh data in case properties has been up and changed it
    if(m_pData) 
        MemFree(m_pData);
    m_pData = InitDialData();

    if(NULL == m_pData)
        return FALSE;

    if(FALSE == m_pData->fEnabled)
        // not enabled
        fPossible = FALSE;
    if(!m_pData->pszConnection[0])
        // no connection
        fPossible = FALSE;

    return fPossible;
}


//
// IsDialExisting - check to see if there's an existing dialup connection
//                  that we didn't do
//

#define MAX_CONNECTION 8

BOOL
CConnectionAgent::IsDialExisting(void)
{
    TCHAR   pszConn[RAS_MaxEntryName+1];
    RASCONN pRasCon[MAX_CONNECTION]; 
    DWORD   dwSize = MAX_CONNECTION * sizeof(RASCONN), dwConn, dwCur;
    HKEY    hkeyRoot = HKEY_CURRENT_USER;

    // read internet connectoid from registry
    if(!ReadRegValue(hkeyRoot, c_szRASKey, c_szProfile, pszConn,
            RAS_MaxEntryName+1)) {
        DBG("CConnectionAgent::IsDialExisting unable to read internet connectoid");
        return FALSE;
    }

    // have Ras enumerate existing connections 
    pRasCon[0].dwSize = sizeof(RASCONN);
    if(_RasEnumConnections(pRasCon, &dwSize, &dwConn)) {
        DBG("CConnectionAgent::IsDialExisting RasEnumConnections failed");
        return FALSE;
    }

    // do any of them match our internet connectoid?
    for(dwCur=0; dwCur<dwConn; dwCur++) {
        if(0 == lstrcmp(pszConn, pRasCon[dwCur].szEntryName))
            return TRUE;
    }

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// IUnknown members
//
STDMETHODIMP CConnectionAgent::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    // Validate requested interface
    if ((IID_IUnknown == riid) ||
        (IID_IOleCommandTarget == riid))
    {
        *ppv=(IOleCommandTarget*)this;
    } else {
        return E_NOINTERFACE;
    }

    ((LPUNKNOWN)*ppv)->AddRef();
    return NOERROR;
}


STDMETHODIMP_(ULONG) CConnectionAgent::AddRef(void)
{
    TraceMsg(TF_THISMODULE, "CConnectionAgent::Addref m_cRef=%d", m_cRef+1);
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CConnectionAgent::Release(void)
{
    TraceMsg(TF_THISMODULE, "CConnectionAgent::Release m_cRef=%d", m_cRef-1);
    if( 0L != --m_cRef )
        return m_cRef;

    DBG("CConnectionAgent::Release Bye Bye");

    delete this;
    return 0L;
}


//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// IOleCommandTarget members
//
STDMETHODIMP CConnectionAgent::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds,
                                    OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    if (IsEqualGUID(*pguidCmdGroup, CGID_ConnCmdGrp))
    {
        // We like connection agent commands
        return S_OK;
    }

    return OLECMDERR_E_UNKNOWNGROUP;
}

STDMETHODIMP CConnectionAgent::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
                             DWORD nCmdexecopt, VARIANTARG *pvaIn,
                             VARIANTARG *pvaOut)
{
    HRESULT     hr;
    CLIENTINFO  *pInfo;
    int         iIndex;

    if (pguidCmdGroup && IsEqualGUID(*pguidCmdGroup, CGID_ConnCmdGrp))
    {
        switch(nCmdID) {
        case AGENT_CONNECT:
            // validate input arguments
            if(VT_UNKNOWN != pvaIn->vt || NULL == pvaOut)
                return E_INVALIDARG;

            // create dpa if necessary
            if(NULL == m_hdpaClient)
                m_hdpaClient = DPA_Create(0);
            if(NULL == m_hdpaClient)
                return E_OUTOFMEMORY;

            // create and initialize new clientinfo struct
            pInfo = new CLIENTINFO;
            if(NULL == pInfo)
                return E_OUTOFMEMORY;
            pInfo->dwFlags = 0;
            hr = pvaIn->punkVal->QueryInterface(IID_IOleCommandTarget, (void **)&pInfo->poctClient);
            if(FAILED(hr))
                return hr;

            // insert struct into dpa and return index
            iIndex = DPA_InsertPtr(m_hdpaClient, DPA_APPEND, pInfo);
            if(iIndex < 0) {
                delete pInfo;
                return E_OUTOFMEMORY;
            } else {
                pvaOut->vt = VT_I4;
                pvaOut->ulVal = iIndex;
            }

            // connect
            Connect();
            return S_OK;

        case AGENT_DISCONNECT:
            // validate input parameters
            if(VT_I4 != pvaIn->vt)
                return E_INVALIDARG;

            // mark client record as disconnected
            pInfo = (CLIENTINFO *)DPA_GetPtr(m_hdpaClient, pvaIn->lVal);
            if(pInfo) {
                pInfo->dwFlags |= CLIENT_DISCONNECT;
                SAFERELEASE(pInfo->poctClient);
            }

            // disconnect
            Disconnect();
            return S_OK;
        }
    }
    
    return E_NOTIMPL;
}


//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

// 
// Notify all waiting agents of success or failure of dial attempt
//
void CConnectionAgent::Notify(HRESULT hrDialResult, TCHAR *pszErrorText)
{
    CLIENTINFO          *pClient;
    int                 i, iCurReport;
    //WCHAR               pwszStatus[TEXT_LENGTH];
    VARIANTARG          vin;

    // We're done connecting
    ClearFlag(m_dwFlags, CA_CONNECTING_NOW);

    // Create the notifications to send
    if(S_OK == hrDialResult) {
        DBG("CConnectionAgent::Notify sending ONLINE");
        LogEvent(TEXT("EVT: Successful connection"));
    } else {
        DBG("CConnectionAgent::Notify sending OFFLINE");
        LogEvent(TEXT("EVT: Unsuccessful connection - hr=%08x"), hrDialResult);
    }

    // convert string to bstr
    // MyStrToOleStrN(pwszStatus, TEXT_LENGTH, pszErrorText);

    // build exec paramaters
    vin.vt = VT_ERROR;
    vin.scode = hrDialResult;

    // Send it to all the clients
    iCurReport = DPA_GetPtrCount(m_hdpaClient);
    for(i=0; i<iCurReport; i++) {
        pClient = (CLIENTINFO *)(DPA_GetPtr(m_hdpaClient, i));
        if(pClient && 0 == pClient->dwFlags) {
            pClient->poctClient->Exec(&CGID_ConnCmdGrp, AGENT_NOTIFY, 0, 
                &vin, NULL);
            //  This can get blown away out from under us.
            if (m_hdpaClient)
            {
                pClient->dwFlags |= CLIENT_NOTIFIED;
                SAFERELEASE(pClient->poctClient);
            }
        }
    }

    // if we're disconnected, clean ourselves up
    Clean();
}

BOOL
GetLogonInfo(DIALPROPDATA *pData)
{
    RASDIALPARAMS   dp;
    DWORD           dwRes;
    BOOL            fPassword = FALSE;

    // initially set name/password/domain to null
    pData->pszUsername[0] = 0;
    pData->pszPassword[0] = 0;
    pData->pszDomain[0] = 0;

    // if there's no connection, we're done
    if(0 == pData->pszConnection[0])
        return FALSE;

    // Try and get name/password/domain from Ras
    memset(&dp, 0, sizeof(RASDIALPARAMS));
    dp.dwSize = sizeof(RASDIALPARAMS);
    lstrcpyn(dp.szEntryName, pData->pszConnection, ARRAYSIZE(dp.szEntryName));
    dwRes = _RasGetEntryDialParams(NULL, &dp, &fPassword);
    if(fPassword && 0 == dwRes) {
        // Copy ras information to pData.
        lstrcpyn(pData->pszUsername, dp.szUserName, ARRAYSIZE(pData->pszUsername));
        lstrcpyn(pData->pszPassword, dp.szPassword, ARRAYSIZE(pData->pszPassword));
        lstrcpyn(pData->pszDomain, dp.szDomain, ARRAYSIZE(pData->pszDomain));
    }

    return fPassword;
}

DIALPROPDATA * InitDialData(void)
{
    DIALPROPDATA *  pData = (DIALPROPDATA *)MemAlloc(LPTR, sizeof(DIALPROPDATA));
    HKEY            hkeyRoot = HKEY_CURRENT_USER;
    BOOL            fGotInfo = FALSE;
    DWORD           dwValue;

    if(NULL == pData)
        return NULL;

    // Fix fEnabled from registry   HKCU\...\Internet Settings\EnableAutodial
    ReadRegValue(hkeyRoot, szInternetSettings, c_szAutodial, &dwValue, sizeof(DWORD));
    if(dwValue == 1) {
        pData->fEnabled = TRUE;
    }

    // Fix fUnattended from registry   HKCU\...\Internet Settings\EnableUnattended
    ReadRegValue(hkeyRoot, szInternetSettings, c_szEnable, &dwValue, sizeof(DWORD));
    if(dwValue == 1) {
        pData->fUnattended = TRUE;
    }

    // Try to find a connection     HKCU\Remote Access\Internet Profile
    if(ReadRegValue(hkeyRoot, c_szRASKey, c_szProfile, pData->pszConnection,
        RAS_MaxEntryName+1)) {
        GetLogonInfo(pData);
    }
            
    return pData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\delagent.h ===
//
// Delivery Agents base class

#ifndef _DELAGENT_H
#define _DELAGENT_H

#include "offline.h"

#define INET_S_AGENT_BASIC_SUCCESS           _HRESULT_TYPEDEF_(0x000C0FFEL)

class CDeliveryAgent :  public ISubscriptionAgentControl,
                        public IShellPropSheetExt,
#ifdef UNICODE
                        public IExtractIconA,
#endif
                        public IExtractIcon,
                        public ISubscriptionAgentShellExt
{
private:
// Data for our OLE support
    ULONG           m_cRef;

#ifdef AGENT_AUTODIAL
    enum DIALER_STATUS { DIALER_OFFLINE, DIALER_CONNECTING, DIALER_ONLINE };
    DIALER_STATUS   m_iDialerStatus;
#endif

    enum {
        FLAG_BUSY          =0x00010000,   // addrefed ourselves; between begin & end reports
        FLAG_PAUSED        =0x00020000,   // We are paused
        FLAG_OPSTARTED     =0x00040000,   // We've entered StartOperation
    };

    // Derived agents can use high 8 bits of this field
    DWORD       m_dwAgentFlags;

    void        SendUpdateBegin();
    void        SendUpdateEnd();
    HRESULT     ProcessEndItem(ISubscriptionItem *pEndItem);


protected:
    // Upper 16 bits allowable here
    enum    {
        FLAG_HOSTED        =0x00100000,     // hosted by another delivery agent
        FLAG_CHANGESONLY   =0x00200000,     // We're in "Changes Only" mode
        FLAG_WAITING_FOR_INCREASED_CACHE = 0x00400000, // Special paused state
    };

    POOEBuf         m_pBuf;
    HPROPSHEETPAGE  m_hPage[MAX_WC_AGENT_PAGES];

    ISubscriptionAgentEvents *m_pAgentEvents;
    ISubscriptionItem        *m_pSubscriptionItem;
    
    SUBSCRIPTIONCOOKIE      m_SubscriptionCookie;

    long        m_lSizeDownloadedKB;    // Size downloaded in KB

    SCODE       m_scEndStatus;

    void        SendUpdateNone();   // Call from StartOperation if we won't be doing anything

    void        SendUpdateProgress(LPCWSTR pwszURL, long lProgress, long lMax, long lCurSizeKB=-1);

    BOOL        IsAgentFlagSet(int iFlag) { return (m_dwAgentFlags & iFlag); }
    void        ClearAgentFlag(int iFlag) { m_dwAgentFlags &= ~iFlag; }
    void        SetAgentFlag(int iFlag) { m_dwAgentFlags |= iFlag; }
    
    HRESULT     CheckResponseCode(DWORD dwHttpResponseCode);    // Also sets EndStatus. E_ABORT on error.

//  DIALER_STATUS GetDialerStatus() { return m_iDialerStatus; }
    void          SetEndStatus(SCODE sc) { m_scEndStatus = sc; }

    virtual ~CDeliveryAgent();

public:
    CDeliveryAgent();

    BOOL        GetBusy() { return IsAgentFlagSet(FLAG_BUSY); }
    BOOL        IsPaused() { return IsAgentFlagSet(FLAG_PAUSED); }

    SCODE       GetEndStatus() { return m_scEndStatus; }

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **punk);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ISubscriptionAgentControl members
    STDMETHODIMP    StartUpdate(IUnknown *pItem, IUnknown *punkAdvise);
    STDMETHODIMP    PauseUpdate(DWORD dwFlags);
    STDMETHODIMP    ResumeUpdate(DWORD dwFlags);
    STDMETHODIMP    AbortUpdate(DWORD dwFlags);
    STDMETHODIMP    SubscriptionControl(IUnknown *pItem, DWORD dwControl);   // Called on delete

    // IShellPropSheetExt members
    STDMETHODIMP    AddPages(LPFNADDPROPSHEETPAGE, LPARAM);
    STDMETHODIMP    ReplacePage(UINT, LPFNADDPROPSHEETPAGE, LPARAM);

    // ISubscriptionAgentShellExt
    STDMETHODIMP    Initialize(SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                               LPCWSTR pwszURL, LPCWSTR pwszName, 
                               SUBSCRIPTIONTYPE subsType);
    STDMETHODIMP    RemovePages(HWND hdlg);
    STDMETHODIMP    SaveSubscription();
    STDMETHODIMP    URLChange(LPCWSTR pwszNewURL);

#ifdef UNICODE
    //  IExtractIconA
    STDMETHODIMP    GetIconLocation(UINT uFlags, LPSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags);
    STDMETHODIMP    Extract(LPCSTR pszFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize);
#endif

    //  IExtractIconT
    STDMETHODIMP    GetIconLocation(UINT uFlags, LPTSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags);
    STDMETHODIMP    Extract(LPCTSTR pszFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize);

private:
    // Functions we provide common implementations for
    HRESULT DoStartDownload();

#ifdef AGENT_AUTODIAL
    HRESULT NotifyAutoDialer();

    HRESULT OnInetOnline();
    HRESULT OnInetOffline();
#endif

protected:
    // Virtual functions for our derived classes to override as necessary
    // We provide implementations which should be called after processing
    virtual HRESULT     AgentPause(DWORD dwFlags);
    virtual HRESULT     AgentResume(DWORD dwFlags);
    virtual HRESULT     AgentAbort(DWORD dwFlags);

    virtual HRESULT     ModifyUpdateEnd(ISubscriptionItem *pEndItem, UINT *puiRes);

    virtual HRESULT     StartOperation();       // connects to internet
    virtual HRESULT     StartDownload() = 0;    // we just got connected
    virtual void        CleanUp();
};

#endif // _DELAGENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\dialmon.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//      DIALMON.H - central header file for dial monitor app
//

//      HISTORY:
//      
//      4/18/95         jeremys         Created.
//

#ifndef _DIALMON_H_
#define _DIALMON_H_

#include <regstr.h>

// We need winver 4.00 so ras doesn't puke on our new structure sizes in
// RasEnumConnections.
#undef WINVER
#define WINVER 0x400
#include <ras.h>
#include <raserror.h>

// how to tell dialmon that something is going on
void IndicateDialmonActivity(void);

// give user 30 seconds to respond to dialog 
#define DISCONNECT_DLG_COUNTDOWN        30      

// truncate and add "..." if connectoid name longer than 20 characters
#define MAX_CONNECTOID_DISPLAY_LEN      50      

// private message sent to disconnect dialog to dismiss it
#define WM_QUIT_DISCONNECT_DLG          WM_USER+50

// sizes of various unknown things
#define MAX_RES_LEN                     255
#define DEF_CONN_BUF_SIZE               4096

// class name used for dial monitoring
#define AUTODIAL_MONITOR_CLASS_NAME     "MS_AutodialMonitor"

// max ras connections we care about
#define MAX_CONNECTION                  8

// forward declaration
class BUFFER;

///////////////////////////////////////////////////////////////////////////
//
// CDialMon class definition
//
///////////////////////////////////////////////////////////////////////////

class CDialMon
{
private:
    BOOL        _fInDisconnectFunction; // prevent dialog reentrancy
    DWORD       _dwTimeoutMins;         // timeout value, in minutes
    DWORD       _dwElapsedTicks;        // elapsed ticks with no activity
    BOOL        _fNoTimeout;            // monitor idle or just exit?
    BOOL        _fDisconnectOnExit;
    BOOL        _fConnected;
    TCHAR       _pszConnectoidName[RAS_MaxEntryName+1];   
                                        // name of connectoid of interest
    UINT_PTR    _uIdleTimerID;          // timer id on parent window
    HWND        _hwndDialmon;

public:
    HWND        _hDisconnectDlg;

    CDialMon();
    ~CDialMon();

    void        OnSetConnectoid(BOOL fNoTimeout);
    void        OnActivity(void);
    void        OnTimer(UINT_PTR uTimerID);
    void        OnExplorerExit();

    void        ResetElapsedTicks(){ _dwElapsedTicks = 0; }
    
    // Set DEBUG_KV to 1 here if you need to test hangup logic 
    // without actually having a dailup connection.
    //#define DEBUG_KV 1
 #ifdef DEBUG_KV
    // wrapper over private fn. StartMonitoring when we need to debug without 
    // actually having a dial-up connection.
    void        kvStartMonitoring(){  StartMonitoring(); }
 #endif
                
private:        
    BOOL        StartMonitoring(void);
    void        StopMonitoring(void);
    INT_PTR     StartIdleTimer(void);
    void        StopIdleTimer(void);
    void        CheckForDisconnect(BOOL fTimer);
    BOOL        PromptForDisconnect(BOOL fTimer, BOOL *pfDisconnectDisabled);
    BOOL        RefreshTimeoutSettings(void);
    BOOL        LoadRNADll(void);
    void        UnloadRNADll(void);
};

// structure for passing params to disconnect prompt dialog
typedef struct tagDISCONNECTDLGINFO {
        LPTSTR  pszConnectoidName;   // input: name of connectoid
        DWORD   dwTimeout;           // input: idle timeout in minutes
        BOOL    fTimer;              // input: timer or shutdown?
        DWORD   dwCountdownVal;      // internal: state of countdown in dialog
        BOOL    fDisconnectDisabled; // output: TRUE if disconnect disabled
        CDialMon *pDialMon;          // pointer back to dialmon class
} DISCONNECTDLGINFO;

///////////////////////////////////////////////////////////////////////////
//
// BUFFER class and helpers
//
///////////////////////////////////////////////////////////////////////////

class BUFFER_BASE
{
protected:
        UINT _cch;

        virtual BOOL Alloc( UINT cchBuffer ) = 0;
        virtual BOOL Realloc( UINT cchBuffer ) = 0;

public:
        BUFFER_BASE()  { _cch = 0; }
        ~BUFFER_BASE() { _cch = 0; }
        BOOL Resize( UINT cchNew );
        UINT QuerySize() const { return _cch; };
};

class BUFFER : public BUFFER_BASE
{
protected:
        TCHAR *_lpBuffer;

        virtual BOOL Alloc( UINT cchBuffer );
        virtual BOOL Realloc( UINT cchBuffer );

public:
        BUFFER( UINT cchInitial=0 );
        ~BUFFER();
        BOOL Resize( UINT cchNew );
        TCHAR * QueryPtr() const { return (TCHAR *)_lpBuffer; }
        operator TCHAR *() const { return (TCHAR *)_lpBuffer; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\dialmon.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1995                    **
//*********************************************************************

//
//      DIALMON.C - Window proc for dial monitor app
//

//      HISTORY:
//      
//      4/18/95         jeremys         Created.
//

#include "private.h"

#include <mluisupp.h>

#define TF_THISMODULE TF_DIALMON

//
// Registry keys we use to get autodial information
//
                                                                     
// Internet connection goes in remote access key
const TCHAR c_szRASKey[]    = TEXT("RemoteAccess");

// Key name
const TCHAR c_szProfile[]   = TEXT("InternetProfile");
const TCHAR c_szEnable[]    = TEXT("EnableUnattended");

// registry keys of interest
const TCHAR c_szRegPathInternetSettings[] =         REGSTR_PATH_INTERNET_SETTINGS;
static const TCHAR szRegValEnableAutoDisconnect[] = REGSTR_VAL_ENABLEAUTODISCONNECT; 
static const TCHAR szRegValDisconnectIdleTime[] =   REGSTR_VAL_DISCONNECTIDLETIME; 
static const TCHAR szRegValExitDisconnect[] =       REGSTR_VAL_ENABLEEXITDISCONNECT;
static const TCHAR szEllipsis[] =                   TEXT("...");
static const CHAR szDashes[] =                      "----";
static const TCHAR szAutodialMonitorClass[] =       REGSTR_VAL_AUTODIAL_MONITORCLASSNAME;
static const TCHAR c_szDialmonClass[] =             TEXT("MS_WebcheckMonitor");

// Dialmon globals
UINT_PTR    g_uDialmonSecTimerID = 0;  

CDialMon *  g_pDialMon = NULL;

// Function prototypes for dialog handling functions
INT_PTR CALLBACK DisconnectPromptDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
        LPARAM lParam);
BOOL DisconnectDlgInit(HWND hDlg,DISCONNECTDLGINFO * pDisconnectDlgInfo);
VOID DisconnectDlgCancel(HWND hDlg);
VOID DisconnectDlgTimerProc(HWND hDlg);
VOID DisconnectDlgDisableAutodisconnect(HWND hDlg);
VOID DisconnectDlgShowCountdown(HWND hDlg,DWORD dwSecsRemaining);
VOID EnableDisconnectDlgCtrls(HWND hDlg,BOOL fEnable);
BOOL CenterWindow (HWND hwndChild, HWND hwndParent);

////////////////////////////////////////////////////////////////////////
// RAS delay load helpers
//

typedef DWORD (WINAPI* _RASSETAUTODIALPARAM) (
    DWORD, LPVOID, DWORD
);

typedef DWORD (WINAPI* _RASENUMCONNECTIONSA) (
    LPRASCONNA, LPDWORD, LPDWORD
);

typedef DWORD (WINAPI* _RASENUMCONNECTIONSW) (
    LPRASCONNW, LPDWORD, LPDWORD
);

typedef DWORD (WINAPI* _RASHANGUP) (
    HRASCONN
);

typedef struct _tagAPIMAPENTRY {
    FARPROC* pfn;
    LPSTR pszProc;
} APIMAPENTRY;

static _RASSETAUTODIALPARAM     pfnRasSetAutodialParam = NULL;
static _RASENUMCONNECTIONSA     pfnRasEnumConnectionsA = NULL;
static _RASENUMCONNECTIONSW     pfnRasEnumConnectionsW = NULL;
static _RASHANGUP               pfnRasHangUp = NULL;

static HINSTANCE    g_hRasLib = NULL;
static long         g_lRasRefCnt = 0;

APIMAPENTRY rgRasApiMap[] = {
    { (FARPROC*) &pfnRasSetAutodialParam,       "RasSetAutodialParamA" },
    { (FARPROC*) &pfnRasEnumConnectionsA,       "RasEnumConnectionsA" },
    { (FARPROC*) &pfnRasEnumConnectionsW,       "RasEnumConnectionsW" },
    { (FARPROC*) &pfnRasHangUp,                 "RasHangUpA" },
    { NULL, NULL },
};

/////////////////////////////////////////////////////////////////////////////
//
// RasEnumHelp
//
// Abstract grusome details of getting a correct enumeration of connections 
// from RAS.  Works on all 9x and NT platforms correctly, maintaining unicode
// whenever possible.
//
/////////////////////////////////////////////////////////////////////////////

class RasEnumHelp
{
private:

    //
    // Possible ways we got info from RAS
    //
    typedef enum {
        ENUM_MULTIBYTE,             // Win9x
        ENUM_UNICODE,               // NT
    } ENUM_TYPE;

    //
    // How we got the info
    //
    ENUM_TYPE       _EnumType;     

    //
    // Any error we got during enumeration
    //
    DWORD           _dwLastError;

    //
    // Number of entries we got
    //
    DWORD           _dwEntries;

    //
    // Pointer to info retrieved from RAS
    //
    RASCONNW *      _rcList;

    //
    // Last entry returned as multibyte or unicode when conversion required
    //
    RASCONNW        _rcCurrentEntryW;


public:
    RasEnumHelp();
    ~RasEnumHelp();

    DWORD       GetError();
    DWORD       GetEntryCount();
    LPRASCONNW  GetEntryW(DWORD dwEntry);
};

RasEnumHelp::RasEnumHelp()
{
    DWORD           dwBufSize, dwStructSize;

    // init
    _dwEntries = 0;
    _dwLastError = 0;

    // figure out which kind of enumeration we're doing - start with multibyte
    _EnumType = ENUM_MULTIBYTE;
    dwStructSize = sizeof(RASCONNA);

    if (g_fIsWinNT)
    {
        _EnumType = ENUM_UNICODE;
        dwStructSize = sizeof(RASCONNW);
    }

    // allocate space for 16 entries
    dwBufSize = 16 * dwStructSize;
    _rcList = (LPRASCONNW)LocalAlloc(LMEM_FIXED, dwBufSize);
    if(_rcList)
    {
        do
        {
            // set up list
            _rcList[0].dwSize = dwStructSize;

            // call ras to enumerate
            _dwLastError = ERROR_UNKNOWN;
            if(ENUM_MULTIBYTE == _EnumType)
            {
                if(pfnRasEnumConnectionsA)
                {
                    _dwLastError = pfnRasEnumConnectionsA(
                                    (LPRASCONNA)_rcList,
                                    &dwBufSize,
                                    &_dwEntries
                                    );
                }
            }
            else
            {
                if(pfnRasEnumConnectionsW)
                {
                    _dwLastError = pfnRasEnumConnectionsW(
                                    _rcList,
                                    &dwBufSize,
                                    &_dwEntries
                                    );
                }
            }
       
            // reallocate buffer if necessary
            if(ERROR_BUFFER_TOO_SMALL == _dwLastError)
            {
                LocalFree(_rcList);
                _rcList = (LPRASCONNW)LocalAlloc(LMEM_FIXED, dwBufSize);
                if(NULL == _rcList)
                {
                    _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
            else
            {
                break;
            }

        } while(TRUE);
    }
    else
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    if(_rcList && (ERROR_SUCCESS != _dwLastError))
    {
        LocalFree(_rcList);
        _rcList = NULL;
        _dwEntries = 0;
    }

    return;
}

RasEnumHelp::~RasEnumHelp()
{
    if(_rcList)
    {
        LocalFree(_rcList);
    }
}

DWORD
RasEnumHelp::GetError()
{
    return _dwLastError;
}

DWORD
RasEnumHelp::GetEntryCount()
{
    return _dwEntries;
}

LPRASCONNW
RasEnumHelp::GetEntryW(DWORD dwEntryNum)
{
    LPRASCONNW  prc = NULL;

    if(dwEntryNum < _dwEntries)
    {
        _rcCurrentEntryW.hrasconn = _rcList[dwEntryNum].hrasconn;

        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            {
                MultiByteToWideChar(CP_ACP, 0,
                                    ((LPRASCONNA)_rcList)[dwEntryNum].szEntryName,
                                    -1, _rcCurrentEntryW.szEntryName,
                                    ARRAYSIZE(_rcCurrentEntryW.szEntryName));
            }
            break;

        case ENUM_UNICODE:
            {
                StrCpyNW(_rcCurrentEntryW.szEntryName,
                         _rcList[dwEntryNum].szEntryName,
                         ARRAYSIZE(_rcCurrentEntryW.szEntryName));
            }   
            break;
        }

        prc = &_rcCurrentEntryW;
    }

    return prc;
}


//
// Functions we can call once ras is loaded
//

DWORD _RasSetAutodialParam(DWORD dwKey, LPVOID lpvValue, DWORD dwcbValue)
{
    if (pfnRasSetAutodialParam == NULL)
        return ERROR_UNKNOWN;

    return (*pfnRasSetAutodialParam)(dwKey, lpvValue, dwcbValue);
}

DWORD _RasEnumConnections(LPRASCONNW lpRasConn, LPDWORD lpdwSize, LPDWORD lpdwConn)
{
    RasEnumHelp     reh;
    DWORD           dwRet = reh.GetError();

    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   cItems = reh.GetEntryCount();
        DWORD   cbNeeded = cItems * sizeof(RASCONNW);

        *lpdwConn = 0;

        if (*lpdwSize >= cbNeeded)
        {

            *lpdwConn = cItems;

            DWORD   dw;

            for (dw = 0; dw < cItems; dw++)
            {
                LPRASCONNW  prc = reh.GetEntryW(dw);

                ASSERT(prc != NULL);

                lpRasConn[dw].hrasconn = prc->hrasconn;
                StrCpyNW(lpRasConn[dw].szEntryName,
                         prc->szEntryName,
                         ARRAYSIZE(lpRasConn[dw].szEntryName));
            }
        }
        else
        {
            dwRet = ERROR_BUFFER_TOO_SMALL;
        }

        *lpdwSize = cbNeeded;
    }

    return dwRet;
}

DWORD _RasHangUp(HRASCONN hRasConn)
{
    if (pfnRasHangUp == NULL)
        return ERROR_UNKNOWN;

    return (*pfnRasHangUp)(hRasConn);
}

BOOL
LoadRasDll(void)
{
    if(NULL == g_hRasLib) {
        g_hRasLib = LoadLibrary(TEXT("RASAPI32.DLL"));

        if(NULL == g_hRasLib)
            return FALSE;

        int nIndex = 0;
        while (rgRasApiMap[nIndex].pszProc != NULL) {
            *rgRasApiMap[nIndex].pfn =
                    GetProcAddress(g_hRasLib, rgRasApiMap[nIndex].pszProc);
            // GetProcAddress will fail on Win95 for a couple of NT only apis.
            // ASSERT(*rgRasApiMap[nIndex].pfn != NULL);

            nIndex++;
        }
    }

    if(g_hRasLib) {
        return TRUE;
    }

    return FALSE;
}

void
UnloadRasDll(void)
{
    if(g_hRasLib) {
        FreeLibrary(g_hRasLib);
        g_hRasLib = NULL;
        int nIndex = 0;
        while (rgRasApiMap[nIndex].pszProc != NULL) {
            *rgRasApiMap[nIndex].pfn = NULL;
            nIndex++;
        }
    }
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
// CDialmonClients
// 
//  Class to maintain a list of application Windows using Dialmon.
//  Used for auto-timeout for all these applications.
//  This class supports 
//      adding hooks to incoming applications, 
//      removing hooks for exiting applications,
//      some aggregate operations on all clients.
// 
//  This is a singleton class, and needs to support only serialized access
//  because all access is thru Dialmon which has a serialized message queue.
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////   

class CDialmonClients
{
private:

    HWND pHwndArray[MAX_DIALMON_HANDLES];
    int cCount;
    static CDialmonClients* pSingleton;

public:

    CDialmonClients();
    
    ~CDialmonClients(){}

    static CDialmonClients* getSingleton()
    {
        if( NULL == pSingleton )
            return ( pSingleton = new CDialmonClients() );
        else
            return pSingleton;
    }

    static void Shutdown()
    {
        if( pSingleton )
            delete pSingleton;
    }
    
    void ClearAll(void);
    BOOL AddHook( HWND hWnd );
    BOOL RemoveHook( HWND hWnd );
    BOOL HasEntries() { return (cCount != 0); };

    friend void BroadcastCanHangup( int iTimeoutMins );
    friend void BroadcastHangingUp( void );
    friend void OnConfirmHangup( HWND hWnd );
    friend void OnDenyHangup( HWND hWnd, CDialMon* pDialMon );
    friend BOOL CanHangup( void ); //doesn't have to be a friend - just bunched it together for now.

    void DebugPrint( void );
};

CDialmonClients* CDialmonClients::pSingleton;

CDialmonClients::CDialmonClients():cCount(0)
{
    for( int i=0; i<MAX_DIALMON_HANDLES; i++ )
        pHwndArray[i] = NULL;
}
void CDialmonClients::ClearAll(void)
{
    for( int i=0; i<MAX_DIALMON_HANDLES; i++ )
        pHwndArray[i] = NULL;
}

// client app. passes a handle to its messaging window when it starts up.
BOOL CDialmonClients::AddHook( HWND hWnd )
{  
    DebugMsg( DM_TRACE, TEXT("\tCDIALMONCLIENTS: Add Hook\n") );

    if( cCount >= MAX_DIALMON_HANDLES )
        return false; /* BAD! */

    pHwndArray[cCount++] = hWnd;

#ifdef DEBUG
    DebugPrint();
#endif

    return true;
}

// client app. unhooks the handle from the CDialmonClients.

//IMPL: cCount always points to the next empty entry in the array.
// so when we delete a handle, we move all the entries beyond that
// handle up one place and decrement cCount.
BOOL CDialmonClients::RemoveHook( HWND hWnd )
{
    DebugMsg( DM_TRACE, TEXT("\tCDIALMONCLIENTS: Remove Hook\n") );

    boolean found = false;
    int i;
    for( i=0; i<cCount; i++ )
    {
        if( hWnd == pHwndArray[i] )
        {
            pHwndArray[i] = NULL;
            --cCount;
            found = true;
            break;
        }
    }
    // move everything beyong cCount up by 1
    // so that cCount represents next free index to 
    // insert into.
    if( found )
    {
        for( ; i<cCount; i++ )
            pHwndArray[i] = pHwndArray[i+1];
        pHwndArray[cCount] = NULL;
    }
    
#ifdef DEBUG    
    DebugPrint();
#endif

    return found;
}

void CDialmonClients::DebugPrint(void)
{
    DebugMsg( DM_TRACE, TEXT("\tCDIALMONCLIENTS: ClientList->\n") );

    for( int i=0; i<cCount; i++ )
    {
        if( pHwndArray[i] )
        {
            DebugMsg( DM_TRACE, TEXT("\t\t%d: %x\n"), i, pHwndArray[i] );
        }
    }
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//             Start up and Shutdown CDialmonClients
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
CDialmonClients* g_pDialmonClients;

static void DialmonClientsInit(void)
{
    g_pDialmonClients = new CDialmonClients();
}

static void DialmonClientsShutdown(void)
{
    delete g_pDialmonClients;
}

//#define USE_CONFIRM_ARRAY 1

// We don't need to use the pConfirmHangupArray.
// The option is to simply wait for some preset time, and if no registered
// client refuses the hangup option, to go ahead and simply hangup.
// This array lets us hangup a little earlier just in case all clients reply
// immdly.
#ifdef USE_CONFIRM_ARRAY
    static BOOL pConfirmHangupArray[MAX_DIALMON_HANDLES];
#endif
static int cOutstandingReplies = 0;

// Broadcast to all registered client a query of can_hang_up?
void BroadcastCanHangup( int iTimeoutMins )
{
    DebugMsg( DM_TRACE, TEXT("\tCDIALMONCLIENTS: Broadcasting WM_CANHANGUP?") );
    int i;
    
    cOutstandingReplies=0;
    for( i=0; i<g_pDialmonClients->cCount; i++ )
    {
        if(PostMessage( g_pDialmonClients->pHwndArray[i], WM_CANHANGUP, 
                    0, (LPARAM)iTimeoutMins ))
            ++cOutstandingReplies;
    }

    // if we are using a confirm boolean array, then set ALL
    // entries to false.. this is to take care of any clients that come
    // in AFTER we broadcast can hangup and BEFORE all the existing clients
    // have finished confirming.
#ifdef USE_CONFIRM_ARRAY
    for( i=0; i<MAX_DIALMON_HANDLES; i++ )
    {
        pConfirmHangupArray[i] = false;
    }
#endif
}

// This is a broadcast AFTER hangingup to all registered clients.
void BroadcastHangingUp(void)
{

    DebugMsg( DM_TRACE, TEXT("\tCDIALMONCLIENTS: Broadcasting WM_HANGING_UP") );
    for( int i=0; i<g_pDialmonClients->cCount; i++ )
        PostMessage( g_pDialmonClients->pHwndArray[i], WM_HANGING_UP, 0,0 );
}


// Record that this particular client would like to hangup.
void OnConfirmHangup( HWND hWnd )
{
#ifdef USE_CONFIRM_ARRAY
    for( int i=0; i<g_pDialmonClients->cCount; i++ )
        if( hWnd == g_pDialmonClients->pHwndArray[i] )
        {
            pConfirmHangupArray[i] = true;
            break;
        }
#endif
    --cOutstandingReplies;
}

// Checks if all clients have replied positively.
// Returns false if any client has not yet replied.
BOOL CanHangup( void )
{
#ifdef USE_CONFIRM_ARRAY
    for( int i=0; i<g_pDialmonClients->cCount; i++ )
        if( false == pConfirmHangupArray[i] )
            return false;
    return true;
#else
    return (cOutstandingReplies==0);
#endif 
}

// take action to abort hangup, ( set CDialmon::_dwElapsedTicks to 0 ).
// The effect of this would be that after another timeout period, dialmon
// would again query all the clients.
// However, the client does not have to bring up a dialog again if the user
// indicates that he is not interested in the feature.. the client can
// negate the hangup without interrupting the user.
// ( see the auto-disconnect feature in dialmon ).
void OnDenyHangup( HWND hWnd, CDialMon* pDialMon )
{
#ifdef USE_CONFIRM_ARRAY
    for( int i=0; i<g_pDialmonClients->cCount; i++ )
        if( hWnd == g_pDialmonClients->pHwndArray[i] )
        {
            pConfirmHangupArray[i] = false;
            break;
        }
#endif
    pDialMon->ResetElapsedTicks();
    cOutstandingReplies=0;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
// Helper to tell dialmon something is going on
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
void IndicateDialmonActivity(void)
{
    static HWND hwndDialmon = NULL;
    HWND hwndMonitor;

    // this one is dynamic - have to find window every time
    hwndMonitor = FindWindow(szAutodialMonitorClass, NULL);
    if(hwndMonitor)
        PostMessage(hwndMonitor, WM_WINSOCK_ACTIVITY, 0, 0);

    // dialmon lives forever - find it once and we're set
    if(NULL == hwndDialmon)
        hwndDialmon = FindWindow(c_szDialmonClass, NULL);
    if(hwndDialmon)
        PostMessage(hwndDialmon, WM_WINSOCK_ACTIVITY, 0, 0);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
// Dialmon startup and shutdown
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
BOOL DialmonInit(void)
{
    g_pDialMon = new CDialMon;

    DialmonClientsInit();
    if(g_pDialMon)
        return TRUE;

    return FALSE;
}


void DialmonShutdown(void)
{
    DialmonClientsShutdown();
    SAFEDELETE(g_pDialMon);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
// Dialmon window functions
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

// this cwebcheck instance is in iwebck.cpp
extern CWebCheck *g_pwc;

#ifdef DEBUG_KV
    // DEBUG_KV is set to 1 if you need to test hangup logic 
    // without actually having a dailup connection.
    static bool kvhack = true;
#endif

LRESULT CALLBACK Dialmon_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDialMon *pDialMon = (CDialMon*) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg)
    {
        case WM_CREATE:
        {
            // snag our class pointer and save in window data
            CREATESTRUCT *pcs;
            pcs = (CREATESTRUCT *)lParam;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pcs->lpCreateParams);
            break;
        }

        // DialMon messages (starting at WM_USER+100)
        case WM_SET_CONNECTOID_NAME:
            if(pDialMon)
                pDialMon->OnSetConnectoid(wParam!=0);
            break;
        case WM_WINSOCK_ACTIVITY:
            if(pDialMon)
                pDialMon->OnActivity();
            break;
        case WM_IEXPLORER_EXITING:
            if(pDialMon)
                pDialMon->OnExplorerExit();
            break;
            
        case WM_DIALMON_HOOK:
            DebugMsg( DM_TRACE, TEXT("\tCDIALMONCLIENTS: WM_HOOK recd. from Window 0x%x"), lParam );

            BOOL fRetval;
            fRetval = g_pDialmonClients->AddHook( (HWND)lParam );
            ASSERT( fRetval == TRUE );
            
#ifdef DEBUG_KV
            if( kvhack == true )
            {
                pDialMon->kvStartMonitoring();
                kvhack = false;
            }
#endif
            break;

        case WM_DIALMON_UNHOOK:            
            DebugMsg( DM_TRACE, TEXT("\tCDIALMONCLIENTS: WM_UNHOOK recd. from Window 0x%x"), lParam );

            g_pDialmonClients->RemoveHook( (HWND)lParam );
            break;

        case WM_CONFIRM_HANGUP:           
            DebugMsg( DM_TRACE, TEXT("\tCDIALMONCLIENTS: WM_CONFIRM_HANGUP recd. from Window 0x%x"), lParam );

            OnConfirmHangup( (HWND)lParam );
            break;

        case WM_DENY_HANGUP:          
            DebugMsg( DM_TRACE, TEXT("\tCDIALMONCLIENTS: WM_DENY_HANGUP recd. from Window 0x%x"), lParam );

            OnDenyHangup( (HWND)lParam, pDialMon );
            break;
            
        case WM_TIMER:
            if(pDialMon)
                pDialMon->OnTimer(wParam);
            break;
        case WM_LOAD_SENSLCE:
            DBG("Dialmon_WndProc - got WM_LOAD_SENSLCE");
            if(g_pwc)
            {
                g_pwc->LoadExternals();
            }
            break;
        case WM_IS_SENSLCE_LOADED:
            if(g_pwc)
            {
                return g_pwc->AreExternalsLoaded();
            }
            else
            {
                return FALSE;
            }
            break;
        case WM_WININICHANGE:
            if (lParam && !StrCmpI((LPCTSTR)lParam, TEXT("policy")))
            {
                ProcessInfodeliveryPolicies();
            }
            // FEATURE: This should be done on Policy and another filter, not for
            // all changes.  (The other filter hasn't been defined yet.)

            //  TODO: handle this in the new architecture!
            //SetNotificationMgrRestrictions(NULL);
            break;

    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                   CDialMon class implementation
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

//
// Constructor / Destructor
//
CDialMon::CDialMon()
{
    WNDCLASS wc;

    // register dialmon window class
    memset(&wc, 0, sizeof(wc));
    wc.lpfnWndProc = Dialmon_WndProc;
    wc.hInstance = g_hInst;
    wc.lpszClassName = c_szDialmonClass;
    RegisterClass(&wc);

    // create dialmon window
    _hwndDialmon = CreateWindow(c_szDialmonClass,
                c_szDialmonClass,
                WS_OVERLAPPEDWINDOW,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                NULL,
                NULL,
                g_hInst,
                (LPVOID)this);
}

CDialMon::~CDialMon()
{
    if(_hwndDialmon)
        DestroyWindow(_hwndDialmon);

    // unload ras if it's still around
    UnloadRasDll();
}


///////////////////////////////////////////////////////////////////////////
//
// Start/StopMonitoring
//
///////////////////////////////////////////////////////////////////////////

BOOL CDialMon::StartMonitoring(void)
{
    DBG("CDialMon::StartMonitoring");

    // read timeout settings from registry
    RefreshTimeoutSettings();

    // set a one-minute timer
    StopIdleTimer();
    if(!StartIdleTimer())
        return FALSE;

    _dwElapsedTicks = 0;
    
    return TRUE;
}

void CDialMon::StopMonitoring(void)
{
    DBG("CDialMon::StopMonitoring");

    // don't ever hang up now but keep an eye on ras connection
    _dwTimeoutMins = 0;
    _fDisconnectOnExit = FALSE;
}

///////////////////////////////////////////////////////////////////////////
//
// Start/StopIdleTimer, OnTimer
//
///////////////////////////////////////////////////////////////////////////

INT_PTR CDialMon::StartIdleTimer(void)
{
    if(0 == _uIdleTimerID)
        _uIdleTimerID = SetTimer(_hwndDialmon, TIMER_ID_DIALMON_IDLE, 30000, NULL);

    ASSERT(_uIdleTimerID);

    return _uIdleTimerID;
}

void CDialMon::StopIdleTimer(void)
{
    if(_uIdleTimerID) {
        KillTimer(_hwndDialmon, _uIdleTimerID);
        _uIdleTimerID = 0;
    }
}

void CDialMon::OnTimer(UINT_PTR uTimerID)
{
    DBG("CDialMon::OnMonitorTimer");

    // if we're on Millennium, just bail out.  The system handles idle disconnect.
    if(g_fIsMillennium)
    {
        return;
    }

    // if it's not our timer, ignore it
    if(uTimerID != _uIdleTimerID)
        return;

    // prevent re-entrancy of timer proc (we can stay in here indefinitely
    // since we may bring up a dialog box)
    if (_fInDisconnectFunction) {
        // disconnect dialog already launched, ignore timer ticks while
        // it's present
        return;
    }

    _fInDisconnectFunction = TRUE;
    CheckForDisconnect(TRUE);
    _fInDisconnectFunction = FALSE;

#ifdef DEBUG_KV
    /* Don't stop idle timer */
#else
    if(FALSE == _fConnected) {
        StopIdleTimer();
    }
#endif
}

///////////////////////////////////////////////////////////////////////////
//
// OnSetConnectoid/OnActivity/OnExplorerExit
//
///////////////////////////////////////////////////////////////////////////

void CDialMon::OnSetConnectoid(BOOL fNoTimeout)
{
    RASCONN RasCon[MAX_CONNECTION];
    DWORD   dwBytes, dwRes, dwConnections;

    // save no timeout setting
    _fNoTimeout = fNoTimeout;

    // Ask ras which connectoid is connected and watch that one
    LoadRasDll();
    RasCon[0].dwSize = sizeof(RasCon[0]);
    dwBytes = MAX_CONNECTION * sizeof(RasCon[0]);
    dwRes = _RasEnumConnections(RasCon, &dwBytes, &dwConnections);
    
    // No connections? bail.
    if(0 == dwConnections) {
        *_pszConnectoidName = TEXT('\0');
        _fConnected = FALSE;
        return;
    }

    // Monitor first connectoid
    StrCpyN(_pszConnectoidName, RasCon[0].szEntryName, ARRAYSIZE(_pszConnectoidName));

    // send ras connect notification if we weren't previously connected
    if(FALSE == _fConnected) {
        _fConnected = TRUE;
    }

    // start watching it
    StartMonitoring();
}

void CDialMon::OnActivity(void)
{
    DBG("CDialMon::OnActivity");

    // reset idle tick count
    _dwElapsedTicks = 0;

    // if the disconnect dialog is present and winsock activity
    // resumes, then dismiss the dialog
    if(_hDisconnectDlg) {
        SendMessage(_hDisconnectDlg, WM_QUIT_DISCONNECT_DLG, 0, 0);
        _hDisconnectDlg = NULL;
    }
}

void CDialMon::OnExplorerExit()
{
    DBG("CDialMon::OnIExplorerExit");

    if(FALSE == _fDisconnectOnExit && FALSE == _fNoTimeout) {
        // no exit disconnection so bail
        DBG("CDialMon::OnIExplorerExit - exit hangup not enabled");
        return;
    }

    // prevent re-entrancy of this function (we can stay in here indefinitely
    // since we may bring up a dialog box)
    if (_fInDisconnectFunction) {
        // some UI already launched
        return;
    }

    _fInDisconnectFunction = TRUE;
    CheckForDisconnect(FALSE);
    _fInDisconnectFunction = FALSE;

    if(FALSE == _fConnected) {
        StopIdleTimer();
    }
}


///////////////////////////////////////////////////////////////////////////
//
// RefreshTimeoutSettings
//
///////////////////////////////////////////////////////////////////////////

BOOL CDialMon::RefreshTimeoutSettings(void)
{
    HKEY    hKey;
    BOOL    fSuccess = FALSE;
    TCHAR   szKey[MAX_PATH];
    DWORD   dwRes, dwData, dwSize, dwDisp;

    // assume disconnect monitoring is off
    _dwTimeoutMins = 0;
    _fDisconnectOnExit = FALSE;

    // figure out appropriate key
    wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("%s\\Profile\\%s"),
            REGSTR_PATH_REMOTEACCESS, _pszConnectoidName);

    // open a regstry key to the internet settings section
    dwRes = RegCreateKeyEx(HKEY_CURRENT_USER, szKey, 0, TEXT(""), 0,
            KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hKey, &dwDisp);
    
    if(ERROR_SUCCESS == dwRes)
    {
        //
        // is autodisconnect enabled?
        //
        dwSize = sizeof(DWORD);
        if (RegQueryValueEx(hKey,szRegValEnableAutoDisconnect,NULL,NULL,
                (LPBYTE) &dwData,&dwSize) == ERROR_SUCCESS)
        {
            if(dwData)
            {
                // what's the timeout?
                dwSize = sizeof(DWORD);
                if (RegQueryValueEx(hKey,szRegValDisconnectIdleTime,NULL,NULL,
                        (LPBYTE) &dwData,&dwSize) == ERROR_SUCCESS && dwData)
                {
                    _dwTimeoutMins = dwData;
                    fSuccess = TRUE;
                }
            }

            // is disconnect on exit enabled?
            dwSize = sizeof(DWORD);
            if (RegQueryValueEx(hKey,szRegValExitDisconnect,NULL,NULL,
                    (LPBYTE) &dwData,&dwSize) == ERROR_SUCCESS && dwData)
            {
                _fDisconnectOnExit = TRUE;
                fSuccess = TRUE;
            }
        }
        else
        {
            //
            // couldn't find enable autodisconnect key.  Set all disconnect
            // settings to their defaults
            //

            // set class members to default values
            _dwTimeoutMins = 20;
            _fDisconnectOnExit = TRUE;
            fSuccess = TRUE;

            // enable idle disconnect and exit disconnect
            dwData = 1;
            RegSetValueEx(hKey, szRegValEnableAutoDisconnect, 0, REG_DWORD,
                    (LPBYTE)&dwData, sizeof(DWORD));
            RegSetValueEx(hKey, szRegValExitDisconnect, 0, REG_DWORD,
                    (LPBYTE)&dwData, sizeof(DWORD));

            // Save idle minutes
            RegSetValueEx(hKey, szRegValDisconnectIdleTime, 0, REG_DWORD,
                    (LPBYTE)&_dwTimeoutMins, sizeof(DWORD));
        }

        RegCloseKey(hKey);
    }

    return fSuccess;
}

///////////////////////////////////////////////////////////////////////////
//
// Disconnection handling
//
///////////////////////////////////////////////////////////////////////////

void CDialMon::CheckForDisconnect(BOOL fTimer)
{
    BOOL    fPromptForDisconnect = TRUE;       // assume we should prompt for disconnect
    BOOL    fDisconnectDisabled = FALSE;
    BOOL    fConnectoidAlive = FALSE;
    RASCONN RasCon[MAX_CONNECTION];
    DWORD   dwBytes, dwRes, dwConnections = 0, i;
    HRASCONN hConnection = NULL;

    // variables for auto-hangup for other client apps. (MARS)
    static int dwElapsedTicksSincePoll = 0;
    static BOOL fPolledForHangup = false; 
    BOOL fClientsOkHangup = false;
    #define MAX_MINS_CLIENT_RESPONSE    1
    
#ifdef DEBUG_KV
    // skip all the connection code..
    goto KVHACK;
#endif    

    // Verify we still have a connection
    RasCon[0].dwSize = sizeof(RasCon[0]);
    dwBytes = MAX_CONNECTION * sizeof(RasCon[0]);
    dwRes = _RasEnumConnections(RasCon, &dwBytes, &dwConnections);
    
    // If ras is connected at all, stay alive to monitor it
    if(0 == dwConnections)
        _fConnected = FALSE;

    // Find connectoid we're supposed to watch
    if(TEXT('\0') == *_pszConnectoidName) {
        DBG_WARN("DisconnectHandler: No designated connection to monitor");
        return;
    }
        
    for(i=0; i<dwConnections; i++) {
        if(!StrCmp(RasCon[i].szEntryName, _pszConnectoidName)) {
            fConnectoidAlive = TRUE;
            hConnection = RasCon[i].hrasconn;
        }
    }

    // if we're not connected to out monitor connectoid, ditch our hangup
    // dialog if we have one and bail out
    if(FALSE == fConnectoidAlive) {
        if(_hDisconnectDlg) {
            SendMessage(_hDisconnectDlg, WM_QUIT_DISCONNECT_DLG, 0, 0);
            _hDisconnectDlg = NULL;
        }

        // Also make sure that if we were waiting for client (MARS) reponses for auto-hangup,
        // we also clean up state information..
        if( fPolledForHangup )
        {
            dwElapsedTicksSincePoll = 0;
            fPolledForHangup = false;
        }
        return;
    }

#ifdef DEBUG_KV
    // label to jump to after skipping connection code..
    // also need to set _dwTimeoutMins since without connection
    KVHACK:_dwTimeoutMins = 2;
#endif

    // Check timeout if we got a timer tick
    if(fTimer) {
        // increment tick count
        _dwElapsedTicks ++;

        // Haven't exceeded idle threshold or not watching for idle
        if (0 == _dwTimeoutMins || _dwElapsedTicks < _dwTimeoutMins * 2)
            fPromptForDisconnect = FALSE;
    }

    // THIS is a good place to message out to other clients (ie Mars ) and
    // see if everybody wants to hang up ( this is the point where if
    // fPromptForDisconnect is true, then the earlier behavior would have
    // prompted for disconnect.

    // If this is a disconnect because of IExplorer exiting, we 
    // probably don't want to hangup if there are other clients using dialmon.
    if( !fTimer && g_pDialmonClients->HasEntries() )
        return;
        
    if( g_pDialmonClients->HasEntries() && fPromptForDisconnect )
    {
        if( fPolledForHangup )
        {  
            // WM_CANHANGUP messages have been sent
            // we can hangup if either all clients have replied yes,
            // or if there are no refusals so far, and time has run out.
            if( CanHangup() ||
                ( dwElapsedTicksSincePoll >= 2*MAX_MINS_CLIENT_RESPONSE ) )
            {
                //can hangup!
                dwElapsedTicksSincePoll = 0;
                fPolledForHangup = false;
                fClientsOkHangup = true;
            }
            else
            {
                dwElapsedTicksSincePoll++;
                //ensure that hangup doesn't occur on THIS particular timer message.
                fPromptForDisconnect = false;
            }        
        }
        else
        {
            // WM_CANHANGUP queries may be sent out now..
            BroadcastCanHangup( _dwTimeoutMins );
            dwElapsedTicksSincePoll = 0;
            fPolledForHangup = true;
            //ensure that hangup doesn't occur now
            fPromptForDisconnect = false;
        }
    }
    else if( fPolledForHangup )
    {
        // activity restarted while waiting for client responses.
        // do clean up of state information.
        dwElapsedTicksSincePoll = 0;
        fPolledForHangup = false;
    }
    
    if(FALSE == fPromptForDisconnect) {
        return;
    }

    // prompt user to see if they want to hang up
    if(fClientsOkHangup || PromptForDisconnect(fTimer, &fDisconnectDisabled)) {
        // hang it up
        ASSERT(hConnection);
        if(hConnection)
            _RasHangUp(hConnection);

         // broadcast WM_HANGING_UP to remaining clients - REQUIRED??
         if( g_pDialmonClients->HasEntries() ) 
            BroadcastHangingUp();
         
        _fConnected = FALSE;
    }

    if (fDisconnectDisabled) {
        StopMonitoring();
    }

    _dwElapsedTicks = 0;
}

BOOL CDialMon::PromptForDisconnect(BOOL fTimer, BOOL *pfDisconnectDisabled)
{
    ASSERT(_pszConnectoidName);
    ASSERT(pfDisconnectDisabled);

    // fill out struct to pass to dialog
    DISCONNECTDLGINFO DisconnectDlgInfo;
    memset(&DisconnectDlgInfo,0,sizeof(DisconnectDlgInfo));
    DisconnectDlgInfo.pszConnectoidName = _pszConnectoidName;
    DisconnectDlgInfo.fTimer = fTimer;
    DisconnectDlgInfo.dwTimeout = _dwTimeoutMins;
    DisconnectDlgInfo.pDialMon = this;

    // choose the appropriate dialog depending on if this a "timeout" dialog
    // or "app exiting" dialog
    UINT uDlgTemplateID = fTimer ? IDD_DISCONNECT_PROMPT:IDD_APP_EXIT_PROMPT;

    // run the dialog
    BOOL fRet = (BOOL)DialogBoxParam(MLGetHinst(),MAKEINTRESOURCE(uDlgTemplateID),
            NULL, DisconnectPromptDlgProc,(LPARAM) &DisconnectDlgInfo);

    // dialog box stores its window handle in our class so we can send
    // messages to it, clear the global handle now that it's dismissed
    _hDisconnectDlg = NULL;

    *pfDisconnectDisabled = FALSE;
    if (!fRet && DisconnectDlgInfo.fDisconnectDisabled) {
        *pfDisconnectDisabled=TRUE;

        // turn off reg keys for this connection
        TCHAR   szKey[128];
        DWORD   dwRes, dwValue = 0;
        HKEY    hKey;

        wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("%s\\Profile\\%s"),
                REGSTR_PATH_REMOTEACCESS, _pszConnectoidName);
        dwRes = RegOpenKey(HKEY_CURRENT_USER, szKey, &hKey);
        if(ERROR_SUCCESS == dwRes) {

            // Turn off idle disconnect
            RegSetValueEx(hKey, szRegValEnableAutoDisconnect, 0, REG_DWORD,
                    (LPBYTE)&dwValue, sizeof(DWORD));

            // Turn off exit disconnect
            RegSetValueEx(hKey, szRegValExitDisconnect, 0, REG_DWORD,
                    (LPBYTE)&dwValue, sizeof(DWORD));

            RegCloseKey(hKey);
        }
    }   

    return fRet;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                  Disconnect dialog implementation
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK DisconnectPromptDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
        LPARAM lParam)
{
    switch (uMsg) {
    case WM_INITDIALOG:
        // lParam points to data struct, store a pointer to it in window data
        SetWindowLongPtr(hDlg, DWLP_USER,lParam);
        return DisconnectDlgInit(hDlg,(DISCONNECTDLGINFO *) lParam);
        break;
    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            EndDialog(hDlg,TRUE);
            break;
        case IDCANCEL:
            DisconnectDlgCancel(hDlg);
            EndDialog(hDlg,FALSE);
            break;
        case IDC_DISABLE_AUTODISCONNECT:
            DisconnectDlgDisableAutodisconnect(hDlg);
            break;
        }
        break;
    case WM_QUIT_DISCONNECT_DLG:
        // parent window wants to terminate us
        EndDialog(hDlg,FALSE);
        break;
    case WM_TIMER:
        DisconnectDlgTimerProc(hDlg);
        break;
    }

    return FALSE;
}

BOOL __cdecl _FormatMessage(LPCWSTR szTemplate, LPWSTR szBuf, UINT cchBuf, ...)
{
    BOOL fRet;
    va_list ArgList;
    va_start(ArgList, cchBuf);

    fRet = FormatMessageWrapW(FORMAT_MESSAGE_FROM_STRING, szTemplate, 0, 0, szBuf, cchBuf, &ArgList);

    va_end(ArgList);
    return fRet;
}

BOOL DisconnectDlgInit(HWND hDlg,DISCONNECTDLGINFO * pDisconnectDlgInfo)
{
    ASSERT(pDisconnectDlgInfo);
    if (!pDisconnectDlgInfo)
        return FALSE;

    // allocate buffers to build text for dialog
    BUFFER BufText(MAX_RES_LEN + MAX_CONNECTOID_DISPLAY_LEN + 1);
    BUFFER BufFmt(MAX_RES_LEN),BufConnectoidName(MAX_CONNECTOID_DISPLAY_LEN+4);
    ASSERT(BufText && BufFmt && BufConnectoidName);
    if (!BufText || !BufFmt || !BufConnectoidName)
        return FALSE;

    UINT uStringID;
    // choose the appropriate text string for dialog
    if (pDisconnectDlgInfo->fTimer) {
        uStringID = IDS_DISCONNECT_DLG_TEXT;
    } else {
        uStringID = IDS_APP_EXIT_TEXT;
    }

    // load the format string from resource
    MLLoadString(uStringID,BufFmt.QueryPtr(),BufFmt.QuerySize());

    // copy the connectoid name into buffer, and truncate it if it's really
    // long
    StrCpyN(BufConnectoidName.QueryPtr(),pDisconnectDlgInfo->pszConnectoidName,
              BufConnectoidName.QuerySize());
    if (lstrlen(pDisconnectDlgInfo->pszConnectoidName) > MAX_CONNECTOID_DISPLAY_LEN) {
        StrCpyN(((TCHAR *) BufConnectoidName.QueryPtr()) + MAX_CONNECTOID_DISPLAY_LEN,
                 szEllipsis, BufConnectoidName.QuerySize());
    }

    if (pDisconnectDlgInfo->fTimer)
    {
        _FormatMessage(BufFmt.QueryPtr(),
                       BufText.QueryPtr(),
                       BufText.QuerySize(),
                       BufConnectoidName.QueryPtr(),
                       pDisconnectDlgInfo->dwTimeout);
    }
    else
    {
        _FormatMessage(BufFmt.QueryPtr(),
                       BufText.QueryPtr(),
                       BufText.QuerySize(),
                       BufConnectoidName.QueryPtr());
    }

    // set text in dialog
    SetDlgItemText(hDlg,IDC_TX1,BufText.QueryPtr());

    // if this timeout dialog (which counts down), initialize countdown timer
    if (pDisconnectDlgInfo->fTimer) {
        pDisconnectDlgInfo->dwCountdownVal = DISCONNECT_DLG_COUNTDOWN;

        DisconnectDlgShowCountdown(hDlg,pDisconnectDlgInfo->dwCountdownVal);

        // set a one-second timer
        g_uDialmonSecTimerID = SetTimer(hDlg,TIMER_ID_DIALMON_SEC,1000,NULL);
        ASSERT(g_uDialmonSecTimerID);
        if (!g_uDialmonSecTimerID) {
            // it's very unlikely that setting the timer will fail... but if it
            // does, then we'll act just like a normal dialog and won't have
            // a countdown.  Hide the countdown-related windows...
            ShowWindow(GetDlgItem(hDlg,IDC_TX2),SW_HIDE);
            ShowWindow(GetDlgItem(hDlg,IDC_GRP),SW_HIDE);
            ShowWindow(GetDlgItem(hDlg,IDC_TIME_REMAINING),SW_HIDE);
            ShowWindow(GetDlgItem(hDlg,IDC_TX3),SW_HIDE);
        }

        // beep to alert user
        MessageBeep(MB_ICONEXCLAMATION);
    }

    // center this dialog on the screen
    CenterWindow(hDlg,GetDesktopWindow());

    // default: assume user does not disable auto disconnect, change
    // this later if they do (this field is output to dialog invoker)
    pDisconnectDlgInfo->fDisconnectDisabled = FALSE;

    // Save dialog handle so we can get quit messages
    pDisconnectDlgInfo->pDialMon->_hDisconnectDlg = hDlg;
 
    return TRUE;
}

VOID DisconnectDlgCancel(HWND hDlg)
{
    // get pointer to data struct out of window data
    DISCONNECTDLGINFO * pDisconnectDlgInfo = (DISCONNECTDLGINFO *)
                                             GetWindowLongPtr(hDlg, DWLP_USER);
    ASSERT(pDisconnectDlgInfo);

    // check to see if user checked 'disable autodisconnect' checkbox
    if(IsDlgButtonChecked(hDlg,IDC_DISABLE_AUTODISCONNECT))
    {
        // set the output field to indicate that user wanted to disable
        // auto disconnect
        pDisconnectDlgInfo->fDisconnectDisabled = TRUE;
    }       
}

VOID DisconnectDlgTimerProc(HWND hDlg)
{
    // ignore timer ticks (e.g. hold countdown) if "disable autodisconnect"
    // checkbox is checked
    if (IsDlgButtonChecked(hDlg,IDC_DISABLE_AUTODISCONNECT))
        return;

    // get pointer to data struct out of window data
    DISCONNECTDLGINFO * pDisconnectDlgInfo =
                (DISCONNECTDLGINFO *) GetWindowLongPtr(hDlg, DWLP_USER);
    ASSERT(pDisconnectDlgInfo);
    if (!pDisconnectDlgInfo)
        return;

    if (pDisconnectDlgInfo->dwCountdownVal) {
        // decrement countdown value
        pDisconnectDlgInfo->dwCountdownVal --;

        // update the dialog with the new value
        if (pDisconnectDlgInfo->dwCountdownVal) {
            DisconnectDlgShowCountdown(hDlg,pDisconnectDlgInfo->dwCountdownVal);
            return;
        }
    }

    // countdown has run out!

    // kill the timer
    KillTimer(hDlg,g_uDialmonSecTimerID);
    g_uDialmonSecTimerID = 0;

    // send a 'OK' message to the dialog to dismiss it
    SendMessage(hDlg,WM_COMMAND,IDOK,0);
}

VOID DisconnectDlgShowCountdown(HWND hDlg,DWORD dwSecsRemaining)
{
    // build a string showing the number of seconds left
    CHAR szSecs[10];
    if (dwSecsRemaining == (DWORD) -1) {
        lstrcpyA(szSecs, szDashes);
    } else {
        wnsprintfA(szSecs, ARRAYSIZE(szSecs), "%lu", dwSecsRemaining);
    }

    // set string in text control
    SetDlgItemTextA(hDlg, IDC_TIME_REMAINING, szSecs);
}

VOID DisconnectDlgDisableAutodisconnect(HWND hDlg)
{
    // get pointer to data struct out of window data
    DISCONNECTDLGINFO * pDisconnectDlgInfo = (DISCONNECTDLGINFO *)
            GetWindowLongPtr(hDlg, DWLP_USER);
    ASSERT(pDisconnectDlgInfo);

    // find out if disable autodisconnect checkbox is checked
    BOOL fDisabled = IsDlgButtonChecked(hDlg,IDC_DISABLE_AUTODISCONNECT);

    // enable or disable controls appropriately
    EnableDisconnectDlgCtrls(hDlg,!fDisabled);

    if (!fDisabled) {
        // reset timer if we're re-enabling autodisconnect
        pDisconnectDlgInfo->dwCountdownVal = DISCONNECT_DLG_COUNTDOWN;
        // show timer value
        DisconnectDlgShowCountdown(hDlg,pDisconnectDlgInfo->dwCountdownVal);
    } else {
        // show "--" in countdown value
        DisconnectDlgShowCountdown(hDlg,(DWORD) -1);
    }
}

VOID EnableDisconnectDlgCtrls(HWND hDlg,BOOL fEnable)
{
    EnableWindow(GetDlgItem(hDlg,IDC_TX1),fEnable);
    EnableWindow(GetDlgItem(hDlg,IDC_TX2),fEnable);
    EnableWindow(GetDlgItem(hDlg,IDC_TX3),fEnable);
    EnableWindow(GetDlgItem(hDlg,IDC_TIME_REMAINING),fEnable);
    EnableWindow(GetDlgItem(hDlg,IDOK),fEnable);
}

BOOL CenterWindow (HWND hwndChild, HWND hwndParent)
{
    RECT    rChild, rParent;
    int     wChild, hChild, wParent, hParent;
    int     wScreen, hScreen, xNew, yNew;
    HDC     hdc;

    // Get the Height and Width of the child window
    GetWindowRect (hwndChild, &rChild);
    wChild = rChild.right - rChild.left;
    hChild = rChild.bottom - rChild.top;

    // Get the Height and Width of the parent window
    GetWindowRect (hwndParent, &rParent);
    wParent = rParent.right - rParent.left;
    hParent = rParent.bottom - rParent.top;

    // Get the display limits
    hdc = GetDC (hwndChild);
    wScreen = GetDeviceCaps (hdc, HORZRES);
    hScreen = GetDeviceCaps (hdc, VERTRES);
    ReleaseDC (hwndChild, hdc);

    // Calculate new X position, then adjust for screen
    xNew = rParent.left + ((wParent - wChild) /2);
    if (xNew < 0) {
        xNew = 0;
    } else if ((xNew+wChild) > wScreen) {
        xNew = wScreen - wChild;
    }

    // Calculate new Y position, then adjust for screen
    yNew = rParent.top  + ((hParent - hChild) /2);
    if (yNew < 0) {
        yNew = 0;
    } else if ((yNew+hChild) > hScreen) {
        yNew = hScreen - hChild;
    }

    // Set it, and return
    return SetWindowPos (hwndChild, NULL, xNew, yNew, 0, 0,
            SWP_NOSIZE | SWP_NOZORDER);
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                      BUFFER class implementation
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL BUFFER::Alloc( UINT cchBuffer )
{
    _lpBuffer = (LPTSTR)::MemAlloc(LPTR,cchBuffer*sizeof(TCHAR));
    if (_lpBuffer != NULL) {
        _cch = cchBuffer;
        return TRUE;
    }
    return FALSE;
}

BOOL BUFFER::Realloc( UINT cchNew )
{
    LPVOID lpNew = ::MemReAlloc((HLOCAL)_lpBuffer, cchNew*sizeof(TCHAR),
            LMEM_MOVEABLE | LMEM_ZEROINIT);
    if (lpNew == NULL)
        return FALSE;

    _lpBuffer = (LPTSTR)lpNew;
    _cch = cchNew;
    return TRUE;
}

BUFFER::BUFFER( UINT cchInitial /* =0 */ )
  : BUFFER_BASE(),
        _lpBuffer( NULL )
{
    if (cchInitial)
        Alloc( cchInitial );
}

BUFFER::~BUFFER()
{
    if (_lpBuffer != NULL) {
        MemFree((HLOCAL) _lpBuffer);
        _lpBuffer = NULL;
    }
}

BOOL BUFFER::Resize( UINT cchNew )
{
    BOOL fSuccess;

    if (QuerySize() == 0)
        fSuccess = Alloc( cchNew*sizeof(TCHAR) );
    else {
        fSuccess = Realloc( cchNew*sizeof(TCHAR) );
    }
    if (fSuccess)
        _cch = cchNew;
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\dllload.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//
//----------------------------------------------------------------------------
#include "private.h"
#include <winsock.h>

#pragma warning(disable:4229)  // No warnings when modifiers used on data

//----------------------------------------------------------------------------
// Delay loading mechanism.  [Stolen from shdocvw.]
//
// This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that 
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_ORD_VOID     
//
// Use these macros for APIs that only exist on the integrated-shell
// installations (i.e., a new shell32 is on the system).
//
//      DELAY_LOAD_SHELL
//      DELAY_LOAD_SHELL_HRESULT
//      DELAY_LOAD_SHELL_VOID     
//
//----------------------------------------------------------------------------

#define ENSURE_LOADED(_hinst, _dll, pszfn)   (_hinst ? TRUE : NULL!=(_hinst = LoadLibrary(TEXT(#_dll))))

#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err) \
static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
_ret __stdcall _fn _args                \
{                                       \
    if (!ENSURE_LOADED(_hinst, _dll, #_fn))   \
    {                                   \
        ASSERT_MSGA(_hinst!=NULL, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        ASSERT_MSGA(_pfn##_fn!=NULL, "GetProcAddress failed on " ## #_fn); \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, #_fn))   \
    {                                   \
        AssertMsg(_hinst!=NULL, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        ASSERT_MSGA(_pfn##_fn!=NULL, "GetProcAddress failed on " ## #_fn); \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
 }

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_DWORD(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, DWORD, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, INT, _fn, _args, _nargs, 0)

#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, "(ordinal " ## #_ord ## ")"))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_ORD_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, "(ordinal " ## #_ord ## ")"))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
}
        
#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)

//
// And now the DLLs which are delay loaded
//

// --------- PSTOREC.DLL ---------------
HINSTANCE g_hinstPSTOREC = NULL;

DELAY_LOAD_ERR(g_hinstPSTOREC, PSTOREC.DLL, HRESULT, PStoreCreateInstance,
    (IPStore ** ppProvider, PST_PROVIDERID *pProviderID, void *pReserved, DWORD dwFlags),
    (ppProvider, pProviderID, pReserved, dwFlags),
    E_FAIL);

#if 0
//
// darrenmi 8/18/98
// icmp only needed for dialer.cpp which is no longer built
//

// --------- ICMP.DLL ----------------

HINSTANCE g_hinstICMP = NULL;

DELAY_LOAD(g_hinstICMP, ICMP.DLL, HANDLE, IcmpCreateFile, (void), ());

DELAY_LOAD(g_hinstICMP, ICMP.DLL, BOOL, IcmpCloseHandle, (HANDLE hPing), (hPing));

DELAY_LOAD(g_hinstICMP, ICMP.DLL, DWORD, IcmpSendEcho, 
        (HANDLE     hPing,
         IPAddr     dwAddress,
         void *     pPingData,
         WORD       wPingDataLength,
         PIP_OPTION_INFORMATION
                    pIpInfo,
         void *     pReplyBuffer,
         DWORD      dwReplySize,
         DWORD      dwTimeout),
        (hPing, dwAddress, pPingData, wPingDataLength, pIpInfo, pReplyBuffer, dwReplySize, dwTimeout));

void UnloadICMP(void)
{
    _pfnIcmpCreateFile = NULL;
    _pfnIcmpCloseHandle = NULL;
    _pfnIcmpSendEcho = NULL;

    if(g_hinstICMP) {
        FreeLibrary(g_hinstICMP);
        g_hinstICMP = NULL;
    }
}
#endif

#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\dialer.h ===
#include "ras.h"
#include "raserror.h"

//
// Useful registry constants
//
extern const TCHAR c_szRASKey[];
extern const TCHAR c_szProfile[];

//
// Data for the dialer and property sheet is loaded and saved
// in this format
//
struct _dialpropdata {

    BOOL        fEnabled;
    BOOL        fUnattended;
    TCHAR       pszConnection[RAS_MaxEntryName + 1];
    TCHAR       pszUsername[UNLEN + 1];
    TCHAR       pszPassword[PWLEN + 1];
    TCHAR       pszDomain[DNLEN + 1];
    UINT        uRedialAttempts;
    UINT        uRedialDelay;

};

typedef struct _dialpropdata DIALPROPDATA;

//
// Forward declaration
//
class CConnectionAgent;

// the various states that a client can be in
typedef enum {
    CLIENT_NEW,
    CLIENT_CONNECTING,
    CLIENT_CONNECTED,
    CLIENT_ABORT,
    CLIENT_DISCONNECTED,
} ClientState;


//
// Connection client object
//
class CConnClient : public INotificationSink,
                    public IOleCommandTarget
{
private:
    ~CConnClient() {};
public:    
    CConnClient();

    //
    // IUnknown members
    //
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // INotificationSink members
    //
    STDMETHODIMP OnNotification(
            LPNOTIFICATION         pNotification,
            LPNOTIFICATIONREPORT   pNotificationReport,
            DWORD                  dwReserved
            );

    //
    // IOleCommandTarget members
    //
    STDMETHODIMP QueryStatus(
            const GUID __RPC_FAR *pguidCmdGroup,
            ULONG cCmds,
            OLECMD __RPC_FAR prgCmds[  ],
            OLECMDTEXT __RPC_FAR *pCmdText
            );
        
    STDMETHODIMP Exec( 
            const GUID __RPC_FAR *pguidCmdGroup,
            DWORD nCmdID,
            DWORD nCmdexecopt,
            VARIANT __RPC_FAR *pvaIn,
            VARIANT __RPC_FAR *pvaOut
            );

    HRESULT SetConnAgent(IUnknown *punk);

protected:
    long                    m_cRef;
    IOleCommandTarget *     m_poctAgent;
    BSTR                    m_bstrURL;
    ClientState             m_State;
    LPNOTIFICATIONREPORT    m_pReport;
    long                    m_iCookie;

    HRESULT Connect(void);
    HRESULT Disconnect(void);
    HRESULT DeliverProgressReport(SCODE, BSTR);
};

//
// Main dialer agent object
//
class CConnectionAgent : public IOleCommandTarget
{
private:
    ~CConnectionAgent();
public:
    CConnectionAgent();

    //
    // IUnknown members
    //
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IOleCommandTarget members
    //
    STDMETHODIMP QueryStatus(
            const GUID __RPC_FAR *pguidCmdGroup,
            ULONG cCmds,
            OLECMD __RPC_FAR prgCmds[  ],
            OLECMDTEXT __RPC_FAR *pCmdText
            );
        
    STDMETHODIMP Exec( 
            const GUID __RPC_FAR *pguidCmdGroup,
            DWORD nCmdID,
            DWORD nCmdexecopt,
            VARIANT __RPC_FAR *pvaIn,
            VARIANT __RPC_FAR *pvaOut
            );


    //
    // Other public members 
    //
    DWORD           m_dwRegisterHandle;

protected:
    long            m_cRef;
    BOOL            IsDialPossible(void);
    BOOL            IsDialExisting(void);
    void            Notify(HRESULT hr, TCHAR *pszErrorText);
    void            Connect(void);
    void            Disconnect(void);
    void            Clean(void);

    INotificationMgr *m_pMgr;
    DIALPROPDATA *  m_pData;
    DWORD           m_dwFlags;
    long            m_lConnectionCount;
    HDPA            m_hdpaClient;
};

// Connection agent flags
#define CA_CONNECTING_NOW       1
#define CA_OFFLINE_STATE_READ   2
#define CA_OFFLINE              4
#define CA_DIALED               8
#define CA_LOADED_RAS           16

// IOleCommandTarget commands
#define AGENT_CONNECT           0x00
#define AGENT_DISCONNECT        0x01
#define AGENT_NOTIFY            0x10

// CLIENTINFO struct - info about each client
typedef struct _ci {

    IOleCommandTarget *     poctClient;
    DWORD                   dwFlags;

} CLIENTINFO;

// flags for CLIENTINFO
#define CLIENT_DISCONNECT       1
#define CLIENT_NOTIFIED         2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\downld.cpp ===
#include "private.h"
#include <exdisp.h>
#include <exdispid.h>
#include <htiface.h>
#include <mshtmdid.h>
#include <mshtmcid.h>
#include <mshtmhst.h>
#include <optary.h>                 // needed for IHtmlLoadOptions

#include "downld.h"

#define TF_THISMODULE   TF_DOWNLD

// CUrlDownload is a single threaded object. We can assume we are always on a single thread.

long g_lRegisteredWnd = 0;
LRESULT UrlDownloadWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

CLIPFORMAT g_cfHTML=CF_NULL;

// User-Agent strings
const WCHAR c_wszUserAgentAppend[] = L"; MSIECrawler)";

// Refresh header for http-equiv (client-pull)
const WCHAR c_wszRefresh[] = L"Refresh";

const int  MAX_CLIENT_PULL_NUM = 4;     // max # redirections
const int  MAX_CLIENT_PULL_TIMEOUT = 6; // max timeout we'll follow

// Function also present in shdocvw\basesb.cpp and in mshtml
BOOL ParseRefreshContent(LPWSTR pwzContent, UINT * puiDelay, LPWSTR pwzUrlBuf, UINT cchUrlBuf);

const WCHAR c_wszHeadVerb[] = L"HEAD";

const WCHAR c_szUserAgentPrefix[] = L"User-Agent: ";
const WCHAR c_szAcceptLanguagePrefix[] = L"Accept-Language: ";

#define WM_URLDL_CLEAN      (WM_USER + 0x1010)
#define WM_URLDL_ONDLCOMPLETE (WM_USER + 0x1012)
#define WM_URLDL_CLIENTPULL (WM_USER+0x1013)

#define SAFE_RELEASE_BSC() \
if (m_pCbsc) { \
m_pCbsc->SetParent(NULL); \
m_pCbsc->Release(); \
m_pCbsc = NULL; \
} else

//---------------------------------------------------------------
// CUrlDownload class
CUrlDownload::CUrlDownload(CUrlDownloadSink *pParent, UINT iID /* =0 */)
{
    DWORD cbData;

    // Maintain global count of objects
    DllAddRef();

    m_iID = iID;
    m_pParent = pParent;

    m_cRef = 1;
    
    ASSERT(m_pDocument==NULL && m_dwConnectionCookie==0 && m_pwszURL == NULL);

    // Get the timeout value (stored in seconds)
    cbData = sizeof(m_nTimeout);
    if (NO_ERROR != SHGetValue(HKEY_CURRENT_USER, c_szRegKey, TEXT("Timeout"), NULL, &m_nTimeout, &cbData))
    {
        // Default to 120 seconds
        m_nTimeout = 120;
    }

    // find the HTML clipboard format
    if (!g_cfHTML)
    {
        g_cfHTML = (CLIPFORMAT) RegisterClipboardFormat(CFSTR_MIME_HTML);
        TraceMsg(TF_THISMODULE, "ClipFormat for HTML = %d", (int)g_cfHTML);
    }

    // find out if we need to set the "RESYNCHRONIZE" flag
    INTERNET_CACHE_CONFIG_INFOA CacheConfigInfo;
    DWORD dwBufSize = sizeof(CacheConfigInfo);
    CacheConfigInfo.dwStructSize = sizeof(CacheConfigInfo);

    if (GetUrlCacheConfigInfoA(&CacheConfigInfo, &dwBufSize, CACHE_CONFIG_SYNC_MODE_FC))
    {
        if ((WININET_SYNC_MODE_ONCE_PER_SESSION == CacheConfigInfo.dwSyncMode) ||
             (WININET_SYNC_MODE_ALWAYS == CacheConfigInfo.dwSyncMode) ||
             (WININET_SYNC_MODE_AUTOMATIC == CacheConfigInfo.dwSyncMode))
        {
            m_fSetResync = FALSE;
        }
        else
        {
            m_fSetResync = TRUE;
            DBG("Browser session update='never', setting RESYNCHRONIZE");
        }
    }
    else
        DBG_WARN("GetUrlCacheConfigInfo failed! Not setting Resync.");

    m_lBindFlags = DLCTL_SILENT | DLCTL_NO_SCRIPTS | DLCTL_NO_BEHAVIORS |
        DLCTL_NO_JAVA | DLCTL_NO_RUNACTIVEXCTLS | DLCTL_NO_DLACTIVEXCTLS;
    if (m_fSetResync)
        m_lBindFlags |= DLCTL_RESYNCHRONIZE;

    // register our window class if necessary
    if (!g_lRegisteredWnd)
    {
        g_lRegisteredWnd++;

        WNDCLASS wc;

        wc.style = 0;
        wc.lpfnWndProc = UrlDownloadWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = g_hInst;
        wc.hIcon = NULL;
        wc.hCursor = NULL;
        wc.hbrBackground = (HBRUSH)NULL;
        wc.lpszMenuName = NULL;
        wc.lpszClassName = URLDL_WNDCLASS;

        RegisterClass(&wc);
    }
}

CUrlDownload::~CUrlDownload()
{
    // Maintain global count of objects
    DllRelease();

    CleanUp();
    DBG("Destroyed CUrlDownload object");
}

void CUrlDownload::CleanUpBrowser()
{
    SAFERELEASE(m_pScript);

    if (m_fAdviseOn)
    {
        UnAdviseMe();
    }
    SAFERELEASE(m_pCP);
    SAFERELEASE(m_pDocument);
    SAFERELEASE(m_pPersistMk);
    SAFERELEASE(m_pOleCmdTarget);
    SAFELOCALFREE(m_pwszClientPullURL);
}

void CUrlDownload::CleanUp()
{
    CleanUpBrowser();
    SAFE_RELEASE_BSC();
    SAFELOCALFREE(m_pwszURL);
    SAFELOCALFREE(m_pstLastModified);
    SAFERELEASE(m_pStm);
    SAFELOCALFREE(m_pwszUserAgent);

    if (m_hwndMe)
    {
        SetWindowLongPtr(m_hwndMe, GWLP_USERDATA, 0);
        DestroyWindow(m_hwndMe);
        m_hwndMe = NULL;
    }
}

LRESULT UrlDownloadWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    CUrlDownload *pThis = (CUrlDownload*) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    // Validate pThis
#ifdef DEBUG
    if (pThis && IsBadWritePtr(pThis, sizeof(*pThis)))
    {
        TraceMsg(TF_THISMODULE,
            "Invalid 'this' in UrlDownloadWndProc (0x%08x) - already destroyed?", pThis);
    }
#endif

    switch (Msg)
    {
    case WM_CREATE :
        {
            LPCREATESTRUCT pcs = (LPCREATESTRUCT)lParam;

            if (!pcs || !(pcs->lpCreateParams))
            {
                DBG_WARN("Invalid param UrlDownloadWndProc Create");
                return -1;
            }
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) pcs->lpCreateParams);
            return 0;
        }

    case WM_URLDL_CLIENTPULL :
    case WM_URLDL_ONDLCOMPLETE :
    case WM_TIMER :
        if (pThis)
            pThis->HandleMessage(hWnd, Msg, wParam, lParam);
        break;

    default:
        return DefWindowProc(hWnd, Msg, wParam, lParam);
    }
    return 0;
}

HRESULT CUrlDownload::CreateMyWindow()
{
    // Create our callback window
    if (NULL == m_hwndMe)
    {
//      TraceMsg(TF_THISMODULE, "Creating MeWnd, this=0x%08x", (DWORD)this);
        m_hwndMe = CreateWindow(URLDL_WNDCLASS, TEXT("YO"), WS_OVERLAPPED,
                    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                    NULL, NULL, g_hInst, (LPVOID)this);

        if (NULL == m_hwndMe)
        {
            DBG_WARN("CUrlDownload CreateWindow(UrlDl WndClass) failed");
            return E_FAIL;
        }
    }
    return S_OK;
}

HRESULT CUrlDownload::BeginDownloadURL2(
    LPCWSTR     pwszURL,        // URL
    BDUMethod   iMethod,        // download method
    BDUOptions  iOptions,       // download options
    LPTSTR      pszLocalFile,   // Local file to download to instead of cache
    DWORD       dwMaxSize       // Max size in bytes; will abort if exceeded
)
{
    HRESULT hr = S_OK;

    // Param validation
    ASSERT(pwszURL);
    ASSERT(!(iOptions & BDU2_NEEDSTREAM) || (iMethod == BDU2_URLMON));
    ASSERT(!pszLocalFile || (iMethod == BDU2_URLMON));

    if (pszLocalFile && iMethod != BDU2_URLMON)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CreateMyWindow();

        // Clean up some old stuff
        if (m_pCbsc)
        {
            if (m_fbscValid)
                m_pCbsc->Abort();
            SAFE_RELEASE_BSC();
        }
        SAFERELEASE(m_pScript);
        SAFERELEASE(m_pStm);

        m_fbscValid = m_fBrowserValid = FALSE;

        m_iMethod = iMethod;
        m_iOptions = iOptions;

        m_dwMaxSize = dwMaxSize;

        SAFELOCALFREE(m_pwszClientPullURL);
        m_iNumClientPull = 0;

        // Save URL
        SAFELOCALFREE(m_pwszURL);
        m_pwszURL = StrDupW(pwszURL);

        SAFELOCALFREE(m_pstLastModified);
        m_dwResponseCode = 0;

        if ((iOptions & BDU2_FAIL_IF_NOT_HTML) && IsNonHtmlUrl(pwszURL))
        {
            // Hey, this isn't an HTML url! Don't even try to download it.
            OnDownloadComplete(BDU2_ERROR_NOT_HTML);
        }
        else
        {
            // Determine how to download this URL
            if ((iMethod == BDU2_BROWSER) ||
                ((iMethod == BDU2_SMART) && IsHtmlUrl(pwszURL)))
            {
                hr = BeginDownloadWithBrowser(pwszURL);
            }
            else
            {
                hr = BeginDownloadWithUrlMon(pwszURL, pszLocalFile, NULL);
            }
        }
    }

    if (FAILED(hr))
    {
        DBG("BeginDownloadURL2 : error HRESULT - calling OnDownloadComplete w/Error");
        OnDownloadComplete(BDU2_ERROR_GENERAL);
    }

    return hr;
}

//
// Looks up the Url in the url history object and if its not CP_ACP
// inserts an IHTMLLoadOptions object that contains the codepage
// into the bind context
//
HRESULT InsertHistoricalCodepageIntoBindCtx(LPCWSTR pwszURL, IBindCtx * pbc)
{
    HRESULT hr = S_OK;

    if (pwszURL == NULL || pbc == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //
        // Get the codepage from the intsite database. This is the codepage
        // the user set when last visiting this url.
        //
        PROPVARIANT propCodepage = {0};
        propCodepage.vt = VT_UI4;

        TCHAR szURL[INTERNET_MAX_URL_LENGTH];
        MyOleStrToStrN(szURL, INTERNET_MAX_URL_LENGTH, pwszURL);
        hr = IntSiteHelper(szURL, &c_rgPropRead[PROP_CODEPAGE], 
            &propCodepage, 1, FALSE);

        if (SUCCEEDED(hr) && propCodepage.lVal != CP_ACP)
        {
            //
            // We got a codepage that wasn't the ansi one create an
            // HTMLLoadOptions object and set the code page in it.
            //
            IHtmlLoadOptions *phlo = NULL;
            hr = CoCreateInstance(CLSID_HTMLLoadOptions, NULL, 
                CLSCTX_INPROC_SERVER, IID_IHtmlLoadOptions, (void**)&phlo);

            if (SUCCEEDED(hr) && phlo)
            {
                hr = phlo->SetOption(HTMLLOADOPTION_CODEPAGE, &propCodepage.lVal,
                    sizeof(propCodepage.lVal));

                if (SUCCEEDED(hr))
                {
                    //
                    // Insert the option into the bindctx
                    //
                    pbc->RegisterObjectParam(L"__HTMLLOADOPTIONS", phlo);
                    TraceMsg(TF_THISMODULE,
                        "InsertHistoricalCodepageIntoBindCtx codepage=%d",
                        propCodepage.lVal);
                }
                phlo->Release();
            }
        }
    }
    return hr;
}

LPCWSTR CUrlDownload::GetUserAgent()
{
    if (m_pwszUserAgent)
    {
        return m_pwszUserAgent;
    }

    // Get default User-Agent string from urlmon
    CHAR chUA[1024];
    DWORD dwBufLen;

    // Assume that UrlMkGetSessionOption always succeeds (82160).
    chUA[0] = 0;
    UrlMkGetSessionOption(URLMON_OPTION_USERAGENT, chUA, sizeof(chUA), &dwBufLen, 0);
    
    // Append "MSIECrawler"
    int iLenUA, iLenNew;

    iLenUA = lstrlenA(chUA);
    iLenNew = iLenUA + ARRAYSIZE(c_wszUserAgentAppend);

    ASSERT(iLenUA == (int)(dwBufLen-1));

    if (iLenUA > 0)
    {
        m_pwszUserAgent = (LPWSTR) LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*iLenNew);

        if (m_pwszUserAgent)
        {
            LPWSTR pwszAppend = m_pwszUserAgent+iLenUA-1;
            m_pwszUserAgent[0] = L'\0';
            SHAnsiToUnicode(chUA, m_pwszUserAgent, iLenNew);
            // find the closing parenthesis and append string there
            if (*pwszAppend != L')')
            {
                DBG("GetUserAgent: Last Char in UA isn't closing paren");
                pwszAppend = StrRChrW(m_pwszUserAgent, m_pwszUserAgent+iLenUA, L')');
            }
            if (pwszAppend)
            {
                StrCpyW(pwszAppend, c_wszUserAgentAppend);
            }
            else
            {
                LocalFree(m_pwszUserAgent);
                m_pwszUserAgent = NULL;
            }
        }
    }

    return m_pwszUserAgent;
}
    
HRESULT CUrlDownload::BeginDownloadWithBrowser(LPCWSTR pwszURL)
{
    HRESULT hr;

    // Get browser and hook up sink
    // (no-op if we're already set up)
    hr = GetBrowser();

    if (SUCCEEDED(hr))
    {
        // browse to the required URL
        LPMONIKER           pURLMoniker = NULL;
        IBindCtx           *pbc = NULL;

        // create a URL moniker from the canonicalized path
        hr=CreateURLMoniker(NULL, pwszURL, &pURLMoniker);
        if (FAILED(hr)) DBG_WARN("CreateURLMoniker failed");

        // create an empty bind context so that Urlmon will call Trident's
        //  QueryService on the proper thread so that Trident can delegate
        //  it to use properly.
        hr=CreateBindCtx(0, &pbc);
        if (FAILED(hr)) DBG_WARN("CreateBindCtx failed");

        if (SUCCEEDED(hr))
        {
            //
            // Looks up the Url in the url history object and if its not CP_ACP
            // inserts an IHTMLLoadOptions object that contains the codepage
            // into the bind context. This is done so that TRIDENT is seeded
            // with the correct codepage.
            //
            InsertHistoricalCodepageIntoBindCtx(pwszURL, pbc);

            hr = m_pPersistMk->Load(FALSE, pURLMoniker, pbc, 0);
            if (SUCCEEDED(hr)) m_fWaitingForReadyState = TRUE;
            if (FAILED(hr)) DBG_WARN("PersistMoniker::Load failed");
        }

        // clean up junk
        if (pURLMoniker)
            pURLMoniker->Release();

        if (pbc)
            pbc->Release();

        if (SUCCEEDED(hr))
        {
            m_fBrowserValid = TRUE;
            StartTimer();       // Start our timeout
        }
        else
        {
            DBG("Error binding with Browser's IPersistMoniker");
            CleanUpBrowser();
        }
    }

    TraceMsg(TF_THISMODULE,
        "CUrlDownload::BeginDownloadWithBrowser (hr=0x%08x)", (long)hr);

    return hr;
}

HRESULT CUrlDownload::OnDownloadComplete(int iError)
{
    PostMessage(m_hwndMe, WM_URLDL_ONDLCOMPLETE, (WPARAM)iError, 0);
    StopTimer();
    return S_OK;
}

BOOL CUrlDownload::HandleMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_URLDL_CLIENTPULL :
        {
            HRESULT hr = E_FAIL;

            // Ask our parent if we should do this
            if (m_pwszClientPullURL)
            {
                if (m_pParent && (m_iNumClientPull < MAX_CLIENT_PULL_NUM))
                    hr = m_pParent->OnClientPull(m_iID, m_pwszURL, m_pwszClientPullURL);

                TraceMsgA(TF_THISMODULE, "CUrlDownload %s executing client pull to %ws",
                    SUCCEEDED(hr) ? "is" : "**not**", m_pwszClientPullURL);
            }

            if (SUCCEEDED(hr))
            {
                // Download this new url. Don't give "downloadcomplete" for first one
                // Save member vars since they get reset in BDU2
                int iNumClientPull = m_iNumClientPull;
                LPWSTR pszNewURL = m_pwszClientPullURL;

                m_pwszClientPullURL = NULL;
                hr = BeginDownloadURL2(pszNewURL, m_iMethod, m_iOptions, NULL, m_dwMaxSize);
                MemFree(pszNewURL);
                if (SUCCEEDED(hr))
                {
                    m_iNumClientPull = iNumClientPull + 1;
                }
            }
        }
        break;

    case WM_URLDL_ONDLCOMPLETE :
        if (m_pParent)
            m_pParent->OnDownloadComplete(m_iID, (int)wParam);
        return TRUE;

    case WM_TIMER :
#ifdef DEBUG
        DBG_WARN("CUrlDownload ERROR - TIMING OUT");

        if ( m_fBrowserValid )
        {
            TraceMsg( TF_ALWAYS, "CUrlDownload::HandleMessage() - Browser Timeout." );
        }
        else
        {
            TraceMsg( TF_ALWAYS, "CUrlDownload::HandleMessage() - Non-Browser Timeout." );
        }

        if ( m_fbscValid )
        {
            TraceMsg( TF_ALWAYS, "CUrlDownload::HandleMessage() - UrlMon Timeout." );
        }
        else
        {
            TraceMsg( TF_ALWAYS, "CUrlDownload::HandleMessage() - Non-UrlMon Timeout." );
        }
#endif
        StopTimer();
        AbortDownload(BDU2_ERROR_TIMEOUT);
        return TRUE;
    }
    return TRUE;
}

HRESULT CUrlDownload::AbortDownload(int iErrorCode /* =-1 */)
{
    HRESULT hr=S_FALSE;
    BOOL    fAborted=FALSE;

    if (m_fBrowserValid)
    {
        ASSERT(m_pOleCmdTarget);
        if (m_pOleCmdTarget)
        {
            m_pOleCmdTarget->Exec(NULL, OLECMDID_STOP, 0, NULL, NULL);
        }

        SAFELOCALFREE(m_pwszClientPullURL);

        fAborted=TRUE;
        m_fBrowserValid = FALSE;
    }

    if (m_fbscValid)
    {
        ASSERT(m_pCbsc);
        if (m_pCbsc)
        {
            hr = m_pCbsc->Abort();
            fAborted=TRUE;
            SAFE_RELEASE_BSC();
        }
        m_fbscValid=FALSE;
    }

    if (fAborted && m_pParent)
    {
        OnDownloadComplete((iErrorCode==-1) ? BDU2_ERROR_ABORT : iErrorCode);
    }

    return hr;
}

// Loads browser, creates sink and hooks it up to sinks
HRESULT CUrlDownload::GetBrowser()
{
    HRESULT hr = S_OK;

    if (m_fAdviseOn)
        return hr;

    if (NULL == m_pDocument)
    {
        ASSERT(!m_pPersistMk);
        ASSERT(!m_pCP);

        hr = CoCreateInstance(CLSID_HTMLDocument, NULL,
                    CLSCTX_INPROC, IID_IHTMLDocument2, (void **)&m_pDocument);

        DBG("Created new CLSID_HTMLDocument");

        if (SUCCEEDED(hr))
        {
            IOleObject *pOleObj;

            hr = m_pDocument->QueryInterface(IID_IOleObject, (void **)&pOleObj);
            if (SUCCEEDED(hr))
            {
                pOleObj->SetClientSite((IOleClientSite *)this);
                pOleObj->Release();
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = m_pDocument->QueryInterface(IID_IPersistMoniker, (void**)&m_pPersistMk);
        }

        if (SUCCEEDED(hr))
        {
            hr = m_pDocument->QueryInterface(IID_IOleCommandTarget, (void**)&m_pOleCmdTarget);
        }
    }

    // At this point we have m_pDocument and m_pPersistMk

    // Get DownloadNotify sink hooked up
    IDownloadNotify *pNotify=NULL;
    BOOL            fNotifySet=FALSE;

    if (SUCCEEDED(hr) && SUCCEEDED(m_pParent->GetDownloadNotify(&pNotify)) && pNotify)
    {
        IOleCommandTarget *pTarget=NULL;

        if (SUCCEEDED(m_pDocument->QueryInterface(IID_IOleCommandTarget, (void **)&pTarget)) && pTarget)
        {
            VARIANTARG varIn;

            varIn.vt = VT_UNKNOWN;
            varIn.punkVal = (IUnknown *)pNotify;
            if (SUCCEEDED(pTarget->Exec(&CGID_DownloadHost, DWNHCMDID_SETDOWNLOADNOTIFY, 0,
                                        &varIn, NULL)))
            {
                fNotifySet=TRUE;
            }

            pTarget->Release();
        }

        if (!fNotifySet)
        {
            DBG_WARN("IDownloadNotify provided, but couldn't set callback!");
        }

        pNotify->Release();
    }

    if (!fNotifySet && (m_iOptions & BDU2_DOWNLOADNOTIFY_REQUIRED))
    {
        DBG_WARN("Couldn't set notify, parent requires it. CUrlDownload failing MSHTML download.");
        hr = E_FAIL;
    }

    // Get PropertyNotifySink hooked up
    // Find our connection point if necessary
    if (NULL == m_pCP && SUCCEEDED(hr))
    {
        IConnectionPointContainer *pCPCont=NULL;
        hr = m_pDocument->QueryInterface(IID_IConnectionPointContainer,
                (void **)&pCPCont);

        if (SUCCEEDED(hr))
        {
            hr = pCPCont->FindConnectionPoint(IID_IPropertyNotifySink, &m_pCP);
            pCPCont->Release();
            pCPCont = NULL;
        }
    }

    // And hook it up to us
    if (SUCCEEDED(hr))
    {
        // create sink
        IPropertyNotifySink *pSink = (IPropertyNotifySink *)this;

        hr = m_pCP->Advise(pSink, &m_dwConnectionCookie);
        if (SUCCEEDED(hr))
        {
            m_fAdviseOn = TRUE;
        }

    }

    if (FAILED(hr)) DBG_WARN("CUrlDownload::GetBrowser returning failure");
    return hr;
}

void CUrlDownload::UnAdviseMe()
{
    if (m_fAdviseOn)
    {
        m_pCP->Unadvise(m_dwConnectionCookie);
        m_fAdviseOn = FALSE;
    }
}

void CUrlDownload::DestroyBrowser()
{
    CleanUpBrowser();
}

void CUrlDownload::DoneDownloading()
{
    // Don't send any more messages to the parent
    LeaveMeAlone();

    AbortDownload();

    CleanUp();
}

HRESULT CUrlDownload::GetScript(IHTMLWindow2 **ppWin)
{
    HRESULT hr = E_FAIL;
    IDispatch *pDisp=NULL;

    ASSERT(ppWin);
    *ppWin=NULL;

    if (!m_fBrowserValid)
    {
        DBG("m_fBrowserValid FALSE, GetScript returning failure");
        return E_FAIL;
    }

    *ppWin = NULL;

    if (m_pScript)
    {
        m_pScript->AddRef();
        *ppWin = m_pScript;
        return S_OK;
    }

    if (m_pDocument)
    {
        hr = m_pDocument->get_Script(&pDisp);
        if (!pDisp) hr=E_NOINTERFACE;
#ifdef DEBUG
        if (FAILED(hr)) DBG_WARN("CUrlDownload::GetScript:  get_Script failed");
#endif
    }

    if (SUCCEEDED(hr))
    {
        hr = pDisp->QueryInterface(IID_IHTMLWindow2, (void **)ppWin);
        if (*ppWin == NULL) hr = E_NOINTERFACE;
        pDisp->Release();
#ifdef DEBUG
        if (FAILED(hr)) DBG_WARN("CUrlDownload::GetScript:  QI IOmWindow2 failed");
#endif
    }

    // Save this so future GetScript() calls much faster
    ASSERT(!m_pScript);
    if (SUCCEEDED(hr))
    {
        m_pScript = *ppWin;
        m_pScript->AddRef();
    }

    return hr;
}

// static member function
// Strips off anchor from URL (# not after ?)
// S_FALSE : Unchanged
// S_OK    : Removed anchor
HRESULT CUrlDownload::StripAnchor(LPWSTR lpURL)
{
    if (!lpURL) return E_POINTER;

    while (*lpURL)
    {
        if (*lpURL == L'?')
            return S_FALSE;
        if (*lpURL == L'#')
        {
            *lpURL = L'\0';
            return S_OK;
        }
        lpURL ++;
    }
    return S_FALSE;
}

// Returns pointer to '.' or pointer to null-terminator or query '?'
LPWSTR                  // ptr to period or to null-term or '?'
URLFindExtensionW(
    LPCWSTR pszURL,
    int *piLen)         // length including period
{
    LPCWSTR pszDot;

    for (pszDot = NULL; *pszURL && *pszURL!='?'; pszURL++)
    {
        switch (*pszURL) {
        case TEXT('.'):
            pszDot = pszURL;         // remember the last dot
            break;
        case TEXT('/'):
            pszDot = NULL;       // forget last dot, it was in a directory
            break;
        }
    }

    if (piLen)
    {
        if (pszDot)
            *piLen = (int) (pszURL-pszDot);
        else
            *piLen = 0;
    }

    // if we found the extension, return ptr to the dot, else
    // ptr to end of the string (NULL extension) (cast->non const)
    return pszDot ? (LPWSTR)pszDot : (LPWSTR)pszURL;
}

// Returns TRUE if this appears to be an HTML URL
BOOL CUrlDownload::IsHtmlUrl(LPCWSTR lpURL)
{
    LPWSTR pwch;
    int iLen;

    pwch = URLFindExtensionW(lpURL, &iLen);

    if (*pwch && iLen)
    {
        pwch ++; iLen --;

        // We found an extension. Check it out.
        if ((iLen == 4 &&
                (!MyAsciiCmpNIW(pwch, L"html", 4))) ||
            (iLen == 3 &&
                (!MyAsciiCmpNIW(pwch, L"htm", 3) ||
                 !MyAsciiCmpNIW(pwch, L"htt", 3) ||
                 !MyAsciiCmpNIW(pwch, L"asp", 3) ||
                 !MyAsciiCmpNIW(pwch, L"htx", 3)
                                            )))
        {
            // known HTML extension
            return TRUE;
        }
    }

    return FALSE;
}

// Returns TRUE if this appears NOT to be an HTML URL
BOOL CUrlDownload::IsNonHtmlUrl(LPCWSTR lpURL)
{
    LPWSTR pwch;
    int iLen;

    pwch = URLFindExtensionW(lpURL, &iLen);

    if (*pwch && iLen)
    {
        pwch ++; iLen --;

        // We found an extension. Check it out.
        if ((iLen==3) &&
                (!MyAsciiCmpNIW(pwch, L"bmp", 3) ||
                 !MyAsciiCmpNIW(pwch, L"cab", 3) ||
                 !MyAsciiCmpNIW(pwch, L"cdf", 3) ||
                 !MyAsciiCmpNIW(pwch, L"jpg", 3) ||
                 !MyAsciiCmpNIW(pwch, L"exe", 3) ||
                 !MyAsciiCmpNIW(pwch, L"zip", 3) ||
                 !MyAsciiCmpNIW(pwch, L"doc", 3) ||
                 !MyAsciiCmpNIW(pwch, L"gif", 3)
                                            ))
        {
            // known non-HTML extension
            return TRUE;
        }
    }

    return FALSE;
}

// Returns TRUE if this is a URL we should try to download (http:)
BOOL CUrlDownload::IsValidURL(LPCWSTR lpURL)
{
    // Check protocol
//  HKEY hk;

#if 0
    BOOL fValidProtocol = FALSE;

    // Always accept http or https
    if (!StrCmpNIW(lpURL, L"http", 4))
        fValidProtocol = TRUE;

    if (!fValidProtocol &&
        (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("PROTOCOLS\\Handler"), 0, KEY_QUERY_VALUE, &hk)))
    {
        // Crack out protocol
        DWORD dwData=0, cbData = sizeof(DWORD);
        int i;
        char ch[16];

        // we know we are 7-bit
        for (i=0; i<ARRAYSIZE(ch) && lpURL[i] != L':' && lpURL[i]; i++)
            ch[i] = (char) (lpURL[i]);

        if (i<ARRAYSIZE(ch))
        {
            ch[i] = '\0';

            // We have protocol
            if (NO_ERROR == SHGetValue(hk, ch, TEXT("SupportsNoUI"), NULL, &dwData, &cbData))
            {
                if (dwData != 0)
                    fValidProtocol = TRUE;  // Passed test
            }
#ifdef DEBUG
            if (!fValidProtocol)
                TraceMsgA(TF_THISMODULE, "IsValidUrl failing url protocol=%s url=%ws", ch, lpURL);
#endif
        }

        RegCloseKey(hk);
    }
#endif

    // See if this protocol will give us something for the cache
    BOOL fUsesCache=FALSE;
    DWORD dwBufSize=0;
    CoInternetQueryInfo(lpURL, QUERY_USES_CACHE, 0,
        &fUsesCache, sizeof(fUsesCache), &dwBufSize, 0);

    if (!fUsesCache || (S_FALSE == ::IsValidURL(NULL, lpURL, 0)))
        return FALSE;

    return TRUE;
}

HRESULT CUrlDownload::GetRealURL(LPWSTR *ppwszURL)
{
    *ppwszURL = NULL;

    if (!m_fBrowserValid)
    {
        if (m_pwszURL)
            *ppwszURL = StrDupW(m_pwszURL);
    }
    else
    {
        // Get the real URL from the browser in case we were redirected
        // We could optimize to do this only once
        ITargetContainer *pTarget=NULL;
        LPWSTR pwszThisUrl=NULL;

        if (m_pDocument)
        {
            m_pDocument->QueryInterface(IID_ITargetContainer, (void **)&pTarget);

            if (pTarget)
            {
                pTarget->GetFrameUrl(&pwszThisUrl);
                pTarget->Release();
            }
        }

        if (pwszThisUrl)
        {
            if (m_pwszURL) MemFree(m_pwszURL);
            m_pwszURL = StrDupW(pwszThisUrl);
            *ppwszURL = StrDupW(pwszThisUrl);
            CoTaskMemFree(pwszThisUrl);
        }
        else if (m_pwszURL)
        {
            *ppwszURL = StrDupW(m_pwszURL);
        }
    }

    return (*ppwszURL) ? S_OK : E_OUTOFMEMORY;
}


HRESULT CUrlDownload::GetDocument(IHTMLDocument2 **ppDoc)
{
    HRESULT hr;

    if (!m_fBrowserValid)
    {
        DBG("GetDocument failing, m_fBrowserValid FALSE");
        *ppDoc = NULL;
        return E_FAIL;
    }

    *ppDoc = m_pDocument;
    if (m_pDocument)
    {
        m_pDocument->AddRef();
        hr = S_OK;
    }
    else
        hr = E_NOINTERFACE;

    return hr;
}

HRESULT CUrlDownload::GetStream(IStream **ppStm)
{
    if (!m_pStm)
    {
        DBG("Stream not available, CUrlDownload::GetStream failing");
        *ppStm = NULL;
        return E_FAIL;
    }

    *ppStm = m_pStm;
    (*ppStm)->AddRef();

    return S_OK;
}

HRESULT CUrlDownload::GetLastModified(SYSTEMTIME *pstLastModified)
{
    if (NULL == pstLastModified)
        return E_INVALIDARG;

    if (NULL == m_pstLastModified)
        return E_FAIL;

    CopyMemory(pstLastModified, m_pstLastModified, sizeof(SYSTEMTIME));

    return S_OK;
}

HRESULT CUrlDownload::GetResponseCode(DWORD *pdwResponseCode)
{
    if (m_dwResponseCode == 0)
        return E_FAIL;

    *pdwResponseCode = m_dwResponseCode;

    return S_OK;
}
    
// Start or extend timer
void CUrlDownload::StartTimer()
{
    if (m_hwndMe)
    {
        if (!m_iTimerID)
        {
            m_iTimerID = 1;
            DBG("CUrlDownload Creating new timeout timer");
        }

        m_iTimerID = SetTimer(m_hwndMe, 1, 1000 * m_nTimeout, NULL);
    }
}

void CUrlDownload::StopTimer()
{
    if (m_hwndMe && m_iTimerID)
    {
        DBG("CUrlDownload destroying timeout timer");
        KillTimer(m_hwndMe, m_iTimerID);
        m_iTimerID = 0;
    }
}

//
// IUnknown of CUrlDownload
//
STDMETHODIMP CUrlDownload::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    // Validate requested interface
    if (IID_IOleClientSite == riid)
        *ppv=(IOleClientSite *)this;
    else if (IID_IPropertyNotifySink == riid)
        *ppv=(IPropertyNotifySink *)this;
    else if (IID_IOleCommandTarget == riid)
        *ppv=(IOleCommandTarget *)this;
    else if (IID_IDispatch == riid)
        *ppv=(IDispatch *)this;
    else if (IID_IServiceProvider == riid)
        *ppv = (IServiceProvider *)this;
    else if (IID_IAuthenticate == riid)
        *ppv = (IAuthenticate *)this;
    else if (IID_IInternetSecurityManager == riid)
        *ppv = (IInternetSecurityManager *)this;
    else if (IID_IHttpSecurity == riid)
        *ppv = (IHttpSecurity *)this;
    else if ((IID_IUnknown == riid) ||
             (IID_IHlinkFrame == riid))
        *ppv = (IHlinkFrame *)this;
    else
    {
        // DBGIID("CUrlDownload::QueryInterface() failing", riid);
    }

    // Addref through the interface
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CUrlDownload::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CUrlDownload::Release(void)
{
    if (0L != --m_cRef)
        return 1L;

    delete this;
    return 0L;
}

STDMETHODIMP CUrlDownload::GetTypeInfoCount(UINT *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
            DISPPARAMS *pdispparams, VARIANT *pvarResult,
            EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    if (!pvarResult)
        return E_INVALIDARG;

    ASSERT(pvarResult->vt == VT_EMPTY);

    if (wFlags == DISPATCH_PROPERTYGET)
    {
        HRESULT hr = DISP_E_MEMBERNOTFOUND;
        
        switch (dispidMember)
        {
        case DISPID_AMBIENT_DLCONTROL :
            TraceMsg(TF_THISMODULE, "Returning DLCONTROL ambient property 0x%08x", m_lBindFlags);
            pvarResult->vt = VT_I4;
            pvarResult->lVal = m_lBindFlags;
            hr = S_OK;
            break;
        case DISPID_AMBIENT_USERAGENT:
            DBG("Returning User Agent ambient property");
            pvarResult->bstrVal = SysAllocString(GetUserAgent());
            if (pvarResult->bstrVal != NULL)
            {
                pvarResult->vt = VT_BSTR;
                hr = S_OK;
            }
            break;
        }
        return hr;
    }

    return DISP_E_MEMBERNOTFOUND;
}

// IPropertyNotifySink

STDMETHODIMP CUrlDownload::OnChanged(DISPID dispID)
{
    // We've received a notification, extend our timer if it's currently running
    if (m_iTimerID)
        StartTimer();

    if ((DISPID_READYSTATE == dispID) ||
        (DISPID_UNKNOWN == dispID))
    {
        // Find out if we're done
        if (m_fWaitingForReadyState)
        {
            VARIANT     varState;
            DISPPARAMS  dp;

            VariantInit(&varState);

            if (SUCCEEDED(m_pDocument->Invoke(DISPID_READYSTATE, 
                                              IID_NULL, 
                                              GetUserDefaultLCID(), 
                                              DISPATCH_PROPERTYGET, 
                                              &dp, 
                                              &varState, NULL, NULL)) &&
                V_VT(&varState)==VT_I4 && 
                V_I4(&varState)== READYSTATE_COMPLETE)
            {
                m_fWaitingForReadyState = FALSE;
                // Successful download. See if a client-pull is waiting.
                if (m_pwszClientPullURL)
                    PostMessage(m_hwndMe, WM_URLDL_CLIENTPULL, 0, 0);
                else
                    OnDownloadComplete(BDU2_ERROR_NONE);
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CUrlDownload::OnRequestEdit(DISPID dispID)
{
    return S_OK;
}

// IOleCommandTarget
STDMETHODIMP CUrlDownload::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds,
                                    OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    return OLECMDERR_E_UNKNOWNGROUP;
}

STDMETHODIMP CUrlDownload::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
                                DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                                VARIANTARG *pvarargOut)
{
    HRESULT hres = OLECMDERR_E_NOTSUPPORTED;

    if (pguidCmdGroup == NULL) 
    {
        switch(nCmdID) 
        {
        case OLECMDID_SETPROGRESSPOS:
        {
            hres = S_OK;
            VARIANT     varBytes;
            
            if (m_pOleCmdTarget)
            {
                varBytes.vt=VT_EMPTY;
                m_pOleCmdTarget->Exec(&CGID_MSHTML, IDM_GETBYTESDOWNLOADED, 0, NULL, &varBytes);

                if (varBytes.vt == VT_I4)
                {
                    DWORD dwBytes = (DWORD) varBytes.lVal;

                    TraceMsg(TF_THISMODULE, "%d bytes on page so far (mshtml)", dwBytes);

                    ProgressBytes(dwBytes);
                }
            }

            // 14032: If dialmon is around, tell it that something is going on
            IndicateDialmonActivity();

        }
            break;
        //
        // The containee has found an http-equiv meta tag; handle it
        // appropriately (client pull)
        //
        case OLECMDID_HTTPEQUIV_DONE:
            hres = S_OK;
            break;

        case OLECMDID_HTTPEQUIV:
            {
                LPWSTR  pwszEquivString = pvarargIn? pvarargIn->bstrVal : NULL;
                BOOL    fHasHeader = (pwszEquivString!=NULL);

                if (pvarargIn && pvarargIn->vt != VT_BSTR)
                    return OLECMDERR_E_NOTSUPPORTED;

                if (!fHasHeader || StrCmpNIW(c_wszRefresh, pwszEquivString, lstrlenW(c_wszRefresh)) == 0)
                {
                    // Hit.  Now do the right thing for this header
                    // We pass both the header and a pointer to the first char after
                    // ':', which is usually the delimiter handlers will look for.

                    LPWSTR pwszColon = fHasHeader ? StrChrW(pwszEquivString, ':') : NULL;
      
                    // Enforce the : at the end of the header
                    if (fHasHeader && !pwszColon)
                    {
                        return OLECMDERR_E_NOTSUPPORTED;
                    }
             
                    hres = HandleRefresh(pwszEquivString, pwszColon ? pwszColon+1:NULL,
                                         (nCmdID == OLECMDID_HTTPEQUIV_DONE));
                }
            }

            // if we return OLECMDERR_E_NOTSUPPORTED, we don't handle
            // client pull
            break;
        }
    }

    if ((hres == OLECMDERR_E_NOTSUPPORTED) && m_pParent)
    {
        hres = m_pParent->OnOleCommandTargetExec(pguidCmdGroup, nCmdID, nCmdexecopt,
                                                    pvarargIn, pvarargOut);
    }

    return hres;
}

// The basic operation was lifted from shdocvw\basesb.cpp
HRESULT CUrlDownload::HandleRefresh(LPWSTR pwszEquivString, LPWSTR pwszContent, BOOL fDone)
{
    unsigned int uiTimeout = 0;
    WCHAR        awch[INTERNET_MAX_URL_LENGTH];

    if (fDone)
    {
        return S_OK;    // fDone means we don't process this
    }

    // NSCompat: we only honor the first successfully parsed Refresh
    if (m_pwszClientPullURL)
        return S_OK;

    if (!pwszContent ||
        !ParseRefreshContent(pwszContent, &uiTimeout, awch, INTERNET_MAX_URL_LENGTH))
    {
        return OLECMDERR_E_NOTSUPPORTED;   // cannot handle refresh w/o timeout
    }
    
    if (!awch[0])
    {
        DBG("CUrlDownload ignoring client-pull directive with no url");
        return S_OK;
    }

    if (m_iNumClientPull >= MAX_CLIENT_PULL_NUM)
    {
        DBG("Max # client pulls exceeded; ignoring client pull directive");
        return S_OK;
    }

    TraceMsg(TF_THISMODULE, "CUrlDownload client pull (refresh=%d) url=%ws", uiTimeout, awch);
    if (uiTimeout > MAX_CLIENT_PULL_TIMEOUT)
    {
        DBG("Ignoring client-pull directive with large timeout");
        return S_OK;
    }

    m_pwszClientPullURL = StrDupW(awch);

    // If we can't copy the URL, don't set the timer or else we'll
    // keep reloading the same page.

    if (m_pwszClientPullURL == NULL)
        return OLECMDERR_E_NOTSUPPORTED;

    return S_OK;
}

HRESULT CUrlDownload::SetDLCTL(long lFlags)
{
//  TraceMsg(TF_THISMODULE, "CUrlDownload: SetDLCTL %04x", lFlags);
    m_lBindFlags = lFlags | DLCTL_SILENT;
    if (m_fSetResync)
        m_lBindFlags |= DLCTL_RESYNCHRONIZE;

    return S_OK;
}

#define INET_E_AGENT_BIND_IN_PROGRESS 0x800C0FFF

//==============================================================================
//  UrlMon download code
//==============================================================================
HRESULT CUrlDownload::BeginDownloadWithUrlMon(
    LPCWSTR     pwszURL,
    LPTSTR      pszLocalFile,
    IEnumFORMATETC *pEFE)
{
    IStream*    pstm = NULL;
    IMoniker*   pmk = NULL;
    IBindCtx*   pbc = NULL;
    HRESULT hr;

    hr = CreateURLMoniker(NULL, pwszURL, &pmk);
    if (FAILED(hr))
    {
        DBG_WARN("CreateURLMoniker failed");
        goto LErrExit;
    }

    SAFE_RELEASE_BSC();

    m_pCbsc = new CUrlDownload_BSC(m_iMethod, m_iOptions, pszLocalFile);
    if (m_pCbsc == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto LErrExit;
    }

    hr = CreateBindCtx(0, &pbc);
    if (FAILED(hr))
        goto LErrExit;

    if (pEFE)
    {
        hr = RegisterFormatEnumerator(pbc, pEFE, 0);
        if (FAILED(hr))
            DBG_WARN("RegisterFormatEnumerator failed (continuing download)");
    }

    hr = RegisterBindStatusCallback(pbc,
            (IBindStatusCallback *)m_pCbsc,
            0,
            0L);
    if (FAILED(hr))
        goto LErrExit;

    m_pCbsc->SetParent(this);
    m_fbscValid = TRUE;
    m_hrStatus = INET_E_AGENT_BIND_IN_PROGRESS;
    StartTimer();       // Start our timeout
    hr = pmk->BindToStorage(pbc, 0, IID_IStream, (void**)&pstm);

    if (m_hrStatus != INET_E_AGENT_BIND_IN_PROGRESS)
    {
        // Synchronous success or failure. Call OnDownloadComplete.
        // We can't do it in OnStopBinding because Urlmon returns hrStatus=S_OK...
        //   even if it fails.
        if (FAILED(hr) || FAILED(m_hrStatus))
            OnDownloadComplete(BDU2_ERROR_GENERAL);
        else
            OnDownloadComplete(BDU2_ERROR_NONE);

        DBG("Synchronous bind; OnDownloadComplete called");
    }

    m_hrStatus = S_OK;      // need this so we get OnDownloadComplete (asynch OnStopBinding)
    hr = S_OK;              // need this so we don't get extra OnDownloadComplete (BDU2)

    // Bind has started (and maybe completed), release stuff we don't need
    pmk->Release();
    pbc->Release();

    if (pstm)
        pstm->Release();

    return hr;

LErrExit:
    DBG_WARN("Error in CUrlDownload::BeginDownloadWithUrlMon");
    if (pbc) pbc->Release();
    if (pmk) pmk->Release();
    if (pstm) pstm->Release();
    SAFERELEASE(m_pCbsc);

    return hr;
} // CUrlDownload::BeginDownloadWithUrlMon

void CUrlDownload::BSC_OnStartBinding()
{
    DBG("BSC_OnStartBinding");
}

// We only get this call if we're not downloading with the browser.
void CUrlDownload::BSC_OnStopBinding(HRESULT hrStatus, IStream *pStm)
{
    TraceMsg(TF_THISMODULE, "BSC_OnStopBinding (hrStatus=0x%08x)", (long)hrStatus);
    ASSERT(m_pCbsc);

// It is ok to not have stream when we requested it (robots.txt)
//  ASSERT(( pStm &&  (m_iOptions & BDU2_NEEDSTREAM)) ||
//         (!pStm && !(m_iOptions & BDU2_NEEDSTREAM)));
    ASSERT(!pStm || (m_iOptions & BDU2_NEEDSTREAM));
    ASSERT(!m_pStm);

    // Save stream for caller if they requested it
    // We keep it until the release it (ReleaseStream) or nav to another url
    if (pStm && (m_iOptions & BDU2_NEEDSTREAM))
    {
        if (m_pStm) m_pStm->Release();
        m_pStm = pStm;
        m_pStm->AddRef();
    }

    // Send OnDownloadComplete, stop the timer
    if (m_iMethod == BDU2_HEADONLY && m_pstLastModified)
        hrStatus = S_OK;        // We got what we came for (hrStatus will be E_ABORT)

    if (m_hrStatus != INET_E_AGENT_BIND_IN_PROGRESS)
        OnDownloadComplete(SUCCEEDED(hrStatus) ? BDU2_ERROR_NONE : BDU2_ERROR_GENERAL);
    else
    {
        DBG("Not calling OnDownloadComplete; synchronous bind");
        m_hrStatus = hrStatus;
    }

    m_fbscValid = FALSE;
    SAFE_RELEASE_BSC();
}

void CUrlDownload::BSC_OnProgress(ULONG ulProgress, ULONG ulProgressMax)
{
    // extend our timer
    if (m_iTimerID)
        StartTimer();
}

void CUrlDownload::BSC_FoundLastModified(SYSTEMTIME *pstLastModified)
{
    DBG("Received last modified time");

    SAFELOCALFREE(m_pstLastModified);

    m_pstLastModified = (SYSTEMTIME *)MemAlloc(LMEM_FIXED, sizeof(SYSTEMTIME));

    if (m_pstLastModified)
    {
        CopyMemory(m_pstLastModified, pstLastModified, sizeof(SYSTEMTIME));
    }
}

void CUrlDownload::BSC_FoundMimeType(CLIPFORMAT cf)
{
    TraceMsg(TF_THISMODULE, "FoundMimeType %d", (int)cf);

    BOOL fAbort = FALSE, fBrowser=FALSE;
    HRESULT hr=S_OK;

    // Abort if not html if necessary.
    if ((m_iOptions & BDU2_FAIL_IF_NOT_HTML) && (cf != g_cfHTML))
    {
        DBG("Aborting non-HTML download");
        fAbort = TRUE;
        OnDownloadComplete(BDU2_ERROR_NOT_HTML);
    }

    // Abort the UrlMon download if necessary. Fire off
    //  a browser download if necessary.
    if (((m_iMethod == BDU2_SMART) || (m_iMethod == BDU2_SNIFF)) && (cf == g_cfHTML))
    {
        // Switch into the browser.
        ASSERT(m_pwszURL);
        if (m_pwszURL &&
            (m_dwResponseCode != 401))      // Don't bother if it's auth failure
        {
            DBG("Switching UrlMon download into browser");
            hr = BeginDownloadWithBrowser(m_pwszURL);
            if (SUCCEEDED(hr))
                fBrowser = TRUE;
        }
    }

    if (fAbort || fBrowser)
    {
        // Disconnect the BSC so that we don't get any more notifications.
        // If we're switching into the browser, don't abort the UrlMon
        //  download to help avoid getting multiple GET requests. We do
        //  disconnect the BSC but still maintain a ref to it so we abort
        //  it if necessary.
        ASSERT(m_pCbsc);
        if (m_pCbsc)
        {
            m_pCbsc->SetParent(NULL);  // We don't want OnStopBinding

            if (fAbort)
            {
                m_pCbsc->Abort();
                m_pCbsc->Release();
                m_pCbsc=NULL;
                m_fbscValid = FALSE;
            }
        }
    }
}

// Returns content for Accept-Language header
LPCWSTR CUrlDownload::GetAcceptLanguages()
{
    if (0 == m_iLangStatus)
    {
        DWORD cchLang = ARRAYSIZE(m_achLang);

        if (SUCCEEDED(::GetAcceptLanguagesW(m_achLang, &cchLang)))
        {
            m_iLangStatus = 1;
        }
        else
        {
            m_iLangStatus = 2;
        }
    }

    if (1 == m_iLangStatus)
    {
        return m_achLang;
    }
    
    return NULL;
}

HRESULT CUrlDownload::ProgressBytes(DWORD dwBytes)
{
    if (m_dwMaxSize > 0 && dwBytes > m_dwMaxSize)
    {
        TraceMsg(TF_THISMODULE, "CUrlDownload MaxSize exceeded aborting. %d of %d bytes", dwBytes, m_dwMaxSize);

        AbortDownload(BDU2_ERROR_MAXSIZE);
        return E_ABORT;
    }

    return S_OK;
}

//---------------------------------------------------------------
// IServiceProvider
STDMETHODIMP CUrlDownload::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    if ((SID_SHlinkFrame == guidService && IID_IHlinkFrame == riid) ||
        (IID_IAuthenticate == guidService && IID_IAuthenticate == riid) ||
        (SID_SInternetSecurityManager == guidService && IID_IInternetSecurityManager == riid) ||
        (IID_IHttpSecurity == guidService && IID_IHttpSecurity == riid))
    {
        return QueryInterface(riid, ppvObject);
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
}

//---------------------------------------------------------------
//IHttpSecurity
STDMETHODIMP CUrlDownload::OnSecurityProblem(DWORD dwProblem)
{
     
    return S_FALSE;
}

STDMETHODIMP CUrlDownload::GetWindow( REFGUID rguidReason, HWND *phwnd ) {
    
    if(phwnd && m_hwndMe) {
        *phwnd = m_hwndMe;
    } else
        return E_FAIL;

    return S_OK;

}

//---------------------------------------------------------------
// IAuthenticate
STDMETHODIMP CUrlDownload::Authenticate(HWND *phwnd, LPWSTR *ppszUsername, LPWSTR *ppszPassword)
{
    HRESULT hr;
    ASSERT(phwnd && ppszUsername && ppszPassword);
    
    *phwnd = (HWND)-1;
    *ppszUsername = NULL;
    *ppszPassword = NULL;

    if (m_pParent)
        hr = m_pParent->OnAuthenticate(phwnd, ppszUsername, ppszPassword);
    else
        hr = E_NOTIMPL;

    TraceMsg(TF_THISMODULE, "CUrlDownload::Authenticate returning hr=%08x", hr);

    return hr;
}

//---------------------------------------------------------------
// IHlinkFrame
STDMETHODIMP CUrlDownload::SetBrowseContext(IHlinkBrowseContext *pihlbc)
{
    DBG_WARN("CUrlDownload::SetBrowseContext() not implemented");
    return E_NOTIMPL;
}
STDMETHODIMP CUrlDownload::GetBrowseContext(IHlinkBrowseContext **ppihlbc)
{
    DBG_WARN("CUrlDownload::GetBrowseContext() not implemented");
    return E_NOTIMPL;
}
STDMETHODIMP CUrlDownload::Navigate(DWORD grfHLNF, LPBC pbc, IBindStatusCallback *pibsc, IHlink *pihlNavigate)
{
    // We should only get a call through IHlinkFrame->Navigate()
    // when the webcrawler has submitted a form for authentication.
    // Bail out if that's not the case.
    if (!m_fFormSubmitted)
    {
        DBG_WARN("CUrlDownload::Navigate() without a form submission!!!");
        return E_NOTIMPL;
    }

    // Our timer has already been started. If this fails, OnDownloadComplete will get
    //  called when we time out.

    // We don't support a wide variety of parameters.
    ASSERT(grfHLNF == 0);
    ASSERT(pbc);
    ASSERT(pibsc);
    ASSERT(pihlNavigate);

    // Get the moniker from IHlink
    HRESULT hr;
    IMoniker *pmk = NULL;
    hr = pihlNavigate->GetMonikerReference(HLINKGETREF_ABSOLUTE, &pmk, NULL);
    if (SUCCEEDED(hr))
    {
        // Load the URL with the post data.
        // WARNING: What if we get redirected to something other than HTML? (beta 2)
        hr = m_pPersistMk->Load(FALSE, pmk, pbc, 0);
        SAFERELEASE(pmk);
        if (SUCCEEDED(hr))
        {
            m_fBrowserValid = TRUE;
            StartTimer();       // Start our timeout
            // Need to wait again.
            m_fWaitingForReadyState = TRUE;
            DBG("CUrlDownload::Navigate (IHLinkFrame) succeeded");
        }
    }
    return hr;
}
STDMETHODIMP CUrlDownload::OnNavigate(DWORD grfHLNF, IMoniker *pimkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName, DWORD dwreserved)
{
    DBG_WARN("CUrlDownload::OnNavigate() not implemented");
    return E_NOTIMPL;
}
STDMETHODIMP CUrlDownload::UpdateHlink(ULONG uHLID, IMoniker *pimkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName)
{
    DBG_WARN("CUrlDownload::UpdateHlink() not implemented");
    return E_NOTIMPL;
}

//---------------------------------------------------------------------
// IInternetSecurityManager interface
// Used to override security to allow form submits, for form auth sites
HRESULT CUrlDownload::SetSecuritySite(IInternetSecurityMgrSite *pSite)
{
    return E_NOTIMPL;
}

HRESULT CUrlDownload::GetSecuritySite(IInternetSecurityMgrSite **ppSite)
{
    return E_NOTIMPL;
}

HRESULT CUrlDownload::MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CUrlDownload::GetSecurityId(LPCWSTR pwszUrl, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CUrlDownload::ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE __RPC_FAR *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved)
{
    if ((dwAction == URLACTION_HTML_SUBMIT_FORMS_TO) ||
        (dwAction == URLACTION_HTML_SUBMIT_FORMS_FROM))
    {
        return S_OK;
    }
    
    return INET_E_DEFAULT_ACTION;
}

HRESULT CUrlDownload::QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CUrlDownload::SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CUrlDownload::GetZoneMappings(DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}


//---------------------------------------------------------------
// CUrlDownload_BSC class
//---------------------------------------------------------------

CUrlDownload_BSC::CUrlDownload_BSC(
    BDUMethod   iMethod,
    BDUOptions  iOptions,
    LPTSTR      pszLocalFile)
{
    // Maintain global count of objects
    DllAddRef();

    m_cRef = 1;

    m_iMethod = iMethod;
    m_iOptions = iOptions;

    if (NULL != pszLocalFile)
    {
        m_pszLocalFileDest = StrDup(pszLocalFile);
        if (m_iMethod != BDU2_URLMON)
        {
            DBG_WARN("CUrlDownload_BSC changing method to URLMON (local file specified)");
            m_iMethod = BDU2_URLMON;
        }
    }
}

CUrlDownload_BSC::~CUrlDownload_BSC()
{
    // Maintain global count of objects
    DllRelease();

    ASSERT(!m_pBinding);
    SAFERELEASE(m_pstm);
    SAFELOCALFREE(m_pszLocalFileDest);
    SAFELOCALFREE(m_pwszLocalFileSrc);
}

void CUrlDownload_BSC::SetParent(CUrlDownload *pUrlDownload)
{
    m_pParent = pUrlDownload;
}

HRESULT CUrlDownload_BSC::Abort()
{
    if (m_pBinding)
    {
        return m_pBinding->Abort();
    }
    return S_FALSE;
}

STDMETHODIMP CUrlDownload_BSC::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if (riid==IID_IUnknown || riid==IID_IBindStatusCallback)
    {
        *ppv = (IBindStatusCallback *)this;
        AddRef();
        return S_OK;
    }
    if (riid==IID_IHttpNegotiate)
    {
        *ppv = (IHttpNegotiate *)this;
        AddRef();
        return S_OK;
    }
    if (riid==IID_IAuthenticate)
    {
        *ppv = (IAuthenticate *)this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}

//---------------------------------------------------------------
// IAuthenticate
STDMETHODIMP CUrlDownload_BSC::Authenticate(HWND *phwnd, LPWSTR *ppszUsername, LPWSTR *ppszPassword)
{   //copied from CUrlDownload::Authenticate (to whom we pass off anyway)
    HRESULT hr;
    ASSERT(phwnd && ppszUsername && ppszPassword);
    
    *phwnd = (HWND)-1;
    *ppszUsername = NULL;
    *ppszPassword = NULL;

    // Only try this once. If Urlmon asks again, fail it and flag an error.
    if (m_fTriedAuthenticate)
    {
        if (m_pParent)
        {
            m_pParent->m_dwResponseCode = 401;
            DBG("CUrlDownload_BSC::Authenticate called twice. Faking 401 response");
        }

        return E_FAIL;
    }

    m_fTriedAuthenticate = TRUE;

    if (m_pParent)
        hr = m_pParent->Authenticate(phwnd, ppszUsername, ppszPassword);
    else
        hr = E_NOTIMPL;

    if (FAILED(hr) && m_pParent)
    {
        m_pParent->m_dwResponseCode = 401;
        DBG("CUrlDownload_BSC::Authenticate called; no username/pass. Faking 401 response");
    }

    TraceMsg(TF_THISMODULE, "CUrlDownload_BSC::Authenticate returning hr=%08x", hr);

    return hr;
}

STDMETHODIMP CUrlDownload_BSC::OnStartBinding(
    DWORD dwReserved,
    IBinding* pbinding)
{
    m_fSentMimeType = FALSE;
    if (m_pBinding != NULL)
        m_pBinding->Release();
    m_pBinding = pbinding;
    if (m_pBinding != NULL)
    {
        m_pBinding->AddRef();
    }
    if (m_pParent)
        m_pParent->BSC_OnStartBinding();
    return S_OK;
}

// ---------------------------------------------------------------------------
// %%Function: CUrlDownload_BSC::GetPriority
// ---------------------------------------------------------------------------
 STDMETHODIMP
CUrlDownload_BSC::GetPriority(LONG* pnPriority)
{
    return E_NOTIMPL;
}

// ---------------------------------------------------------------------------
// %%Function: CUrlDownload_BSC::OnLowResource
// ---------------------------------------------------------------------------
 STDMETHODIMP
CUrlDownload_BSC::OnLowResource(DWORD dwReserved)
{
    return E_NOTIMPL;
}

// ---------------------------------------------------------------------------
// %%Function: CUrlDownload_BSC::OnProgress
// ---------------------------------------------------------------------------
 STDMETHODIMP
CUrlDownload_BSC::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
{
//  TraceMsg(TF_THISMODULE, "cbsc::OnProgress %d of %d : msg %ws", ulProgress, ulProgressMax, szStatusText);

    /*
    if (ulStatusCode==BINDSTATUS_USINGCACHEDCOPY)
    */
    if (ulStatusCode == BINDSTATUS_REDIRECTING)
    {
        DBG("CUrlDownload_BSC::OnProgress getting redirected url");
        TraceMsg(TF_THISMODULE, "New url=%ws", szStatusText);
        if (m_pParent)
        {
            if (m_pParent->m_pwszURL) MemFree(m_pParent->m_pwszURL);
            m_pParent->m_pwszURL = StrDupW(szStatusText);
        }
    }

    if ((ulStatusCode == BINDSTATUS_CACHEFILENAMEAVAILABLE) && m_pszLocalFileDest)
    {
        ASSERT(!m_pwszLocalFileSrc);
        DBG("CUrlDownload_BSC::OnProgress Getting local file name");
        if (!m_pwszLocalFileSrc)
            m_pwszLocalFileSrc = StrDupW(szStatusText);
    }

    if (m_pParent)
        m_pParent->BSC_OnProgress(ulProgress, ulProgressMax);

    // 14032: If dialmon is around, tell it that something is going on
    IndicateDialmonActivity();

    return S_OK;
}

STDMETHODIMP CUrlDownload_BSC::OnStopBinding(
    HRESULT     hrStatus,
    LPCWSTR     pszError)
{
#ifdef DEBUG
    if (hrStatus && (hrStatus != E_ABORT))
        TraceMsg(TF_THISMODULE,
            "cbsc: File download Failed hr=%08x.", (int)hrStatus);
#endif

    if (m_pParent)
        m_pParent->BSC_OnStopBinding(hrStatus, (m_iOptions&BDU2_NEEDSTREAM) ? m_pstm : NULL);

    // We should have neither or both of these
    ASSERT(!m_pwszLocalFileSrc == !m_pszLocalFileDest);

    if (m_pwszLocalFileSrc && m_pszLocalFileDest)
    {
        // Copy or move file from cache file to file/directory requested
        // We have a LPWSTR source name and an LPTSTR destination
        TCHAR szSrc[MAX_PATH];
        TCHAR szDest[MAX_PATH];
        LPTSTR pszSrcFileName, pszDest=NULL;

        MyOleStrToStrN(szSrc, MAX_PATH, m_pwszLocalFileSrc);

        // Combine paths to find destination filename if necessary
        if (PathIsDirectory(m_pszLocalFileDest))
        {
            pszSrcFileName = PathFindFileName(szSrc);
            if (pszSrcFileName)
            {
                PathCombine(szDest, m_pszLocalFileDest, pszSrcFileName);
                pszDest = szDest;
            }
        }
        else
        {
            pszDest = m_pszLocalFileDest;
        }

        if (pszDest)
        {
            TraceMsg(TF_THISMODULE, "Copying file\n%s\n to file \n%s", szSrc, pszDest);
            CopyFile(szSrc, pszDest, FALSE);
        }
        else
            DBG_WARN("Unable to get dest path for local file");
    }

    SAFERELEASE(m_pstm);
    SAFERELEASE(m_pBinding);

    return S_OK;
}

STDMETHODIMP CUrlDownload_BSC::GetBindInfo(
    DWORD       *pgrfBINDF,
    BINDINFO    *pbindInfo)
{
    if ( !pgrfBINDF || !pbindInfo || !pbindInfo->cbSize )
        return E_INVALIDARG;

    *pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_NO_UI;
    if (m_pszLocalFileDest)
        *pgrfBINDF |= BINDF_NEEDFILE;
    if (m_pParent && m_pParent->m_fSetResync)
        *pgrfBINDF |= BINDF_RESYNCHRONIZE;
    if (m_pParent && (m_pParent->m_lBindFlags & DLCTL_FORCEOFFLINE))
        *pgrfBINDF |= BINDF_OFFLINEOPERATION;

    // clear BINDINFO but keep its size
    DWORD cbSize = pbindInfo->cbSize;
    ZeroMemory( pbindInfo, cbSize );
    pbindInfo->cbSize = cbSize;

    pbindInfo->dwBindVerb = BINDVERB_GET;

    if (m_iMethod == BDU2_HEADONLY)
    {
        LPWSTR pwszVerb = (LPWSTR) CoTaskMemAlloc(sizeof(c_wszHeadVerb));
        if (pwszVerb)
        {
            CopyMemory(pwszVerb, c_wszHeadVerb, sizeof(c_wszHeadVerb));
            pbindInfo->dwBindVerb = BINDVERB_CUSTOM;
            pbindInfo->szCustomVerb = pwszVerb;
            DBG("Using 'HEAD' custom bind verb.");
        }
        else
        {
            DBG_WARN("MemAlloc failure CUrlDownload_BSC::GetBindInfo");
            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}

STDMETHODIMP CUrlDownload_BSC::OnDataAvailable(
    DWORD grfBSCF,
    DWORD dwSize,
    FORMATETC* pfmtetc,
    STGMEDIUM* pstgmed)
{
    TraceMsg(TF_THISMODULE, "%d bytes on page so far (urlmon)", dwSize);

    if (m_pParent)
        if (FAILED(m_pParent->ProgressBytes(dwSize)))
            return S_OK;

        // Get the Stream passed if we want a local file (to lock the file)
    // We just ignore any data in any case
    if (BSCF_FIRSTDATANOTIFICATION & grfBSCF)
    {
        if (!m_pstm && (pstgmed->tymed==TYMED_ISTREAM) &&
            (m_pszLocalFileDest || (m_iOptions & BDU2_NEEDSTREAM)))
        {
            m_pstm = pstgmed->pstm;
            if (m_pstm)
                m_pstm->AddRef();
        }
    }

    if (!m_fSentMimeType && pfmtetc && m_pParent)
    {
        m_pParent->BSC_FoundMimeType(pfmtetc->cfFormat);
        m_fSentMimeType = TRUE;
    }

    if (BSCF_LASTDATANOTIFICATION & grfBSCF)
    {
        DBG("cbsc: LastDataNotification");
    }

    return S_OK;
}  // CUrlDownload_BSC::OnDataAvailable

STDMETHODIMP CUrlDownload_BSC::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload_BSC::BeginningTransaction(
        LPCWSTR szURL,      LPCWSTR szHeaders,
        DWORD dwReserved,   LPWSTR *pszAdditionalHeaders)
{
    // Add User-Agent and Accept-Language headers
    DBG("CUrlDownload_BSC::BeginningTransaction returning headers");

    LPCWSTR pwszAcceptLanguage;
    int iUAlen=0, iALlen=0;     // in chars, with \r\n, without null-term
    LPWSTR pwsz;
    LPCWSTR pwszUA = m_pParent ? m_pParent->GetUserAgent() : NULL;
    
    pwszAcceptLanguage = (m_pParent) ? m_pParent->GetAcceptLanguages() : NULL;

    if (pwszUA)
    {
        iUAlen = ARRAYSIZE(c_szUserAgentPrefix) + lstrlenW(pwszUA) + 1;
    }
    
    if (pwszAcceptLanguage)
    {
        iALlen = ARRAYSIZE(c_szAcceptLanguagePrefix) + lstrlenW(pwszAcceptLanguage)+1;
    }

    if (iUAlen || iALlen)
    {
        pwsz = (WCHAR *)CoTaskMemAlloc((iUAlen + iALlen + 1) * sizeof(WCHAR));

        if (pwsz)
        {
            pwsz[0] = L'\0';
            
            if (iUAlen)
            {
                StrCpyW(pwsz, c_szUserAgentPrefix);
                StrCatW(pwsz, pwszUA);
                StrCatW(pwsz, L"\r\n");
            }

            if (iALlen)
            {
                StrCatW(pwsz, c_szAcceptLanguagePrefix);
                StrCatW(pwsz, pwszAcceptLanguage);
                StrCatW(pwsz, L"\r\n");
            }

            ASSERT(lstrlenW(pwsz) == (iUAlen + iALlen));

            *pszAdditionalHeaders = pwsz;

            return S_OK;
        }
    }

    return E_OUTOFMEMORY;
}
    
STDMETHODIMP CUrlDownload_BSC::OnResponse(
        DWORD   dwResponseCode,     LPCWSTR szResponseHeaders, 
        LPCWSTR szRequestHeaders,   LPWSTR *pszAdditionalRequestHeaders)
{
    TraceMsg(TF_THISMODULE, "CUrlDownload_BSC::OnResponse - %d", dwResponseCode);

    // If we sent a "HEAD" request, Urlmon will hang expecting data.
    // Abort it here.
    if (m_iMethod == BDU2_HEADONLY)
    {
        // First get the Last-Modified date from Urlmon
        IWinInetHttpInfo    *pInfo;

        if (m_pParent
            && SUCCEEDED(m_pBinding->QueryInterface(IID_IWinInetHttpInfo, (void **)&pInfo)
            && pInfo))
        {
            SYSTEMTIME  st;
            DWORD       dwSize = sizeof(st), dwZero=0;

            if (SUCCEEDED(pInfo->QueryInfo(HTTP_QUERY_FLAG_SYSTEMTIME | HTTP_QUERY_LAST_MODIFIED,
                                           (LPVOID) &st, &dwSize, &dwZero, 0)))
            {
                m_pParent->BSC_FoundLastModified(&st);
            }

            pInfo->Release();
        }
        Abort();    // FEATURE: return E_ABORT and handle abort internally
    }

    if (m_pParent)
        m_pParent->m_dwResponseCode = dwResponseCode;
    else
        DBG_WARN("CUrlDownload_BSC::OnResponse - Parent already NULL");

    return S_OK;
}

//
// IOleClientSite
//
STDMETHODIMP CUrlDownload:: SaveObject(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload:: GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk)
{
    DBG("CUrlDownload::GetMoniker returning failure");
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload:: GetContainer(IOleContainer **ppContainer)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload:: ShowObject(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload:: OnShowWindow(BOOL fShow)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload:: RequestNewObjectLayout(void)
{
    return E_NOTIMPL;
}



// ParseRefreshContent was lifted in its entirety from shdocvw\basesb.cpp
BOOL ParseRefreshContent(LPWSTR pwzContent,
    UINT * puiDelay, LPWSTR pwzUrlBuf, UINT cchUrlBuf)
{
    // We are parsing the following string:
    //
    //  [ws]* [0-9]+ [ws]* ; [ws]* url [ws]* = [ws]* { ' | " } [any]* { ' | " }
    //
    // Netscape insists that the string begins with a delay.  If not, it
    // ignores the entire directive.  There can be more than one URL mentioned,
    // and the last one wins.  An empty URL is treated the same as not having
    // a URL at all.  An empty URL which follows a non-empty URL resets
    // the previous URL.

    enum { PRC_START, PRC_DIG, PRC_DIG_WS, PRC_SEMI, PRC_SEMI_URL,
        PRC_SEMI_URL_EQL, PRC_SEMI_URL_EQL_ANY };
    #define ISSPACE(ch) (((ch) == 32) || ((unsigned)((ch) - 9)) <= 13 - 9)

    UINT uiState = PRC_START;
    UINT uiDelay = 0;
    LPWSTR pwz = pwzContent;
    LPWSTR pwzUrl = NULL;
    UINT   cchUrl = 0;
    WCHAR  wch,  wchDel = 0;

    *pwzUrlBuf = 0;

    do
    {
        wch = *pwz;

        switch (uiState)
        {
            case PRC_START:
                if (wch >= TEXT('0') && wch <= TEXT('9'))
                {
                    uiState = PRC_DIG;
                    uiDelay = wch - TEXT('0');
                }
                else if (!ISSPACE(wch))
                    goto done;
                break;

            case PRC_DIG:
                if (wch >= TEXT('0') && wch <= TEXT('9'))
                    uiDelay = uiDelay * 10 + wch - TEXT('0');
                else if (ISSPACE(wch))
                    uiState = PRC_DIG_WS;
                else if (wch == TEXT(';'))
                    uiState = PRC_SEMI;
                else
                    goto done;
                break;

            case PRC_DIG_WS:
                if (wch == TEXT(';'))
                    uiState = PRC_SEMI;
                else if (!ISSPACE(wch))
                    goto done;
                break;

            case PRC_SEMI:
                if (    (wch == TEXT('u') || wch == TEXT('U'))
                    &&  (pwz[1] == TEXT('r') || pwz[1] == TEXT('R'))
                    &&  (pwz[2] == TEXT('l') || pwz[2] == TEXT('L')))
                {
                    uiState = PRC_SEMI_URL;
                    pwz += 2;
                }
                else if (!ISSPACE(wch) && wch != TEXT(';'))
                    goto done;
                break;

            case PRC_SEMI_URL:
                if (wch == TEXT('='))
                {
                    uiState = PRC_SEMI_URL_EQL;
                    *pwzUrlBuf = 0;
                }
                else if (wch == TEXT(';'))
                    uiState = PRC_SEMI;
                else if (!ISSPACE(wch))
                    goto done;
                break;

            case PRC_SEMI_URL_EQL:
                if (wch == TEXT(';'))
                    uiState = PRC_SEMI;
                else if (!ISSPACE(wch))
                {
                    uiState = PRC_SEMI_URL_EQL_ANY;

                    pwzUrl = pwzUrlBuf;
                    cchUrl = cchUrlBuf;

                    if (wch == TEXT('\'')|| wch == TEXT('\"'))
                        wchDel = wch;
                    else
                    {
                        wchDel = 0;
                        *pwzUrl++ = wch;
                        cchUrl--;
                    }
                }
                break;
                        
            case PRC_SEMI_URL_EQL_ANY:
                if (    !wch
                    ||  ( wchDel && wch == wchDel)
                    ||  (!wchDel && wch == L';'))
                {
                    *pwzUrl = 0;
                    uiState = wch == TEXT(';') ? PRC_SEMI : PRC_DIG_WS;
                }
                else if (cchUrl > 1)
                {
                    *pwzUrl++ = wch;
                    cchUrl--;
                }
                break;
        }

        ++pwz;

    } while (wch);

done:

    *puiDelay = uiDelay;

    return(uiState >= PRC_DIG);
} // ParseRefreshContent
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\factory.h ===
#ifndef _factory_h
#define _factory_h

#define FD_ALLOWAGGREGATION     0x00000001

struct CFactoryData
{
    CLSID const *m_pClsid;
    CREATEPROC  m_pCreateProc;
    DWORD       m_dwFlags;
};

class CClassFactory : public IClassFactory
{
public:
    CClassFactory(const CFactoryData *pFactoryData);
    ~CClassFactory();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory members
    STDMETHODIMP         CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void **ppvObj);
    STDMETHODIMP         LockServer(BOOL fLock);

private:
    ULONG               m_cRef;
    const CFactoryData  *m_pFactoryData;
};

#endif // _factory_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\factory.cpp ===
#include "private.h"
#include "factory.h"

CClassFactory::CClassFactory(const CFactoryData *pFactoryData) :
    m_pFactoryData(pFactoryData)
{
    ASSERT(NULL != m_pFactoryData);

    m_cRef = 1;

    DllAddRef();
}

CClassFactory::~CClassFactory()
{
    DllRelease();
}

// IUnknown members
STDMETHODIMP CClassFactory::QueryInterface(
    REFIID riid, void **ppv)
{
    if (NULL == ppv)
    {
        return E_INVALIDARG;
    }
    
    *ppv=NULL;

    // Validate requested interface
    if( IID_IUnknown == riid || IID_IClassFactory == riid )
        *ppv = (IClassFactory *)this;

    // Addref through the interface
    if( NULL != *ppv ) {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

// IClassFactory members
STDMETHODIMP CClassFactory::CreateInstance(
    LPUNKNOWN punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;

    if ((NULL == ppv) ||
        (punkOuter && (IID_IUnknown != riid)))
    {
        return E_INVALIDARG;
    }

    *ppv = NULL;

    if ((NULL != punkOuter) && 
        !(m_pFactoryData->m_dwFlags & FD_ALLOWAGGREGATION))
    {
        return CLASS_E_NOAGGREGATION;
    }

    IUnknown *punk;
    hr = m_pFactoryData->m_pCreateProc(punkOuter, &punk);

    if (SUCCEEDED(hr))
    {
        hr = punk->QueryInterface(riid, ppv);
        punk->Release();
    }

    ASSERT((SUCCEEDED(hr) && (NULL != *ppv)) || 
           (FAILED(hr) && (NULL == *ppv)))

    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
        DllLock();
    }
    else
    {
        DllUnlock();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\droptrgt.cpp ===
#include "private.h"
#include "offl_cpp.h"
#include "subsmgrp.h"

HRESULT _GetURLData(IDataObject *, int, TCHAR *, TCHAR *);
HRESULT _ConvertHDROPData(IDataObject *, BOOL);
HRESULT ScheduleDefault(LPCTSTR, LPCTSTR);

#define CITBDTYPE_HDROP     1
#define CITBDTYPE_URL       2
#define CITBDTYPE_TEXT      3

//
// Constructor
//

COfflineDropTarget::COfflineDropTarget(HWND hwndParent)
{
    m_cRefs                 = 1;
    m_hwndParent            = hwndParent;
    m_pDataObj              = NULL;
    m_grfKeyStateLast       = 0;
    m_fHasHDROP             = FALSE;
    m_fHasSHELLURL          = FALSE;
    m_fHasTEXT              = FALSE;
    m_dwEffectLastReturned  = 0;

    DllAddRef();
}

//
// Destructor
//

COfflineDropTarget::~COfflineDropTarget()
{
    DllRelease();
}

//
// QueryInterface
//

STDMETHODIMP COfflineDropTarget::QueryInterface(REFIID riid, LPVOID *ppv)
{
    HRESULT  hr = E_NOINTERFACE;

    *ppv = NULL;

    // Any interface on this object is the object pointer

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDropTarget))
    {
        *ppv = (LPDROPTARGET)this;

        AddRef();

        hr = NOERROR;
    }

    return hr;
}   

//
// AddRef
//

STDMETHODIMP_(ULONG) COfflineDropTarget::AddRef()
{
    return ++m_cRefs;
}

//
// Release
//

STDMETHODIMP_(ULONG) COfflineDropTarget::Release()
{
    if (0L != --m_cRefs)
    {
        return m_cRefs;
    }

    delete this;

    return 0L;
}

//
// DragEnter
//

STDMETHODIMP COfflineDropTarget::DragEnter(LPDATAOBJECT pDataObj, 
                                           DWORD        grfKeyState,
                                           POINTL       pt, 
                                           LPDWORD      pdwEffect)
{
    // Release any old data object we might have

//    TraceMsg(TF_SUBSFOLDER, TEXT("odt - DragEnter"));
    if (m_pDataObj)
    {
        m_pDataObj->Release();
    }

    m_grfKeyStateLast = grfKeyState;
    m_pDataObj        = pDataObj;

    //
    // See if we will be able to get CF_HDROP from this guy
    //

    if (pDataObj)
    {
        pDataObj->AddRef();
            TCHAR url[INTERNET_MAX_URL_LENGTH], name[MAX_NAME_QUICKLINK];
            FORMATETC fe = {(CLIPFORMAT) RegisterClipboardFormat(CFSTR_SHELLURL), 
                        NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

            m_fHasSHELLURL = m_fHasHDROP = m_fHasTEXT = FALSE;
            if (NOERROR == pDataObj->QueryGetData(&fe))
            {
                TraceMsg(TF_SUBSFOLDER, "odt - DragEnter : SHELLURL!");
                m_fHasSHELLURL = 
                    (NOERROR == _GetURLData(pDataObj,CITBDTYPE_URL,url,name));
            }
            if (fe.cfFormat = CF_HDROP, NOERROR == pDataObj->QueryGetData(&fe))
            {
                TraceMsg(TF_SUBSFOLDER, "odt - DragEnter : HDROP!");
                m_fHasHDROP = (NOERROR == 
                    _ConvertHDROPData(pDataObj, FALSE));
            }
            if (fe.cfFormat = CF_TEXT, NOERROR == pDataObj->QueryGetData(&fe))
            {
                TraceMsg(TF_SUBSFOLDER, "odt - DragEnter : TEXT!");
                m_fHasTEXT = 
                    (NOERROR == _GetURLData(pDataObj,CITBDTYPE_TEXT,url,name));
            }
    }

    // Save the drop effect

    if (pdwEffect)
    {
        *pdwEffect = m_dwEffectLastReturned = GetDropEffect(pdwEffect);
    }

    return S_OK;
}

//
// GetDropEffect
//

DWORD COfflineDropTarget::GetDropEffect(LPDWORD pdwEffect)
{
    ASSERT(pdwEffect);

    if (m_fHasSHELLURL || m_fHasTEXT)
    {
        return *pdwEffect & (DROPEFFECT_COPY | DROPEFFECT_LINK);
    }
    else if (m_fHasHDROP)    {
        return *pdwEffect & (DROPEFFECT_COPY );
    }
    else
    {
        return DROPEFFECT_NONE;
    }
}

//
// DragOver
//

STDMETHODIMP COfflineDropTarget::DragOver(DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect)
{
//    TraceMsg(TF_SUBSFOLDER, TEXT("odt - DragOver"));
    if (m_grfKeyStateLast == grfKeyState)
    {
        // Return the effect we saved at dragenter time

        if (*pdwEffect)
        {
            *pdwEffect = m_dwEffectLastReturned;
        }
    }
    else
    {
        if (*pdwEffect)
        {
            *pdwEffect = m_dwEffectLastReturned = GetDropEffect(pdwEffect);
        }
    }

    m_grfKeyStateLast = grfKeyState;

    return S_OK;
}

//
// DragLeave
//
 
STDMETHODIMP COfflineDropTarget::DragLeave()
{
//    TraceMsg(TF_SUBSFOLDER, TEXT("odt - DragLeave"));
    if (m_pDataObj)
    {
        m_pDataObj->Release();
        m_pDataObj = NULL;
    }

    return S_OK;
}

//
// Drop
//
STDMETHODIMP COfflineDropTarget::Drop(LPDATAOBJECT pDataObj,
                                      DWORD        grfKeyState, 
                                      POINTL       pt, 
                                      LPDWORD      pdwEffect)
{
//    UINT idCmd;             // Choice from drop popup menu
    HRESULT hr = S_OK;
  
    //
    // Take the new data object, since OLE can give us a different one than
    // it did in DragEnter
    //

//    TraceMsg(TF_SUBSFOLDER, TEXT("odt - Drop"));
    if (m_pDataObj)
    {
        m_pDataObj->Release();
    }
    m_pDataObj = pDataObj;
    if (pDataObj)
    {
        pDataObj->AddRef();
    }

    // If the dataobject doesn't have an HDROP, its not much good to us

    *pdwEffect &= DROPEFFECT_COPY|DROPEFFECT_LINK; 
    if (!(*pdwEffect))  {
        DragLeave();        
        return S_OK;
    }


    hr = E_NOINTERFACE;
    if (m_fHasHDROP)
        hr = _ConvertHDROPData(pDataObj, TRUE);
    else  {
        TCHAR url[INTERNET_MAX_URL_LENGTH], name[MAX_NAME_QUICKLINK];
        if (m_fHasSHELLURL)
            hr = _GetURLData(pDataObj, CITBDTYPE_URL,   url, name);
        if (FAILED(hr) && m_fHasTEXT)
            hr = _GetURLData(pDataObj, CITBDTYPE_TEXT,  url, name);
        if (SUCCEEDED(hr))  {
            TraceMsg(TF_SUBSFOLDER, "URL: %s, Name: %s", url, name);  
            hr = ScheduleDefault(url, name);
        }
    }

    if (FAILED(hr))
    {
        TraceMsg(TF_SUBSFOLDER, "Couldn't DROP");
    }

    DragLeave();
    return hr;
}

HRESULT _CLSIDFromExtension(
    LPCTSTR pszExt, 
    CLSID *pclsid)
{
    TCHAR szProgID[80];
    long cb = SIZEOF(szProgID);
    if (RegQueryValue(HKEY_CLASSES_ROOT, pszExt, szProgID, &cb) == ERROR_SUCCESS)
    {
        TCHAR szCLSID[80];
        
        StrCatN(szProgID, TEXT("\\CLSID"), ARRAYSIZE(szProgID)); 
        cb = SIZEOF(szCLSID);

        if (RegQueryValue(HKEY_CLASSES_ROOT, szProgID, szCLSID, &cb) == ERROR_SUCCESS)
        {
            // FEATURE (scotth): call shell32's SHCLSIDFromString once it
            //                  exports A/W versions.  This would clean this
            //                  up.
#ifdef UNICODE
            return CLSIDFromString(szCLSID, pclsid);
#else
            WCHAR wszCLSID[80];
            MultiByteToWideChar(CP_ACP, 0, szCLSID, -1, wszCLSID, ARRAYSIZE(wszCLSID));
            return CLSIDFromString(wszCLSID, pclsid);
#endif
        }
    }
    return E_FAIL;
}


// get the target of a shortcut. this uses IShellLink which 
// Internet Shortcuts (.URL) and Shell Shortcuts (.LNK) support so
// it should work generally
//
HRESULT _GetURLTarget(LPCTSTR pszPath, LPTSTR pszTarget, UINT cch)
{
    IShellLink *psl;
    HRESULT hr = E_FAIL;
    CLSID clsid;

    if (FAILED(_CLSIDFromExtension(PathFindExtension(pszPath), &clsid)))
        clsid = CLSID_ShellLink;        // assume it's a shell link

    hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (LPVOID *)&psl);

    if (SUCCEEDED(hr))
    {
        IPersistFile *ppf;

        hr = psl->QueryInterface(IID_IPersistFile, (void **)&ppf);
        if (SUCCEEDED(hr))
        {
#ifdef UNICODE
            hr = ppf->Load(pszPath, 0);
#else
            WCHAR wszPath[MAX_PATH];
            MultiByteToWideChar(CP_ACP, 0, pszPath, -1, wszPath, ARRAYSIZE(wszPath));

            hr = ppf->Load (wszPath, 0);
#endif
            ppf->Release();
        }
        if (SUCCEEDED(hr))  {
            IUniformResourceLocator * purl;

            hr = psl->QueryInterface(IID_IUniformResourceLocator,(void**)&purl);
            if (SUCCEEDED(hr))
                purl->Release();
        }
        if (SUCCEEDED(hr))
            hr = psl->GetPath(pszTarget, cch, NULL, SLGP_UNCPRIORITY);
        psl->Release();
    }
    return hr;
}

HRESULT _ConvertHDROPData(IDataObject *pdtobj, BOOL bSubscribe)
{
    HRESULT hRes = NOERROR;
    STGMEDIUM stgmedium;
    FORMATETC formatetc;
    TCHAR    url[INTERNET_MAX_URL_LENGTH];
    TCHAR    name[MAX_NAME_QUICKLINK];

    name[0] = 0;
    url[0] = 0;

    formatetc.cfFormat = CF_HDROP;
    formatetc.ptd = NULL;
    formatetc.dwAspect = DVASPECT_CONTENT;
    formatetc.lindex = -1;
    formatetc.tymed = TYMED_HGLOBAL;

    // Get the parse string
    hRes = pdtobj->GetData(&formatetc, &stgmedium);
    if (SUCCEEDED(hRes))
    {
        LPTSTR pszURLData = (LPTSTR)GlobalLock(stgmedium.hGlobal);
        if (pszURLData) {
            TCHAR szPath[MAX_PATH];
            SHFILEINFO sfi;
            int cFiles, i;
            HDROP hDrop = (HDROP)stgmedium.hGlobal;

            hRes = S_FALSE;
            cFiles = DragQueryFile(hDrop, 0xFFFFFFFF, NULL, 0);
            for (i = 0; i < cFiles; i ++)   {
                DragQueryFile(hDrop, i, szPath, ARRAYSIZE(szPath));

                // defaults...
                StrCpyN(name, szPath, MAX_NAME_QUICKLINK);

                if (SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME))
                    StrCpyN(name, sfi.szDisplayName, MAX_NAME_QUICKLINK);

                if (SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi),SHGFI_ATTRIBUTES)
                        && (sfi.dwAttributes & SFGAO_LINK))
                {
                    if (SUCCEEDED(_GetURLTarget(szPath, url, INTERNET_MAX_URL_LENGTH)))
                    { 
                        TraceMsg(TF_SUBSFOLDER, "URL: %s, Name: %s", url, name);  
                        //  If we just want to see whether there is some urls
                        //  here, we can break now.
                        if (!bSubscribe)    
                        {
                            if ((IsHTTPPrefixed(url)) && 
                                (!SHRestricted2(REST_NoAddingSubscriptions, url, 0)))
                            {
                                hRes = S_OK;
                            }
                            break;
                        }
                        hRes = ScheduleDefault(url, name);
                    }
                }
            }
            GlobalUnlock(stgmedium.hGlobal);
            if (bSubscribe)
                hRes = S_OK;
        } else
            hRes = S_FALSE;

        ReleaseStgMedium(&stgmedium);
    }
    return hRes;
}
    
//  Takes a variety of inputs and returns a string for drop targets.
//  szUrl:    the URL
//  szName:   the name (for quicklinks and the confo dialog boxes)
//  returns:  NOERROR if succeeded
//
HRESULT _GetURLData(IDataObject *pdtobj, int iDropType, TCHAR *pszUrl, TCHAR *pszName)
{
    HRESULT hRes = NOERROR;
    STGMEDIUM stgmedium;
    FORMATETC formatetc;

    *pszName = 0;
    *pszUrl = 0;

    switch (iDropType)
    {
    case CITBDTYPE_URL:
        formatetc.cfFormat = (CLIPFORMAT) RegisterClipboardFormat(CFSTR_SHELLURL);
        break;
    case CITBDTYPE_TEXT:
        formatetc.cfFormat = CF_TEXT;
        break;
    default:
        return E_UNEXPECTED;
    }
    formatetc.ptd = NULL;
    formatetc.dwAspect = DVASPECT_CONTENT;
    formatetc.lindex = -1;
    formatetc.tymed = TYMED_HGLOBAL;

    // Get the parse string
    hRes = pdtobj->GetData(&formatetc, &stgmedium);
    if (SUCCEEDED(hRes))
    {
        LPTSTR pszURLData = (LPTSTR)GlobalLock(stgmedium.hGlobal);
        if (pszURLData)
        {
            if (iDropType == CITBDTYPE_URL)
            {
                STGMEDIUM stgmediumFGD;

                 // defaults
                StrCpyN(pszUrl,  pszURLData, INTERNET_MAX_URL_LENGTH);
                StrCpyN(pszName, pszURLData, MAX_NAME_QUICKLINK);

                formatetc.cfFormat = (CLIPFORMAT) RegisterClipboardFormat(CFSTR_FILEDESCRIPTOR);
                if (SUCCEEDED(pdtobj->GetData(&formatetc, &stgmediumFGD)))
                {
                    FILEGROUPDESCRIPTOR *pfgd = (FILEGROUPDESCRIPTOR *)GlobalLock(stgmediumFGD.hGlobal);
                    if (pfgd)
                    {
                        TCHAR szPath[MAX_PATH];
                        StrCpyN(szPath, pfgd->fgd[0].cFileName, ARRAYSIZE(szPath));
                        PathRemoveExtension(szPath);
                        StrCpyN(pszName, szPath, MAX_NAME_QUICKLINK);
                        GlobalUnlock(stgmediumFGD.hGlobal);
                    }
                    ReleaseStgMedium(&stgmediumFGD);
                }
            }
            else if (iDropType == CITBDTYPE_TEXT)
            {
                if (PathIsURL(pszURLData))  {
                    StrCpyN(pszUrl, pszURLData, INTERNET_MAX_URL_LENGTH);
                    StrCpyN(pszName, pszURLData, MAX_NAME_QUICKLINK);
                } else
                    hRes = E_FAIL;
            }
            GlobalUnlock(stgmedium.hGlobal);
        }
        ReleaseStgMedium(&stgmedium);
    }

    if (SUCCEEDED(hRes))
    {
        if (!IsHTTPPrefixed(pszUrl) || SHRestricted2(REST_NoAddingSubscriptions, pszUrl, 0))
        {
            hRes = E_FAIL;
        }
    }
    return hRes;
}

HRESULT ScheduleDefault(LPCTSTR url, LPCTSTR name)
{
    if (!IsHTTPPrefixed(url))
        return E_INVALIDARG;

    ISubscriptionMgr    * pSub= NULL;
    HRESULT hr = CoInitialize(NULL);
    RETURN_ON_FAILURE(hr);

    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, 
                IID_ISubscriptionMgr, (void **)&pSub);
    CoUninitialize();
    RETURN_ON_FAILURE(hr);
    ASSERT(pSub);

    BSTR    bstrURL = NULL, bstrName = NULL;
    hr = CreateBSTRFromTSTR(&bstrURL, url);
    if (S_OK == hr)
        hr = CreateBSTRFromTSTR(&bstrName, name);

    //  We need a perfectly valid structure.
    SUBSCRIPTIONINFO    subInfo;
    ZeroMemory((void *)&subInfo, sizeof (SUBSCRIPTIONINFO));
    subInfo.cbSize = sizeof(SUBSCRIPTIONINFO);

    if (S_OK == hr)
        hr = pSub->CreateSubscription(NULL, bstrURL, bstrName,
                                      CREATESUBS_NOUI, SUBSTYPE_URL, &subInfo);

    SAFERELEASE(pSub);
    SAFEFREEBSTR(bstrURL);
    SAFEFREEBSTR(bstrName);

    if (FAILED(hr)) {
        TraceMsg(TF_ALWAYS, "Failed to add default object.");
        TraceMsg(TF_ALWAYS, "  hr = 0x%x\n", hr);
        return (FAILED(hr))?hr:E_FAIL;
    } else if (hr == S_FALSE)   {
        TraceMsg(TF_SUBSFOLDER, "%s(%s) is already there.", url, name);
        return hr;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\filetime.h ===
#ifndef _FILETIME_H_
#define _FILETIME_H_

//**************************************************************************
//  NOTE:  This file is duplicated in urlmon and webcheck.  If you make 
//         changes please sync them!
//**************************************************************************

#define MAKEINT64(lo, hi)   ((__int64)(((DWORD)(lo)) | ((__int64)((DWORD)(hi))) << 32))

#ifndef LODWORD
#define LODWORD(i)          ((DWORD)(i))
#endif

#ifndef HIDWORD
#define HIDWORD(i)          ((DWORD)(((__int64)(i) >> 32) & 0xFFFFFFFF))
#endif

// This is Monday, January 1, 1601 at 12:00:00 am
#define MIN_FILETIME            0i64

// This is Thursday, September 14, 30828 at 2:48:05 am
#define MAX_FILETIME            0x7FFFFFFFFFFFFFFFi64

//  For clarity since FILETIME is expressed as 100-nanosecond intervals
#define ONE_SECOND_IN_FILETIME  10000000i64
#define ONE_MSEC_IN_FILEITME    10000i64
#define ONE_MINUTE_IN_FILETIME  (ONE_SECOND_IN_FILETIME * 60i64)

struct CFileTime : public FILETIME
{
    // Constructors
    CFileTime()             { *this = 0; }
    CFileTime(const FILETIME& f)  { *this = f; }
    CFileTime(const CFileTime& f) { *this = f; }
    CFileTime(__int64 i)    { *this = i; }

    // Assignment operators
    inline CFileTime& operator = (const FILETIME& f)
    {   
        dwLowDateTime = f.dwLowDateTime;
        dwHighDateTime = f.dwHighDateTime;
        return *this;
    }

    inline CFileTime& operator = (const CFileTime& f)
    {   
        dwLowDateTime = f.dwLowDateTime;
        dwHighDateTime = f.dwHighDateTime;
        return *this;
    }

    inline CFileTime& operator = (__int64 i)
    {   
        dwLowDateTime = LODWORD(i);
        dwHighDateTime = HIDWORD(i);
        return *this;
    }

    // Comparison operators
    inline BOOL operator == (__int64 i)
    {   
        return MAKEINT64(dwLowDateTime, dwHighDateTime) == i;
    }

    inline BOOL operator > (__int64 i)
    {   
        return MAKEINT64(dwLowDateTime, dwHighDateTime) > i;
    }

    inline BOOL operator < (__int64 i)
    {   
        return MAKEINT64(dwLowDateTime, dwHighDateTime) < i;
    }

    inline BOOL operator != (__int64 i)
    {   
        return !(*this == i);
    }

    inline BOOL operator >= (__int64 i)
    {   
        return !(*this < i);
    }

    inline BOOL operator <= (__int64 i)
    {   
        return !(*this > i);
    }

    inline BOOL operator == (const FILETIME& f)
    {   
        return *this == MAKEINT64(f.dwLowDateTime, f.dwHighDateTime);
    }

    inline BOOL operator > (const FILETIME& f)
    {   
        return *this > MAKEINT64(f.dwLowDateTime, f.dwHighDateTime);
    }

    inline BOOL operator < (const FILETIME& f)
    {   
        return *this < MAKEINT64(f.dwLowDateTime, f.dwHighDateTime);
    }

    inline BOOL operator != (const FILETIME& f)
    {   
        return !(*this == f);
    }

    inline BOOL operator >= (const FILETIME& f)
    {   
        return !(*this < f);
    }

    inline BOOL operator <= (const FILETIME& f)
    {   
        return !(*this > f);
    }

    // Arithemetic operators
    inline CFileTime operator + (__int64 i)
    {
        return CFileTime(MAKEINT64(dwLowDateTime, dwHighDateTime) + i);
    }
    
    inline CFileTime operator += (__int64 i)
    {
        *this = *this + i;
        return *this;
    }

    inline CFileTime operator - (__int64 i)
    {
        return CFileTime(MAKEINT64(dwLowDateTime, dwHighDateTime) - i);
    }
    
    inline CFileTime operator -= (__int64 i)
    {
        *this = *this - i;
        return *this;
    }

    inline CFileTime operator * (__int64 i)
    {
        return CFileTime(MAKEINT64(dwLowDateTime, dwHighDateTime) * i);
    }
    
    inline CFileTime operator *= (__int64 i)
    {
        *this = *this * i;
        return *this;
    }

    inline CFileTime operator / (__int64 i)
    {
        return CFileTime(MAKEINT64(dwLowDateTime, dwHighDateTime) / i);
    }
    
    inline CFileTime operator /= (__int64 i)
    {
        *this = *this / i;
        return *this;
    }

    inline CFileTime operator + (const FILETIME& f)
    {
        return *this + MAKEINT64(f.dwLowDateTime, f.dwHighDateTime);
    }
    
    inline CFileTime operator += (const FILETIME& f)
    {
        *this = *this + f;
        return *this;
    }

    inline CFileTime operator - (const FILETIME& f)
    {
        return *this - MAKEINT64(f.dwLowDateTime, f.dwHighDateTime);
    }
    
    inline CFileTime operator -= (const FILETIME& f)
    {
        *this = *this - f;
        return *this;
    }

    inline CFileTime operator * (const FILETIME& f)
    {
        return *this * MAKEINT64(f.dwLowDateTime, f.dwHighDateTime);
    }
    
    inline CFileTime operator *= (const FILETIME& f)
    {
        *this = *this * f;
        return *this;
    }

    inline CFileTime operator / (const FILETIME& f)
    {
        return *this / MAKEINT64(f.dwLowDateTime, f.dwHighDateTime);
    }
    
    inline CFileTime operator /= (const FILETIME& f)
    {
        *this = *this / f;
        return *this;
    }
};

//
//  Conversions 
//  NOTE: We can't do want operator __int64() since what causes to many
//  ambiguous situations that the compiler just can't handle.
//
inline  __int64 FileTimeToInt64(const FILETIME& f)
{
    return MAKEINT64(f.dwLowDateTime, f.dwHighDateTime);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\encodeqp.cpp ===
// --------------------------------------------------------------------------------
// EncodeQP.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
//
// Stolen from Athena's source base by JulianJ, January 21st, 1997
//
// --------------------------------------------------------------------------------

#include "private.h"

//
// Porting macros so the code can be copied without changes
//
#define MIMEOLEAPI
#define AssertSz ASSERT_MSG
#define TrapError(hr) ((EVAL(SUCCEEDED(hr))), (hr))
#define CCHMAX_ENCODE_BUFFER 4096
#define CHECKHR(hrExp) \
    if (FAILED (hrExp)) { \
    ASSERT_MSG(SUCCEEDED(hr), "%x", (hr)); \
    goto exit; \
    } else



// --------------------------------------------------------------------------------
// QP Encoder
// --------------------------------------------------------------------------------
static char rgchHex[] = "0123456789ABCDEF";
#define ENCODEQPBUF 4096
#define CCHMAX_QPLINE 72

// --------------------------------------------------------------------------------
// MimeOleEncodeStreamQP
// --------------------------------------------------------------------------------
MIMEOLEAPI HRESULT MimeOleEncodeStreamQP(IStream *pstmIn, IStream *pstmOut)
{
    // Locals
    HRESULT         hr=S_OK;
    BOOL            fSeenCR=FALSE,
                    fEOLN=FALSE;
    CHAR            szBuffer[CCHMAX_ENCODE_BUFFER];
    ULONG           cbRead=0, 
                    cbCurr=1, 
                    cbAttLast=0,
                    cbBffLast=0, 
                    cbBuffer=0;
    UCHAR           chThis=0, 
                    chPrev=0,
                    buf[ENCODEQPBUF];

    // check params
    if (NULL == pstmIn || NULL == pstmOut)
        return TrapError(E_INVALIDARG);

    // Read from pstmIn and encode into pstmOut
    while (1)
    {    
        // Reads one buffer full from the attachment
        if (cbCurr >= cbRead)
        {
            // Moves buffer from the last white space to front
            cbCurr = 0;
            while (cbAttLast < cbRead)
                buf[cbCurr++] = buf[cbAttLast++];

            // RAID-33342 - Reset cbAttLast - buff[0] is now equal to cbAttLast !!!
            cbAttLast = 0;

            // Read into buf
            CHECKHR(hr = pstmIn->Read(buf+cbCurr, ENCODEQPBUF-cbCurr, &cbRead));

            // No more ?
            if (cbRead == 0)
                break;

            // Adjusts buffer length
            cbRead += cbCurr;
        }

        // Gets the next character
        chThis = buf[cbCurr++]; 

        // Tests for end of line
        if (chThis == '\n' && fSeenCR == TRUE)
            fEOLN = TRUE;
        
        // Tests for an isolated CR
        else if (fSeenCR == TRUE)
        {
            szBuffer[cbBuffer++] = '=';
            szBuffer[cbBuffer++] = '0';
            szBuffer[cbBuffer++] = 'D';
            chPrev = 0xFF;
        }

        // CR has been taken care of
        fSeenCR = FALSE;

        // Tests for trailing white space if end of line
        if (fEOLN == TRUE)
        {
            if (chPrev == ' ' || chPrev == '\t')
            {
                cbBuffer--;
                szBuffer[cbBuffer++] = '=';
                szBuffer[cbBuffer++] = rgchHex[chPrev >>    4];
                szBuffer[cbBuffer++] = rgchHex[chPrev &  0x0F];
                chPrev = 0xFF;
                cbAttLast = cbCurr;
                cbBffLast = cbBuffer;
            }
        }

        // Tests for a must quote character
        else if (((chThis < 32) && (chThis != '\r' && chThis != '\t')) || (chThis > 126 ) || (chThis == '='))
        {
            szBuffer[cbBuffer++] = '=';
            szBuffer[cbBuffer++] = rgchHex[chThis >>    4];
            szBuffer[cbBuffer++] = rgchHex[chThis &  0x0F];
            chPrev = 0xFF;
        }

        // Tests for possible end of line
        else if (chThis == '\r')
        {
            fSeenCR = TRUE;
        }

        // Other characters (includes ' ' and '\t')
        else
        {
            // Stuffs leading '.'
            if (chThis == '.' && cbBuffer == 0)
                szBuffer[cbBuffer++] = '.';

            szBuffer[cbBuffer++] = chThis;
            chPrev = chThis;

            // Tests for white space and saves location
            if (chThis == ' ' || chThis == '\t')
            {
                cbAttLast = cbCurr;
                cbBffLast = cbBuffer;
            }
        }

        // Tests for line break
        if (cbBuffer > 72 || fEOLN == TRUE || chThis == '\n')
        {
            // Backtracks to last whitespace
            if (cbBuffer > 72 && cbBffLast > 0)
            {
                // RAID-33342
                AssertSz(cbAttLast <= cbCurr, "Were about to eat some text.");
                cbCurr = cbAttLast;
                cbBuffer = cbBffLast;
            }
            else
            {
                cbAttLast = cbCurr;
                cbBffLast = cbBuffer;
            }

            // Adds soft line break, if necessary
            if (fEOLN == FALSE)
                szBuffer[cbBuffer++] = '=';

            // Ends line and writes to storage
            szBuffer[cbBuffer++] = '\r';
            szBuffer[cbBuffer++] = '\n';

            // Write the buffer
            CHECKHR(hr = pstmOut->Write(szBuffer, cbBuffer, NULL));

            // Resets counters
            fEOLN = FALSE;
            cbBuffer = 0;
            chPrev = 0xFF;
            cbBffLast = 0;
        }
    }

    // Writes last line to storage
    if (cbBuffer > 0)
    {
        // Write the line
        CHECKHR(hr = pstmOut->Write(szBuffer, cbBuffer, NULL));
    }

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\folder.cpp ===
#include "private.h"
#include "offl_cpp.h"
#include <htmlhelp.h>
#include <shdocvw.h>

#include <mluisupp.h>

// {F5175861-2688-11d0-9C5E-00AA00A45957}
const GUID CLSID_OfflineFolder = 
{ 0xf5175861, 0x2688, 0x11d0, { 0x9c, 0x5e, 0x0, 0xaa, 0x0, 0xa4, 0x59, 0x57 } };

// {F5175860-2688-11d0-9C5E-00AA00A45957}
const GUID IID_IOfflineObject = 
{ 0xf5175860, 0x2688, 0x11d0, { 0x9c, 0x5e, 0x0, 0xaa, 0x0, 0xa4, 0x59, 0x57 } };

// Column definition for the Cache Folder DefView
    
ColInfoType s_AllItems_cols[] = {
        {ICOLC_SHORTNAME,   IDS_NAME_COL,           20, LVCFMT_LEFT},
        {ICOLC_LAST,        IDS_LAST_COL,           14, LVCFMT_LEFT},
        {ICOLC_STATUS,      IDS_STATUS_COL,         14, LVCFMT_LEFT},
        {ICOLC_URL,         IDS_URL_COL,            20, LVCFMT_LEFT}, 
        {ICOLC_ACTUALSIZE,  IDS_SIZE_COL,           10, LVCFMT_LEFT}};

ColInfoType * colInfo = s_AllItems_cols;

LPMYPIDL _CreateFolderPidl(IMalloc *pmalloc, DWORD dwSize);

HRESULT OfflineFolderView_InitMenuPopup(HWND hwnd, UINT idCmdFirst, int nIndex, HMENU hMenu)
{
    UINT platform = WhichPlatform();

    if (platform != PLATFORM_INTEGRATED)    {
        MENUITEMINFO    mInfo = {0};
        mInfo.cbSize = sizeof(MENUITEMINFO);
        mInfo.fMask = MIIM_STATE;
        if (IsGlobalOffline())  {
            mInfo.fState = MFS_CHECKED;
        } else  {
            mInfo.fState = MFS_UNCHECKED;
        }
        SetMenuItemInfo(hMenu, RSVIDM_WORKOFFLINE + idCmdFirst, FALSE, &mInfo);
    }

    return NOERROR;
}

HRESULT OfflineFolderView_MergeMenu(LPQCMINFO pqcm)
{
    HMENU hmenu = NULL;
    UINT  platform = WhichPlatform();
    
    if (platform == PLATFORM_INTEGRATED) {
        hmenu = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(MENU_OFFLINE_TOP));
    } else  {
        hmenu = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(MENU_OFFLINE_BRONLY));
    }

    if (hmenu)
    {
        MergeMenuHierarchy(pqcm->hmenu, hmenu, pqcm->idCmdFirst, pqcm->idCmdLast, TRUE);
        DestroyMenu(hmenu);
    }

    return S_OK;
}

extern HRESULT CancelAllDownloads();

HRESULT OfflineFolderView_Command(HWND hwnd, UINT uID)
{
    switch (uID) {
    case RSVIDM_SORTBYNAME:
        ShellFolderView_ReArrange(hwnd, ICOLC_SHORTNAME);
        break;
    case RSVIDM_UPDATEALL:
        SendUpdateRequests(hwnd, NULL, 0);
        break;
    case RSVIDM_WORKOFFLINE:
        SetGlobalOffline(!IsGlobalOffline());
        break;
    case RSVIDM_HELP:
        SHHtmlHelpOnDemandWrap(hwnd, TEXT("iexplore.chm > iedefault"), 0, (DWORD_PTR) TEXT("subs_upd.htm"), ML_CROSSCODEPAGE);
        break;

    case RSVIDM_UPDATE:
        {
            LPMYPIDL *  pidlsSel = NULL;
            UINT    count = 0;

            count = (UINT) ShellFolderView_GetSelectedObjects
                                (hwnd, (LPITEMIDLIST*) &pidlsSel);

            if ((!pidlsSel) || !count)
                break;

            CLSID   * cookies = (CLSID *)MemAlloc(LPTR, count * sizeof(CLSID));
            UINT    validCount = 0;

            if (cookies)
            {
                for (UINT i = 0; i < count; i ++)   {
                    if (IS_VALID_MYPIDL(pidlsSel[i]))
                        cookies[validCount++] = pidlsSel[i]->ooe.m_Cookie;
                }

                if (validCount)
                    SendUpdateRequests(hwnd, cookies, validCount);
            
                MemFree(cookies);
                cookies = NULL;
            }
            break;
        }
    default:
        return E_FAIL;
    }
    return NOERROR;
}

//  We should make this a generic function for all types of items, even
//  for the third party items they should support these properties.

HRESULT Generic_GetDetails(PDETAILSINFO pdi, UINT iColumn)
{
    LPMYPIDL pooi = (LPMYPIDL)pdi->pidl;
    POOEntry pooe = NULL;
    TCHAR timeSTR[128];

    pdi->str.uType = STRRET_CSTR;
    pdi->str.cStr[0] = '\0';

    pooe = &(pooi->ooe);
    switch (iColumn)
    {
    case ICOLC_SHORTNAME:
        SHTCharToAnsi(NAME(pooe), pdi->str.cStr, sizeof(pdi->str.cStr));
        break;
    case ICOLC_URL:
        SHTCharToAnsi(URL(pooe), pdi->str.cStr, sizeof(pdi->str.cStr));
        break;
    case ICOLC_LAST:
        DATE2DateTimeString(pooe->m_LastUpdated, timeSTR);
        SHTCharToAnsi(timeSTR, pdi->str.cStr, sizeof(pdi->str.cStr));
        break;
    case ICOLC_STATUS:
        SHTCharToAnsi(STATUS(pooe), pdi->str.cStr, sizeof(pdi->str.cStr));
        break;
    case ICOLC_ACTUALSIZE:
        StrFormatByteSizeA(pooe->m_ActualSize * 1024, pdi->str.cStr, sizeof(pdi->str.cStr));
        break;
    }

    return S_OK;
}

HRESULT OfflineFolderView_OnGetDetailsOf(HWND hwnd, UINT iColumn, PDETAILSINFO pdi)
{
    LPMYPIDL pooi = (LPMYPIDL)pdi->pidl;

    if (iColumn > ICOLC_ACTUALSIZE)
        return E_NOTIMPL;

    if (!pooi)
    {
        pdi->str.uType = STRRET_CSTR;
        pdi->str.cStr[0] = '\0';
        MLLoadStringA(colInfo[iColumn].ids, pdi->str.cStr, sizeof(pdi->str.cStr));
        pdi->fmt = colInfo[iColumn].iFmt;
        pdi->cxChar = colInfo[iColumn].cchCol;
        return S_OK;
    }

    UINT    colId = colInfo[iColumn].iCol;
    return Generic_GetDetails(pdi, colId);
}

HRESULT OfflineFolderView_OnColumnClick(HWND hwnd, UINT iColumn)
{
    ShellFolderView_ReArrange(hwnd, colInfo[iColumn].iCol);
    return NOERROR;
}

const TBBUTTON c_tbOffline[] = {
    { 0, RSVIDM_UPDATE,       TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, -1 },
    { 1, RSVIDM_UPDATEALL,    TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, -1 },
    { 0,  0,                  TBSTATE_ENABLED, TBSTYLE_SEP   , {0,0}, 0L, -1 },
    };

HRESULT OfflineFolderView_OnGetButtons(HWND hwnd, UINT idCmdFirst, LPTBBUTTON ptButton)
{
    UINT i;
    LONG_PTR iBtnOffset;
    IShellBrowser * psb = FileCabinet_GetIShellBrowser(hwnd);
    TBADDBITMAP ab;

    // add the toolbar button bitmap, get it's offset
    ab.hInst =g_hInst;
    ab.nID   = IDB_TB_SMALL;        // std bitmaps
    psb->SendControlMsg(FCW_TOOLBAR, TB_ADDBITMAP, 2, (LPARAM)&ab, &iBtnOffset);

    for (i = 0; i < ARRAYSIZE(c_tbOffline); i++)
    {
        ptButton[i] = c_tbOffline[i];

        if (!(c_tbOffline[i].fsStyle & TBSTYLE_SEP))
        {
            ptButton[i].idCommand += idCmdFirst;
            ptButton[i].iBitmap += (int)iBtnOffset;
        }
    }

    return S_OK;
}

HRESULT OfflineFolderView_OnGetButtonInfo(TBINFO * ptbInfo)
{
    ptbInfo->uFlags = TBIF_PREPEND;
    ptbInfo->cbuttons = ARRAYSIZE(c_tbOffline);
    return S_OK;
}

HRESULT OfflineFolderView_DidDragDrop(HWND hwnd,IDataObject *pdo,DWORD dwEffect)
{
    if ((dwEffect & (DROPEFFECT_MOVE |DROPEFFECT_COPY)) == DROPEFFECT_MOVE)
    {
        COfflineObjectItem *pOOItem;
        
        if (SUCCEEDED(pdo->QueryInterface(IID_IOfflineObject, (void **)&pOOItem)))
        {
            BOOL fDel = ConfirmDelete(hwnd, pOOItem->_cItems, pOOItem->_ppooi);
            if (!fDel)  {
                pOOItem->Release();
                return S_FALSE;
            }

            for (UINT i = 0; i < pOOItem->_cItems; i++)
            {
                if (SUCCEEDED(DoDeleteSubscription(&(pOOItem->_ppooi[i]->ooe)))) {
                    _GenerateEvent(SHCNE_DELETE, 
                            (LPITEMIDLIST)pOOItem->_ppooi[i], 
                            NULL);
                }
            }

            pOOItem->Release();
            return S_OK;
        }
    }
    return E_FAIL;
}

HRESULT CALLBACK OfflineFolderView_ViewCallback(
     IShellView *psvOuter,
     IShellFolder *psf,
     HWND hwnd,
     UINT uMsg,
     WPARAM wParam,
     LPARAM lParam)
{
    HRESULT hres = NOERROR;

    switch (uMsg)
    {
    case DVM_GETHELPTEXT:
    case DVM_GETTOOLTIPTEXT:
    {
        UINT id = LOWORD(wParam);
        UINT cchBuf = HIWORD(wParam);
        if (g_fIsWinNT)   
        {
            WCHAR * pszBuf = (WCHAR *)lParam;
            MLLoadStringW(id + IDS_SB_FIRST, pszBuf, cchBuf);
        }
        else  
        {
            CHAR * pszBuf = (CHAR *)lParam;
            MLLoadStringA(id + IDS_SB_FIRST, pszBuf, cchBuf);
        }
    }   
        break;

    case DVM_DIDDRAGDROP:
        hres = OfflineFolderView_DidDragDrop(hwnd,(IDataObject *)lParam,(DWORD)wParam);
        break;
      
    case DVM_INITMENUPOPUP:
        hres = OfflineFolderView_InitMenuPopup(hwnd, LOWORD(wParam), HIWORD(wParam), (HMENU)lParam);
        break;

    case DVM_INVOKECOMMAND:
        OfflineFolderView_Command(hwnd, (UINT)wParam);
        break;

    case DVM_COLUMNCLICK:
        hres = OfflineFolderView_OnColumnClick(hwnd, (UINT)wParam);
        break;

    case DVM_GETDETAILSOF:
        hres = OfflineFolderView_OnGetDetailsOf(hwnd, (UINT)wParam, (PDETAILSINFO)lParam);
        break;

    case DVM_MERGEMENU:
        hres = OfflineFolderView_MergeMenu((LPQCMINFO)lParam);
        break;

    case DVM_DEFVIEWMODE:
        *(FOLDERVIEWMODE *)lParam = FVM_DETAILS;
        break;

    case DVM_GETBUTTONINFO:
        hres = OfflineFolderView_OnGetButtonInfo((TBINFO *)lParam);
        break;

    case DVM_GETBUTTONS:
        hres = OfflineFolderView_OnGetButtons(hwnd, LOWORD(wParam), (TBBUTTON *)lParam);
        break;

    default:
        hres = E_FAIL;
    }

    return hres;
}

HRESULT OfflineFolderView_CreateInstance(COfflineFolder *pOOFolder, LPCITEMIDLIST pidl, void **ppvOut)
{
    CSFV csfv;

    csfv.cbSize = sizeof(csfv);
    csfv.pshf = (IShellFolder *)pOOFolder;
    csfv.psvOuter = NULL;
    csfv.pidl = pidl;
    csfv.lEvents = SHCNE_DELETE | SHCNE_CREATE | SHCNE_RENAMEITEM | SHCNE_UPDATEITEM | SHCNE_UPDATEDIR;
    csfv.pfnCallback = OfflineFolderView_ViewCallback;
    csfv.fvm = (FOLDERVIEWMODE)0;         // Have defview restore the folder view mode

    return SHCreateShellFolderViewEx(&csfv, (IShellView**)ppvOut); // &this->psv);
}



//////////////////////////////////////////////////////////////////////////////
//
// COfflineFolderEnum Object
//
//////////////////////////////////////////////////////////////////////////////


COfflineFolderEnum::COfflineFolderEnum(DWORD grfFlags)
{
    TraceMsg(TF_SUBSFOLDER, "hcfe - COfflineFolderEnum() called");
    
    m_cRef = 1;
    DllAddRef();

    m_grfFlags = grfFlags;
}

IMalloc *COfflineFolderEnum::s_pMalloc = NULL;

void COf