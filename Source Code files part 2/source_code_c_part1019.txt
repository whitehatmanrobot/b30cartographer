the default maximum number of nodes allowed in the cluster, based
    on the product suite.

Arguments:

    None.

Return Value:

    The default maximum number of nodes allowed in the cluster.

    Note that this function will return ZERO if the product suite is neither
    DataCenter, Advanced Server (aka Enterprise), nor Embedded.

--*/

{
    DWORD   NodeLimit;
    
    switch( SuiteType )
    {
        case DataCenter:
            NodeLimit = DATACENTER_DEFAULT_NODE_LIMIT;
            break;

        case Enterprise:
            NodeLimit = ADVANCEDSERVER_DEFAULT_NODE_LIMIT;
            break;

        case EmbeddedNT:
            NodeLimit = EMBEDDED_DEFAULT_NODE_LIMIT;
            break;

        case VER_SERVER_NT:
        default:
        {
            DWORD       dwOverride;

            //
            // Check the override registry value.
            //
            GetEnableClusterRegValue( &dwOverride );
            if ( dwOverride != 0 ) {
                NodeLimit = 2;
            } else {
                NodeLimit = 0;
            }
        }
            
    }

    return( NodeLimit );

}  // ClRtlGetDefaultNodeLimit



DWORD
ClRtlGetSuiteType(
    void
    )

/*++

Routine Description:

    Returns the current product suite type.

Arguments:

    None.

Return Value:

    Returns the product suite type DataCenter or Enterprise (aka Advanced Server)
    Returns zero if not DataCenter or Enterprise

--*/

{
    DWORD           dwSuiteType = 0;
    OSVERSIONINFOEX osiv;
    DWORDLONG       dwlConditionMask;

    ZeroMemory( &osiv, sizeof( OSVERSIONINFOEX ) );
    osiv.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );

    // First check if product suite is DataCenter.

    osiv.wSuiteMask = VER_SUITE_DATACENTER;
    dwlConditionMask = (DWORDLONG) 0L;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );
   
    if ( VerifyVersionInfo( &osiv, VER_SUITENAME, dwlConditionMask ) == TRUE )
    {
      // This is DataCenter.

      dwSuiteType = DataCenter;
      goto Cleanup;
    }

    ZeroMemory( &osiv, sizeof( OSVERSIONINFOEX ) );
    osiv.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );

    // Next check if this is Advanced Server (Enterprise).

    osiv.wSuiteMask = VER_SUITE_ENTERPRISE;
    dwlConditionMask = (DWORDLONG) 0L;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

    if ( VerifyVersionInfo( &osiv, VER_SUITENAME, dwlConditionMask ) == TRUE )
    {
        dwSuiteType = Enterprise;
        goto Cleanup;
    }

    // Next check if this is Embedded.

    osiv.wSuiteMask = VER_SUITE_EMBEDDEDNT;
    dwlConditionMask = (DWORDLONG) 0L;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

    if ( VerifyVersionInfo( &osiv, VER_SUITENAME, dwlConditionMask ) == TRUE )
    {
        dwSuiteType = EmbeddedNT;
        goto Cleanup;
    }

    // Finally check if this is any Server.

    if ( GetVersionEx( (LPOSVERSIONINFO) &osiv ) ) {
        if ( osiv.wProductType == VER_NT_SERVER ) {
            dwSuiteType = VER_SERVER_NT;
            goto Cleanup;
        }
    }

Cleanup:
    return( dwSuiteType );

} // ClRtlGetSuiteType
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\regutil.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

   regutil.c

Abstract:

    Utilities for accessing the system registry.

Author:

    Mike Massa (mikemas)           May 19, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     05-19-97    created


--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>



LPCWSTR
ClRtlMultiSzEnum(
    IN LPCWSTR MszString,
    IN DWORD   MszStringLength,
    IN DWORD   StringIndex
    )

/*++

 Routine Description:

     Parses a REG_MULTI_SZ string and returns the specified substring.

 Arguments:

    MszString        - A pointer to the REG_MULTI_SZ string.

    MszStringLength  - The length of the REG_MULTI_SZ string in characters,
                       including the terminating null character.

    StringIndex      - Index number of the substring to return. Specifiying
                       index 0 retrieves the first substring.

 Return Value:

    A pointer to the specified substring.

--*/
{
    LPCWSTR   string = MszString;

    if ( MszStringLength < 2  ) {
        return(NULL);
    }

    //
    // Find the start of the desired string.
    //
    while (StringIndex) {

        while (MszStringLength >= 1) {
            MszStringLength -= 1;

            if (*string++ == UNICODE_NULL) {
                break;
            }
        }

        //
        // Check for index out of range.
        //
        if ( MszStringLength < 2 ) {
            return(NULL);
        }

        StringIndex--;
    }

    if ( MszStringLength < 2 ) {
        return(NULL);
    }

    return(string);
}


DWORD
ClRtlMultiSzRemove(
    IN LPWSTR lpszMultiSz,
    IN OUT LPDWORD StringLength,
    IN LPCWSTR lpString
    )
/*++

Routine Description:

    Removes the specified string from the supplied REG_MULTI_SZ.
    The MULTI_SZ is edited in place.

Arguments:

    lpszMultiSz - Supplies the REG_MULTI_SZ string that lpString should
        be removed from.

    StringLength - Supplies the length (in characters) of lpszMultiSz
        Returns the new length (in characters) of lpszMultiSz

    lpString - Supplies the string to be removed from lpszMultiSz

Return Value:

    ERROR_SUCCESS if successful

    ERROR_FILE_NOT_FOUND if the string was not found in the MULTI_SZ

    Win32 error code otherwise

--*/

{
    PCHAR Dest, Src;
    DWORD CurrentLength;
    DWORD i;
    LPCWSTR Next;
    DWORD NextLength;

    //
    // Scan through the strings in the returned MULTI_SZ looking
    // for a match.
    //
    CurrentLength = *StringLength;
    for (i=0; ;i++) {
        Next = ClRtlMultiSzEnum(lpszMultiSz, *StringLength, i);
        if (Next == NULL) {
            //
            // The value was not in the specified multi-sz
            //
            break;
        }
        NextLength = lstrlenW(Next)+1;
        CurrentLength -= NextLength;
        if (lstrcmpiW(Next, lpString)==0) {
            //
            // Found the string, delete it and return
            //
            Dest = (PCHAR)Next;
            Src = (PCHAR)Next + (NextLength*sizeof(WCHAR));
            CopyMemory(Dest, Src, CurrentLength*sizeof(WCHAR));
            *StringLength -= NextLength;
            return(ERROR_SUCCESS);
        }
    }

    return(ERROR_FILE_NOT_FOUND);
}


DWORD
ClRtlMultiSzAppend(
    IN OUT LPWSTR *MultiSz,
    IN OUT LPDWORD StringLength,
    IN LPCWSTR lpString
    )
/*++

Routine Description:

    Appends the specified string to the supplied REG_MULTI_SZ.
    The passed in MultiSz will be freed with LocalFree. A new
    MultiSz large enough to hold the new value will be allocated
    with LocalAlloc and returned in *MultiSz

Arguments:

    lpszMultiSz - Supplies the REG_MULTI_SZ string that lpString should
        be appended to.
        Returns the new REG_MULTI_SZ string with lpString appended

    StringLength - Supplies the length (in characters) of lpszMultiSz
        Returns the new length (in characters) of lpszMultiSz

    lpString - Supplies the string to be appended to lpszMultiSz

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    LPWSTR NewMultiSz;
    DWORD Length;
    DWORD NewLength;

    if (*MultiSz == NULL) {

        //
        // There is no multi-sz, create a new multi-sz with lpString as the
        // only entry.
        //
        NewLength = lstrlenW(lpString)+2;
        NewMultiSz = LocalAlloc(LMEM_FIXED, NewLength*sizeof(WCHAR));
        if (NewMultiSz == NULL) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        CopyMemory(NewMultiSz, lpString, (NewLength-1)*sizeof(WCHAR));
    } else {
        //
        // Append this string to the existing MULTI_SZ
        //
        Length = lstrlenW(lpString) + 1;
        NewLength = *StringLength + Length;
        NewMultiSz = LocalAlloc(LMEM_FIXED, NewLength * sizeof(WCHAR));
        if (NewMultiSz == NULL) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        CopyMemory(NewMultiSz, *MultiSz, *StringLength * sizeof(WCHAR));
        CopyMemory(NewMultiSz + *StringLength - 1, lpString, Length * sizeof(WCHAR));
        NewMultiSz[NewLength-1] = L'\0';
        //Free the passed in MultiSz
        LocalFree(*MultiSz);
    }

    NewMultiSz[NewLength-1] = L'\0';
    *MultiSz = NewMultiSz;
    *StringLength = NewLength;
    return(ERROR_SUCCESS);

}


DWORD
ClRtlMultiSzLength(
    IN LPCWSTR lpszMultiSz
    )
/*++

Routine Description:

    Determines the length (in characters) of a multi-sz. The calculated
    length includes all trailing NULLs.

Arguments:

    lpszMultiSz - Supplies the multi-sz

Return Value:

    The length (in characters) of the supplied multi-sz

--*/

{
    LPCWSTR p;
    DWORD Length=0;

    if(!lpszMultiSz)
        return 0;
        
    if (*lpszMultiSz == UNICODE_NULL)
        return 1;
        
    p=lpszMultiSz;
    do {
        while (p[Length++] != L'\0') {
        }
    } while ( p[Length++] != L'\0' );

    return(Length);
}


LPCWSTR
ClRtlMultiSzScan(
    IN LPCWSTR lpszMultiSz,
    IN LPCWSTR lpszString
    )
/*++

Routine Description:

    Scans a multi-sz looking for an entry that matches the specified string.
    The match is done case-insensitive.

Arguments:

    lpszMultiSz - Supplies the multi-sz to scan.

    lpszString - Supplies the string to look for

Return Value:

    A pointer to the string in the supplied multi-sz if found.

    NULL if not found.

--*/

{
    DWORD dwLength;
    DWORD i;
    LPCWSTR sz;

    dwLength = ClRtlMultiSzLength(lpszMultiSz);
    for (i=0; ; i++) {
        sz = ClRtlMultiSzEnum(lpszMultiSz,
                              dwLength,
                              i);
        if (sz == NULL) {
            break;
        }
        if (lstrcmpiW(sz, lpszString) == 0) {
            break;
        }
    }

    return(sz);
}


DWORD
ClRtlRegQueryDword(
    IN  HKEY    hKey,
    IN  LPWSTR  lpValueName,
    OUT LPDWORD lpValue,
    IN  LPDWORD lpDefaultValue OPTIONAL
    )

/*++

Routine Description:

    Reads a REG_DWORD registry value. If the value is not present, then
    default to the value supplied in lpDefaultValue (if present).

Arguments:

    hKey        - Open key for the value to be read.

    lpValueName - Unicode name of the value to be read.

    lpValue     - Pointer to the DWORD into which to read the value.

    lpDefaultValue - Optional pointer to a DWORD to use as a default value.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    HKEY    Key;
    DWORD   Status;
    DWORD   ValueType;
    DWORD   ValueSize = sizeof(DWORD);


    Status = RegQueryValueExW(
                 hKey,
                 lpValueName,
                 NULL,
                 &ValueType,
                 (LPBYTE)lpValue,
                 &ValueSize
                 );

    if ( Status == ERROR_SUCCESS ) {
        if ( ValueType != REG_DWORD ) {
            Status = ERROR_INVALID_PARAMETER;
        }
    } else {
        if ( ARGUMENT_PRESENT( lpDefaultValue ) ) {
            *lpValue = *lpDefaultValue;
            Status = ERROR_SUCCESS;
        }
    }

    return(Status);

} // ClRtlRegQueryDword



DWORD
ClRtlRegQueryString(
    IN     HKEY     Key,
    IN     LPWSTR   ValueName,
    IN     DWORD    ValueType,
    IN     LPWSTR  *StringBuffer,
    IN OUT LPDWORD  StringBufferSize,
    OUT    LPDWORD  StringSize
    )

/*++

Routine Description:

    Reads a REG_SZ or REG_MULTI_SZ registry value. If the StringBuffer is
    not large enough to hold the data, it is reallocated.

Arguments:

    Key              - Open key for the value to be read.

    ValueName        - Unicode name of the value to be read.

    ValueType        - REG_SZ or REG_MULTI_SZ.

    StringBuffer     - Buffer into which to place the value data.

    StringBufferSize - Pointer to the size of the StringBuffer. This parameter
                       is updated if StringBuffer is reallocated.

    StringSize       - The size of the data returned in StringBuffer, including
                       the terminating null character.

Return Value:

    The status of the registry query.

--*/
{
    DWORD    status;
    DWORD    valueType;
    WCHAR   *temp;
    DWORD    oldBufferSize = *StringBufferSize;
    BOOL     noBuffer = FALSE;


    if (*StringBufferSize == 0) {
        noBuffer = TRUE;
    }

    *StringSize = *StringBufferSize;

    status = RegQueryValueExW(
                 Key,
                 ValueName,
                 NULL,
                 &valueType,
                 (LPBYTE) *StringBuffer,
                 StringSize
                 );

    if (status == NO_ERROR) {
        if (!noBuffer ) {
            if (valueType == ValueType) {
                return(NO_ERROR);
            }
            else {
                return(ERROR_INVALID_PARAMETER);
            }
        }

        status = ERROR_MORE_DATA;
    }

    if (status == ERROR_MORE_DATA) {
        temp = LocalAlloc(LMEM_FIXED, *StringSize);

        if (temp == NULL) {
            *StringSize = 0;
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        if (!noBuffer) {
            LocalFree(*StringBuffer);
        }

        *StringBuffer = temp;
        *StringBufferSize = *StringSize;

        status = RegQueryValueExW(
                     Key,
                     ValueName,
                     NULL,
                     &valueType,
                     (LPBYTE) *StringBuffer,
                     StringSize
                     );

        if (status == NO_ERROR) {
            if (valueType == ValueType) {
                return(NO_ERROR);
            }
            else {
                *StringSize = 0;
                return(ERROR_INVALID_PARAMETER);
            }
        }
    }

    return(status);

} // ClRtlRegQueryString
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\registryvaluename.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		RegistryValueName.cpp
//
//	Abstract:
//		Implementation of the CRegistryValueName class.
//
//	Author:
//		Vijayendra Vasu (vvasu) February 5, 1999
//
//	Revision History:
//		None.
//
/////////////////////////////////////////////////////////////////////////////

#define UNICODE 1
#define _UNICODE 1

#include "clusrtlp.h"
#include <string.h>
#include <tchar.h>
#include "RegistryValueName.h"

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#define REGISTRY_SEPARATOR_CHAR 	L'\\'
#define REGISTRY_SEPARATOR_STRING	L"\\"


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRegistryValueName::ScInit
//
//	Routine Description:
//		Initialize the class.
//
//	Arguments:
//		pszOldName		[IN] Old value name.
//		pszOldKeyName	[IN] Old key name.
//
//	Return Value:
//		ERROR_NOT_ENOUGH_MEMORY 	Error allocating memory.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CRegistryValueName::ScInit(
	IN LPCWSTR	pszOldName,
	IN LPCWSTR	pszOldKeyName
	)
{
	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbBufSize;
	LPWSTR	_pszBackslashPointer;

	// Dummy do to avoid goto
	do
	{
		if ( pszOldName == NULL )
		{
			FreeBuffers();
			m_pszKeyName = pszOldKeyName;
			break;
		} // if: no value name specified

		//
		// Look for a backslash in the name.
		//
		_pszBackslashPointer = ::wcsrchr( pszOldName, REGISTRY_SEPARATOR_CHAR );
		if ( _pszBackslashPointer == NULL )
		{
			//
			// The name does not contain a backslash.
			// No memory allocation need be made.
			//
			FreeBuffers();
			m_pszName = pszOldName;
			m_pszKeyName = pszOldKeyName;
			break;
		} // if: no backslash found

		//
		// Copy all characters after the last backslash into m_pszName.
		//
		_cbBufSize = ( ::lstrlenW( _pszBackslashPointer + 1 ) + 1 ) * sizeof( *m_pszName );

		//
		// Don't allocate memory if the existing buffer is already big enough to hold
		// the required string.
		//
		if ( _cbBufSize > m_cbNameBufferSize )
		{
	        if ( m_cbNameBufferSize > 0 )
	        {
		        ::LocalFree( const_cast< LPWSTR >( m_pszName ) );
		        m_cbNameBufferSize = 0;
	        }


			m_pszName = static_cast< LPWSTR >( ::LocalAlloc( LMEM_FIXED, _cbBufSize ) );
			if ( m_pszName == NULL )
			{
				FreeBuffers();
				_sc = ERROR_NOT_ENOUGH_MEMORY;
				break;
			} // if: error allocating memory
			else
			{
				m_cbNameBufferSize = _cbBufSize;
			}

		} // if: the existing buffer is not big enough

		//
		// Copy everything past the last backslash to the name buffer.
		//
		::lstrcpyW( const_cast< LPWSTR >( m_pszName ), _pszBackslashPointer + 1 );

		//
		// Everything before the last backslash is part of the key name path.
		// Append it to the specified key name.
		//
		{
			DWORD _cchNewKeyNameLength = 0;

			if ( pszOldKeyName != NULL )
			{
				_cchNewKeyNameLength = lstrlenW( pszOldKeyName );
			} // if: key name specified
			_cchNewKeyNameLength += static_cast< DWORD >( _pszBackslashPointer - pszOldName );

			//
			// nNewKeyNameLength is zero if pszOldKeyName is NULL and pszBackslashPointer
			// is the same as pszOldName (that is the backslash is the first character
			// of pszOldName). In this case, m_pszKeyName is to remain NULL.
			//
			if ( _cchNewKeyNameLength != 0 )
			{
				//
				// Allocate space for m_pszKeyName, the appended backslash character,
				// and the terminating '\0'.
				//
				
				_cbBufSize = _cchNewKeyNameLength * sizeof( *m_pszKeyName )
											+ sizeof( REGISTRY_SEPARATOR_CHAR )
											+ sizeof( L'\0' );
				//
				// Don't allocate memory if the existing buffer is already big enough to hold
				// the required string.
				//
				if ( _cbBufSize > m_cbKeyNameBufferSize )
				{
	                if ( m_cbKeyNameBufferSize > 0 )
	                {
		                ::LocalFree( const_cast< LPWSTR >( m_pszKeyName ) );
		                m_cbKeyNameBufferSize = 0;
	                }

					m_pszKeyName = static_cast< LPWSTR >( ::LocalAlloc( LMEM_FIXED, _cbBufSize ) );
					if ( m_pszKeyName == NULL )
					{
						FreeBuffers();
						_sc = ERROR_NOT_ENOUGH_MEMORY;
						break;
					} // if: error allocating memory
					else
					{
						m_cbKeyNameBufferSize = _cbBufSize;
					}

				} // if: the existing buffer is not big enough

				if ( pszOldKeyName != NULL )
				{
					// 
					// Copy the old key name if it exists into the new buffer and
					// append a backslash character to it.
					//
					::lstrcpyW( const_cast< LPWSTR >( m_pszKeyName ), pszOldKeyName );
					::lstrcatW( const_cast< LPWSTR >( m_pszKeyName ), REGISTRY_SEPARATOR_STRING );
				} // if: key name specified
				else
				{
					*(const_cast< LPWSTR >( m_pszKeyName )) = L'\0';
				} // if: no key name specified

				//
				// Concatenate all the characters of pszOldName upto (but not including) 
				// the first backslash character.
				//
				::wcsncat(
					const_cast< LPWSTR >( m_pszKeyName ),
					pszOldName,
					static_cast< DWORD >( _pszBackslashPointer - pszOldName )
					);

			} // if: cchNewKeyNameLength != 0
		}

	}
	while( FALSE ); // Dummy do-while

	return _sc;

} //*** CRegistryValueName::ScInit()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRegistryValueName::FreeBuffers
//
//	Routine Description:
//		Cleanup our allocations.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CRegistryValueName::FreeBuffers( void )
{
	if ( m_cbNameBufferSize > 0 )
	{
		::LocalFree( const_cast< LPWSTR >( m_pszName ) );
		m_cbNameBufferSize = 0;
	}

	if ( m_cbKeyNameBufferSize > 0 )
	{
		::LocalFree( const_cast< LPWSTR >( m_pszKeyName ) );
		m_cbKeyNameBufferSize = 0;
	}

	m_pszName = NULL;
	m_pszKeyName = NULL;

} //*** CRegistryValueName::FreeBuffers()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\regutils.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 Microsoft Corporation
//
//	Module Name:
//		RegUtils.cpp
//
//	Abstract:
//		Registry utilities
//
//	Author:
//		Galen Barbee	(galenb)	November 16, 1998
//
//	Revision History:
//		16-Nov-1998	GalenB	Stolen from nt\private\gina\samples\gptdemo
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "ClusRtlP.h"

#include <tchar.h>

//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
LPTSTR CheckSlash(  LPTSTR lpDir )
{
	DWORD	dwStrLen;
	LPTSTR	lpEnd;

	lpEnd = lpDir + lstrlen( lpDir );
	if ( *( lpEnd - 1 ) != TEXT( '\\' ) )
	{
		*lpEnd =  TEXT( '\\' );
		lpEnd++;
		*lpEnd =  TEXT( '\0' );
	}

	return lpEnd;

}

//*************************************************************
//
//  RegDelnodeRecurse()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values.
//              Called by RegDelnode
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************
BOOL RegDelnodeRecurse( HKEY hKeyRoot, LPTSTR lpSubKey )
{
	LPTSTR		lpEnd;
	LONG		lResult;
	DWORD		dwSize;
	TCHAR		szName[MAX_PATH];
	HKEY		hKey;
	FILETIME	ftWrite;

	//
	// First, see if we can delete the key without having
	// to recurse.
	//
	lResult = RegDeleteKey( hKeyRoot, lpSubKey );
	if (lResult == ERROR_SUCCESS)
	{
		return TRUE;
	}

	lResult = RegOpenKeyEx( hKeyRoot, lpSubKey, 0, KEY_READ, &hKey );
	if ( lResult != ERROR_SUCCESS )
	{
		return FALSE;
	}

	lpEnd = CheckSlash( lpSubKey );

	//
	// Enumerate the keys
	//
	dwSize = MAX_PATH;
	lResult = RegEnumKeyEx( hKey, 0, szName, &dwSize, NULL, NULL, NULL, &ftWrite );
	if ( lResult == ERROR_SUCCESS )
	{
		do
		{

			lstrcpy( lpEnd, szName );

			if ( !RegDelnodeRecurse( hKeyRoot, lpSubKey ) )
			{
				break;
			}

			//
			// Enumerate again
			//
			dwSize = MAX_PATH;

			lResult = RegEnumKeyEx( hKey, 0, szName, &dwSize, NULL, NULL, NULL, &ftWrite );

		} while ( lResult == ERROR_SUCCESS );
	}

	lpEnd--;
	*lpEnd = TEXT( '\0' );

	RegCloseKey( hKey );

	//
	// Try again to delete the key
	//
	lResult = RegDeleteKey( hKeyRoot, lpSubKey );
	if ( lResult == ERROR_SUCCESS )
	{
		return TRUE;
	}

	return FALSE;
}

//*************************************************************
//
//  RegDelnode()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************
BOOL RegDelnode( HKEY hKeyRoot, const LPTSTR lpSubKey )
{
	TCHAR	szDelKey[2 * MAX_PATH];

	lstrcpy ( szDelKey, lpSubKey );

	return RegDelnodeRecurse( hKeyRoot, szDelKey );

}

//*************************************************************
//
//  RegCleanUpValue()
//
//  Purpose:    Removes the target value and if no more values / keys
//              are present, removes the key.  This function then
//              works up the parent tree removing keys if they are
//              also empty.  If any parent key has a value / subkey,
//              it won't be removed.
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey
//              lpValueName -   Value to remove
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************
BOOL RegCleanUpValue( HKEY hKeyRoot, LPTSTR lpSubKey, LPTSTR lpValueName )
{
	LPTSTR	lpEnd;
	DWORD	dwKeys;
	DWORD	dwValues;
	LONG	lResult;
	HKEY	hKey;
	TCHAR	szDelKey[2 * MAX_PATH];

	//
	// Make a copy of the subkey so we can write to it.
	//
	lstrcpy( szDelKey, lpSubKey );

	//
	// First delete the value
	//

	lResult = RegOpenKeyEx( hKeyRoot, szDelKey, 0, KEY_WRITE, &hKey );
	if ( lResult == ERROR_SUCCESS )
	{
		lResult = RegDeleteValue( hKey, lpValueName );

		RegCloseKey( hKey );

		if ( lResult != ERROR_SUCCESS )
		{
			if ( lResult != ERROR_FILE_NOT_FOUND )
			{
				//DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to delete value <%s> with %d."), lpValueName, lResult));
				return FALSE;
			}
		}
	}

	//
	// Now loop through each of the parents.  If the parent is empty
	// eg: no values and no other subkeys, then remove the parent and
	// keep working up.
	//
	lpEnd = szDelKey + lstrlen( szDelKey ) - 1;

	while ( lpEnd >= szDelKey )
	{

		//
		// Find the parent key
		//
		while ( ( lpEnd > szDelKey ) && ( *lpEnd != TEXT( '\\' ) ) )
		{
			lpEnd--;
		}

		//
		// Open the key
		//
		lResult = RegOpenKeyEx( hKeyRoot, szDelKey, 0, KEY_READ, &hKey );
		if ( lResult != ERROR_SUCCESS )
		{
			if ( lResult == ERROR_FILE_NOT_FOUND )
			{
				goto LoopAgain;
			}
			else
			{
				//DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to open key <%s> with %d."), szDelKey, lResult));
				return FALSE;
			}
		}

		//
		// See if there any any values / keys
		//
		lResult = RegQueryInfoKey( hKey, NULL, NULL, NULL, &dwKeys, NULL, NULL, &dwValues, NULL, NULL, NULL, NULL );

		RegCloseKey( hKey );

		if ( lResult != ERROR_SUCCESS )
		{
			//DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to query key <%s> with %d."), szDelKey, lResult));
			return FALSE;
		}

		//
		// Exit now if this key has values or keys
		//
		if ( ( dwKeys != 0 ) || ( dwValues != 0 ) )
		{
			return TRUE;
		}

		RegDeleteKey( hKeyRoot, szDelKey );

LoopAgain:
		//
		// If we are at the beginning of the subkey, we can leave now.
		//
		if ( lpEnd == szDelKey )
		{
			return TRUE;
		}

		//
		// There is a parent key.  Remove the slash and loop again.
		//
		if ( *lpEnd == TEXT( '\\' ) )
		{
			*lpEnd = TEXT( '\0' );
		}
	}

	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\rpc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rpc.c

Abstract:

    Handy utility functions for supporting RPC

Author:

    John Vert (jvert) 2-Jan-1996

Revision History:

--*/
#include "clusrtlp.h"
#include "rpc.h"

void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(LocalAlloc(LMEM_FIXED, len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    LocalFree(ptr);
}

LPWSTR
ClRtlMakeGuid(
    VOID
    )
/*++

Routine Description:

    Creates a new GUID in string form.

Arguments:

    None.

Return Value:

    A pointer to the GUID string if successful.
    NULL if unsuccessful.

Notes:

    The storage for the GUID string must be freed by the caller.
    Sometimes, the GUID storage is copied to a buffer that is
    allocated using another allocator. At that point, the free
    routines can't tell where free method to call. Sometimes this
    causes a problem. To get around this problem, antoher buffer
    is allocated such that the free methods will always work.

--*/
{
    DWORD    sc;
    UUID     guid;
    LPWSTR   guidString = NULL;
    LPWSTR   guidBuffer = NULL;


    sc = UuidCreate( &guid );
    if ( ( sc != RPC_S_OK ) && ( sc != RPC_S_UUID_LOCAL_ONLY ) )
        goto Error;

    sc = UuidToString( &guid, &guidString );
    if ( sc != RPC_S_OK )
        goto Error;

    guidBuffer = LocalAlloc( LMEM_FIXED, ( wcslen( guidString ) + 1 ) * sizeof( WCHAR ) );
    if ( guidBuffer == NULL )
        goto Error;

    wcscpy( guidBuffer, guidString );

    goto Cleanup;

Error:

    SetLastError( sc );

Cleanup:

    if ( guidString != NULL )
    {
        RpcStringFree( &guidString );
    } // if:

    return( guidBuffer );

}  // ClRtlMakeGuid
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\rtlprop.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    rtlprop.c

Abstract:

    Implements the management of properties.

Author:

    Rod Gamache (rodga) 7-Jan-1996

Revision History:

    David Potter (davidp) 12-Mar-1997
        Moved to CLUSRTL.

--*/

#define UNICODE 1
#define _UNICODE 1

#include "clusrtlp.h"
#include "stdio.h"
#include "stdlib.h"
#include "RegistryValueName.h"

#define CLRTL_NULL_STRING L"\0"

//
// Data alignment notes
//
// All data (including embedded pointers) are aligned on 32b boundaries (64b
// platforms where not a consideration when this code was originally
// written). This makes some of the typecasting a bit tricky since the
// embedded pointers are really pointers to pointers. All double star pointers
// (i.e., LPBYTE *) have to use UNALIGNED since it is possible that the
// starting address of the pointer, i.e., the value contained in the variable,
// could end in a 4 (which on 64b. platforms is unaligned). (LPBYTE *) becomes
// (LPBYTE UNALIGNED *) or BYTE * UNALIGNED *.
//
// Consider these statements from below:
//
//    LPWSTR UNALIGNED *      ppszOutValue;
//         ppszOutValue = (LPWSTR UNALIGNED *) &pOutParams[propertyItem->Offset];
//
// ppszOutValue is an automatic variable so its address is guaranteed to be
// aligned. pOutParams is essentially an array of DWORDS (though we make no
// effort to enforce this. If that changed, property lists would be broken in
// many different places). It is possible that when we take the address of
// pOutParams + Offset, the offset may be on a DWORD boundary and not a QUAD
// boundary. Therefore we have to treat ppszOutValue's value (a pointer to
// WCHAR) as unaligned (the data itself is properly aligned). You can read the
// typecast as "an aligned pointer (ppszOutValue) to an unaligned pointer
// (address of pOutParams[Offset]) to an aligned WCHAR."
//
// LARGE_INTEGER allows us to "cheat" in that we can leverage the internal
// struct definition of LARGER_INTEGER to do 2 DWORD copies instead of
// treating the data for worst-case alignment.
//
// ISSUE-01/03/16 charlwi CLUSPROP_BUFFER_HELPER might not be correctly aligned
//
// still unsure about this but seeing how the whole property thing is
// 32b. aligned and this structure is used copiously for casting (at DWORD
// boundaries), the potential exists to have a pointer that is not QUADWORD
// aligned. When we go to deref it, we get an alignment fault.
//

//
// Static function prototypes.
//

static
DWORD
WINAPI
ClRtlpSetDwordProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_DWORD pInDwordValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    );

static
DWORD
WINAPI
ClRtlpSetLongProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_LONG pInLongValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    );

static
DWORD
WINAPI
ClRtlpSetULargeIntegerProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_ULARGE_INTEGER pInULargeIntegerValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    );

static
DWORD
WINAPI
ClRtlpSetLargeIntegerProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_LARGE_INTEGER pInLargeIntegerValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    );

static
DWORD
WINAPI
ClRtlpSetStringProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_SZ pInStringValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    );

static
DWORD
WINAPI
ClRtlpSetMultiStringProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_MULTI_SZ pInMultiStringValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    );

static
DWORD
WINAPI
ClRtlpSetBinaryProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_BINARY pInBinaryValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    );



DWORD
WINAPI
ClRtlEnumProperties(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT LPWSTR pszOutProperties,
    IN DWORD cbOutPropertiesSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Enumerates the properties for a given object.

Arguments:

    pPropertyTable - Pointer to the property table to process.

    pszOutProperties - Supplies the output buffer.

    cbOutPropertiesSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pszOutProperties.

    pcbRequired - The required number of bytes if pszOutProperties is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    A Win32 error code on failure.

--*/

{
    DWORD                   status = ERROR_SUCCESS;
    DWORD                   totalBufferLength = 0;
    PRESUTIL_PROPERTY_ITEM  property;
    LPWSTR                  psz = pszOutProperties;

    *pcbBytesReturned = 0;
    *pcbRequired = 0;

    if ( pPropertyTable == NULL ) {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlEnumProperties: pPropertyTable == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    //
    // Clear the output buffer
    //
    if ( pszOutProperties != NULL ) {
        ZeroMemory( pszOutProperties, cbOutPropertiesSize );
    }

    //
    // Get the size of all property names for this object.
    //
    for ( property = pPropertyTable ; property->Name != NULL ; property++ ) {
        totalBufferLength += (lstrlenW( property->Name ) + 1) * sizeof(WCHAR);
    }

    totalBufferLength += sizeof(UNICODE_NULL);

    //
    // If the output buffer is big enough, copy the property names.
    //
    if ( totalBufferLength > cbOutPropertiesSize ) {
        *pcbRequired = totalBufferLength;
        totalBufferLength = 0;
        if ( pszOutProperties == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        DWORD   cchCurrentNameSize;
        for ( property = pPropertyTable ; property->Name != NULL ; property++ ) {
            lstrcpyW( psz, property->Name );
            cchCurrentNameSize = lstrlenW( psz ) + 1;
            *pcbBytesReturned += cchCurrentNameSize * sizeof(WCHAR);
            psz += cchCurrentNameSize;
        }

        *psz = L'\0';
        *pcbBytesReturned += sizeof(WCHAR);
    }

    return(status);

} // ClRtlEnumProperties



DWORD
WINAPI
ClRtlEnumPrivateProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    OUT LPWSTR pszOutProperties,
    IN DWORD cbOutPropertiesSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Enumerates the properties for a given object.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pszOutProperties - Supplies the output buffer.

    cbOutPropertiesSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pszOutProperties.

    pcbRequired - The required number of bytes if pszOutProperties is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    A Win32 error code on failure.

--*/

{
    DWORD       status = ERROR_SUCCESS;
    DWORD       totalBufferLength = 0;
    LPWSTR      psz = pszOutProperties;
    DWORD       ival;
    DWORD       currentNameLength = 20;
    DWORD       nameLength;
    DWORD       dataLength;
    DWORD       type;
    LPWSTR      pszName;

    *pcbBytesReturned = 0;
    *pcbRequired = 0;

    //
    // Validate inputs
    //
    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis == NULL) ) {

        ClRtlDbgPrint( LOG_CRITICAL,
                       "ClRtlEnumPrivateProperties: hkeyClusterKey or pClusterRegApis == NULL. "
                       "Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    //
    // Clear the output buffer
    //
    if ( pszOutProperties != NULL ) {
        ZeroMemory( pszOutProperties, cbOutPropertiesSize );
    }

    //
    // Allocate a property name buffer.
    //
    pszName = static_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, currentNameLength * sizeof(WCHAR) ) );
    if ( pszName == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Enumerate all properties to find the total size.
    //
    ival = 0;
    while ( TRUE ) {
        //
        // Read the next property.
        //
        nameLength = currentNameLength;
        dataLength = 0;
        status = (*pClusterRegApis->pfnEnumValue)( hkeyClusterKey,
                                                   ival,
                                                   pszName,
                                                   &nameLength,
                                                   &type,
                                                   NULL,
                                                   &dataLength );
        if ( status == ERROR_NO_MORE_ITEMS ) {
            status = ERROR_SUCCESS;
            break;
        } else if ( status == ERROR_MORE_DATA ) {

            CL_ASSERT( (nameLength+1) > currentNameLength );

            LocalFree( pszName );

            currentNameLength = nameLength + 1; // returned value doesn't include terminating NULL
            pszName = static_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, currentNameLength * sizeof(WCHAR) ) );
            if ( pszName == NULL ) {
                status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            continue; // retry

        } else if ( status != ERROR_SUCCESS ) {
            break;
        }

        totalBufferLength += (nameLength + 1) * sizeof(WCHAR);
        ++ival;
    }

    //
    // Continue only if the operations so far have been successful.
    //
    if ( status == ERROR_SUCCESS ) {

        if ( totalBufferLength != 0 ) {
            totalBufferLength += sizeof(UNICODE_NULL);
        }

        //
        // If the output buffer is big enough, copy the property names.
        //
        if ( totalBufferLength > cbOutPropertiesSize ) {
            *pcbRequired = totalBufferLength;
            totalBufferLength = 0;
            if ( (pszOutProperties == NULL) ||
                 (cbOutPropertiesSize == 0) ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        } else if ( totalBufferLength != 0 ) {
            //
            // Enumerate all properties for copying
            //
            for ( ival = 0; ; ival++ ) {
                //
                // Read the next property.
                //
                nameLength = currentNameLength;
                dataLength = 0;
                status = (*pClusterRegApis->pfnEnumValue)( hkeyClusterKey,
                                                           ival,
                                                           pszName,
                                                           &nameLength,
                                                           &type,
                                                           NULL,
                                                           &dataLength );

                if ( status == ERROR_NO_MORE_ITEMS ) {
                    status = ERROR_SUCCESS;
                    break;
                } else if ( status == ERROR_MORE_DATA ) {
                    CL_ASSERT( 0 ); // THIS SHOULDN'T HAPPEN
                } else if ( status != ERROR_SUCCESS ) {
                    break;
                }

                //CL_ASSERT( (DWORD)lstrlenW( name ) == nameLength );
                lstrcpyW( psz, pszName );
                psz += nameLength + 1;
                *pcbBytesReturned += (nameLength + 1) * sizeof(WCHAR);
            }

            *psz = L'\0';
            *pcbBytesReturned += sizeof(WCHAR);
        }
    }

    LocalFree( pszName );

    return(status);

} // ClRtlEnumPrivateProperties



DWORD
WINAPI
ClRtlGetProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Gets the properties for a given object.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyTable - Pointer to the property list to process.

    pOutPropertyList - Supplies the output buffer.

    cbOutPropertyListSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pOutPropertyList.

    pcbRequired - The required number of bytes if pOutPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    A Win32 error code on failure.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    DWORD           itemCount = 0;
    DWORD           totalBufferLength = 0;
    PVOID           outBuffer = pOutPropertyList;
    DWORD           bufferLength = cbOutPropertyListSize;
    PRESUTIL_PROPERTY_ITEM  property;

    *pcbBytesReturned = 0;
    *pcbRequired = 0;

    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis == NULL) ||
         (pPropertyTable == NULL) ) {

        ClRtlDbgPrint( LOG_CRITICAL,
                       "ClRtlGetProperties: hkeyClusterKey, pClusterRegApis, or "
                       "pPropertyTable == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    //
    // Clear the output buffer
    //
    if ( pOutPropertyList != NULL ) {
        ZeroMemory( pOutPropertyList, cbOutPropertyListSize );
    }

    //
    // Get the size of all properties for this object.
    //
    property = pPropertyTable;
    while ( property->Name != NULL ) {
        status = ClRtlGetPropertySize( hkeyClusterKey,
                                       pClusterRegApis,
                                       property,
                                       &totalBufferLength,
                                       &itemCount );

        if ( status != ERROR_SUCCESS ) {
            break;
        }
        property++;
    }


    //
    // Continue only if the operations so far have been successful.
    //
    if ( status == ERROR_SUCCESS ) {
        //
        // Count for item count at front of return data and endmark.
        //
        totalBufferLength += sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX);

        //
        // Verify the size of all the properties
        //
        if ( totalBufferLength > cbOutPropertyListSize ) {
            *pcbRequired = totalBufferLength;
            totalBufferLength = 0;
            if ( pOutPropertyList == NULL ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        }
        else {
            *(LPDWORD)outBuffer = itemCount;
            outBuffer = (PVOID)( (PUCHAR)outBuffer + sizeof(itemCount) );
            bufferLength -= sizeof(itemCount);

            //
            // Now fetch all of the properties.
            //
            property = pPropertyTable;
            while ( property->Name != NULL ) {
                status = ClRtlGetProperty( hkeyClusterKey,
                                           pClusterRegApis,
                                           property,
                                           &outBuffer,
                                           &bufferLength );

                if ( status != ERROR_SUCCESS ) {
                    break;
                }
                property++;
            }

            // Don't forget the ENDMARK
            *(LPDWORD)outBuffer = CLUSPROP_SYNTAX_ENDMARK;

            if ( (status != ERROR_SUCCESS) &&
                 (status != ERROR_MORE_DATA) ) {
                totalBufferLength = 0;
            }
        }

        *pcbBytesReturned = totalBufferLength;
    }

    return(status);

} // ClRtlGetProperties



DWORD
WINAPI
ClRtlGetAllProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Gets the default and 'unknown' properties for a given object.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyTable - Pointer to the property table to process.

    pOutPropertyList - Supplies the output buffer.

    cbOutPropertyListSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pOutPropertyList.

    pcbRequired - The required number of bytes if pOutPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    A Win32 error code on failure.

--*/

{
    CLUSPROP_BUFFER_HELPER      cbhKnownPropBuffer;
    CLUSPROP_BUFFER_HELPER      cbhUnknownPropBuffer;
    DWORD                       cbKnownPropBufferSize;
    DWORD                       cbUnknownPropBufferSize;
    DWORD                       sc = ERROR_SUCCESS;
    DWORD                       scUnknown;
    DWORD                       dwSavedData;
    DWORD                       cbUnknownRequired = 0;
    DWORD                       cbUnknownReturned = 0;


    cbhKnownPropBuffer.pb = static_cast< LPBYTE >( pOutPropertyList );
    cbKnownPropBufferSize = cbOutPropertyListSize;

    //
    // First get the 'known' properties.
    //
    sc = ClRtlGetProperties(
                hkeyClusterKey,
                pClusterRegApis,
                pPropertyTable,
                cbhKnownPropBuffer.pb,
                cbKnownPropBufferSize,
                pcbReturned,
                pcbRequired
                );

    if ( sc != ERROR_SUCCESS )
    {
        *pcbReturned = 0;

        if ( sc != ERROR_MORE_DATA )
        {
            *pcbRequired = 0;
            return sc;
        }

        // We already know that there is insufficient space.
        scUnknown = ClRtlGetUnknownProperties(
                            hkeyClusterKey,
                            pClusterRegApis,
                            pPropertyTable,
                            NULL,
                            0,
                            &cbUnknownReturned,
                            &cbUnknownRequired
                            );

        if ( ( scUnknown != ERROR_SUCCESS ) &&
             ( scUnknown != ERROR_MORE_DATA ) )
        {
            *pcbRequired = 0;
             return scUnknown;
        }

        //
        // If both known and unknown properties exist, only one endmark
        // is required. So, subtract endmark size from total required size.
        //
        if ( ( *pcbRequired > sizeof(DWORD) ) &&
             ( cbUnknownRequired > sizeof(DWORD) ) )
        {
             *pcbRequired -= sizeof(CLUSPROP_SYNTAX);
        }

        //
        // Subtract off the size of the property count for the
        // unknown property list.
        //
        *pcbRequired += cbUnknownRequired - sizeof(DWORD);
        return sc;
    } // if: call to ClRtlGetProperties failed

    // If we are here then the call to ClRtlGetProperties succeeded.

    //
    // Calculate the position in the output buffer where unknown properties
    // should be stored.  Subtract off the size of the property count for
    // the unknown property list.  These calculations will cause the buffer
    // pointer to overlap the known property list buffer by one DWORD.
    //
    cbhUnknownPropBuffer.pb = cbhKnownPropBuffer.pb + *pcbReturned - sizeof(DWORD);
    cbUnknownPropBufferSize = cbKnownPropBufferSize - *pcbReturned + sizeof(DWORD);

    // If there are known properties, move the unknown property list
    // buffer pointer to overlap that as well.
    if ( *pcbReturned > sizeof(DWORD) )
    {
        cbhUnknownPropBuffer.pb -= sizeof(CLUSPROP_SYNTAX);
        cbUnknownPropBufferSize += sizeof(CLUSPROP_SYNTAX);
    } // if: a nonzero number of properties has been returned.

    //
    // Save the DWORD we are about to overlap.
    //
    dwSavedData = *(cbhUnknownPropBuffer.pdw);

    scUnknown = ClRtlGetUnknownProperties(
                        hkeyClusterKey,
                        pClusterRegApis,
                        pPropertyTable,
                        cbhUnknownPropBuffer.pb,
                        cbUnknownPropBufferSize,
                        &cbUnknownReturned,
                        &cbUnknownRequired
                        );

    if ( scUnknown == ERROR_SUCCESS )
    {
        //
        // The order of the next three statements is very important
        // since the known and the unknown property buffers can overlap.
        //
        DWORD nUnknownPropCount = cbhUnknownPropBuffer.pList->nPropertyCount;
        *(cbhUnknownPropBuffer.pdw) = dwSavedData;
        cbhKnownPropBuffer.pList->nPropertyCount += nUnknownPropCount;

        //
        // If both known and unknown properties exist, only one endmark
        // is required. So, subtract endmark size from total returned size.
        //
        if ( ( *pcbReturned > sizeof(DWORD) ) && 
             ( cbUnknownReturned > sizeof(DWORD) ) )
        {
            *pcbReturned -= sizeof(CLUSPROP_SYNTAX);
        }

        //
        // Add in the size of the unknown property list minus the
        // size of the unknown property list property count.
        //
        *pcbReturned += cbUnknownReturned - sizeof(DWORD);
        *pcbRequired = 0;

    } // if: call to ClRtlGetUnknownProperties succeeded
    else
    {
        if ( scUnknown == ERROR_MORE_DATA )
        {
            *pcbRequired = *pcbReturned;
            *pcbReturned = 0;

            //
            // Both known and unknown properties exist. Only one endmark
            // is required. So, subtract endmark size from total required size.
            //
            if ( ( *pcbRequired > sizeof(DWORD) ) &&
                 ( cbUnknownRequired > sizeof(DWORD) ) )
            {
                 *pcbRequired -= sizeof(CLUSPROP_SYNTAX);
            }

            //
            // Add in the size of the unknown property list minus the
            // size of the unknown property list property count.
            //
            *pcbRequired += cbUnknownRequired - sizeof(DWORD);

        } // if: ClRtlGetUnknownProperties returned ERROR_MORE_DATA
        else
        {
            *pcbRequired = 0;
            *pcbReturned = 0;

        } // else: ClRtlGetUnknownProperties failed for some unknown reason.

    } // else: Call to ClRtlGetUnknownProperties failed.

    return scUnknown;

} //*** ClRtlGetAllProperties()


DWORD
WINAPI
ClRtlGetPropertiesToParameterBlock(
    IN HKEY hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN OUT LPBYTE pOutParams,
    IN BOOL bCheckForRequiredProperties,
    OUT OPTIONAL LPWSTR * pszNameOfPropInError
    )

/*++

Routine Description:

    Read properties based on a property table.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the properties are stored.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyTable - Pointer to the property table to process.

    pOutParams - Parameter block to read into.

    bCheckForRequiredProperties - Boolean value specifying whether missing
        required properties should cause an error.

    pszNameOfPropInError - String pointer in which to return the name of the
        property in error (optional).

Return Value:

    ERROR_SUCCESS - Properties read successfully.

    ERROR_INVALID_DATA - Required property not present.

    ERROR_INVALID_PARAMETER - 

    A Win32 error code on failure.

--*/

{
    PRESUTIL_PROPERTY_ITEM  propertyItem = pPropertyTable;
    HKEY                    key;
    DWORD                   status = ERROR_SUCCESS;
    DWORD                   valueType;
    DWORD                   valueSize;
    LPWSTR                  pszInValue;
    LPBYTE                  pbInValue;
    DWORD                   dwInValue;
    LPWSTR UNALIGNED *      ppszOutValue;
    LPBYTE UNALIGNED *      ppbOutValue;
    DWORD *                 pdwOutValue;
    LONG *                  plOutValue;
    ULARGE_INTEGER *        pullOutValue;
    LARGE_INTEGER *         pllOutValue;
    CRegistryValueName      rvn;


    if ( pszNameOfPropInError != NULL ) {
        *pszNameOfPropInError = NULL;
    }

    if ( (hkeyClusterKey == NULL) ||
         (pPropertyTable == NULL) ||
         (pOutParams == NULL) ||
         (pClusterRegApis == NULL) ||
         (pClusterRegApis->pfnOpenKey == NULL) ||
         (pClusterRegApis->pfnCloseKey == NULL) ||
         (pClusterRegApis->pfnQueryValue == NULL) ) {

        ClRtlDbgPrint( LOG_CRITICAL,
                       "ClRtlGetPropertiesToParameterBlock: hkeyClusterKey, pPropertyTable, "
                       "pOutParams, pClusterRegApis, or required pfns == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    while ( propertyItem->Name != NULL ) {
        // 
        // Use the wrapper class CRegistryValueName to parse value name to see if it 
        // contains a backslash.
        // 
        status = rvn.ScInit( propertyItem->Name, propertyItem->KeyName );
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // If the value resides at a different location, open the key.
        //
        if ( rvn.PszKeyName() != NULL ) {

            DWORD disposition;

            status = (*pClusterRegApis->pfnOpenKey)( 
                            hkeyClusterKey,
                            rvn.PszKeyName(),
                            KEY_ALL_ACCESS,
                            (void **) &key
                            );

            // If key could not be opened, then we may need to put the default value
            // for the property item.
            if ( status != ERROR_SUCCESS ) {
                status = ERROR_FILE_NOT_FOUND;
            }

        } else {
            key = hkeyClusterKey;
        }

        switch ( propertyItem->Format ) {
            case CLUSPROP_FORMAT_DWORD:
                pdwOutValue = (DWORD *) &pOutParams[propertyItem->Offset];
                valueSize = sizeof(DWORD);

                // If OpenKey has succeeded.
                if ( status == ERROR_SUCCESS ) {
                    status = (*pClusterRegApis->pfnQueryValue)( key,
                                                                rvn.PszName(),
                                                                &valueType,
                                                                (LPBYTE) pdwOutValue,
                                                                &valueSize );
                }

                if ( status == ERROR_SUCCESS ) {
                    if ( valueType != REG_DWORD ) {

                        ClRtlDbgPrint( LOG_CRITICAL,
                                       "ClRtlGetPropertiesToParameterBlock: Property '%1!ls!' "
                                       "expected to be REG_DWORD (%2!d!), was %3!d!.\n",
                                       propertyItem->Name, REG_DWORD, valueType );
                        status = ERROR_INVALID_PARAMETER;
                    }
                } else if ( (status == ERROR_FILE_NOT_FOUND) &&
                            (!(propertyItem->Flags & RESUTIL_PROPITEM_REQUIRED) ||
                             ! bCheckForRequiredProperties) ) {
                    *pdwOutValue = propertyItem->Default;
                    status = ERROR_SUCCESS;
                }
                break;

            case CLUSPROP_FORMAT_LONG:
                plOutValue = (LONG *) &pOutParams[propertyItem->Offset];
                valueSize = sizeof(LONG);
                // If OpenKey has succeeded.
                if ( status == ERROR_SUCCESS ) {
                    status = (*pClusterRegApis->pfnQueryValue)( key,
                                                                rvn.PszName(),
                                                                &valueType,
                                                                (LPBYTE) plOutValue,
                                                                &valueSize );
                }

                if ( status == ERROR_SUCCESS ) {
                    if ( valueType != REG_DWORD ) {

                        ClRtlDbgPrint( LOG_CRITICAL,
                                       "ClRtlGetPropertiesToParameterBlock: Property '%1!ls!' "
                                       "expected to be REG_DWORD (%2!d!), was %3!d!.\n",
                                       propertyItem->Name, REG_DWORD, valueType );
                        status = ERROR_INVALID_PARAMETER;
                    }
                } else if ( (status == ERROR_FILE_NOT_FOUND) &&
                            (!(propertyItem->Flags & RESUTIL_PROPITEM_REQUIRED) ||
                             !bCheckForRequiredProperties) ) {
                    *plOutValue = propertyItem->Default;
                    status = ERROR_SUCCESS;
                }
                break;

            case CLUSPROP_FORMAT_ULARGE_INTEGER:
                pullOutValue = (ULARGE_INTEGER *) &pOutParams[propertyItem->Offset];
                valueSize = sizeof(ULARGE_INTEGER);

                // If OpenKey has succeeded.
                if ( status == ERROR_SUCCESS ) {
                    status = (*pClusterRegApis->pfnQueryValue)( key,
                                                                rvn.PszName(),
                                                                &valueType,
                                                                (LPBYTE) pullOutValue,
                                                                &valueSize );
                }

                if ( status == ERROR_SUCCESS ) {
                    if ( valueType != REG_QWORD ) {

                        ClRtlDbgPrint( LOG_CRITICAL,
                                       "ClRtlGetPropertiesToParameterBlock: Property '%1!ls!' "
                                       "expected to be REG_QWORD (%2!d!), was %3!d!.\n",
                                       propertyItem->Name, REG_QWORD, valueType );
                        status = ERROR_INVALID_PARAMETER;
                    }
                } else if ( (status == ERROR_FILE_NOT_FOUND) &&
                            (!(propertyItem->Flags & RESUTIL_PROPITEM_REQUIRED) ||
                             ! bCheckForRequiredProperties) ) {
                    pullOutValue->u = propertyItem->ULargeIntData->Default.u;
                    status = ERROR_SUCCESS;
                }
                break;

            case CLUSPROP_FORMAT_LARGE_INTEGER:
                pllOutValue = (LARGE_INTEGER *) &pOutParams[propertyItem->Offset];
                valueSize = sizeof(LARGE_INTEGER);

                // If OpenKey has succeeded.
                if ( status == ERROR_SUCCESS ) {
                    status = (*pClusterRegApis->pfnQueryValue)( key,
                                                                rvn.PszName(),
                                                                &valueType,
                                                                (LPBYTE) pllOutValue,
                                                                &valueSize );
                }

                if ( status == ERROR_SUCCESS ) {
                    if ( valueType != REG_QWORD ) {

                        ClRtlDbgPrint( LOG_CRITICAL,
                                       "ClRtlGetPropertiesToParameterBlock: Property '%1!ls!' "
                                       "expected to be REG_QWORD (%2!d!), was %3!d!.\n",
                                       propertyItem->Name, REG_QWORD, valueType );
                        status = ERROR_INVALID_PARAMETER;
                    }
                } else if ( (status == ERROR_FILE_NOT_FOUND) &&
                            (!(propertyItem->Flags & RESUTIL_PROPITEM_REQUIRED) ||
                             ! bCheckForRequiredProperties) )
                {
                    pllOutValue->u = propertyItem->LargeIntData->Default.u;
                    status = ERROR_SUCCESS;
                }
                break;

            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
                ppszOutValue = (LPWSTR UNALIGNED *) &pOutParams[propertyItem->Offset];
                // If OpenKey has succeeded.
                if ( status == ERROR_SUCCESS ) {
                    pszInValue = ClRtlGetSzValue( key,
                                                  rvn.PszName(),
                                                  pClusterRegApis );
                }
                else {
                    pszInValue = NULL;
                    SetLastError(status);
                }

                if ( pszInValue == NULL ) {
                    status = GetLastError();
                    if ( (status == ERROR_FILE_NOT_FOUND) &&
                         (!(propertyItem->Flags & RESUTIL_PROPITEM_REQUIRED) ||
                          ! bCheckForRequiredProperties) ) {

                        status = ERROR_SUCCESS;

                        // Deallocate old value.
                        if ( *ppszOutValue != NULL ) {
                            LocalFree( *ppszOutValue );
                            *ppszOutValue = NULL;
                        }

                        // If a default is specified, copy it.
                        if ( propertyItem->lpDefault != NULL ) {
                            *ppszOutValue = (LPWSTR) LocalAlloc( LMEM_FIXED, (lstrlenW( (LPCWSTR) propertyItem->lpDefault ) + 1) * sizeof(WCHAR) );
                            if ( *ppszOutValue == NULL ) {
                                status = GetLastError();
                            } else {
                                lstrcpyW( *ppszOutValue, (LPCWSTR) propertyItem->lpDefault );
                            }
                        }
                    }
                } else {
                    if ( *ppszOutValue != NULL ) {
                        LocalFree( *ppszOutValue );
                    }
                    *ppszOutValue = pszInValue;
                }
                break;

            case CLUSPROP_FORMAT_MULTI_SZ:
            case CLUSPROP_FORMAT_BINARY:
                ppbOutValue = (LPBYTE UNALIGNED *) &pOutParams[propertyItem->Offset];
                pdwOutValue = (DWORD *) &pOutParams[propertyItem->Offset+sizeof(LPBYTE*)];
                // If OpenKey has succeeded.
                if ( status == ERROR_SUCCESS ) {
                    status = ClRtlGetBinaryValue( key,
                                                  rvn.PszName(),
                                                  &pbInValue,
                                                  &dwInValue,
                                                  pClusterRegApis );
                }

                if ( status == ERROR_SUCCESS ) {
                    if ( *ppbOutValue != NULL ) {
                        LocalFree( *ppbOutValue );
                    }
                    *ppbOutValue = pbInValue;
                    *pdwOutValue = dwInValue;
                } else if ( (status == ERROR_FILE_NOT_FOUND) &&
                            (!(propertyItem->Flags & RESUTIL_PROPITEM_REQUIRED) ||
                             ! bCheckForRequiredProperties) ) {

                    status = ERROR_SUCCESS;

                    // Deallocate old value.
                    if ( *ppbOutValue != NULL ) {
                        LocalFree( *ppbOutValue );
                        *ppbOutValue = NULL;
                    }

                    *pdwOutValue = 0;

                    // If a default is specified, copy it.
                    if ( propertyItem->lpDefault != NULL ) {
                        *ppbOutValue = (LPBYTE) LocalAlloc( LMEM_FIXED, propertyItem->Minimum );
                        if ( *ppbOutValue == NULL ) {
                            status = GetLastError();
                        } else {
                            CopyMemory( *ppbOutValue, (const PVOID) propertyItem->lpDefault, propertyItem->Minimum );
                            *pdwOutValue = propertyItem->Minimum;
                        }
                    }
                }
                break;
        }

        //
        // Close the key if we opened it.
        //
        if ( (rvn.PszKeyName() != NULL) &&
             (key != NULL) ) {
            (*pClusterRegApis->pfnCloseKey)( key );
        }

        //
        // Handle any errors that occurred.
        //
        if ( status != ERROR_SUCCESS ) {
            if ( pszNameOfPropInError != NULL ) {
                *pszNameOfPropInError = propertyItem->Name;
            }
            if ( propertyItem->Flags & RESUTIL_PROPITEM_REQUIRED ) {
                if ( status == ERROR_FILE_NOT_FOUND ) {
                    status = ERROR_INVALID_DATA;
                }
                break;
            } else {
                status = ERROR_SUCCESS;
            }
        }

        //
        // Advance to the next property.
        //
        propertyItem++;
    }

    return(status);

} // ClRtlGetPropertiesToParameterBlock



DWORD
WINAPI
ClRtlPropertyListFromParameterBlock(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID  pOutPropertyList,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN const LPBYTE pInParams,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Constructs a property list from a parameter block.

Arguments:

    pPropertyTable - Pointer to the property table to process.

    pOutPropertyList - Supplies the output buffer.

    pcbOutPropertyListSize - Supplies the size of the output buffer.

    pInParams - Supplies the input parameter block.

    pcbBytesReturned - The number of bytes returned in pOutPropertyList.

    pcbRequired - The required number of bytes if pOutPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    ERROR_MORE_DATA - Output buffer isn't big enough to build the property list.

    A Win32 error code on failure.

--*/

{
    DWORD                   status = ERROR_SUCCESS;
    DWORD                   bytesReturned;
    DWORD                   required;
    DWORD                   nameSize;
    DWORD                   dataSize;
    DWORD                   bufferIncrement;
    DWORD                   totalBufferSize = 0;
    LPDWORD                 ptrItemCount;
    WORD                    propertyFormat;
    BOOL                    copying = TRUE;
    PRESUTIL_PROPERTY_ITEM  propertyItem = pPropertyTable;
    CLUSPROP_BUFFER_HELPER  props;
    LPWSTR UNALIGNED *      ppszValue;
    PBYTE UNALIGNED *       ppbValue;
    DWORD *                 pdwValue;
    ULARGE_INTEGER *        pullValue;
    LPWSTR                  pszUnexpanded;
    LPWSTR                  pszExpanded = NULL;

    *pcbBytesReturned = 0;
    *pcbRequired = 0;

    if ( (pPropertyTable == NULL) ||
         (pInParams == NULL) ||
         (pcbOutPropertyListSize == NULL) ) {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlPropertyListFromParameterBlock: pPropertyTable, pInParams, or pcbOutPropertyListSize == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    //
    // Clear the output buffer.
    //
    if ( pOutPropertyList != NULL ) {
        ZeroMemory( pOutPropertyList, *pcbOutPropertyListSize );
    } else {
        copying = FALSE;
    }

    //
    // Need a DWORD of item count.
    //
    props.pb = (LPBYTE) pOutPropertyList;
    ptrItemCount = props.pdw++;

    totalBufferSize += sizeof(DWORD);
    if ( totalBufferSize > *pcbOutPropertyListSize ) {
        copying = FALSE;
    }

    while ( propertyItem->Name != NULL ) {
        //
        // Copy the property name.
        //
        nameSize = (lstrlenW( propertyItem->Name ) + 1) * sizeof(WCHAR);
        bufferIncrement = sizeof(CLUSPROP_PROPERTY_NAME) + ALIGN_CLUSPROP( nameSize );
        totalBufferSize += bufferIncrement;
        if ( copying && (totalBufferSize <= *pcbOutPropertyListSize) ) {
            props.pName->Syntax.dw = CLUSPROP_SYNTAX_NAME;
            props.pName->cbLength = nameSize;
            lstrcpyW( props.pName->sz, propertyItem->Name );
            props.pb += bufferIncrement;
        } else {
            copying = FALSE;
        }

        //
        // Copy the property value.
        //
        propertyFormat = (WORD) propertyItem->Format;
        switch ( propertyItem->Format ) {

            case CLUSPROP_FORMAT_DWORD:
            case CLUSPROP_FORMAT_LONG:
                pdwValue = (DWORD *) &pInParams[propertyItem->Offset];
                bufferIncrement = sizeof(CLUSPROP_DWORD);
                totalBufferSize += bufferIncrement;
                if ( copying && (totalBufferSize <= *pcbOutPropertyListSize) ) {
                    props.pSyntax->wFormat = propertyFormat;
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    props.pDwordValue->cbLength = sizeof(DWORD);
                    props.pDwordValue->dw = *pdwValue;
                    props.pb += bufferIncrement;
                } else {
                    copying = FALSE;
                }
                break;

            case CLUSPROP_FORMAT_ULARGE_INTEGER:
            case CLUSPROP_FORMAT_LARGE_INTEGER:
                pullValue = (ULARGE_INTEGER *) &pInParams[propertyItem->Offset];
                bufferIncrement = sizeof(CLUSPROP_ULARGE_INTEGER);
                totalBufferSize += bufferIncrement;
                if ( copying && (totalBufferSize <= *pcbOutPropertyListSize) ) {
                    props.pSyntax->wFormat = propertyFormat;
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    props.pULargeIntegerValue->cbLength = sizeof(ULARGE_INTEGER);
                    props.pULargeIntegerValue->li.u = pullValue->u;
                    props.pb += bufferIncrement;
                } else {
                    copying = FALSE;
                }
                break;

            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
                ppszValue = (LPWSTR UNALIGNED *) &pInParams[propertyItem->Offset];
                pszUnexpanded = *ppszValue;
                if ( *ppszValue != NULL ) {
                    dataSize = (lstrlenW( *ppszValue ) + 1) * sizeof(WCHAR);
                } else {
                    dataSize = sizeof(WCHAR);
                }
                bufferIncrement = sizeof(CLUSPROP_SZ) + ALIGN_CLUSPROP( dataSize );
                totalBufferSize += bufferIncrement;
                if ( copying && (totalBufferSize <= *pcbOutPropertyListSize) ) {
                    props.pSyntax->wFormat = propertyFormat;
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    props.pStringValue->cbLength = dataSize;
                    if ( *ppszValue != NULL ) {
                        lstrcpyW( props.pStringValue->sz, *ppszValue );
                    } else {
                        props.pStringValue->sz[0] = L'\0';
                    }
                    props.pb += bufferIncrement;
                } else {
                    copying = FALSE;
                }

                //
                // See if there is a different expanded string and, if so,
                // return it as an additional value in the value list.
                //
                if ( pszUnexpanded != NULL ) {
                    pszExpanded = ClRtlExpandEnvironmentStrings( pszUnexpanded );
                    if ( pszExpanded == NULL ) {
                        status = GetLastError();
                        break;
                    }
                    if ( lstrcmpW( pszExpanded, pszUnexpanded ) != 0 ) {
                        dataSize = (lstrlenW( pszExpanded ) + 1) * sizeof( WCHAR );
                        bufferIncrement = sizeof( CLUSPROP_SZ ) + ALIGN_CLUSPROP( dataSize );
                        totalBufferSize += bufferIncrement;
                        if ( totalBufferSize <= *pcbOutPropertyListSize ) {
                            props.pSyntax->dw = CLUSPROP_SYNTAX_LIST_VALUE_EXPANDED_SZ;
                            props.pStringValue->cbLength = dataSize;
                            lstrcpyW( props.pStringValue->sz, pszExpanded );
                            props.pb += bufferIncrement;
                        } else {
                            copying = FALSE;
                        }
                    }
                    LocalFree( pszExpanded );
                    pszExpanded = NULL;
                }
                break;

            case CLUSPROP_FORMAT_MULTI_SZ:
                ppszValue = (LPWSTR UNALIGNED *) &pInParams[propertyItem->Offset];
                pdwValue = (DWORD *) &pInParams[propertyItem->Offset+sizeof(LPWSTR*)];
                if ( *ppszValue != NULL ) {
                    bufferIncrement = sizeof(CLUSPROP_SZ) + ALIGN_CLUSPROP( *pdwValue );
                } else {
                    bufferIncrement = sizeof(CLUSPROP_SZ) + ALIGN_CLUSPROP( sizeof(WCHAR) );
                }
                totalBufferSize += bufferIncrement;
                if ( copying && (totalBufferSize <= *pcbOutPropertyListSize) ) {
                    props.pSyntax->wFormat = propertyFormat;
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    if ( *ppszValue != NULL ) {
                        props.pStringValue->cbLength = *pdwValue;
                        CopyMemory( props.pStringValue->sz, *ppszValue, *pdwValue );
                    } else {
                        props.pStringValue->cbLength = sizeof(WCHAR);
                        props.pStringValue->sz[0] = L'\0';
                    }
                    props.pb += bufferIncrement;
                } else {
                    copying = FALSE;
                }
                break;

            case CLUSPROP_FORMAT_BINARY:
                ppbValue = (PBYTE UNALIGNED *) &pInParams[propertyItem->Offset];
                pdwValue = (DWORD *) &pInParams[propertyItem->Offset+sizeof(PBYTE*)];
                if ( *ppbValue != NULL ) {
                    bufferIncrement = sizeof(CLUSPROP_BINARY) + ALIGN_CLUSPROP( *pdwValue );
                } else {
                    bufferIncrement = sizeof(CLUSPROP_BINARY);
                }
                totalBufferSize += bufferIncrement;
                if ( copying && (totalBufferSize <= *pcbOutPropertyListSize) ) {
                    props.pSyntax->wFormat = propertyFormat;
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    if ( *ppbValue != NULL ) {
                        props.pBinaryValue->cbLength = *pdwValue;
                        CopyMemory( props.pBinaryValue->rgb, *ppbValue, *pdwValue );
                    } else {
                        props.pBinaryValue->cbLength = 0;
                    }
                    props.pb += bufferIncrement;
                } else {
                    copying = FALSE;
                }
                break;

            default:
                break;
        }

        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // Add the value-closing endmark.
        //
        bufferIncrement = sizeof(CLUSPROP_SYNTAX);
        totalBufferSize += bufferIncrement;
        if ( copying && (totalBufferSize <= *pcbOutPropertyListSize) ) {
            props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
            props.pb += bufferIncrement;
            (*ptrItemCount)++;
        } else {
            copying = FALSE;
        }

        //
        // Advance to the next property.
        //
        propertyItem++;
    }

    if ( status == ERROR_SUCCESS ) {
        // Don't forget the ENDMARK.
        totalBufferSize += sizeof(CLUSPROP_SYNTAX);
        if ( copying && (totalBufferSize <= *pcbOutPropertyListSize) ) {
            props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
        } else {
            copying = FALSE;
        }

        //
        // Return size of data.
        //
        if ( copying == FALSE ) {
            *pcbRequired = totalBufferSize;
            *pcbBytesReturned = 0;
            status = ERROR_MORE_DATA;
        } else {
            *pcbRequired = 0;
            *pcbBytesReturned = totalBufferSize;
            status = ERROR_SUCCESS;
        }
    }

    return(status);

} // ClRtlPropertyListFromParameterBlock



DWORD
WINAPI
ClRtlGetPrivateProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Gets the private properties for a given object.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pOutPropertyList - Supplies the output buffer.

    cbOutPropertyListSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pOutPropertyList.

    pcbRequired - The required number of bytes if pOutPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    ERROR_MORE_DATA - Output buffer isn't big enough to build the property list.

    A Win32 error code on failure.

--*/

{
    DWORD       status = ERROR_SUCCESS;
    DWORD       ival;
    DWORD       currentNameLength = 80;
    DWORD       currentDataLength = 80;
    DWORD       nameLength;
    DWORD       dataLength;
    DWORD       dataLengthExpanded;
    DWORD       type;
    LPWSTR      name;
    PUCHAR      data;
    LPDWORD     ptrItemCount;
    DWORD       itemCount = 0;
    BOOL        copying = TRUE;
    DWORD       totalBufferSize = 0;
    DWORD       bufferIncrement;
    DWORD       bufferIncrementExpanded;
    CLUSPROP_BUFFER_HELPER  props;
    LPWSTR      pszExpanded = NULL;

    *pcbBytesReturned = 0;
    *pcbRequired = 0;

    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis->pfnEnumValue == NULL) ) {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetPrivateProperties: hkeyClusterKey or pClusterRegApis->pfnEnumValue == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    //
    // Clear the output buffer
    //
    if ( pOutPropertyList != NULL ) {
        ZeroMemory( pOutPropertyList, cbOutPropertyListSize );
    } else {
        copying = FALSE;
    }

    //
    // Need a DWORD of item count.
    //
    props.pb = (LPBYTE) pOutPropertyList;
    ptrItemCount = props.pdw++;

    totalBufferSize += sizeof(DWORD);
    if ( totalBufferSize > cbOutPropertyListSize ) {
        copying = FALSE;
    }

    //
    // Allocate a property name buffer.
    //
    name = (LPWSTR) LocalAlloc( LMEM_FIXED, currentNameLength * sizeof(WCHAR) );
    if ( name == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Allocate a property value data buffer.
    //
    data = (PUCHAR) LocalAlloc( LMEM_FIXED, currentDataLength );
    if ( data == NULL ) {
        LocalFree( name );
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Enumerate all properties and return them!
    //
    for ( ival = 0; ; ival++ ) {
retry:
        //
        // Read the next property.
        //
        nameLength = currentNameLength;
        dataLength = currentDataLength;
        status = (*pClusterRegApis->pfnEnumValue)( hkeyClusterKey,
                                                   ival,
                                                   name,
                                                   &nameLength,
                                                   &type,
                                                   data,
                                                   &dataLength );

        if ( status == ERROR_MORE_DATA ) {
            if ( (nameLength+1) > currentNameLength ) {
                currentNameLength = nameLength+1;
                LocalFree( name );
                name = (LPWSTR) LocalAlloc( LMEM_FIXED, currentNameLength * sizeof(WCHAR) );
                if ( name == NULL ) {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
            if ( dataLength > currentDataLength ) {
                currentDataLength = dataLength;
                LocalFree( data );
                data = (PUCHAR) LocalAlloc( LMEM_FIXED, currentDataLength );
                if ( data == NULL ) {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
            goto retry;
        } else if ( status == ERROR_NO_MORE_ITEMS ) {
            status = ERROR_SUCCESS;
            break;
        } else if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // Skip this property if it isn't of a known type.
        //
        if ( (type != REG_SZ) &&
             (type != REG_EXPAND_SZ) &&
             (type != REG_MULTI_SZ) &&
             (type != REG_BINARY) &&
             (type != REG_DWORD) &&
             (type != REG_QWORD) ) {
            continue;
        }

        itemCount++;

        //
        // Copy the property name.
        // Need a DWORD for the next name Syntax + DWORD for name byte count +
        // the namelength (in bytes? + NULL?)... must be rounded!
        //
        bufferIncrement = sizeof(CLUSPROP_PROPERTY_NAME)
                            + ALIGN_CLUSPROP( (nameLength + 1) * sizeof(WCHAR) );
        totalBufferSize += bufferIncrement;
        if ( copying && (totalBufferSize <= cbOutPropertyListSize) ) {
            props.pName->Syntax.dw = CLUSPROP_SYNTAX_NAME;
            props.pName->cbLength = (nameLength + 1) * sizeof(WCHAR);
            lstrcpyW( props.pName->sz, name);
            props.pb += bufferIncrement;
        } else {
            copying = FALSE;
        }

        switch ( type ) {

            case REG_SZ:
            case REG_EXPAND_SZ:
            case REG_MULTI_SZ:
            case REG_BINARY:
                bufferIncrement = sizeof(CLUSPROP_BINARY)
                                    + ALIGN_CLUSPROP( dataLength );
                totalBufferSize += bufferIncrement;
                if ( ( type == REG_SZ ) 
                  || ( type == REG_EXPAND_SZ ) ) {
                    pszExpanded = ClRtlExpandEnvironmentStrings( (LPCWSTR) data );
                    if ( pszExpanded == NULL ) {
                        status = GetLastError();
                        break;
                    }
                    if ( lstrcmpW( pszExpanded, (LPCWSTR) data ) != 0 ) {
                        dataLengthExpanded = (lstrlenW( pszExpanded ) + 1) * sizeof( WCHAR );
                        bufferIncrementExpanded = sizeof( CLUSPROP_SZ ) + ALIGN_CLUSPROP( dataLengthExpanded );
                        totalBufferSize += bufferIncrementExpanded;
                    }
                }
                if ( copying && (totalBufferSize <= cbOutPropertyListSize) ) {
                    if ( type == REG_SZ ) {
                        props.pSyntax->wFormat = CLUSPROP_FORMAT_SZ;
                    } else if ( type == REG_EXPAND_SZ ) {
                        props.pSyntax->wFormat = CLUSPROP_FORMAT_EXPAND_SZ;
                    } else if ( type == REG_MULTI_SZ ) {
                        props.pSyntax->wFormat = CLUSPROP_FORMAT_MULTI_SZ;
                    } else {
                        props.pSyntax->wFormat = CLUSPROP_FORMAT_BINARY;
                    }
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    props.pBinaryValue->cbLength = dataLength;
                    CopyMemory( props.pBinaryValue->rgb, data, dataLength );
                    props.pb += bufferIncrement;

                    //
                    // For SZ or EXPAND_SZ, see if there is a different
                    // expanded string and, if so, return it as an additional
                    // value in the value list.
                    //
                    if (    ( type == REG_SZ )
                        ||  ( type == REG_EXPAND_SZ ) ) {
                        if ( lstrcmpW( pszExpanded, (LPCWSTR) data ) != 0 ) {
                            props.pSyntax->dw = CLUSPROP_SYNTAX_LIST_VALUE_EXPANDED_SZ;
                            props.pStringValue->cbLength = dataLengthExpanded;
                            lstrcpyW( props.pStringValue->sz, pszExpanded );
                            props.pb += bufferIncrementExpanded;
                        }
                    }
                } else {
                    copying = FALSE;
                }
                if ( ( ( type == REG_SZ ) || ( type == REG_EXPAND_SZ ) )
                  && ( pszExpanded != NULL ) )
                {
                    LocalFree( pszExpanded );
                    pszExpanded = NULL;
                }
                break;

            case REG_DWORD:
                bufferIncrement = sizeof(CLUSPROP_DWORD);
                totalBufferSize += bufferIncrement;
                if ( copying && (totalBufferSize <= cbOutPropertyListSize) ) {
                    props.pSyntax->wFormat = CLUSPROP_FORMAT_DWORD;
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    props.pDwordValue->cbLength = sizeof(DWORD);
                    props.pDwordValue->dw = *(LPDWORD)data;
                    props.pb += bufferIncrement;
                } else {
                    copying = FALSE;
                }
                break;

            case REG_QWORD:
                bufferIncrement = sizeof(CLUSPROP_ULARGE_INTEGER);
                totalBufferSize += bufferIncrement;
                if ( copying && (totalBufferSize <= cbOutPropertyListSize) ) {
                    props.pSyntax->wFormat = CLUSPROP_FORMAT_ULARGE_INTEGER;
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    props.pULargeIntegerValue->cbLength = sizeof(ULARGE_INTEGER);
                    props.pULargeIntegerValue->li.u = ((ULARGE_INTEGER *)data)->u;
                    props.pb += bufferIncrement;
                } else {
                    copying = FALSE;
                }
                break;

            default:
                break;
        }

        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // Add the closing endmark.
        //
        bufferIncrement = sizeof(CLUSPROP_SYNTAX);
        totalBufferSize += bufferIncrement;
        if ( copying && (totalBufferSize <= cbOutPropertyListSize) ) {
            props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
            props.pb += bufferIncrement;
        } else {
            copying = FALSE;
        }

    }

    if ( status == ERROR_SUCCESS ) {
        //
        // Add the closing endmark.
        //
        bufferIncrement = sizeof(CLUSPROP_SYNTAX);
        totalBufferSize += bufferIncrement;
        if ( copying && (totalBufferSize <= cbOutPropertyListSize) ) {
            props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
            props.pb += bufferIncrement;
        } else {
            copying = FALSE;
        }
    }

    LocalFree( name );
    LocalFree( data );

    if ( status == ERROR_SUCCESS ) {
        if ( !copying ) {
            *pcbRequired = totalBufferSize;
            status = ERROR_MORE_DATA;
        } else {
            *ptrItemCount = itemCount;
            *pcbBytesReturned = totalBufferSize;
            status = ERROR_SUCCESS;
        }
    }

    return(status);

} // ClRtlGetPrivateProperties



DWORD
WINAPI
ClRtlGetUnknownProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Gets the unknown properties for a given object.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyTable - Pointer to the property table to process.

    pOutPropertyList - Supplies the output buffer.

    cbOutPropertyListSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pOutPropertyList.

    pcbRequired - The required number of bytes if pOutPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    ERROR_MORE_DATA - Output buffer isn't big enough to build the property list.

    A Win32 error code on failure.

--*/

{
    DWORD       status = ERROR_SUCCESS;
    DWORD       ival;
    DWORD       currentNameLength = 80;
    DWORD       currentDataLength = 80;
    DWORD       nameLength;
    DWORD       dataLength;
    DWORD       dataLengthExpanded;
    DWORD       type;
    LPWSTR      name;
    PUCHAR      data;
    LPDWORD     ptrItemCount;
    DWORD       itemCount = 0;
    BOOL        copying = TRUE;
    DWORD       totalBufferSize = 0;
    DWORD       bufferIncrement;
    DWORD       bufferIncrementExpanded;
    BOOL        found;
    LPWSTR      pszExpanded = NULL;

    CLUSPROP_BUFFER_HELPER  props;
    PRESUTIL_PROPERTY_ITEM  property;

    *pcbBytesReturned = 0;
    *pcbRequired = 0;

    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis->pfnEnumValue == NULL) ) {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetPrivateProperties: hkeyClusterKey or pClusterRegApis->pfnEnumValue == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    //
    // Clear the output buffer
    //
    if ( pOutPropertyList != NULL ) {
        ZeroMemory( pOutPropertyList, cbOutPropertyListSize );
    } else {
        copying = FALSE;
    }

    //
    // Need a DWORD of item count.
    //
    props.pb = (LPBYTE) pOutPropertyList;
    ptrItemCount = props.pdw++;

    totalBufferSize += sizeof(DWORD);
    if ( totalBufferSize > cbOutPropertyListSize ) {
        copying = FALSE;
    }

    //
    // Allocate a property name buffer.
    //
    name = (LPWSTR) LocalAlloc( LMEM_FIXED, currentNameLength * sizeof(WCHAR) );
    if ( name == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Allocate a property value data buffer.
    //
    data = (PUCHAR) LocalAlloc( LMEM_FIXED, currentDataLength );
    if ( data == NULL ) {
        LocalFree( name );
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Enumerate all properties and return them!
    //
    for ( ival = 0; ; ival++ ) {
retry:
        //
        // Read the next property.
        //
        nameLength = currentNameLength;
        dataLength = currentDataLength;
        status = (*pClusterRegApis->pfnEnumValue)( hkeyClusterKey,
                                                   ival,
                                                   name,
                                                   &nameLength,
                                                   &type,
                                                   data,
                                                   &dataLength );

        if ( status == ERROR_MORE_DATA ) {
            if ( (nameLength+1) > currentNameLength ) {
                currentNameLength = nameLength+1;
                LocalFree( name );
                name = (LPWSTR) LocalAlloc( LMEM_FIXED, currentNameLength * sizeof(WCHAR) );
                if ( name == NULL ) {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
            if ( dataLength > currentDataLength ) {
                currentDataLength = dataLength;
                LocalFree( data );
                data = (PUCHAR) LocalAlloc( LMEM_FIXED, currentDataLength );
                if ( data == NULL ) {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
            goto retry;
        } else if ( status == ERROR_NO_MORE_ITEMS ) {
            status = ERROR_SUCCESS;
            break;
        } else if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // Skip this property if it isn't of a known type.
        //
        if ( (type != REG_SZ) &&
             (type != REG_EXPAND_SZ) &&
             (type != REG_MULTI_SZ) &&
             (type != REG_BINARY) &&
             (type != REG_DWORD) &&
             (type != REG_QWORD) ) {
            continue;
        }

        //
        // Check if this property item is 'known'. If so, continue.
        //
        found = FALSE;
        property = pPropertyTable;
        while ( property->Name != NULL ) {
            if ( lstrcmpiW( property->Name, name ) == 0 ) {
                found = TRUE;
                break;
            }
            property++;
        }
        if ( found ) {
            continue;
        }

        itemCount++;

        //
        // Copy the property name.
        // Need a DWORD for the next name Syntax + DWORD for name byte count +
        // the namelength (in bytes? + NULL?)... must be rounded!
        //
        bufferIncrement = sizeof(CLUSPROP_PROPERTY_NAME)
                            + ALIGN_CLUSPROP( (nameLength + 1) * sizeof(WCHAR) );
        totalBufferSize += bufferIncrement;
        if ( copying && (totalBufferSize <= cbOutPropertyListSize) ) {
            props.pName->Syntax.dw = CLUSPROP_SYNTAX_NAME;
            props.pName->cbLength = (nameLength + 1) * sizeof(WCHAR);
            lstrcpyW( props.pName->sz, name);
            props.pb += bufferIncrement;
        } else {
            copying = FALSE;
        }

        switch ( type ) {

            case REG_SZ:
            case REG_EXPAND_SZ:
            case REG_MULTI_SZ:
            case REG_BINARY:
                bufferIncrement = sizeof(CLUSPROP_BINARY)
                                    + ALIGN_CLUSPROP( dataLength );
                totalBufferSize += bufferIncrement;
                if ( type == REG_EXPAND_SZ ) {
                    pszExpanded = ClRtlExpandEnvironmentStrings( (LPCWSTR) data );
                    if ( pszExpanded == NULL ) {
                        status = GetLastError();
                        break;
                    }
                    if ( lstrcmpW( pszExpanded, (LPCWSTR) data ) != 0 ) {
                        dataLengthExpanded = (lstrlenW( pszExpanded ) + 1) * sizeof( WCHAR );
                        bufferIncrementExpanded = sizeof( CLUSPROP_SZ ) + ALIGN_CLUSPROP( dataLengthExpanded );
                        totalBufferSize += bufferIncrementExpanded;
                    }
                }
                if ( copying && (totalBufferSize <= cbOutPropertyListSize) ) {
                    if ( type == REG_SZ ) {
                        props.pSyntax->wFormat = CLUSPROP_FORMAT_SZ;
                    } else if ( type == REG_EXPAND_SZ ) {
                        props.pSyntax->wFormat = CLUSPROP_FORMAT_EXPAND_SZ;
                    } else if ( type == REG_MULTI_SZ ) {
                        props.pSyntax->wFormat = CLUSPROP_FORMAT_MULTI_SZ;
                    } else {
                        props.pSyntax->wFormat = CLUSPROP_FORMAT_BINARY;
                    }
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    props.pBinaryValue->cbLength = dataLength;
                    CopyMemory( props.pBinaryValue->rgb, data, dataLength );
                    props.pb += bufferIncrement;

                    //
                    // For SZ or EXPAND_SZ, see if there is a different
                    // expanded string and, if so, return it as an additional
                    // value in the value list.
                    //
                    if (    ( type == REG_SZ )
                        ||  ( type == REG_EXPAND_SZ ) )
                    {
                        if ( pszExpanded != NULL ) {
                            if ( lstrcmpW( pszExpanded, (LPCWSTR) data ) != 0 ) {
                                props.pSyntax->dw = CLUSPROP_SYNTAX_LIST_VALUE_EXPANDED_SZ;
                                props.pStringValue->cbLength = dataLengthExpanded;
                                lstrcpyW( props.pStringValue->sz, pszExpanded );
                                props.pb += bufferIncrementExpanded;
                            }
                        }
                    }
                } else {
                    copying = FALSE;
                }
                if ( type == REG_EXPAND_SZ ) {
                    LocalFree( pszExpanded );
                    pszExpanded = NULL;
                }
                break;

            case REG_DWORD:
                bufferIncrement = sizeof(CLUSPROP_DWORD);
                totalBufferSize += bufferIncrement;
                if ( copying && (totalBufferSize <= cbOutPropertyListSize) ) {
                    props.pSyntax->wFormat = CLUSPROP_FORMAT_DWORD;
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    props.pDwordValue->cbLength = sizeof(DWORD);
                    props.pDwordValue->dw = *(LPDWORD)data;
                    props.pb += bufferIncrement;
                } else {
                    copying = FALSE;
                }
                break;

            case REG_QWORD:
                bufferIncrement = sizeof(CLUSPROP_ULARGE_INTEGER);
                totalBufferSize += bufferIncrement;
                if ( copying && (totalBufferSize <= cbOutPropertyListSize) ) {
                    props.pSyntax->wFormat = CLUSPROP_FORMAT_ULARGE_INTEGER;
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    props.pULargeIntegerValue->cbLength = sizeof(ULARGE_INTEGER);
                    props.pULargeIntegerValue->li.u = ((ULARGE_INTEGER *)data)->u;
                    props.pb += bufferIncrement;
                } else {
                    copying = FALSE;
                }
                break;

            default:
                break;
        }

        //
        // Add the closing endmark.
        //
        bufferIncrement = sizeof(CLUSPROP_SYNTAX);
        totalBufferSize += bufferIncrement;
        if ( copying && (totalBufferSize <= cbOutPropertyListSize) ) {
            props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
            props.pb += bufferIncrement;
        } else {
            copying = FALSE;
        }

    }

    LocalFree( name );
    LocalFree( data );

    if ( !copying ) {
        *pcbRequired = totalBufferSize;
        status = ERROR_MORE_DATA;
    } else {
        *ptrItemCount = itemCount;
        *pcbBytesReturned = totalBufferSize;
        status = ERROR_SUCCESS;
    }

    return(status);

} // ClRtlGetUnknownProperties



DWORD
WINAPI
ClRtlAddUnknownProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    IN OUT LPDWORD pcbBytesReturned,
    IN OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Adds the unknown properties for a given object to the end of a property
    list.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyTable - Pointer to the property table to process.

    pOutPropertyList - Supplies the output buffer.

    cbOutPropertyListSize - Supplies the size of the output buffer.

    pcbBytesReturned - On input, contains the number of bytes in use in the
        output buffer.  On output, contains the total number of bytes in
        pOutPropertyList.

    pcbRequired - The required number of bytes if pOutPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    A Win32 error code on failure.

--*/

{
    DWORD                   status;
    CLUSPROP_BUFFER_HELPER  copyBuffer;
    CLUSPROP_BUFFER_HELPER  outBuffer;
    DWORD                   bufferLength;
    DWORD                   bytesReturned;
    DWORD                   required;

    //
    // Allocate a buffer for getting 'unknown' properties.
    //
    if ( (cbOutPropertyListSize > *pcbBytesReturned) &&
         (*pcbRequired == 0) )
    {
        bufferLength = cbOutPropertyListSize + (2 * sizeof(DWORD)) - *pcbBytesReturned;
        outBuffer.pb = (LPBYTE) LocalAlloc( LMEM_FIXED, bufferLength );
        if ( outBuffer.pb == NULL ) {
            *pcbBytesReturned = 0;
            *pcbRequired = 0;
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    } else {
        bufferLength = 0;
        outBuffer.pb = NULL;
    }

    //
    // Get the 'unknown' properties.
    //
    status = ClRtlGetUnknownProperties( hkeyClusterKey,
                                        pClusterRegApis,
                                        pPropertyTable,
                                        outBuffer.pb,
                                        bufferLength,
                                        &bytesReturned,
                                        &required );
    if ( status == ERROR_SUCCESS ) {
        //
        // Copy properties if any were found.
        //
        if ( bytesReturned > sizeof(DWORD) ) {
            //
            // Copy the unknown property data to the end of the property list.
            //
            CL_ASSERT( bytesReturned <= bufferLength );
            copyBuffer.pb = (LPBYTE) pOutPropertyList;
            copyBuffer.pList->nPropertyCount += outBuffer.pList->nPropertyCount;
            copyBuffer.pb += *pcbBytesReturned - sizeof(CLUSPROP_SYNTAX);
            CopyMemory( copyBuffer.pb, outBuffer.pb + sizeof(DWORD), bytesReturned - sizeof(DWORD) );
            *pcbBytesReturned += bytesReturned - sizeof(DWORD) - sizeof(CLUSPROP_SYNTAX);
        }
    } else if ( ( status == ERROR_MORE_DATA )
            &&  ( required == sizeof(DWORD) ) ) {
        required = 0;
        status = ERROR_SUCCESS;
    } else {
        if ( *pcbRequired == 0 ) {
            *pcbRequired = *pcbBytesReturned;
        }
        *pcbBytesReturned = 0;
    }

    //
    // If there are any properties, the number of bytes required will include
    // both a property count (DWORD) and an endmark (CLUSPROP_SYNTAX).
    // Subtract these off because these appear in both lists.
    //
    if ( required > sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX) ) {
        required -= sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX);
    }

    //
    // Free the out buffer (which may be NULL)
    //
    LocalFree( outBuffer.pb );

    //
    // Adjust lengths
    //
    *pcbRequired += required;

    return(status);

} // ClRtlAddUnknownProperties



DWORD
WINAPI
ClRtlGetPropertySize(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pnPropertyCount
    )

/*++

Routine Description:

    Get the total number of bytes required for this property.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.


    pPropertyTableItem - Supplies the property table item for the property
        whose size is to be returned.

    pcbOutPropertyListSize - Supplies the size of the output buffer
        required to add this property to a property list.

    pnPropertyCount - The count of properties is incremented.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_INVALID_PARAMETER - 

    A Win32 error code on failure.

--*/

{
    DWORD   status = ERROR_SUCCESS;
    DWORD   valueType;
    DWORD   bytesReturned;
    DWORD   headerLength;
    PVOID   key;
    LPWSTR  pszValue = NULL;
    LPWSTR  pszExpanded = NULL;
    CRegistryValueName rvn;

    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis->pfnQueryValue == NULL) ) {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetPropertySize: hkeyClusterKey or pClusterRegApis->pfnQueryValue == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    // 
    // Use the wrapper class CRegistryValueName to parse value name to see if it 
    // contains a backslash.
    // 
    status = rvn.ScInit( pPropertyTableItem->Name, pPropertyTableItem->KeyName );
    if ( status != ERROR_SUCCESS )
    {
       return status;
    }

    //
    // If the value resides at a different location, open the key.
    //
    if ( rvn.PszKeyName() != NULL ) {
        if ( (pClusterRegApis->pfnOpenKey == NULL) ||
             (pClusterRegApis->pfnCloseKey == NULL) ) {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetPropertySize: pClusterRegApis->pfnOpenValue or pfnCloseKey == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
            return(ERROR_BAD_ARGUMENTS);
        }

        status = (*pClusterRegApis->pfnOpenKey)( hkeyClusterKey,
                                                 rvn.PszKeyName(),
                                                 KEY_READ,
                                                 &key);
        
    } else {
        key = hkeyClusterKey;
    }

    //
    // Read the value size.
    //
    if ( status == ERROR_SUCCESS ) {
        status = (*pClusterRegApis->pfnQueryValue)( key,
                                                    rvn.PszName(),
                                                    &valueType,
                                                    NULL,
                                                    &bytesReturned );
    }

    //
    // If the value is not present, return the default value.
    //
    if ( status == ERROR_FILE_NOT_FOUND ) {

        switch ( pPropertyTableItem->Format ) {

            case CLUSPROP_FORMAT_DWORD:
            case CLUSPROP_FORMAT_LONG:
                status = ERROR_SUCCESS;
                bytesReturned = sizeof(DWORD);
                valueType = pPropertyTableItem->Format;
                break;

            case CLUSPROP_FORMAT_ULARGE_INTEGER:
            case CLUSPROP_FORMAT_LARGE_INTEGER:
                status = ERROR_SUCCESS;
                bytesReturned = sizeof(ULARGE_INTEGER);
                valueType = pPropertyTableItem->Format;
                break;

            case CLUSPROP_FORMAT_MULTI_SZ:
                status = ERROR_SUCCESS;
                if ( pPropertyTableItem->Default != 0 ) {
                    bytesReturned = pPropertyTableItem->Minimum;
                } else {
                    bytesReturned = sizeof(WCHAR);
                }
                valueType = pPropertyTableItem->Format;
                break;

            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
                status = ERROR_SUCCESS;
                if ( pPropertyTableItem->Default != 0 ) {
                    bytesReturned = (lstrlenW((LPCWSTR)pPropertyTableItem->lpDefault) + 1) * sizeof(WCHAR);
                } else {
                    bytesReturned = (lstrlenW(CLRTL_NULL_STRING) + 1) * sizeof(WCHAR);
                }
                valueType = pPropertyTableItem->Format;
                break;

            case CLUSPROP_FORMAT_BINARY:
                status = ERROR_SUCCESS;
                if ( pPropertyTableItem->Default != 0 ) {
                    bytesReturned = pPropertyTableItem->Minimum;
                } else {
                    bytesReturned = 0;
                }
                valueType = pPropertyTableItem->Format;
                break;

            default:
                valueType = CLUSPROP_FORMAT_UNKNOWN;
                break;
        }
    } else if ( status == ERROR_SUCCESS ) {
        switch ( valueType ) {
            case REG_DWORD:
                if ((pPropertyTableItem->Format == CLUSPROP_FORMAT_DWORD) ||
                    (pPropertyTableItem->Format == CLUSPROP_FORMAT_LONG))
                {
                    valueType = pPropertyTableItem->Format;
                } else {
                    valueType = CLUSPROP_FORMAT_UNKNOWN;
                }
                break;

            case REG_QWORD:
                if ((pPropertyTableItem->Format == CLUSPROP_FORMAT_ULARGE_INTEGER) ||
                    (pPropertyTableItem->Format == CLUSPROP_FORMAT_LARGE_INTEGER))
                {
                    valueType = pPropertyTableItem->Format;
                } else {
                    valueType = CLUSPROP_FORMAT_UNKNOWN;
                }
                break;

            case REG_MULTI_SZ:
                valueType = CLUSPROP_FORMAT_MULTI_SZ;
                break;

            case REG_SZ:
            case REG_EXPAND_SZ:
                //
                // Include the size of the expanded string in both REG_SZ and REG_EXPAND_SZ
                //
                pszValue = ClRtlGetSzValue( (HKEY) key,
                                            rvn.PszName(),
                                            pClusterRegApis );
                if ( pszValue != NULL ) {
                    pszExpanded = ClRtlExpandEnvironmentStrings( pszValue );
                    if ( pszExpanded == NULL ) {
                        status = GetLastError();
                    } else if ( lstrcmpW( pszValue, pszExpanded ) != 0 ) {
                        bytesReturned += ALIGN_CLUSPROP( (lstrlenW( pszExpanded ) + 1) * sizeof( WCHAR ) );
                        bytesReturned += sizeof(CLUSPROP_SZ);
                    }
                    LocalFree( pszValue );
                    LocalFree( pszExpanded );
                }

                if ( valueType == REG_SZ ) {
                    valueType = CLUSPROP_FORMAT_SZ;
                }
                else {
                    valueType = CLUSPROP_FORMAT_EXPAND_SZ;
                }
                break;

            case REG_BINARY:
                valueType = CLUSPROP_FORMAT_BINARY;
                break;

            default:
                valueType = CLUSPROP_FORMAT_UNKNOWN;
                break;
        }
    }

    if ( status == ERROR_FILE_NOT_FOUND ) {
        status = ERROR_SUCCESS;
    } else if ( status == ERROR_SUCCESS ) {
        if ( pPropertyTableItem->Format != valueType ) {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetPropertySize: Property '%1!ls!' format %2!d! expected, was %3!d!.\n", rvn.PszKeyName(), pPropertyTableItem->Format, valueType );
            status = ERROR_INVALID_PARAMETER;
        } else {
            //assume that the size of dword and long 
            //is fixed to 32 bits
            if (( valueType == CLUSPROP_FORMAT_DWORD ) ||
                ( valueType == CLUSPROP_FORMAT_LONG ))
            {
                headerLength = sizeof(CLUSPROP_PROPERTY_NAME)
                                + ((lstrlenW( pPropertyTableItem->Name ) + 1) * sizeof(WCHAR))
                                + sizeof(CLUSPROP_DWORD)
                                - 4   // CLUSPROP_DWORD.dw (specified by bytesReturned)
                                + sizeof(CLUSPROP_SYNTAX); // for endmark
            } else
            if (( valueType == CLUSPROP_FORMAT_ULARGE_INTEGER ) ||
                ( valueType == CLUSPROP_FORMAT_LARGE_INTEGER ))
            {
                headerLength = sizeof(CLUSPROP_PROPERTY_NAME)
                                + ((lstrlenW( pPropertyTableItem->Name ) + 1) * sizeof(WCHAR))
                                + sizeof(CLUSPROP_ULARGE_INTEGER)
                                - 8   // CLUSPROP_ULARGE_INTEGER.li (specified by bytesReturned)
                                + sizeof(CLUSPROP_SYNTAX); // for endmark
            } else {
                // NOTE: This assumes SZ, EXPAND_SZ, MULTI_SZ, and BINARY are the same size
                headerLength = sizeof(CLUSPROP_PROPERTY_NAME)
                                + ((lstrlenW( pPropertyTableItem->Name ) + 1) * sizeof(WCHAR))
                                + sizeof(CLUSPROP_BINARY)
                                + sizeof(CLUSPROP_SYNTAX); // for endmark
            }

            headerLength = ALIGN_CLUSPROP( headerLength );
            bytesReturned = ALIGN_CLUSPROP( bytesReturned );
            *pcbOutPropertyListSize += (bytesReturned + headerLength);
            *pnPropertyCount += 1;
        }
    }

    //
    // Close the key if we opened it.
    //
    if ( ( rvn.PszKeyName() != NULL ) && 
         ( key != NULL ) ) {
        (*pClusterRegApis->pfnCloseKey)( key );
    }

    return(status);

} // ClRtlGetPropertySize



DWORD
WINAPI
ClRtlGetProperty(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    OUT PVOID * pOutPropertyItem,
    IN OUT LPDWORD pcbOutPropertyItemSize
    )

/*++

Routine Description:

Arguments:

Return Value:

    ERROR_SUCCESS - 

    ERROR_BAD_ARGUMENTS - 

    ERROR_MORE_DATA - 

Notes:

    The buffer size has already been determined to be large enough to hold
    the return data.

--*/

{
    DWORD   status = ERROR_SUCCESS;
    DWORD   valueType;
    DWORD   bytesReturned;
    DWORD   bufferSize;
    PVOID   dataBuffer;
    DWORD   nameLength;
    PVOID   key = NULL;
    CLUSTER_PROPERTY_FORMAT format;
    CLUSPROP_BUFFER_HELPER  props;
    LPWSTR  pszExpanded = NULL;
    CRegistryValueName rvn;

    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis->pfnQueryValue == NULL) ) {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetProperty: hkeyClusterKey or pClusterRegApis->pfnQueryValue == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    // 
    // Use the wrapper class CRegistryValueName to parse value name to see if it 
    // contains a backslash.
    // 
    status = rvn.ScInit( pPropertyTableItem->Name, pPropertyTableItem->KeyName );
    if ( status != ERROR_SUCCESS )
    {
       return status;
    }

    //
    // If the value resides at a different location, open the key.
    //
    if ( rvn.PszKeyName() != NULL ) {
        if ( (pClusterRegApis->pfnOpenKey == NULL) ||
             (pClusterRegApis->pfnCloseKey == NULL) ) {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetProperty: pClusterRegApis->pfnOpenValue or pfnCloseKey == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
            return(ERROR_BAD_ARGUMENTS);
        }

        status = (*pClusterRegApis->pfnOpenKey)( hkeyClusterKey,
                                                 rvn.PszKeyName(),
                                                 KEY_READ,
                                                 &key);
    } else {
        key = hkeyClusterKey;
    }

    //
    // Find out if this property is available
    //
    if ( status == ERROR_SUCCESS ) {
        status = (*pClusterRegApis->pfnQueryValue)( key,
                                                    rvn.PszName(),
                                                    &valueType,
                                                    NULL,
                                                    &bytesReturned );
    }

    //
    // If the value is not present, return the default value.
    //
    if ( status == ERROR_FILE_NOT_FOUND ) {
        switch ( pPropertyTableItem->Format ) {

            case CLUSPROP_FORMAT_DWORD:
            case CLUSPROP_FORMAT_LONG:
                status = ERROR_SUCCESS;
                bytesReturned = sizeof(DWORD);
                valueType = pPropertyTableItem->Format;
                break;

            case CLUSPROP_FORMAT_ULARGE_INTEGER:
            case CLUSPROP_FORMAT_LARGE_INTEGER:
                status = ERROR_SUCCESS;
                bytesReturned = sizeof(ULARGE_INTEGER);
                valueType = pPropertyTableItem->Format;
                break;

            case CLUSPROP_FORMAT_MULTI_SZ:
                status = ERROR_SUCCESS;
                if ( pPropertyTableItem->Default != 0 ) {
                    bytesReturned = pPropertyTableItem->Minimum;
                } else {
                    bytesReturned = sizeof(WCHAR);
                }
                valueType = pPropertyTableItem->Format;
                break;

            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
                status = ERROR_SUCCESS;
                if ( pPropertyTableItem->Default != 0 ) {
                    bytesReturned = (lstrlenW((LPCWSTR)pPropertyTableItem->lpDefault) + 1) * sizeof(WCHAR);
                } else {
                    bytesReturned = (lstrlenW(CLRTL_NULL_STRING) + 1) * sizeof(WCHAR);
                }
                valueType = pPropertyTableItem->Format;
                break;

            case CLUSPROP_FORMAT_BINARY:
                status = ERROR_SUCCESS;
                if ( pPropertyTableItem->Default != 0 ) {
                    bytesReturned = pPropertyTableItem->Minimum;
                } else {
                    bytesReturned = 0;
                }
                valueType = pPropertyTableItem->Format;
                break;

            default:
                valueType = CLUSPROP_FORMAT_UNKNOWN;
                break;
        }
    }

    if ( status == ERROR_SUCCESS ) {
        //
        // Get the property format
        //
        switch ( pPropertyTableItem->Format ) {
            case CLUSPROP_FORMAT_BINARY:
            case CLUSPROP_FORMAT_DWORD:
            case CLUSPROP_FORMAT_LONG:
            case CLUSPROP_FORMAT_ULARGE_INTEGER:
            case CLUSPROP_FORMAT_LARGE_INTEGER:
            case CLUSPROP_FORMAT_MULTI_SZ:
            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
                format = (enum CLUSTER_PROPERTY_FORMAT) pPropertyTableItem->Format;
                break;

            default:
                format = CLUSPROP_FORMAT_UNKNOWN;
                break;

        }

        props.pb = (LPBYTE) *pOutPropertyItem;

        //
        // Copy the property name, which includes its syntax and length.
        //
        nameLength = (lstrlenW( pPropertyTableItem->Name ) + 1) * sizeof(WCHAR);
        props.pSyntax->dw = CLUSPROP_SYNTAX_NAME;
        props.pName->cbLength = nameLength;
        lstrcpyW( props.pName->sz, pPropertyTableItem->Name );
        bytesReturned = sizeof(*props.pName) + ALIGN_CLUSPROP( nameLength );
        *pcbOutPropertyItemSize -= bytesReturned;
        props.pb += bytesReturned;

        //
        // Copy the property value header.
        //
        props.pSyntax->wFormat = (USHORT)format;
        props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;

        //
        // Read the property value.
        //
        if ( pPropertyTableItem->Format == CLUSPROP_FORMAT_DWORD ||
             pPropertyTableItem->Format == CLUSPROP_FORMAT_LONG )
        {
            bufferSize = *pcbOutPropertyItemSize
                        - (sizeof(*props.pDwordValue) - sizeof(props.pDwordValue->dw));
            dataBuffer = &props.pDwordValue->dw;
        } else
        if ( pPropertyTableItem->Format == CLUSPROP_FORMAT_ULARGE_INTEGER ||
             pPropertyTableItem->Format == CLUSPROP_FORMAT_ULARGE_INTEGER )
        {
            bufferSize = *pcbOutPropertyItemSize
                        - (sizeof(*props.pULargeIntegerValue) - sizeof(props.pULargeIntegerValue->li));
            dataBuffer = &props.pULargeIntegerValue->li;
        } else {
            // NOTE: This assumes SZ, MULTI_SZ, and BINARY are the same size
            bufferSize = *pcbOutPropertyItemSize - sizeof(*props.pBinaryValue);
            dataBuffer = props.pBinaryValue->rgb;
        }
        bytesReturned = bufferSize;
        if ( key == NULL ) {
            status = ERROR_FILE_NOT_FOUND;
        } else {
            status = (*pClusterRegApis->pfnQueryValue)( key,
                                                        rvn.PszName(),
                                                        &valueType,
                                                        (LPBYTE) dataBuffer,
                                                        &bytesReturned );
        }

        //
        // If the value is not present, return the default value.
        //
        if ( status == ERROR_FILE_NOT_FOUND ) {
            switch ( pPropertyTableItem->Format ) {

                case CLUSPROP_FORMAT_DWORD:
                case CLUSPROP_FORMAT_LONG:
                    //assume size of dword and long is the same
                    status = ERROR_SUCCESS;
                    bytesReturned = sizeof(DWORD);
                    props.pDwordValue->dw = pPropertyTableItem->Default;
                    break;

                case CLUSPROP_FORMAT_ULARGE_INTEGER:
                case CLUSPROP_FORMAT_LARGE_INTEGER:
                    status = ERROR_SUCCESS;
                    bytesReturned = sizeof(ULARGE_INTEGER);
                    props.pULargeIntegerValue->li.u = pPropertyTableItem->ULargeIntData->Default.u;
                    break;

                case CLUSPROP_FORMAT_MULTI_SZ:
                    status = ERROR_SUCCESS;
                    if ( pPropertyTableItem->Default != 0 ) {
                        bytesReturned = pPropertyTableItem->Minimum;
                        if ( bufferSize < bytesReturned ) {
                            CopyMemory( dataBuffer, (LPCWSTR)pPropertyTableItem->lpDefault, bytesReturned );
                        }
                    } else {
                        bytesReturned = sizeof(WCHAR);
                    }
                    break;

                case CLUSPROP_FORMAT_SZ:
                case CLUSPROP_FORMAT_EXPAND_SZ:
                    status = ERROR_SUCCESS;
                    if ( pPropertyTableItem->Default != 0 ) {
                        bytesReturned = (lstrlenW((LPCWSTR)pPropertyTableItem->lpDefault) + 1) * sizeof(WCHAR);
                        if ( bufferSize < bytesReturned ) {
                            lstrcpyW( (LPWSTR) dataBuffer, (LPCWSTR)pPropertyTableItem->lpDefault );
                        }
                    } else {
                        bytesReturned = (lstrlenW(CLRTL_NULL_STRING) + 1) * sizeof(WCHAR);
                    }
                    break;

                case CLUSPROP_FORMAT_BINARY:
                    status = ERROR_SUCCESS;
                    if ( pPropertyTableItem->Default != 0 ) {
                        bytesReturned = pPropertyTableItem->Minimum;
                        if ( bufferSize < bytesReturned ) {
                            CopyMemory( dataBuffer, (LPBYTE)pPropertyTableItem->lpDefault, bytesReturned );
                        }
                    } else {
                        bytesReturned = 0;
                    }
                    break;

                default:
                    break;
            }
        }

        if ( bufferSize < bytesReturned ) {
            status = ERROR_MORE_DATA;
        } else if ( status == ERROR_SUCCESS ) {
            props.pValue->cbLength = bytesReturned;

            // Round the bytes used up to the next DWORD boundary.
            bytesReturned = ALIGN_CLUSPROP( bytesReturned );

            bytesReturned += sizeof(*props.pValue);
            props.pb += bytesReturned;

            //
            // If this is an SZ or EXPAND_SZ, see if the expanded value should
            // be added to the value list.
            //
            if (    ( pPropertyTableItem->Format == CLUSPROP_FORMAT_SZ )
                ||  ( pPropertyTableItem->Format == CLUSPROP_FORMAT_EXPAND_SZ ) ) {
                pszExpanded = ClRtlExpandEnvironmentStrings( (LPCWSTR) dataBuffer );
                if ( pszExpanded == NULL ) {
                    status = GetLastError();
                } else {
                    if ( lstrcmpiW( pszExpanded, (LPCWSTR) dataBuffer ) != 0 ) {
                        props.pSyntax->dw = CLUSPROP_SYNTAX_LIST_VALUE_EXPANDED_SZ;
                        bufferSize = ALIGN_CLUSPROP( (lstrlenW( pszExpanded ) + 1) * sizeof( WCHAR ) );
                        props.pStringValue->cbLength = bufferSize;
                        lstrcpyW( props.pStringValue->sz, pszExpanded );
                        bytesReturned += sizeof( *props.pStringValue ) + bufferSize;
                        props.pb += sizeof( *props.pStringValue ) + bufferSize;
                    }
                    LocalFree( pszExpanded );
                }
            }

            if ( status == ERROR_SUCCESS ) {
                // Add the value list endmark.
                props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
                props.pb += sizeof(*props.pSyntax);
                bytesReturned += sizeof(*props.pSyntax);

                *pcbOutPropertyItemSize -= bytesReturned;
                *pOutPropertyItem = (PVOID)props.pb;
            } // if:  ERROR_SUCCESS
        } // else if:  ERROR_SUCCESS
    } // if:  ERROR_SUCCESS

    if ( status == ERROR_FILE_NOT_FOUND ) {
        status = ERROR_SUCCESS;
    }

    //
    // Close the key if we opened it.
    //
    if ( (rvn.PszKeyName() != NULL) &&
         (key != NULL) ) {
        (*pClusterRegApis->pfnCloseKey)( key );
    }

    return(status);

} // ClRtlGetProperty



DWORD
WINAPI
ClRtlpSetPropertyTable(
    IN HANDLE hXsaction,
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    )

/*++

Routine Description:

Arguments:

    hkeyClusterKey - The opened cluster database key where properties are to
        be written.  If not specified, the property list will only be
        validated.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyTable - Pointer to the property table to process.

    Reserved - Reserved for future use.

    bAllowUnknownProperties - Don't fail if unknown properties are found.

    pInPropertyList - The input buffer.

    cbInPropertyListSize - The input buffer size.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameter block in which to return the data.  If specified,
        parameters will only be written if they are different between
        the input buffer and the parameter block.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_BAD_ARGUMENTS - hkeyClusterKey is specified but proper cluster
        registry APIs are not specified, or no property table is specified.

    ERROR_INVALID_DATA - No property list is specified or the format of the
        property list is invalid.

    ERROR_INSUFFICIENT_BUFFER - The property list buffer isn't large enough to
        contain all the data it indicates it should contain.

    ERROR_INVALID_PARAMETER - The property list isn't formatted properly.

    A Win32 Error on failure.

--*/

{
    DWORD                   status = ERROR_SUCCESS;
    PRESUTIL_PROPERTY_ITEM  propertyItem;
    DWORD                   inBufferSize;
    DWORD                   itemCount;
    DWORD                   dataSize;
    PVOID                   key;
    CLUSPROP_BUFFER_HELPER  buf;
    PCLUSPROP_PROPERTY_NAME pName;
    CRegistryValueName      rvn;

    if ( ( (hkeyClusterKey != NULL) &&
           (pClusterRegApis->pfnSetValue == NULL) ) ||
         ( pPropertyTable == NULL ) ) {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: hkeyClusterKey or pClusterRegApis->pfnSetValue == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    if ( pInPropertyList == NULL ) {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: pInPropertyList == NULL. Returning ERROR_INVALID_DATA\n" );
        return(ERROR_INVALID_DATA);
    }

    buf.pb = (LPBYTE) pInPropertyList;
    inBufferSize = cbInPropertyListSize;

    //
    // Get the number of items in this list
    //
    if ( inBufferSize < sizeof(DWORD) ) {
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    itemCount = buf.pList->nPropertyCount;
    buf.pdw++;
    inBufferSize -= sizeof(*buf.pdw);

    //
    // Parse the rest of the items in the buffer.
    //
    while ( itemCount-- ) {
        //
        // Verify that the buffer is big enough to contain the
        // property name and a value.
        //
        pName = buf.pName;
        if ( inBufferSize < sizeof(*pName) ) {
            return(ERROR_INSUFFICIENT_BUFFER);
        }
        dataSize = sizeof(*pName) + ALIGN_CLUSPROP( pName->cbLength );
        if ( inBufferSize < dataSize + sizeof(CLUSPROP_VALUE) ) {
            return(ERROR_INSUFFICIENT_BUFFER);
        }

        //
        // Verify that the syntax of the property name is correct.
        //
        if ( pName->Syntax.dw != CLUSPROP_SYNTAX_NAME ) {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: not a name syntax.\n" );
            return(ERROR_INVALID_PARAMETER);
        }

        //
        // Verify that the length is correct for the string.
        //
        if ( pName->cbLength != (lstrlenW( pName->sz ) + 1) * sizeof(WCHAR) ) {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: name is not a valid C string.\n" );
            return(ERROR_INVALID_DATA);
        }

        //
        // Move the buffer pointer to the property value.
        //
        buf.pb += dataSize;
        inBufferSize -= dataSize;

        //
        // Find the property name in the list of known properties.
        //
        propertyItem = pPropertyTable;
        while ( propertyItem->Name != NULL ) {

            if ( lstrcmpiW( pName->sz, propertyItem->Name ) == 0 ) {
                //
                // Verify that the buffer is big enough to contain the value.
                //
                dataSize = sizeof(*buf.pValue)
                            + ALIGN_CLUSPROP( buf.pValue->cbLength )
                            + sizeof(CLUSPROP_SYNTAX); // endmark
                if ( inBufferSize < dataSize ) {
                    return(ERROR_INSUFFICIENT_BUFFER);
                }

                //
                // Verify that the syntax type is LIST_VALUE.
                //
                if ( buf.pSyntax->wType != CLUSPROP_TYPE_LIST_VALUE ) {
                    ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: Property '%1!ls!' type CLUSPROP_TYPE_LIST_VALUE (%2!d!) expected, was %3!d!.\n", pName->sz, CLUSPROP_TYPE_LIST_VALUE, buf.pSyntax->wType );
                    return(ERROR_INVALID_PARAMETER);
                }

                //
                // Verify that this property should be of this format.
                //
                if ( buf.pSyntax->wFormat != propertyItem->Format ) {
                    ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: Property '%1!ls!' format %2!d! expected, was %3!d!.\n", pName->sz, propertyItem->Format, buf.pSyntax->wType );
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                //
                // Make sure we are allowed to set this item.
                //
                if ( propertyItem->Flags & RESUTIL_PROPITEM_READ_ONLY ) {
                    ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: Property '%1!ls!' is non-writable.\n", pName->sz );
                    return(ERROR_INVALID_PARAMETER);
                }

                // 
                // Use the wrapper class CRegistryValueName to parse value name to see if it 
                // contains a backslash.
                // 
                status = rvn.ScInit( propertyItem->Name, propertyItem->KeyName );
                if ( status != ERROR_SUCCESS ) {
                    return status;
                }

                //
                // If the value resides at a different location, create the key.
                //
                if ( (hkeyClusterKey != NULL) &&
                     (rvn.PszKeyName() != NULL) ) {

                    DWORD disposition;

                    if ( (pClusterRegApis->pfnCreateKey == NULL) ||
                         (pClusterRegApis->pfnCloseKey == NULL)  ) {
                        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: pClusterRegApis->pfnCreateKey or pfnCloseKey == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
                        return(ERROR_BAD_ARGUMENTS);
                    }
                    if ( hXsaction != NULL ) {
                        if ( pClusterRegApis->pfnLocalCreateKey == NULL ) {
                            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: pClusterRegApis->pfnLocalCreateKey == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
                            return(ERROR_BAD_ARGUMENTS);
                        }
                    
                        status = (*pClusterRegApis->pfnLocalCreateKey)(hXsaction, 
                                                               hkeyClusterKey,
                                                               rvn.PszKeyName(),
                                                               0,
                                                               KEY_ALL_ACCESS,
                                                               NULL,
                                                               &key,
                                                               &disposition );
                    }

                    else {
                        status = (*pClusterRegApis->pfnCreateKey)( hkeyClusterKey,
                                                               rvn.PszKeyName(),
                                                               0,
                                                               KEY_ALL_ACCESS,
                                                               NULL,
                                                               &key,
                                                               &disposition );
                    }

                    if ( status != ERROR_SUCCESS ) {
                        return(status);
                    }
                } else {
                    key = hkeyClusterKey;
                }

                //
                // Validate, write, and save the property data.
                //
                switch ( buf.pSyntax->wFormat ) {
                    case CLUSPROP_FORMAT_DWORD:
                        status = ClRtlpSetDwordProperty(
                                    hXsaction,
                                    key,
                                    pClusterRegApis,
                                    propertyItem,
                                    rvn,
                                    buf.pDwordValue,
                                    bForceWrite,
                                    pOutParams );
                        break;

                    case CLUSPROP_FORMAT_LONG:
                        status = ClRtlpSetLongProperty(
                                    hXsaction,
                                    key,
                                    pClusterRegApis,
                                    propertyItem,
                                    rvn,
                                    buf.pLongValue,
                                    bForceWrite,
                                    pOutParams );
                        break;

                    case CLUSPROP_FORMAT_ULARGE_INTEGER:
                        status = ClRtlpSetULargeIntegerProperty(
                                    hXsaction,
                                    key,
                                    pClusterRegApis,
                                    propertyItem,
                                    rvn,
                                    buf.pULargeIntegerValue,
                                    bForceWrite,
                                    pOutParams );
                        break;

                    case CLUSPROP_FORMAT_LARGE_INTEGER:
                        status = ClRtlpSetLargeIntegerProperty(
                                    hXsaction,
                                    key,
                                    pClusterRegApis,
                                    propertyItem,
                                    rvn,
                                    buf.pLargeIntegerValue,
                                    bForceWrite,
                                    pOutParams );
                        break;

                    case CLUSPROP_FORMAT_SZ:
                    case CLUSPROP_FORMAT_EXPAND_SZ:
                        status = ClRtlpSetStringProperty(
                                    hXsaction,
                                    key,
                                    pClusterRegApis,
                                    propertyItem,
                                    rvn,
                                    buf.pStringValue,
                                    bForceWrite,
                                    pOutParams );
                        break;

                    case CLUSPROP_FORMAT_MULTI_SZ:
                        status = ClRtlpSetMultiStringProperty(
                                    hXsaction,
                                    key,
                                    pClusterRegApis,
                                    propertyItem,
                                    rvn,
                                    buf.pStringValue,
                                    bForceWrite,
                                    pOutParams );
                        break;

                    case CLUSPROP_FORMAT_BINARY:
                        status = ClRtlpSetBinaryProperty(
                                    hXsaction,
                                    key,
                                    pClusterRegApis,
                                    propertyItem,
                                    rvn,
                                    buf.pBinaryValue,
                                    bForceWrite,
                                    pOutParams );
                        break;

                    default:
                        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: Property '%1!ls!' unknown format %2!d! specified.\n", pName->sz, buf.pSyntax->wFormat );
                        status = ERROR_INVALID_PARAMETER;
                        break;

                } // switch:  value data format

                //
                // Close the key if we opened it.
                //
                if ( (hkeyClusterKey != NULL) &&
                     (rvn.PszKeyName() != NULL) ) {
                    (*pClusterRegApis->pfnCloseKey)( key );
                }

                //
                // If an error occurred processing the property, cleanup and return.
                //
                if ( status != ERROR_SUCCESS ) {
                    return(status);
                }

                //
                // Move the buffer past the value.
                //
                buf.pb += dataSize;
                inBufferSize -= dataSize;

                break;

            } else {
                propertyItem++;
                //
                // If we reached the end of the list, then return failure
                // if we do not allow unknown properties.
                //
                if ( (propertyItem->Name == NULL) &&
                     ! bAllowUnknownProperties ) {
                    ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: Property '%1!ls!' not found.\n", pName->sz );
                    return(ERROR_INVALID_PARAMETER);
                }
            }

        }

        //
        // If no property name was found, this is an invalid parameter if
        // we don't allow unknown properties.  Otherwise advance past the
        // property value.
        //
        if ( propertyItem->Name == NULL) {
            if ( ! bAllowUnknownProperties ) {
                ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: Property '%1!ls!' not found.\n", pName->sz );
                return(ERROR_INVALID_PARAMETER);
            }

            //
            // Advance the buffer pointer past the value in the value list.
            //
            while ( (buf.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) &&
                    (inBufferSize > 0) ) {
                // ASSERT(inBufferSize > sizeof(*buf.pValue) + ALIGN_CLUSPROP(buf.pValue->cbLength));
                buf.pb += sizeof(*buf.pValue) + ALIGN_CLUSPROP(buf.pValue->cbLength);
                inBufferSize -= sizeof(*buf.pValue) + ALIGN_CLUSPROP(buf.pValue->cbLength);
            }  // while:  more values in the list

            //
            // Advance the buffer pointer past the value list endmark.
            //
            // ASSERT(inBufferSize >= sizeof(*buf.pSyntax));
            buf.pb += sizeof(*buf.pSyntax); // endmark
            inBufferSize -= sizeof(*buf.pSyntax);
        }
    }

    //
    // Now find any parameters that are not represented in the property
    // table. All of these extra properties will just be set without validation.
    //
    if ( (status == ERROR_SUCCESS) &&
         (pInPropertyList != NULL) &&
         bAllowUnknownProperties ) {
        status = ClRtlpSetNonPropertyTable( hXsaction,
                                            hkeyClusterKey,
                                            pClusterRegApis,
                                            pPropertyTable,
                                            NULL,
                                            pInPropertyList,
                                            cbInPropertyListSize );
    }

    return(status);

} // ClRtlpSetPropertyTable



static
DWORD
WINAPI
ClRtlpSetDwordProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_DWORD pInDwordValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    )

/*++

Routine Description:

    Validate a DWORD property, write it to the cluster database (or delete it
    if it is zero length), and save it in the specified parameter block.

Arguments:

    hXsaction - Transaction handle.

    hkey - The opened cluster database key where the property is to be written.
        If not specified, the property will only be validated.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyItem - The property from a property table to set/validate.

    rrvnModifiedNames - If the name of the property contains a backslash
        this object contains the modified name and keyname.

    pInDwordValue - The value from the property list to set/validate.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameter block in which to return the data.  If specified,
        parameters will only be written if they are different between
        the input data and the parameter block, unless bForceWrite == TRUE.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - The format of the data is invalid for a property
        list value.

    A Win32 Error on failure.

--*/

{
    DWORD   status = ERROR_SUCCESS;
    BOOL    bZeroLengthData;
    DWORD * pdwValue;

    // Loop to avoid goto's.
    do
    {
        bZeroLengthData = ( pInDwordValue->cbLength == 0 );

        //
        // Validate the property data if not zero length.
        //
        if ( ! bZeroLengthData ) {
            //
            // Verify the length of the value.
            //
            if ( pInDwordValue->cbLength != sizeof(DWORD) ) {
                ClRtlDbgPrint( LOG_UNUSUAL, "ClRtlpSetDwordProperty: Property '%1!ls!' length %2!d! not DWORD length.\n", rrvnModifiedNames.PszName(), pInDwordValue->cbLength );
                status = ERROR_INVALID_DATA;
                break;
            } // if:  data in value not size of DWORD

            //
            // Verify that the value is within the valid range.
            //
            if ( (      (pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                    &&  ((LONG) pInDwordValue->dw > (LONG) pPropertyItem->Maximum))
                || (    !(pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                    &&  (pInDwordValue->dw > pPropertyItem->Maximum)) ) {
                ClRtlDbgPrint( LOG_UNUSUAL, "ClRtlpSetDwordProperty: Property '%1!ls!' value %2!u! too large.\n", rrvnModifiedNames.PszName(), pInDwordValue->dw );
                status = ERROR_INVALID_DATA;
                break;
            } // if:  value too high
            if ( (      (pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                    &&  ((LONG) pInDwordValue->dw < (LONG) pPropertyItem->Minimum))
                || (    !(pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                    &&  (pInDwordValue->dw < pPropertyItem->Minimum)) ) {
                ClRtlDbgPrint( LOG_UNUSUAL, "ClRtlpSetDwordProperty: Property '%1!ls!' value %2!u! too small.\n", rrvnModifiedNames.PszName(), pInDwordValue->dw );
                status = ERROR_INVALID_DATA;
                break;
            } // if:  value to low
        } // if:  non-zero length data

        pdwValue = (DWORD *) &pOutParams[pPropertyItem->Offset];

        //
        // Write the value to the cluster database.
        // If the data length is zero, delete the value.
        //
        if ( hkey != NULL ) {
            if ( bZeroLengthData ) {
                if ( hXsaction ) {
                    status = (*pClusterRegApis->pfnLocalDeleteValue)(
                                    hXsaction,
                                    hkey,
                                    rrvnModifiedNames.PszName() );
                } else {
                    status = (*pClusterRegApis->pfnDeleteValue)(
                                    hkey,
                                    rrvnModifiedNames.PszName() );
                } // if/else:  doing/not doing a transaction

                //
                // If the property doesn't exist in the
                // cluster database, fix the status.
                //
                if ( status == ERROR_FILE_NOT_FOUND ) {
                    status = ERROR_SUCCESS;
                } // if:  property already doesn't exist
            } else {
                if ( hXsaction ) {
                    status = (*pClusterRegApis->pfnLocalSetValue)(
                                    hXsaction,
                                    hkey,
                                    rrvnModifiedNames.PszName(),
                                    REG_DWORD,
                                    (CONST BYTE *) &pInDwordValue->dw,
                                    sizeof(DWORD) );
                } else {
                    status = (*pClusterRegApis->pfnSetValue)(
                                    hkey,
                                    rrvnModifiedNames.PszName(),
                                    REG_DWORD,
                                    (CONST BYTE *) &pInDwordValue->dw,
                                    sizeof(DWORD) );
                } // if/else:  doing/not doing a transaction
            } // if/else:  zero length data
        } // if:  writing data

        //
        // Save the value to the output Parameter block.
        // If the data length is zero, set to the default.
        //
        if (    (status == ERROR_SUCCESS)
            &&  (pOutParams != NULL) ) {
            if ( bZeroLengthData ) {
                *pdwValue = pPropertyItem->Default;
            } else {
                *pdwValue = pInDwordValue->dw;
            } // if/else:  zero length data
        } // if:  data written successfully and parameter block specified
    } while ( 0 );

    return status;

} // ClRtlpSetDwordProperty



static
DWORD
WINAPI
ClRtlpSetLongProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_LONG pInLongValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    )

/*++

Routine Description:

    Validate a LONG property, write it to the cluster database (or delete it
    if it is zero length), and save it in the specified parameter block.

Arguments:

    hXsaction - Transaction handle.

    hkey - The opened cluster database key where the property is to be written.
        If not specified, the property will only be validated.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyItem - The property from a property table to set/validate.

    rrvnModifiedNames - If the name of the property contains a backslash
        this object contains the modified name and keyname.

    pInLongValue - The value from the property list to set/validate.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameter block in which to return the data.  If specified,
        parameters will only be written if they are different between
        the input data and the parameter block, unless bForceWrite == TRUE.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - The format of the data is invalid for a property
        list value.

    A Win32 Error on failure.

--*/

{
    DWORD   status = ERROR_SUCCESS;
    BOOL    bZeroLengthData;
    LONG *  plValue;

    // Loop to avoid goto's.
    do
    {
        bZeroLengthData = ( pInLongValue->cbLength == 0 );

        //
        // Validate the property data if not zero length.
        //
        if ( ! bZeroLengthData ) {
            //
            // Verify the length of the value.
            //
            if ( pInLongValue->cbLength != sizeof(LONG) ) {
                ClRtlDbgPrint( LOG_UNUSUAL, "ClRtlpSetLongProperty: Property '%1!ls!' length %2!d! not LONG length.\n", rrvnModifiedNames.PszName(), pInLongValue->cbLength );
                status = ERROR_INVALID_DATA;
                break;
            } // if:  data in value not size of LONG

            //
            // Verify that the value is within the valid range.
            //
            if ( pInLongValue->l > (LONG) pPropertyItem->Maximum ) {
                ClRtlDbgPrint( LOG_UNUSUAL, "ClRtlpSetLongProperty: Property '%1!ls!' value %2!d! too large.\n", rrvnModifiedNames.PszName(), pInLongValue->l );
                status = ERROR_INVALID_DATA;
                break;
            } // if:  value too high
            if ( pInLongValue->l < (LONG) pPropertyItem->Minimum ) {
                ClRtlDbgPrint( LOG_UNUSUAL, "ClRtlpSetLongProperty: Property '%1!ls!' value %2!d! too small.\n", rrvnModifiedNames.PszName(), pInLongValue->l );
                status = ERROR_INVALID_DATA;
                break;
            } // if:  value too small
        } // if:  non-zero length data

        plValue = (LONG *) &pOutParams[pPropertyItem->Offset];

        //
        // Write the value to the cluster database.
        // If the data length is zero, delete the value.
        //
        if ( hkey != NULL ) {
            if ( bZeroLengthData ) {
                if ( hXsaction ) {
                    status = (*pClusterRegApis->pfnLocalDeleteValue)(
                                    hXsaction,
                                    hkey,
                                    rrvnModifiedNames.PszName() );
                } else {
                    status = (*pClusterRegApis->pfnDeleteValue)(
                                    hkey,
                                    rrvnModifiedNames.PszName() );
                } // if/else:  doing/not doing a transaction

                //
                // If the property doesn't exist in the
                // cluster database, fix the status.
                //
                if ( status == ERROR_FILE_NOT_FOUND ) {
                    status = ERROR_SUCCESS;
                } // if:  property already doesn't exist
            } else {
                if ( hXsaction ) {
                    status = (*pClusterRegApis->pfnLocalSetValue)(
                                    hXsaction,
                                    hkey,
                                    rrvnModifiedNames.PszName(),
                                    REG_DWORD,
                                    (CONST BYTE *) &pInLongValue->l,
                                    sizeof(LONG) );
                } else {
                    status = (*pClusterRegApis->pfnSetValue)(
                                    hkey,
                                    rrvnModifiedNames.PszName(),
                                    REG_DWORD,
                                    (CONST BYTE *) &pInLongValue->l,
                                    sizeof(LONG) );
                } // if/else:  doing/not doing a transaction
            } // if/else:  zero length data
        } // if:  writing data

        //
        // Save the value to the output Parameter block.
        // If the data length is zero, set to the default.
        //
        if (    (status == ERROR_SUCCESS)
            &&  (pOutParams != NULL) ) {
            if ( bZeroLengthData ) {
                *plValue = (LONG) pPropertyItem->Default;
            } else {
                *plValue = pInLongValue->l;
            } // if/else:  zero length data
        } // if:  data written successfully and parameter block specified
    } while ( 0 );

    return status;

} // ClRtlpSetLongProperty



static
DWORD
WINAPI
ClRtlpSetULargeIntegerProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_ULARGE_INTEGER pInULargeIntegerValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    )

/*++

Routine Description:

    Validate a ULARGE_INTEGER property, write it to the cluster database (or
    delete it if it is zero length), and save it in the specified parameter
    block.

Arguments:

    hXsaction - Transaction handle.

    hkey - The opened cluster database key where the property is to be written.
        If not specified, the property will only be validated.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyItem - The property from a property table to set/validate.

    rrvnModifiedNames - If the name of the property contains a backslash
        this object contains the modified name and keyname.

    pInULargeIntegerValue - The value from the property list to set/validate.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameter block in which to return the data.  If specified,
        parameters will only be written if they are different between
        the input data and the parameter block, unless bForceWrite == TRUE.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - The format of the data is invalid for a property
        list value.

    A Win32 Error on failure.

--*/

{
    DWORD               status = ERROR_SUCCESS;
    BOOL                bZeroLengthData;
    ULARGE_INTEGER *    pullValue;

    // Loop to avoid goto's.
    do
    {
        bZeroLengthData = ( pInULargeIntegerValue->cbLength == 0 );

        //
        // Validate the property data if not zero length.
        //
        if ( ! bZeroLengthData ) {
            //
            // Verify the length of the value.
            //
            if ( pInULargeIntegerValue->cbLength != sizeof(ULARGE_INTEGER) ) {
                ClRtlDbgPrint(LOG_UNUSUAL,
                              "ClRtlpSetULargeIntegerProperty: Property '%1!ls!' length %2!d! "
                              "not ULARGE_INTEGER length.\n",
                              rrvnModifiedNames.PszName(),
                              pInULargeIntegerValue->cbLength );
                status = ERROR_INVALID_DATA;
                break;
            } // if:  data in value not size of DWORD

            //
            // Verify that the value is within the valid range.
            //
            if ( (      (pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                    &&  ((LONGLONG)pInULargeIntegerValue->li.QuadPart > (LONGLONG)pPropertyItem->ULargeIntData->Maximum.QuadPart))
                || (    !(pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                    &&  (pInULargeIntegerValue->li.QuadPart > pPropertyItem->ULargeIntData->Maximum.QuadPart)) )
            {
                ClRtlDbgPrint(
                              LOG_UNUSUAL,
                              "ClRtlpSetULargeIntegerProperty: Property '%1!ls!' value %2!I64u! "
                              "too large.\n",
                              rrvnModifiedNames.PszName(),
                              pInULargeIntegerValue->li.QuadPart );
                status = ERROR_INVALID_DATA;
                break;
            } // if:  value too high
            if ( (      (pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                    &&  ((LONGLONG)pInULargeIntegerValue->li.QuadPart < (LONGLONG)pPropertyItem->ULargeIntData->Minimum.QuadPart))
                || (    !(pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                    &&  (pInULargeIntegerValue->li.QuadPart < pPropertyItem->ULargeIntData->Minimum.QuadPart)) )
            {
                ClRtlDbgPrint(LOG_UNUSUAL,
                              "ClRtlpSetULargeIntegerProperty: Property '%1!ls!' value "
                              "%2!I64u! too small.\n",
                              rrvnModifiedNames.PszName(),
                              pInULargeIntegerValue->li.QuadPart );
                status = ERROR_INVALID_DATA;
                break;
            } // if:  value to low
        } // if:  non-zero length data

        pullValue = (ULARGE_INTEGER *) &pOutParams[pPropertyItem->Offset];

        //
        // Write the value to the cluster database.
        // If the data length is zero, delete the value.
        //
        if ( hkey != NULL ) {
            if ( bZeroLengthData ) {
                if ( hXsaction ) {
                    status = (*pClusterRegApis->pfnLocalDeleteValue)(
                                    hXsaction,
                                    hkey,
                                    rrvnModifiedNames.PszName() );
                } else {
                    status = (*pClusterRegApis->pfnDeleteValue)(
                                    hkey,
                                    rrvnModifiedNames.PszName() );
                } // if/else:  doing/not doing a transaction

                //
                // If the property doesn't exist in the
                // cluster database, fix the status.
                //
                if ( status == ERROR_FILE_NOT_FOUND ) {
                    status = ERROR_SUCCESS;
                } // if:  property already doesn't exist
            } else {
                if ( hXsaction ) {
                    status = (*pClusterRegApis->pfnLocalSetValue)(
                                    hXsaction,
                                    hkey,
                                    rrvnModifiedNames.PszName(),
                                    REG_QWORD,
                                    (CONST BYTE *) &pInULargeIntegerValue->li.QuadPart,
                                    sizeof(ULARGE_INTEGER) );
                } else {
                    status = (*pClusterRegApis->pfnSetValue)(
                                    hkey,
                                    rrvnModifiedNames.PszName(),
                                    REG_QWORD,
                                    (CONST BYTE *) &pInULargeIntegerValue->li.QuadPart,
                                    sizeof(ULARGE_INTEGER) );
                } // if/else:  doing/not doing a transaction
            } // if/else:  zero length data
        } // if:  writing data

        //
        // Save the value to the output Parameter block.
        // If the data length is zero, set to the default.
        //
        if (    (status == ERROR_SUCCESS)  &&  (pOutParams != NULL) ) {
            if ( bZeroLengthData ) {
                pullValue->u = pPropertyItem->ULargeIntData->Default.u;
            } else {
                pullValue->u = pInULargeIntegerValue->li.u;
            } // if/else:  zero length data
        } // if:  data written successfully and parameter block specified
    } while ( 0 );

    return status;

} // ClRtlpSetULargeIntegerProperty


static
DWORD
WINAPI
ClRtlpSetLargeIntegerProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_LARGE_INTEGER pInLargeIntegerValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    )

/*++

Routine Description:

    Validate a LARGE_INTEGER property, write it to the cluster database (or
    delete it if it is zero length), and save it in the specified parameter
    block.

Arguments:

    hXsaction - Transaction handle.

    hkey - The opened cluster database key where the property is to be written.
        If not specified, the property will only be validated.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyItem - The property from a property table to set/validate.

    rrvnModifiedNames - If the name of the property contains a backslash
        this object contains the modified name and keyname.

    pInLargeIntegerValue - The value from the property list to set/validate.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameter block in which to return the data.  If specified,
        parameters will only be written if they are different between
        the input data and the parameter block, unless bForceWrite == TRUE.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - The format of the data is invalid for a property
        list value.

    A Win32 Error on failure.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    BOOL            bZeroLengthData;
    LARGE_INTEGER * pllValue;

    // Loop to avoid goto's.
    do
    {
        bZeroLengthData = ( pInLargeIntegerValue->cbLength == 0 );

        //
        // Validate the property data if not zero length.
        //
        if ( ! bZeroLengthData ) {
            //
            // Verify the length of the value.
            //
            if ( pInLargeIntegerValue->cbLength != sizeof(LARGE_INTEGER) ) {
                ClRtlDbgPrint(LOG_UNUSUAL,
                              "ClRtlpSetLargeIntegerProperty: Property '%1!ls!' length %2!d! "
                              "not LARGE_INTEGER length.\n",
                              rrvnModifiedNames.PszName(),
                              pInLargeIntegerValue->cbLength );
                status = ERROR_INVALID_DATA;
                break;
            } // if:  data in value not size of DWORD

            //
            // Verify that the value is within the valid range.
            //
            if ( (      (pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                    &&  ((LONGLONG)pInLargeIntegerValue->li.QuadPart > (LONGLONG)pPropertyItem->LargeIntData->Maximum.QuadPart))
                || (    !(pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                    &&  (pInLargeIntegerValue->li.QuadPart > pPropertyItem->LargeIntData->Maximum.QuadPart)) )
            {
                ClRtlDbgPrint(LOG_UNUSUAL,
                              "ClRtlpSetLargeIntegerProperty: Property '%1!ls!' value %2!I64d! "
                              "too large.\n",
                              rrvnModifiedNames.PszName(),
                              pInLargeIntegerValue->li.QuadPart );
                status = ERROR_INVALID_DATA;
                break;
            } // if:  value too high
            if ( (      (pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                    &&  ((LONGLONG)pInLargeIntegerValue->li.QuadPart < (LONGLONG)pPropertyItem->LargeIntData->Minimum.QuadPart))
                || (    !(pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                    &&  (pInLargeIntegerValue->li.QuadPart < pPropertyItem->LargeIntData->Minimum.QuadPart)) )
            {
                ClRtlDbgPrint(LOG_UNUSUAL,
                              "ClRtlpSetLargeIntegerProperty: Property '%1!ls!' value "
                              "%2!I64d! too small.\n",
                              rrvnModifiedNames.PszName(),
                              pInLargeIntegerValue->li.QuadPart );
                status = ERROR_INVALID_DATA;
                break;
            } // if:  value to low
        } // if:  non-zero length data

        pllValue = (LARGE_INTEGER *) &pOutParams[pPropertyItem->Offset];

        //
        // Write the value to the cluster database.
        // If the data length is zero, delete the value.
        //
        if ( hkey != NULL ) {
            if ( bZeroLengthData ) {
                if ( hXsaction ) {
                    status = (*pClusterRegApis->pfnLocalDeleteValue)(
                                    hXsaction,
                                    hkey,
                                    rrvnModifiedNames.PszName() );
                } else {
                    status = (*pClusterRegApis->pfnDeleteValue)(
                                    hkey,
                                    rrvnModifiedNames.PszName() );
                } // if/else:  doing/not doing a transaction

                //
                // If the property doesn't exist in the
                // cluster database, fix the status.
                //
                if ( status == ERROR_FILE_NOT_FOUND ) {
                    status = ERROR_SUCCESS;
                } // if:  property already doesn't exist
            } else {
                if ( hXsaction ) {
                    status = (*pClusterRegApis->pfnLocalSetValue)(
                                    hXsaction,
                                    hkey,
                                    rrvnModifiedNames.PszName(),
                                    REG_QWORD,
                                    (CONST BYTE *) &pInLargeIntegerValue->li.QuadPart,
                                    sizeof(LARGE_INTEGER) );
                } else {
                    status = (*pClusterRegApis->pfnSetValue)(
                                    hkey,
                                    rrvnModifiedNames.PszName(),
                                    REG_QWORD,
                                    (CONST BYTE *) &pInLargeIntegerValue->li.QuadPart,
                                    sizeof(LARGE_INTEGER) );
                } // if/else:  doing/not doing a transaction
            } // if/else:  zero length data
        } // if:  writing data

        //
        // Save the value to the output Parameter block.
        // If the data length is zero, set to the default.
        //
        if (    (status == ERROR_SUCCESS)  &&  (pOutParams != NULL) ) {
            if ( bZeroLengthData ) {
                pllValue->u = pPropertyItem->LargeIntData->Default.u;
            } else {
                pllValue->u = pInLargeIntegerValue->li.u;
            } // if/else:  zero length data
        } // if:  data written successfully and parameter block specified
    } while ( 0 );

    return status;

} // ClRtlpSetLargeIntegerProperty


static
DWORD
WINAPI
ClRtlpSetStringProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_SZ pInStringValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    )

/*++

Routine Description:

    Validate a string property (SZ or EXPAND_SZ), write it to the cluster
    database (or delete it if it is zero length), and save it in the
    specified parameter block.

Arguments:

    hXsaction - Transaction handle.

    hkey - The opened cluster database key where the property is to be written.
        If not specified, the property will only be validated.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyItem - The property from a property table to set/validate.

    rrvnModifiedNames - If the name of the property contains a backslash
        this object contains the modified name and keyname.

    pInStringValue - The value from the property list to set/validate.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameter block in which to return the data.  If specified,
        parameters will only be written if they are different between
        the input data and the parameter block, unless bForceWrite == TRUE.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - The format of the data is invalid for a property
        list value.

    A Win32 Error on failure.

--*/

{
    DWORD               status = ERROR_SUCCESS;
    BOOL                bZeroLengthData;
    LPWSTR UNALIGNED *  ppszValue;
    DWORD               dwType;

    // Loop to avoid goto's.
    do
    {
        bZeroLengthData = ( pInStringValue->cbLength == 0 );

        //
        // Validate the property data if not zero length.
        //
        if ( ! bZeroLengthData ) {
            //
            // Verify the length of the value.
            //
            if ( pInStringValue->cbLength != (lstrlenW( pInStringValue->sz ) + 1) * sizeof(WCHAR) ) {
                ClRtlDbgPrint( LOG_UNUSUAL, "ClRtlpSetStringProperty: Property '%1!ls!' length %2!d! doesn't match zero-term. length.\n", rrvnModifiedNames.PszName(), pInStringValue->cbLength );
                status = ERROR_INVALID_DATA;
                break;
            } // if:  string length doesn't match length in property
        } // if:  non-zero length data

        ppszValue = (LPWSTR UNALIGNED *) &pOutParams[pPropertyItem->Offset];

        //
        // If the data changed, write it and save it.
        // Do this even if only the case of the data changed.
        //
        if (    (pOutParams == NULL)
            ||  (*ppszValue == NULL)
            ||  bZeroLengthData
            ||  bForceWrite
            ||  (lstrcmpW( *ppszValue, pInStringValue->sz ) != 0) ) {

            //
            // Write the value to the cluster database.
            // If the data length is zero, delete the value.
            //
            if ( hkey != NULL ) {
                if ( bZeroLengthData ) {
                    if ( hXsaction ) {
                        status = (*pClusterRegApis->pfnLocalDeleteValue)(
                                        hXsaction,
                                        hkey,
                                        rrvnModifiedNames.PszName() );
                    } else {
                        status = (*pClusterRegApis->pfnDeleteValue)(
                                        hkey,
                                        rrvnModifiedNames.PszName() );
                    } // if/else:  doing/not doing a transaction

                    //
                    // If the property doesn't exist in the
                    // cluster database, fix the status.
                    //
                    if ( status == ERROR_FILE_NOT_FOUND ) {
                        status = ERROR_SUCCESS;
                    } // if:  property already doesn't exist
                } else {
                    if ( pPropertyItem->Format == CLUSPROP_FORMAT_EXPAND_SZ ) {
                        dwType = REG_EXPAND_SZ;
                    } else {
                        dwType = REG_SZ;
                    } // if/else:  property format is EXPAND_SZ
                    if ( hXsaction ) {
                        status = (*pClusterRegApis->pfnLocalSetValue)(
                                        hXsaction,
                                        hkey,
                                        rrvnModifiedNames.PszName(),
                                        dwType,
                                        (CONST BYTE *) &pInStringValue->sz,
                                        pInStringValue->cbLength );
                    } else {
                        status = (*pClusterRegApis->pfnSetValue)(
                                        hkey,
                                        rrvnModifiedNames.PszName(),
                                        dwType,
                                        (CONST BYTE *) &pInStringValue->sz,
                                        pInStringValue->cbLength );
                    } // if/else:  doing/not doing a transaction
                } // if/else:  zero length data
            } // if:  writing data

            //
            // Save the value to the output Parameter block.
            // If the data length is zero, set to the default.
            //
            if (    (status == ERROR_SUCCESS)
                &&  (pOutParams != NULL) ) {

                if ( *ppszValue != NULL ) {
                    LocalFree( *ppszValue );
                } // if:  previous value in parameter block

                if ( bZeroLengthData ) {
                    // If a default is specified, copy it.
                    if ( pPropertyItem->lpDefault != NULL ) {
                        *ppszValue = (LPWSTR) LocalAlloc(
                                                  LMEM_FIXED,
                                                  (lstrlenW( (LPCWSTR) pPropertyItem->lpDefault ) + 1) * sizeof(WCHAR)
                                                  );
                        if ( *ppszValue == NULL ) {
                            status = GetLastError();
                            ClRtlDbgPrint(
                                LOG_CRITICAL,
                                "ClRtlpSetStringProperty: error allocating memory for default "
                                "SZ value '%1!ls!' in parameter block for property '%2!ls!'.\n",
                                pPropertyItem->lpDefault,
                                rrvnModifiedNames.PszName() );
                            break;
                        } // if:  error allocating memory
                        lstrcpyW( *ppszValue, (LPCWSTR) pPropertyItem->lpDefault );
                    } else {
                        *ppszValue = NULL;
                    } // if/else:  default value specified
                } else {
                    *ppszValue = (LPWSTR) LocalAlloc( LMEM_FIXED, pInStringValue->cbLength );
                    if ( *ppszValue == NULL ) {
                        status = GetLastError();
                        ClRtlDbgPrint(
                            LOG_CRITICAL,
                            "ClRtlpSetStringProperty: error allocating memory for SZ "
                            "value '%1!ls!' in parameter block for property '%2!ls!'.\n",
                            pInStringValue->cbLength,
                            rrvnModifiedNames.PszName() );
                        break;
                    } // if:  error allocating memory
                    lstrcpyW( *ppszValue, pInStringValue->sz );
                } // if/else:  zero length data
            } // if:  data written successfully and parameter block specified
        } // if:  value changed or zero-length value
    } while ( 0 );

    return status;

} // ClRtlpSetStringProperty



static
DWORD
WINAPI
ClRtlpSetMultiStringProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_MULTI_SZ pInMultiStringValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    )

/*++

Routine Description:

    Validate a MULTI_SZ property, write it to the cluster database (or delete
    it if it is zero length), and save it in the specified parameter block.

Arguments:

    hXsaction - Transaction handle.

    hkey - The opened cluster database key where the property is to be written.
        If not specified, the property will only be validated.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyItem - The property from a property table to set/validate.

    rrvnModifiedNames - If the name of the property contains a backslash
        this object contains the modified name and keyname.

    pInMultiStringValue - The value from the property list to set/validate.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameter block in which to return the data.  If specified,
        parameters will only be written if they are different between
        the input data and the parameter block, unless bForceWrite == TRUE.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - The format of the data is invalid for a property
        list value.

    A Win32 Error on failure.

--*/

{
    DWORD               status = ERROR_SUCCESS;
    BOOL                bZeroLengthData;
    LPWSTR UNALIGNED *  ppszValue;
    DWORD *             pdwValue;
    DWORD               dwType;

    // Loop to avoid goto's.
    do
    {
        bZeroLengthData = ( pInMultiStringValue->cbLength == 0 );

        ppszValue = (LPWSTR UNALIGNED *) &pOutParams[pPropertyItem->Offset];
        pdwValue = (DWORD *) &pOutParams[pPropertyItem->Offset + sizeof(LPWSTR *)];

        //
        // If the data changed, write it and save it.
        // Do this even if only the case of the data changed.
        //
        if (    (pOutParams == NULL)
            ||  (*ppszValue == NULL)
            ||  (*pdwValue != pInMultiStringValue->cbLength)
            ||  bZeroLengthData
            ||  bForceWrite
            ||  (memcmp( *ppszValue, pInMultiStringValue->sz, *pdwValue ) != 0) ) {

            //
            // Write the value to the cluster database.
            // If the data length is zero, delete the value.
            //
            if ( hkey != NULL ) {
                if ( bZeroLengthData ) {
                    if ( hXsaction ) {
                        status = (*pClusterRegApis->pfnLocalDeleteValue)(
                                        hXsaction,
                                        hkey,
                                        rrvnModifiedNames.PszName() );
                    } else {
                        status = (*pClusterRegApis->pfnDeleteValue)(
                                        hkey,
                                        rrvnModifiedNames.PszName() );
                    } // if/else:  doing/not doing a transaction

                    //
                    // If the property doesn't exist in the
                    // cluster database, fix the status.
                    //
                    if ( status == ERROR_FILE_NOT_FOUND ) {
                        status = ERROR_SUCCESS;
                    } // if:  property already doesn't exist
                } else {
                    if ( pPropertyItem->Format == CLUSPROP_FORMAT_MULTI_SZ ) {
                        dwType = REG_MULTI_SZ;
                    } else {
                        dwType = REG_SZ;
                    } // if/else:  property format is EXPAND_SZ
                    if ( hXsaction ) {
                        status = (*pClusterRegApis->pfnLocalSetValue)(
                                        hXsaction,
                                        hkey,
                                        rrvnModifiedNames.PszName(),
                                        dwType,
                                        (CONST BYTE *) &pInMultiStringValue->sz,
                                        pInMultiStringValue->cbLength );
                    } else {
                        status = (*pClusterRegApis->pfnSetValue)(
                                        hkey,
                                        rrvnModifiedNames.PszName(),
                                        dwType,
                                        (CONST BYTE *) &pInMultiStringValue->sz,
                                        pInMultiStringValue->cbLength );
                    } // if/else:  doing/not doing a transaction
                } // if/else:  zero length data
            } // if:  writing data

            //
            // Save the value to the output Parameter block.
            // If the data length is zero, set to the default.
            //
            if (    (status == ERROR_SUCCESS)
                &&  (pOutParams != NULL) ) {

                if ( *ppszValue != NULL ) {
                    LocalFree( *ppszValue );
                } // if:  previous value in parameter block

                if ( bZeroLengthData ) {
                    // If a default is specified, copy it.
                    if ( pPropertyItem->lpDefault != NULL ) {
                        *ppszValue = (LPWSTR) LocalAlloc( LMEM_FIXED, pPropertyItem->Minimum );
                        if ( *ppszValue == NULL ) {
                            status = GetLastError();
                            *pdwValue = 0;
                            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetMultiStringProperty: error allocating memory for default MULTI_SZ value in parameter block for property '%1!ls!'.\n", rrvnModifiedNames.PszName() );
                            break;
                        } // if:  error allocating memory
                        CopyMemory( *ppszValue, pPropertyItem->lpDefault, pPropertyItem->Minimum );
                        *pdwValue = pPropertyItem->Minimum;
                    } else {
                        *ppszValue = NULL;
                        *pdwValue = 0;
                    } // if/else:  default value specified
                } else {
                    *ppszValue = (LPWSTR) LocalAlloc( LMEM_FIXED, pInMultiStringValue->cbLength );
                    if ( *ppszValue == NULL ) {
                        status = GetLastError();
                        *pdwValue = 0;
                        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetMultiStringProperty: error allocating memory for MULTI_SZ value in parameter block for property '%1!ls!'.\n", rrvnModifiedNames.PszName() );
                        break;
                    } // if:  error allocating memory
                    CopyMemory( *ppszValue, pInMultiStringValue->sz, pInMultiStringValue->cbLength );
                    *pdwValue = pInMultiStringValue->cbLength;
                } // if/else:  zero length data
            } // if:  data written successfully and parameter block specified
        } // if:  value changed or zero-length value
    } while ( 0 );

    return status;

} // ClRtlpSetMultiStringProperty



static
DWORD
WINAPI
ClRtlpSetBinaryProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_BINARY pInBinaryValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    )

/*++

Routine Description:

    Validate a BINARY property, write it to the cluster database (or delete
    it if it is zero length), and save it in the specified parameter block.

Arguments:

    hXsaction - Transaction handle.

    hkey - The opened cluster database key where the property is to be written.
        If not specified, the property will only be validated.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyItem - The property from a property table to set/validate.

    rrvnModifiedNames - If the name of the property contains a backslash
        this object contains the modified name and keyname.

    pInBinaryValue - The value from the property list to set/validate.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameter block in which to return the data.  If specified,
        parameters will only be written if they are different between
        the input data and the parameter block, unless bForceWrite == TRUE.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - The format of the data is invalid for a property
        list value.

    A Win32 Error on failure.

--*/

{
    DWORD               status = ERROR_SUCCESS;
    BOOL                bZeroLengthData;
    PBYTE UNALIGNED *   ppbValue;
    DWORD *             pdwValue;

    // Loop to avoid goto's.
    do
    {
        bZeroLengthData = ( pInBinaryValue->cbLength == 0 );

        ppbValue = (PBYTE UNALIGNED *) &pOutParams[pPropertyItem->Offset];
        pdwValue = (DWORD *) &pOutParams[pPropertyItem->Offset + sizeof(PBYTE *)];

        //
        // If the data changed, write it and save it.
        // Do this even if only the case of the data changed.
        //
        if (    (pOutParams == NULL)
            ||  (*ppbValue == NULL)
            ||  (*pdwValue != pInBinaryValue->cbLength)
            ||  bZeroLengthData
            ||  bForceWrite
            ||  (memcmp( *ppbValue, pInBinaryValue->rgb, *pdwValue ) != 0) ) {

            //
            // Write the value to the cluster database.
            // If the data length is zero, delete the value.
            //
            if ( hkey != NULL ) {
                if ( bZeroLengthData ) {
                    if ( hXsaction ) {
                        status = (*pClusterRegApis->pfnLocalDeleteValue)(
                                        hXsaction,
                                        hkey,
                                        rrvnModifiedNames.PszName() );
                    } else {
                        status = (*pClusterRegApis->pfnDeleteValue)(
                                        hkey,
                                        rrvnModifiedNames.PszName() );
                    } // if/else:  doing/not doing a transaction

                    //
                    // If the property doesn't exist in the
                    // cluster database, fix the status.
                    //
                    if ( status == ERROR_FILE_NOT_FOUND ) {
                        status = ERROR_SUCCESS;
                    } // if:  property already doesn't exist
                } else {
                    if ( hXsaction ) {
                        status = (*pClusterRegApis->pfnLocalSetValue)(
                                        hXsaction,
                                        hkey,
                                        rrvnModifiedNames.PszName(),
                                        REG_BINARY,
                                        (CONST BYTE *) &pInBinaryValue->rgb,
                                        pInBinaryValue->cbLength );
                    } else {
                        status = (*pClusterRegApis->pfnSetValue)(
                                        hkey,
                                        rrvnModifiedNames.PszName(),
                                        REG_BINARY,
                                        (CONST BYTE *) &pInBinaryValue->rgb,
                                        pInBinaryValue->cbLength );
                    } // if/else:  doing/not doing a transaction
                } // if/else:  zero length data
            } // if:  writing data

            //
            // Save the value to the output Parameter block.
            // If the data length is zero, set to the default.
            //
            if (    (status == ERROR_SUCCESS)
                &&  (pOutParams != NULL) ) {

                if ( *ppbValue != NULL ) {
                    LocalFree( *ppbValue );
                } // if:  previous value in parameter block

                if ( bZeroLengthData ) {
                    // If a default is specified, copy it.
                    if ( pPropertyItem->lpDefault != NULL ) {
                        *ppbValue = (LPBYTE) LocalAlloc( LMEM_FIXED, pPropertyItem->Minimum );
                        if ( *ppbValue == NULL ) {
                            status = GetLastError();
                            *pdwValue = 0;
                            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetBinaryProperty: error allocating memory for default BINARY value in parameter block for property '%1!ls!'.\n", rrvnModifiedNames.PszName() );
                            break;
                        } // if:  error allocating memory
                        CopyMemory( *ppbValue, pPropertyItem->lpDefault, pPropertyItem->Minimum );
                        *pdwValue = pPropertyItem->Minimum;
                    } else {
                        *ppbValue = NULL;
                        *pdwValue = 0;
                    } // if/else:  default value specified
                } else {
                    *ppbValue = (LPBYTE) LocalAlloc( LMEM_FIXED, pInBinaryValue->cbLength );
                    if ( *ppbValue == NULL ) {
                        status = GetLastError();
                        *pdwValue = 0;
                        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetBinaryProperty: error allocating memory for BINARY value in parameter block for property '%1!ls!'.\n", rrvnModifiedNames.PszName() );
                        break;
                    } // if:  error allocating memory
                    CopyMemory( *ppbValue, pInBinaryValue->rgb, pInBinaryValue->cbLength );
                    *pdwValue = pInBinaryValue->cbLength;
                } // if/else:  zero length data
            } // if:  data written successfully and parameter block specified
        } // if:  value changed or zero-length value
    } while ( 0 );

    return status;

} // ClRtlpSetBinaryProperty



DWORD
WINAPI
ClRtlpSetNonPropertyTable(
    IN HANDLE hXsaction,
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    )

/*++

Routine Description:

    Set items that are not in the property table list.

Arguments:

    hXsaction - Local Transaction handle.

    hkeyClusterKey - The opened registry key for this object's parameters.
        If not specified, the property list will only be validated.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyTable - Pointer to the property table to process.

    pInPropertyList - The input buffer.

    cbInPropertyListSize - The input buffer size.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    DWORD                   status = ERROR_SUCCESS;
    PRESUTIL_PROPERTY_ITEM  propertyItem;
    DWORD                   inBufferSize;
    DWORD                   itemCount;
    DWORD                   dataSize;
    CLUSPROP_BUFFER_HELPER  buf;
    PCLUSPROP_PROPERTY_NAME pName;
    BOOL                    bZeroLengthData;
    CRegistryValueName      rvn;

    //
    // If hKeyClusterKey is present then 'normal' functions must be present.
    //
    if ( ( (hkeyClusterKey != NULL) &&
           ((pClusterRegApis->pfnSetValue == NULL) ||
           (pClusterRegApis->pfnCreateKey == NULL) ||
           (pClusterRegApis->pfnOpenKey == NULL) ||
           (pClusterRegApis->pfnCloseKey == NULL)
         )) ||
         ( pPropertyTable == NULL ) ) {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: pClusterRegApis->pfnSetValue, pfnCreateKey, pfnOpenKey, or pfnCloseKey == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    //
    // If hKeyClusterKey and hXsaction are present
    // then 'local' functions must be present.
    //
    if ( ((hkeyClusterKey != NULL) &&
           (hXsaction != NULL )) &&
           ((pClusterRegApis->pfnLocalCreateKey == NULL) ||
           (pClusterRegApis->pfnLocalDeleteValue == NULL)
         ) ) {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: pClusterRegApis->pfnpfnLocalCreateKey or pfnLocalDeleteValue == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    if ( pInPropertyList == NULL ) {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: pInPropertyList == NULL. Returning ERROR_INVALID_DATA\n" );
        return(ERROR_INVALID_DATA);
    }

    buf.pb = (LPBYTE) pInPropertyList;
    inBufferSize = cbInPropertyListSize;

    //
    // Get the number of items in this list
    //
    if ( inBufferSize < sizeof(DWORD) ) {
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    itemCount = buf.pList->nPropertyCount;
    buf.pdw++;

    //
    // Parse the rest of the items in the buffer.
    //
    while ( itemCount-- ) {
        //
        // Verify that the buffer is big enough to contain the
        // property name and a value.
        //
        pName = buf.pName;
        if ( inBufferSize < sizeof(*pName) ) {
            return(ERROR_INSUFFICIENT_BUFFER);
        }
        dataSize = sizeof(*pName) + ALIGN_CLUSPROP( pName->cbLength );
        if ( inBufferSize < dataSize + sizeof(CLUSPROP_VALUE) ) {
            return(ERROR_INSUFFICIENT_BUFFER);
        }

        //
        // Verify that the syntax of the property name is correct.
        //
        if ( pName->Syntax.dw != CLUSPROP_SYNTAX_NAME ) {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: syntax %1!d! not a name syntax.\n", pName->Syntax.dw );
            return(ERROR_INVALID_PARAMETER);
        }

        //
        // Verify that the length is correct for the string.
        //
        if ( pName->cbLength != (lstrlenW( pName->sz ) + 1) * sizeof(WCHAR) ) {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: name is not a valid C string.\n" );
            return(ERROR_INVALID_DATA);
        }

        //
        // Move the buffer pointer to the property value.
        //
        buf.pb += dataSize;
        inBufferSize -= dataSize;

        //
        // Find the property name in the list of known properties.
        //
        propertyItem = pPropertyTable;
        while ( propertyItem->Name != NULL ) {

            if ( lstrcmpiW( pName->sz, propertyItem->Name ) == 0 ) {
                //
                // Verify that the buffer is big enough to contain the value.
                //
                do {
                    dataSize = sizeof(*buf.pValue)
                                + ALIGN_CLUSPROP( buf.pValue->cbLength );
                    if ( inBufferSize < dataSize ) {
                        return(ERROR_INSUFFICIENT_BUFFER);
                    }

                    //
                    // Skip this value.
                    //
                    buf.pb += dataSize;
                    inBufferSize -= dataSize;
                } while ( buf.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK );

                //
                // Skip the endmark.
                //
                dataSize = sizeof( CLUSPROP_SYNTAX );
                if ( inBufferSize < dataSize ) {
                    return(ERROR_INSUFFICIENT_BUFFER);
                }
                buf.pb += dataSize;
                inBufferSize -= dataSize;

                break;

            } else {
                propertyItem++;
            }
        }

        //
        // If no property name was found, just save this item.
        //
        if ( propertyItem->Name == NULL) {
            //
            // Verify that the buffer is big enough to contain the value.
            //
            dataSize = sizeof(*buf.pValue)
                        + ALIGN_CLUSPROP( buf.pValue->cbLength );
            if ( inBufferSize < dataSize + sizeof( CLUSPROP_SYNTAX ) ) {
                return(ERROR_INSUFFICIENT_BUFFER);
            }

            //
            // Verify that the syntax type is LIST_VALUE.
            //
            if ( buf.pSyntax->wType != CLUSPROP_TYPE_LIST_VALUE ) {
                ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: Property '%1!ls!' type CLUSPROP_TYPE_LIST_VALUE (%2!d!) expected, was %3!d!.\n", pName->sz, CLUSPROP_TYPE_LIST_VALUE, buf.pSyntax->wType );
                return(ERROR_INVALID_PARAMETER);
            }

            //
            // If the value is not specified, delete the property.
            //
            bZeroLengthData = ( buf.pValue->cbLength == 0 );
            if ( bZeroLengthData ) {
                
                if ( hkeyClusterKey != NULL ) {
                    PVOID key = NULL;
                    DWORD disposition;

                    // 
                    // Use the wrapper class CRegistryValueName to parse value name to see if it 
                    // contains a backslash.
                    // 
                    status = rvn.ScInit( pName->sz, NULL );
                    if ( status != ERROR_SUCCESS ) {
                        break;
                    }

                    //
                    // If the value resides at a different location, open the key.
                    //
                    if ( rvn.PszKeyName() != NULL ) {
                        status = (*pClusterRegApis->pfnOpenKey)( hkeyClusterKey,
                                                                 rvn.PszKeyName(),
                                                                 KEY_ALL_ACCESS,
                                                                 &key);

                        if ( status != ERROR_SUCCESS ) {
                            break;
                        }
        
                    } else {
                        key = hkeyClusterKey;
                    }

                    if ( hXsaction != NULL ) {
                        status = (*pClusterRegApis->pfnLocalDeleteValue)(
                                            hXsaction,
                                            key,
                                            rvn.PszName() );
                    }
                    else {
                        status = (*pClusterRegApis->pfnDeleteValue)(
                                            key,
                                            rvn.PszName() );
                    }

                    //
                    // If the property doesn't exist in the
                    // cluster database, fix the status.
                    //
                    if ( status == ERROR_FILE_NOT_FOUND ) {
                        status = ERROR_SUCCESS;
                    } // if:  property already doesn't exist

                    //
                    // Close the key if we opened it.
                    //
                    if ( (rvn.PszKeyName() != NULL) &&
                         (key != NULL) ) {
                        (*pClusterRegApis->pfnCloseKey)( key );
                    }

                } // if:  key specified
            } else {
                PVOID key = NULL;
                DWORD disposition;

                if ( hkeyClusterKey != NULL ) {
                    // 
                    // Use the wrapper class CRegistryValueName to parse value name to see if it 
                    // contains a backslash.
                    // 
                    status = rvn.ScInit( pName->sz, NULL );
                    if ( status != ERROR_SUCCESS ) {
                        break;
                    }

                    //
                    // If the value resides at a different location, open the key.
                    //
                    if ( rvn.PszKeyName() != NULL ) {

                        if ( hXsaction != NULL ) {
                            status = (*pClusterRegApis->pfnLocalCreateKey)( hXsaction,
                                                                            hkeyClusterKey,
                                                                            rvn.PszKeyName(),
                                                                            0,
                                                                            KEY_ALL_ACCESS,
                                                                            NULL,
                                                                            &key,
                                                                            &disposition);
                        }
                        else {
                            status = (*pClusterRegApis->pfnCreateKey)( hkeyClusterKey,
                                                                       rvn.PszKeyName(),
                                                                       0,
                                                                       KEY_ALL_ACCESS,
                                                                       NULL,
                                                                       &key,
                                                                       &disposition);
                        }

                        if ( status != ERROR_SUCCESS ) {
                            break;
                        }
        
                    } else {
                        key = hkeyClusterKey;
                    }
                }

                switch ( buf.pSyntax->wFormat ) {
                    case CLUSPROP_FORMAT_DWORD:
                        //
                        // Verify the length of the value.
                        //
                        if ( buf.pDwordValue->cbLength != sizeof(DWORD) ) {
                            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: Property '%1!ls!' length %2!d! not DWORD length.\n", pName->sz, buf.pDwordValue->cbLength );
                            status = ERROR_INVALID_DATA;
                            break;
                        }

                        //
                        // Write the value to the cluster database.
                        //
                        if ( key != NULL ) {
                            if ( hXsaction != NULL ) {
                                status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                               key,
                                                                               rvn.PszName(),
                                                                               REG_DWORD,
                                                                               (CONST BYTE*)&buf.pDwordValue->dw,
                                                                               sizeof(DWORD) );
                            }
                            else {
                                status = (*pClusterRegApis->pfnSetValue)( key,
                                                                          rvn.PszName(),
                                                                          REG_DWORD,
                                                                          (CONST BYTE*)&buf.pDwordValue->dw,
                                                                          sizeof(DWORD) );
                            }
                        }

                        break;

                    case CLUSPROP_FORMAT_LONG:
                        //
                        // Verify the length of the value.
                        //
                        if ( buf.pLongValue->cbLength != sizeof(LONG) ) {
                            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: Property '%1!ls!' length %2!d! not LONG length.\n", pName->sz, buf.pLongValue->cbLength );
                            status = ERROR_INVALID_DATA;
                            break;
                        }

                        //
                        // Write the value to the cluster database.
                        //
                        if ( key != NULL ) {
                            if ( hXsaction != NULL ) {
                                status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                               key,
                                                                               rvn.PszName(),
                                                                               REG_DWORD,
                                                                               (CONST BYTE*)&buf.pLongValue->l,
                                                                               sizeof(LONG) );
                            }
                            else {
                                status = (*pClusterRegApis->pfnSetValue)( key,
                                                                          rvn.PszName(),
                                                                          REG_DWORD,
                                                                          (CONST BYTE*)&buf.pLongValue->l,
                                                                          sizeof(LONG) );
                            }
                        }

                        break;

                    case CLUSPROP_FORMAT_ULARGE_INTEGER:
                    case CLUSPROP_FORMAT_LARGE_INTEGER:
                        //
                        // Write the value to the cluster database.
                        //
                        if ( key != NULL ) {
                            if ( hXsaction ) {
                                status = (*pClusterRegApis->pfnLocalSetValue)(
                                             hXsaction,
                                             key,
                                             rvn.PszName(),
                                             REG_QWORD,
                                             (CONST BYTE*)&buf.pULargeIntegerValue->li.QuadPart,
                                             sizeof(ULARGE_INTEGER));
                            } else {
                                status = (*pClusterRegApis->pfnSetValue)(
                                             key,
                                             rvn.PszName(),
                                             REG_QWORD,
                                             (CONST BYTE*)&buf.pULargeIntegerValue->li.QuadPart,
                                             sizeof(ULARGE_INTEGER));
                            }
                        }

                        break;

                    case CLUSPROP_FORMAT_SZ:
                        //
                        // Verify the length of the value.
                        //
                        if ( buf.pStringValue->cbLength != (lstrlenW( buf.pStringValue->sz ) + 1) * sizeof(WCHAR) ) {
                            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: Property '%1!ls!' length %2!d! doesn't match null-term. length.\n", pName->sz, buf.pStringValue->cbLength );
                            status = ERROR_INVALID_DATA;
                            break;
                        }

                        //
                        // Write the value to the cluster database.
                        //
                        if ( key != NULL ) {
                            if ( hXsaction != NULL ) {
                                status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                               key,
                                                                               rvn.PszName(),
                                                                               REG_SZ,
                                                                               (CONST BYTE*)buf.pStringValue->sz,
                                                                               buf.pStringValue->cbLength );
                            }
                            else {
                                status = (*pClusterRegApis->pfnSetValue)( key,
                                                                          rvn.PszName(),
                                                                          REG_SZ,
                                                                          (CONST BYTE*)buf.pStringValue->sz,
                                                                          buf.pStringValue->cbLength );
                            }
                        }

                        break;


                    case CLUSPROP_FORMAT_EXPAND_SZ:
                        //
                        // Verify the length of the value.
                        //
                        if ( buf.pStringValue->cbLength != (lstrlenW( buf.pStringValue->sz ) + 1) * sizeof(WCHAR) ) {
                            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: Property '%1!ls!' length %2!d! doesn't match null-term. length.\n", pName->sz, buf.pStringValue->cbLength );
                            status = ERROR_INVALID_DATA;
                            break;
                        }

                        //
                        // Write the value to the cluster database.
                        //
                        if ( key != NULL ) {
                            if ( hXsaction != NULL ) {
                                status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                               key,
                                                                               rvn.PszName(),
                                                                               REG_EXPAND_SZ,
                                                                               (CONST BYTE*)buf.pStringValue->sz,
                                                                               buf.pStringValue->cbLength );
                            }
                            else {
                                status = (*pClusterRegApis->pfnSetValue)( key,
                                                                          rvn.PszName(),
                                                                          REG_EXPAND_SZ,
                                                                          (CONST BYTE*)buf.pStringValue->sz,
                                                                          buf.pStringValue->cbLength );
                            }
                        }

                        break;

                    case CLUSPROP_FORMAT_MULTI_SZ:
                        //
                        // Write the value to the cluster database.
                        //
                        if ( key != NULL ) {
                            if ( hXsaction != NULL ) {
                                status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                               key,
                                                                               rvn.PszName(),
                                                                               REG_MULTI_SZ,
                                                                               (CONST BYTE*)buf.pStringValue->sz,
                                                                               buf.pStringValue->cbLength );
                            }
                            else {
                                status = (*pClusterRegApis->pfnSetValue)( key,
                                                                          rvn.PszName(),
                                                                          REG_MULTI_SZ,
                                                                          (CONST BYTE*)buf.pStringValue->sz,
                                                                          buf.pStringValue->cbLength );
                            }
                        }

                        break;

                    case CLUSPROP_FORMAT_BINARY:
                        //
                        // Write the value to the cluster database.
                        //
                        if ( key != NULL ) {
                            if ( hXsaction ) {
                                status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                               key,
                                                                               rvn.PszName(),
                                                                               REG_BINARY,
                                                                               (CONST BYTE*)buf.pBinaryValue->rgb,
                                                                               buf.pStringValue->cbLength );
                            } else {
                                status = (*pClusterRegApis->pfnSetValue)( key,
                                                                          rvn.PszName(),
                                                                          REG_BINARY,
                                                                          (CONST BYTE*)buf.pBinaryValue->rgb,
                                                                          buf.pStringValue->cbLength );
                            }
                        }

                        break;

                    default:
                        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: Property '%1!ls!' unknown format %2!d! specified.\n", pName->sz, buf.pSyntax->wFormat );
                        status = ERROR_INVALID_PARAMETER;
                        break;

                } // switch

                //
                // Close the key if we opened it.
                //
                if ( (rvn.PszKeyName() != NULL) &&
                     (key != NULL) ) {
                    (*pClusterRegApis->pfnCloseKey)( key );
                }

            } // if/else:  zero length data

            //
            // Move the buffer past the value.
            //
            do {
                dataSize = sizeof(*buf.pValue)
                            + ALIGN_CLUSPROP( buf.pValue->cbLength );
                buf.pb += dataSize;
                inBufferSize -= dataSize;
            } while ( buf.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK );
            dataSize = sizeof( CLUSPROP_SYNTAX );
            buf.pb += dataSize;
            inBufferSize -= dataSize;
        }

        if ( status != ERROR_SUCCESS ) {
            break;
        }
    }

    return(status);

} // ClRtlpSetNonPropertyTable



DWORD
WINAPI
ClRtlSetPropertyParameterBlock(
    IN HANDLE hXsaction, 
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE pInParams,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    )

/*++

Routine Description:

Arguments:

    hXsaction - Transaction key used when called from the cluster service.

    hkeyClusterKey - The opened registry key for this object's parameters.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyTable - Pointer to the property table to process.

    pInParams - Parameter block to set.

    pInPropertyList - Full property list.

    cbInPropertyListSize - Size of the input full property list.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameters block to copy pInParams to.  If specified,
        parameters will only be written if they are different between
        the two parameter blocks.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    DWORD                   status = ERROR_SUCCESS;
    PRESUTIL_PROPERTY_ITEM  propertyItem;
    DWORD                   itemCount;
    DWORD                   dataSize;
    PVOID                   key;
    LPWSTR UNALIGNED *      ppszInValue;
    LPWSTR UNALIGNED *      ppszOutValue;
    PBYTE UNALIGNED *       ppbInValue;
    PBYTE UNALIGNED *       ppbOutValue;
    DWORD *                 pdwInValue;
    DWORD *                 pdwOutValue;
    ULARGE_INTEGER *        pullInValue;
    ULARGE_INTEGER *        pullOutValue;
    CRegistryValueName      rvn;

    //
    // If hKeyClusterKey is present then 'normal' functions must be present.
    //
    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis->pfnCreateKey == NULL) ||
         (pClusterRegApis->pfnSetValue == NULL) ||
         (pClusterRegApis->pfnCloseKey == NULL) ||
         (pPropertyTable == NULL) ||
         (pInParams == NULL) ) {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlSetPropertyParameterBlock: hkeyClusterKey, pClusterRegApis->pfnCreateKey, pfnSetValue, or pfnCloseKey == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    //
    // If hXsaction is present then 'local' functions must be present.
    //
    if ( (hXsaction != NULL ) &&
           ((pClusterRegApis->pfnLocalCreateKey == NULL) ||
           (pClusterRegApis->pfnLocalSetValue == NULL) ) ) {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlSetPropertyParameterBlock: pClusterRegApis->pfnLocalCreateKey or pfnLocalDeleteValue == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    //
    // Parse the property table.
    //
    propertyItem = pPropertyTable;
    while ( propertyItem->Name != NULL ) {
        //
        // Make sure we are allowed to set this item.
        //
        if ( propertyItem->Flags & RESUTIL_PROPITEM_READ_ONLY ) {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlSetPropertyParameterBlock: Property '%1!ls!' is non-writable.\n", propertyItem->Name );
            return(ERROR_INVALID_PARAMETER);
        }

        // 
        // Use the wrapper class CRegistryValueName to parse value name to see if it 
        // contains a backslash.
        // 
        status = rvn.ScInit(  propertyItem->Name, propertyItem->KeyName );
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // If the value resides at a different location, create the key.
        //
        if ( rvn.PszKeyName() != NULL ) {

            DWORD disposition;

            if ( hXsaction != NULL ) {
                status = (*pClusterRegApis->pfnLocalCreateKey)( hXsaction,
                                                                hkeyClusterKey,
                                                                rvn.PszKeyName(),
                                                                0,
                                                                KEY_ALL_ACCESS,
                                                                NULL,
                                                                &key,
                                                                &disposition );
            } else {
                status = (*pClusterRegApis->pfnCreateKey)( hkeyClusterKey,
                                                           rvn.PszKeyName(),
                                                           0,
                                                           KEY_ALL_ACCESS,
                                                           NULL,
                                                           &key,
                                                           &disposition );
            }
            
            if ( status != ERROR_SUCCESS ) {
                return(status);
            }
        } else {
            key = hkeyClusterKey;
        }

        switch ( propertyItem->Format ) {
            case CLUSPROP_FORMAT_DWORD:
            case CLUSPROP_FORMAT_LONG:
                pdwInValue = (DWORD *) &pInParams[propertyItem->Offset];
                pdwOutValue = (DWORD *) &pOutParams[propertyItem->Offset];

                //
                // Write the value to the cluster database.
                //
                if ( hXsaction != NULL ) {
                    status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                   key,
                                                                   rvn.PszName(),
                                                                   REG_DWORD,
                                                                   (CONST BYTE*)pdwInValue,
                                                                   sizeof(DWORD) );
                } else {
                    status = (*pClusterRegApis->pfnSetValue)( key,
                                                              rvn.PszName(),
                                                              REG_DWORD,
                                                              (CONST BYTE*)pdwInValue,
                                                              sizeof(DWORD) );
                }

                //
                // Save the value to the output Parameter block.
                //
                if ( (status == ERROR_SUCCESS) &&
                     (pOutParams != NULL) ) {
                    *pdwOutValue = *pdwInValue;
                }
                break;

            case CLUSPROP_FORMAT_ULARGE_INTEGER:
            case CLUSPROP_FORMAT_LARGE_INTEGER:
                pullInValue = (ULARGE_INTEGER *) &pInParams[propertyItem->Offset];
                pullOutValue = (ULARGE_INTEGER *) &pOutParams[propertyItem->Offset];

                //
                // Write the value to the cluster database.
                //
                if ( hXsaction != NULL ) {
                    status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                   key,
                                                                   rvn.PszName(),
                                                                   REG_QWORD,
                                                                   (CONST BYTE*)pullInValue,
                                                                   sizeof(ULARGE_INTEGER) );
                } else {
                    status = (*pClusterRegApis->pfnSetValue)( key,
                                                              rvn.PszName(),
                                                              REG_QWORD,
                                                              (CONST BYTE*)pullInValue,
                                                              sizeof(ULARGE_INTEGER) );
                }

                //
                // Save the value to the output Parameter block.
                //
                if ( (status == ERROR_SUCCESS) && (pOutParams != NULL) ) {
                    pullOutValue->u = pullInValue->u;
                }
                break;

            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
                ppszInValue = (LPWSTR UNALIGNED *) &pInParams[propertyItem->Offset];
                ppszOutValue = (LPWSTR UNALIGNED *) &pOutParams[propertyItem->Offset];

                //
                // If the data changed, write it and save it.
                // Do this even if only the case of the data changed.
                //
                if ( bForceWrite ||
                     (pOutParams == NULL) ||
                     (*ppszOutValue == NULL) ||
                     (lstrcmpW( *ppszInValue, *ppszOutValue ) != 0) ) {

                    //
                    // Write the value to the cluster database.
                    //
                    if ( *ppszInValue != NULL ) {
                        if ( hXsaction != NULL ) {
                            status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                           key,
                                                                           rvn.PszName(),
                                                                           (propertyItem->Format == CLUSPROP_FORMAT_EXPAND_SZ
                                                                                 ? REG_EXPAND_SZ
                                                                                 : REG_SZ),
                                                                           (CONST BYTE*)*ppszInValue,
                                                                           (lstrlenW(*ppszInValue) + 1) * sizeof(WCHAR) );
                        } else {
                            status = (*pClusterRegApis->pfnSetValue)( key,
                                                                      rvn.PszName(),
                                                                      (propertyItem->Format == CLUSPROP_FORMAT_EXPAND_SZ
                                                                            ? REG_EXPAND_SZ
                                                                            : REG_SZ),
                                                                      (CONST BYTE*)*ppszInValue,
                                                                      (lstrlenW(*ppszInValue) + 1) * sizeof(WCHAR) );
                        }
                    }

                    //
                    // Save the value to the output Parameter block.
                    //
                    if ( (status == ERROR_SUCCESS) &&
                         (pOutParams != NULL) ) {
                        if ( *ppszOutValue != NULL ) {
                            LocalFree( *ppszOutValue );
                        }
                        if ( *ppszInValue == NULL ) {
                            *ppszOutValue = NULL;
                        } else {
                            *ppszOutValue = (LPWSTR) LocalAlloc( LMEM_FIXED, (lstrlenW( *ppszInValue )+1) * sizeof(WCHAR) );
                            if ( *ppszOutValue == NULL ) {
                                status = GetLastError();
                                ClRtlDbgPrint(
                                    LOG_CRITICAL,
                                    "ClRtlSetPropertyParameterBlock: error allocating memory for "
                                    "SZ value '%1!ls!' in parameter block for property '%2!ls!'.\n",
                                    *ppszInValue,
                                    propertyItem->Name );
                                break;
                            }
                            lstrcpyW( *ppszOutValue, *ppszInValue );
                        }
                    }
                }
                break;

            case CLUSPROP_FORMAT_MULTI_SZ:
                ppszInValue = (LPWSTR UNALIGNED *) &pInParams[propertyItem->Offset];
                pdwInValue = (DWORD *) &pInParams[propertyItem->Offset+sizeof(LPWSTR*)];
                ppszOutValue = (LPWSTR UNALIGNED *) &pOutParams[propertyItem->Offset];
                pdwOutValue = (DWORD *) &pOutParams[propertyItem->Offset+sizeof(LPWSTR*)];

                //
                // If the data changed, write it and save it.
                //
                if ( bForceWrite ||
                     (pOutParams == NULL) ||
                     (*ppszOutValue == NULL) ||
                     (*pdwInValue != *pdwOutValue) ||
                     (memcmp( *ppszInValue, *ppszOutValue, *pdwInValue ) != 0) ) {

                    //
                    // Write the value to the cluster database.
                    //
                    if ( *ppszInValue != NULL ) {
                        if ( hXsaction != NULL ) {
                            status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                           key,
                                                                           rvn.PszName(),
                                                                           REG_MULTI_SZ,
                                                                           (CONST BYTE*)*ppszInValue,
                                                                           *pdwInValue );
                        } else {
                            status = (*pClusterRegApis->pfnSetValue)( key,
                                                                      rvn.PszName(),
                                                                      REG_MULTI_SZ,
                                                                      (CONST BYTE*)*ppszInValue,
                                                                      *pdwInValue );
                        }
                    }

                    //
                    // Save the value to the output Parameter block.
                    //
                    if ( (status == ERROR_SUCCESS) &&
                         (pOutParams != NULL) ) {
                        if ( *ppszOutValue != NULL ) {
                            LocalFree( *ppszOutValue );
                        }
                        if ( *ppszInValue == NULL ) {
                            *ppszOutValue = NULL;
                        } else {
                            *ppszOutValue = (LPWSTR) LocalAlloc( LMEM_FIXED, *pdwInValue );
                            if ( *ppszOutValue == NULL ) {
                                status = GetLastError();
                                *pdwOutValue = 0;
                                ClRtlDbgPrint(
                                    LOG_CRITICAL,
                                    "ClRtlSetPropertyParameterBlock: error allocating memory for "
                                    "MULTI_SZ value in parameter block for property '%1!ls!'.\n",
                                    propertyItem->Name );
                                break;
                            }
                            CopyMemory( *ppszOutValue, *ppszInValue, *pdwInValue );
                            *pdwOutValue = *pdwInValue;
                        }
                    }
                }
                break;

            case CLUSPROP_FORMAT_BINARY:
                ppbInValue = (PBYTE UNALIGNED *) &pInParams[propertyItem->Offset];
                pdwInValue = (DWORD *) &pInParams[propertyItem->Offset+sizeof(LPWSTR*)];
                ppbOutValue = (PBYTE UNALIGNED *) &pOutParams[propertyItem->Offset];
                pdwOutValue = (DWORD *) &pOutParams[propertyItem->Offset+sizeof(PBYTE*)];

                //
                // If the data changed, write it and save it.
                //
                if ( bForceWrite ||
                     (pOutParams == NULL) ||
                     (*ppbOutValue == NULL) ||
                     (*pdwInValue != *pdwOutValue) ||
                     (memcmp( *ppbInValue, *ppbOutValue, *pdwInValue ) != 0) ) {

                    //
                    // Write the value to the cluster database.
                    //
                    if ( *ppbInValue != NULL ) {
                        if ( hXsaction != NULL ) {
                            status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                           key,
                                                                           rvn.PszName(),
                                                                           REG_BINARY,
                                                                           (CONST BYTE*)*ppbInValue,
                                                                           *pdwInValue );
                        }
                        else {
                            status = (*pClusterRegApis->pfnSetValue)( key,
                                                                      rvn.PszName(),
                                                                      REG_BINARY,
                                                                      (CONST BYTE*)*ppbInValue,
                                                                      *pdwInValue );
                        }
                    }

                    //
                    // Save the value to the output Parameter block.
                    //
                    if ( (status == ERROR_SUCCESS) &&
                         (pOutParams != NULL) ) {
                        if ( *ppbOutValue != NULL ) {
                            LocalFree( *ppbOutValue );
                        }
                        if ( *ppbInValue == NULL ) {
                            *ppbOutValue = NULL;
                        } else {
                            *ppbOutValue = (LPBYTE) LocalAlloc( LMEM_FIXED, *pdwInValue );
                            if ( *ppbOutValue == NULL ) {
                                status = GetLastError();
                                *pdwOutValue = 0;
                                ClRtlDbgPrint( LOG_CRITICAL, "ClRtlSetPropertyParameterBlock: error allocating memory for BINARY value in parameter block for property '%1!ls!'.\n", propertyItem->Name );
                                break;
                            }
                            CopyMemory( *ppbOutValue, *ppbInValue, *pdwInValue );
                            *pdwOutValue = *pdwInValue;
                        }
                    }
                }
                break;

            default:
                ClRtlDbgPrint( LOG_CRITICAL, "ClRtlSetPropertyParameterBlock: Property '%1!ls!' unknown format %2!d! specified.\n", propertyItem->Name, propertyItem->Format );
                status = ERROR_INVALID_PARAMETER;
                break;

        }

        //
        // Close the key if we opened it.
        //
        if ( rvn.PszKeyName() != NULL ) {
            (*pClusterRegApis->pfnCloseKey)( key );
        }

        //
        // If an error occurred processing the property, cleanup and return.
        //
        if ( status != ERROR_SUCCESS ) {
            return(status);
        }

        propertyItem++;

    }

    //
    // Now find any parameters that are not represented in the property
    // table. All of these extra properties will just be set without validation.
    //
    if ( (status == ERROR_SUCCESS) &&
         (pInPropertyList != NULL) ) {
        status = ClRtlpSetNonPropertyTable( hXsaction,
                                            hkeyClusterKey,
                                            pClusterRegApis,
                                            pPropertyTable,
                                            NULL,
                                            pInPropertyList,
                                            cbInPropertyListSize );
    }

    return(status);

} // ClRtlSetPropertyParameterBlock



DWORD
WINAPI
ClRtlpSetPrivatePropertyList(
    IN HANDLE hXsaction,
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    )

/*++

Routine Description:

Arguments:

    hkeyClusterKey - The opened registry key for this resource's parameters.
        If not specified, the property list will only be validated.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pInPropertyList - The input buffer.

    cbInPropertyListSize - The input buffer size.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    DWORD                   status = ERROR_SUCCESS;
    DWORD                   inBufferSize;
    DWORD                   itemCount;
    DWORD                   dataSize;
    DWORD                   valueSize;
    CLUSPROP_BUFFER_HELPER  bufSizeTest;
    CLUSPROP_BUFFER_HELPER  buf;
    PCLUSPROP_PROPERTY_NAME pName;
    BOOL                    bZeroLengthData;
    CRegistryValueName      rvn;

    if ( (hkeyClusterKey != NULL) &&
         ( (pClusterRegApis->pfnSetValue == NULL) ||
           (pClusterRegApis->pfnCreateKey == NULL) ||
           (pClusterRegApis->pfnOpenKey == NULL) ||
           (pClusterRegApis->pfnCloseKey == NULL) ||
           (pClusterRegApis->pfnDeleteValue == NULL)
         ) ) {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPrivatePropertyList: pClusterRegApis->pfnCreateKey, pfnOpenKey, pfnSetValue, pfnCloseKey, or pfnDeleteValue == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }
    if ( pInPropertyList == NULL ) {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPrivatePropertyList: pInPropertyList == NULL. Returning ERROR_INVALID_DATA\n" );
        return(ERROR_INVALID_DATA);
    }

    //
    // If hXsaction is present then 'local' functions must be present.
    //
    if ( (hXsaction != NULL ) &&
         ( (pClusterRegApis->pfnLocalCreateKey == NULL) ||
           (pClusterRegApis->pfnLocalDeleteValue == NULL)
         ) ) {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPrivatePropertyList: pClusterRegApis->pfnLocalCreateKey or pfnLocalDeleteValue == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    buf.pb = (LPBYTE) pInPropertyList;
    inBufferSize = cbInPropertyListSize;

    //
    // Get the number of items in this list
    //
    if ( inBufferSize < sizeof(DWORD) ) {
        return(ERROR_INSUFFICIENT_BUFFER);
    }
    itemCount = buf.pList->nPropertyCount;
    buf.pdw++;

    //
    // Parse the rest of the items in the buffer.
    //
    while ( itemCount-- ) {
        pName = buf.pName;
        if ( inBufferSize < sizeof(*pName) ) {
            return(ERROR_INSUFFICIENT_BUFFER);
        }
        dataSize = sizeof(*pName) + ALIGN_CLUSPROP( pName->cbLength );
        if ( inBufferSize < dataSize + sizeof(CLUSPROP_VALUE) ) {
            return(ERROR_INSUFFICIENT_BUFFER);
        }

        //
        // Verify that the syntax of the property name is correct.
        //
        if ( pName->Syntax.dw != CLUSPROP_SYNTAX_NAME ) {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPrivatePropertyList: syntax %1!d! not a name syntax.\n", pName->Syntax.dw );
            return(ERROR_INVALID_PARAMETER);
        }

        //
        // Verify that the length is correct for the string.
        //
        if ( pName->cbLength != (lstrlenW( pName->sz ) + 1) * sizeof(WCHAR) ) {
            ClRtlDbgPrint( LOG_CRITICAL, "SetPrivatePropertyList: name is not a valid C string.\n" );
            return(ERROR_INVALID_DATA);
        }

        //
        // Move the buffer pointer to the property value.
        //
        buf.pb += dataSize;
        inBufferSize -= dataSize;

        //
        // Verify that the buffer is big enough to contain the value.
        //
        bufSizeTest.pb = buf.pb;
        dataSize = 0;
        do {
            valueSize = sizeof( *bufSizeTest.pValue )
                        + ALIGN_CLUSPROP( bufSizeTest.pValue->cbLength );
            bufSizeTest.pb += valueSize;
            dataSize += valueSize;
        } while ( bufSizeTest.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK );
        dataSize += sizeof( CLUSPROP_SYNTAX );
        if ( inBufferSize < dataSize ) {
            return(ERROR_INSUFFICIENT_BUFFER);
        }

        //
        // Verify that the syntax type is SPECIAL.
        //
        if ( buf.pSyntax->wType != CLUSPROP_TYPE_LIST_VALUE ) {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPrivatePropertyList: Property '%1!ls!' type CLUSPROP_TYPE_LIST_VALUE (%2!d!) expected, was %3!d!.\n", pName->sz, CLUSPROP_TYPE_LIST_VALUE, buf.pSyntax->wType );
            return(ERROR_INVALID_PARAMETER);
        }

        //
        // If the value is not specified, delete the property.
        //
        bZeroLengthData = ( buf.pValue->cbLength == 0 );
        if ( bZeroLengthData ) {
            if ( hkeyClusterKey != NULL ) {
                PVOID key = NULL;

                // 
                // Use the wrapper class CRegistryValueName to parse value name to see if it 
                // contains a backslash.
                // 
                status = rvn.ScInit( pName->sz, NULL );
                if ( status != ERROR_SUCCESS ) {
                    break;
                }

                //
                // If the value resides at a different location, open the key.
                //
                if ( rvn.PszKeyName() != NULL ) {
                    status = (*pClusterRegApis->pfnOpenKey)( hkeyClusterKey,
                                                             rvn.PszKeyName(),
                                                             KEY_ALL_ACCESS,
                                                             &key);

                    if ( status != ERROR_SUCCESS ) {
                        break;
                    }
    
                } else {
                    key = hkeyClusterKey;
                }

                if ( hXsaction != NULL ) {
                    status = (*pClusterRegApis->pfnLocalDeleteValue)(
                                                hXsaction,
                                                key,
                                                rvn.PszName() );
                }
                else {
                    status = (*pClusterRegApis->pfnDeleteValue)(
                                                key,
                                                rvn.PszName() );
                }

                //
                // If the property doesn't exist in the
                // cluster database, fix the status.
                //
                if ( status == ERROR_FILE_NOT_FOUND ) {
                    status = ERROR_SUCCESS;
                } // if:  property already doesn't exist

                //
                // Close the key if we opened it.
                //
                if ( (rvn.PszKeyName() != NULL) &&
                     (key != NULL) ) {
                    (*pClusterRegApis->pfnCloseKey)( key );
                }

            } // if:  key specified
        } else {
            PVOID key = NULL;
            DWORD disposition;

            if ( hkeyClusterKey != NULL ) {
                // 
                // Use the wrapper class CRegistryValueName to parse value name to see if it 
                // contains a backslash.
                // 
                status = rvn.ScInit( pName->sz, NULL );
                if ( status != ERROR_SUCCESS ) {
                    break;
                }

                //
                // If the value resides at a different location, open the key.
                //
                if ( rvn.PszKeyName() != NULL ) {

                    if ( hXsaction != NULL )  {
                        status = (*pClusterRegApis->pfnLocalCreateKey)( 
                                                                   hXsaction,
                                                                   hkeyClusterKey,
                                                                   rvn.PszKeyName(),
                                                                   0,
                                                                   KEY_ALL_ACCESS,
                                                                   NULL,
                                                                   &key,
                                                                   &disposition);

                    }
                    else {
                        status = (*pClusterRegApis->pfnCreateKey)( hkeyClusterKey,
                                                                   rvn.PszKeyName(),
                                                                   0,
                                                                   KEY_ALL_ACCESS,
                                                                   NULL,
                                                                   &key,
                                                                   &disposition);
                    }

                    if ( status != ERROR_SUCCESS ) {
                        break;
                    }
    
                } else {
                    key = hkeyClusterKey;
                }
            }

            //
            // Parse the property and set it in the cluster database
            //
            switch ( buf.pSyntax->wFormat ) {
                case CLUSPROP_FORMAT_DWORD:
                case CLUSPROP_FORMAT_LONG:
                    //
                    // Verify the length of the value.
                    //
                    if ( buf.pDwordValue->cbLength != sizeof(DWORD) ) {
                        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPrivatePropertyList: Property '%1!ls!' length %2!d! not DWORD or LONG length.\n", pName->sz, buf.pDwordValue->cbLength );
                        status = ERROR_INVALID_DATA;
                        break;
                    }

                    // 
                    // Write the value to the cluster database.
                    //
                    if ( key != NULL ) {
                        if ( hXsaction != NULL ) {
                            status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                           key,
                                                                           rvn.PszName(),
                                                                           REG_DWORD,
                                                                           (CONST BYTE*)&buf.pDwordValue->dw,
                                                                           sizeof(DWORD) );
                        }
                        else {
                            status = (*pClusterRegApis->pfnSetValue)( key,
                                                                      rvn.PszName(),
                                                                      REG_DWORD,
                                                                      (CONST BYTE*)&buf.pDwordValue->dw,
                                                                      sizeof(DWORD));
                        }
                    }
                    break;

                case CLUSPROP_FORMAT_ULARGE_INTEGER:
                case CLUSPROP_FORMAT_LARGE_INTEGER:
                    //
                    // Verify the length of the value.
                    //
                    if ( buf.pULargeIntegerValue->cbLength != sizeof(ULARGE_INTEGER) ) {
                        ClRtlDbgPrint(LOG_CRITICAL,
                                      "ClRtlpSetPrivatePropertyList: Property '%1!ls!' length "
                                      "%2!d! not ULARGE_INTEGER or LARGE_INTEGER length.\n",
                                      pName->sz,
                                      buf.pULargeIntegerValue->cbLength );
                        status = ERROR_INVALID_DATA;
                        break;
                    }

                    // 
                    // Write the value to the cluster database.
                    //
                    if ( key != NULL ) {
                        if ( hXsaction != NULL ) {
                            status = (*pClusterRegApis->pfnLocalSetValue)(
                                         hXsaction,
                                         key,
                                         rvn.PszName(),
                                         REG_QWORD,
                                         (CONST BYTE*)&buf.pULargeIntegerValue->li.QuadPart,
                                         sizeof(ULARGE_INTEGER) );
                        }
                        else {
                            status = (*pClusterRegApis->pfnSetValue)(
                                         key,
                                         rvn.PszName(),
                                         REG_QWORD,
                                         (CONST BYTE*)&buf.pULargeIntegerValue->li.QuadPart,
                                         sizeof(ULARGE_INTEGER));
                        }
                    }
                    break;

               case CLUSPROP_FORMAT_SZ:
               case CLUSPROP_FORMAT_EXPAND_SZ:
                    //
                    // Verify the length of the value.
                    //
                    if ( buf.pStringValue->cbLength != (lstrlenW( buf.pStringValue->sz ) + 1) * sizeof(WCHAR) ) {
                        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPrivatePropertyList: Property '%1!ls!' length %2!d! doesn't match null-term. length.\n", pName->sz, buf.pStringValue->cbLength );
                        status = ERROR_INVALID_DATA;
                        break;
                    }

                    //
                    // Write the value to the cluster database.
                    //
                    if ( key != NULL ) {
                        if ( hXsaction != NULL ) {
                            status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                           key,
                                                                           rvn.PszName(),
                                                                           (buf.pSyntax->wFormat == CLUSPROP_FORMAT_EXPAND_SZ
                                                                                ? REG_EXPAND_SZ
                                                                                : REG_SZ),
                                                                           (CONST BYTE*)buf.pStringValue->sz,
                                                                           buf.pStringValue->cbLength);
                        }
                        else {
                            status = (*pClusterRegApis->pfnSetValue)( key,
                                                                      rvn.PszName(),
                                                                      (buf.pSyntax->wFormat == CLUSPROP_FORMAT_EXPAND_SZ
                                                                            ? REG_EXPAND_SZ
                                                                            : REG_SZ),
                                                                      (CONST BYTE*)buf.pStringValue->sz,
                                                                      buf.pStringValue->cbLength);
                        }
                    }
                    break;

                case CLUSPROP_FORMAT_MULTI_SZ:
                    //
                    // Write the value to the cluster database.
                    //
                    if ( key != NULL ) {
                        if ( hXsaction != NULL ) {
                            status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                           key,
                                                                           rvn.PszName(),
                                                                           REG_MULTI_SZ,
                                                                           (CONST BYTE*)buf.pStringValue->sz,
                                                                           buf.pStringValue->cbLength );
                        }
                        else {
                            status = (*pClusterRegApis->pfnSetValue)( key,
                                                                      rvn.PszName(),
                                                                      REG_MULTI_SZ,
                                                                      (CONST BYTE*)buf.pStringValue->sz,
                                                                      buf.pStringValue->cbLength );
                        }
                    }
                    break;

                case CLUSPROP_FORMAT_BINARY:
                    //
                    // Write the value to the cluster database.
                    //
                    if ( key != NULL ) {
                        if ( hXsaction != NULL ) {
                            status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                           key,
                                                                           rvn.PszName(),
                                                                           REG_BINARY,
                                                                           (CONST BYTE*)buf.pBinaryValue->rgb,
                                                                           buf.pBinaryValue->cbLength );
                        }
                        else {
                            status = (*pClusterRegApis->pfnSetValue)( key,
                                                                      rvn.PszName(),
                                                                      REG_BINARY,
                                                                      (CONST BYTE*)buf.pBinaryValue->rgb,
                                                                      buf.pBinaryValue->cbLength );
                        }
                    }
                    break;

                default:
                    status = ERROR_INVALID_PARAMETER; // not tested

            } // switch

            //
            // Close the key if we opened it.
            //
            if ( (rvn.PszKeyName() != NULL) &&
                 (key != NULL) ) {
                (*pClusterRegApis->pfnCloseKey)( key );
            }

        } // if/else:  zero length data

        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // Move the buffer past the value.
        //
        buf.pb += dataSize;
        inBufferSize -= dataSize;

    }

    return(status);

} // ClRtlpSetPrivatePropertyList



DWORD
WINAPI
ClRtlpFindSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue,
    IN BOOL bReturnExpandedValue
    )

/*++

Routine Description:

    Finds the specified string property in the Property List buffer pointed at
    by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pszPropertyValue - the matching string value found.

    bReturnExpandedValue - TRUE = return expanded value if one is present,
        FALSE = return the first value.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - 

    ERROR_FILE_NOT_FOUND - 

    ERROR_NOT_ENOUGH_MEMORY - 

    A Win32 error code on failure.

--*/

{
    CLUSPROP_BUFFER_HELPER  props;
    LPWSTR                  valueData;
    LPWSTR                  listValueData;
    DWORD                   listByteLength;
    DWORD                   itemCount;
    DWORD                   byteCount;

    props.pb = (LPBYTE) pPropertyList;
    itemCount = *(props.pdw++);
    cbPropertyListSize -= sizeof(DWORD);

    while ( itemCount-- &&
            ((LONG)cbPropertyListSize > 0) ) {
        //
        // If we found the specified property, validate the entry and return
        // the value to the caller.
        //
        if ( (props.pName->Syntax.dw == CLUSPROP_SYNTAX_NAME) &&
             (lstrcmpiW( props.pName->sz, pszPropertyName ) == 0) ) {
            //
            // Calculate the size of the name and move to the value.
            //
            byteCount = ALIGN_CLUSPROP(props.pName->cbLength);
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Make sure this is a string property.
            //
            if ( (props.pStringValue->Syntax.dw != CLUSPROP_SYNTAX_LIST_VALUE_SZ) &&
                 (props.pStringValue->Syntax.dw != CLUSPROP_SYNTAX_LIST_VALUE_EXPAND_SZ) ) {
                ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpFindSzProperty: Property '%1!ls!' syntax (%2!d!, %3!d!) not proper list string syntax.\n", pszPropertyName, props.pSyntax->wType, props.pSyntax->wFormat );
                return(ERROR_INVALID_DATA);
            }

            //
            // If caller wants the value, allocate a buffer for it
            // and copy the value in.
            //
            if ( pszPropertyValue != NULL ) {
                //
                // If caller wants the expanded value, look at any
                // additional values in the value list to see if one
                // was returned.
                //
                listValueData = props.pStringValue->sz;
                listByteLength = props.pStringValue->cbLength;
                if ( bReturnExpandedValue ) {
                    //
                    // Skip past values in the value list looking for
                    // an expanded string value.
                    //
                    while ( (props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) &&
                            (cbPropertyListSize > 0) ) {
                        byteCount = sizeof(*props.pValue) + ALIGN_CLUSPROP(listByteLength);
                        cbPropertyListSize -= byteCount;
                        props.pb += byteCount;
                        if ( props.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_EXPANDED_SZ ) {
                            listValueData = props.pStringValue->sz;
                            listByteLength = props.pStringValue->cbLength;
                            break;
                        }
                    }
                }

                //
                // Allocate a buffer for the string value and
                // copy the value from the property list.
                //
                valueData = (LPWSTR) LocalAlloc( LMEM_FIXED, listByteLength );
                if ( valueData == NULL ) {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }
                CopyMemory( valueData, listValueData, listByteLength );
                *pszPropertyValue = valueData;
            }

            //
            // We found the property so return success.
            //
            return(ERROR_SUCCESS);

        } else {
            //
            // Skip the name (value header + size of data).
            //
            byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
            cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Skip it's value list (one or more values + endmark).
            //
            while ( (props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) &&
                    (cbPropertyListSize > 0) ) {
                byteCount = sizeof(*props.pValue) + ALIGN_CLUSPROP(props.pValue->cbLength);
                cbPropertyListSize -= byteCount;
                props.pb += byteCount;
            }
            cbPropertyListSize -= sizeof(*props.pSyntax);
            props.pb += sizeof(*props.pSyntax);
        }
    }

    return(ERROR_FILE_NOT_FOUND);

} // ClRtlpFindSzProperty



DWORD
WINAPI
ClRtlFindDwordProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPDWORD pdwPropertyValue
    )

/*++

Routine Description:

    Finds the specified DWORD property in the Property List buffer pointed at
    by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pdwPropertyValue - the matching DWORD value found.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - 

    ERROR_FILE_NOT_FOUND - 

    A Win32 error code on failure.

--*/

{
    CLUSPROP_BUFFER_HELPER  props;
    LPWSTR                  valueData;
    DWORD                   itemCount;
    DWORD                   byteCount;

    props.pb = (LPBYTE) pPropertyList;
    itemCount = *(props.pdw++);
    cbPropertyListSize -= sizeof(DWORD);

    while ( itemCount-- &&
            ((LONG)cbPropertyListSize > 0) ) {
        //
        // If we found the specified property, validate the entry and return
        // the value to the caller.
        //
        if ( (props.pName->Syntax.dw == CLUSPROP_SYNTAX_NAME) &&
             (lstrcmpiW( props.pName->sz, pszPropertyName ) == 0) ) {
            //
            // Calculate the size of the name and move to the value.
            //
            byteCount = ALIGN_CLUSPROP(props.pName->cbLength);
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Make sure this is a dword property.
            //
            if ( props.pDwordValue->Syntax.dw != CLUSPROP_SYNTAX_LIST_VALUE_DWORD )  {
                ClRtlDbgPrint( LOG_CRITICAL, "ClRtlFindDwordProperty: Property '%1!ls!' syntax (%2!d!, %3!d!) not proper list DWORD syntax.\n", pszPropertyName, props.pSyntax->wType, props.pSyntax->wFormat );
                return(ERROR_INVALID_DATA);
            }

            //
            // If caller wants the value, allocate a buffer for it.
            //
            if ( pdwPropertyValue ) {
                *pdwPropertyValue = props.pDwordValue->dw;
            }

            //
            // We found the property so return success.
            //
            return(ERROR_SUCCESS);

        } else {
            //
            // Skip the name (value header + size of data).
            //
            byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
            cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Skip it's value list and endmark.
            //
            while ( (props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) &&
                    (cbPropertyListSize > 0) ) {
                byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
                cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
                props.pb += sizeof(*props.pValue) + byteCount;
            }
            cbPropertyListSize -= sizeof(*props.pSyntax);
            props.pb += sizeof(*props.pSyntax);
        }
    }

    return(ERROR_FILE_NOT_FOUND);

} // ClRtlFindDwordProperty

DWORD
WINAPI
ClRtlFindLongProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPLONG plPropertyValue
    )
/*++

Routine Description:

    Finds the specified dword in the Value List buffer pointed at by Buffer.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    plPropertyValue - the matching long value found.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - 

    ERROR_FILE_NOT_FOUND - 

    A Win32 error code on failure.

--*/
{
    CLUSPROP_BUFFER_HELPER  props;
    LPWSTR                  valueData;
    DWORD                   itemCount;
    DWORD                   byteCount;

    props.pb = (LPBYTE) pPropertyList;
    itemCount = *(props.pdw++);
    cbPropertyListSize -= sizeof(DWORD);

    while ( itemCount-- &&
            (cbPropertyListSize > 0) ) {
        //
        // If we found the specified property, validate the entry and return
        // the value to the caller.
        //
        if ( (props.pName->Syntax.dw == CLUSPROP_SYNTAX_NAME) &&
             (lstrcmpiW( props.pName->sz, pszPropertyName ) == 0) ) {
            //
            // Calculate the size of the name and move to the value.
            //
            byteCount = ALIGN_CLUSPROP(props.pName->cbLength);
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Make sure this is a long property.
            //
            if ( props.pLongValue->Syntax.dw != CLUSPROP_SYNTAX_LIST_VALUE_DWORD )  {
                ClRtlDbgPrint( LOG_CRITICAL, "ClRtlFindLongProperty: Property '%1!ls!' syntax (%2!d!, %3!d!) not proper list LONG syntax.\n", pszPropertyName, props.pSyntax->wType, props.pSyntax->wFormat );
                return(ERROR_INVALID_DATA);
            }

            //
            // If caller wants the value, allocate a buffer for it.
            //
            if ( plPropertyValue) {
                *plPropertyValue = props.pLongValue->l;
            }

            //
            // We found the property so return success.
            //
            return(ERROR_SUCCESS);

        } else {
            //
            // Skip the name (value header + size of data).
            //
            byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
            cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Skip it's value list and endmark.
            //
            while ( (props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) &&
                    (cbPropertyListSize > 0) ) {
                byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
                cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
                props.pb += sizeof(*props.pValue) + byteCount;
            }
            cbPropertyListSize -= sizeof(*props.pSyntax);
            props.pb += sizeof(*props.pSyntax);
        }
    }

    return(ERROR_FILE_NOT_FOUND);

} // ClRtlFindLongProperty


DWORD
WINAPI
ClRtlFindULargeIntegerProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT PULARGE_INTEGER pullPropertyValue
    )

/*++

Routine Description:

    Finds the specified ULARGE_INTEGER property in the Property List buffer
    pointed at by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pullPropertyValue - the matching ULARGE_INTEGER value found.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - 

    ERROR_FILE_NOT_FOUND - 

    A Win32 error code on failure.

--*/

{
    CLUSPROP_BUFFER_HELPER  props;
    LPWSTR                  valueData;
    DWORD                   itemCount;
    DWORD                   byteCount;

    props.pb = (LPBYTE) pPropertyList;
    itemCount = *(props.pdw++);
    cbPropertyListSize -= sizeof(DWORD);

    while ( itemCount-- &&
            ((LONG)cbPropertyListSize > 0) ) {
        //
        // If we found the specified property, validate the entry and return
        // the value to the caller.
        //
        if ( (props.pName->Syntax.dw == CLUSPROP_SYNTAX_NAME) &&
             (lstrcmpiW( props.pName->sz, pszPropertyName ) == 0) ) {
            //
            // Calculate the size of the name and move to the value.
            //
            byteCount = ALIGN_CLUSPROP(props.pName->cbLength);
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Make sure this is a LARGE INT property.
            //
            if ( props.pULargeIntegerValue->Syntax.dw != CLUSPROP_SYNTAX_LIST_VALUE_LARGE_INTEGER )  {
                ClRtlDbgPrint(LOG_CRITICAL,
                              "ClRtlFindULargeIntegerProperty: Property '%1!ls!' syntax "
                              "(%2!d!, %3!d!) not proper list ULARGE_INTEGER syntax.\n",
                              pszPropertyName,
                              props.pSyntax->wType,
                              props.pSyntax->wFormat );
                return(ERROR_INVALID_DATA);
            }

            //
            // If caller wants the value, allocate a buffer for it.
            //
            if ( pullPropertyValue ) {
                pullPropertyValue->QuadPart = props.pULargeIntegerValue->li.QuadPart;
            }

            //
            // We found the property so return success.
            //
            return(ERROR_SUCCESS);

        } else {
            //
            // Skip the name (value header + size of data).
            //
            byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
            cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Skip it's value list and endmark.
            //
            while ( (props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) &&
                    (cbPropertyListSize > 0) )
            {
                byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
                cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
                props.pb += sizeof(*props.pValue) + byteCount;
            }
            cbPropertyListSize -= sizeof(*props.pSyntax);
            props.pb += sizeof(*props.pSyntax);
        }
    }

    return(ERROR_FILE_NOT_FOUND);

} // ClRtlFindULargeIntegerProperty


DWORD
WINAPI
ClRtlFindLargeIntegerProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT PLARGE_INTEGER pllPropertyValue
    )

/*++

Routine Description:

    Finds the specified LARGE_INTEGER property in the Property List buffer
    pointed at by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pllPropertyValue - the matching ULARGE_INTEGER value found.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - 

    ERROR_FILE_NOT_FOUND - 

    A Win32 error code on failure.

--*/

{
    CLUSPROP_BUFFER_HELPER  props;
    LPWSTR                  valueData;
    DWORD                   itemCount;
    DWORD                   byteCount;

    props.pb = (LPBYTE) pPropertyList;
    itemCount = *(props.pdw++);
    cbPropertyListSize -= sizeof(DWORD);

    while ( itemCount-- &&
            ((LONG)cbPropertyListSize > 0) ) {
        //
        // If we found the specified property, validate the entry and return
        // the value to the caller.
        //
        if ( (props.pName->Syntax.dw == CLUSPROP_SYNTAX_NAME) &&
             (lstrcmpiW( props.pName->sz, pszPropertyName ) == 0) ) {
            //
            // Calculate the size of the name and move to the value.
            //
            byteCount = ALIGN_CLUSPROP(props.pName->cbLength);
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Make sure this is a large int property.
            //
            if ( props.pLargeIntegerValue->Syntax.dw != CLUSPROP_SYNTAX_LIST_VALUE_LARGE_INTEGER )  {
                ClRtlDbgPrint(LOG_CRITICAL,
                              "ClRtlFindLargeIntegerProperty: Property '%1!ls!' syntax "
                              "(%2!d!, %3!d!) not proper list ULARGE_INTEGER syntax.\n",
                              pszPropertyName,
                              props.pSyntax->wType,
                              props.pSyntax->wFormat );
                return(ERROR_INVALID_DATA);
            }

            //
            // If caller wants the value, allocate a buffer for it.
            //
            if ( pllPropertyValue ) {
                pllPropertyValue->QuadPart = props.pLargeIntegerValue->li.QuadPart;
            }

            //
            // We found the property so return success.
            //
            return(ERROR_SUCCESS);

        } else {
            //
            // Skip the name (value header + size of data).
            //
            byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
            cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Skip it's value list and endmark.
            //
            while ( (props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) &&
                    (cbPropertyListSize > 0) )
            {
                byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
                cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
                props.pb += sizeof(*props.pValue) + byteCount;
            }
            cbPropertyListSize -= sizeof(*props.pSyntax);
            props.pb += sizeof(*props.pSyntax);
        }
    }

    return(ERROR_FILE_NOT_FOUND);

} // ClRtlFindLargeIntegerProperty


DWORD
WINAPI
ClRtlFindBinaryProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPBYTE * pbPropertyValue,
    OUT LPDWORD pcbPropertyValueSize
    )

/*++

Routine Description:

    Finds the specified binary property in the Property List buffer pointed at
    by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pbPropertyValue - the matching binary value found.

    pcbPropertyValueSize - the length of the matching binary value found.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - 

    ERROR_NOT_ENOUGH_MEMORY - 

    ERROR_FILE_NOT_FOUND - 

    A Win32 error code on failure.

--*/

{
    CLUSPROP_BUFFER_HELPER  props;
    PBYTE                   valueData;
    DWORD                   itemCount;
    DWORD                   byteCount;

    props.pb = (LPBYTE) pPropertyList;
    itemCount = *(props.pdw++);
    cbPropertyListSize -= sizeof(DWORD);

    while ( itemCount-- &&
            ((LONG)cbPropertyListSize > 0) ) {
        //
        // If we found the specified property, validate the entry and return
        // the value to the caller.
        //
        if ( (props.pName->Syntax.dw == CLUSPROP_SYNTAX_NAME) &&
             (lstrcmpiW( props.pName->sz, pszPropertyName ) == 0) ) {
            //
            // Calculate the size of the name and move to the value.
            //
            byteCount = ALIGN_CLUSPROP(props.pName->cbLength);
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Make sure this is a binary property.
            //
            if ( props.pStringValue->Syntax.dw != CLUSPROP_SYNTAX_LIST_VALUE_BINARY ) {
                ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpFindBinaryProperty: Property '%1!ls!' syntax (%2!d!, %3!d!) not proper list binary syntax.\n", pszPropertyName, props.pSyntax->wType, props.pSyntax->wFormat );
                return(ERROR_INVALID_DATA);
            }

            //
            // If caller wants the value, allocate a buffer for it.
            //
            if ( pbPropertyValue ) {
                valueData = (PBYTE) LocalAlloc( LMEM_FIXED, props.pBinaryValue->cbLength );
                if ( !valueData ) {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }
                CopyMemory( valueData, props.pBinaryValue->rgb, props.pBinaryValue->cbLength );
                *pbPropertyValue = valueData;
            }

            //
            // If caller wants the value size
            //
            if ( pcbPropertyValueSize ) {
                *pcbPropertyValueSize = props.pBinaryValue->cbLength;
            }

            //
            // We found the property so return success.
            //
            return(ERROR_SUCCESS);

        } else {
            //
            // Skip the name (value header + size of data).
            //
            byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
            cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Skip it's value list and endmark.
            //
            while ( (props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) &&
                    (cbPropertyListSize > 0) ) {
                byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
                cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
                props.pb += sizeof(*props.pValue) + byteCount;
            }
            cbPropertyListSize -= sizeof(*props.pSyntax);
            props.pb += sizeof(*props.pSyntax);
        }
    }

    return(ERROR_FILE_NOT_FOUND);

} // ClRtlFindBinaryProperty



DWORD
WINAPI
ClRtlFindMultiSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue,
    OUT LPDWORD pcbPropertyValueSize
    )

/*++

Routine Description:

    Finds the specified multiple string property in the Property List buffer
    pointed at by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pszPropertyValue - the matching multiple string value found.

    pcbPropertyValueSize - the length of the matching multiple string value found.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - 

    ERROR_NOT_ENOUGH_MEMORY - 

    ERROR_FILE_NOT_FOUND - 

    A Win32 error code on failure.

--*/

{
    CLUSPROP_BUFFER_HELPER  props;
    LPWSTR                  valueData;
    DWORD                   itemCount;
    DWORD                   byteCount;

    props.pb = (LPBYTE) pPropertyList;
    itemCount = *(props.pdw++);
    cbPropertyListSize -= sizeof(DWORD);

    while ( itemCount-- &&
            ((LONG)cbPropertyListSize > 0) ) {
        //
        // If we found the specified property, validate the entry and return
        // the value to the caller.
        //
        if ( (props.pName->Syntax.dw == CLUSPROP_SYNTAX_NAME) &&
             (lstrcmpiW( props.pName->sz, pszPropertyName ) == 0) ) {
            //
            // Calculate the size of the name and move to the value.
            //
            byteCount = ALIGN_CLUSPROP(props.pName->cbLength);
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Make sure this is a multi-sz property.
            //
            if ( props.pStringValue->Syntax.dw != CLUSPROP_SYNTAX_LIST_VALUE_MULTI_SZ ) {
                ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpFindMultiSzProperty: Property '%1!ls!' syntax (%2!d!, %3!d!) not proper list MultiSz syntax.\n", pszPropertyName, props.pSyntax->wType, props.pSyntax->wFormat );
                return(ERROR_INVALID_DATA);
            }

            //
            // If caller wants the value, allocate a buffer for it.
            //
            if ( pszPropertyValue ) {
                valueData = (LPWSTR) LocalAlloc( LMEM_FIXED, props.pMultiSzValue->cbLength );
                if ( !valueData ) {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }
                CopyMemory( valueData, props.pBinaryValue->rgb, props.pMultiSzValue->cbLength );
                *pszPropertyValue = valueData;
            }

            //
            // If caller wants the value size
            //
            if ( pcbPropertyValueSize ) {
                *pcbPropertyValueSize = props.pMultiSzValue->cbLength;
            }

            //
            // We found the property so return success.
            //
            return(ERROR_SUCCESS);

        } else {
            //
            // Skip the name (value header + size of data).
            //
            byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
            cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Skip it's value list and endmark.
            //
            while ( (props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) &&
                    (cbPropertyListSize > 0) ) {
                byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
                cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
                props.pb += sizeof(*props.pValue) + byteCount;
            }
            cbPropertyListSize -= sizeof(*props.pSyntax);
            props.pb += sizeof(*props.pSyntax);
        }
    }

    return(ERROR_FILE_NOT_FOUND);

} // ClRtlFindMultiSzProperty



DWORD
WINAPI
ClRtlGetBinaryValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    OUT LPBYTE * ppbOutValue,
    OUT LPDWORD pcbOutValueSize,
    IN const PCLUSTER_REG_APIS pClusterRegApis
    )

/*++

Routine Description:

    Queries a REG_BINARY or REG_MULTI_SZ value out of the cluster
    database and allocates the necessary storage for it.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the value is stored

    pszValueName - Supplies the name of the value.

    ppbOutValue - Supplies the address of a pointer in which to return the value.

    pcbOutValueSize - Supplies the address of a DWORD in which to return the
        size of the value.

    pfnQueryValue - Address of QueryValue function.

Return Value:

    ERROR_SUCCESS - The value was read successfully.

    ERROR_BAD_ARGUMENTS - 

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory for the value.

    Win32 error code - The operation failed.

--*/

{
    LPBYTE value = NULL;
    DWORD valueSize;
    DWORD valueType;
    DWORD status;

    PVOID key = NULL;
    CRegistryValueName rvn;

    //
    // Initialize the output parameters.
    //
    *ppbOutValue = NULL;
    *pcbOutValueSize = 0;

    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis == NULL) ||
         (pClusterRegApis->pfnQueryValue == NULL) ) {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetBinaryValue: hkeyClusterKey, pClusterRegApis, or pClusterRegApis->pfnQueryValue == NULL. Returning ERROR_BAD_ARGUMENTS.\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    // 
    // Use the wrapper class CRegistryValueName to parse value name to see if it 
    // contains a backslash.
    // 
    status = rvn.ScInit( pszValueName, NULL );
    if ( status != ERROR_SUCCESS )
    {
       return status;
    }

    //
    // If the value resides at a different location, open the key.
    //
    if ( rvn.PszKeyName() != NULL ) {
        if ( (pClusterRegApis->pfnOpenKey == NULL) ||
             (pClusterRegApis->pfnCloseKey == NULL) ) {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetBinaryValue: pClusterRegApis->pfnOpenKey or pfnCloseKey == NULL. Returning ERROR_BAD_ARGUMENTS.\n" );
            return(ERROR_BAD_ARGUMENTS);
        }

        status = (*pClusterRegApis->pfnOpenKey)( hkeyClusterKey,
                                                 rvn.PszKeyName(),
                                                 KEY_READ,
                                                 &key);
        
    } else {
        key = hkeyClusterKey;
    }

    //
    // Dummy do-while loop to avoid gotos.
    //
    do
    {
        //
        // Get the size of the value so we know how much to allocate.
        //
        valueSize = 0;
        status = (*pClusterRegApis->pfnQueryValue)( key,
                                                    rvn.PszName(),
                                                    &valueType,
                                                    NULL,
                                                    &valueSize );
        if ( (status != ERROR_SUCCESS) &&
             (status != ERROR_MORE_DATA) ) {
            break;
        }

        //if the size is zero, just return
        if (valueSize == 0)
        {
            break;
        }
        //
        // Allocate a buffer to read the value into.
        //
        value = (LPBYTE) LocalAlloc( LMEM_FIXED, valueSize );
        if ( value == NULL ) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Read the value from the cluster database.
        //
        status = (*pClusterRegApis->pfnQueryValue)( key,
                                                    pszValueName,
                                                    &valueType,
                                                    (LPBYTE)value,
                                                    &valueSize );

        if ( status != ERROR_SUCCESS ) {
            LocalFree( value );
        } else {
            *ppbOutValue = value;
            *pcbOutValueSize = valueSize;
        }

    }
    while (FALSE);

    //
    // Close the key if we opened it.
    //
    if ( (rvn.PszKeyName() != NULL) &&
         (key != NULL) ) {
        (*pClusterRegApis->pfnCloseKey)( key );
    }

    return(status);

} // ClRtlGetBinaryValue



LPWSTR
WINAPI
ClRtlGetSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN const PCLUSTER_REG_APIS pClusterRegApis
    )

/*++

Routine Description:

    Queries a REG_SZ or REG_EXPAND_SZ value out of the cluster database
    and allocates the necessary storage for it.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the value is stored

    pszValueName - Supplies the name of the value.

    pfnQueryValue - Address of QueryValue function.

Return Value:

    A pointer to a buffer containing the value if successful.

    NULL if unsuccessful.  Call GetLastError() to get more details.

--*/

{
    PWSTR value;
    DWORD valueSize;
    DWORD valueType;
    DWORD status;
    PVOID key = NULL;
    CRegistryValueName rvn;

    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis == NULL) ||
         (pClusterRegApis->pfnQueryValue == NULL) ) {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetSzValue: hkeyClusterKey, pClusterRegApis, or pClusterRegApis->pfnQueryValue == NULL. Returning ERROR_BAD_ARGUMENTS.\n" );
        SetLastError(ERROR_BAD_ARGUMENTS);
        return(NULL);
    }

    // 
    // Use the wrapper class CRegistryValueName to parse value name to see if it 
    // contains a backslash.
    // 
    status = rvn.ScInit( pszValueName, NULL );
    if ( status != ERROR_SUCCESS )
    {
        SetLastError(status);
        return(NULL);
    }
    //
    // If the value resides at a different location, open the key.
    //
    if ( rvn.PszKeyName() != NULL ) {
        if ( (pClusterRegApis->pfnOpenKey == NULL) ||
             (pClusterRegApis->pfnCloseKey == NULL) ) {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetSzValue: pClusterRegApis->pfnOpenKey or pfnCloseKey == NULL. Returning ERROR_BAD_ARGUMENTS.\n" );
            SetLastError(ERROR_BAD_ARGUMENTS);
            return(NULL);
        }

        status = (*pClusterRegApis->pfnOpenKey)( hkeyClusterKey,
                                                 rvn.PszKeyName(),
                                                 KEY_READ,
                                                 &key);
        
    } else {
        key = hkeyClusterKey;
    }

    //
    // Dummy do-while loop to avoid gotos.
    //
    do
    {
        //
        // Get the size of the value so we know how much to allocate.
        //
        valueSize = 0;
        status = (*pClusterRegApis->pfnQueryValue)( key,
                                                    rvn.PszName(),
                                                    &valueType,
                                                    NULL,
                                                    &valueSize );
        if ( (status != ERROR_SUCCESS) &&
             (status != ERROR_MORE_DATA) ) {
            SetLastError( status );
            value = NULL;
            break;
        }

        //
        // Add on the size of the null terminator.
        //
        valueSize += sizeof(UNICODE_NULL);

        //
        // Allocate a buffer to read the string into.
        //
        value = (PWSTR) LocalAlloc( LMEM_FIXED, valueSize );
        if ( value == NULL ) {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            value = NULL;
            break;
        }

        //
        // Read the value from the cluster database.
        //
        status = (*pClusterRegApis->pfnQueryValue)( key,
                                                    rvn.PszName(),
                                                    &valueType,
                                                    (LPBYTE)value,
                                                    &valueSize );
        if ( status != ERROR_SUCCESS ) {
            LocalFree( value );
            value = NULL;
        } else if ( (valueType != REG_SZ) &&
                    (valueType != REG_EXPAND_SZ) &&
                    (valueType != REG_MULTI_SZ) ) {
            status = ERROR_INVALID_PARAMETER;
            LocalFree( value );
            SetLastError( status );
            value = NULL;
        }

    }
    while (FALSE);

    //
    // Close the key if we opened it.
    //
    if ( (rvn.PszKeyName() != NULL) &&
         (key != NULL) ) {
        (*pClusterRegApis->pfnCloseKey)( key );
    }

    return(value);

} // ClRtlGetSzValue



DWORD
WINAPI
ClRtlDupParameterBlock(
    OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    )

/*++

Routine Description:

    Deallocates any buffers allocated for a parameter block that are
    different than the buffers used for the input parameter block.

Arguments:

    pOutParams - Parameter block to return.

    pInParams - Reference parameter block.

    pPropertyTable - Pointer to the property table to process.

Return Value:

    ERROR_SUCCESS - Parameter block duplicated successfully.

--*/

{
    DWORD                   status = ERROR_SUCCESS;
    PRESUTIL_PROPERTY_ITEM  propertyItem = pPropertyTable;
    LPWSTR UNALIGNED *      ppszInValue;
    DWORD *                 pdwInValue;
    ULARGE_INTEGER *        pullInValue;
    LPWSTR UNALIGNED *      ppszOutValue;
    DWORD *                 pdwOutValue;
    ULARGE_INTEGER *        pullOutValue;

    while ( propertyItem->Name != NULL ) {
        switch ( propertyItem->Format ) {
            case CLUSPROP_FORMAT_DWORD:
            case CLUSPROP_FORMAT_LONG:
                pdwInValue = (DWORD *) &pInParams[propertyItem->Offset];
                pdwOutValue = (DWORD *) &pOutParams[propertyItem->Offset];
                *pdwOutValue = *pdwInValue;
                break;

            case CLUSPROP_FORMAT_ULARGE_INTEGER:
            case CLUSPROP_FORMAT_LARGE_INTEGER:
                pullInValue = (ULARGE_INTEGER *) &pInParams[propertyItem->Offset];
                pullOutValue = (ULARGE_INTEGER *) &pOutParams[propertyItem->Offset];
                pullOutValue->u = pullInValue->u;
                break;

            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
                ppszInValue = (LPWSTR UNALIGNED *) &pInParams[propertyItem->Offset];
                ppszOutValue = (LPWSTR UNALIGNED *) &pOutParams[propertyItem->Offset];
                if ( *ppszInValue == NULL ) {
                    if ( propertyItem->lpDefault != NULL ) {
                        *ppszOutValue = (LPWSTR) LocalAlloc(
                                                     LMEM_FIXED,
                                                     (lstrlenW( (LPCWSTR) propertyItem->lpDefault ) + 1) * sizeof(WCHAR)
                                                     );
                        if ( *ppszOutValue == NULL ) {
                            status = GetLastError();
                        } else {
                            lstrcpyW( *ppszOutValue, (LPCWSTR) propertyItem->lpDefault );
                        }
                    } else {
                        *ppszOutValue = NULL;
                    }
                } else {
                    *ppszOutValue = (LPWSTR) LocalAlloc( LMEM_FIXED, (lstrlenW( *ppszInValue ) + 1) * sizeof(WCHAR) );
                    if ( *ppszOutValue == NULL ) {
                        status = GetLastError();
                    } else {
                        lstrcpyW( *ppszOutValue, *ppszInValue );
                    }
                }
                break;

            case CLUSPROP_FORMAT_MULTI_SZ:
            case CLUSPROP_FORMAT_BINARY:
                ppszInValue = (LPWSTR UNALIGNED *) &pInParams[propertyItem->Offset];
                pdwInValue = (DWORD *) &pInParams[propertyItem->Offset + sizeof(LPCWSTR)];
                ppszOutValue = (LPWSTR UNALIGNED *) &pOutParams[propertyItem->Offset];
                pdwOutValue = (DWORD *) &pOutParams[propertyItem->Offset + sizeof(LPWSTR)];
                if ( *ppszInValue == NULL ) {
                    if ( propertyItem->lpDefault != NULL ) {
                        *ppszOutValue = (LPWSTR) LocalAlloc( LMEM_FIXED, propertyItem->Minimum );
                        if ( *ppszOutValue == NULL ) {
                            status = GetLastError();
                            *pdwOutValue = 0;
                        } else {
                            *pdwOutValue = propertyItem->Minimum;
                            CopyMemory( *ppszOutValue, (const PVOID) propertyItem->lpDefault, *pdwOutValue );
                        }
                    } else {
                        *ppszOutValue = NULL;
                        *pdwOutValue = 0;
                    }
                } else {
                    *ppszOutValue = (LPWSTR) LocalAlloc( LMEM_FIXED, *pdwInValue );
                    if ( *ppszOutValue == NULL ) {
                        status = GetLastError();
                        *pdwOutValue = 0;
                    } else {
                        CopyMemory( *ppszOutValue, *ppszInValue, *pdwInValue );
                        *pdwOutValue = *pdwInValue;
                    }
                }
                break;
        }
        propertyItem++;
    }

    //
    // If an error occurred, make sure we don't leak memory.
    //
    if ( status != ERROR_SUCCESS ) {
        ClRtlFreeParameterBlock( pOutParams, pInParams, pPropertyTable );
    }

    return(status);

} // ClRtlDupParameterBlock



void
WINAPI
ClRtlFreeParameterBlock(
    IN OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    )

/*++

Routine Description:

    Deallocates any buffers allocated for a parameter block that are
    different than the buffers used for the input parameter block.

Arguments:

    pOutParams - Parameter block to free.

    pInParams - Reference parameter block.

    pPropertyTable - Pointer to the property table to process.

Return Value:

    None.

--*/

{
    PRESUTIL_PROPERTY_ITEM  propertyItem = pPropertyTable;
    LPCWSTR UNALIGNED *     ppszInValue;
    LPWSTR UNALIGNED *      ppszOutValue;

    while ( propertyItem->Name != NULL ) {
        switch ( propertyItem->Format ) {
            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
            case CLUSPROP_FORMAT_MULTI_SZ:
            case CLUSPROP_FORMAT_BINARY:
                ppszInValue = (LPCWSTR UNALIGNED *) &pInParams[propertyItem->Offset];
                ppszOutValue = (LPWSTR UNALIGNED *) &pOutParams[propertyItem->Offset];

                if ( (pInParams == NULL) || (*ppszInValue != *ppszOutValue) ) {
                    LocalFree( *ppszOutValue );
                }
                break;
        }
        propertyItem++;
    }

} // ClRtlFreeParameterBlock



DWORD
WINAPI
ClRtlMarshallPropertyTable(
    IN PRESUTIL_PROPERTY_ITEM    pPropertyTable,
    IN OUT  DWORD                dwSize,
    IN OUT  LPBYTE               pBuffer,
    OUT     DWORD                *Required
    )
/*++

Routine Description

    Rohit (rjain) : It marshalls the pPropertyTable into a buffer so that the
    buffer can be passed as an argument to the NmUpdatePerformFixups2 handler

    This function assumes that the value field in all the elements of the 
    table is 0.

Arguments
    pPropertyTable - This table is converted to buffer

    dwSize         - size in bytes of the pbuffer supplied 

    pbuffer        - byte array into which pPropertyTable is copied

    Required       - number of bytes required

Return Value
    returns 
        ERROR_SUCCESS on success, 
        ERROR_MORE_DATA if the size of pbuffer is insufficient

++*/
    
{
    DWORD                   dwPosition=sizeof(DWORD);
    PRESUTIL_PROPERTY_ITEM  pPropertyItem=pPropertyTable;
    BOOL                    copying = TRUE;
    DWORD                   items=0;
    DWORD                   dwNameLength;
    DWORD                   dwKeyLength;
    DWORD                   status=ERROR_SUCCESS;

    *Required=sizeof(DWORD); // first DWORD will contain the number of items in PropertyTable
    while(pPropertyItem->Name != NULL)
    {
        items++;
        dwNameLength=(lstrlenW(pPropertyItem->Name)+1)*sizeof(WCHAR);
        if(pPropertyItem->KeyName==NULL)
            dwKeyLength=0;
        else
            dwKeyLength=(lstrlenW(pPropertyItem->KeyName)+1)*sizeof(WCHAR);
        *Required+=(dwNameLength+dwKeyLength+8*sizeof(DWORD));

        // if pbufer is smaller than needed, copying is turned off
        // and only the required size is calculated
        if ((copying && (dwSize < *Required)))
            copying=FALSE;

        if(copying)
        {

            // copy length of name and then the name itself

            CopyMemory(pBuffer+dwPosition,&dwNameLength,sizeof(DWORD));
            dwPosition+=(sizeof(DWORD));

            CopyMemory(pBuffer+dwPosition,pPropertyItem->Name,dwNameLength);
            dwPosition+=dwNameLength;

            //copy length of keyname and then the keyname itself

            CopyMemory(pBuffer+dwPosition,&dwKeyLength,sizeof(DWORD));
            dwPosition+=(sizeof(DWORD));
            if(dwKeyLength!=0)
            {
                CopyMemory(pBuffer+dwPosition,pPropertyItem->KeyName,dwKeyLength);
                dwPosition+=dwKeyLength;
            }
            //now copy remaining fields
            CopyMemory(pBuffer+dwPosition,&(pPropertyItem->Format),sizeof(DWORD));
            dwPosition+=(sizeof(DWORD));

            // ISSUE-2000/11/21-charlwi
            // this needs to be fixed for Large Int properties since they
            // don't store their values in Default, Minimum, and Maximum

            //IMP: the default value is always assumed to be a DWORD. This is
            // because the values for properties in PropertyTable are stored 
            // in a seperate parameter list. See ClRtlSetPropertyTable
            //
            CopyMemory(pBuffer+dwPosition,&(pPropertyItem->Default),sizeof(DWORD));
            dwPosition+=(sizeof(DWORD));
        
            CopyMemory(pBuffer+dwPosition,&(pPropertyItem->Minimum),sizeof(DWORD));
            dwPosition+=(sizeof(DWORD));

            CopyMemory(pBuffer+dwPosition,&(pPropertyItem->Maximum),sizeof(DWORD));
            dwPosition+=(sizeof(DWORD));

            CopyMemory(pBuffer+dwPosition,&(pPropertyItem->Flags),sizeof(DWORD));
            dwPosition+=(sizeof(DWORD));

            CopyMemory(pBuffer+dwPosition,&(pPropertyItem->Offset),sizeof(DWORD));
            dwPosition+=(sizeof(DWORD));
        }
        //
        // Advance to the next property.
        //
        pPropertyItem++;
    }
    if(copying)
    {
        CopyMemory(pBuffer,&items,sizeof(DWORD));
        status=ERROR_SUCCESS;
     }
    else
        status=ERROR_MORE_DATA;
    return status;

} // MarshallPropertyTable



DWORD
WINAPI
ClRtlUnmarshallPropertyTable(
    IN OUT PRESUTIL_PROPERTY_ITEM   *ppPropertyTable,
    IN LPBYTE                       pBuffer
    )

/*++

Routine Description
    Rohit (rjain) : It unmarshalls the pBuffer into a RESUTIL_PROPERTY_ITEM table
   
Arguments
    pPropertyTable - This is the resulting table

    pbuffer        - marshalled byte array 
Return Value
    returns 
        ERROR_SUCCESS on success, 
        Win32 error on error
++*/        
{
    PRESUTIL_PROPERTY_ITEM          propertyItem;
    DWORD                           items;
    DWORD                           dwPosition=sizeof(DWORD);
    DWORD                           dwLength;
    DWORD                           i;
    DWORD                           status=ERROR_SUCCESS;

    if((pBuffer==NULL) ||(ppPropertyTable==NULL))
    {
        ClRtlDbgPrint( LOG_CRITICAL, "[ClRtl] Uncopy PropertyTable: Bad Argumnets\r\n");
        return ERROR_BAD_ARGUMENTS;
    }

    CopyMemory(&items,pBuffer,sizeof(DWORD));
    *ppPropertyTable=(PRESUTIL_PROPERTY_ITEM)LocalAlloc(LMEM_FIXED,(items+1)*sizeof(RESUTIL_PROPERTY_ITEM));
    if(*ppPropertyTable == NULL)
    {
        status=GetLastError();
        goto FnExit;
    }
    propertyItem=*ppPropertyTable;
    for(i=0; i<items; i++)
    {

        CopyMemory(&dwLength,pBuffer+dwPosition,sizeof(DWORD));
        dwPosition+=sizeof(DWORD);
        propertyItem->Name = NULL;
        propertyItem->Name=(LPWSTR)LocalAlloc(LMEM_FIXED,dwLength);
        if(propertyItem->Name == NULL)
        {
            status=GetLastError();
            goto FnExit;
        }
        CopyMemory(propertyItem->Name,pBuffer+dwPosition,dwLength);
        dwPosition+=dwLength;

        CopyMemory(&dwLength,pBuffer+dwPosition,sizeof(DWORD));
        dwPosition+=sizeof(DWORD);
        propertyItem->KeyName=NULL;
        if (dwLength!=0)
        {
            propertyItem->KeyName=(LPWSTR)LocalAlloc(LMEM_FIXED,dwLength);
            if(propertyItem->KeyName == NULL)
            {
                status=GetLastError();
                goto FnExit;
            }
            CopyMemory(propertyItem->KeyName,pBuffer+dwPosition,dwLength);
            dwPosition+=dwLength;
        }
        //now rest of the fields - all DWORDS
        CopyMemory(&(propertyItem->Format),pBuffer+dwPosition,sizeof(DWORD));
        dwPosition+=(sizeof(DWORD));

        // ISSUE-2000/11/21-charlwi
        // this needs to be fixed for Large Int properties since they don't
        // store their values in Default, Minimum, and Maximum
        
        // IMP: the default value is always passed as a  DWORD. This is
        // because the values for properties in PropertyTable are stored 
        // in a seperate parameter list so the value here won't be used.
        // See ClRtlSetPropertyTable
        //

        CopyMemory(&(propertyItem->Default),pBuffer+dwPosition,sizeof(DWORD));
        dwPosition+=(sizeof(DWORD));
        
        CopyMemory(&(propertyItem->Minimum),pBuffer+dwPosition,sizeof(DWORD));
        dwPosition+=(sizeof(DWORD));

        CopyMemory(&(propertyItem->Maximum),pBuffer+dwPosition,sizeof(DWORD));
        dwPosition+=(sizeof(DWORD));

        CopyMemory(&(propertyItem->Flags),  pBuffer+dwPosition,sizeof(DWORD));
        dwPosition+=(sizeof(DWORD));

        CopyMemory(&(propertyItem->Offset), pBuffer+dwPosition,sizeof(DWORD));
        dwPosition+=(sizeof(DWORD));

        propertyItem++;
    }

   // the last entry is marked NULL to indicate the end of table
      propertyItem->Name=NULL;
    FnExit:
        return status;

} // UnmarshallPropertyTable



LPWSTR
WINAPI
ClRtlExpandEnvironmentStrings(
    IN LPCWSTR pszSrc
    )

/*++

Routine Description:

    Expands environment strings and returns an allocated buffer containing
    the result.

Arguments:

    pszSrc - Source string to expand.

Return Value:

    A pointer to a buffer containing the value if successful.

    NULL if unsuccessful.  Call GetLastError() to get more details.

--*/

{
    DWORD   status;
    DWORD   cchDst = 0;
    LPWSTR  pszDst = NULL;

    //
    // Get the required length of the output string.
    //
    cchDst = ExpandEnvironmentStrings( pszSrc, NULL, 0 );
    if ( cchDst == 0 ) {
        status = GetLastError();
    } else {
        //
        // Allocate a buffer for the expanded string.
        //
        pszDst = (LPWSTR) LocalAlloc( LMEM_FIXED, cchDst * sizeof(WCHAR) );
        if ( pszDst == NULL ) {
            status = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            //
            // Get the expanded string.
            //
            cchDst = ExpandEnvironmentStrings( pszSrc, pszDst, cchDst );
            if ( cchDst == 0 ) {
                status = GetLastError();
                LocalFree( pszDst );
                pszDst = NULL;
            } else {
                status = ERROR_SUCCESS;
            }
        }
    }

    if ( status != ERROR_SUCCESS ) {
        SetLastError( status );
    }
    return(pszDst);

} // ClRtlExpandEnvironmentStrings



DWORD
WINAPI
ClRtlGetPropertyFormatSize(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pnPropertyCount
    )

/*++

Routine Description:

    Get the total number of bytes required for this property item format.

Arguments:

    pPropertyTableItem - Supplies the property table item for the property
        format whose size is to be returned.

    pcbOutPropertyListSize - Supplies the size of the output buffer
        required to add this property to a property list.

    pnPropertyCount - The count of properties is incremented.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_INVALID_PARAMETER - 

    A Win32 error code on failure.

--*/

{
    WORD    formatType;
    DWORD   valueLength;
    DWORD   nameLength;
    PCLUSPROP_SYNTAX propSyntax;

    //
    // We will return a name, value pair.
    // each of which must be aligned.
    //
    // Get the format type.
    //propSyntax = (PCLUSPROP_SYNTAX) &pPropertyTableItem->Format;
    //formatType = propSyntax->wFormat;

    nameLength = sizeof(CLUSPROP_PROPERTY_NAME)
                    + ((wcslen( pPropertyTableItem->Name ) + 1) * sizeof(WCHAR))
                    + sizeof(CLUSPROP_SYNTAX); // for endmark

    nameLength = ALIGN_CLUSPROP( nameLength );
    valueLength = ALIGN_CLUSPROP( sizeof(CLUSPROP_WORD) );
    *pcbOutPropertyListSize += (valueLength + nameLength);
    *pnPropertyCount += 1;

    return(ERROR_SUCCESS);

} // ClRtlGetPropertyFormatSize



DWORD
WINAPI
ClRtlGetPropertyFormat(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    IN OUT PVOID * pOutPropertyBuffer,
    IN OUT LPDWORD pcbOutPropertyBufferSize
    )

/*++

Routine Description:

    Get the total number of bytes required for this property item format.

Arguments:

    pPropertyTableItem - Supplies the property table item for the property
        format whose size is to be returned.

    pcbOutPropertyBuffer - Supplies the size of the output buffer
        required to add this property to a property list.

    pcbPropertyBufferSize - The size 

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_INVALID_PARAMETER - 

    A Win32 error code on failure.

--*/

{
    WORD    formatType;
    DWORD   valueLength;
    DWORD   nameLength;
    DWORD   bytesReturned;
    PCLUSPROP_SYNTAX propSyntax;
    CLUSPROP_BUFFER_HELPER  props;

    props.pb = (LPBYTE) *pOutPropertyBuffer;
    //
    // We will return a name, value pair.
    // each of which must be aligned.
    //
    // Get the format type.
    propSyntax = (PCLUSPROP_SYNTAX) &pPropertyTableItem->Format;
    formatType = propSyntax->wFormat;

    //
    // Copy the property name, which includes its syntax and length.
    //
    nameLength = (wcslen( pPropertyTableItem->Name ) + 1) * sizeof(WCHAR);
    props.pName->Syntax.dw = CLUSPROP_SYNTAX_NAME;
    props.pName->cbLength = nameLength;
    wcscpy( props.pName->sz, pPropertyTableItem->Name );
    bytesReturned = sizeof(*props.pName) + ALIGN_CLUSPROP( nameLength );
    *pcbOutPropertyBufferSize -= bytesReturned;
    props.pb += bytesReturned;

    //
    // Copy the property value, syntax, length, and ENDMARK
    //
    props.pWordValue->Syntax.wFormat = CLUSPROP_FORMAT_WORD;
    props.pWordValue->Syntax.wType = CLUSPROP_TYPE_LIST_VALUE;
    props.pName->cbLength = sizeof(WORD);
    props.pWordValue->w = formatType;
    bytesReturned = sizeof(*props.pWordValue) + sizeof(CLUSPROP_SYNTAX);
    props.pb += sizeof(*props.pWordValue);
    props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
    props.pb += sizeof(CLUSPROP_SYNTAX);
    bytesReturned = sizeof(*props.pWordValue) + sizeof(CLUSPROP_SYNTAX);
    *pcbOutPropertyBufferSize -= bytesReturned;

    *pOutPropertyBuffer = props.pb;

    return(ERROR_SUCCESS);

} // ClRtlGetPropertyFormat



DWORD
WINAPI
ClRtlGetPropertyFormats(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pOutPropertyFormatList,
    IN DWORD cbOutPropertyFormatListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Gets the 'known' property formats for a given object - given its
    property table.

Arguments:

    pPropertyTable - Pointer to the property table to process.

    pOutPropertyList - Supplies the output buffer.

    cbOutPropertyListSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pOutPropertyList.

    pcbRequired - The required number of bytes if pOutPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    A Win32 error code on failure.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    DWORD           itemCount = 0;
    DWORD           totalBufferLength = 0;
    PVOID           outBuffer = pOutPropertyFormatList;
    DWORD           bufferLength = cbOutPropertyFormatListSize;
    PRESUTIL_PROPERTY_ITEM  property;

    *pcbBytesReturned = 0;
    *pcbRequired = 0;

    //
    // Clear the output buffer
    //
    if ( pOutPropertyFormatList != NULL ) {
        ZeroMemory( pOutPropertyFormatList, cbOutPropertyFormatListSize );
    }

    //
    // Get the size of all properties for this object.
    //
    property = pPropertyTable;
    while ( property->Name != NULL ) {
        status = ClRtlGetPropertyFormatSize( 
                                       property,
                                       &totalBufferLength,
                                       &itemCount );

        if ( status != ERROR_SUCCESS ) {
            break;
        }
        property++;
    }


    //
    // Continue only if the operations so far have been successful.
    //
    if ( status == ERROR_SUCCESS ) {
        //
        // Count for item count at front of return data and endmark.
        //
        totalBufferLength += sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX);

        //
        // Verify the size of all the properties
        //
        if ( totalBufferLength > cbOutPropertyFormatListSize ) {
            *pcbRequired = totalBufferLength;
            totalBufferLength = 0;
            if ( pOutPropertyFormatList == NULL ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        } else {
            *(LPDWORD)outBuffer = itemCount;
            outBuffer = (PVOID)( (PUCHAR)outBuffer + sizeof(itemCount) );
            bufferLength -= sizeof(itemCount);

            //
            // Now fetch all of the property Formats.
            //
            property = pPropertyTable;
            while ( property->Name != NULL ) {
                status = ClRtlGetPropertyFormat( 
                                           property,
                                           &outBuffer,
                                           &itemCount );

                if ( status != ERROR_SUCCESS ) {
                    break;
                }
                property++;
            }

            // Don't forget the ENDMARK
            *(LPDWORD)outBuffer = CLUSPROP_SYNTAX_ENDMARK;

            if ( (status != ERROR_SUCCESS) &&
                 (status != ERROR_MORE_DATA) ) {
                totalBufferLength = 0;
            }
        }

        *pcbBytesReturned = totalBufferLength;
    }

    return(status);

} // ClRtlGetPropertyFormats
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\vercheck.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      VerCheck.cpp
//
//  Abstract:
//      Contains the implementation of the ClRtlIsVersionCheckingDisabled()
//      function that checks if the cluster version checking has been disabled
//      on a particular computer or not.
//
//  Author:
//      Vijayendra Vasu (VVasu) 11-NOV-2000
//
//  Revision History:
//      None.
//
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include files
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <malloc.h>
#include "clusudef.h"
#include "clusrtl.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//	ClRtlIsVersionCheckingDisabled()
//
//	Routine Description:
//		Checks if cluster version checking has been disabled on a particular
//      computer.
//
//	Arguments:
//      const WCHAR * pcszNodeNameIn
//          Name of the node on which the test for the version checking state
//          is to be performed. If NULL, this function checks if cluster
//          version checking in disabled on the local node.
//
//      BOOL *  pfVerCheckDisabledOut
//          Pointer to the boolean variable that will be set to TRUE if
//          version checking is disabled on pcszNodeNameIn and FALSE otherwise.
//
//	Return Value:
//      ERROR_SUCCESS
//          If all went well.
//
//      Other Win32 error codes
//          In case of error
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ClRtlIsVersionCheckingDisabled(
      const WCHAR * pcszNodeNameIn
    , BOOL *        pfVerCheckDisabledOut
    )
{
    DWORD       dwError = ERROR_SUCCESS;
    HKEY        hRemoteRegistry = NULL;
    HKEY        hClusSvcParamsKey = NULL;
    WCHAR *     pszTempString = NULL;

    do
    {
        HKEY    hParentKey = HKEY_LOCAL_MACHINE;
        DWORD   dwVersionCheck = 0;
        DWORD   dwType;
        DWORD   dwSize;

        // Validate parameter.
        if ( pfVerCheckDisabledOut == NULL )
        {
            dwError = ERROR_INVALID_PARAMETER;
            break;
        } // if: the output parameter is invalid

        // Initialize output.
        *pfVerCheckDisabledOut = FALSE;

        // Connect to the remote registry, if required.
        if ( pcszNodeNameIn != NULL )
        {
            const WCHAR *   pcszDoubleBackslashes = L"\\\\";
            DWORD           cchComputerNameSize = wcslen( pcszNodeNameIn ) + 1;
            DWORD           cchPrefixLen = wcslen( pcszDoubleBackslashes );

            // Allocate space for and prefix the computer name with '\\'
            pszTempString = reinterpret_cast< WCHAR * >( malloc( ( cchPrefixLen + cchComputerNameSize ) * sizeof( *pszTempString ) ) );
            if ( pszTempString == NULL )
            {
                dwError = ERROR_OUTOFMEMORY;
                break;
            } // if: memory allocation failed

            wcsncpy( pszTempString, pcszDoubleBackslashes, cchPrefixLen );
            wcsncpy( pszTempString + cchPrefixLen, pcszNodeNameIn, cchComputerNameSize );

            // Open the registry on the remote computer.
            dwError = RegConnectRegistry( pszTempString, HKEY_LOCAL_MACHINE, &hRemoteRegistry );
            if ( dwError != ERROR_SUCCESS )
            {
                break;
            } // if: RegConnectRegistry() has failed

            hParentKey = hRemoteRegistry;
        } // if: a remote computer needs to be contacted.

        // Open the cluster service parameters registry key.
        dwError = RegOpenKeyEx(
              hParentKey
            , CLUSREG_KEYNAME_CLUSSVC_PARAMETERS
            , 0
            , KEY_QUERY_VALUE
            , &hClusSvcParamsKey
            );

        if ( dwError != ERROR_SUCCESS )
        {
            if ( dwError == ERROR_FILE_NOT_FOUND )
            {
                // This is ok - absence of the value indicates that the cluster service 
                // does not exist on the target computer.
                dwError = ERROR_SUCCESS;
            } // if: RegOpenKeyEx did not find the key

            break;
        } // if: RegOpenKeyEx() has failed

        // Read the required registry value
        dwSize = sizeof( dwVersionCheck );
        dwError = RegQueryValueEx(
              hClusSvcParamsKey
            , CLUSREG_NAME_SVC_PARAM_NOVER_CHECK
            , 0
            , &dwType
            , reinterpret_cast< BYTE * >( &dwVersionCheck )
            , &dwSize
            );

        if ( dwError == ERROR_FILE_NOT_FOUND )
        {
            // This is ok - absence of the value indicates that version checking is not disabled.
            dwVersionCheck = 0;
            dwError = ERROR_SUCCESS;
        } // if: RegQueryValueEx did not find the value
        else if ( dwError != ERROR_SUCCESS )
        {
            break;
        } // else if: RegQueryValueEx() has failed

        *pfVerCheckDisabledOut = ( dwVersionCheck == 0 ) ? FALSE : TRUE;
    }
    while( false ); // dummy do-while loop to avoid gotos

    //
    // Free acquired resources
    //

    if ( hRemoteRegistry != NULL )
    {
        RegCloseKey( hRemoteRegistry );
    } // if: we had opened the remote registry

    if ( hClusSvcParamsKey != NULL )
    {
        RegCloseKey( hClusSvcParamsKey );
    } // if: we had opened the cluster service parameters registry key

    // Free the allocated temporary string. (note, free( NULL ) is valid)
    free( pszTempString );
    
    return dwError;
} //*** ClRtlIsVersionCheckingDisabled()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\security.c ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    Security.c

Abstract:

    This module contains common security routines for
    NT Clusters.

Author:

    John Vert (jvert) 12-Mar-1996

--*/

#include "clusrtlp.h"
#include "api_rpc.h"
#include <aclapi.h>
#include <accctrl.h>
#include <malloc.h>

//
// Use this SD to adjust access to tokens so that the cluster
// service can access and adjust privileges.
//
// This is initialized in ClRtlBuildClusterServiceSecurityDescriptor()
// and freed in ClRtlFreeClusterServiceSecurityDescriptor( ).
//
PSECURITY_DESCRIPTOR g_pClusterSecurityDescriptor = NULL;

//
// local defines
//
#define FREE_IF_NOT_NULL( _ptr, _func ) \
    if (( _ptr ) != NULL ) {            \
        _func( _ptr );                  \
    }

LONG
MapSAToRpcSA (
    IN LPSECURITY_ATTRIBUTES lpSA,
    OUT PRPC_SECURITY_ATTRIBUTES lpRpcSA
    )

/*++

Routine Description:

    Maps a SECURITY_ATTRIBUTES structure to a RPC_SECURITY_ATTRIBUTES
    structure by converting the SECURITY_DESCRIPTOR to a form where it can
    be marshalled/unmarshalled.

Arguments:

    lpSA - Supplies a pointer to the SECURITY_ATTRIBUTES structure to be
        converted.

    lpRpcSA - Supplies a pointer to the converted RPC_SECURITY_ATTRIBUTES
        structure.  The caller should free (using RtlFreeHeap) the field
        lpSecurityDescriptor when its finished using it.

Return Value:

    LONG - Returns ERROR_SUCCESS if the SECURITY_ATTRIBUTES is
        succesfully mapped.

--*/

{
    LONG    Error;

    ASSERT( lpSA != NULL );
    ASSERT( lpRpcSA != NULL );

    //
    // Map the SECURITY_DESCRIPTOR to a RPC_SECURITY_DESCRIPTOR.
    //
    lpRpcSA->RpcSecurityDescriptor.lpSecurityDescriptor = NULL;

    if( lpSA->lpSecurityDescriptor != NULL ) {
        Error = MapSDToRpcSD(
                    lpSA->lpSecurityDescriptor,
                    &lpRpcSA->RpcSecurityDescriptor
                    );
    } else {
        lpRpcSA->RpcSecurityDescriptor.cbInSecurityDescriptor = 0;
        lpRpcSA->RpcSecurityDescriptor.cbOutSecurityDescriptor = 0;
        Error = ERROR_SUCCESS;
    }

    if( Error == ERROR_SUCCESS ) {

        //
        //
        // The supplied SECURITY_DESCRIPTOR was successfully converted
        // to self relative format so assign the remaining fields.
        //

        lpRpcSA->nLength = lpSA->nLength;

        lpRpcSA->bInheritHandle = ( BOOLEAN ) lpSA->bInheritHandle;
    }

    return Error;
}

LONG
MapSDToRpcSD (
    IN  PSECURITY_DESCRIPTOR lpSD,
    IN OUT PRPC_SECURITY_DESCRIPTOR lpRpcSD
    )

/*++

Routine Description:

    Maps a SECURITY_DESCRIPTOR to a RPC_SECURITY_DESCRIPTOR by converting
    it to a form where it can be marshalled/unmarshalled.

Arguments:

    lpSD - Supplies a pointer to the SECURITY_DESCRIPTOR
        structure to be converted.

    lpRpcSD - Supplies a pointer to the converted RPC_SECURITY_DESCRIPTOR
        structure. Memory for the security descriptor is allocated if
        not provided. The caller must take care of freeing up the memory
        if necessary.

Return Value:

    LONG - Returns ERROR_SUCCESS if the SECURITY_DESCRIPTOR is
        succesfully mapped.

--*/

{
    DWORD   cbLen;


    ASSERT( lpSD != NULL );
    ASSERT( lpRpcSD != NULL );

    if( RtlValidSecurityDescriptor( lpSD )) {

        cbLen = RtlLengthSecurityDescriptor( lpSD );
        CL_ASSERT( cbLen > 0 );

        //
        //  If we're not provided a buffer for the security descriptor,
        //  allocate it.
        //
        if ( !lpRpcSD->lpSecurityDescriptor ) {

            //
            // Allocate space for the converted SECURITY_DESCRIPTOR.
            //
            lpRpcSD->lpSecurityDescriptor =
                 ( PBYTE ) RtlAllocateHeap(
                                RtlProcessHeap( ), 0,
                                cbLen
                                );

            //
            // If the memory allocation failed, return.
            //
            if( lpRpcSD->lpSecurityDescriptor == NULL ) {
                return ERROR_OUTOFMEMORY;
            }

            lpRpcSD->cbInSecurityDescriptor = cbLen;

        } else {

            //
            //  Make sure that the buffer provided is big enough
            //
            if ( lpRpcSD->cbInSecurityDescriptor < cbLen ) {
                return ERROR_OUTOFMEMORY;
            }
        }

        //
        //  Set the size of the transmittable buffer
        //
        lpRpcSD->cbOutSecurityDescriptor = cbLen;

        //
        // Convert the supplied SECURITY_DESCRIPTOR to self relative form.
        //

        return RtlNtStatusToDosError(
            RtlMakeSelfRelativeSD(
                        lpSD,
                        lpRpcSD->lpSecurityDescriptor,
                        &lpRpcSD->cbInSecurityDescriptor
                        )
                    );
    } else {

        //
        // The supplied SECURITY_DESCRIPTOR is invalid.
        //

        return ERROR_INVALID_PARAMETER;
    }
}

DWORD
ClRtlSetObjSecurityInfo(
    IN HANDLE           hObject,
    IN SE_OBJECT_TYPE   SeObjType,
    IN DWORD            dwAdminMask,
    IN DWORD            dwOwnerMask,
    IN DWORD            dwEveryOneMask
    )
/*++

Routine Description:

    Sets the proper security on the cluster object(registry root/cluster files
    directory).

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    DWORD                       Status;
    PACL                        pAcl = NULL;
    DWORD                       cbDaclSize;
    PACCESS_ALLOWED_ACE         pAce;
    PSID                        pAdminSid = NULL;
    PSID                        pOwnerSid = NULL;
    PSID                        pEveryoneSid = NULL;
    PULONG                      pSubAuthority;
    SID_IDENTIFIER_AUTHORITY    SidIdentifierNtAuth = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    siaCreator = SECURITY_CREATOR_SID_AUTHORITY;
    DWORD AceIndex = 0;

    //
    // Create the local Administrators group SID.
    //
    pAdminSid = LocalAlloc(LMEM_FIXED, GetSidLengthRequired( 2 ));
    if (pAdminSid == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }
    if (!InitializeSid(pAdminSid, &SidIdentifierNtAuth, 2)) {
        Status = GetLastError();
        goto error_exit;
    }

    //
    // Set the sub-authorities on the ACE for the local Administrators group.
    //
    pSubAuthority  = GetSidSubAuthority( pAdminSid, 0 );
    *pSubAuthority = SECURITY_BUILTIN_DOMAIN_RID;

    pSubAuthority  = GetSidSubAuthority( pAdminSid, 1 );
    *pSubAuthority = DOMAIN_ALIAS_RID_ADMINS;

    //
    // Create the owner's SID
    //
    pOwnerSid = LocalAlloc(LMEM_FIXED, GetSidLengthRequired( 1 ));
    if (pOwnerSid == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }
    if (!InitializeSid(pOwnerSid, &siaCreator, 1)) {
        Status = GetLastError();
        goto error_exit;
    }

    pSubAuthority = GetSidSubAuthority(pOwnerSid, 0);
    *pSubAuthority = SECURITY_CREATOR_OWNER_RID;

    //
    // Create the Everyone SID
    //
    pEveryoneSid = LocalAlloc(LMEM_FIXED, GetSidLengthRequired( 1 ));
    if (pEveryoneSid == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }
    if (!InitializeSid(pEveryoneSid, &siaWorld, 1)) {
        Status = GetLastError();
        goto error_exit;
    }

    pSubAuthority = GetSidSubAuthority(pEveryoneSid, 0);
    *pSubAuthority = SECURITY_WORLD_RID;

    //
    // now calculate the size of the buffer needed to hold the
    // ACL and its ACEs and initialize it.
    //
    cbDaclSize = sizeof(ACL) +
        3 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(pAce->SidStart)) +
        GetLengthSid(pAdminSid) + GetLengthSid(pOwnerSid) + GetLengthSid(pEveryoneSid);

    pAcl = (PACL)LocalAlloc( LMEM_FIXED, cbDaclSize );
    if ( pAcl == NULL ) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    if ( !InitializeAcl( pAcl,  cbDaclSize, ACL_REVISION )) {
        Status = GetLastError();
        goto error_exit;
    }

    //
    // add in the specified ACEs
    //
    if (dwAdminMask) {
        //
        // Add the ACE for the local Administrators group to the DACL
        //
        if ( !AddAccessAllowedAce( pAcl,
                                   ACL_REVISION,
                                   dwAdminMask,
                                   pAdminSid )) {
            Status = GetLastError();
            goto error_exit;
        }
        GetAce(pAcl, AceIndex, (PVOID *)&pAce);
        ++AceIndex;
        pAce->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
    }

    if (dwOwnerMask) {
        //
        // Add the ACE for the Creator/Owner to the DACL
        //
        if ( !AddAccessAllowedAce( pAcl,
                                   ACL_REVISION,
                                   dwOwnerMask,
                                   pOwnerSid )) {
            Status = GetLastError();
            goto error_exit;
        }
        GetAce(pAcl, AceIndex, (PVOID *)&pAce);
        ++AceIndex;
        pAce->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
    }

    if (dwEveryOneMask) {
        //
        // Add the ACE for Everyone to the DACL
        //
        if ( !AddAccessAllowedAce( pAcl,
                                   ACL_REVISION,
                                   dwEveryOneMask,
                                   pEveryoneSid )) {
            Status = GetLastError();
            goto error_exit;
        }
        GetAce(pAcl, AceIndex, (PVOID *)&pAce);
        ++AceIndex;
        pAce->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
    }

    //
    // Now that we have an ACL we can set the appropriate security.
    //
    Status = SetSecurityInfo(hObject,
                             SeObjType,
                             DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
                             NULL,
                             NULL,
                             pAcl,
                             NULL);

error_exit:
    if (pAdminSid != NULL) {
        LocalFree(pAdminSid);
    }
    if (pOwnerSid != NULL) {
        LocalFree(pOwnerSid);
    }
    if (pEveryoneSid != NULL) {
        LocalFree(pEveryoneSid);
    }
    if (pAcl != NULL) {
        LocalFree(pAcl);
    }

    //
    //  Chittur Subbaraman (chitturs) - 01/04/2001
    //
    //  Change error code to support file systems that don't support setting
    //  security. This specific change is made to support AhmedM's quorum (of
    //  nodes) resource DLL.
    //
    if ( Status == ERROR_NOT_SUPPORTED ) Status = ERROR_SUCCESS;

    return(Status);
}

DWORD
ClRtlFreeClusterServiceSecurityDescriptor( )
/*++

  Frees the security descriptor that is used to give the cluster
  service access to tokens.

--*/
{
    LocalFree( g_pClusterSecurityDescriptor );
    g_pClusterSecurityDescriptor = NULL;

    return ERROR_SUCCESS;
}

DWORD
ClRtlBuildClusterServiceSecurityDescriptor(
    PSECURITY_DESCRIPTOR * poutSD
    )
/*++

Routine Description:

    Builds a security descriptor that gives the cluster service
    access to tokens. It places this in a global that can be
    reused when other tokens are generated.

    This should be called when the process starts to initialize
    the global. It can pass in NULL if no reference is needed
    right away.

    NOTE: poutSD should NOT be freed by the caller.

Arguments:

Return Value:

--*/
{
    NTSTATUS                Status;
    HANDLE                  ProcessToken = NULL;
    ULONG                   AclLength;
    ULONG                   SDLength;
    PACL                    NewDacl = NULL;
    ULONG                   TokenUserSize;
    PTOKEN_USER             ProcessTokenUser = NULL;
    SECURITY_DESCRIPTOR     SecurityDescriptor;
    PSECURITY_DESCRIPTOR    pNewSD = NULL;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID GlobalLocalSystemSid = NULL;
    PSID GlobalAliasAdminsSid = NULL;

    // If we already have a SD, reuse it.
    if ( g_pClusterSecurityDescriptor != NULL ) {
        Status = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    // Build the two well known sids we need.
    //
    Status = RtlAllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0,0,0,0,0,0,0,
                &GlobalLocalSystemSid
                );
    if ( ! NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    Status = RtlAllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,0,0,0,0,0,
                &GlobalAliasAdminsSid
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }
    //
    // Open the process token to find out the user sid
    //

    Status = NtOpenProcessToken(
                NtCurrentProcess(),
                TOKEN_QUERY | WRITE_DAC,
                &ProcessToken
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    // find out the size
    Status = NtQueryInformationToken(
                ProcessToken,
                TokenUser,
                NULL,
                0,
                &TokenUserSize
                );
    CL_ASSERT( Status == STATUS_BUFFER_TOO_SMALL );
    if ( Status != STATUS_BUFFER_TOO_SMALL ) {
        goto Cleanup;
    }

    ProcessTokenUser = (PTOKEN_USER) LocalAlloc( 0, TokenUserSize );
    if ( ProcessTokenUser == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = NtQueryInformationToken(
                ProcessToken,
                TokenUser,
                ProcessTokenUser,
                TokenUserSize,
                &TokenUserSize
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    AclLength = 3 * sizeof( ACCESS_ALLOWED_ACE ) - 3 * sizeof( ULONG ) +
                RtlLengthSid( ProcessTokenUser->User.Sid ) +
                RtlLengthSid( GlobalLocalSystemSid ) +
                RtlLengthSid( GlobalAliasAdminsSid ) +
                sizeof( ACL );

    NewDacl = (PACL) LocalAlloc(0, AclLength );

    if (NewDacl == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = RtlCreateAcl( NewDacl, AclLength, ACL_REVISION2 );
    CL_ASSERT(NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 ProcessTokenUser->User.Sid
                 );
    CL_ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 GlobalAliasAdminsSid
                 );
    CL_ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 GlobalLocalSystemSid
                 );
    CL_ASSERT( NT_SUCCESS( Status ));

    Status = RtlCreateSecurityDescriptor (
                 &SecurityDescriptor,
                 SECURITY_DESCRIPTOR_REVISION
                 );
    CL_ASSERT( NT_SUCCESS( Status ));

    Status = RtlSetDaclSecurityDescriptor(
                 &SecurityDescriptor,
                 TRUE,
                 NewDacl,
                 FALSE
                 );
    CL_ASSERT( NT_SUCCESS( Status ));

    // Convert the newly created SD into a relative SD to make cleanup
    // easier.
    SDLength = sizeof( SECURITY_DESCRIPTOR_RELATIVE ) + AclLength;
    pNewSD = (PSECURITY_DESCRIPTOR) LocalAlloc( 0, SDLength );
    if ( pNewSD == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if ( !MakeSelfRelativeSD( &SecurityDescriptor, pNewSD, &SDLength ) ) {
        Status = GetLastError( );
        if ( Status != STATUS_BUFFER_TOO_SMALL ) {
            ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] MakeSelfRelativeSD failed 0x%1!.8x!\n", Status );
            goto Cleanup;
        }

        pNewSD = (PSECURITY_DESCRIPTOR) LocalAlloc( 0, SDLength );
        if ( pNewSD == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }

    if ( !MakeSelfRelativeSD( &SecurityDescriptor, pNewSD, &SDLength ) ) {
        Status = GetLastError( );
        goto Cleanup;
    }

    // give ownership to global
    g_pClusterSecurityDescriptor = pNewSD;
    pNewSD = NULL;

Cleanup:
    if (ProcessTokenUser != NULL) {
        LocalFree( ProcessTokenUser );
    }

    if (NewDacl != NULL) {
        LocalFree( NewDacl );
    }

    if (ProcessToken != NULL) {
        NtClose(ProcessToken);
    }

    // This should be NULL if successful.
    if ( pNewSD != NULL ) {
        LocalFree( pNewSD );
    }

    // If successful and the caller wanted to reference the SD, assign it now.
    if ( Status == ERROR_SUCCESS && poutSD != NULL ) {
        *poutSD = g_pClusterSecurityDescriptor;
    }

    if ( GlobalLocalSystemSid != NULL )
    {
        RtlFreeSid( GlobalLocalSystemSid );
    }

    if ( GlobalAliasAdminsSid != NULL )
    {
        RtlFreeSid( GlobalAliasAdminsSid );
    }

    if ( ! NT_SUCCESS( Status ) ) {
        ClRtlLogPrint(LOG_NOISE, "[ClRtl] ClRtlBuildClusterServiceSecurityDescriptor exit. Status = 0x%1!.8x!\n", Status );
    }

    return (DWORD) Status;      // hack it to a DWORD...
}


NTSTATUS
ClRtlImpersonateSelf(
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN ACCESS_MASK AccessMask
    )

/*++

Routine Description:

    This routine may be used to obtain an Impersonation token representing
    your own process's context.  This may be useful for enabling a privilege
    for a single thread rather than for the entire process; or changing
    the default DACL for a single thread.

    The token is assigned to the callers thread.



Arguments:

    ImpersonationLevel - The level to make the impersonation token.

    AccessMask - Access control to the new token.

Return Value:

    STATUS_SUCCESS -  The thread is now impersonating the calling process.

    Other - Status values returned by:

            NtOpenProcessToken()
            NtDuplicateToken()
            NtSetInformationThread()

--*/

{
    NTSTATUS
        Status,
        IgnoreStatus;

    HANDLE
        Token1,
        Token2;

    OBJECT_ATTRIBUTES
        ObjectAttributes;

    SECURITY_QUALITY_OF_SERVICE
        Qos;

    PSECURITY_DESCRIPTOR
        pSecurityDescriptor = NULL;

    Status = ClRtlBuildClusterServiceSecurityDescriptor( &pSecurityDescriptor );
    if(NT_SUCCESS(Status))
    {
        InitializeObjectAttributes(&ObjectAttributes, NULL, 0, 0, NULL);

        Qos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        Qos.ImpersonationLevel = ImpersonationLevel;
        Qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        Qos.EffectiveOnly = FALSE;
        ObjectAttributes.SecurityQualityOfService = &Qos;
        ObjectAttributes.SecurityDescriptor = pSecurityDescriptor;

        Status = NtOpenProcessToken( NtCurrentProcess(), TOKEN_DUPLICATE, &Token1 );

        if (NT_SUCCESS(Status)) {
            Status = NtDuplicateToken(
                         Token1,
                         AccessMask,
                         &ObjectAttributes,
                         FALSE,                 //EffectiveOnly
                         TokenImpersonation,
                         &Token2
                         );

            if (NT_SUCCESS(Status)) {
                Status = NtSetInformationThread(
                             NtCurrentThread(),
                             ThreadImpersonationToken,
                             &Token2,
                             sizeof(HANDLE)
                             );

                IgnoreStatus = NtClose( Token2 );
            }

            IgnoreStatus = NtClose( Token1 );
        }
    }

    return(Status);

}


DWORD
ClRtlEnableThreadPrivilege(
    IN  ULONG        Privilege,
    OUT BOOLEAN      *pWasEnabled
    )
/*++

Routine Description:

    Enables a privilege for the current thread.

Arguments:

    Privilege - The privilege to be enabled.

    pWasEnabled - Returns whether this privilege was originally
        enabled or disabled.  This should be passed into
        ClRtlRestoreThreadPrivilege() for restoring the privileges of
        the thread back.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{

    DWORD           Status;
    BOOL            bImpersonate = FALSE;

    //obtain a token that impersonates the security context
    //of the calling process
    Status = ClRtlImpersonateSelf( SecurityImpersonation, TOKEN_ALL_ACCESS );

    if ( !NT_SUCCESS( Status ) )
    {
        CL_LOGFAILURE(Status);
        goto FnExit;
    }

    bImpersonate = TRUE;
    //
    // Enable the required privilege
    //

    Status = RtlAdjustPrivilege(Privilege, TRUE, TRUE, pWasEnabled);

    if (!NT_SUCCESS(Status)) {
        CL_LOGFAILURE(Status);
        goto FnExit;

    }

FnExit:
    if (Status != ERROR_SUCCESS)
    {
        if (bImpersonate)
        {
            //if this failed and if we
            //
            // terminate impersonation
            //
            HANDLE  NullHandle;


            NullHandle = NULL;

            NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID) &NullHandle,
                sizeof( HANDLE ) );
        }
    }
    return(Status);
}

DWORD
ClRtlRestoreThreadPrivilege(
    IN ULONG        Privilege,
    IN BOOLEAN      WasEnabled
    )
/*++

Routine Description:

    Restores the privilege for the current thread.

Arguments:

    Privilege - The privilege to be enabled.

    WasEnabled - TRUE to restore this privilege to enabled state.
        FALSE otherwise.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   Status = ERROR_SUCCESS;
    HANDLE  NullHandle;
    DWORD   ReturnStatus = ERROR_SUCCESS;
    //
    // If the privilege was originally disabled, disable it now.
    // Else we dont have to do anything.
    //

    if (!WasEnabled)
    {
        ReturnStatus = RtlAdjustPrivilege(Privilege,
                                      WasEnabled, TRUE, &WasEnabled);
        if (!NT_SUCCESS(ReturnStatus)) {
            CL_LOGFAILURE(ReturnStatus);
            //we still need to terminate the impersonation
        }
    }

    //
    // terminate impersonation
    //

    NullHandle = NULL;

    Status = NtSetInformationThread(
                    NtCurrentThread(),
                    ThreadImpersonationToken,
                    (PVOID) &NullHandle,
                    sizeof( HANDLE ) );

    if ( !NT_SUCCESS( Status ) )
    {

        CL_LOGFAILURE(Status);
        //Let the first error be reported
        if (ReturnStatus != ERROR_SUCCESS)
            ReturnStatus = Status;
        goto FnExit;

    }

FnExit:
    return (ReturnStatus);
}

PSECURITY_DESCRIPTOR
ClRtlCopySecurityDescriptor(
    IN PSECURITY_DESCRIPTOR psd
    )

/*++

Routine Description:

    Copy an NT security descriptor. The security descriptor must
    be in self-relative (not absolute) form. Delete the result using LocalFree()

Arguments:

    psd - the SD to copy

Return Value:

    NULL if an error occured or an invalid SD
    Call GetLastError for more detailed information

--*/

{
    PSECURITY_DESCRIPTOR        pSelfSecDesc = NULL;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD                       dwLen = 0;
    DWORD                       cbSelfSecDesc = 0;
    DWORD                       dwRevision = 0;
    DWORD                       status = ERROR_SUCCESS;

    if (NULL == psd) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return NULL;
    }

    ASSERT(IsValidSecurityDescriptor(psd));

    if ( ! GetSecurityDescriptorControl( psd, &sdc, &dwRevision ) ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE, "[ClRtl] CopySecurityDescriptor: GetSecurityDescriptorControl() failed:%1!d1\n", GetLastError());
        SetLastError( status );
        return NULL;    // actually, should probably return an error
    }

    dwLen = GetSecurityDescriptorLength(psd);

    pSelfSecDesc = LocalAlloc( LMEM_ZEROINIT, dwLen );

    if (pSelfSecDesc == NULL) {
        ClRtlLogPrint(LOG_NOISE, "[ClRtl] CopySecurityDescriptor: LocalAlloc() SECURITY_DESCRIPTOR (2) failed\n");
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return NULL;    // actually, should probably return an error
    }

    cbSelfSecDesc = dwLen;

    if (!MakeSelfRelativeSD(psd, pSelfSecDesc, &cbSelfSecDesc)) {
        if ( ( sdc & SE_SELF_RELATIVE ) == 0 ) {
            ClRtlLogPrint(LOG_NOISE, "[ClRtl] CopySecurityDescriptor: MakeSelfRelativeSD failed, 0x%1!.8x!\n", GetLastError());
        } // if: only log this error if the old SD was not already self-relative

        // assume it failed because it was already self-relative
        CopyMemory(pSelfSecDesc, psd, dwLen);
    }

    ASSERT(IsValidSecurityDescriptor(pSelfSecDesc));

    return pSelfSecDesc;

}  //*** ClRtlCopySecurityDescriptor()

static VOID
ClRtlGetSidTypeDesc(
    SID_NAME_USE    SidType,
    LPSTR           pszSidType,
    size_t          cchSidType
    )

/*++

Routine Description:

    Convert the SidType into a meaningful string.

Arguments:

    SidType -
    pszSidType
    cchSidType

Return Value:

        none

--*/

{

    if ((pszSidType != NULL) && (cchSidType > 0))
    {
        char    szSidType [128];

        switch (SidType)
        {
            case SidTypeUser:
                lstrcpyA(szSidType, "has a user SID for");
                break;

            case SidTypeGroup:
                lstrcpyA(szSidType, "has a group SID for");
                break;

            case SidTypeDomain:
                lstrcpyA(szSidType, "has a domain SID for");
                break;

            case SidTypeAlias:
                lstrcpyA(szSidType, "has an alias SID for");
                break;

            case SidTypeWellKnownGroup:
                lstrcpyA(szSidType, "has an SID for a well-known group for");
                break;

            case SidTypeDeletedAccount:
                lstrcpyA(szSidType, "has an SID for a deleted account for");
                break;

            case SidTypeInvalid:
                lstrcpyA(szSidType, "has an invalid SID for");
                break;

            case SidTypeUnknown:
                lstrcpyA(szSidType, "has an unknown SID type:");
                break;

            default:
                szSidType [0] = '\0';
                break;

        } // switch: SidType

        strncpy(pszSidType, szSidType, cchSidType);

    } // if: buffer not null and has space allocated

}  //*** ClRtlGetSidTypeDesc()

static VOID
ClRtlExamineSid(
    PSID        pSid,
    LPSTR       lpszOldIndent
    )

/*++

Routine Description:

    Dump the SID.

Arguments:

    pSid -
    lpzOldIndent -

Return Value:

        none

--*/

{
    CHAR            szUserName [128];
    CHAR            szDomainName [128];
    DWORD           cbUser  = sizeof(szUserName);
    DWORD           cbDomain = sizeof(szDomainName);
    SID_NAME_USE    SidType;

    if ( LookupAccountSidA( NULL, pSid, szUserName, &cbUser, szDomainName, &cbDomain, &SidType ) )
    {
        char    szSidType [128];

        ClRtlGetSidTypeDesc( SidType, szSidType, sizeof( szSidType ) );
        ClRtlLogPrint( LOG_NOISE, "%1!hs!%2!hs! %3!hs!\\%4!hs!\n", lpszOldIndent, szSidType, szDomainName, szUserName ) ;
    }

}  // *** ClRtlExamineSid()

VOID
ClRtlExamineMask(
    ACCESS_MASK amMask,
    LPSTR       lpszOldIndent
    )

/*++

Routine Description:

    Dump the AccessMask context.

Arguments:

    amMask -
    lpzOldIndent -

Return Value:

        none

--*/

{
    #define STANDARD_RIGHTS_ALL_THE_BITS 0x00FF0000L
    #define GENERIC_RIGHTS_ALL_THE_BITS  0xF0000000L

    CHAR  szIndent[100]     = "";
    CHAR  ucIndentBitsBuf[100] = "";
    DWORD dwGenericBits;
    DWORD dwStandardBits;
    DWORD dwSpecificBits;
    DWORD dwAccessSystemSecurityBit;
    DWORD dwExtraBits;

    _snprintf( szIndent, sizeof( szIndent ), "%s    ",  lpszOldIndent );
    _snprintf( ucIndentBitsBuf, sizeof(ucIndentBitsBuf),
               "%s                           ",
               szIndent);

    dwStandardBits            = (amMask & STANDARD_RIGHTS_ALL_THE_BITS);
    dwSpecificBits            = (amMask & SPECIFIC_RIGHTS_ALL         );
    dwAccessSystemSecurityBit = (amMask & ACCESS_SYSTEM_SECURITY      );
    dwGenericBits             = (amMask & GENERIC_RIGHTS_ALL_THE_BITS );

    // **************************************************************************
    // *
    // * Print then decode the standard rights bits
    // *
    // **************************************************************************

    ClRtlLogPrint(LOG_NOISE, "%1!hs! Standard Rights        == 0x%2!.8x!\n", szIndent, dwStandardBits);

    if (dwStandardBits) {

        if ((dwStandardBits & DELETE) == DELETE) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! DELETE\n", ucIndentBitsBuf, DELETE);
        }

        if ((dwStandardBits & READ_CONTROL) == READ_CONTROL) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! READ_CONTROL\n", ucIndentBitsBuf, READ_CONTROL);
        }

        if ((dwStandardBits & STANDARD_RIGHTS_READ) == STANDARD_RIGHTS_READ) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! STANDARD_RIGHTS_READ\n", ucIndentBitsBuf, STANDARD_RIGHTS_READ);
        }

        if ((dwStandardBits & STANDARD_RIGHTS_WRITE) == STANDARD_RIGHTS_WRITE) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! STANDARD_RIGHTS_WRITE\n", ucIndentBitsBuf, STANDARD_RIGHTS_WRITE);
        }

        if ((dwStandardBits & STANDARD_RIGHTS_EXECUTE) == STANDARD_RIGHTS_EXECUTE) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! STANDARD_RIGHTS_EXECUTE\n", ucIndentBitsBuf, STANDARD_RIGHTS_EXECUTE);
        }

        if ((dwStandardBits & WRITE_DAC) == WRITE_DAC) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! WRITE_DAC\n", ucIndentBitsBuf, WRITE_DAC);
        }

        if ((dwStandardBits & WRITE_OWNER) == WRITE_OWNER) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! WRITE_OWNER\n", ucIndentBitsBuf, WRITE_OWNER);
        }

        if ((dwStandardBits & SYNCHRONIZE) == SYNCHRONIZE) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! SYNCHRONIZE\n", ucIndentBitsBuf, SYNCHRONIZE);
        }

        if ((dwStandardBits & STANDARD_RIGHTS_REQUIRED) == STANDARD_RIGHTS_REQUIRED) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! STANDARD_RIGHTS_REQUIRED\n", ucIndentBitsBuf, STANDARD_RIGHTS_REQUIRED);
        }

        if ((dwStandardBits & STANDARD_RIGHTS_ALL) == STANDARD_RIGHTS_ALL) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! STANDARD_RIGHTS_ALL\n", ucIndentBitsBuf, STANDARD_RIGHTS_ALL);
        }

        dwExtraBits = dwStandardBits & (~(DELETE
                                          | READ_CONTROL
                                          | STANDARD_RIGHTS_READ
                                          | STANDARD_RIGHTS_WRITE
                                          | STANDARD_RIGHTS_EXECUTE
                                          | WRITE_DAC
                                          | WRITE_OWNER
                                          | SYNCHRONIZE
                                          | STANDARD_RIGHTS_REQUIRED
                                          | STANDARD_RIGHTS_ALL));
        if (dwExtraBits) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs! Extra standard bits    == 0x%2!.8x! <-This is a problem, should be all 0s\n", szIndent, dwExtraBits);
        }
    }

    ClRtlLogPrint(LOG_NOISE, "%1!hs! Specific Rights        == 0x%2!.8x!\n", szIndent, dwSpecificBits);

    // **************************************************************************
    // *
    // * Print then decode the ACCESS_SYSTEM_SECURITY bit
    // *
    // *************************************************************************

    ClRtlLogPrint(LOG_NOISE, "%1!hs! Access System Security == 0x%2!.8x!\n", szIndent, dwAccessSystemSecurityBit);

    // **************************************************************************
    // *
    // * Print then decode the generic rights bits, which will rarely be on
    // *
    // * Generic bits are nearly always mapped by Windows NT before it tries to do
    // *   anything with them.  You can ignore the fact that generic bits are
    // *   special in any way, although it helps to keep track of what the mappings
    // *   are so that you don't have any surprises
    // *
    // * The only time the generic bits are not mapped immediately is if they are
    // *   placed in an inheritable ACE in an ACL, or in an ACL that will be
    // *   assigned by default (such as the default DACL in an access token).  In
    // *   that case they're mapped when the child object is created (or when the
    // *   default DACL is used at object creation time)
    // *
    // **************************************************************************

    ClRtlLogPrint(LOG_NOISE, "%1!hs! Generic Rights         == 0x%2!.8x!\n", szIndent, dwGenericBits);

    if (dwGenericBits) {

        if ((dwGenericBits & GENERIC_READ) == GENERIC_READ) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! GENERIC_READ\n", ucIndentBitsBuf, GENERIC_READ);
        }

        if ((dwGenericBits & GENERIC_WRITE) == GENERIC_WRITE) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! GENERIC_WRITE\n", ucIndentBitsBuf, GENERIC_WRITE);
        }

        if ((dwGenericBits & GENERIC_EXECUTE) == GENERIC_EXECUTE) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! GENERIC_EXECUTE\n", ucIndentBitsBuf, GENERIC_EXECUTE);
        }

        if ((dwGenericBits & GENERIC_ALL) == GENERIC_ALL) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! GENERIC_ALL\n", ucIndentBitsBuf, GENERIC_ALL);
        }

        dwExtraBits = dwGenericBits & (~(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL));
        if (dwExtraBits) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs! Extra generic bits     == 0x%2!.8x! <-This is a problem, should be all 0s\n", szIndent, dwExtraBits);
        }
    }

}  // *** ClRtlExamineMask()

static BOOL
ClRtlExamineACL(
    PACL    paclACL,
    LPSTR   lpszOldIndent
    )

/*++

Routine Description:

    Dump the Access Control List context.

Arguments:

    amMask -
    lpzOldIndent -

Return Value:

        none

--*/

{
    #define                    SZ_INDENT_BUF 80
    CHAR                       szIndent[100]     = "";
    ACL_SIZE_INFORMATION       asiAclSize;
    ACL_REVISION_INFORMATION   ariAclRevision;
    DWORD                      dwBufLength;
    DWORD                      dwAcl_i;
    ACCESS_ALLOWED_ACE *       paaAllowedAce;

    lstrcpyA(szIndent, lpszOldIndent);
    lstrcatA(szIndent, "    ");

    if (!IsValidAcl(paclACL)) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineACL() - IsValidAcl() failed.\n", szIndent);
        return FALSE;
    }

    dwBufLength = sizeof(asiAclSize);

    if (!GetAclInformation(paclACL, &asiAclSize, dwBufLength, AclSizeInformation)) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineACL() - GetAclInformation failed.\n", szIndent);
        return FALSE;
    }

    dwBufLength = sizeof(ariAclRevision);

    if (!GetAclInformation(paclACL, (LPVOID) &ariAclRevision, dwBufLength, AclRevisionInformation)) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineACL() - GetAclInformation failed\n", szIndent);
        return FALSE;
    }

    ClRtlLogPrint(LOG_NOISE, "%1!hs!ACL has %2!d! ACE(s), %3!d! bytes used, %4!d! bytes free\n",
                szIndent,
                asiAclSize.AceCount,
                asiAclSize.AclBytesInUse,
                asiAclSize.AclBytesFree);

    switch (ariAclRevision.AclRevision) {
        case ACL_REVISION1:
            ClRtlLogPrint(LOG_NOISE, "%1!hs!ACL revision is %2!d! == ACL_REVISION1\n", szIndent, ariAclRevision.AclRevision);
            break;
        case ACL_REVISION2:
            ClRtlLogPrint(LOG_NOISE, "%1!hs!ACL revision is %2!d! == ACL_REVISION2\n", szIndent, ariAclRevision.AclRevision);
            break;
        default:
            ClRtlLogPrint(LOG_NOISE, "%1!hs!ACL revision is %2!d! == ACL Revision is an IMPOSSIBLE ACL revision!!! Perhaps a new revision was added...\n",
                        szIndent,
                        ariAclRevision.AclRevision);
            return FALSE;
            break;
    }

    for (dwAcl_i = 0; dwAcl_i < asiAclSize.AceCount;  dwAcl_i++) {

        if (!GetAce(paclACL, dwAcl_i, (LPVOID *) &paaAllowedAce)) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineACL() - GetAce failed.\n", szIndent);
            return FALSE;
        }

        ClRtlLogPrint(LOG_NOISE, "%1!hs!ACE %2!d! size %3!d!\n", szIndent, dwAcl_i, paaAllowedAce->Header.AceSize);

        {
            char    szBuf [128];

            wsprintfA(szBuf, "%sACE %d ", szIndent, dwAcl_i);
            ClRtlExamineSid(&(paaAllowedAce->SidStart), szBuf );
        }

        {
            DWORD dwAceFlags = paaAllowedAce->Header.AceFlags;

            ClRtlLogPrint(LOG_NOISE, "%1!hs!ACE %2!d! flags 0x%3!.2x!\n", szIndent, dwAcl_i, dwAceFlags);

            if (dwAceFlags) {

                DWORD   dwExtraBits;
                CHAR    ucIndentBitsBuf[SZ_INDENT_BUF] = "";

                lstrcpyA(ucIndentBitsBuf, szIndent);
                lstrcatA(ucIndentBitsBuf, "            ");

                if ((dwAceFlags & OBJECT_INHERIT_ACE) == OBJECT_INHERIT_ACE) {
                    ClRtlLogPrint(LOG_NOISE, "%1!hs!0x01 OBJECT_INHERIT_ACE\n", ucIndentBitsBuf);
                }

                if ((dwAceFlags & CONTAINER_INHERIT_ACE) == CONTAINER_INHERIT_ACE) {
                    ClRtlLogPrint(LOG_NOISE, "%1!hs!0x02 CONTAINER_INHERIT_ACE\n", ucIndentBitsBuf);
                }

                if ((dwAceFlags & NO_PROPAGATE_INHERIT_ACE) == NO_PROPAGATE_INHERIT_ACE) {
                    ClRtlLogPrint(LOG_NOISE, "%1!hs!0x04 NO_PROPAGATE_INHERIT_ACE\n", ucIndentBitsBuf);
                }

                if ((dwAceFlags & INHERIT_ONLY_ACE) == INHERIT_ONLY_ACE) {
                    ClRtlLogPrint(LOG_NOISE, "%1!hs!0x08 INHERIT_ONLY_ACE\n", ucIndentBitsBuf);
                }

                if ((dwAceFlags & VALID_INHERIT_FLAGS) == VALID_INHERIT_FLAGS) {
                    ClRtlLogPrint(LOG_NOISE, "%1!hs!0x0F VALID_INHERIT_FLAGS\n", ucIndentBitsBuf);
                }

                if ((dwAceFlags & SUCCESSFUL_ACCESS_ACE_FLAG) == SUCCESSFUL_ACCESS_ACE_FLAG) {
                    ClRtlLogPrint(LOG_NOISE, "%1!hs!0x40 SUCCESSFUL_ACCESS_ACE_FLAG\n", ucIndentBitsBuf);
                }

                if ((dwAceFlags & FAILED_ACCESS_ACE_FLAG) == FAILED_ACCESS_ACE_FLAG) {
                    ClRtlLogPrint(LOG_NOISE, "%1!hs!0x80 FAILED_ACCESS_ACE_FLAG\n", ucIndentBitsBuf);
                }

                dwExtraBits = dwAceFlags & (~(OBJECT_INHERIT_ACE
                                              | CONTAINER_INHERIT_ACE
                                              | NO_PROPAGATE_INHERIT_ACE
                                              | INHERIT_ONLY_ACE
                                              | VALID_INHERIT_FLAGS
                                              | SUCCESSFUL_ACCESS_ACE_FLAG
                                              | FAILED_ACCESS_ACE_FLAG));
                if (dwExtraBits) {
                    ClRtlLogPrint(LOG_NOISE, "%1!hs! Extra AceFlag bits     == 0x%2!.8x! <-This is a problem, should be all 0s\n",
                                szIndent,
                                dwExtraBits);
                }
            }
        }

        switch (paaAllowedAce->Header.AceType) {
            case ACCESS_ALLOWED_ACE_TYPE:
                ClRtlLogPrint(LOG_NOISE, "%1!hs!ACE %2!d! is an ACCESS_ALLOWED_ACE_TYPE\n", szIndent, dwAcl_i);
                break;
            case ACCESS_DENIED_ACE_TYPE:
                ClRtlLogPrint(LOG_NOISE, "%1!hs!ACE %2!d! is an ACCESS_DENIED_ACE_TYPE\n", szIndent, dwAcl_i);
                break;
            case SYSTEM_AUDIT_ACE_TYPE:
                ClRtlLogPrint(LOG_NOISE, "%1!hs!ACE %2!d! is a  SYSTEM_AUDIT_ACE_TYPE\n", szIndent, dwAcl_i);
                break;
            case SYSTEM_ALARM_ACE_TYPE:
                ClRtlLogPrint(LOG_NOISE, "%1!hs!ACE %2!d! is a  SYSTEM_ALARM_ACE_TYPE\n", szIndent, dwAcl_i);
                break;
            default :
                ClRtlLogPrint(LOG_NOISE, "%1!hs!ACE %2!d! is an IMPOSSIBLE ACE_TYPE!!! Run debugger, examine value!\n", szIndent, dwAcl_i);
                return FALSE;
        }

        ClRtlLogPrint(LOG_NOISE, "%1!hs!ACE %2!d! mask                  == 0x%3!.8x!\n", szIndent, dwAcl_i, paaAllowedAce->Mask);

        ClRtlExamineMask(paaAllowedAce->Mask, szIndent);
    }

    return TRUE;

}  // *** ClRtlExamineACL()

BOOL
ClRtlExamineSD(
    PSECURITY_DESCRIPTOR    psdSD,
    LPSTR                   pszPrefix
    )

/*++

Routine Description:

    Dump the Security descriptor context.

Arguments:

    psdSD - the SD to dump

Return Value:

    BOOL, TRUE for success, FALSE for failure

--*/

{
    PACL                        paclDACL;
    PACL                        paclSACL;
    BOOL                        bHasDACL        = FALSE;
    BOOL                        bHasSACL        = FALSE;
    BOOL                        bDaclDefaulted  = FALSE;
    BOOL                        bSaclDefaulted  = FALSE;
    BOOL                        bOwnerDefaulted = FALSE;
    BOOL                        bGroupDefaulted = FALSE;
    PSID                        psidOwner;
    PSID                        psidGroup;
    SECURITY_DESCRIPTOR_CONTROL sdcSDControl;
    DWORD                       dwSDRevision;
    DWORD                       dwSDLength;
    char                        szIndent [33];

    strncpy(szIndent, pszPrefix, sizeof(szIndent) - 1);
    strcat(szIndent, " ");

    if (!IsValidSecurityDescriptor(psdSD)) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineSD() - IsValidSecurityDescriptor failed.\n", szIndent);
        return FALSE;
    }

    dwSDLength = GetSecurityDescriptorLength(psdSD);

    if (!GetSecurityDescriptorDacl(psdSD, (LPBOOL) &bHasDACL, (PACL *) &paclDACL, (LPBOOL) &bDaclDefaulted)) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineSD() - GetSecurityDescriptorDacl failed.\n", szIndent);
        return FALSE;
    }

    if (!GetSecurityDescriptorSacl(psdSD, (LPBOOL) &bHasSACL, (PACL *) &paclSACL, (LPBOOL) &bSaclDefaulted)) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineSD() - GetSecurityDescriptorSacl failed.\n", szIndent);
        return FALSE;
    }

    if (!GetSecurityDescriptorOwner(psdSD, (PSID *)&psidOwner, (LPBOOL)&bOwnerDefaulted)) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineSD() - GetSecurityDescriptorOwner failed.\n", szIndent);
        return FALSE;
    }

    if (!GetSecurityDescriptorGroup(psdSD, (PSID *) &psidGroup, (LPBOOL) &bGroupDefaulted)) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineSD() - GetSecurityDescriptorGroup failed.\n", szIndent);
        return FALSE;
    }

    if (!GetSecurityDescriptorControl(
                                psdSD,
                                (PSECURITY_DESCRIPTOR_CONTROL) &sdcSDControl,
                                (LPDWORD) &dwSDRevision)) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineSD() - GetSecurityDescriptorControl failed.\n", szIndent);
        return FALSE;
    }

    switch (dwSDRevision) {
        case SECURITY_DESCRIPTOR_REVISION1:
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD is valid.  SD is %2!d! bytes long.  SD revision is %3!d! == SECURITY_DESCRIPTOR_REVISION1\n", szIndent, dwSDLength, dwSDRevision);
            break;
        default :
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD is valid.  SD is %2!d! bytes long.  SD revision is %3!d! == ! SD Revision is an IMPOSSIBLE SD revision!!! Perhaps a new revision was added...\n",
                        szIndent,
                        dwSDLength,
                        dwSDRevision);
            return FALSE;
    }

    if (SE_SELF_RELATIVE & sdcSDControl) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!SD is in self-relative format (all SDs returned by the system are)\n", szIndent);
    }

    if (NULL == psidOwner) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's Owner is NULL, so SE_OWNER_DEFAULTED is ignored\n", szIndent);
    }
    else {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's Owner is Not NULL\n", szIndent);
        if (bOwnerDefaulted) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's Owner-Defaulted flag is TRUE\n", szIndent);
        }
        else {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's Owner-Defaulted flag is FALSE\n", szIndent);
        }
    }

    // **************************************************************************
    // *
    // * The other use for psidGroup is for Macintosh client support
    // *
    // **************************************************************************

    if (NULL == psidGroup) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's Group is NULL, so SE_GROUP_DEFAULTED is ignored. SD's Group being NULL is typical, GROUP in SD(s) is mainly for POSIX compliance\n", szIndent);
    }
    else {
        if (bGroupDefaulted) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's Group-Defaulted flag is TRUE\n", szIndent);
        }
        else {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's Group-Defaulted flag is FALSE\n", szIndent);
        }
    }

    if (SE_DACL_PRESENT & sdcSDControl) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's DACL is Present\n", szIndent);
        if (bDaclDefaulted) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's DACL-Defaulted flag is TRUE\n", szIndent);
        } else {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's DACL-Defaulted flag is FALSE\n", szIndent);
        }

        if (NULL == paclDACL) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD has a NULL DACL explicitly specified (allows all access to Everyone). This does not apply to this SD, but for comparison, a non-NULL DACL pointer to a 0-length ACL allows  no access to anyone\n", szIndent);
        }
        else if(!ClRtlExamineACL(paclDACL, pszPrefix))  {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineSD() - ClRtlExamineACL failed.\n", szIndent);
        }
    }
    else {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's DACL is Not Present, so SE_DACL_DEFAULTED is ignored. SD has no DACL at all (allows all access to Everyone)\n", szIndent);
    }

    if (SE_SACL_PRESENT & sdcSDControl) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's SACL is Present\n", szIndent);
        if (bSaclDefaulted) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's SACL-Defaulted flag is TRUE\n", szIndent);
        }
        else {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's SACL-Defaulted flag is FALSE\n", szIndent);
        }

        if (NULL == paclSACL) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD has a NULL SACL explicitly specified\n", szIndent);
        }
        else if (!ClRtlExamineACL(paclSACL, pszPrefix)) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineSD() - ClRtlExamineACL failed.\n", szIndent);
        }
    }
    else {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's SACL is Not Present, so SE_SACL_DEFAULTED is ignored. SD has no SACL at all (or we did not request to see it)\n", szIndent);
    }

    return TRUE;

}  // *** ClRtlExamineSD()

DWORD
ClRtlBuildDefaultClusterSD(
    IN PSID                 pOwnerSid,
    PSECURITY_DESCRIPTOR *  SD,
    ULONG *                 SizeSD
    )
/*++

Routine Description:

    Builds the default security descriptor to control access to
    the cluster API

    Modified permissions in ACEs in order to augment cluster security
    administration.

Arguments:

    pOwnerSid - Supplies the SID that the cluster account runs in

    SD - Returns a pointer to the created security descriptor. This
        should be freed by the caller.

    SizeSD - Returns the size in bytes of the security descriptor

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD                       Status;
    HANDLE                      Token;
    PACL                        pAcl = NULL;
    DWORD                       cbDaclSize;
    PSECURITY_DESCRIPTOR        psd;
    PSECURITY_DESCRIPTOR        NewSD;
    BYTE                        SDBuffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PACCESS_ALLOWED_ACE         pAce;
    PSID                        pAdminSid = NULL;
    PSID                        pSystemSid = NULL;
    PSID                        pServiceSid = NULL;
    PULONG                      pSubAuthority;
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;
    ULONG                       NewSDLen;

    psd = (PSECURITY_DESCRIPTOR) SDBuffer;

    //
    // allocate and init the Administrators group sid
    //
    if ( !AllocateAndInitializeSid( &siaNtAuthority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0, 0, 0, 0, 0, 0,
                                    &pAdminSid ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    //
    // allocate and init the SYSTEM sid
    //
    if ( !AllocateAndInitializeSid( &siaNtAuthority,
                                    1,
                                    SECURITY_LOCAL_SYSTEM_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pSystemSid ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    if ( pOwnerSid == NULL ) {
        pOwnerSid = pAdminSid;
    }

    //
    // allocate and init the Service sid
    //
    if ( !AllocateAndInitializeSid( &siaNtAuthority,
                                    1,
                                    SECURITY_SERVICE_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pServiceSid ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    //
    // Set up the DACL that will allow admins all access.
    // It should be large enough to hold 3 ACEs and their SIDs
    //

    cbDaclSize = ( 3 * sizeof( ACCESS_ALLOWED_ACE ) ) +
        GetLengthSid( pAdminSid ) +
        GetLengthSid( pSystemSid ) +
        GetLengthSid( pServiceSid );

    pAcl = (PACL) LocalAlloc( LPTR, cbDaclSize );
    if ( pAcl == NULL ) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    InitializeSecurityDescriptor( psd, SECURITY_DESCRIPTOR_REVISION );
    InitializeAcl( pAcl,  cbDaclSize, ACL_REVISION );

    //
    // Add the ACE for the local Administrators group to the DACL
    //
    if ( !AddAccessAllowedAce( pAcl,
                               ACL_REVISION,
                               CLUSAPI_ALL_ACCESS, // What the admin can do
                               pAdminSid ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    //
    // Add the ACE for the SYSTEM account to the DACL
    //
    if ( !AddAccessAllowedAce( pAcl,
                               ACL_REVISION,
                               CLUSAPI_ALL_ACCESS, // What local system can do
                               pSystemSid ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    //
    // Add the ACE for the Service account to the DACL
    //
    if ( !AddAccessAllowedAce( pAcl,
                               ACL_REVISION,
                               CLUSAPI_ALL_ACCESS, // What services can do
                               pServiceSid ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    if ( !GetAce( pAcl, 0, (PVOID *) &pAce ) ) {

        Status = GetLastError();
        goto error_exit;
    }

    pAce->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;

    if ( !GetAce( pAcl, 1, (PVOID *) &pAce ) ) {

        Status = GetLastError();
        goto error_exit;
    }

    pAce->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;

    if ( !GetAce( pAcl, 2, (PVOID *) &pAce ) ) {

        Status = GetLastError();
        goto error_exit;
    }

    pAce->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;

    if ( !SetSecurityDescriptorDacl( psd, TRUE, pAcl, FALSE ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    if ( !SetSecurityDescriptorOwner( psd, pOwnerSid, FALSE ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    if ( !SetSecurityDescriptorGroup( psd, pOwnerSid, FALSE ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    if ( !SetSecurityDescriptorSacl( psd, TRUE, NULL, FALSE ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    NewSDLen = 0 ;

    if ( !MakeSelfRelativeSD( psd, NULL, &NewSDLen ) ) {
        Status = GetLastError();
        if ( Status != ERROR_INSUFFICIENT_BUFFER ) {    // Duh, we're trying to find out how big the buffer should be?
            goto error_exit;
        }
    }

    NewSD = LocalAlloc( LPTR, NewSDLen );
    if ( NewSD ) {
        if ( !MakeSelfRelativeSD( psd, NewSD, &NewSDLen ) ) {
            Status = GetLastError();
            goto error_exit;
        }

        Status = ERROR_SUCCESS;
        *SD = NewSD;
        *SizeSD = NewSDLen;
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

error_exit:
    if ( pAdminSid != NULL ) {
        FreeSid( pAdminSid );
    }

    if ( pSystemSid != NULL ) {
        FreeSid( pSystemSid );
    }

    if ( pServiceSid != NULL ) {
        FreeSid( pServiceSid );
    }

    if ( pAcl != NULL ) {
        LocalFree( pAcl );
    }

    return( Status );

}  // *** ClRtlBuildDefaultClusterSD()


static BOOL
ClRtlGetTokenInformation(
    HANDLE                  hClientToken,
    TOKEN_INFORMATION_CLASS ticRequest,
    PBYTE *                 ppb,
    LPSTR                   pszPrefix
    )

/*++

Routine Description:

    Get the requested information from the passed in client token.

Arguments:

    hClientToken - the client token to dump

Return Value:

    BOOL, TRUE for success, FALSE for failure

--*/

{
    PBYTE   _pb = NULL;
    DWORD   _cb = 64;
    DWORD   _cbNeeded = 0;
    DWORD   _sc = NO_ERROR;

    //
    // Get the user information from the client token.
    //
    do {
        _pb = LocalAlloc( LMEM_ZEROINIT, _cb );
        if ( _pb == NULL ) {
            _sc = GetLastError();
            ClRtlLogPrint( LOG_NOISE,  "%1!hs!ClRtlGetTokenInformation() - LocalAlloc() failed:%2!d!\n", pszPrefix, _sc ) ;
            return FALSE;
        } // if: LocalAlloc failed

        if ( ! GetTokenInformation( hClientToken, ticRequest, _pb, _cb, &_cbNeeded ) ) {
            _sc = GetLastError();
            if ( _sc == ERROR_INSUFFICIENT_BUFFER ) {
                _cb = _cbNeeded;
                LocalFree( _pb );
                _pb = NULL;
                continue;
            } // if: buffer size is too small
            else {
                ClRtlLogPrint( LOG_NOISE,  "%1!hs!ClRtlGetTokenInformation() - GetTokenInformation() failed:%2!d!\n", pszPrefix, _sc ) ;
                return FALSE;
            } // else: fatal error
        } // if: GetTokenInformation failed

        break;  // everything is ok and we can exit the loop normally

    } while( TRUE );

    *ppb = _pb;

    return TRUE;

}  // *** ClRtlGetTokenInformation()

BOOL
ClRtlExamineClientToken(
    HANDLE  hClientToken,
    LPSTR   pszPrefix
    )

/*++

Routine Description:

    Dump the client token.

Arguments:

    hClientToken - the client token to dump

Return Value:

    BOOL, TRUE for success, FALSE for failure

--*/

{
    char    _szIndent [33];
    char    _szBuf [128];
    PBYTE   _pb = NULL;

    strncpy( _szIndent, pszPrefix, sizeof( _szIndent ) - 1 );
    strcat( _szIndent, " " );

    //
    // Get the user information from the client token.
    //
    if ( ClRtlGetTokenInformation( hClientToken, TokenUser, &_pb, _szIndent ) ) {
        PTOKEN_USER _ptu = NULL;

        wsprintfA( _szBuf, "%sClientToken ", _szIndent );

        _ptu = (PTOKEN_USER) _pb;
        ClRtlExamineSid( _ptu->User.Sid, _szBuf );

        LocalFree( _pb );
        _pb = NULL;
    }

    //
    // Get the user's group information from the client token.
    //
    if ( ClRtlGetTokenInformation( hClientToken, TokenGroups, &_pb, _szIndent ) ) {
        PTOKEN_GROUPS   _ptg = NULL;
        DWORD           _nIndex = 0;

        wsprintfA( _szBuf, "%s   ClientToken ", _szIndent );

        _ptg = (PTOKEN_GROUPS) _pb;

        for ( _nIndex = 0; _nIndex < _ptg->GroupCount; _nIndex++ )
        {
            ClRtlExamineSid( _ptg->Groups[ _nIndex ].Sid, _szBuf );
        }

        LocalFree( _pb );
        _pb = NULL;
    }

    //
    // Get the token type information from the client token.
    //
    if ( ClRtlGetTokenInformation( hClientToken, TokenType, &_pb, _szIndent ) ) {
        PTOKEN_TYPE _ptt = NULL;

        wsprintfA( _szBuf, "%s   ClientToken type is", _szIndent );

        _ptt = (PTOKEN_TYPE) _pb;

        if ( *_ptt == TokenPrimary ) {
            ClRtlLogPrint( LOG_NOISE,  "%1!hs! primary.\n", _szBuf ) ;
        }

        if ( *_ptt == TokenImpersonation ) {
            ClRtlLogPrint( LOG_NOISE,  "%1!hs! impersonation.\n", _szBuf ) ;
        }

        LocalFree( _pb );
        _pb = NULL;
    }

    //
    // Get the token impersonation level information from the client token.
    //
    if ( ClRtlGetTokenInformation( hClientToken, TokenImpersonationLevel, &_pb, _szIndent ) ) {
        PSECURITY_IMPERSONATION_LEVEL _psil = NULL;

        wsprintfA( _szBuf, "%s   ClientToken security impersonation level is", _szIndent );

        _psil = (PSECURITY_IMPERSONATION_LEVEL) _pb;

        switch ( *_psil )
        {
            case SecurityAnonymous :
                ClRtlLogPrint( LOG_NOISE,  "%1!hs! Anonymous.\n", _szBuf ) ;
                break;

            case SecurityIdentification :
                ClRtlLogPrint( LOG_NOISE,  "%1!hs! Identification.\n", _szBuf ) ;
                break;

            case SecurityImpersonation :
                ClRtlLogPrint( LOG_NOISE,  "%1!hs! Impersonation.\n", _szBuf ) ;
                break;

            case SecurityDelegation :
                ClRtlLogPrint( LOG_NOISE,  "%1!hs! Delegation.\n", _szBuf ) ;
                break;
        }

        LocalFree( _pb );
        _pb = NULL;
    }

    return TRUE;

}  // *** ClRtlExamineClientToken()

DWORD
ClRtlIsCallerAccountLocalSystemAccount(
    OUT PBOOL pbIsLocalSystemAccount
    )
/*++

Routine Description:

    This function checks whether the caller's account is the local system
    account.

Arguments:

    pbIsLocalSystemAccount - The caller's account is local system account or not.

Return Value:

    ERROR_SUCCESS on success.

    Win32 error code on failure.

Remarks:

    Must be called by an impersonating thread.

--*/
{
    DWORD   dwStatus = ERROR_SUCCESS;
    SID_IDENTIFIER_AUTHORITY
            siaNtAuthority = SECURITY_NT_AUTHORITY;
    PSID    psidLocalSystem = NULL;

    *pbIsLocalSystemAccount = FALSE;

    if ( !AllocateAndInitializeSid(
                    &siaNtAuthority,
                    1,
                    SECURITY_LOCAL_SYSTEM_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &psidLocalSystem ) )
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    if ( !CheckTokenMembership(
                NULL,
                psidLocalSystem,
                pbIsLocalSystemAccount ) )
    {
        dwStatus = GetLastError();
    }

FnExit:
    if( psidLocalSystem != NULL )
    {
        FreeSid( psidLocalSystem );
    }

    return( dwStatus );
}


PTOKEN_USER
ClRtlGetSidOfCallingThread(
    VOID
    )

/*++

Routine Description:

    Get the SID associated with the calling thread (or process if the thread
    has no token)

Arguments:

    none

Return Value:

    pointer to TOKEN_USER data; null if error with last error set on thread

--*/

{
    HANDLE      currentToken;
    PTOKEN_USER tokenUserData;
    DWORD       sizeRequired;
    BOOL        success;

    // check if there is a thread token
    if (!OpenThreadToken(GetCurrentThread(),
                         MAXIMUM_ALLOWED,
                         TRUE,
                         &currentToken))
    {
        // get the process token
        if (!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &currentToken )) {
            return NULL;
        }
    }

    //
    // get the size needed
    //
    success = GetTokenInformation(currentToken,
                                  TokenUser,
                                  NULL,
                                  0,
                                  &sizeRequired);

    tokenUserData = LocalAlloc( LMEM_FIXED, sizeRequired );
    if ( tokenUserData == NULL ) {
        CloseHandle( currentToken );
        return NULL;
    }

    success = GetTokenInformation(currentToken,
                                  TokenUser,
                                  tokenUserData,
                                  sizeRequired,
                                  &sizeRequired);

    CloseHandle( currentToken );

    if ( !success ) {
        LocalFree( tokenUserData );
        return NULL;
    }

    return tokenUserData;
} // ClRtlGetSidOfCallingThread

#if 0
//
// not needed but no point in throwing it away just yet
//
DWORD
ClRtlConvertDomainAccountToSid(
    IN LPWSTR   AccountInfo,
    OUT PSID *  AccountSid
    )

/*++

Routine Description:

    For the given credentials, look up the account SID for the specified
    domain.

Arguments:

    AccountInfo - pointer to string of the form 'domain\user'

    AccountSid - address of pointer that receives the SID for this user

Return Value:

    ERROR_SUCCESS if everything worked

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwSidSize = 128;
    DWORD dwDomainNameSize = DNS_MAX_NAME_BUFFER_LENGTH;
    LPWSTR pwszDomainName;
    SID_NAME_USE SidType;
    PSID accountSid;

    do {
        //
        // Attempt to allocate a buffer for the SID.
        //
        accountSid = LocalAlloc( LMEM_FIXED, dwSidSize );
        pwszDomainName = (LPWSTR) LocalAlloc( LMEM_FIXED, dwDomainNameSize * sizeof(WCHAR) );

        // Was space allocated for the SID and domain name successfully?

        if ( accountSid == NULL || pwszDomainName == NULL ) {
            if ( accountSid != NULL ) {
                LocalFree( accountSid );
            }

            if ( pwszDomainName != NULL ) {
                LocalFree( pwszDomainName );
            }

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Attempt to Retrieve the SID and domain name. If LookupAccountName fails
        // because of insufficient buffer size(s) dwSidSize and dwDomainNameSize
        // will be set correctly for the next attempt.
        //
        if ( !LookupAccountName( NULL,
                                 AccountInfo,
                                 accountSid,
                                 &dwSidSize,
                                 pwszDomainName,
                                 &dwDomainNameSize,
                                 &SidType ))
        {
            // free the Sid buffer and find out why we failed
            LocalFree( accountSid );

            dwStatus = GetLastError();
        }

        // domain name isn't needed at any time
        LocalFree( pwszDomainName );
        pwszDomainName = NULL;

    } while ( dwStatus == ERROR_INSUFFICIENT_BUFFER );

    if ( dwStatus == ERROR_SUCCESS ) {
        *AccountSid = accountSid;
    }

    return dwStatus;
} // ClRtlConvertDomainAccountToSid
#endif

DWORD
AddAceToAcl(
    IN  PACL        pOldAcl,
    IN  PSID        pClientSid,
    IN  ACCESS_MASK AccessMask,
    OUT PACL *      ppNewAcl
    )
/*++

Routine Description:

    This routine creates a new ACL by copying the ACEs from the old ACL and
    creating a new ACE with pClientSid and AccessMask. Stolen from
    \nt\ds\ds\src\ntdsa\dra\remove.c

Arguments:

    pOldAcl - pointer to old ACL with its ACEs

    pClientSid - SID to add

    AccessMask - access mask associated with SID

    pNewAcl - brand spanking new ACL with ACE for the SID and access mask

Return Values:

    ERROR_SUCCESS if the ace was put in the sd

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    BOOL  fStatus;

    ACL_SIZE_INFORMATION     AclSizeInfo;
    ACL_REVISION_INFORMATION AclRevInfo;
    ACCESS_ALLOWED_ACE       Dummy;

    PVOID  FirstAce = 0;
    PACL   pNewAcl = 0;

    ULONG NewAclSize, NewAceCount, AceSize;

    // Parameter check
    if ( !pOldAcl || !pClientSid || !ppNewAcl ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Init the out parameter
    *ppNewAcl = NULL;

    memset( &AclSizeInfo, 0, sizeof( AclSizeInfo ) );
    memset( &AclRevInfo, 0, sizeof( AclRevInfo ) );

    //
    // Get the old sd's values
    //
    fStatus = GetAclInformation( pOldAcl,
                                 &AclSizeInfo,
                                 sizeof( AclSizeInfo ),
                                 AclSizeInformation );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    fStatus = GetAclInformation( pOldAcl,
                                 &AclRevInfo,
                                 sizeof( AclRevInfo ),
                                 AclRevisionInformation );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    //
    // Calculate the new sd's values
    //
    AceSize = sizeof( ACCESS_ALLOWED_ACE ) - sizeof( Dummy.SidStart )
              + GetLengthSid( pClientSid );

    NewAclSize  = AceSize + AclSizeInfo.AclBytesInUse;
    NewAceCount = AclSizeInfo.AceCount + 1;

    //
    // Init the new acl
    //
    pNewAcl = LocalAlloc( 0, NewAclSize );
    if ( NULL == pNewAcl )
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    fStatus = InitializeAcl( pNewAcl,
                             NewAclSize,
                             AclRevInfo.AclRevision );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    //
    // Copy the old into the new
    //
    fStatus = GetAce( pOldAcl,
                      0,
                      &FirstAce );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    fStatus = AddAce( pNewAcl,
                      AclRevInfo.AclRevision,
                      0,
                      FirstAce,
                      AclSizeInfo.AclBytesInUse - sizeof( ACL ) );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    //
    // Finally, add the new ace
    //
    fStatus = AddAccessAllowedAce( pNewAcl,
                                   ACL_REVISION,
                                   AccessMask,
                                   pClientSid );

    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    // Assign the out parameter
    *ppNewAcl = pNewAcl;

    //
    // That's it fall through to cleanup
    //

Cleanup:

    if ( ERROR_SUCCESS != WinError )
    {
        if ( pNewAcl )
        {
            LocalFree( pNewAcl );
        }
    }

    return WinError;
} // AddAceToAcl

DWORD
AddAceToSd(
    IN  PSECURITY_DESCRIPTOR    pOldSd,
    IN  PSID                    pClientSid,
    IN  ACCESS_MASK             AccessMask,
    OUT PSECURITY_DESCRIPTOR *  ppNewSd
    )
/*++

Routine Description:

    This routine creates a new sd with a new ace with pClientSid and
    AccessMask. Stolen from \nt\ds\ds\src\ntdsa\dra\remove.c

Arguments:

    pOldSd - existing SD in self relative format

    pClientSid - SID to add to an ACE

    AccessMask - 'nuff said

    pNewAcl - pointer to new SD that contains new ACE

Return Values:

    ERROR_SUCCESS if the ace was put in the sd

--*/
{

    DWORD  WinError = ERROR_SUCCESS;
    BOOL   fStatus;

    PSECURITY_DESCRIPTOR pNewSelfRelativeSd = NULL;
    DWORD                NewSelfRelativeSdSize = 0;
    PACL                 pNewDacl  = NULL;

    SECURITY_DESCRIPTOR  AbsoluteSd;
    PACL                 pDacl  = NULL;
    PACL                 pSacl  = NULL;
    PSID                 pGroup = NULL;
    PSID                 pOwner = NULL;

    DWORD AbsoluteSdSize = sizeof( SECURITY_DESCRIPTOR );
    DWORD DaclSize = 0;
    DWORD SaclSize = 0;
    DWORD GroupSize = 0;
    DWORD OwnerSize = 0;


    // Parameter check
    if ( !pOldSd || !pClientSid || !ppNewSd ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Init the out parameter
    *ppNewSd = NULL;

    RtlZeroMemory( &AbsoluteSd, AbsoluteSdSize );

    //
    // Make sd absolute
    //
    fStatus = MakeAbsoluteSD( pOldSd,
                              &AbsoluteSd,
                              &AbsoluteSdSize,
                              pDacl,
                              &DaclSize,
                              pSacl,
                              &SaclSize,
                              pOwner,
                              &OwnerSize,
                              pGroup,
                              &GroupSize );

    if ( !fStatus && (ERROR_INSUFFICIENT_BUFFER == (WinError = GetLastError())))
    {
        WinError = ERROR_SUCCESS;

        if ( 0 == DaclSize )
        {
            // No Dacl? We can't write to the dacl, then
            WinError = ERROR_ACCESS_DENIED;
            goto Cleanup;
        }

        if ( DaclSize > 0 ) pDacl = alloca( DaclSize );
        if ( SaclSize > 0 ) pSacl = alloca( SaclSize );
        if ( OwnerSize > 0 ) pOwner = alloca( OwnerSize );
        if ( GroupSize > 0 ) pGroup = alloca( GroupSize );

        if ( pDacl )
        {
            fStatus = MakeAbsoluteSD( pOldSd,
                                      &AbsoluteSd,
                                      &AbsoluteSdSize,
                                      pDacl,
                                      &DaclSize,
                                      pSacl,
                                      &SaclSize,
                                      pOwner,
                                      &OwnerSize,
                                      pGroup,
                                      &GroupSize );

            if ( !fStatus )
            {
                WinError = GetLastError();
            }
        }
        else
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
        }

    }

    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    //
    // Create a new dacl with the new ace
    //
    WinError = AddAceToAcl(pDacl,
                           pClientSid,
                           AccessMask,
                           &pNewDacl );

    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    //
    // Set the dacl
    //
    fStatus = SetSecurityDescriptorDacl ( &AbsoluteSd,
                                         TRUE,     // dacl is present
                                         pNewDacl,
                                         FALSE );  //  facl is not defaulted

    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    //
    // Make the new sd self relative
    //
    fStatus =  MakeSelfRelativeSD( &AbsoluteSd,
                                   pNewSelfRelativeSd,
                                   &NewSelfRelativeSdSize );

    if ( !fStatus && (ERROR_INSUFFICIENT_BUFFER == (WinError = GetLastError())))
    {
        WinError = ERROR_SUCCESS;

        pNewSelfRelativeSd = LocalAlloc( 0, NewSelfRelativeSdSize );

        if ( pNewSelfRelativeSd )
        {
            fStatus =  MakeSelfRelativeSD( &AbsoluteSd,
                                           pNewSelfRelativeSd,
                                           &NewSelfRelativeSdSize );

            if ( !fStatus )
            {
                WinError = GetLastError();
            }
        }
        else
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // That's it fall through to cleanup
    //

Cleanup:

    if ( pNewDacl )
    {
        LocalFree( pNewDacl );
    }

    if ( ERROR_SUCCESS == WinError )
    {
        *ppNewSd = pNewSelfRelativeSd;
    }
    else
    {
        if ( pNewSelfRelativeSd )
        {
            LocalFree( pNewSelfRelativeSd );
        }
    }

    return WinError;

} // AddAceToSd

DWORD
ClRtlAddClusterServiceAccountToWinsta0DACL(
    VOID
    )

/*++

Routine Description:

    Modify the DACL on the interactive window station (Winsta0) and its
    desktop such that resmon child processes (such as gennap resources) can
    display on the desktop if so desired.

    MEGA-IMPORTANT: this routine must be synchronized in a multi-threaded
    environment, i.e., make sure that you're holding a lock of some sort
    before calling it. It won't solve the race condition on setting the DACL
    that exists between processes but it will make sure that the window
    station APIs work correctly.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if it worked...

--*/

{
    DWORD                   status = ERROR_SUCCESS;
    LPWSTR                  accountInfo = NULL;
    PTOKEN_USER             sidData = NULL;
    HWINSTA                 winsta0 = NULL;
    HWINSTA                 previousWinStation = NULL;
    HDESK                   desktop = NULL;
    SECURITY_INFORMATION    requestedSI = DACL_SECURITY_INFORMATION;
    BOOL                    success;
    DWORD                   lengthRequired = 0;
    DWORD                   lengthRequired2;
    DWORD                   i;
    PSECURITY_DESCRIPTOR    winstaSD = NULL;
    PSECURITY_DESCRIPTOR    deskSD = NULL;
    PSECURITY_DESCRIPTOR    newSD = NULL;
    BOOL                    hasDACL;
    PACL                    dacl;
    BOOL                    daclDefaulted;

    //
    // first see if we have the access we need by trying to open the
    // interactive window station and its default desktop. if so, don't go any
    // further and return success
    //
    winsta0 = OpenWindowStation( L"winsta0", FALSE, GENERIC_ALL );
    if ( winsta0 != NULL ) {

        previousWinStation = GetProcessWindowStation();
        success = SetProcessWindowStation( winsta0 );

        if ( success ) {

            //
            // if we have window station access, we should have desktop as well
            //
            desktop = OpenDesktop( L"default", 0, FALSE, GENERIC_ALL );
            SetProcessWindowStation( previousWinStation );
            previousWinStation = NULL;

            if ( desktop != NULL ) {
                //
                // always switch the winstation back to the previous one
                // before closing the desktop and winstation handles
                //
                CloseDesktop( desktop );
                CloseWindowStation( winsta0 );
                return ERROR_SUCCESS;
            }
        }
        CloseWindowStation( winsta0 );
    }

    //
    // get the SID of the account associated with this thread. This is the
    // account that will be added to the DACL
    //
    sidData = ClRtlGetSidOfCallingThread();
    if ( sidData == NULL ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] ClRtlGetSidOfCallingThread failed. Status %1!u!\n", status );
        goto error_exit;
    }

    //
    // open handles to Winsta0 and its default desktop. Temporarily switch to
    // winsta0 to get its default desktop
    //
    winsta0 = OpenWindowStation( L"winsta0", TRUE, MAXIMUM_ALLOWED );
    if ( winsta0 == NULL ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] OpenWindowStation failed. Status %1!u!\n", status );
        goto error_exit;
    }

    previousWinStation = GetProcessWindowStation();
    success = SetProcessWindowStation( winsta0 );
    if ( !success ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] SetProcessWindowStation(winsta0) failed. Status %1!u!\n", status );
        goto error_exit;
    }

    desktop = OpenDesktop( L"default", 0, TRUE, MAXIMUM_ALLOWED );
    if ( desktop == NULL ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] OpenDesktop(default) failed. Status %1!u!\n", status );
        goto error_exit;
    }

    //
    // get the SD and its DACL for Winsta0
    //
    success = GetUserObjectSecurity(winsta0,
                                    &requestedSI,
                                    NULL,
                                    0,
                                    &lengthRequired);
    if ( !success ) {
        status = GetLastError();
        if ( status != ERROR_INSUFFICIENT_BUFFER ) {
            ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] GetUOSecurityLen(winsta0) failed. Status %1!u!\n", status );
            goto error_exit;
        }
    }

    //
    // If UserObjectLen grew on us more than a few times,
    // something is fishy, so we will fail the request
    //
    for(i = 0; i < 5; ++i) {
        winstaSD = LocalAlloc( LMEM_FIXED, lengthRequired );
        if ( winstaSD == NULL ) {
            status = GetLastError();
            goto error_exit;
        }

        success = GetUserObjectSecurity(winsta0,
                                        &requestedSI,
                                        winstaSD,
                                        lengthRequired,
                                        &lengthRequired2);
        if ( success ) {
            status = ERROR_SUCCESS;
            break;
        }

        status = GetLastError();
        if ( status != ERROR_INSUFFICIENT_BUFFER ) {
            ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] GetUOSecurity(winsta0) failed. Status %1!u!\n", status );
            goto error_exit;
        }

        lengthRequired = lengthRequired2;
        LocalFree(winstaSD);
        winstaSD = NULL;
    }

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] GetUOSecurity(winsta0) failed. Status %1!u!\n", status );
        goto error_exit;
    }

    //
    // build a new SD that includes our service account SID giving it complete
    // access
    //
    status = AddAceToSd(winstaSD,
                        sidData->User.Sid,
                        GENERIC_ALL,
                        &newSD);

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] AddAceToSd(winsta) failed. Status %1!u!\n", status );
        goto error_exit;
    }

    //
    // set the new SD on Winsta0
    //
    success = SetUserObjectSecurity( winsta0, &requestedSI, newSD );
    if ( !success ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] SetUOSecurity(winsta0) failed. Status %1!u!\n", status );
        goto error_exit;
    }

    LocalFree( newSD );
    newSD = NULL;

    //
    // repeat the process for the desktop SD and its DACL
    //
    success = GetUserObjectSecurity(desktop,
                                    &requestedSI,
                                    NULL,
                                    0,
                                    &lengthRequired);
    if ( !success ) {
        status = GetLastError();
        if ( status != ERROR_INSUFFICIENT_BUFFER ) {
            ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] GetUOSecurityLen(desktop) failed. Status %1!u!\n", status );
            goto error_exit;
        }
    }

    //
    // If UserObjectLen grew on us more than a few times,
    // something is fishy, so we will fail the request
    //
    for (i = 0; i < 5; ++i) {
        deskSD = LocalAlloc( LMEM_FIXED, lengthRequired );
        if ( deskSD == NULL ) {
            status = GetLastError();
            goto error_exit;
        }

        success = GetUserObjectSecurity(desktop,
                                        &requestedSI,
                                        deskSD,
                                        lengthRequired,
                                        &lengthRequired2);
        if ( success ) {
            status = ERROR_SUCCESS;
            break;
        }

        status = GetLastError();
        if ( status != ERROR_INSUFFICIENT_BUFFER ) {
            ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] GetUOSecurity(desktop) failed. Status %1!u!\n", status );
            goto error_exit;
        }

        lengthRequired = lengthRequired2;
        LocalFree(deskSD);
        deskSD = NULL;
    }
    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] GetUOSecurity(desktop) failed. Status %1!u!\n", status );
        goto error_exit;
    }

    status = AddAceToSd(deskSD,
                        sidData->User.Sid,
                        GENERIC_ALL,
                        &newSD);

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] AddAceToSd(desktop) failed. Status %1!u!\n", status );
        goto error_exit;
    }

    success = SetUserObjectSecurity( desktop, &requestedSI, newSD );
    if ( !success ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] SetUserObjectSecurity(desktop) failed. Status %1!u!\n", status );
    }

error_exit:

    FREE_IF_NOT_NULL( newSD, LocalFree );

    FREE_IF_NOT_NULL( deskSD, LocalFree );

    FREE_IF_NOT_NULL( winstaSD, LocalFree );

    //
    // always switch the winstation back to the previous one before closing
    // the desktop and winstation handles
    //
    if ( previousWinStation != NULL ) {
        success = SetProcessWindowStation( previousWinStation );
        if ( !success ) {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] SetWindowsStation(previous) failed. Status %1!u!\n", status );
        }
    }

    FREE_IF_NOT_NULL( desktop, CloseDesktop );

    FREE_IF_NOT_NULL( winsta0, CloseWindowStation );

    FREE_IF_NOT_NULL( sidData, LocalFree );

    FREE_IF_NOT_NULL( accountInfo, LocalFree );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clussprt\clusprtp.h ===
#ifndef _CLUSPRTP_H
#define _CLUSPRTP_H

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clusprtp.h

Abstract:

    Private header file for cluster support api

Author:

    Sunita Shrivastava (sunitas) 15-Jan-1997

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "api_rpc.h"

//
// Define CLUSTER structure. There is one cluster structure created
// for each OpenCluster API call. An HCLUSTER is really a pointer to
// this structure.
//

#define CLUSTER_SPRT_SIGNATURE 'SULC'


typedef struct _CLUSTER_SPRT {
    DWORD dwSignature;
    RPC_BINDING_HANDLE RpcBinding;
} CLUSTER_SPRT, *PCLUSTER_SPRT;

HANDLE
WINAPI
BindToClusterSvc(
    IN LPWSTR lpszClusterName);

DWORD
WINAPI
UnbindFromClusterSvc(
    IN HANDLE hCluster);


DWORD
WINAPI
PropagateEvents(
    IN HANDLE       hCluster,
    IN DWORD        dwEventInfoSize,
    IN PPACKEDEVENTINFO pPackedEventInfo);


#endif //_CLUSPRTP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clussprt\clussprt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clussprt.c

Abstract:

    Public interfaces for managing clusters.

Author:

    Sunita Shrivastava (sunitas) 15-Jan-1997

Revision History:

--*/
#include "clusprtp.h"


//
// General Cluster Support Routines for base components
//

/****
@doc    EXTERNAL INTERFACES CLUSSVC CLUSSPRT EVTLOG
****/

/****
@func       HANDLE WINAPI | BindToClusterSvc| This returns a handle via which
            you can talk to the cluster service.

@parm       IN LPWSTR | lpszClusterName | A pointer to the cluster name.  If NULL,
            this connects to the local cluster service.

@rdesc      Returns a handle to the binding if successful, else returns NULL.
            Error can be obtained by calling GetLastError().

@comm       The handle obtained from this must be passed on to other apis exported
            by this module.  It must be freed eventually by calling UnbindFromClusterSvc().

@xref       <f UnbindFromClusterSvc>
****/
HANDLE
WINAPI
BindToClusterSvc(IN LPWSTR lpszClusterName)
{
    WCHAR           *pBinding = NULL;
    PCLUSTER_SPRT    pCluster;
    DWORD           Status = ERROR_SUCCESS;
    
    pCluster = LocalAlloc(LMEM_ZEROINIT, sizeof(CLUSTER_SPRT));
    if (pCluster == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        SetLastError( Status );
        return NULL;
    }
    pCluster->dwSignature = CLUSTER_SPRT_SIGNATURE;

    if ((lpszClusterName == NULL) ||
        (lpszClusterName[0] == '\0')) 
    {

        Status = RpcStringBindingComposeW(L"b97db8b2-4c63-11cf-bff6-08002be23f2f",
                                          L"ncalrpc",
                                          NULL,
                                          L"clusapi",
                                          NULL,
                                          &pBinding);
        if (Status != RPC_S_OK) 
        {
            goto FnExit;
        }

    } 
    else 
    {

        //
        // Try to connect directly to the cluster.
        //
        Status = RpcStringBindingComposeW(L"b97db8b2-4c63-11cf-bff6-08002be23f2f",
                                          L"ncacn_np",
                                          (LPWSTR)lpszClusterName,
                                          L"\\pipe\\clusapi",
                                          NULL,
                                          &pBinding);
        if (Status != RPC_S_OK) {
            goto FnExit;
        }
    }
    //bind to the cluster svc and save the binding handle
    Status = RpcBindingFromStringBindingW(pBinding, &pCluster->RpcBinding);
    RpcStringFreeW(&pBinding);
    if (Status != RPC_S_OK) {
        goto FnExit;
    }

    Status = RpcBindingSetAuthInfoW(pCluster->RpcBinding,
                                    L"CLUSAPI",
                                    RPC_C_AUTHN_LEVEL_CONNECT,
                                    RPC_C_AUTHN_WINNT,
                                    NULL,
                                    RPC_C_AUTHZ_NAME);

FnExit:
    if (Status != ERROR_SUCCESS) 
    {
        SetLastError(Status);
        if (pCluster->RpcBinding)
            RpcBindingFree(&(pCluster->RpcBinding));
        LocalFree(pCluster);
        pCluster=NULL;
    }
    return((HANDLE)pCluster);
}


/****
@func       DWORD | UnbindFromClusterSvc| This initializes the cluster
            wide eventlog replicating services.

@parm       IN HANDLE | hCluster | A handle to the binding context obtained
            via BindToClusterSvc().
            
@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm       Frees the context related with this binding.

@xref       <f UnbindFromClusterSvc>
****/
DWORD
WINAPI
UnbindFromClusterSvc(IN HANDLE hCluster)
{
    DWORD   Status = ERROR_SUCCESS;
    PCLUSTER_SPRT    pCluster = (PCLUSTER_SPRT)hCluster;
    
    
    if (!pCluster || (pCluster->dwSignature != CLUSTER_SPRT_SIGNATURE) || !(pCluster->RpcBinding))
    {
        Status = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }
    RpcBindingFree(&(pCluster->RpcBinding));
    LocalFree(pCluster);

FnExit:
    return(Status);
}



/****
@func       DWORD | PropagateEvents| This eventlog service calls the
            local cluster service via this api to propagate events
            within a cluster.

@parm       IN HANDLE | hCluster | handle to a cluster binding context
            returned by BindToClusterSvc().

@parm       IN DWORD | dwEventInfoSize | Size of the event info structure
            that contains the events to be propagated.

@parm       IN PPACKEDEVENTINFO| pPackedEventInfo | A pointer to the packed
            event information structure.
            
@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm       This calls ApiEvPropEvents() in the cluster via lrpc.

@xref       <f BindToClusterSvc>
****/
DWORD
WINAPI
PropagateEvents(
    IN HANDLE       hCluster,
    IN DWORD        dwEventInfoSize,
    IN PPACKEDEVENTINFO pPackedEventInfo)
{
    DWORD Status=ERROR_SUCCESS;
    PCLUSTER_SPRT pCluster=(PCLUSTER_SPRT)hCluster;

    if (!pCluster || (pCluster->dwSignature != CLUSTER_SPRT_SIGNATURE) || !(pCluster->RpcBinding))
    {
        Status = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }
    RpcTryExcept {
    //call the cluster service
        ApiEvPropEvents(pCluster->RpcBinding, 
            dwEventInfoSize, (UCHAR *)pPackedEventInfo);
    }
    
    RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
    //SS: dont do anything -
    }
    RpcEndExcept

FnExit:
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\tdisk.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    disk.c

Abstract:

    Test harness for the disk.cpp module

Author:

    John Vert (jvert) 10/10/1996

Revision History:

--*/
#include "stdlib.h"

#include "disk.h"

VOID
DiskFatalError(
    IN DWORD MessageId,
    IN DWORD ErrCode,
    IN LPSTR File,
    IN DWORD Line
    );

class CTestApp : public CWinApp
{
public:
    CTestApp::CTestApp();
    virtual BOOL InitInstance();
    DECLARE_MESSAGE_MAP()

};

BEGIN_MESSAGE_MAP(CTestApp, CWinApp)
        //{{AFX_MSG_MAP(CTestApp)
                // NOTE - the ClassWizard will add and remove mapping macros here.
                //    DO NOT EDIT what you see in these blocks of generated code!
        //}}AFX_MSG
END_MESSAGE_MAP()

CTestApp TestApp;


CTestApp::CTestApp()
{
}
VOID
OutputPhysicalPartition(
    IN CPhysicalPartition *Partition,
    IN DWORD Indent
    )
{
    LARGE_INTEGER EndingOffset;
    DWORD i;
    for (i=0; i<Indent; i++) {
        printf(" ");
    }
    printf("%d(%d): ",
           Partition->m_Info.PartitionNumber,
           Partition->m_Info.PartitionType);
    EndingOffset.QuadPart = Partition->m_Info.StartingOffset.QuadPart +
                            Partition->m_Info.PartitionLength.QuadPart;
    if (Partition->m_Info.StartingOffset.HighPart > 0) {
        printf("%lx%08lx - ",
               Partition->m_Info.StartingOffset.HighPart,
               Partition->m_Info.StartingOffset.LowPart);
    } else {
        printf("%lx - ",Partition->m_Info.StartingOffset.LowPart);
    }
    if (EndingOffset.HighPart > 0) {
        printf("%lx%08lx - ",
               EndingOffset.HighPart,
               EndingOffset.LowPart);
    } else {
        printf("%lx - ",EndingOffset.LowPart);
    }
    printf(" (%dMB)\n", Partition->m_Info.PartitionLength.QuadPart / (1024*1024));
}

VOID
OutputPhysicalDisk(
    IN CPhysicalDisk *Disk,
    IN DWORD Indent
    )
{
    DWORD i;
    for (i=0; i<Indent; i++) {
        printf(" ");
    }
    printf("%ws Harddisk%d (%08lx) ",
            Disk->m_Identifier,
            Disk->m_DiskNumber,
            Disk->m_Signature);
    if (Disk->m_IsSCSI) {
        printf("port %d, bus %d, TID %d\n",
               Disk->m_ScsiAddress.PortNumber,
               Disk->m_ScsiAddress.PathId,
               Disk->m_ScsiAddress.TargetId);
    } else {
        printf(" not SCSI\n");
    }

    //
    // Dump out all the partitions
    //
    POSITION pos = Disk->m_PartitionList.GetHeadPosition();
    while (pos != NULL) {
        OutputPhysicalPartition(Disk->m_PartitionList.GetNext(pos), Indent+4);
    }

}


VOID
OutputLogicalDisk(
    IN CLogicalDrive *Drive,
    IN DWORD Indent
    )
{
    DWORD i;
    for (i=0; i<Indent; i++) {
        printf(" ");
    }
    printf("%c: %-16ws\t(%s)\t(%s)\n",
           Drive->m_DriveLetter,
           (LPCTSTR)Drive->m_VolumeLabel,
           Drive->m_IsNTFS ? "  NTFS  " : "not NTFS",
           Drive->m_IsSticky ? "  sticky  " : "not sticky");
    printf("\t%ws\n",(LPCTSTR)Drive->m_Identifier);
}

BOOL
CTestApp::InitInstance()
{
    CDiskConfig Config;
    BOOL Success;
    PFT_INFO ftInfo;
    LARGE_INTEGER startingOffset;
    LARGE_INTEGER partLength;
    DWORD status;

//#define DISKINFO_TEST
#ifdef DISKINFO_TEST
    ftInfo = DiskGetFtInfo();

    status = DiskAddDiskInfo( ftInfo, 0, 0x385849FB);
    printf( "DiskAddDisk status = %u\n", status);

    startingOffset.QuadPart = 0x4000;
    partLength.QuadPart = 0xFF4FC000I64;
    status = DiskAddDriveLetter( ftInfo, 0x385849FB, startingOffset, partLength, 'C');
    printf("AddDriveLetter for C: %u\n", status);

    startingOffset.QuadPart = 0xFF504000I64;
    partLength.QuadPart = 0x5FC000I64;
    status = DiskAddDriveLetter( ftInfo, 0x385849FB, startingOffset, partLength, 'G');
    printf("AddDriveLetter for G: %u\n", status);

    status = DiskAddDiskInfo( ftInfo, 1, 0x19B25E84);
    printf( "DiskAddDisk status = %u\n", status);

    startingOffset.QuadPart = 0x4000I64;
    partLength.QuadPart = 0x7FCFC000I64;
    status = DiskAddDriveLetter( ftInfo, 0x19B25E84, startingOffset, partLength, 'D');
    printf("AddDriveLetter for D: %u\n", status);

    startingOffset.QuadPart = 0x7FD00000I64;
    partLength.QuadPart = 0x7FE00000I64;
    status = DiskAddDriveLetter( ftInfo, 0x19B25E84, startingOffset, partLength, 'E');
    printf("AddDriveLetter for E: %u\n", status);

    DiskFreeFtInfo( ftInfo );
    return 1;
#endif // DISKINFO_TEST
    //
    // Initialize the disk configuration
    //
    Success = Config.Initialize();
    if (!Success) {
        fprintf(stderr, "Disk initialization failed\n");
    }


    //
    // Display the physical disk configuration
    //

    printf("Physical disk configuration\n");
    POSITION pos = Config.m_PhysicalDisks.GetStartPosition();
    while( pos != NULL )
    {
        CPhysicalDisk* pDisk;
        int Index;

        Config.m_PhysicalDisks.GetNextAssoc( pos, Index, pDisk );
        OutputPhysicalDisk(pDisk,4);
    }

    //
    // Display the logical disk configuration
    //

    printf("\nLogical disk configuration\n");
    pos = Config.m_LogicalDrives.GetStartPosition();
    while( pos != NULL )
    {
        CLogicalDrive* pDisk;
        WCHAR Letter;

        Config.m_LogicalDrives.GetNextAssoc( pos, Letter, pDisk );
        OutputLogicalDisk(pDisk,4);
    }
    return(1);
}


VOID
DiskErrorFatal(
    INT MessageId,
    DWORD Error,
    LPSTR File,
    DWORD Line
    )
{
    fprintf(stderr, "A fatal error occurred.\n");
    fprintf(stderr, "\tMessage %d\n",MessageId);
    fprintf(stderr, "\tErrCode %d\n",Error);
    fprintf(stderr, "\tFile %s\n, line %d",File, Line);
    exit(1);
}


VOID
DiskErrorLogInfo(
    PCHAR Format,
    ...
    )
{

    CHAR Buffer[256];
    DWORD Bytes;
    va_list ArgList;

    va_start(ArgList, Format);

    vprintf(Format, ArgList);

    va_end(ArgList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\tcpcfg.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

   tcpcfg.c

Abstract:

    TCP/IP translation routines

Author:

    Mike Massa (mikemas)           July 15, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     07-15-97    created


--*/
#include "clusrtlp.h"
#include <tdi.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <llinfo.h>
#include <ntddtcp.h>
#include <winsock2.h>
#include <wchar.h>



//
// Private Constants
//
#define MAX_ADDRESS_STRING_LENGTH    15
#define MAX_ENDPOINT_STRING_LENGTH    5

VOID
ClRtlQueryTcpipInformation(
    OUT  LPDWORD   MaxAddressStringLength,
    OUT  LPDWORD   MaxEndpointStringLength,
    OUT  LPDWORD   TdiAddressInfoLength
    )
/*++

Routine Description:

    Returns information about the TCP/IP protocol.

Arguments:

    MaxAddressStringLength - A pointer to a variable into which to place
                             the maximum length, in characters, of a TCP/IP
                             network address value in string format, including
                             the terminating NULL. If this parameter is NUL,
                             it will be skipped.

    MaxEndpointStringLength - A pointer to a variable into which to place
                             the maximum length, in characters, of a TCP/IP
                             transport endpoint value in string format,
                             including the terminating NUL. If this parameter
                             is NULL, it will be skipped.

Return Value:

    None.

--*/
{
    if (MaxAddressStringLength != NULL) {
        *MaxAddressStringLength = MAX_ADDRESS_STRING_LENGTH;
    }

    if (MaxEndpointStringLength != NULL) {
        *MaxEndpointStringLength = MAX_ENDPOINT_STRING_LENGTH;
    }

    if (TdiAddressInfoLength != NULL) {
        *TdiAddressInfoLength =  sizeof(TDI_ADDRESS_INFO) -
                                 sizeof(TRANSPORT_ADDRESS) +
                                 sizeof(TA_IP_ADDRESS);
    }

    return;

} // ClRtlQueryTcpipInformation


DWORD
ClRtlTcpipAddressToString(
    ULONG     AddressValue,
    LPWSTR *  AddressString
    )
/*++

Routine Description:

    Converts a binary representation of a TCP/IP network address,
    in network byte order, into a string representation.

Arguments:

     AddressValue - The binary value, in network byte order, to convert.

     AddressString - A pointer to a pointer to a unicode string buffer into
                     which to place the converted value. If this parameter
                     is NULL, the string buffer will be allocated and
                     must be freed by the caller.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD              status;
    NTSTATUS           ntStatus;
    UNICODE_STRING     unicodeString;
    ANSI_STRING        ansiString;
    LPSTR              ansiBuffer;
    LPWSTR             addressString;
    BOOLEAN            allocatedStringBuffer = FALSE;
    USHORT             maxStringLength = (MAX_ADDRESS_STRING_LENGTH + 1) *
                                         sizeof(WCHAR);


    if (*AddressString == NULL) {
        addressString = LocalAlloc(LMEM_FIXED, maxStringLength);

        if (addressString == NULL) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        allocatedStringBuffer = TRUE;
    }
    else {
        addressString = *AddressString;
    }

    ansiBuffer = inet_ntoa(*((struct in_addr *) &AddressValue));

    if (ansiBuffer == NULL) {
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    RtlInitAnsiString(&ansiString, ansiBuffer);

    unicodeString.Buffer = addressString;
    unicodeString.Length = 0;
    unicodeString.MaximumLength = maxStringLength;

    ntStatus = RtlAnsiStringToUnicodeString(
                   &unicodeString,
                   &ansiString,
                   FALSE
                   );

    if (ntStatus != STATUS_SUCCESS) {
        status = RtlNtStatusToDosError(ntStatus);
        goto error_exit;
    }

    *AddressString = addressString;

    return(ERROR_SUCCESS);

error_exit:

    if (allocatedStringBuffer) {
        LocalFree(addressString);
    }

    return(status);

}  // ClRtlTcpipAddressToString


DWORD
ClRtlTcpipStringToAddress(
    LPCWSTR AddressString,
    PULONG  AddressValue
    )
/*++

Routine Description:

    Converts a string representation of a TCP/IP network address
    into a binary representation in network byte order.  The string must
    be formatted in the canonical IP Address form (xxx.xxx.xxx.xxx).
    Leading zeros are optional.

Arguments:

    AddressString  - A pointer to the string to convert.

    AddressValue - A pointer to a variable into which to place the converted
                   binary value. The value will be in network byte order.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS        status;
    UNICODE_STRING  unicodeString;
    STRING          ansiString;
    ULONG           address;


    //
    // Make sure the string is formatted correctly.
    //
    {
        DWORD   periodCount = 0;
        DWORD   digitCount = 0;
        BOOLEAN isValid = TRUE;
        LPCWSTR addressString = AddressString;
        LPCWSTR digitString = AddressString;

        while (*addressString != L'\0') {
            if (*addressString == L'.') {
                // Character is a period.  There must be exactly
                // three periods.  There must be at least one
                // digit before each period.
                periodCount++;
                if ((digitCount == 0) || (periodCount > 3)) {
                    isValid = FALSE;
                } else if (wcstoul(digitString, NULL, 10) > 255) {
                    isValid = FALSE;
                } else {
                    digitCount = 0;
                    digitString = addressString + 1;
                }
            } else if (iswdigit(*addressString)) {
                // Character is a digit.  There can be up to three
                // decimal digits before each period, and the value
                // can not exceed 255.
                digitCount++;
                if (digitCount > 3) {
                    isValid = FALSE;
                }
            }
            else {
                // Character is not a digit.
                isValid = FALSE;
            }

            if (!isValid)
                break;
            addressString++;
        }
        if ((periodCount != 3) ||
            (digitCount == 0) ||
            (wcstoul(digitString, NULL, 10) > 255)) {
            isValid = FALSE;
        }
        if (!isValid)
            return(ERROR_INVALID_PARAMETER);
    }

    RtlInitUnicodeString(&unicodeString, AddressString);

    status = RtlUnicodeStringToAnsiString(
                 &ansiString,
                 &unicodeString,
                 TRUE
                 );

    if (status == STATUS_SUCCESS) {
        address = inet_addr(ansiString.Buffer);

        RtlFreeAnsiString(&ansiString);

        if (address == INADDR_NONE) {
           if (lstrcmpW(AddressString, L"255.255.255.255") != 0) {
               return(ERROR_INVALID_PARAMETER);
           }
        }

        *AddressValue = address;

        return(ERROR_SUCCESS);
    }

    return(status);

}  // ClRtlTcpipStringToAddress


DWORD
ClRtlTcpipEndpointToString(
    USHORT    EndpointValue,
    LPWSTR *  EndpointString
    )
/*++

Routine Description:

    Converts a binary representation of a TCP/IP transport endpoint,
    in network byte order, into a string representation.

Arguments:

     EndpointValue - The binary value, in network byte order, to convert.

     EndpointString - A pointer to a pointer to a unicode string buffer into
                      which to place the converted value. If this parameter
                      is NULL, the string buffer will be allocated and
                      must be freed by the caller.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD              status;
    NTSTATUS           ntStatus;
    ULONG              endpointValue;
    LPWSTR             endpointString;
    USHORT             maxStringLength =  (MAX_ENDPOINT_STRING_LENGTH + 1) *
                                          sizeof(WCHAR);


    if (*EndpointString == NULL) {
        endpointString = LocalAlloc(LMEM_FIXED, maxStringLength);

        if (endpointString == NULL) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        *EndpointString = endpointString;
    }
    else {
        endpointString = *EndpointString;
    }

    endpointValue = 0;
    endpointValue = ntohs(EndpointValue);

    _ultow( endpointValue, endpointString, 10);

    return(ERROR_SUCCESS);

}  // ClRtlTcpipEndpointToString


DWORD
ClRtlTcpipStringToEndpoint(
    LPCWSTR  EndpointString,
    PUSHORT  EndpointValue
    )
/*++

Routine Description:

    Converts a string representation of a TCP/IP transport endpoint
    into a binary representation in network byte order.

Arguments:

    EndpointString  - A pointer to the string to convert.

    EndpointValue - A pointer to a variable into which to place the converted
                    binary value. The value will be in network byte order.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    ULONG   endpoint;
    DWORD   length = lstrlenW(EndpointString);


    if ( (length == 0) || (length > MAX_ENDPOINT_STRING_LENGTH) ) {
        return(ERROR_INCORRECT_ADDRESS);
    }

    endpoint = wcstoul(EndpointString, NULL, 10);

    if (endpoint > 0xFFFF) {
        return(ERROR_INCORRECT_ADDRESS);
    }

    *EndpointValue = (USHORT) htons( ((USHORT) endpoint) );

    return(ERROR_SUCCESS);

}  // ClRtlTcpipStringToEndpoint


BOOL
ClRtlIsValidTcpipAddress(
    IN ULONG   Address
    )
{

    //
    // Convert to little-endian format, since that is what the broken
    // winsock macros require.
    //
    Address = ntohl(Address);

    if ( (Address == 0) ||
         (!IN_CLASSA(Address) && !IN_CLASSB(Address) && !IN_CLASSC(Address))
       )
    {
        return(FALSE);
    }

    return(TRUE);

} // ClRtlIsValidTcpipAddress



BOOL
ClRtlIsValidTcpipSubnetMask(
    IN ULONG   SubnetMask
    )
{

    if ( (SubnetMask == 0xffffffff) || (SubnetMask == 0)) {
        return(FALSE);
    }

    return(TRUE);

} // ClRtlIsValidTcpipSubnetMask

BOOL
ClRtlIsValidTcpipAddressAndSubnetMask(
    IN ULONG   Address,
    IN ULONG   SubnetMask
    )
{
    ULONG NetOnly = Address & SubnetMask;
    ULONG HostOnly = Address & ~SubnetMask;

    //
    // make sure the address/subnet combination makes sense.
    // This assumes that the address has already been validated
    // by a call to ClRtlIsValidTcpipAddress
    //

    return !( NetOnly == 0            ||
              NetOnly == SubnetMask   ||
              HostOnly == 0           ||
              HostOnly == ~SubnetMask
            );

} // ClRtlIsValidTcpipAddressAndSubnetMask


DWORD
ClRtlBuildTcpipTdiAddress(
    IN  LPWSTR    NetworkAddress,
    IN  LPWSTR    TransportEndpoint,
    OUT LPVOID *  TdiAddress,
    OUT LPDWORD   TdiAddressLength
    )
/*++

Routine Description:

    Builds a TDI Transport Address structure containing the specified
    NetworkAddress and TransportEndpoint. The memory for the TDI address
    is allocated by this routine and must be freed by the caller.

Arguments:

    NetworkAddress - A pointer to a unicode string containing the
                     network address to encode.

    TransportEndpoint - A pointer to a unicode string containing the
                        transport endpoint to encode.

    TdiAddress - On output, contains the address of the TDI Transport
                 Address structure.

    TdiAddressLength - On output, contains the length of the TDI Transport
                       address structure.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    PTA_IP_ADDRESS          taIpAddress;
    ULONG                   ipAddress;
    USHORT                  udpPort;


    status = ClRtlTcpipStringToAddress(NetworkAddress, &ipAddress);

    if (status != ERROR_SUCCESS) {
        return(status);
    }

    status = ClRtlTcpipStringToEndpoint(TransportEndpoint, &udpPort);

    if (lstrlenW(TransportEndpoint) > MAX_ENDPOINT_STRING_LENGTH) {
        return(ERROR_INCORRECT_ADDRESS);
    }

    if (status != ERROR_SUCCESS) {
        return(status);
    }

    taIpAddress = LocalAlloc(LMEM_FIXED, sizeof(TA_IP_ADDRESS));

    if (taIpAddress == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(taIpAddress, sizeof(TA_IP_ADDRESS));

    taIpAddress->TAAddressCount = 1;
    taIpAddress->Address[0].AddressLength = sizeof(TDI_ADDRESS_IP);
    taIpAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    taIpAddress->Address[0].Address[0].in_addr = ipAddress;
    taIpAddress->Address[0].Address[0].sin_port = udpPort;

    *TdiAddress = taIpAddress;
    *TdiAddressLength = sizeof(TA_IP_ADDRESS);

    return(ERROR_SUCCESS);

}  // ClRtlBuildTcpipTdiAddress


DWORD
ClRtlBuildLocalTcpipTdiAddress(
    IN  LPWSTR    NetworkAddress,
    OUT LPVOID    TdiAddress,
    OUT LPDWORD   TdiAddressLength
    )
/*++

Routine Description:

    Builds a TDI Transport Address structure which can be used to open
    a local TDI Address Object. The TransportEndpoint is chosen by the
    transport. The memory for the TDI address is allocated by this
    routine and must be freed by the caller.

Arguments:

    NetworkAddress - A pointer to a unicode string containing the
                     network address to encode.

    TdiAddress - On output, contains the address of the TDI Transport
                 Address structure.

    TdiAddressLength - On output, contains the length of the TDI Transport
                       address structure.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{

    return(ClRtlBuildTcpipTdiAddress(
               NetworkAddress,
               L"0",
               TdiAddress,
               TdiAddressLength
               ));

}  // ClRtlBuildLocalTcpipTdiAddress


DWORD
ClRtlParseTcpipTdiAddress(
    IN  LPVOID    TdiAddress,
    OUT LPWSTR *  NetworkAddress,
    OUT LPWSTR *  TransportEndpoint
    )
/*++

Routine Description:

    Extracts the NetworkAddress and TransportEndpoint values from
    a TDI address.

Arguments:

    TdiAddress - A pointer to the TDI TRANSPORT_ADDRESS structure to parse.

    NetworkAddress - A pointer to a pointer to a unicode string into which
                     the parsed network address will be placed. If this
                     parameter is NULL, the target string buffer will be
                     allocated and must be freed by the caller.

    TransportEndpoint - A pointer to a pointer to a unicode string into
                        which the parsed transport endpoint will be placed.
                        If this parameter is NULL, the target string buffer
                        will be allocated and must be freed by the caller.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    LONG                        i;
    TA_ADDRESS *                currentAddr;
    TDI_ADDRESS_IP UNALIGNED *  validAddr = NULL;
    PTRANSPORT_ADDRESS          addrList = TdiAddress;
    DWORD                       status;
    BOOLEAN                     allocatedAddressString = FALSE;


    currentAddr = (TA_ADDRESS *)addrList->Address;

    for (i = 0; i < addrList->TAAddressCount; i++) {
        if (currentAddr->AddressType == TDI_ADDRESS_TYPE_IP) {
            if (currentAddr->AddressLength >= TDI_ADDRESS_LENGTH_IP) {
                validAddr = (TDI_ADDRESS_IP UNALIGNED *) currentAddr->Address;
                break;

            }
        } else {
            currentAddr = (TA_ADDRESS *)(currentAddr->Address +
                currentAddr->AddressLength);
        }
    }

    if (validAddr == NULL) {
        return(ERROR_INCORRECT_ADDRESS);
    }

    if (NetworkAddress == NULL) {
        allocatedAddressString = TRUE;
    }

    status = ClRtlTcpipAddressToString(
                 validAddr->in_addr,
                 NetworkAddress
                 );

    if (status != ERROR_SUCCESS) {
        return(status);
    }

    status = ClRtlTcpipEndpointToString(
                 validAddr->sin_port,
                 TransportEndpoint
                 );

    if (status != ERROR_SUCCESS) {
        if (allocatedAddressString) {
            LocalFree(*NetworkAddress);
            *NetworkAddress = NULL;
        }

        return(status);
    }

    return(ERROR_SUCCESS);

}  // ClRtlParseTcpipTdiAddress


DWORD
ClRtlParseTcpipTdiAddressInfo(
    IN  LPVOID    TdiAddressInfo,
    OUT LPWSTR *  NetworkAddress,
    OUT LPWSTR *  TransportEndpoint
    )
/*++

Routine Description:

    Extracts the NetworkAddress and TransportEndpoint values from
    a TDI_ADDRESS_INFO structure.

Arguments:

    TdiAddressInfo - A pointer to the TDI_ADDRESS_INFO  structure to parse.

    NetworkAddress - A pointer to a pointer to a unicode string into which
                     the parsed network address will be placed. If this
                     parameter is NULL, the target string buffer will be
                     allocated and must be freed by the caller.

    TransportEndpoint - A pointer to a pointer to a unicode string into
                        which the parsed transport endpoint will be placed.
                        If this parameter is NULL, the target string buffer
                        will be allocated and must be freed by the caller.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD status;
    PTDI_ADDRESS_INFO   addressInfo = TdiAddressInfo;


    status = ClRtlParseTcpipTdiAddress(
                 &(addressInfo->Address),
                 NetworkAddress,
                 TransportEndpoint
                 );

    return(status);

}  // ClRtlParseTcpipTdiAddressInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\threadq.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   threadq.c

Abstract:

    Generic Worker Thread Queue Package

Author:

    Mike Massa (mikemas)           April 5, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     04-05-96    created

Notes:

    Worker Thread Queues provide a single mechanism for processing
    overlapped I/O completions as well as deferred work items. Work
    queues are created and destroyed using ClRtlCreateWorkQueue()
    and ClRtlDestroyWorkQueue(). Overlapped I/O completions are
    directed to a work queue by associating an I/O handle with a work
    queue using ClRtlAssociateIoHandleWorkQueue(). Deferred work items
    are posted to a work queue using ClRtlPostItemWorkQueue().

    Work queues are implemented using I/O completion ports. Each work
    queue is serviced by a set of threads which dispatch work items
    to specified work routines. Threads are created dynamically, up to
    a specified maximum, to ensure that there is always a thread waiting
    to service new work items. The priority of the threads servicing a
    work queue can be specified.

    [Future enhancement: dynamically shrink the thread pool when the
    incoming work rate drops off. Currently, threads continue to service
    the work queue until it is destroyed.]

    Special care must be taken when destroying a work queue to ensure
    that all threads terminate properly and no work items are lost.
    See the notes under ClRtlDestroyWorkQueue.

--*/

#include "clusrtlp.h"


//
// Private Types
//
typedef struct _CLRTL_WORK_QUEUE {
    HANDLE    IoCompletionPort;
    LONG      MaximumThreads;
    LONG      TotalThreads;
    LONG      WaitingThreads;
    LONG      ReserveThreads;
    LONG      ConcurrentThreads;
    DWORD     Timeout;
    int       ThreadPriority;
    HANDLE    StopEvent;
} CLRTL_WORK_QUEUE;


//
// Private Routines
//
DWORD
ClRtlpWorkerThread(
    LPDWORD  Context
    )
{
    PCLRTL_WORK_QUEUE       workQueue = (PCLRTL_WORK_QUEUE) Context;
    DWORD                   bytesTransferred;
    BOOL                    ioSuccess;
    ULONG_PTR               ioContext;
    LPOVERLAPPED            overlapped;
    PCLRTL_WORK_ITEM        workItem;
    DWORD                   status;
    LONG                    interlockedResult;
    DWORD                   threadId;
    HANDLE                  threadHandle;
    DWORD                   timeout;
    LONG                    myThreadId;


    timeout = workQueue->Timeout;
    myThreadId = GetCurrentThreadId();

    if (!SetThreadPriority(GetCurrentThread(), workQueue->ThreadPriority)) {
        status = GetLastError();

        ClRtlLogPrint(
            LOG_UNUSUAL,
            "[WTQ] Thread %1!u! unable to set priority to %2!d!, status %3!u!\n",
            myThreadId,
            workQueue->ThreadPriority,
            status
            );
    }

#if THREADQ_VERBOSE
    ClRtlLogPrint(
        LOG_CRITICAL,
        "[WTQ] Thread %1!u! started, queue %2!lx!.\n",
        myThreadId,
        workQueue
        );
#endif

    while (TRUE) {

        InterlockedIncrement(&(workQueue->WaitingThreads));

        ioSuccess = GetQueuedCompletionStatus(
                        workQueue->IoCompletionPort,
                        &bytesTransferred,
                        &ioContext,
                        &overlapped,
                        timeout
                        );

        interlockedResult = InterlockedDecrement(
                                &(workQueue->WaitingThreads)
                                );

        if (overlapped) {
            //
            // Something was dequeued.
            //
            workItem = CONTAINING_RECORD(
                           overlapped,
                           CLRTL_WORK_ITEM,
                           Overlapped
                           );

            if (interlockedResult == 0) {
                //
                // No more threads are waiting. Fire another one up.
                // Make sure we haven't started too many first.
                //
                interlockedResult = InterlockedDecrement(
                                        &(workQueue->ReserveThreads)
                                        );

                if (interlockedResult > 0) {
                    //
                    // We haven't started too many
                    //

#if THREADQ_VERBOSE
                    ClRtlLogPrint(
                        LOG_NOISE,
                        "[WTQ] Thread %1!u! starting another thread for queue %2!lx!.\n",
                        myThreadId,
                        workQueue
                        );
#endif // 0

                    InterlockedIncrement(&(workQueue->TotalThreads));

                    threadHandle = CreateThread(
                                       NULL,
                                       0,
                                       ClRtlpWorkerThread,
                                       workQueue,
                                       0,
                                       &threadId
                                       );

                    if (threadHandle == NULL) {
                        InterlockedDecrement(&(workQueue->TotalThreads));
                        InterlockedIncrement(&(workQueue->ReserveThreads));

                        status = GetLastError();

                        ClRtlLogPrint(
                            LOG_CRITICAL,
                            "[WTQ] Thread %1!u! failed to create thread, %2!u!\n",
                            myThreadId,
                            status
                            );
                    }
                    else {
                        CloseHandle(threadHandle);
                    }
                }
                else {
                    InterlockedIncrement(&(workQueue->ReserveThreads));
                }
            } // end if (interlockedResult == 0)

            if (ioSuccess) {
                (*(workItem->WorkRoutine))(
                    workItem,
                    ERROR_SUCCESS,
                    bytesTransferred,
                    ioContext
                    );
            }
            else {
                //
                // The item was posted with an error.
                //
                status = GetLastError();

                (*(workItem->WorkRoutine))(
                    workItem,
                    status,
                    bytesTransferred,
                    ioContext
                    );
            }

            continue;
        }
        else {
            //
            // No item was dequeued
            //
            if (ioSuccess) {
                //
                // This is our cue to start the termination process.
                // Set the timeout to zero to make sure we don't block
                // after the port is drained.
                //
                timeout = 0;
#if THREADQ_VERBOSE
                ClRtlLogPrint(
                    LOG_NOISE,
                    "[WTQ] Thread %1!u! beginning termination process\n",
                    myThreadId
                    );
#endif // 0
            }
            else {
                status = GetLastError();

                if (status == WAIT_TIMEOUT) {
                    //
                    // No more items pending, time to exit.
                    //
                    CL_ASSERT(timeout == 0);

                    break;
                }

                CL_ASSERT(status == WAIT_TIMEOUT);

                ClRtlLogPrint(
                    LOG_CRITICAL,
                    "[WTQ] Thread %1!u! No item, strange status %2!u! on queue %3!lx!\n",
                    myThreadId,
                    status,
                    workQueue
                    );
            }
        } // end if (overlapped)
    } // end while(TRUE)

    CL_ASSERT(workQueue->TotalThreads > 0);
    InterlockedIncrement(&(workQueue->ReserveThreads));
    InterlockedDecrement(&(workQueue->TotalThreads));

#if THREADQ_VERBOSE
    ClRtlLogPrint(LOG_NOISE, "[WTQ] Thread %1!u! exiting.\n", myThreadId);
#endif // 0

    //
    // Let the ClRtlDestroyWorkQueue know we are terminating.
    //
    SetEvent(workQueue->StopEvent);

    return(ERROR_SUCCESS);
}


//
// Public Routines
//
PCLRTL_WORK_QUEUE
ClRtlCreateWorkQueue(
    IN DWORD  MaximumThreads,
    IN int    ThreadPriority
    )
/*++

Routine Description:

    Creates a work queue and a dynamic pool of threads to service it.

Arguments:

    MaximumThreads - The maximum number of threads to create to service
                     the queue.

    ThreadPriority - The priority level at which the queue worker threads
                     should run.

Return Value:

    A pointer to the created queue if the routine is successful.

    NULL if the routine fails. Call GetLastError for extended
    error information.

--*/
{
    DWORD               status;
    PCLRTL_WORK_QUEUE   workQueue = NULL;
    DWORD               threadId;
    HANDLE              threadHandle = NULL;
    HANDLE              bogusHandle = NULL;


    if (MaximumThreads == 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    bogusHandle = CreateFileW(
                      L"NUL",
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      FILE_FLAG_OVERLAPPED,
                      NULL
                      );


    if (bogusHandle == INVALID_HANDLE_VALUE) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[WTQ] bogus file creation failed, %1!u!\n", status);
        return(NULL);
    }

    workQueue = LocalAlloc(
                    LMEM_FIXED | LMEM_ZEROINIT,
                    sizeof(CLRTL_WORK_QUEUE)
                    );

    if (workQueue == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    workQueue->MaximumThreads = MaximumThreads;
    workQueue->TotalThreads = 1;
    workQueue->WaitingThreads = 0;
    workQueue->ReserveThreads = MaximumThreads - 1;
    workQueue->ConcurrentThreads = 0;
    workQueue->Timeout = INFINITE;
    workQueue->ThreadPriority = ThreadPriority;

    workQueue->IoCompletionPort = CreateIoCompletionPort(
                                      bogusHandle,
                                      NULL,
                                      0,
                                      workQueue->ConcurrentThreads
                                      );

    CloseHandle(bogusHandle); bogusHandle = NULL;

    if (workQueue->IoCompletionPort == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[WTQ] Creation of I/O Port failed, %1!u!\n", status);
    }

    workQueue->StopEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (workQueue->StopEvent == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[WTQ] Creation of stop event failed, %1!u!\n", status);
        goto error_exit;
    }

    threadHandle = CreateThread(
                       NULL,
                       0,
                       ClRtlpWorkerThread,
                       workQueue,
                       0,
                       &threadId
                       );

    if (threadHandle == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[WTQ] Failed to create worker thread, %1!u!\n", status);
        goto error_exit;
    }

    CloseHandle(threadHandle);

    return(workQueue);


error_exit:

    if (bogusHandle != NULL) {
        CloseHandle(bogusHandle);
    }

    if (workQueue != NULL) {
        if (workQueue->IoCompletionPort != NULL) {
            CloseHandle(workQueue->IoCompletionPort);
        }

        if (workQueue->StopEvent != NULL) {
            CloseHandle(workQueue->StopEvent);
        }

        LocalFree(workQueue);
    }

    SetLastError(status);

    return(NULL);
}


VOID
ClRtlDestroyWorkQueue(
    IN PCLRTL_WORK_QUEUE  WorkQueue
    )
/*++

Routine Description:

    Destroys a work queue and its thread pool.

Arguments:

    WorkQueue  - The queue to destroy.

Return Value:

    None.

Notes:

    The following rules must be observed in order to safely destroy a
    work queue:

        1) No new work items may be posted to the queue once all previously
           posted items have been processed by this routine.

        2) WorkRoutines must be able to process items until this
           call returns. After the call returns, no more items will
           be delivered from the specified queue.

    One workable cleanup procedure is as follows: First, direct the
    WorkRoutines to silently discard completed items. Next, eliminate
    all sources of new work. Finally, destroy the work queue. Note that
    when in discard mode, the WorkRoutines may not access any structures
    which will be destroyed by eliminating the sources of new work.

--*/
{
    BOOL   posted;
    DWORD  status;


#if THREADQ_VERBOSE
    ClRtlLogPrint(LOG_NOISE, "[WTQ] Destroying work queue %1!lx!\n", WorkQueue);
#endif // 0


    while (WorkQueue->TotalThreads != 0) {
#if THREADQ_VERBOSE
        ClRtlLogPrint(
            LOG_NOISE,
            "[WTQ] Destroy: Posting terminate item, thread cnt %1!u!\n",
            WorkQueue->TotalThreads
            );
#endif // 0

        posted = PostQueuedCompletionStatus(
                     WorkQueue->IoCompletionPort,
                     0,
                     0,
                     NULL
                     );

        if (!posted) {
            status = GetLastError();

            ClRtlLogPrint(
                LOG_CRITICAL,
                "[WTQ] Destroy: Failed to post termination item, %1!u!\n",
                status
                );

            CL_ASSERT(status == ERROR_SUCCESS);

            break;
        }
#if THREADQ_VERBOSE
        ClRtlLogPrint(LOG_NOISE, "[WTQ] Destroy: Waiting for a thread to terminate.\n");
#endif // 0

        status = WaitForSingleObject(WorkQueue->StopEvent, INFINITE);

        CL_ASSERT(status == WAIT_OBJECT_0);

#if THREADQ_VERBOSE
        ClRtlLogPrint(LOG_NOISE, "[WTQ] Destroy: A thread terminated.\n");
#endif // 0
    }

    CloseHandle(WorkQueue->IoCompletionPort);
    CloseHandle(WorkQueue->StopEvent);

    LocalFree(WorkQueue);

#if THREADQ_VERBOSE
    ClRtlLogPrint(LOG_NOISE, "[WTQ] Work queue %1!lx! destroyed\n", WorkQueue);
#endif // 0

    return;
}


DWORD
ClRtlPostItemWorkQueue(
    IN PCLRTL_WORK_QUEUE  WorkQueue,
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
/*++

Routine Description:

    Posts a specified work item to a specified work queue.

Arguments:

    WorkQueue         - A pointer to the work queue to which to post the item.

    WorkItem          - A pointer to the item to post.

    BytesTransferred  - If the work item represents a completed I/O operation,
                        this parameter contains the number of bytes
                        transferred during the operation. For other work items,
                        the semantics of this parameter may be defined by
                        the caller.

    IoContext         - If the work item represents a completed I/O operation,
                        this parameter contains the context value associated
                        with the handle on which the operation was submitted.
                        Of other work items, the semantics of this parameter
                        may be defined by the caller.

Return Value:

    ERROR_SUCCESS if the item was posted successfully.
    A Win32 error code if the post operation fails.

--*/
{
    BOOL  posted;

    posted = PostQueuedCompletionStatus(
                 WorkQueue->IoCompletionPort,
                 BytesTransferred,
                 IoContext,
                 &(WorkItem->Overlapped)
                 );

    if (posted) {
        return(ERROR_SUCCESS);
    }

    return(GetLastError());
}


DWORD
ClRtlAssociateIoHandleWorkQueue(
    IN PCLRTL_WORK_QUEUE  WorkQueue,
    IN HANDLE             IoHandle,
    IN ULONG_PTR          IoContext
    )
/*++

Routine Description:

    Associates a specified I/O handle, opened for overlapped I/O
    completion, with a work queue. All pending I/O operations on
    the specified handle will be posted to the work queue when
    completed. An initialized CLRTL_WORK_ITEM must be used to supply
    the OVERLAPPED structure whenever an I/O operation is submitted on
    the specified handle.

Arguments:

    WorkQueue     - The work queue with which to associate the I/O handle.

    IoHandle      - The I/O handle to associate.

    IoContext     - A context value to associate with the specified handle.
                    This value will be supplied as a parameter to the
                    WorkRoutine which processes completions for this
                    handle.

Return Value:

    ERROR_SUCCESS if the association completes successfully.
    A Win32 error code if the association fails.

--*/
{
    HANDLE   portHandle;


    portHandle = CreateIoCompletionPort(
                     IoHandle,
                     WorkQueue->IoCompletionPort,
                     IoContext,
                     WorkQueue->ConcurrentThreads
                     );

    if (portHandle != NULL) {
        CL_ASSERT(portHandle == WorkQueue->IoCompletionPort);

        return(ERROR_SUCCESS);
    }

    return(GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\ext\mfcapwz\inc\customaw.h ===
#ifndef __CUSTOMAW_H__
#define __CUSTOMAW_H__

/////////////////////////////////////////////////////////////////////////////
// customaw.h -- Header file to be included by all custom AppWizards.

// Link to the AppWizard import library
#pragma comment(lib, "mfcapwz.lib")

/////////////////////////////////////////////////////////////////////////////
// Class CAppWizStepDlg-- all custom AppWizard steps must derive from
//  this class

class CAppWizStepDlg : public CDialog
{
public:
	CAppWizStepDlg(UINT nIDTemplate);
	~CAppWizStepDlg();
	virtual BOOL OnDismiss();

	// You will probably not want to override or call this function.  It is
	//  overriden (for CAppWizStepDlg) in MFCAPWZ.DLL to handle tabbing from
	//  the dialog controls in CAppWizStepDlg to the outer AppWizard dialog's
	//  controls.
    virtual BOOL PreTranslateMessage(MSG* pMsg);


	// You will probably not want to override or call this function.  It is
	//  overriden (for CAppWizStepDlg) in MFCAPWZ.DLL to dynamically change
	//  the dialog template's font to match the rest of the IDE.
	virtual BOOL Create(UINT nIDTemplate, CWnd* pParentWnd = NULL);

	UINT m_nIDTemplate;
};


/////////////////////////////////////////////////////////////////////////////
// class OutputStream-- this abstract class is used to funnel output while
//  parsing templates.

class OutputStream
{
public:
    virtual void WriteLine(LPCTSTR lpsz) = 0;
    virtual void WriteBlock(LPCTSTR pBlock, DWORD dwSize) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// Class CCustomAppWiz-- all custom AppWizards must have a class derived from
//  this.  MFCAPWZ.DLL talks to the custom AppWizard by calling these virtual
//  functions.

class CCustomAppWiz : public CObject
{
public:
	CMapStringToString m_Dictionary;

	virtual void GetPlatforms(CStringList& rPlatforms) {}

	virtual CAppWizStepDlg* Next(CAppWizStepDlg* pDlg) { return NULL; }
	virtual CAppWizStepDlg* Back(CAppWizStepDlg* pDlg) { return NULL; }

	virtual void InitCustomAppWiz() { m_Dictionary.RemoveAll(); }
	virtual void ExitCustomAppWiz() {}

	virtual LPCTSTR LoadTemplate(LPCTSTR lpszTemplateName,
		DWORD& rdwSize, HINSTANCE hInstance = NULL);

	virtual void CopyTemplate(LPCTSTR lpszInput, DWORD dwSize, OutputStream* pOutput);
	virtual void ProcessTemplate(LPCTSTR lpszInput, DWORD dwSize, OutputStream* pOutput);
	virtual void PostProcessTemplate(LPCTSTR szTemplate) {}
};


/////////////////////////////////////////////////////////////////////////////
// C API's exported by AppWizard.  The custom AppWizard talks to MFCAPWZ.DLL
//  by calling these functions.

// Values to be passed to GetDialog()
enum AppWizDlgID
{
	APWZDLG_APPTYPE = 1,
	APWZDLG_DATABASE,
	APWZDLG_OLE,
	APWZDLG_DOCAPPOPTIONS,
	APWZDLG_PROJOPTIONS,
	APWZDLG_CLASSES,
	APWZDLG_DLGAPPOPTIONS,
	APWZDLG_DLLPROJOPTIONS,
};

void SetCustomAppWizClass(CCustomAppWiz* pAW);
CAppWizStepDlg* GetDialog(AppWizDlgID nID);
void SetNumberOfSteps(int nSteps);
BOOL ScanForAvailableLanguages(CStringList& rLanguages);
void SetSupportedLanguages(LPCTSTR szSupportedLangs);


#endif //__CUSTOMAW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clussprt\rpc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rpc.c

Abstract:

    Handy utility functions for supporting RPC

Author:

    Sunita Shrivastava (sunitas) 22-Jan-1997

Revision History:

--*/
#include "rpc.h"

void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(LocalAlloc(LMEM_FIXED, len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    LocalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\ext\atlsnap\inc\atlsnap.cpp ===
void __cdecl operator delete(void* p)
{
	_free_dbg(p, _NORMAL_BLOCK);
}

void* __cdecl operator new(size_t nSize, LPCSTR lpszFileName, int nLine)
{
	return _malloc_dbg(nSize, _NORMAL_BLOCK, lpszFileName, nLine);
}
#include <atlsnap.h>

const IID IID_ISnapInDataInterface = {0x1FABD781,0xECDA,0x11D0,{0xAA,0xCE,0x00,0xAA,0x00,0xC0,0x01,0x89}};

const UINT CSnapInBaseData::m_CCF_NODETYPE			= RegisterClipboardFormat(CCF_NODETYPE);;
const UINT CSnapInBaseData::m_CCF_SZNODETYPE		= RegisterClipboardFormat(CCF_SZNODETYPE);  
const UINT CSnapInBaseData::m_CCF_DISPLAY_NAME		= RegisterClipboardFormat(CCF_DISPLAY_NAME); 
const UINT CSnapInBaseData::m_CCF_SNAPIN_CLASSID	= RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
const UINT CSnapInBaseData::m_CCF_SCOPEDATAITEM	= RegisterClipboardFormat(_T("CCF_SCOPEDATAITEM"));
const UINT CSnapInBaseData::m_CCF_RESULTDATAITEM = RegisterClipboardFormat(_T("CCF_RESULTDATAITEM"));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\ext\atlsnap\inc\atlsnap.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATL_SNAPIN_H__
#define __ATL_SNAPIN_H__

#ifndef UNICODE
#error "Only Unicode builds supported"
#endif

#include <mmc.h>
#include <commctrl.h>
#pragma comment(lib, "mmc.lib")


// Wrappers for propertypage
#pragma comment(lib, "comctl32.lib")

template <class T>
class ATL_NO_VTABLE CSnapInPropertyPageImpl : public CDialogImplBase
{
public:
	PROPSHEETPAGE m_psp;

	operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
	CSnapInPropertyPageImpl(LPCTSTR lpszTitle = NULL)
	{
		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK;
		m_psp.hInstance = _Module.GetResourceInstance();
		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = (DLGPROC)T::StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
		m_psp.lParam = (LPARAM)this;

		if(lpszTitle != NULL)
		{
			m_psp.pszTitle = lpszTitle;
			m_psp.dwFlags |= PSP_USETITLE;
		}
	}

	static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
	{
		if(uMsg == PSPCB_CREATE)
		{
			ATLASSERT(hWnd == NULL);
			CDialogImplBase* pPage = (CDialogImplBase*)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}

		return 1;
	}

	HPROPSHEETPAGE Create()
	{
		return ::CreatePropertySheetPage(&m_psp);
	}

	BOOL EndDialog(int)
	{
		// do nothing here, calling ::EndDialog will close the whole sheet
		ATLASSERT(FALSE);
		return FALSE;
	}

// Operations
	void CancelToClose()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		::SendMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
	}
	void SetModified(BOOL bChanged = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		if(bChanged)
			::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
		else
			::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0L);
	}
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		return ::SendMessage(GetParent(), PSM_QUERYSIBLINGS, wParam, lParam);
	}

	BEGIN_MSG_MAP(CSnapInPropertyPageImpl< T >)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	END_MSG_MAP()

// Message handler
	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		NMHDR* pNMHDR = (NMHDR*)lParam;

		// don't handle messages not from the page/sheet itself
		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		{
			bHandled = FALSE;
			return 1;
		}

		T* pT = (T*)this;
		LRESULT lResult = 0;
		// handle default
		switch(pNMHDR->code)
		{
		case PSN_SETACTIVE:
			lResult = pT->OnSetActive() ? 0 : -1;
			break;
		case PSN_KILLACTIVE:
			lResult = !pT->OnKillActive();
			break;
		case PSN_APPLY:
			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
			break;
		case PSN_RESET:
			pT->OnReset();
			break;
		case PSN_QUERYCANCEL:
			lResult = !pT->OnQueryCancel();
			break;
		case PSN_WIZNEXT:
			lResult = !pT->OnWizardNext();
			break;
		case PSN_WIZBACK:
			lResult = !pT->OnWizardBack();
			break;
		case PSN_WIZFINISH:
			lResult = !pT->OnWizardFinish();
			break;
		case PSN_HELP:
			lResult = pT->OnHelp();
			break;
		default:
			bHandled = FALSE;	// not handled
		}

		return lResult;
	}

// Overridables
	BOOL OnSetActive()
	{
		return TRUE;
	}
	BOOL OnKillActive()
	{
		return TRUE;
	}
	BOOL OnApply()
	{
		return TRUE;
	}
	void OnReset()
	{
	}
	BOOL OnQueryCancel()
	{
		return TRUE;    // ok to cancel
	}
	BOOL OnWizardBack()
	{
		return TRUE;
	}
	BOOL OnWizardNext()
	{
		return TRUE;
	}
	BOOL OnWizardFinish()
	{
		return TRUE;
	}
	BOOL OnHelp()
	{
		return TRUE;
	}

#if _ATL_VER < 0x0300
	//Overridden to reference overridden DialogProc
	static LRESULT CALLBACK StartDialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		CSnapInPropertyPageImpl< T >* pThis = (CSnapInPropertyPageImpl< T >*)_Module.ExtractCreateWndData();
		ATLASSERT(pThis != NULL);
		pThis->m_hWnd = hWnd;
		pThis->m_thunk.Init(DialogProc, pThis);
		WNDPROC pProc = (WNDPROC)&(pThis->m_thunk.thunk);
		WNDPROC pOldProc;
		pOldProc = (WNDPROC)::SetWindowLongPtr(hWnd, DWLP_DLGPROC, (LONG_PTR)pProc);
	#ifdef _DEBUG
		// check if somebody has subclassed us already since we discard it
		if(pOldProc != StartDialogProc)
			ATLTRACE(_T("ATL: Subclassing through a hook discarded.\n"));
	#endif
		return pProc(hWnd, uMsg, wParam, lParam);
	}

	// Overriden for handling WM_NCDESTROY correctly
	static LRESULT CALLBACK DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
#ifdef _M_IX86
	__asm mov dword ptr[hWnd], ecx
#endif
		CSnapInPropertyPageImpl< T >* pThis = (CSnapInPropertyPageImpl< T >*)hWnd;
		LRESULT lRes;
		if(pThis->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, 0))
		{
			switch (uMsg)
			{
			case WM_COMPAREITEM:
			case WM_VKEYTOITEM:
			case WM_CHARTOITEM:
			case WM_INITDIALOG:
			case WM_QUERYDRAGICON:
			case WM_CTLCOLORMSGBOX:
			case WM_CTLCOLOREDIT:
			case WM_CTLCOLORLISTBOX:
			case WM_CTLCOLORBTN:
			case WM_CTLCOLORDLG:
			case WM_CTLCOLORSCROLLBAR:
			case WM_CTLCOLORSTATIC:
				return lRes;
				break;
			}
			::SetWindowLongPtr(pThis->m_hWnd, DWLP_MSGRESULT, lRes);
			return TRUE;
		}
		if(uMsg == WM_NCDESTROY)
		{
			// clear out window handle
			HWND hWnd = pThis->m_hWnd;
			pThis->m_hWnd = NULL;
			// clean up after dialog is destroyed
			pThis->OnFinalMessage(hWnd);
		}
		return FALSE;
	}
	virtual void OnFinalMessage(HWND hWnd)
	{
	};
#endif
};

#if _ATL_VER < 0x0300
// intended for small number of simple types or pointers
template <class TKey, class TVal>
class CSnapInSimpleMap
{
public:
	TKey* m_aKey;
	TVal* m_aVal;
	int m_nSize;

// Construction/destruction
	CSnapInSimpleMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
	{ }

	~CSnapInSimpleMap()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(TKey key, TVal val)
	{
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
		if(pKey == NULL)
			return FALSE;
		m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
		if(pVal == NULL)
			return FALSE;
		m_aVal = pVal;
		m_nSize++;
		SetAtIndex(m_nSize - 1, key, val);
		return TRUE;
	}
	BOOL Remove(TKey key)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		if(nIndex != (m_nSize - 1))
		{
			memmove((void*)&m_aKey[nIndex], (void*)&m_aKey[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TKey));
			memmove((void*)&m_aVal[nIndex], (void*)&m_aVal[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TVal));
		}
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
		if(pKey != NULL || m_nSize == 1)
			m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
		if(pVal != NULL || m_nSize == 1)
			m_aVal = pVal;
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_nSize > 0)
		{
			free(m_aKey);
			free(m_aVal);
			m_aKey = NULL;
			m_aVal = NULL;
			m_nSize = 0;
		}
	}
	BOOL SetAt(TKey key, TVal val)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		SetAtIndex(nIndex, key, val);
		return TRUE;
	}
	TVal Lookup(TKey key) const
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return NULL;	// must be able to convert
		return GetValueAt(nIndex);
	}
	TKey ReverseLookup(TVal val) const
	{
		int nIndex = FindVal(val);
		if(nIndex == -1)
			return NULL;	// must be able to convert
		return GetKeyAt(nIndex);
	}
	TKey& GetKeyAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aKey[nIndex];
	}
	TVal& GetValueAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aVal[nIndex];
	}

// Implementation
	void SetAtIndex(int nIndex, TKey& key, TVal& val)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_aKey[nIndex] = key;
		m_aVal[nIndex] = val;
	}
	int FindKey(TKey& key) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aKey[i] == key)
				return i;
		}
		return -1;	// not found
	}
	int FindVal(TVal& val) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aVal[i] == val)
				return i;
		}
		return -1;	// not found
	}
};
#endif

/*class CSnapInBitmap
{
public:
	HBITMAP m_hBitmap;

	CSnapInBitmap(HBITMAP hBitmap = NULL) : m_hBitmap(hBitmap)
	{ }
	~CSnapInBitmap()
	{
		if(m_hBitmap != NULL)
			DeleteObject();
	}

	CSnapInBitmap& operator=(HBITMAP hBitmap)
	{
		m_hBitmap = hBitmap;
		return *this;
	}

	void Attach(HBITMAP hBitmap)
	{
		m_hBitmap = hBitmap;
	}
	HBITMAP Detach()
	{
		HBITMAP hBitmap = m_hBitmap;
		m_hBitmap = NULL;
		return hBitmap;
	}

	operator HBITMAP() const { return m_hBitmap; }

	HBITMAP LoadBitmap(LPCTSTR lpszResourceName)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::LoadBitmap(_Module.GetResourceInstance(), lpszResourceName);
		return m_hBitmap;
	}
	HBITMAP LoadBitmap(UINT nIDResource)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(nIDResource));
		return m_hBitmap;
	}
	HBITMAP LoadOEMBitmap(UINT nIDBitmap) // for OBM_/OCR_/OIC_
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::LoadBitmap(NULL, MAKEINTRESOURCE(nIDBitmap));
		return m_hBitmap;
	}
	HBITMAP LoadMappedBitmap(UINT nIDBitmap, UINT nFlags = 0, LPCOLORMAP lpColorMap = NULL, int nMapSize = 0)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateMappedBitmap(_Module.GetResourceInstance(), nIDBitmap, (WORD)nFlags, lpColorMap, nMapSize);
		return m_hBitmap;
	}
	HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitcount, const void* lpBits)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateBitmap(nWidth, nHeight, nPlanes, nBitcount, lpBits);
		return m_hBitmap;
	}
	HBITMAP CreateBitmapIndirect(LPBITMAP lpBitmap)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateBitmapIndirect(lpBitmap);
		return m_hBitmap;
	}
	HBITMAP CreateCompatibleBitmap(HDC hDC, int nWidth, int nHeight)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateCompatibleBitmap(hDC, nWidth, nHeight);
		return m_hBitmap;
	}
	HBITMAP CreateDiscardableBitmap(HDC hDC, int nWidth, int nHeight)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateDiscardableBitmap(hDC, nWidth, nHeight);
		return m_hBitmap;
	}

	BOOL DeleteObject()
	{
		ATLASSERT(m_hBitmap != NULL);
		BOOL bRet = ::DeleteObject(m_hBitmap);
		if(bRet)
			m_hBitmap = NULL;
		return bRet;
	}

// Attributes
	int GetBitmap(BITMAP* pBitMap)
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::GetObject(m_hBitmap, sizeof(BITMAP), pBitMap);
	}
// Operations
	DWORD SetBitmapBits(DWORD dwCount, const void* lpBits)
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::SetBitmapBits(m_hBitmap, dwCount, lpBits);
	}
	DWORD GetBitmapBits(DWORD dwCount, LPVOID lpBits) const
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::GetBitmapBits(m_hBitmap, dwCount, lpBits);
	}
	BOOL SetBitmapDimension(int nWidth, int nHeight, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::SetBitmapDimensionEx(m_hBitmap, nWidth, nHeight, lpSize);
	}
	BOOL GetBitmapDimension(LPSIZE lpSize) const
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::GetBitmapDimensionEx(m_hBitmap, lpSize);
	}
};
*/
class CSnapInItem;

class CObjectData
{
public:
	CSnapInItem* m_pItem;
	DATA_OBJECT_TYPES m_type;
};

class ATL_NO_VTABLE CSnapInItem
{
public:
	virtual ~CSnapInItem()
	{
	}
    STDMETHOD(Notify)(MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type) = 0;

    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM  *pScopeDataItem) = 0;

    STDMETHOD(GetResultViewType)(LPOLESTR  *ppViewType,
        long  *pViewOptions) = 0;

    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM  *pResultDataItem) = 0;

    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long  *pInsertionAllowed,
		DATA_OBJECT_TYPES type) = 0;

    STDMETHOD(Command)(long lCommandID,		
		DATA_OBJECT_TYPES type) = 0;

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type) = 0;

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type) = 0;

    STDMETHOD(SetControlbar)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar,
		CSnapInSimpleMap<UINT, IUnknown*>* pToolbarMap) = 0;

    STDMETHOD(ControlbarNotify)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar,
		CSnapInSimpleMap<UINT, IUnknown*>* pToolbarMap,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		DATA_OBJECT_TYPES type) = 0;

    STDMETHOD(GetScopeData)(SCOPEDATAITEM  * *pScopeDataItem) = 0;

    STDMETHOD(GetResultData)(RESULTDATAITEM  * *pResultDataItem) = 0;

	STDMETHOD(FillData)(CLIPFORMAT cf,
		LPSTREAM pStream) = 0;

	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		_ASSERTE(0 && "Override this function in derived class");
	}

	static HRESULT GetDataClass(IDataObject* pDataObj, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType)
	{
		if (ppItem == NULL)
			return E_POINTER;
		if (pType == NULL)
			return E_POINTER;

		*ppItem = NULL;
		*pType = CCT_UNINITIALIZED;

		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
		FORMATETC formatetc = { m_CCF_SNAPIN_GETOBJECTDATA,
			NULL,
			DVASPECT_CONTENT,
			-1,
			TYMED_HGLOBAL
		};

		stgmedium.hGlobal = GlobalAlloc(0, sizeof(CObjectData));
		if (stgmedium.hGlobal == NULL)
			return E_OUTOFMEMORY;

		HRESULT hr = pDataObj->GetDataHere(&formatetc, &stgmedium);
		if (SUCCEEDED(hr))
		{
			CObjectData* pData = (CObjectData*)stgmedium.hGlobal;
			 *ppItem = pData->m_pItem;
			 *pType = pData->m_type;
		}
		
		GlobalFree(stgmedium.hGlobal);
		
		return hr;
	}


	virtual HRESULT STDMETHODCALLTYPE GetDataObject(IDataObject** pDataObj, DATA_OBJECT_TYPES type) = 0;

	static void Init()
	{
		m_CCF_NODETYPE			= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_NODETYPE"));
		m_CCF_SZNODETYPE		= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SZNODETYPE"));
		m_CCF_DISPLAY_NAME		= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_DISPLAY_NAME"));
		m_CCF_SNAPIN_CLASSID	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SNAPIN_CLASSID"));
		m_CCF_SNAPIN_GETOBJECTDATA	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_GETOBJECTDATA"));
	}
public:
	static CLIPFORMAT m_CCF_NODETYPE;
	static CLIPFORMAT m_CCF_SZNODETYPE;
	static CLIPFORMAT m_CCF_DISPLAY_NAME;
	static CLIPFORMAT m_CCF_SNAPIN_CLASSID;
	static CLIPFORMAT m_CCF_SNAPIN_GETOBJECTDATA;
};

class CSnapInObjectRoot
{
public:
	CComPtr <IControlbar> m_spControlbar;
	CSnapInSimpleMap <UINT, IUnknown*> m_toolbarMap;

	HRESULT GetDataClass(IDataObject* pDataObject, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType)
	{
		return CSnapInItem::GetDataClass(pDataObject, ppItem, pType);
	}
};

#define EXTENSION_SNAPIN_DATACLASS(dataClass) dataClass m_##dataClass;

#define BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(classname) \
	HRESULT GetDataClass(IDataObject* pDataObject, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType) \
	{ \
		if (ppItem == NULL) \
			return E_POINTER; \
		if (pType == NULL) \
			return E_POINTER; \
\
		*ppItem = NULL; \
\
		*pType = CCT_UNINITIALIZED; \
\
		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL }; \
		FORMATETC formatetc = { CSnapInItem::m_CCF_NODETYPE, \
			NULL, \
			DVASPECT_CONTENT, \
			-1, \
			TYMED_HGLOBAL \
		}; \
\
		stgmedium.hGlobal = GlobalAlloc(0, sizeof(GUID)); \
		if (stgmedium.hGlobal == NULL) \
			return E_OUTOFMEMORY; \
\
		HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium); \
		if (FAILED(hr)) \
		{ \
			GlobalFree(stgmedium.hGlobal); \
			return hr; \
		} \
\
		GUID guid; \
		memcpy(&guid, stgmedium.hGlobal, sizeof(GUID)); \
\
		GlobalFree(stgmedium.hGlobal); \
		hr = S_OK;

#define EXTENSION_SNAPIN_NODEINFO_ENTRY(dataClass) \
		if (IsEqualGUID(guid, *(GUID*)m_##dataClass.GetNodeType())) \
		{ \
			*ppItem = m_##dataClass.GetExtNodeObject(pDataObject, &m_##dataClass); \
			_ASSERTE(*ppItem != NULL); \
			(*ppItem)->InitDataClass(pDataObject, &m_##dataClass); \
			return hr; \
		}

#define END_EXTENSION_SNAPIN_NODEINFO_MAP() \
			return CSnapInItem::GetDataClass(pDataObject, ppItem, pType); \
	};

class ATL_NO_VTABLE CSnapInDataObjectImpl : public IDataObject,
	public CComObjectRoot
{
public:
	BEGIN_COM_MAP(CSnapInDataObjectImpl)
		COM_INTERFACE_ENTRY(IDataObject)
	END_COM_MAP()
	STDMETHOD(GetData)(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetData\n"));
	}

	STDMETHOD(GetDataHere)(FORMATETC* pformatetc, STGMEDIUM* pmedium)
	{
		ATLTRACE(_T("SnapInDataObjectImpl::GetDataHere\n"));
		if (pmedium == NULL)
			return E_POINTER;

		HRESULT hr = DV_E_TYMED;
		// Make sure the type medium is HGLOBAL
		if (pmedium->tymed == TYMED_HGLOBAL)
		{
			// Create the stream on the hGlobal passed in
			CComPtr<IStream> spStream;
			hr = CreateStreamOnHGlobal(pmedium->hGlobal, FALSE, &spStream);
			if (SUCCEEDED(hr))
				if (pformatetc->cfFormat == CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA)
				{
					hr = DV_E_CLIPFORMAT;
					ULONG uWritten;
					hr = spStream->Write(&m_objectData, sizeof(CObjectData), &uWritten);
				}
				else
					hr = m_objectData.m_pItem->FillData(pformatetc->cfFormat, spStream);
		}
		return hr;
	}

	STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::QueryGetData\n"));
	}
	STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetCanonicalFormatEtc\n"));
	}
	STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}
	STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::EnumFormatEtc\n"));
	}
	STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
		DWORD *pdwConnection)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}
	STDMETHOD(DUnadvise)(DWORD dwConnection)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetDatan\n"));
	}
	STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}

	CObjectData m_objectData;
};


template <class T, class Component>
class ATL_NO_VTABLE IComponentDataImpl : public IComponentData
{
public :
	IComponentDataImpl()
	{
		m_pNode = NULL;
	}

    STDMETHOD(Initialize)(LPUNKNOWN pUnknown)
	{
		ATLTRACE(_T("IComponentDataImpl::Initialize\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pUnknown != NULL);
		if (pUnknown == NULL)
			ATLTRACE(_T("IComponentData::Initialize called with pUnknown == NULL\n"));
		else
		{
			// review change to QI
			hr = S_OK;
			m_spConsole = pUnknown;
			if (m_spConsole == NULL)
			{
				ATLTRACE(_T("QI for IConsole failed\n"));
				hr = E_UNEXPECTED;
			}
		}

		return hr;
	}

	STDMETHOD(CreateComponent)(LPCOMPONENT *ppComponent)
	{
		ATLTRACE(_T("IComponentDataImpl::CreateComponent\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(ppComponent != NULL);
		if (ppComponent == NULL)
			ATLTRACE(_T("IComponentData::CreateComponent called with ppComponent == NULL\n"));
		else
		{
			*ppComponent = NULL;
			
			CComObject< Component >* pComponent;
			hr = CComObject< Component >::CreateInstance(&pComponent);
			ATLASSERT(SUCCEEDED(hr));
			if (FAILED(hr))
				ATLTRACE(_T("IComponentData::CreateComponent : Could not create IComponent object\n"));
			else			
				hr = pComponent->QueryInterface(IID_IComponent, (void**)ppComponent);
		}
		return hr;
	}


    STDMETHOD(Notify)(
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
	{
		ATLTRACE(_T("IComponentDataImpl::Notify\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(lpDataObject != NULL);
		if (lpDataObject == NULL)
			ATLTRACE(_T("IComponentData::Notify called with lpDataObject == NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->GetDataClass(lpDataObject, &pItem, &type);
			ATLASSERT(SUCCEEDED(hr));
			if (SUCCEEDED(hr))
				hr = pItem->Notify(event, arg, param, pT, NULL, type);
		}
		return hr;
	}

    STDMETHOD(Destroy)(void)
	{
		ATLTRACE(_T("IComponentDataImpl::Destroy\n"));

		T* pT = static_cast<T*>(this);
		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		m_spConsole.Release();
		return S_OK;
	}

    STDMETHOD(QueryDataObject)(LONG_PTR cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
	{
		ATLTRACE(_T("IComponentDataImpl::QueryDataObject\n"));
		ATLASSERT(m_pNode != NULL);


		HRESULT hr = E_POINTER;
		
		ATLASSERT(ppDataObject != NULL);
		if (ppDataObject == NULL)
			ATLTRACE(_T("IComponentData::QueryDataObject called with ppDataObject == NULL\n"));
		else
		{
			*ppDataObject = NULL;
			
			CSnapInItem* pItem = (CSnapInItem*) cookie;
			if (cookie == NULL)
				pItem = m_pNode;

			hr = pItem->GetDataObject(ppDataObject, type);
		}
		return hr;
	}

    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM *pScopeDataItem)
	{
		ATLTRACE(_T("IComponentDataImpl::GetDisplayInfo\n"));


		HRESULT hr = E_POINTER;
		
		ATLASSERT(pScopeDataItem != NULL);
		if (pScopeDataItem == NULL)
			ATLTRACE(_T("IComponentData::GetDisplayInfo called with pScopeDataItem == NULL\n"));
		else
		{
			CSnapInItem* pItem= (CSnapInItem*) pScopeDataItem->lParam;
			if (pItem == NULL)
				pItem = m_pNode;

			hr = E_UNEXPECTED;
			if (pItem != NULL)
				hr = pItem->GetScopePaneInfo(pScopeDataItem);
		}
		return hr;
	}

    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB)
	{
		ATLTRACENOTIMPL(_T("IComponentDataImpl::CompareObjects\n"));
    }

	CComQIPtr<IConsole, &IID_IConsole> m_spConsole;

	protected:
		CSnapInItem* m_pNode;
};


template <class T>
class ATL_NO_VTABLE IComponentImpl : public IComponent
{
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole)
	{
		ATLTRACE(_T("IComponentImpl::Initialize\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(lpConsole != NULL);
		if (lpConsole == NULL)
			ATLTRACE(_T("lpConsole is NULL\n"));
		else
		{
			m_spConsole = lpConsole;
	
			CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeaderCtrl;
			// review : change to QI
			spHeaderCtrl = lpConsole;
			if (spHeaderCtrl == NULL)
				ATLTRACE(_T("QI for IHeaderCtrl failed\n"));
			else
			{
				hr = m_spConsole->SetHeader(spHeaderCtrl);
				if (FAILED(hr))
					ATLTRACE(_T("IConsole::SetHeader failed (HRESULT = %x)\n"), hr);
			}
		}
		return hr;
	}

	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
	{
		ATLTRACE(_T("IComponentImpl::Notify\n"));


		HRESULT hr = E_POINTER;
		
		ATLASSERT(lpDataObject != NULL);
		if (lpDataObject == NULL)
			ATLTRACE(_T("IComponent::Notify called with lpDataObject==NULL \n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->GetDataClass(lpDataObject, &pItem, &type);
			if (SUCCEEDED(hr))
				hr = pItem->Notify(event, arg, param, NULL, pT, type);
		}
		return hr;
	}

    STDMETHOD(Destroy)(LONG_PTR cookie)
	{
		ATLTRACE(_T("IComponentImpl::Destroy\n"));

		T* pT = static_cast<T*>(this);

		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		m_spConsole->SetHeader(NULL);
		m_spConsole.Release();
		return S_OK;
	}

    STDMETHOD(QueryDataObject)(LONG_PTR cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
	{
		ATLTRACE(_T("IComponentImpl::QueryDataObject\n"));

		ATLASSERT(ppDataObject != NULL);
		if (ppDataObject == NULL)
		{
			ATLTRACE(_T("IComponent::QueryDataObject called with ppDataObject==NULL \n"));
			return E_POINTER;
		}
		
		if (cookie == NULL)
		{
			ATLTRACE(_T("IComponent::QueryDataObject called with cookie==NULL \n"));
			return E_UNEXPECTED;
		}

		*ppDataObject = NULL;

		CSnapInItem* pItem = (CSnapInItem*) cookie;
		return pItem->GetDataObject(ppDataObject, type);
	}

    STDMETHOD(GetResultViewType)(LONG_PTR cookie,
        LPOLESTR  *ppViewType,
        long  *pViewOptions)
	{
		ATLTRACE(_T("IComponentImpl::GetResultViewType\n"));

		if (cookie == NULL)
		{
			*ppViewType = NULL;
			*pViewOptions = MMC_VIEW_OPTIONS_NONE;
			return S_FALSE;
		}
		
		CSnapInItem* pItem = (CSnapInItem*)cookie;
		return pItem->GetResultViewType(ppViewType, pViewOptions);
	}

    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM *pResultDataItem)
	{
		ATLTRACE(_T("IComponentImpl::GetDisplayInfo\n"));

		ATLASSERT(pResultDataItem != NULL);
		if (pResultDataItem == NULL)
		{
			ATLTRACE(_T("IComponent::GetDisplayInfo called with pResultDataItem==NULL\n"));
			return E_POINTER;
		}

		CSnapInItem* pItem = (CSnapInItem*) pResultDataItem->lParam;

		if (pItem == NULL)
		{
			ATLTRACE(_T("Invalid Item\n"));
			return E_UNEXPECTED;
		}
		return pItem->GetResultPaneInfo(pResultDataItem);
	}

    STDMETHOD(CompareObjects)( LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB)
	{
		ATLTRACENOTIMPL(_T("IComponentImpl::CompareObjects\n"));
	}

	CComPtr<IConsole> m_spConsole;
};

template <class T, class D>
class ATL_NO_VTABLE IResultDataCompareImpl : public IResultDataCompare
{
public:
    STDMETHOD(Compare)(long lUserParam,
        LONG_PTR cookieA,
        LONG_PTR cookieB,
        int *pnResult)
	{
		ATLTRACENOTIMPL(_T("IResultDataCompareImpl::Compare"));
	}
};


template <class T>
class ATL_NO_VTABLE IExtendContextMenuImpl : public IExtendContextMenu
{
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
        LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed)
	{
		ATLTRACE(_T("IExtendContextMenuImpl::AddMenuItems\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE(_T("IExtendContextMenu::AddMenuItems called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->GetDataClass(pDataObject, &pItem, &type);

			if (SUCCEEDED(hr))
				hr = pItem->AddMenuItems(piCallback, pInsertionAllowed, type);
		}
		return hr;
	}

    STDMETHOD(Command)(long lCommandID,
        LPDATAOBJECT pDataObject)
	{
		ATLTRACE(_T("IExtendContextMenuImpl::Command\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE(_T("IExtendContextMenu::Command called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->GetDataClass(pDataObject, &pItem, &type);
			
			if (SUCCEEDED(hr))
				hr = pItem->Command(lCommandID, type);
		}
		return hr;
	}
};

template<class T>
class ATL_NO_VTABLE IExtendPropertySheetImpl : public IExtendPropertySheet
{
public:
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        LPDATAOBJECT pDataObject)
	{
		ATLTRACE(_T("IExtendPropertySheetImpl::CreatePropertyPages\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE(_T("IExtendPropertySheetImpl::CreatePropertyPages called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->GetDataClass(pDataObject, &pItem, &type);

			if (SUCCEEDED(hr))
				hr = pItem->CreatePropertyPages(lpProvider, handle, this, type);
		}

		return hr;
	}

    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject)
	{
		ATLTRACE(_T("IExtendPropertySheetImpl::QueryPagesFor\n"));
		

		HRESULT hr = E_POINTER;
		
		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE(_T("IExtendPropertySheetImpl::QueryPagesFor called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->GetDataClass(pDataObject, &pItem, &type);

			if (SUCCEEDED(hr))
				hr = pItem->QueryPagesFor(type);
		}
		return hr;
	}
};

template <class T>
class ATL_NO_VTABLE IExtendControlbarImpl : public IExtendControlbar
{
public:
	STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar)
	{
		ATLTRACE(_T("IExtendControlbarImpl::SetControlbar\n"));
		T* pT = static_cast<T*>(this);

		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		pT->m_spControlbar = pControlbar;
		return S_OK;
	}

    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
	{
		ATLTRACE(_T("IExtendControlbarImpl::ControlbarNotify\n"));

		CSnapInItem* pItem = NULL;
		DATA_OBJECT_TYPES type;
		HRESULT hr = S_OK;
		T* pT = static_cast<T*>(this);

		if (event == MMCN_BTN_CLICK)
			hr = pT->GetDataClass((IDataObject*) arg, &pItem, &type);
		else if (event == MMCN_SELECT)
			hr = pT->GetDataClass((IDataObject*) param, &pItem, &type);

		if (SUCCEEDED(hr))
		{
			hr = pItem->ControlbarNotify(pT->m_spControlbar, this, &(pT->m_toolbarMap), event, arg, param, type);
		}

		return hr;
	}
};

#define SNAPINMENUID(id) \
public: \
	static const UINT GetMenuID() \
	{ \
		static const UINT IDMENU = id; \
		return id; \
	}

#define EXT_SNAPINMENUID(id) \
public: \
	static const UINT GetMenuID() \
	{ \
		static const UINT IDMENU = id; \
		return id; \
	}

#define BEGIN_SNAPINCOMMAND_MAP(theClass, bIsExtension) \
	HRESULT ProcessCommand(UINT nID, \
		bool& bHandled, \
		CSnapInObjectRoot* pObj, \
		DATA_OBJECT_TYPES type) \
	{ \
			bHandled = true; \
			HRESULT hr = S_OK;

#define SNAPINCOMMAND_ENTRY(id, func) \
		if (id == nID) \
		{ \
			hr = func(bHandled, pObj); \
			if (bHandled) \
				return hr; \
		}

#define SNAPINCOMMAND_RANGE_ENTRY(id1, id2, func) \
		if (id1 >= nID && nID <= id2) \
		{ \
			hr = func(nID, bHandled, pObj); \
			if (bHandled) \
				return hr; \
		}

#define CHAIN_SNAPINCOMMAND_MAP(theChainClass) \
	{ \
		hr = theChainClass.ProcessCommand(nID, bHandled, pObj, type); \
		if (bHandled) \
			return hr; \
	}

#define END_SNAPINCOMMAND_MAP() \
			return hr; \
	}

struct CSnapInToolBarData
{
	WORD wVersion;
	WORD wWidth;
	WORD wHeight;
	WORD wItemCount;
	//WORD aItems[wItemCount]

	WORD* items()
		{ return (WORD*)(this+1); }
};

#define RT_TOOLBAR  MAKEINTRESOURCE(241)
	
class CSnapInToolbarInfo
{
public:
	~CSnapInToolbarInfo()
	{
		CleanUp();
	}

	HRESULT CleanUp()
	{
		if (m_pStrToolTip)
		{
			for (UINT i = 0; i < m_nButtonCount; i++)
			{
				delete m_pStrToolTip[i];
				m_pStrToolTip[i] = NULL;
			}
			delete [] m_pStrToolTip;
			m_pStrToolTip = NULL;
		}

		if (m_pStrButtonText)
		{
			for (UINT i = 0; i < m_nButtonCount; i++)
			{
				delete m_pStrButtonText[i];
				m_pStrButtonText[i] = NULL;
			}

			delete [] m_pStrButtonText;
			m_pStrButtonText = NULL;
		}
		if (m_pnButtonID)
		{
			delete m_pnButtonID;
			m_pnButtonID = NULL;
		}

		m_nButtonCount = 0;
		return S_OK;
	}

	TCHAR** m_pStrToolTip;
	TCHAR** m_pStrButtonText;
	UINT* m_pnButtonID;
	UINT m_idToolbar;
	UINT m_nButtonCount;
};

#define BEGIN_SNAPINTOOLBARID_MAP(theClass) \
public: \
	static CSnapInToolbarInfo* GetToolbarInfo() \
	{ \
		static CSnapInToolbarInfo m_toolbarInfo[] = \
		{

#define SNAPINTOOLBARID_ENTRY(id) \
			{ NULL, NULL, NULL, id, 0},

#define END_SNAPINTOOLBARID_MAP() \
			{ NULL, NULL, NULL, 0, 0} \
		}; \
		return m_toolbarInfo; \
	}	

template <class T, BOOL bIsExtension = FALSE>
class ATL_NO_VTABLE CSnapInItemImpl : public CSnapInItem
{
public:
	CSnapInItemImpl()
	{
	}

	virtual ~CSnapInItemImpl()
	{
	}

public:

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::Notify"));
	}

    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem)
	{
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetScopePaneInfo"));
	}

    STDMETHOD(GetResultViewType)(LPOLESTR *ppViewType,
        long *pViewOptions)
	{
		ATLTRACE(_T("CSnapInItemImpl::GetResultViewType\n"));
		*ppViewType = NULL;
		*pViewOptions = MMC_VIEW_OPTIONS_NONE;
		return S_FALSE;
	}

    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem)
	{
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetResultPaneInfo"));
	}

    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE(_T("CSnapInItemImpl::AddMenuItems\n"));
		T* pT = static_cast<T*>(this);

		if (!bIsExtension)
			pT->SetMenuInsertionFlags(true, pInsertionAllowed);

		UINT menuID = pT->GetMenuID();
		if (menuID == 0)
			return S_OK;

		HMENU hMenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(menuID));
		long insertionID;
		if (hMenu)
		{
			for (int i = 0; 1; i++)
			{
				HMENU hSubMenu = GetSubMenu(hMenu, i);
				if (hSubMenu == NULL)
					break;
				
				MENUITEMINFO menuItemInfo;
				memset(&menuItemInfo, 0, sizeof(menuItemInfo));
				menuItemInfo.cbSize = sizeof(menuItemInfo);

				switch (i)
				{
				case 0:
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) )
						continue;
					insertionID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
					break;

				case 1:
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) )
						continue;
					if (bIsExtension)
						insertionID = CCM_INSERTIONPOINTID_3RDPARTY_NEW;
					else
						insertionID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
					break;

				case 2:;
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) )
						continue;
					if (bIsExtension)
						insertionID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
					else
						insertionID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
					break;
				case 3:;
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) )
						continue;
					insertionID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
					break;
				default:
					{
						insertionID = 0;
						continue;
					}
					break;
				}

				menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
				menuItemInfo.fType = MFT_STRING;
				TCHAR buf[128];

				for (int j = 0; 1; j++)
				{
					menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
					menuItemInfo.fType = MFT_STRING;
					menuItemInfo.cch = 128;
					menuItemInfo.dwTypeData = buf;
					TCHAR strStatusBar[256];

					if (!GetMenuItemInfo(hSubMenu, j, TRUE, &menuItemInfo))
						break;
					if (menuItemInfo.fType != MFT_STRING)
						continue;

					pT->UpdateMenuState(menuItemInfo.wID, buf, &menuItemInfo.fState);
					LoadString(_Module.GetResourceInstance(), menuItemInfo.wID, strStatusBar, 256);

					CONTEXTMENUITEM contextMenuItem;
					memset(&contextMenuItem, 0, sizeof(contextMenuItem));
					contextMenuItem.strName = buf;
					contextMenuItem.strStatusBarText = strStatusBar;
					contextMenuItem.lCommandID = menuItemInfo.wID;
					contextMenuItem.lInsertionPointID = insertionID;
					contextMenuItem.fFlags = menuItemInfo.fState;
					
					HRESULT hr;
					hr = piCallback->AddItem(&contextMenuItem);
					ATLASSERT(SUCCEEDED(hr));
				}
			}
			DestroyMenu(hMenu);
		}

		if (!bIsExtension)
			pT->SetMenuInsertionFlags(true, pInsertionAllowed);

		return S_OK;
	}

    STDMETHOD(Command)(long lCommandID,		
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE(_T("CSnapInItemImpl::Command\n"));
		bool bHandled;
		T* pT = static_cast<T*>(this);
		return pT->ProcessCommand(lCommandID, bHandled, (CSnapInObjectRoot*) this, type);
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::CreatePropertyPages"));
	}

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::QueryPagesFor"));
	}

    STDMETHOD(SetControlbar)(IControlbar *pControlbar,
		IExtendControlbar* pExtendControlBar,
		CSnapInSimpleMap<UINT, IUnknown*>* pToolbarMap)
	{
		ATLTRACE(_T("CSnapInItemImpl::SetControlbar\n"));
		T* pT = static_cast<T*>(this);

		CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
		if (pInfo == NULL)
			return S_OK;

		for( ; pInfo->m_idToolbar; pInfo++)
		{
			IToolbar* p = (IToolbar*) pToolbarMap->Lookup(pInfo->m_idToolbar);
			if (p != NULL)
				continue;

			HBITMAP hBitmap = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar));
			if (hBitmap == NULL)
				return S_OK;

			HRSRC hRsrc = ::FindResource(_Module.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar), RT_TOOLBAR);
			if (hRsrc == NULL)
				return S_OK;

			HGLOBAL hGlobal = LoadResource(_Module.GetResourceInstance(), hRsrc);
			if (hGlobal == NULL)
				return S_OK;

			CSnapInToolBarData* pData = (CSnapInToolBarData*)LockResource(hGlobal);
			if (pData == NULL)
				return S_OK;
			ATLASSERT(pData->wVersion == 1);
			ATLASSERT(pData->wWidth == 16);
			ATLASSERT(pData->wHeight == 16);

			pInfo->m_nButtonCount = pData->wItemCount;
			if (pInfo->m_pnButtonID == NULL)
				pInfo->m_pnButtonID = new UINT[pInfo->m_nButtonCount];

			if (pInfo->m_pnButtonID == NULL)
				continue;

			MMCBUTTON *pButtons = new MMCBUTTON[pData->wItemCount];
			if (pButtons == NULL)
			{
				delete []pInfo->m_pnButtonID;
				continue;
			}
			
			if (pInfo->m_pStrToolTip == NULL)
			{
				pInfo->m_pStrToolTip = new TCHAR* [pData->wItemCount];
				if (pInfo->m_pStrToolTip)
					memset(pInfo->m_pStrToolTip, 0, sizeof(TCHAR*) * pData->wItemCount);
			}

			if (pInfo->m_pStrToolTip == NULL)
			{
				delete []pInfo->m_pnButtonID;
				delete []pButtons;
				continue;
			}


			for (int i = 0, j = 0; i < pData->wItemCount; i++)
			{
//				pInfo->m_pStrToolTip[i] = NULL;
				memset(&pButtons[i], 0, sizeof(MMCBUTTON));
				pInfo->m_pnButtonID[i] = pButtons[i].idCommand = pData->items()[i];
				if (pButtons[i].idCommand)
				{
					pButtons[i].nBitmap = j++;
					// get the statusbar string and allow modification of the button state
					TCHAR strStatusBar[512];
					LoadString(_Module.GetResourceInstance(), pButtons[i].idCommand, strStatusBar, 512);

					if (pInfo->m_pStrToolTip[i] == NULL)
						pInfo->m_pStrToolTip[i] = new TCHAR[lstrlen(strStatusBar) + 1];
					if (pInfo->m_pStrToolTip[i] == NULL)
						continue;
					lstrcpy(pInfo->m_pStrToolTip[i], strStatusBar);
					pButtons[i].lpTooltipText = pInfo->m_pStrToolTip[i];
					pButtons[i].lpButtonText = _T("");
					pT->SetToolbarButtonInfo(pButtons[i].idCommand, &pButtons[i].fsState, &pButtons[i].fsType);
				}
				else
				{
					pButtons[i].lpTooltipText = _T("");
					pButtons[i].lpButtonText = _T("");
					pButtons[i].fsType = TBSTYLE_SEP;
				}
			}

			IToolbar* pToolbar;
	        HRESULT hr = pControlbar->Create(TOOLBAR, pExtendControlBar, reinterpret_cast<LPUNKNOWN*>(&pToolbar));
			if (SUCCEEDED(hr))
			{

				hr = pToolbar->AddBitmap(pData->wItemCount, hBitmap, pData->wWidth, pData->wHeight, RGB(192, 192, 192));
				if (SUCCEEDED(hr))
				{
					hr = pToolbar->AddButtons(pData->wItemCount, pButtons);
					if (SUCCEEDED(hr))
					{
						pToolbar->AddRef();
						pToolbarMap->Add(pInfo->m_idToolbar, (IUnknown*)pToolbar);
					}
				}
			}
			pToolbar->Release();
			delete [] pButtons;
		}
		return S_OK;
	}

    STDMETHOD(ControlbarNotify)(IControlbar *pControlbar,
        IExtendControlbar *pExtendControlbar,
		CSnapInSimpleMap<UINT, IUnknown*>* pToolbarMap,
		MMC_NOTIFY_TYPE event,
        LPARAM arg,
		LPARAM param,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE(_T("CSnapInItemImpl::ControlbarNotify\n"));
		T* pT = static_cast<T*>(this);

		SetControlbar(pControlbar, pExtendControlbar, pToolbarMap);

		CComPtr<IUnknown> spUnknown;
		HRESULT hr = pControlbar->QueryInterface(IID_IUnknown, (void**)&spUnknown);
		if (FAILED(hr))
			return hr;

		if(event == MMCN_SELECT)
		{
			if (pControlbar == NULL)
				return S_OK;

			BOOL bSelect = (BOOL) HIWORD (arg);
			BOOL bScope;
			bScope = (BOOL) LOWORD(arg);

			CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
			if (pInfo == NULL)
				return S_OK;

			for(; pInfo->m_idToolbar; pInfo++)
			{
				IToolbar* pToolbar = (IToolbar*)pToolbarMap->Lookup(pInfo->m_idToolbar);
				if (pToolbar == NULL)
					continue;

				if (!bSelect)
					pControlbar->Detach(pToolbar);
				else
				{
					pControlbar->Attach(TOOLBAR, pToolbar);
					for (UINT i = 0; i < pInfo->m_nButtonCount; i++)
					{
						if (pInfo->m_pnButtonID[i])
						{
							pToolbar->SetButtonState(pInfo->m_pnButtonID[i],
								ENABLED,
								pT->UpdateToolbarButton(pInfo->m_pnButtonID[i],
									ENABLED));
							pToolbar->SetButtonState(pInfo->m_pnButtonID[i],
								CHECKED,
								pT->UpdateToolbarButton(pInfo->m_pnButtonID[i],
									CHECKED));
							pToolbar->SetButtonState(pInfo->m_pnButtonID[i],
								HIDDEN,
								pT->UpdateToolbarButton(pInfo->m_pnButtonID[i],
									HIDDEN));
							pToolbar->SetButtonState(pInfo->m_pnButtonID[i],
								INDETERMINATE,
								pT->UpdateToolbarButton(pInfo->m_pnButtonID[i],
									INDETERMINATE));
							pToolbar->SetButtonState(pInfo->m_pnButtonID[i],
								BUTTONPRESSED,
								pT->UpdateToolbarButton(pInfo->m_pnButtonID[i],
									BUTTONPRESSED));
						}
					}
				}
			}
			return S_OK;
		}
		else if (event == MMCN_BTN_CLICK)
		{
			bool bHandled;
			return pT->ProcessCommand((UINT) param, bHandled, (CSnapInObjectRoot*) this, type);
		}

		return E_UNEXPECTED;
	}

	STDMETHOD(GetScopeData)(SCOPEDATAITEM **pScopeDataItem)
	{
		if (pScopeDataItem == NULL)
			return E_FAIL;

		*pScopeDataItem = &m_scopeDataItem;
		return S_OK;
	}

    STDMETHOD(GetResultData)(RESULTDATAITEM **pResultDataItem)
	{
		if (pResultDataItem == NULL)
			return E_FAIL;

		*pResultDataItem = &m_resultDataItem;
		return S_OK;
	}

	STDMETHOD(GetDataObject)(IDataObject** pDataObj, DATA_OBJECT_TYPES type)
	{
		CComObject<CSnapInDataObjectImpl>* pData;
		HRESULT hr = CComObject<CSnapInDataObjectImpl>::CreateInstance(&pData);
		if (FAILED(hr))
			return hr;

		T* pT = static_cast<T*> (this);
		pData->m_objectData.m_pItem = pT;
		pData->m_objectData.m_type = type;

		hr = pData->QueryInterface(IID_IDataObject, (void**)(pDataObj));
		return hr;
	}

	void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
	{
		return;
	}

	void SetToolbarButtonInfo(UINT id, BYTE *fsState, BYTE *fsType)
	{
		*fsState = TBSTATE_ENABLED;
		*fsType = TBSTYLE_BUTTON;
	}

	BOOL UpdateToolbarButton(UINT id, BYTE fsState)
	{
		if (fsState == ENABLED)
			return TRUE;
		return FALSE;
	}

	HRESULT ProcessCommand(UINT nID,
		bool& bHandled,
		CSnapInObjectRoot* pObj,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE(_T("No handler for item with ID %d\n"), nID);
		return S_OK;
	}

	STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream)
	{
		HRESULT hr = DV_E_CLIPFORMAT;
		ULONG uWritten;

		T* pT = static_cast<T*> (this);

		if (cf == m_CCF_NODETYPE)
		{
			hr = pStream->Write(pT->GetNodeType(), sizeof(GUID), &uWritten);
			return hr;
		}

		if (cf == m_CCF_SZNODETYPE)
		{
			hr = pStream->Write(pT->GetSZNodeType(), (lstrlen((LPCTSTR)pT->GetSZNodeType()) + 1 )* sizeof(TCHAR), &uWritten);
			return hr;
		}

		if (cf == m_CCF_DISPLAY_NAME)
		{
			hr = pStream->Write(pT->GetDisplayName(), (lstrlen((LPCTSTR)pT->GetDisplayName()) + 1) * sizeof(TCHAR), &uWritten);
			return hr;
		}

		if (cf == m_CCF_SNAPIN_CLASSID)
		{
			hr = pStream->Write(pT->GetSnapInCLSID(), sizeof(GUID), &uWritten);
			return hr;
		}

		return hr;
	}

	static CSnapInToolbarInfo* GetToolbarInfo()
	{
		return NULL;
	}

	static const UINT GetMenuID()
	{
		return 0;
	}

	void SetMenuInsertionFlags(bool bBeforeInsertion, long* pInsertionAllowed)
	{
	}

	void* GetNodeType()
	{
		return (void*)T::m_NODETYPE;
	}
	void* GetSZNodeType()
	{
		return (void*)T::m_SZNODETYPE;
	}

	void* GetDisplayName()
	{
		return (void*)T::m_SZDISPLAY_NAME;
	}

	void* GetSnapInCLSID()
	{
		return (void*)T::m_SNAPIN_CLASSID;
	}

	CComBSTR m_bstrDisplayName;
	SCOPEDATAITEM m_scopeDataItem;
	RESULTDATAITEM m_resultDataItem;
};


_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_NODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SZNODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_DISPLAY_NAME = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_CLASSID = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA = 0;

#endif //__ATL_SNAPIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\ext\gc\inc\gcp.h ===
#ifndef __GCP_H
#define __GCP_H

//	Great Circle garbage collector header
/// Copyright Geodesic Systems 1993-95
/// By Charles Fiterman.

//	Collector algorithm from an article by Henry G. Baker
/// ACM Sigplan Notices March 1992 pp 66
///
/// The Baker paper referred to this as a four color algorithm.
/// Free, White (which I call Mixed), Grey (which I call Marked)
/// and Black (which I call Passed).
/// Dealing with C++ adds two new queues, which are really about C++.
/// Locked, which is generally called the root object in collector
/// terminology, and Limbo which is used for objects under construction.
/// I think this is better than the original inconsistent color terminology.

//	Meaningful defines
///
/// #define GC_NO_TEMPLATES to generate non-template code from the macro
/// version of Great Circle. This is set in gc.h for Microsoft C++ and g++.
///
/// #define GC_NO_EXCEPTIONS to generate a non exception handling version
/// of Great Circle. This is set in gc.h for Microsoft C++. It is slightly
/// more efficient.
///
/// #define GC_DEBUG to enable extra debug support. GC_DEBUG allows
/// gcCheckAll() to be called at any moment even as a watch variable from a
/// debugger. This is expensive in time but costs little space.
///
/// #define GC_INCREMENTAL to make the collector incremental.
/// This means write barrier overhead and calls to gcMinWork().
///
/// #define GC_COLLECTION_TRIGGER some_number
/// When ever this much collectible memory is new()ed a collection cycle
/// is run. In our samples we like values around 40000L but don't know why
/// this is true. A value of zero turns off automatic collection cycles.
/// This is ignored if GC_INCREMENTAL is defined.
///
/// Great Circle uses the #define _MSC_VER set by Microsoft C++.
///
/// Great Circle uses the #define __BCPLUSPLUS__ set by Borland C++.
///
/// Great Circle uses the #define __GNUG__ set by Gnu C++

//	#defines used for tuning.

//  This is the largest message that can be built in a gcCheck()
/// Zero disables gcCheck() and gcCheckAll(). This must be done in advance
/// since if an error occurs the memory managment system may be dead.
/// Space for address decoration is automatically added. This shouldn't be
/// too large to display easily.
#define GC_ERROR_MESSAGE_SIZE 50

//	One object's constructor may new another to a depth of GC_MAX_NEW_RECURSION.
/// For most programs 1 or 2 is enough. The problem with letting this run
/// limitlessly is that a buggy program in which a class x object news another
/// x endlessly will run longer and be harder to debug. At initialization we 
/// build a stack of size (GC_MAX_NEW_RECURSION * 6 * sizeof(void *)).
#define GC_MAX_NEW_RECURSION 50

//	This is the number of gcHandle's allocated at once
#define GC_FREELUMP	 64

#include <stdlib.h>
#include <string.h>
#include <assert.h>

// This section adjusts to various known compilers.
#define GC_NO_EXCEPTIONS	1
#define GC_INLINE_DELETE	1 

#ifdef __BCPLUSPLUS__
#define GC_NOT_CFRONT
#if __BCPLUSPLUS__ == 0x310
//	Version 3.10 is buggy for fooPtr->~foo(); which calls the destructor.
/// This means the destructors on array items don't get called.
/// We have no workaround. One result is that you can't have a collectible
/// array of non collectible objects which contain collectible objects.
#define GC_NO_INPLACE_DESTRUCTORS 1

// Don't inline delete function under Borland C++ 3.10 it generates buggy code.
#undef GC_INLINE_DELETE

#else
// So far only Borland 4.0 allows exceptions
#undef GC_NO_EXCEPTIONS
#endif
inline void *operator new(size_t, void *p) { return p; }
#endif

#ifdef _MSC_VER
#define GC_NOT_CFRONT
#include <new.h>
#if 800 == _MSC_VER
// No Templates in Visual C++ 1.5
#define GC_NO_TEMPLATES  1
inline void *operator new(size_t, void *p) { return p; }
#endif

#if 900 == _MSC_VER
// Visual C++ 2.0 will not automatically instantiate template statics.
#define GC_NO_TEMPLATE_STATICS 1
#define GC_NO_INPLACE_DESTRUCTORS 1
inline void *operator new(size_t, void *p) { return p; }
#endif

#endif

#ifdef __SUNPRO_CC
#define GC_NOT_CFRONT
// Sparcworks CC will not automatically instantiate template statics.
#define GC_NO_TEMPLATE_STATICS 1
#define GC_SPECIAL_INLINING 1
inline void *operator new(size_t, void *p) { return p; }
#endif

#ifdef __CLCC__
inline void *operator new(size_t, void *p) { return p; }
#endif

#ifdef __GNUG__
#define GC_NOT_CFRONT
#include <new.h>
//	g++ 2.6 templates will not automatically instantiate statics.
/// For versions below 2.6 replace this with GC_NO_TEMPLATES
#define GC_NO_TEMPLATE_STATICS 1
#define GC_SPECIAL_INLINING 1
#endif

#ifdef __HIGHC__
#define GC_NOT_CFRONT
#define GC_SPECIAL_INLINING 1
#define GC_TEMPLATE_H template<class T>
inline void *operator new(size_t, void *p) { return p; }
#else
#define GC_TEMPLATE_H template<class T> inline
#endif

#ifdef __OS2__
#define GC_NOT_CFRONT
#define GC_NO_TEMPLATE_STATICS 1
inline void *operator new(size_t, void *p) { return p; }
#endif

#ifndef GC_NOT_CFRONT
//	fooPtr->~foo(); produces syntax errors under cfront.
/// This means the destructors on array items don't get called.
/// We have no workaround. One result is that you can't have a collectible
/// array of non collectible objects which contain collectible objects.
#define GC_NO_INPLACE_DESTRUCTORS 1
#endif

#define GC_COLLECTION_TRIGGER 40000L

#include <iostream.h>

//	It is usually poor to use the keyword inline directly for non trivial
/// functions. This is because debuggers don't step through inline functions.
/// And you don't want to step through the inline functions of working
/// subsystems while debugging. By using lines like '#define GC_INLINE inline'
/// you gain the ability to turn inlining off and on selectivly by subsystem.
#define GC_INLINE inline

#ifdef NDEBUG
#define GC_ASSERT(cond, message)
#else
#define GC_ASSERT(cond, message) if(!(cond)) gc::gcError(message);
#endif

#ifdef  GC_SPECIAL_INLINING
#define GC_TEMPLATE template<class T> inline
#else
#define GC_TEMPLATE template<class T>
#endif

// Forward class definitions.
class gcHandle;
class gcTable;
class gcNewTable;

// Function that takes a string describing a fatal error and responds to it.
typedef void (*gcErrorHandler)(const char *);

// Single object gc::gcStats used to collect and display statistics.
class gcStatistics {
	long gcCycles,			// Calls to gcSwitchLists
		 gcCollectCalls,	// Calls to gcCollect
		 gcTotalHandles;	// gcHandles allocated

	friend class gcHandle;
	friend class gc;
	friend ostream &operator<<(ostream &, const gcStatistics &);

public:
	//	Change these flags in gc::gcStats to modify the statistical report.
	/// Non zero displays zero supresses.
	char showQueue,		// Show the counts in each queue.
		 showCount,		// Count the objects of each type before display.
		 showErrors;	// Show the results of gcCheckAll().

	gcStatistics() : gcCycles(0), gcCollectCalls(0), gcTotalHandles(0),
					  showQueue(1), showCount(1), showErrors(1) {}
};
ostream &operator<<(ostream &, const gcStatistics &);
extern char *gcCheckAll();						// Consistency check

//	Used on user collectible classes to tell gcIsCollectible
/// if a class is being used as a base class or a member
enum gcPosition {
	gcOuter  = 0,	// Outer level declaration
	gcBase	 = 1,	// Base class
	gcMember = 3	// Member class
};

//	Used to initialize the garbage collector through the
/// idiom described on page 20 of the ARM
class gcInitializeFirst {
public:
	static unsigned int firstTime;

    gcInitializeFirst(int	  errorSize,
							  size_t stackSize,
							  size_t freeLump,
//	If GC_DEBUG is defined for a user module a debug form of gc.cpp is required.
							  size_t debugSw,
//	The incremental | not_incremental mode of all modules in an executable
/// must match.
							  long	  incrAmt);
	~gcInitializeFirst();
};

static gcInitializeFirst GC_INITIALIZE_FIRST_OBJECT(
	GC_ERROR_MESSAGE_SIZE,
	GC_MAX_NEW_RECURSION,
	GC_FREELUMP,
#ifdef GC_DEBUG
	1,
#else
	0,
#endif
#ifndef GC_INCREMENTAL
	GC_COLLECTION_TRIGGER);
#else
	1);
#endif

//	Garbage Collectible object class.
/// Collectible objects must inherit from a single instance of this publicly.
class gc {
public:
	gc();
	gc(const gc &);

// To create user defined new and delete redefine _new or _delete
	static void * _new(size_t s) {
		return new char[s];
	}
#ifdef GC_INLINE_DELETE
    static void _delete(void *x) {
		::delete x;
	}
#else
	static void _delete(void *);
#endif

	static int	gcMinWork();
	//	If not GC_INCREMENTAL this is the number of bytes which are allocated
	/// before a collection cycle is triggered.
	static long gcSetAllocationLimit(long limit);

	//	If GC_INCREMENTAL this is the number of calls to gcMinWork()
	/// every time a gcHandle is new()ed. It is initialized to 1 which is
	/// generally good. But for real time programs 0 is often better.
	static unsigned gcSetCollectionRate(unsigned count = 1);

	//	If GC_INCREMENTAL this causes objects to be deleted as soon
	/// as the collector knows they are free. This may cause millesecond pauses
	/// it is generally ok with interactive programs but not with real time
	/// ones or animation. It reduces the amount of storage required and
	/// improves speed about 3%. Your mileage may vary.
	static unsigned gcSetQuickDelete(unsigned doQuickDelete = 1);

	//	This causes all unlocked and completed collectible objects to be
	/// deleted at end of job.
	static unsigned gcSetDeleteAtEnd(unsigned sw = 1);

	//	Locate all unreferenced objects and delete them.
	static int gcCollect();

	//	Return compiler used.
	static const char *gcCompiler();

	//	Return Library Id
	static const char *gcLibrary();

	//	Return Great Circle Version Number
	static int gcVersion();

    // Returns zero for production copies and the expire time() 
    // for evaluation copies.
    static long gcEvaluationCopy();

	//	Accumulator for statistics, cout << gc::gcStats; prints them.
	static gcStatistics gcStats;

	//	Copyright string
	static const char *gcCopyright();

	// Table for leaf objects
	static gcTable *gcLeafTable;

	//	This normally points to a function that prints a message and exit()s
	/// you may change it say to something that raises an exception. It is
	/// called on all fatal errors by the collector.
	static gcErrorHandler gcSetFatalError(gcErrorHandler v);
        static void gcError(char *msg);  // default gc fatal error routine.

	// new()s for default objects
	static void * operator new(size_t, void *, gcTable **); // Inplace new
	static void * operator new(size_t, gcTable **, void *); // whole object new

	// new()s for pointer and custom objects
	static void * operator new(size_t);
	static void * operator new(size_t, void *); 

	virtual		 ~gc();
	virtual void  gcMarkRefs() const;
	virtual char *gcCheck() const;

	void   operator =(const gc &) {}	// Copy of gc part does nothing.

	int	  gcLock() const;			// Locked objects are never deleted
	int	  gcUnlock() const;	        // Decrement lock count.
	void  gcMark() const;			// Mark this object as used.
	void *gcFindOuterObject() const;

protected:
	static void gcInternalMakeCollectible(gc *, gcTable **);
	static void gcInternalMakeCollectible(void *, gcTable **);

	gc(gcPosition);		// Used by custom collectible objects
	gc(int);			// Used by special collectible objects

	virtual void gcAppend() const;	// Save object location on a table.
	void   operator delete(void *x) {
		_delete(x); 
	}

	void gcWriteBarrier(void *) const;
	void gcInternalArrayMakeCollectible();
	void gcInternalPtrCollectible(size_t, gcHandle **);

private:
	static gcErrorHandler gcFatalError;
#ifdef _MSC_VER
	static int	noMoreMemory(size_t);
#else
	static void noMoreMemory();
#endif
	void gcExceptionTearDown();

	gcHandle *gcHandlePtr;

	friend class gcInitializeFirst;
	friend class gcHandle;
	friend class gcList;
	friend class gcPointerBase;
	friend class gcLocker;
	friend class gcNewTable;
	friend ostream &operator<<(ostream &, const gc &);
};
ostream &operator<<(ostream &, const gc &); // Usefull for debugging only.

// Custom collectible objects descend from this
class gcCustom : public gc {
public:
	gcCustom()					: gc(gcBase) {}
	gcCustom(const gcCustom &)	: gc(gcBase) {}
	gcCustom(int)				: gc(0)		  {}

	virtual void  gcMarkRefs()	const = 0;
	virtual char *gcCheck() const;
};

class gcSpecial : public gcCustom {
public:
	gcSpecial()						: gcCustom(0) {}
	gcSpecial(const gcSpecial &)	: gcCustom(0) {}

	static gcPosition gcPos;	// creates default of gcOuter
};

#define gcIsCollectible() gcLocker gcLockedObj(this, sizeof(*this), gcPos)
#ifdef GC_DEBUG
//	In debug mode gcMark of a deleted object triggers a fatal error.
/// If there are any pointers left to the object gcCollect() will find them.
#define gcDelete(ptr) \
	if(!!ptr) { gc *x = ptr; ptr = 0; _delete(x); gc::gcCollect(); }
#else
#define gcDelete(ptr) if(!!ptr) { gc *x = ptr; ptr = 0; _delete(x); }
#endif
#define gcParm gcPosition gcPos = gcOuter
#define gcPtrCollectible() \
	gcInternalPtrCollectible(sizeof(*this), &gcPtrHandle)

//	Collectible objects are removed from the Limbo queue by the construction
/// of a gcLocker object, but left locked. They are unlocked by the gcLocker
/// destructor if they were independently new()ed.
class gcLocker {
public:
	gcLocker(gc *, size_t, gcParm);	// custom objects
	~gcLocker();
private:
	gcHandle *lockedHandle;
};

//  This are short ways to allocate Arrays
#define GC_NEW_ARRAY(S, T) new(S) GC_ARRAY(T)
#define GC_NEW_PRIMITIVE_ARRAY(S, T) new(S) GC_PRIMARRAY(T)

//	These are used for default collectible objects. These objects don't declare
/// themselves collectible. They are all allocated by their own new() which
/// saves the objects size and position and the address of its table pointer
/// on a stack. When a pointer is saved to the object its constuction is
/// completed. Default collectible objects are the sum of their non-default
/// parts, so if the object is not independently newed it never needs to be
/// constructed as collectible.
#define GC_STRUCT(T) GC_CLASS(T) class T : GC(T) public:
#define GC_CLASS(T) GC_START_CLASS(T) GC_FINISH_CLASS(T)
#define GC(T) public virtual gc { GC_BODY(T)

#if !defined(GC_NOT_CFRONT) || defined (__GNUG__)
//	Some compilers require these apparently as the result of some bug.
#define GC_ODDNEW1 static void *operator new(size_t s) { \
	return ::operator new(s); }
#define GC_ODDNEW2 static void *operator new(size_t s) { \
	return gc::operator new(s, &gc::gcLeafTable, _new(s)); }
#else
#define GC_ODDNEW1
#define GC_ODDNEW2
#endif

//  Define operator new for a default object, define an inaccessable
/// operator delete.
#ifdef GC_NOT_CFRONT
#define GC_BODY(T) public: \
        static void * operator new(size_t n) { \
	GC_ASSERT(n == sizeof(T), "A subclass of '" # T \
	"' was not declared collectible") \
	return gc::operator new(n, GC_GENERATE(T)::whereTab(), _new(n)); } \
	static void * operator new(size_t n, void *p) { \
	GC_ASSERT(n == sizeof(T), "A subclass of '" # T\
	"' was not declared collectible") \
	return gc::operator new(n, p, GC_GENERATE(T)::whereTab()); } private:
#else
//	The full message format in GC_BODY confuses cfront under objectcenter.
#define GC_BODY(T) void operator delete(void *x) { _delete(x); } public: \
	static void * operator new(size_t n) { \
	GC_ASSERT(n == sizeof(T), \
	"A subclass of a default collectible was not declared collectible") \
	return gc::operator new(n, GC_GENERATE(T)::whereTab(), _new(n)); } \
	static void * operator new(size_t n, void *p) { \
	GC_ASSERT(n == sizeof(T), \
	"A subclass of a default collectible was not declared collectible") \
	return gc::operator new(n, p, GC_GENERATE(T)::whereTab()); } private:
#endif

// Return values for gcInBounds tests
enum gcArrayTest {
	gcNotAnArray,
	gcPointerOk,
	gcPointerTooLow,
	gcPointerTooHigh,
	gcPointerAtEnd
};

// Parent of all array class templates.
class gcArrayBase : public gc {
public:
	static gcTable *ncoTable;
	//	The maybe functions call gcMarkRefs or gcCheck for gc's but not
	/// otherwise they are used in gcArray< T >'s functions.
	static void	  gcMaybeMarkRefs(const gc *);
	static void	  gcMaybeMarkRefs(const void *) {}
	static char * gcMaybeCheck(const gc *);
	static char * gcMaybeCheck(const void *);

	static void * operator new(size_t, size_t, gcTable **);
	
	gcArrayBase() {}

	virtual void    gcMarkRefs() const {}
	void * gcArrayBottom() const;
	size_t size() const;
	size_t len() const;
	void   setLen(size_t);
	int	   gcValidReference(const void *);
	gcArrayTest gcInBounds(const void *) const;

	size_t gcItemLen;
	void * gcArrayEnd;
private:
	GC_ODDNEW1
};

//	All pointer and reference wrappers descend from this class which
/// contains the pointer's handle. This class does the actual write
/// barrier. Since we always choose speed over space it is correct
/// to keep the handle with the pointer. Whenever a pointer is changed
/// the handle is loaded but since we always gcMark() there is no
/// time lost in the case when gcMarkRefs is never called.
class gcPointerBase {
public:
	virtual void gcMarkRefs() const;

protected:
	gcPointerBase()	{}
	gcPointerBase(const gcPointerBase &);
	gcPointerBase(gcHandle *);
	gcPointerBase(int);

#ifdef GC_DEBUG
	static char gcBusy;
#endif

	void	gcMarkPtr() const;
	void	pointersBusy();
	void	pointersOk();
	char *	gcCheck(const gc *) const;
	char *  gcCheck(const void *) const { return 0; };
	void	setHandle();
	void	setHandle(const gc *);
	void	setHandle(gcHandle *);
	void	setHandle(const gcPointerBase &p);
	void *	gcValidReference(void *newP) const;
	virtual void	gcAppend() const;
	gcArrayBase *	isArray() const;
	gcHandle *gcPtrHandle;
};

//	Doubly linked list
class gcDlist {
public:
	void l_dconn();
	void l_conn(gcDlist *);
	int	 isEmpty() const;

	gcDlist *f, *b;		// Forward and backward pointers
};

// Color bucket
class gcList : public gcDlist {
public:
	gcList() {}
	gcList(unsigned char, char *);

	void operator << (gcList &);
	int		gcMinWork();
	int		gcFreeAll();
	void	l_dconn(gcHandle *);
	void	l_conn(gcHandle *);
	char *	gcCheck() const;
	char *	gcBuildMsg(char *) const;
	void	gcAllLive();
	int		gcPassAll();
	unsigned long l_count() const;

	char		 *gcName;		// Name for statistics and error reporting
	unsigned long gcCount;		// items on queue if GC_DEBUG else garbage
	unsigned char gcColor;		// Queue items match this except for free queue
	unsigned char gcBusy;		// Semiphore used if GC_DEBUG
};
ostream &operator<<(ostream &, const gcList &);

//	gcHandle objects have pointers to the user's objects and are the
/// real basis of collectibility
class gcHandle : public gcDlist {
public:
	enum gcMarkValue {			// The kind of objects in the system
		gcNewlyCreatedObject,	// Object newly created
		gcTempValue,			// Short term transient value for debugging
		gcUnlinkedObject,		// Object marked for destruction
		gcPointerMarkRefs,		// Table has only pointers
		gcObjectMarkRefs,		// Table has only subobjects
		gcFullMarkRefs,			// Table has pointers and subobjects
		gcCustomMarkRefs,		// Not a default object
		gcPtrMarkRefs,			// gcPtr etc is outer object
		gcArrayMarkRefs,		// gcArray< T > is outer object
		gcLeafMarkRefs,			// Table is empty
		gcArrayLeafMarkRefs,	// gcArray< T > is outer object
		gcEndOfEnum				// No objects of this type
	};

	gcHandle();

	static int gcSwitchLists();

	// static class instead of static here stops an objectcenter warning.
	static class gcList Free, Mixed, Marked, Passed, Locked, Limbo;

	static void * operator new(size_t);
	void   operator delete(void *) {} // never called

	void	gcMark();
#ifndef _MSC_VER
	void	gcMarkWork();
#endif
	void	gcPass();
	void	gcAborted();
	int		gcLock();
	int		gcUnlock();
	void	gcUnlink();
	void	gcAssert(const gcList &);
	char *	gcCheck(const gcList &) const;
	char *	gcBuildMsg(char *, const gcList &) const;
	char *	gcBuildConnectMsg(const gcList &) const;
	char *	gcBuildColorMsg(const gcList &) const;
	char *	gcBuildTrampolineMsg(const gcList &) const;
	void	gcMake(gcList &, gcList &);
	void	gcInternalMakeCollectible(gc *, void *);
	void	gcWriteBarrier(const gc *, void *);
	int		gcIs(const gcList &) const;
	int		gcIsLeaf() const;
	gcArrayBase * isArray() const;

	gc *gcUsersObj;				// The users actual object
	union {						// Union descriminated by gcTrampoline
		gcHandle **gcPtr;		// gcMarkValue::gcPtrMarkrefs
		gcTable   *gcTablePtr;	// gcMarkValue:: Table values
	} gcTabs;
	unsigned	  gcLockCount;		// Non zero is locked.
	gcMarkValue  gcTrampoline;		// Set what we do
	unsigned char gcColor;			// Color of this object.
};

// Inline functions for common section.

GC_INLINE void *gc::gcFindOuterObject() const {
	return (void *)gcHandlePtr->gcUsersObj;
}
GC_INLINE void gc::gcInternalMakeCollectible(void *, gcTable **t) {
	*t = gcArrayBase::ncoTable;
}
GC_INLINE int gc::gcLock() const {
	return gcHandlePtr->gcLock();
}
GC_INLINE int gc::gcUnlock() const {
	return gcHandlePtr->gcUnlock();
}

#ifdef GC_NO_GLOBAL_FUNCTIONS
GC_INLINE gcErrorHandler gc::gcSetFatalError(gcErrorHandler v) {
	gcErrorHandler rv = gcFatalError;
	gcFatalError = v;
	return rv;
}
#endif

GC_INLINE void gc::gcError(char *msg) {
	gcFatalError(msg);
}
GC_INLINE unsigned long
gcNotYetProtected()
{
	return gcHandle::Limbo.l_count();
}

//	If you intend to improve speed by rewriting something in assembler
/// our profile analysis shows these three functions are the best candidates.
inline void gcDlist::l_dconn() {
	(f->b = b)->f = f;
}
inline void gcDlist::l_conn(gcDlist *t) {
	t->b = (b = (f = t)->b)->f = this;
}
inline gcDlist::isEmpty() const {
	return this == f;
}

inline int gcList::gcMinWork() {
#ifdef GC_INCREMENTAL
	if (!isEmpty()) {
	  ((gcHandle *)b)->gcPass();
	  return 0;
	}
	else {
	  gcHandle::gcSwitchLists();
	  return 1;
	}
#else
	return 1;
#endif
}

inline int gc::gcMinWork() {
	return gcHandle::Marked.gcMinWork();
}

inline void gcList::l_dconn(gcHandle *p) {
#ifdef GC_DEBUG
	gcBusy = 1;
	gcCount--;
#endif
	p->l_dconn();
#ifdef GC_DEBUG
	gcBusy = 0;
#endif
}
inline void gcList::l_conn(gcHandle *p)	{
#ifdef GC_DEBUG
	gcBusy = 1;
	gcCount++;
#endif
	p->l_conn(this);
	p->gcColor = gcColor;
#ifdef GC_DEBUG
	gcBusy = 0;
#endif
}

GC_INLINE gcHandle::gcHandle()
 : gcLockCount(1), gcUsersObj(0), gcTrampoline(gcNewlyCreatedObject)
{
	gcTabs.gcTablePtr = gc::gcLeafTable;
	Limbo.l_conn(this);
}
inline int gcHandle::gcIs(const gcList &c) const {
	return c.gcColor == gcColor;
}
inline int gcHandle::gcIsLeaf() const {
	return gcLeafMarkRefs <= gcTrampoline;
}
inline void gcHandle::gcMake(gcList &c, gcList &l) {
	l.l_dconn(this);
	c.l_conn(this);
}

#ifdef GC_DEBUG
// Check the validity of a gcHandle and have a fatal error if bad.
GC_INLINE void
gcHandle::gcAssert(const gcList &c)
{
	char *msg = gcCheck(c);

	if (msg)
		gc::gcError(gcBuildMsg(msg, c));
}
#else
GC_INLINE void
gcHandle::gcAssert(const gcList &) {}
#endif

#ifndef _MSC_VER
GC_INLINE void
gcHandle::gcMark() {
	if (gcIs(Mixed))
		gcMarkWork();
}
#endif

inline void gc::gcMark() const {
	gcHandlePtr->gcMark();
}
GC_INLINE void gcHandle::gcWriteBarrier(const gc *obj, void *ptr) {
	if (gcNewlyCreatedObject == gcTrampoline)
		gcInternalMakeCollectible((gc *)obj, ptr);
#ifdef GC_INCREMENTAL
	else
		gcMark();
#endif
}
inline void gc::gcWriteBarrier(void *ptr) const {
	gcHandlePtr->gcWriteBarrier(this, ptr);
}
GC_INLINE void gcHandle::gcUnlink() {
#ifdef GC_DEBUG
	gcTrampoline = gcTempValue;
#endif
	gcUsersObj	 = 0;
	gcLockCount  = 0;
	gcTrampoline = gcUnlinkedObject;
}

GC_INLINE gcArrayBase * gcHandle::isArray() const {
	return (gcTrampoline == gcArrayMarkRefs ||
			gcTrampoline == gcArrayLeafMarkRefs) ?
		(gcArrayBase *)(void *)gcUsersObj : 0;
}
inline void *gcArrayBase::gcArrayBottom() const {
	return (void *)(this + 1);
}
inline size_t gcArrayBase::size() const {
	return (size_t)((char *)gcArrayEnd - (char *)gcArrayBottom());
}
inline size_t gcArrayBase::len() const{
	return size() / gcItemLen;
}
GC_INLINE void gcArrayBase::setLen(size_t newLen) {
	void *x = (char *)gcArrayBottom() + newLen * gcItemLen;
	GC_ASSERT(x <= gcArrayEnd, "Attempt to set array length too large");
	gcArrayEnd = x;
}
GC_INLINE int gcArrayBase::gcValidReference(const void *p) {
	return p < gcArrayEnd && p >= gcArrayBottom();
}
GC_INLINE void gcArrayBase::gcMaybeMarkRefs(const gc *p) {
	p->gcMarkRefs();
}
GC_INLINE char * gcArrayBase::gcMaybeCheck(const gc *p) {
	return p->gcCheck();
}
GC_INLINE char * gcArrayBase::gcMaybeCheck(const void *) {
	return 0;
}

//  Some people like the convenience of avoiding gc:: and others
/// want to avoid namespace pollution. We try to satisfy both.
/// Define GC_NO_GLOBAL_FUNCTIONS to avoid namespace pollution.
#ifndef GC_NO_GLOBAL_FUNCTIONS
inline const char *gcCompiler() {
    return gc::gcCompiler();
}
inline const char *gcLibrary() {
    return gc::gcLibrary();
}
inline int gcVersion() {
    return gc::gcVersion();
}
inline const char *gcCopyright() {
    return gc::gcCopyright();
}
inline int gcMinWork() {
    return gc::gcMinWork();
}
inline long gcSetAllocationLimit(long limit) {
    return gc::gcSetAllocationLimit(limit);
}
inline unsigned gcSetCollectionRate(unsigned count = 1) {
    return gc::gcSetCollectionRate(count);
}
inline unsigned gcSetQuickDelete(unsigned doQuickDelete = 1) {
    return gc::gcSetQuickDelete(doQuickDelete);
}
inline unsigned gcSetDeleteAtEnd(unsigned sw = 1) {
    return gc::gcSetDeleteAtEnd(sw);
}
inline int gcCollect() {
    return gc::gcCollect();
}
inline gcErrorHandler gcSetFatalError(gcErrorHandler v) {
    return gc::gcSetFatalError(v);
}
#endif

#ifdef GC_DEBUG
inline void gcPointerBase::pointersBusy() { gcBusy = 1; }
inline void gcPointerBase::pointersOk()   { gcBusy = 0; }
#else
inline void gcPointerBase::pointersBusy() {}
inline void gcPointerBase::pointersOk()   {}
#endif
inline void gcPointerBase::gcMarkPtr() const {
	gcPtrHandle->gcMark();
}
GC_INLINE void gcPointerBase::gcMarkRefs() const {
	if (gcPtrHandle)
		gcMarkPtr();
}
GC_INLINE void gcPointerBase::setHandle() {
	gcPtrHandle = 0;
	pointersOk();
}
GC_INLINE void gcPointerBase::setHandle(const gc *p) {
	if (p) {
		gcPtrHandle = p->gcHandlePtr;
		p->gcWriteBarrier((void *)this);
	} else
		gcPtrHandle = 0;
	pointersOk();
}
GC_INLINE void gcPointerBase::setHandle(gcHandle *h) {
#ifndef GC_INCREMENTAL
	gcPtrHandle = h;
#else
	if (0 != (gcPtrHandle = h))
		gcMarkPtr();
#endif
	pointersOk();
}
GC_INLINE void gcPointerBase::setHandle(const gcPointerBase &p) {
	setHandle(p.gcPtrHandle);
}
GC_INLINE gcPointerBase::gcPointerBase(int) {
	setHandle();
}
GC_INLINE gcPointerBase::gcPointerBase(gcHandle *h) {
	setHandle(h);
}
GC_INLINE gcPointerBase::gcPointerBase(const gcPointerBase &p) {
	setHandle(p.gcPtrHandle);
}
GC_INLINE gcArrayBase * gcPointerBase::isArray() const {
	return gcPtrHandle ? gcPtrHandle->isArray() : 0;
}
GC_INLINE void* gcPointerBase::gcValidReference(void *newP) const {
#ifdef GC_DEBUG
	gcArrayBase *a = isArray();
	GC_ASSERT(a && a->gcValidReference(newP), "Invalid Pointer Dereference");
#endif
	return newP;
}

GC_INLINE gcLocker::~gcLocker() {
	if (lockedHandle)
		lockedHandle->gcLockCount--;
}

#ifndef GC_NO_TEMPLATES

//	gc template wrapper classes.

//	Normally it is good style to separate class definitions from function
/// internals as with the above non template classes. However templates are
/// new to C++ and some compilers crash with the normal style.

template<class T> class gcPrimArray;

template<class T>
class gcGenerate {
public:
	static gcTable **whereTab() {
		return &gcTablePtr;
	}
	static gcTable* gcTablePtr;	// Table of offsets
};

// Parent for wrapped data pointers and references.
template<class T>
class gcWrap : public gcPointerBase {
protected:
	gcWrap() : data(0), gcPointerBase(0) {}
	gcWrap(T *p) {
		setPointer(p);
	}
	gcWrap(const gcWrap< T > &p) : data(p.data), gcPointerBase(p.gcPtrHandle) {}

	void setPointer() {
		pointersBusy(); // Prevent gcCheck from testing pointers
		data = 0;
		setHandle();	// Allow gcCheck to check pointers
	}
	void setPointer(T* p);
	void setPointer(const gcWrap< T > &p) {
		pointersBusy();
		data = p.data;
		setHandle(p);
	}

	T* data;			// The pointer to the actual object
};

//	Wrap data pointers only for items that will not have
/// automtacally generated gcMarkRefs()
template<class T>
class gcPointer : public gcWrap< T > {
public:
	gcPointer()	  {}
	gcPointer(int) {}
	gcPointer(T *x) : gcWrap< T >(x) {}
	gcPointer(const gcPointer< T > &x) : gcWrap< T >(x) {}
	gcPointer(gcPrimArray< T > *x);

	T* operator=(T *x) {
		setPointer(x);
		return data;
	}
	T* operator=(const gcPointer< T > &x) {
		setPointer(x);
		return data;
	}
	operator T*()	const {
		return data;
	}
	T* operator()() const {
		return data;
	}
	T* operator->() const {
		return data;
	}

	int operator!() const {
		return data == 0;
	}
	int operator==(const gcPointer< T > &x) const {
		return data == x.data;
	}
	int operator==(T *x) const {
		return data == x;
	}
    int operator==(int x) const {
        return data == (T *) x;
    }
	int operator!=(const gcPointer< T > &x) const {
		return data != x.data;
	}
	int operator!=(T *x) const {
		return data != x;
	}
	T& operator[](int n) const;
	T* operator+(int n) const;
	T* operator-(int n) const {
		return (*this) + -n;
	}
	T* operator+=(int n) {
		return data = (*this + n);
	}
	T* operator-=(int n) {
		return data = (*this + -n);
	}
#ifdef GC_DEBUG
	T* operator=(int n) {
		GC_ASSERT(!n, "Invalid integer to pointer assignment");
		setPointer();
		return 0;
	}
	T& operator*() const {
		if (isArray())
			return *(T*)gcValidReference((void *)data);
		else {
			GC_ASSERT(data, "Dereference of null pointer");
			return *data;
		}
	}
#else
	T* operator=(int) {
		setPointer();
		return 0;
	}
	T& operator*() const {
		return *data;
	}
#endif
	gcArrayTest gcInBounds(int n) const;
};

//	Wrap pointers to collectible arrays of uncollectible objects.
/// This will also work on arrays of collectible objects but is less
/// space efficient than gcP< T >
template<class T>
class gcArrayP : public gcPointerBase {
protected:
	T* data;
	void setPointer() {
		pointersBusy();
		data = 0;
		setHandle();
	}
	void setPointer(const gcArrayP< T > &p) {
		pointersBusy();
		data = p.data;
		setHandle(p.gcPtrHandle);
	}
	void setPointer(gcPrimArray< T > *p) {
		pointersBusy();
		if (p) {
			data = (T*)p->gcArrayBottom();
			setHandle(p);
		} else {
			data = 0;
			setHandle();
		}
	}
public:
	gcArrayP() : data(0), gcPointerBase(0) {}
	gcArrayP(int) : data(0), gcPointerBase(0) {}
	gcArrayP(const gcArrayP< T > &p)
		: data(p.data), gcPointerBase(p.gcPtrHandle) {}
	gcArrayP(gcPrimArray< T > *p) {
		setPointer(p);
	}

	T* operator=(T *x) {
		return data = x;
	}
	T* operator=(const gcArrayP< T > &x) {
		setPointer(x);
		return data;
	}
	T* operator=(gcPrimArray< T > *x) {
		setPointer(x);
		return data;
	}
	operator T*()	const {
		return data;
	}
	T* operator()() const {
		return data;
	}
	operator gcPrimArray< T > *() const {
		return (gcPrimArray< T > *)(void *)isArray();
	}
	int operator!() const {
		return data == 0;
	}
	int operator==(const gcArrayP< T > &x) const {
		return data == x.data;
	}
	int operator==(T *x) const {
		return data == x;
	}

	int operator!=(const gcArrayP< T > &x) const {
		return data != x.data;
	}
	int operator!=(T *x) const {
		return data != x;
	}

	T* operator++() {
		return data = (*this + 1);
	}
	T* operator--() {
		return data = (*this - 1);
	}
	T* operator++(int) {
		T* tmp = data;
		data = (*this + 1);
		return tmp;
	}
	T* operator--(int) {
		T* tmp = data;
		data = (*this - 1);
		return tmp;
	}

	T* operator+(int n) const;
	T* operator-(int n) const {
		return (*this) + -n;
	}
	T* operator+=(int n) {
		return data = (*this + n);
	}
	T* operator-=(int n) {
		return data = (*this + -n);
	}
	size_t len() const {
		gcArrayBase *a = isArray();
		return a ? a->len() : 0;
	}
	size_t size() const {
		gcArrayBase *a = isArray();
		return a ? a->size() : 0;
	}
	void setLen(size_t l) {
		gcArrayBase *a = isArray();
		if (a)
			a->setLen(l);
	}
#ifdef GC_DEBUG
	T* operator=(int n) {
		GC_ASSERT(!n, "Invalid integer to pointer assignment");
		setHandle();
		return data = 0;
	}
	T& operator[](int n) const {
		return *(T*)gcValidReference((void *)(*this + n));
	}
	T& operator	 *() const {
		return *(T*)gcValidReference((void *)data);
	}
#else
	T* operator=(int) {
		setHandle();
		return data = 0;
	}
	T& operator*() const {
		return *data;
	}
	T& operator[](int n) const {
		return *(*this + n);
	}
#endif
	gcArrayTest gcInBounds(int n) const;
};

//	gcR is a reference to a collectible object which, but it is not
/// itself a collectible object. It is used as a reference through operator()
template<class T>
class gcReference : public gcWrap< T > {
public:
	gcReference() {}
	gcReference(const T &x) : gcWrap< T >((T *)&x) {}
	gcReference(const gcReference< T > &x) : gcWrap< T >(x) {}

// Only Borland can inline this operator
#ifdef __BCPLUSPLUS__
	void operator=(T &x) {
		*data = x;
	}
	void operator=(const gcReference< T > &x) {
		*data = x();
	}
#else
	void operator=(T &x);
	void operator=(const gcReference< T > &x);
#endif
	T& operator()() const {
		return *data;
	}
	operator T&() const {
		return *data;
	}
};

// gcRef is a gcRWrap that is itself a collectible object
template<class T>
class gcRef : public gc, public gcReference< T > {
public:
	gcRef() {
		gcPtrCollectible();
	}
	gcRef(const T &x)				: gcReference< T >(x) {
		gcPtrCollectible();
	}
	gcRef(const gcReference< T > &x)		: gcReference< T >(x) {
		gcPtrCollectible();
	}
	gcRef(const gcRef< T > &x)	: gcReference< T >(x) {
		gcPtrCollectible();
	}

	virtual void gcMarkRefs() const;
	virtual void gcAppend() const;
	char *gcCheck() const;
};

// gcPtr is a pointer to a gc object. It is itself a gc object.
template<class T>
class gcPtr : public gc, public gcPointer< T > {
public:
	gcPtr() {
		gcPtrCollectible();
	}
	gcPtr(int) {
		gcPtrCollectible();
	}
	gcPtr(T *x)				: gcPointer< T >(x) {
		gcPtrCollectible();
	}
	gcPtr(const gcPointer< T > &x)	: gcPointer< T >(x) {
		gcPtrCollectible();
	}
	gcPtr(const gcPtr< T > &x): gcPointer< T >(x) {
		gcPtrCollectible();
	}
	gcPtr(gcPrimArray< T > *x)	: gcPointer< T >(x) {
		gcPtrCollectible();
	}

	T* operator=(T *x) {
		setPointer(x);
		return data;
	}
	T* operator=(const gcPointer< T > &x) {
		setPointer(x);
		return data;
	}
	T* operator=(const gcPtr< T > &x) {
		setPointer(x);
		return data;
	}
	T* operator->() const {
		return data;
	}
	virtual void gcMarkRefs() const;
	virtual void gcAppend() const;
	char *gcCheck() const;
};

// gcArrayPtr is a pointer to a gc object. It is itself a gc object.
template<class T>
class gcArrayPtr : public gc, public gcArrayP< T > {
public:
	gcArrayPtr() {
		gcPtrCollectible();
	}
	gcArrayPtr(const gcArrayP< T > &x)	: gcArrayP< T >(x) {
		gcPtrCollectible();
	}
	gcArrayPtr(const gcArrayPtr< T > &x)	: gcArrayP< T >(x) {
		gcPtrCollectible();
	}
	gcArrayPtr(gcPrimArray< T > *x)		: gcArrayP< T >(x) {
		gcPtrCollectible();
	}

	T* operator=(gcPrimArray< T > *x) {
		setPointer(x);
		return data;
	}
#ifdef GC_DEBUG
	T* operator=(int n) {
		GC_ASSERT(!n, "Invalid integer to pointer assignment");
		setPointer();
		return 0;
	}
#else
	T* operator=(int) {
		setPointer();
		return 0;
	}
#endif

	virtual void gcMarkRefs() const;
	virtual void gcAppend() const;
	char *gcCheck() const {
		return 0;
	}
};

//	Arrays of primitive objects like ints
template<class T>
class gcPrimArray : public gcArrayBase {
public:
	gcPrimArray() {
		gcInternalArrayMakeCollectible();
	}
	static void *operator new(size_t, size_t);
	operator T*() const {
		return (T*)gcArrayBottom();
	}
	T& operator[](int n) const;
	T* operator+(int n) const;

	virtual void gcMarkRefs() const {}

protected:
	GC_ODDNEW2
	gcPrimArray(gcPosition) {
		// used only by children for null effect.
	}

private:
	gcPrimArray(const gcPrimArray< T > &) {}	// prevent use
};

//	Arrays of collectible objects used like gcPrimArray< T >
template<class T>
class gcArray : public gcPrimArray< T > {
public:
	gcArray();
#ifndef GC_NO_INPLACE_DESTRUCTORS
	~gcArray();
#endif
	static void *operator new(size_t, size_t);

	virtual void gcMarkRefs() const;
	char *	gcCheck() const;

protected:
	GC_ODDNEW2

private:
	gcArray(const gcArray< T > &) {}	// private declaration prevents use
};

//	These functions may not be inlined. They are kept together
/// to make the creation of the macro version easier.
GC_TEMPLATE void gcWrap< T >::setPointer(T* p) {
	pointersBusy();
	setHandle((gc *)(data = p));
}

GC_TEMPLATE gcArrayTest gcPointer< T >::gcInBounds(int n) const {
	gcArrayBase *a = isArray();
	return a ? a->gcInBounds((void *)(data + n)) : gcNotAnArray;
}
GC_TEMPLATE T& gcPointer< T >::operator[](int n) const {
	return *(T*)gcValidReference((void *)(data + n));
}
GC_TEMPLATE T* gcPointer< T >::operator+(int n) const {
	return data + n;
}

GC_TEMPLATE T* gcArrayP< T >::operator+(int n) const {
	return data + n;
}

GC_TEMPLATE gcPointer< T >::gcPointer(gcPrimArray< T > *x) {
	setPointer((T*)*x);

}
GC_TEMPLATE void gcPtr< T >::gcMarkRefs() const {
	gcPointerBase::gcMarkRefs();
}
GC_TEMPLATE void gcPtr< T >::gcAppend() const {
	gcPointerBase::gcAppend();
}
GC_TEMPLATE char * gcPtr< T >::gcCheck() const {
#ifdef GC_DEBUG
	if (gcBusy)
		return 0;
#endif
	return (gcPtrHandle
		? ((data && gcPtrHandle->isArray()) || 
		   (data == gcPtrHandle->gcUsersObj))
		: !data) 
			? 0 : "Invalid Pointer";
}
GC_TEMPLATE void gcRef< T >::gcMarkRefs() const {
	gcPointerBase::gcMarkRefs();
}
GC_TEMPLATE void gcRef< T >::gcAppend() const {
	gcPointerBase::gcAppend();
}
GC_TEMPLATE char * gcRef< T >::gcCheck() const {
	return gcPointerBase::gcCheck(data);
}

GC_TEMPLATE gcArrayTest gcArrayP< T >::gcInBounds(int n) const {
	gcArrayBase *a = isArray();
	return a ? a->gcInBounds((void *)(data + n)) : gcNotAnArray;
}
GC_TEMPLATE void gcArrayPtr< T >::gcMarkRefs() const {
	gcPointerBase::gcMarkRefs();
}
GC_TEMPLATE void gcArrayPtr< T >::gcAppend() const {
	gcPointerBase::gcAppend();
}

#ifndef __BCPLUSPLUS__
GC_TEMPLATE void gcReference< T >::operator=(T &x) {
	*data = x;
}
GC_TEMPLATE void gcReference< T >::operator=(const gcReference< T > &x) {
	*data = x();
}
#endif

// Pointer to default table or zero
#define GC_METHODS(T) GC_ARRAY_METHODS(T)
#ifdef GC_NO_TEMPLATE_STATICS
#define GC_ARRAY_METHODS(T) gcTable * gcGenerate< T >::gcTablePtr;
#else
#define GC_ARRAY_METHODS(T)
template<class T> gcTable * gcGenerate< T >::gcTablePtr;
#endif

// Array of primitive objects
GC_TEMPLATE void * gcPrimArray< T >::operator new(size_t s, size_t i) {
	return gcArrayBase::operator new(s+i*sizeof(T),sizeof(T),&gc::gcLeafTable);
}
GC_TEMPLATE T& gcPrimArray< T >::operator[](int n) const {
	T* loc = (T *)gcArrayBottom() + n;
	GC_ASSERT(((void*)loc) >= gcArrayBottom() && ((void*)loc) < gcArrayEnd,
		"Array reference out of bounds");
	return *loc;
}
GC_TEMPLATE T* gcPrimArray< T >::operator+(int n) const {
	T* loc = (T *)gcArrayBottom() + n;
	GC_ASSERT(((void*)loc) >= gcArrayBottom() && ((void*)loc) <= gcArrayEnd,
		"Array increment out of bounds");
	return loc;
}

// For array of collectable objects
GC_TEMPLATE void * gcArray< T >::operator new(size_t s, size_t i) {
	gcTable **table = gcGenerate< T >::whereTab();
	if (!*table)
		gcInternalMakeCollectible(new T, table);
		
	return gcArrayBase::operator new(s + (i * sizeof(T)), sizeof(T), table); 
}

GC_TEMPLATE gcArray< T >::gcArray() : gcPrimArray< T >(gcBase) {
	for (T *x = (T *)*this; ((void*)x) < gcArrayEnd; x++)
		new((void *)x) T;
	gcInternalArrayMakeCollectible();
}

#ifndef GC_NO_INPLACE_DESTRUCTORS
GC_TEMPLATE_H gcArray< T >::~gcArray() {
	for (T *x = (T *)*this; ((void*)x) < gcArrayEnd; x++)
		x->~T();
}
#endif

// This will never be called on non collectible T.
GC_TEMPLATE void gcArray< T >::gcMarkRefs() const {
	for (T *x = (T *)*this; ((void*)x) < gcArrayEnd; x++)
		gcMaybeMarkRefs(x);
}

GC_TEMPLATE char * gcArray< T >::gcCheck() const {
	for (T *x = (T *)*this; ((void*)x) < gcArrayEnd; x++) {
		char *msg;

		if (0 != (msg = gcMaybeCheck(x)))
			return msg;
	}
	return 0;
}

#define GC_NEST(a, b, c)	a< b< c > >

#define GC_START_CLASS(T)	class T;
#define GC_FINISH_CLASS(T)
#define GC_PRIM(T)
#define GC_PRIM_METHODS(T)

#define GC_GENERATE(T)		gcGenerate< T >
#define GC_WRAP(T)			gcWrap< T >
#define GC_POINTER(T)				gcPointer< T >
#define GC_REFERENCE(T)				gcReference< T >
#define GC_PTR(T)			gcPtr< T >
#define GC_REF(T)			gcRef< T >
#define GC_ARRAYP(T)		gcArrayP< T >
#define GC_ARRAYPTR(T)		gcArrayPtr< T >
#define GC_PRIMARRAY(T)		gcPrimArray< T >
#define GC_OBJARRAY(T)		gcObjArray< T >
#define GC_ARRAY(T)			gcArray< T >

#else   // GC_NO_TEMPLATES

//	These macros allow programs to be freely ported between compilers that
/// do and do not support templates.

//	If you use cpp to expand this before debugging you will get a
/// largely unreadable mess. However we provide a program fixer.cpp
/// which will make it a semi readable mess.

#define GC_NEST(a, b, c)	a ## _ ## b ## _ ## c

#define GC_GENERATE(T)		GC_GENERATE_ ## T
#define GC_WRAP(T)			GC_WRAP_ ## T
#define GC_POINTER(T)				GC_P_ ## T
#define GC_REFERENCE(T)				GC_R_ ## T
#define GC_PTR(T)			GC_PTR_ ## T
#define GC_REF(T)			GC_REF_ ## T
#define GC_ARRAYP(T)		GC_ARRAYP_ ## T
#define GC_ARRAYPTR(T)		GC_ARRAYPTR_ ## T
#define GC_PRIMARRAY(T)		GC_PRIMARRAY_ ## T
#define GC_OBJARRAY(T)		GC_OBJARRAY_ ## T
#define GC_ARRAY(T)			GC_ARRAY_ ## T

#ifdef __BCPLUSPLUS__
#define GC_R_DEF(T) void operator=(T &x) { *data = x; } \
	void operator=(const GC_REFERENCE(T) &x) { *data = x(); }

#define GC_R_MOD(T)
#else
#define GC_R_DEF(T) void operator=(T &x); \
	void operator=(const GC_REFERENCE(T) &x);

#define GC_R_MOD(T) void GC_REFERENCE(T)::operator=(T &x) { *data = x; } \
	void GC_REFERENCE(T)::operator=(const GC_REFERENCE(T) &x) { *data = x(); }
#endif

#ifdef GC_NO_INPLACE_DESTRUCTORS
#define GC_ARRAY_DES(T)

#define GC_ARRAY_DES_METH(T)
#else
#define GC_ARRAY_DES(T) ~GC_ARRAY(T)();

#define GC_ARRAY_DES_METH(T) GC_ARRAY(T)::~GC_ARRAY(T)() { \
	for (T *x = (T *)*this; ((void*)x) < gcArrayEnd; x++) { x->~T(); } }
#endif

#ifdef GC_DEBUG
#define GC_P_DEF(T) T* operator=(int n) { \
	GC_ASSERT(!n, "Invalid integer to pointer assignment"); \
	setPointer(); return 0; } \
	T& operator	 *() const { \
	if (isArray()) \
	return *(T*)gcValidReference((void *)data); \
	else { \
	GC_ASSERT(data, "Dereference of null pointer"); \
	return *data; } }

#define GC_AP_DEF(T) T* operator=(int n) { \
	GC_ASSERT(!n, "Invalid integer to pointer assignment"); \
	setHandle(); return data = 0; } \
	T& operator[](int n) const { \
	return *(T*)gcValidReference((void *)(*this + n)); } \
	T& operator	 *() const { \
	return *(T*)gcValidReference((void *)data); }

#define GC_APTR_DEF(T)	T* operator=(int n) { \
	GC_ASSERT(!n, "Invalid integer to pointer assignment"); \
	setPointer(); \
	return 0; } 

#define GC_CHECK_BUSY if(gcBusy) return 0;
#else
#define GC_P_DEF(T) T* operator=(int) { setPointer(); return 0; } \
	T& operator	 *() const { return *data; }

#define GC_AP_DEF(T) T* operator=(int) { \
	setHandle(); return data = 0; } \
	T& operator	 *() const { return *data; } \
	T& operator[](int n) const { return *(*this + n); }

#define GC_APTR_DEF(T)	T* operator=(int) { \
	setPointer(); \
	return 0; }
#define GC_CHECK_BUSY
#endif

#define GC_INTERNAL(T) \
class T; \
class GC_WRAP(T) : public gcPointerBase { protected: \
	T* data; \
	GC_WRAP(T)() : data(0), gcPointerBase(0) {} \
	GC_WRAP(T)(T *p) { setPointer(p); } \
	GC_WRAP(T)(const GC_WRAP(T) &p) : data(p.data), \
	gcPointerBase(p.gcPtrHandle) {} \
	void setPointer() { pointersBusy(); data = 0; setHandle(); } \
	void setPointer(T* p); \
	void setPointer(const GC_WRAP(T) &p) { \
	pointersBusy(); data = p.data; setHandle(p); } };

//	Microsoft Visual C++ has a fixed macro expansion buffer which is
/// too small for GC_CLASS so you must use GC_START and GC_FINISH.
#define GC_START_CLASS(T) \
	class GC_GENERATE(T); \
GC_INTERNAL(T) \
	class GC_PRIMARRAY(T); \
	class GC_POINTER(T) : public GC_WRAP(T) { public: \
	GC_POINTER(T)() {} \
	GC_POINTER(T)(int) {} \
	GC_POINTER(T)(T *x) : GC_WRAP(T)(x) {} \
	GC_POINTER(T)(const GC_POINTER(T) &x) : GC_WRAP(T)(x) {} \
	GC_POINTER(T)(GC_PRIMARRAY(T) *x); \
	T* operator=(T *x) { setPointer(x); return data; } \
	T* operator=(const GC_POINTER(T) &x) { setPointer((T*)x); return data; } \
	operator T*() const { return data; } \
	T* operator()() const { return data; } \
	T* operator->() const { return data; } \
	int operator!() const { return data == 0; } \
	int operator==(const GC_POINTER(T) &x) const { return data == x.data; } \
	int operator==(T *x) const { return data == x; } \
    int operator==(int x) const { return data == (T *) x; } \
	int operator!=(const GC_POINTER(T) &x) const { return data != x.data; } \
	int operator!=(T *x) const { return data != x; } \
	T& operator[](int n) const; \
	T* operator+(int n) const; \
	T* operator-(int n) const { return (*this) + -n; } \
	T* operator+=(int n) { return data = (*this + n); } \
	T* operator-=(int n) { return data = (*this + -n); } \
GC_P_DEF(T) \
	gcArrayTest gcInBounds(int n) const; }; \
	class GC_REFERENCE(T) : public GC_WRAP(T) { public: \
	GC_REFERENCE(T)() {} \
	GC_REFERENCE(T)(const T &x) : GC_WRAP(T)((T *)&x) {} \
	GC_REFERENCE(T)(const GC_REFERENCE(T) &x) : GC_WRAP(T)(x) {} \
GC_R_DEF(T) \
	T& operator()() const { return *data; } \
	operator T&() const { return *data; } }; \
	class GC_REF(T) : public gc, public GC_REFERENCE(T) { public: \
	GC_REF(T)() { gcPtrCollectible(); } \
	GC_REF(T)(const T &x) : GC_REFERENCE(T)(x) { gcPtrCollectible(); } \
	GC_REF(T)(const GC_REFERENCE(T) &x) : GC_REFERENCE(T)(x) { gcPtrCollectible(); } \
	GC_REF(T)(const GC_REF(T) &x) : GC_REFERENCE(T)(x) { gcPtrCollectible(); } \
	void gcMarkRefs() const; \
	void gcAppend() const; \
	char *gcCheck() const; }; \
	class GC_PTR(T) : public gc, public GC_POINTER(T) { public: \
	GC_PTR(T)(int i = 0) { gcPtrCollectible(); } \
	GC_PTR(T)(T *x) : GC_POINTER(T)(x) { gcPtrCollectible(); } \
	GC_PTR(T)(const GC_POINTER(T) &x) : GC_POINTER(T)(x) { gcPtrCollectible(); } \
	GC_PTR(T)(const GC_PTR(T) &x) : GC_POINTER(T)(x) { gcPtrCollectible(); } \
	GC_PTR(T)(GC_PRIMARRAY(T) *x) : GC_POINTER(T)(x) { gcPtrCollectible(); } \
	T* operator=(T *x) { setPointer(x); return data; } \
	T* operator=(const GC_POINTER(T) &x) { setPointer((T*)x); return data; } \
	T* operator=(const GC_PTR(T) &x) { setPointer(x); return data; } \
	T* operator->() const { return data; } \
	void gcMarkRefs() const; \
	void gcAppend() const; \
	char *gcCheck() const; };

#define GC_PRIM(T) \
	class GC_PRIMARRAY(T) : public gcArrayBase { \
	GC_PRIMARRAY(T)(const GC_PRIMARRAY(T) &) {} \
	protected: \
GC_ODDNEW2 \
	GC_PRIMARRAY(T)(gcPosition) {} \
	public: \
	static void *operator new(size_t, size_t); \
	GC_PRIMARRAY(T)() { gcInternalArrayMakeCollectible(); } \
	operator T*() const { return (T*)gcArrayBottom(); } \
	T& operator[](int n) const; \
	T* operator+(int n) const; \
	void gcMarkRefs() const {} }; \
	class GC_ARRAYP(T) : public gcPointerBase { protected: \
	T* data; \
	void setPointer() { pointersBusy(); data = 0; setHandle(); } \
	void setPointer(const GC_ARRAYP(T) &p) { \
	pointersBusy(); data = p.data; setHandle(p.gcPtrHandle); } \
	void setPointer(GC_PRIMARRAY(T) *p) { \
	pointersBusy(); \
	if (p) { \
	data = (T*)p->gcArrayBottom(); setHandle(p); \
	} else { \
	data = 0; setHandle(); } } \
	public: \
	GC_ARRAYP(T)() : data(0), gcPointerBase(0) {} \
	GC_ARRAYP(T)(int) : data(0), gcPointerBase(0) {} \
	GC_ARRAYP(T)(const GC_ARRAYP(T) &p) : data(p.data), \
	gcPointerBase(p.gcPtrHandle) {} \
	GC_ARRAYP(T)(GC_PRIMARRAY(T) *p) { setPointer(p); } \
	T* operator=(T *x) { return data = x; } \
	T* operator=(const GC_ARRAYP(T) &x) { setPointer(x); return data; } \
	T* operator=(GC_PRIMARRAY(T) *x) { setPointer(x); return data; } \
	operator T*() const { return data; } \
	T* operator()() const { return data; } \
	operator GC_PRIMARRAY(T) *() const { \
	return (GC_PRIMARRAY(T) *)(void *)isArray(); } \
	int operator!() const { return data == 0; } \
	int operator==(const GC_ARRAYP(T) &x) const { return data == x.data; } \
	int operator==(T *x) const { return data == x; } \
	int operator!=(const GC_ARRAYP(T) &x) const { return data != x.data; } \
	int operator!=(T *x) const { return data != x; } \
	T* operator+(int n) const; \
	T* operator-(int n) const { return (*this) + -n; } \
	T* operator+=(int n) { return data = (*this + n); } \
	T* operator-=(int n) { return data = (*this + -n); } \
	size_t len() const { \
	gcArrayBase *a = isArray(); return a ? a->len() : 0; } \
	size_t size() const { \
	gcArrayBase *a = isArray(); return a ? a->size() : 0; } \
	void setLen(size_t l) { \
	gcArrayBase *a = isArray(); if (a) a->setLen(l); } \
GC_AP_DEF(T) \
	gcArrayTest gcInBounds(int n) const; }; \
	class GC_ARRAYPTR(T) : public gc, public GC_ARRAYP(T) { public: \
	GC_ARRAYPTR(T)() { gcPtrCollectible(); } \
	GC_ARRAYPTR(T)(const GC_ARRAYP(T) &x) : GC_ARRAYP(T)(x) { \
	gcPtrCollectible(); } \
	GC_ARRAYPTR(T)(const GC_ARRAYPTR(T) &x) : GC_ARRAYP(T)(x) { \
	gcPtrCollectible(); } \
	GC_ARRAYPTR(T)(GC_PRIMARRAY(T) *x) : GC_ARRAYP(T)(x) { \
	gcPtrCollectible(); } \
	T* operator=(GC_PRIMARRAY(T) *x) { setPointer(x); return data; } \
GC_APTR_DEF(T) \
	void gcMarkRefs() const; \
	void gcAppend() const; \
	char *gcCheck() const { return 0; } }; \

#define GC_FINISH_CLASS(T) \
	class GC_GENERATE(T) { \
	public: \
	static gcTable** whereTab(); \
	static gcTable* gcTablePtr; }; \
GC_INTERNAL(GC_PARRAY_ ## T) \
GC_PRIM(T) \
	class GC_ARRAY(T) : public GC_PRIMARRAY(T) { \
	GC_ARRAY(T)(const GC_ARRAY(T) &) {} \
	protected: \
GC_ODDNEW2 \
	public: \
	static void *operator new(size_t, size_t); \
	GC_ARRAY(T)(); \
GC_ARRAY_DES(T) \
	void gcMarkRefs() const; \
	char * gcCheck() const; };

#define GC_INTERNAL_METHODS(T) \
	void GC_WRAP(T)::setPointer(T* p) { \
	pointersBusy(); \
	setHandle((gc *)(data = p)); }

#define GC_METHODS(T) \
GC_INTERNAL_METHODS(T) \
	gcArrayTest GC_POINTER(T)::gcInBounds(int n) const { \
	gcArrayBase *a = isArray(); \
	return a ? a->gcInBounds((void *)(data + n)) : gcNotAnArray; } \
	T& GC_POINTER(T)::operator[](int n) const { \
	return *(T*)gcValidReference((void *)(data + n)); } \
	T* GC_POINTER(T)::operator+(int n) const { \
	return data + n; } \
	GC_POINTER(T)::GC_POINTER(T)(GC_PRIMARRAY(T) *x) { setPointer((T*)*x); } \
	void GC_PTR(T)::gcMarkRefs() const { gcPointerBase::gcMarkRefs(); } \
	void GC_PTR(T)::gcAppend() const { gcPointerBase::gcAppend(); } \
	char * GC_PTR(T)::gcCheck() const { \
	GC_CHECK_BUSY \
	return (gcPtrHandle \
		? ((data && gcPtrHandle->isArray()) || \
		   (data == gcPtrHandle->gcUsersObj)) \
		: !data) ? 0 : "Invalid Pointer"; } \
	GC_R_MOD(T) \
	void GC_REF(T)::gcMarkRefs() const { gcPointerBase::gcMarkRefs(); } \
	void GC_REF(T)::gcAppend() const { gcPointerBase::gcAppend(); } \
	char * GC_REF(T)::gcCheck() const { return gcPointerBase::gcCheck(data); } \
GC_ARRAY_METHODS(T)

#define GC_PRIM_METHODS(T) \
	T& GC_PRIMARRAY(T)::operator[](int n) const { \
	T* loc = (T *)gcArrayBottom() + n; \
	GC_ASSERT(((void*)loc) >= gcArrayBottom() && ((void*)loc) < gcArrayEnd, \
	"Array reference out of bounds"); \
	return *loc; } \
	T* GC_PRIMARRAY(T)::operator+(int n) const { \
	T* loc = (T *)gcArrayBottom() + n; \
	GC_ASSERT(((void*)loc) >= gcArrayBottom() && ((void*)loc) <= gcArrayEnd, \
	"Array increment out of bounds"); \
	return loc; } \
	T* GC_ARRAYP(T)::operator+(int n) const { \
	return data + n; } \
	void * GC_PRIMARRAY(T)::operator new(size_t s, size_t i) { \
	return gcArrayBase::operator new(s+i*sizeof(T),sizeof(T),&gc::gcLeafTable); }\
	gcArrayTest GC_ARRAYP(T)::gcInBounds(int n) const { \
	gcArrayBase *a = isArray(); \
	return a ? a->gcInBounds((void *)(data + n)) : gcNotAnArray; } \
	void GC_ARRAYPTR(T)::gcMarkRefs() const { gcPointerBase::gcMarkRefs(); } \
	void GC_ARRAYPTR(T)::gcAppend() const { gcPointerBase::gcAppend(); } \

#define GC_ARRAY_METHODS(T) \
GC_INTERNAL_METHODS(GC_PARRAY_ ## T) \
	gcTable ** GC_GENERATE(T)::whereTab() { return &gcTablePtr; } \
	gcTable * GC_GENERATE(T)::gcTablePtr; \
GC_PRIM_METHODS(T) \
	void * GC_ARRAY(T)::operator new(size_t s, size_t i) { \
	gcTable **table = GC_GENERATE(T)::whereTab(); \
	if (!*table) gcInternalMakeCollectible(new T, table); \
	return gcArrayBase::operator new(s + (i * sizeof(T)), sizeof(T), table);} \
	GC_ARRAY(T)::GC_ARRAY(T)() : GC_PRIMARRAY(T)(gcBase) { \
	for (T *x = (T *)*this; ((void*)x) < gcArrayEnd; x++) \
	new((void *)x) T; \
	gcInternalArrayMakeCollectible(); } \
GC_ARRAY_DES_METH(T) \
	void GC_ARRAY(T)::gcMarkRefs() const { \
	for (T *x = (T *)*this; ((void*)x) < gcArrayEnd; x++) \
	gcMaybeMarkRefs(x); } \
	char * GC_ARRAY(T)::gcCheck() const { \
	for (T *x = (T *)*this; ((void*)x) < gcArrayEnd; x++) { \
	char *msg; \
	if (0 != (msg = gcMaybeCheck(x))) return msg; } \
	return 0; }
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\inc\clnetcfg.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    clnetcfg.h

Abstract:

    Network Configuration Engine definitions

Author:

    Mike Massa (mikemas) 28-Feb-1998

Revision History:

--*/

#ifndef _CLNETCFG_INCLUDED_
#define _CLNETCFG_INCLUDED_


#ifdef __cplusplus
extern "C" {
#endif


//
// Structures
//

//
// Network Configuration Entry Structure
// Identifies a network and a local interface.
//
typedef struct _CLNET_CONFIG_ENTRY {
    LIST_ENTRY          Linkage;
    NM_NETWORK_INFO     NetworkInfo;
    BOOLEAN             IsInterfaceInfoValid;
    BOOLEAN             UpdateNetworkName;
    NM_INTERFACE_INFO2  InterfaceInfo;

    // Fields used by setup
    BOOL               New;
    BOOL               IsPrimed;
    LPWSTR             PreviousNetworkName;
    LIST_ENTRY         PriorityLinkage;

} CLNET_CONFIG_ENTRY, *PCLNET_CONFIG_ENTRY;


//
// Configuration Lists Structure
// Contains the set of network configuration lists emitted by the
// configuration engine.
//
typedef struct _CLNET_CONFIG_LISTS {
    LIST_ENTRY  InputConfigList;
    LIST_ENTRY  DeletedInterfaceList;
    LIST_ENTRY  UpdatedInterfaceList;
    LIST_ENTRY  CreatedInterfaceList;
    LIST_ENTRY  CreatedNetworkList;
} CLNET_CONFIG_LISTS, *PCLNET_CONFIG_LISTS;


//
// Definitions for functions supplied by the consumer of the network
// configuration engine.
//
typedef
VOID
(*LPFN_CLNETPRINT)(
    IN ULONG LogLevel,
    IN PCHAR FormatString,
    ...
    );

typedef
VOID
(*LPFN_CLNETLOGEVENT)(
    IN DWORD    LogLevel,
    IN DWORD    MessageId
    );

typedef
VOID
(*LPFN_CLNETLOGEVENT1)(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1
    );

typedef
VOID
(*LPFN_CLNETLOGEVENT2)(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1,
    IN LPCWSTR  Arg2
    );

typedef
VOID
(*LPFN_CLNETLOGEVENT3)(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1,
    IN LPCWSTR  Arg2,
    IN LPCWSTR  Arg3
    );


//
// Exported Routines
//
VOID
ClNetInitialize(
    IN LPFN_CLNETPRINT       Print,
    IN LPFN_CLNETLOGEVENT    LogEvent,
    IN LPFN_CLNETLOGEVENT1   LogEvent1,
    IN LPFN_CLNETLOGEVENT2   LogEvent2,
    IN LPFN_CLNETLOGEVENT3   LogEvent3
    );

LPWSTR
ClNetCopyString(
    IN LPWSTR  SourceString,
    IN BOOL    RaiseExceptionOnError
    );

VOID
ClNetInitializeConfigLists(
    PCLNET_CONFIG_LISTS  Lists
    );

DWORD
ClNetConvertEnumsToConfigList(
    IN     PNM_NETWORK_ENUM *     NetworkEnum,
    IN     PNM_INTERFACE_ENUM2 *  InterfaceEnum,
    IN     LPWSTR                 LocalNodeId,
    IN OUT PLIST_ENTRY            ConfigList,
    IN     BOOLEAN                DeleteEnums
    );

VOID
ClNetFreeNetworkEnum(
    IN PNM_NETWORK_ENUM  NetworkEnum
    );

VOID
ClNetFreeNetworkInfo(
    IN PNM_NETWORK_INFO  NetworkInfo
    );

VOID
ClNetFreeInterfaceEnum1(
    IN PNM_INTERFACE_ENUM  InterfaceEnum1
    );

VOID
ClNetFreeInterfaceEnum(
    IN PNM_INTERFACE_ENUM2  InterfaceEnum
    );

VOID
ClNetFreeInterfaceInfo(
    IN PNM_INTERFACE_INFO2  InterfaceInfo
    );

VOID
ClNetFreeNodeEnum1(
    IN PNM_NODE_ENUM  NodeEnum
    );

VOID
ClNetFreeNodeEnum(
    IN PNM_NODE_ENUM2  NodeEnum
    );

VOID
ClNetFreeNodeInfo(
    IN PNM_NODE_INFO2  NodeInfo
    );

VOID
ClNetFreeConfigEntry(
    PCLNET_CONFIG_ENTRY  ConfigEntry
    );

VOID
ClNetFreeConfigList(
    IN PLIST_ENTRY  ConfigList
    );

VOID
ClNetFreeConfigLists(
    PCLNET_CONFIG_LISTS  Lists
    );

LPWSTR
ClNetMakeInterfaceName(
    LPWSTR  Prefix,      OPTIONAL
    LPWSTR  NodeName,
    LPWSTR  AdapterName
    );

DWORD
ClNetConfigureNetworks(
    IN     LPWSTR                LocalNodeId,
    IN     LPWSTR                LocalNodeName,
    IN     LPWSTR                DefaultClusnetEndpoint,
    IN     CLUSTER_NETWORK_ROLE  DefaultNetworkRole,
    IN     BOOL                  NetNameHasPrecedence,
    IN OUT PCLNET_CONFIG_LISTS   ConfigLists,
    IN OUT LPDWORD               MatchedNetworkCount,
    IN OUT LPDWORD               NewNetworkCount
    );
/*++

Notes:

    Output interface lists must be processed in the following order to
    guarantee correctness:
        1 - RenamedInterfaceList
        2 - DeletedInterfaceList
        3 - UpdatedInterfaceList
        4 - CreatedInterfaceList
        5 - CreatedNetworkList

--*/


#ifdef __cplusplus
}
#endif


#endif // ifndef _CLNETCFG_INCLUDED_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\ext\mfcapwz\inc5\customaw.h ===
#ifndef __CUSTOMAW_H__
#define __CUSTOMAW_H__

#include <afxdisp.h>
#include <ObjModel\appauto.h>
#include <ObjModel\bldauto.h>

/////////////////////////////////////////////////////////////////////////////
// customaw.h -- Header file to be included by all custom AppWizards.

// Link to the AppWizard import library
#pragma comment(lib, "mfcapwz.lib")

/////////////////////////////////////////////////////////////////////////////
// Class CAppWizStepDlg-- all custom AppWizard steps must derive from
//  this class

class CAppWizStepDlg : public CDialog
{
public:
	CAppWizStepDlg(UINT nIDTemplate);
	~CAppWizStepDlg();
	virtual BOOL OnDismiss();

	// You will probably not want to override or call this function.  It is
	//  overridden (for CAppWizStepDlg) in MFCAPWZ.DLL to handle tabbing from
	//  the dialog controls in CAppWizStepDlg to the outer AppWizard dialog's
	//  controls.
    virtual BOOL PreTranslateMessage(MSG* pMsg);


	// You will probably not want to override or call this function.  It is
	//  overridden (for CAppWizStepDlg) in MFCAPWZ.DLL to dynamically change
	//  the dialog template's font to match the rest of the IDE.
	virtual BOOL Create(UINT nIDTemplate, CWnd* pParentWnd = NULL);

	UINT m_nIDTemplate;
};


/////////////////////////////////////////////////////////////////////////////
// class OutputStream-- this abstract class is used to funnel output while
//  parsing templates.

class OutputStream
{
public:
    virtual void WriteLine(LPCTSTR lpsz) = 0;
    virtual void WriteBlock(LPCTSTR pBlock, DWORD dwSize) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// Class CCustomAppWiz-- all custom AppWizards must have a class derived from
//  this.  MFCAPWZ.DLL talks to the custom AppWizard by calling these virtual
//  functions.

class CCustomAppWiz : public CObject
{
public:
	CMapStringToString m_Dictionary;

	virtual void GetPlatforms(CStringList& rPlatforms) {}

	virtual CAppWizStepDlg* Next(CAppWizStepDlg* pDlg) { return NULL; }
	virtual CAppWizStepDlg* Back(CAppWizStepDlg* pDlg) { return NULL; }

	virtual void InitCustomAppWiz() { m_Dictionary.RemoveAll(); }
	virtual void ExitCustomAppWiz() {}

	virtual LPCTSTR LoadTemplate(LPCTSTR lpszTemplateName,
		DWORD& rdwSize, HINSTANCE hInstance = NULL);

	virtual void CopyTemplate(LPCTSTR lpszInput, DWORD dwSize, OutputStream* pOutput);
	virtual void ProcessTemplate(LPCTSTR lpszInput, DWORD dwSize, OutputStream* pOutput);
	virtual void PostProcessTemplate(LPCTSTR szTemplate) {}

	virtual void CustomizeProject(IBuildProject* pProject) {}
};


/////////////////////////////////////////////////////////////////////////////
// C API's exported by AppWizard.  The custom AppWizard talks to MFCAPWZ.DLL
//  by calling these functions.

// Values to be passed to GetDialog()
enum AppWizDlgID
{
	APWZDLG_APPTYPE = 1,
	APWZDLG_DATABASE,
	APWZDLG_OLE,
	APWZDLG_DOCAPPOPTIONS,
	APWZDLG_PROJOPTIONS,
	APWZDLG_CLASSES,
	APWZDLG_DLGAPPOPTIONS,
	APWZDLG_DLLPROJOPTIONS,
};

void SetCustomAppWizClass(CCustomAppWiz* pAW);
CAppWizStepDlg* GetDialog(AppWizDlgID nID);
void SetNumberOfSteps(int nSteps);
BOOL ScanForAvailableLanguages(CStringList& rLanguages);
void SetSupportedLanguages(LPCTSTR szSupportedLangs);


#endif //__CUSTOMAW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\ext\gc\inc\gct.h ===
/*
 * This software and its associated documentation are protected by
 *   Copyright 1995 Geodesic Systems Inc. All Rights Reserved.
 * Portions of the software include modification to code which was
 * released publicly by Xerox Corporation, subject to the requirement that
 * the following notice be retained and included with the modified code:
 *  "Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers.
 *   Copyright (c) 1991-1995 by Xerox Corporation.
 *   All rights reserved. THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY
 *   NO WARRANTY EXPRESS OR IMPLIED. ANY USE IS AT YOUR OWN RISK."
 */
/* Fiterman, May 8, 1997 14:20 am CST */

#ifndef _GCT_H
# define _GCT_H

# ifdef __cplusplus
    extern "C" {
# endif

# include <stddef.h>
# include <stdlib.h>


#define NO_PARAMS void

#ifdef __cplusplus
# undef NO_PARAMS
#endif


#ifndef NO_PARAMS
# define NO_PARAMS
#endif

#ifdef GC_BUILD_DLL
#  define GC_SYS_IMPORT __declspec(dllimport)
#  define GC_IMPORTX  __declspec(dllexport)
#  define GC_EXPORT   __declspec(dllexport)
#  ifdef GC_CRTDLL
#	define GC_EXPORTY(t)	__declspec(dllexport) t
#  else
#   define GC_EXPORTY(t) t
#  endif

#  define GC_EXPORTX(t) GC_EXPORTY(t) __cdecl
#else /* GC_BUILD_DLL */
#  define GC_IMPORTX    __declspec(dllimport)
#  define GC_EXPORTX(t) __declspec(dllimport) t
#  ifdef __cplusplus
#	define gcInitFunction extern "C" __declspec(dllexport) void __cdecl
#  else
#	define gcInitFunction __declspec(dllexport) void
#  endif
#  define GC_EXPORTY(x) x
#endif /* GC_BUILD_DLL */
#define GC_IMPORT extern GC_IMPORTX

/*
 * Define word and signed_word to be unsigned and signed types of the
 * size as char * or void *.  There seems to be no way to do this
 * even semi-portably.  The following is probably no better/worse
 * than almost anything else
 * The ANSI standard suggests that size_t and ptr_diff_t might be
 * better choices.  But those appear to have incorrect definitions
 * on may systems.  Notably "typedef int size_t" seems to be both
 * frequent and WRONG
 */
typedef unsigned long gcWord;
typedef long gcSignedWord;

/* Public read-only variables */

GC_IMPORT gcWord gcCollections;   /* Counter incremented per collection. */

/* Public R/W variables */

/*
 * Non zero Enables logging output. This involves a performance
 * cost and is thus not the default.
 */
GC_IMPORT long gcPrintStats;

/*
 * Print memory usage statistics
 */
GC_IMPORT int gcPrintMemUsage;

/* 
 * Consider as roots all non heap mappings where pointers can be found 
 * Sunos only
 */
GC_IMPORT int gcScanAllPotentialRoots;

/* Disable signals in critical sections of the collector */
GC_IMPORT int gcDisableSignalsSwitch;

/* Memory explicitly freed before next footprint-reduce */
GC_IMPORT unsigned long gcMaxMemFreedBeforeNextFootPrintReduce;

/* 
 * Some applications like netscape with java change the location of
 * the execution stack (Argh!). This causes the collector to smash memory when
 * cleaning the stack. When this variable is set to 0, the stack is cleaned
 * just a little above the current sp. This prevents netscape with java from
 * crashing.
 */
GC_IMPORT int gcAllowUserStacks;

/*
 * Memory usage statistics are obtained at the end of a garbage collection
 * This variable forces a collection every so many bytes allocated.
 * The initialy value is 1 Mb and it can be changed at run time with
 * an environment var.
 */
GC_IMPORT unsigned long gcBytesBeforeNextStatistics;


/*
 * Non zero enables collect at end.	Defaults to 1 for report
 * libs and zero otherwise.
 */
GC_IMPORT int gcCollectAtEnd;

/*
 * Defaults to zero which implies not flushing the log file.
 * If gcFlushLog > 0 flush the log file every gcFlushLog lines.
 */
GC_IMPORT int gcFlushLog;

/*
 * Normally non leaf objects are zeroed to avoid spotting pointers
 * in them when they are reallocated. Setting this to zero prevents
 * that and may speed up some programs.
 */
GC_IMPORT int gcZeroAllocatedObject;

/*
 * Non zero enables free(). zero causes free() to be ignored.
 * defaults to one. Not used in the report libraries.
 */
GC_IMPORT char gcEnableFree;

/*
 * gcFixPrematureFrees() sets gcEnableFree to 0; and other 
 * tuning stuff. Fixing premature frees may increase memory 
 * usage. gcStopFixingPrematureFrees(NO_PARAMS) has the opposite
 * effect. Both functions return nonzero if premature frees
 * were previously being fixed.
 */
GC_EXPORTX(int) gcFixPrematureFrees(NO_PARAMS);
GC_EXPORTX(int) gcStopFixingPrematureFrees(NO_PARAMS);

/*
 * If gcEnableFree is zero and gcFreeProcessOldObject is non
 * zero it will be called to process the free()ed object.
 * gcFreeProcessOldObject defaults to zero.	gcDefaultFreeProcessOldObject
 * will zero old objects which seems a reasonable.
 */
typedef void (* gcObjectFunction)(void *obj, size_t size);
GC_EXPORTX(void) gcDefaultFreeProcessOldObject(void *obj, size_t size);

GC_IMPORT gcObjectFunction gcFreeProcessOldObject;


/*
 * This points to the name of the log file. It is initially aimed at
 * "gc.log", it is used to create the log file the first time output
 * is done, after that it is never used. This constant is contained
 * in a separate module so it can be replaced before startup.
 */
typedef const char * gcConstCharStar;
GC_IMPORT gcConstCharStar gcLogFile;

/*
 * Activates stack tracing on the position where items are allocated.
 * Only used when linked to a debug library.
 */
GC_IMPORT int gcShowStackTrace;

/*
 * When an attempted allocation fails, Great Circle must decide whether to
 * collect or expand the heap.	gcNotTransparent != 0 says always expand
 * this until stopped by gcSetMaxHeapSize or a failure to expand.
 * gcDontExpand != 0 says always collect but then expand if that isn't enough.
 *
 * Otherwise collect if (M > N/(gcPriority + 1)) where N is the heap size plus
 * a rough estimate of the root set size, and M is the amount allocated since
 * the last complete collection.
 *
 * Initially, gcPriority = 3, increasing its value will use less space but
 * more collection time. Decreasing it will appreciably decrease collection
 * time at the expense of space. gcPriority = 0 will cause the equation to
 * always choose expand. Setting incremental mode or pseudo incremental mode
 * effectivly doubles gcPriority. Since a single paging operation is likely
 * to eat more time than the collector ever could, increasing the number of
 * collections has the paradoxical effect of speeding up some programs.
 *
 * If you call gcAttemptCollection() the equation (M > N/(gcPriority + 1))
 * will determine if a collection actually takes place.
 */
GC_IMPORT unsigned gcPriority;
GC_IMPORT int gcNotTransparent;	
GC_IMPORT int gcDontExpand;

/*
 * Number of partial collections between full collections.
 * Matters only if gcIncremental is set.
 */
GC_IMPORT int gcFullFrequency;
			
#ifdef GC_DEBUG
#define GC_DEBUG_BOUNDS_CHECK 1
#define GC_DEBUG_LINE_NUMBERS 1
#define GC_WRAPPED_NEW new(__FILE__, __LINE__)
#else
#define GC_WRAPPED_NEW new
#endif

/* Public procedures */

/*
 * General purpose allocation routines, with malloc calling conventions.
 * The leaf versions promise that no relevant pointers are contained
 * in the object.  The nonleaf versions guarantee that the new object
 * is cleared. gcMallocManual allocates an object that is scanned
 * for pointers to collectible objects, but is not itself collectible.
 */
GC_EXPORTX(void *) gcMalloc(size_t size_in_bytes);
GC_EXPORTX(void *) gcMallocLeaf(size_t size_in_bytes);
GC_EXPORTX(void *) gcMallocManual(size_t size_in_bytes);

/*
 * Explicitly deallocate an object.  Dangerous if used incorrectly.
 * Requires a pointer to the base of an object.
 * An object should not be enabled for finalization when it is
 * explicitly deallocated.
 * gcFree(0) is a no-op, as required by ANSI C for free.
 */
  GC_EXPORTX(void) gcFree(void * object_addr);

/*
 * gcMallocIgnoreOffPage reduces the chance of accidentally retaining
 * a large, > 4096 byte, object as a result of scanning an integer
 * that happens to be an address inside the array. Large arrays usually
 * are only used where there is a pointer to the beginning of the array.
 *
 * This was built around the needs of very large Xwindows programs, we
 * have discovered that it works well with almost all programs, improving
 * space and speed efficiency.
 *
 * gcMallocIgnoreOffPage(lb) acts like malloc(lb) except that only pointers
 * to the first 4096 bytes will be used by the collector to keep the
 * object alive. If lb is smaller than 4K it acts exactly like malloc.
 *
 * gcMallocIgnoreOffPage is the connection for malloc(lb) where
 * lb > gcVeryLargeAllocationSize && gcIgnoreOffPage
 *
 * gcVeryLargeAllocationSize is initialized to 100000.
 *
 * gcIgnoreOffPage is in a separate module in the libraries to
 * allow you to replace it in programs where you have no source code, or
 * where you need it replaced before startup code runs. This also effects
 * calloc and realloc. It is initialized to 1 except in the gcsome and
 * gcsomedb libraries where it is initialized to 0.
 *
 * If we need a block N bytes long and have a block > N + gcBlackSizeLimit
 * and N > gcBlackSizeLimit but all possible positions in it are
 * the targets of apparent pointers, we use it anyway and print a warning.
 * This risks leaking the block due to a false reference. But not using
 * it risks unreasonable immeadiate heap growth. gcBlackSizeLimit defaults
 * to 100K.
 */ 
GC_EXPORTX(void *) gcMallocIgnoreOffPage(size_t lb);
GC_EXPORTX(void *) gcMallocLeafIgnoreOffPage(size_t lb);

GC_IMPORT unsigned long gcVeryLargeAllocationSize;
GC_IMPORT int gcIgnoreOffPage;
GC_IMPORT long gcBlackSizeLimit;

/* Kinds of objects */
# define gcLeafObject							0
# define gcCollectibleObject					1
# define gcManualObject							2

/*
 * Return the kind of an object, gcLeafObject etc.
 */
GC_EXPORTX(int) gcWhatKind(void *p);

/*
 * Return a pointer to the base (lowest address) of an object given
 * a pointer to a location within the object
 * Return 0 if displaced_pointer doesn't point to within a valid object.
 * gcIsValidPointer returns the start of the users area.
 * gcBase may point to debug information if present.
 */
GC_EXPORTX(void *) gcIsValidPointer(const void * displaced_pointer);
GC_EXPORTX(void *) gcBase(const void * displaced_pointer);

/*
 * Check object with debugging info. Return kinds of
 * damage found as bit flags.
 *  1 User size smashed
 *  2 Start Flag smashed
 *  4 Near End flag smashed
 *  8 Far End flag smashed
 * 16 Previously freed.
 * 32 not a collectible object
 * 64 too small for a debug object od debug lib not used
 */
GC_EXPORTX(int) gcObjectCheck(const void *ohdr);

/*
 * Given a pointer into an object, return its size in bytes. gcFullSize
 * includes the debug header.
 */
GC_EXPORTX(size_t) gcSize(const void * object_addr);
GC_EXPORTX(size_t) gcFullSize(const void * object_addr);

/*
 * A realloc()'ed object has the same collection kind as the original
 */
GC_EXPORTX(void *) gcRealloc(void * old_object, size_t new_size_in_bytes);

/* 
 * Logging and diagnostic output.
 *
 * gcPrintf, gcErrorPrintf, gcWarningPrintf, gcAbort, gcReportLeak,
 * gcAbortPrintf and gcLogFileAbort all point at functions used for 
 * various kinds of logging. The are initialized to point to functions 
 * who`s names are gcDefaultPrintf, gcDefaultErrorPrintf etc.
 *
 * gcDefaultPrintf and gcDefaultErrorPrintf both print to the log file.
 *
 * gcDefaultWarningPrintf() only prints to the logfile if gcPrintStats
 * is nonzero. Otherwise it does nothing.
 * 
 * gcDefaultAbortPrintf() formats a line and calls gcAbort.
 *
 * gcDefaultAbort() prints and exits.
 *
 * gcReportLeak() is used by the gcreport and gcreptdb libs to report
 * leaks. It's work is primarily done by gcPrintObj().
 *
 * If gcLogAllLeaks is nonzero, all leaks are reported to the log file.
 * If nonzero, only the first gcMaximumLeaksToLogFile are printed.
 *
 * void gcPuts() invokes via the function pointer gcPutsFunction which
 * defaults to gcDefaultPuts. In the threads libraries it locks and unlocks
 * the log file to prevent chaos. gcDefaultPuts discards calls made before
 * the collector is initialized.
 *
 * void gcDefaultPuts(const char *msg); writes to gcLogFile and insures it
 * is flushed every gcFlushLog lines. It is used by the above logging
 * functions. It may call gcLogFileAbort() which reports failures in using 
 * gcLogFile and then aborts, hopefully a rare event. In GUI environment and 
 * other situations, the user may wish to replace this. The function of 
 * gcDefaultLogFileAbort is 
 *   sprintf(buf, "%s of %s failed.\n", msg, gcLogFile);
 *   display buf somehow with the log file dead.
 *   abort();
 */
typedef void (* gcPrintFunction)(const char *, ...);
typedef void (* gcPutFunction)(const char *msg);

GC_EXPORTX(void) gcDefaultPrintf(const char *, ...);
GC_EXPORTX(void) gcDefaultAbortPrintf(const char *, ...);
GC_EXPORTX(void) gcDefaultWarningPrintf(const char *, ...);
GC_EXPORTX(void) gcDefaultErrorPrintf(const char *, ...);
GC_EXPORTX(void) gcDefaultAbort(const char *msg);
GC_EXPORTX(void) gcPuts(const char *msg);
GC_EXPORTX(void) gcDefaultPuts(const char *msg);
GC_EXPORTX(void) gcDefaultLogFileAbort(const char *msg);
GC_EXPORTX(void) gcDefaultReportLeak(const char *msg);

GC_IMPORT gcPrintFunction gcPrintf,	gcAbortPrintf, gcWarningPrintf, 
		  gcErrorPrintf;
GC_IMPORT gcPutFunction gcAbort, gcLogFileAbort, gcReportLeak, gcPutsFunction;
GC_IMPORT int gcLogAllLeaks;
GC_IMPORT unsigned gcMaximumLeaksToLogFile;
GC_IMPORT int gcGUIEnabled;

/*
 * p points to somewhere inside an object.
 * Print a human readable description of the object using gcPrintf. If the
 * object has debugging information, this will all be printed as well.
 */
GC_EXPORTX(void) gcPrintObject(const void *p);

/*
 * Returns the debugging information
 */
GC_EXPORTX(char *) gcDebugString(const void *p);

GC_EXPORTX(int) gcDebugInt(const void *p);

/*
 * Explicitly increase the heap size. Returns 0 on failure, 1 on success.
 * If you can use this to set your heap size to near its final value
 * your program will run more efficiently due to fewer collection cycles
 * and more efficient data structures. gcLogFile will show log when collector
 * expands the heap and how much. You may want to use gcNotTransparent 
 * and gcSetMaxHeapSize() instead.
 */
GC_EXPORTX(int) gcExpandHeap(size_t number_of_bytes);

/*
 * Limit the heap size to n bytes.  Useful when you're debugging
 * especially on systems that don't handle running out of memory well
 * n == 0 ==> unbounded.  This is the default
 */
GC_EXPORTX(void) gcSetMaxHeapSize(long n);

/*
 * gcClearRoots clears the set of root segments.
 * gcAddRoots Adds a root segment. 
 * gcDeclareLeafRoot declares all or part of a root segment as leaf. 
 * All for wizards only. 
 */
GC_EXPORTX(void) gcClearRoots(NO_PARAMS);
GC_EXPORTX(void) gcAddRoots(const char *low_address, 
							const char *high_address_plus_1);
GC_EXPORTX(void) gcDeclareLeafRoot(const char *low_address, 
								   const char *high_address_plus_1);

/* Explicitly trigger a full, world-stop collection. 	*/
GC_EXPORTX(void) __cdecl gcCollect(NO_PARAMS);

/*
 * Trigger a full world-stopped collection.  Abort the collection if
 * and when stop_func returns a nonzero value.  gcIdleTest will be
 * called frequently, and should be reasonably fast.  This works even
 * if virtual dirty bits, and hence incremental collection is not
 * available for this architecture.  Collections can be aborted faster
 * than normal pause times for incremental collection.  However,
 * aborted collections do no useful work; the next collection needs
 * to start from the beginning.
 */
typedef int (* gcIdleTestFunction)(NO_PARAMS);
GC_EXPORTX(int) gcAttemptCollection(NO_PARAMS);

/*
 * Explicitly trigger a full world-stop collection followed by
 * an explicit foot print reduce, or attempt to do so. Footprint
 * reduce wont free memory used since the last footprint reduce.
 * Normally this is correct but to do an extreme job call twice.
 */
GC_EXPORTX(void) gcFootPrintReduce(NO_PARAMS);
GC_EXPORTX(int) gcAttemptFootPrintReduce(NO_PARAMS);

/*
 * In windows mode this defaults to gcMSWinIdleTest otherwise it
 * starts null and must be aimed by the user. Only used by gcAttemptCollection
 * and gcEnablePseudoIncremental.
 */
GC_IMPORT gcIdleTestFunction gcIdleTest;

/*
 * In Pseudo incremental mode Great Circle will periodically call
 * gcAttemptCollection();
 * in an attempt to free storage before increasing allocated heap.
 * There is actually a complex heuristic involved using the amount
 * allocated since the last collection and a few other things.
 */
GC_EXPORTX(int) gcEnablePseudoIncremental(NO_PARAMS);
GC_EXPORTX(int) gcDisablePseudoIncremental(NO_PARAMS);

/*
 * gcNeverStopFunc can be used as a gcIdleTestFunction, gcAttemptCollection 
 * recongizes it and is extra efficient.
 */
GC_EXPORTX(int) gcNeverStopFunc(NO_PARAMS);

/*
 * gcMSWinIdleTest is an idle test designed for the Windows environment.
 * It returns a 1 if there are windows events to process.
 */
GC_EXPORTX(int) gcMSWinIdleTest(NO_PARAMS);


/*
 * Return the number of bytes in the heap.  Excludes collector private
 * data structures.  Includes empty blocks and fragmentation loss.
 */
GC_EXPORTX(size_t) gcGetHeapSize(NO_PARAMS);

/* Return the number of bytes allocated since the last collection.	*/
GC_EXPORTX(size_t) gcGetBytesSinceGc(NO_PARAMS);

/*
 * Enable incremental/generational collection.
 * Don't use in leak finding mode.
 */
GC_EXPORTX(void) gcEnableIncremental(NO_PARAMS);

/*
 * Perform some garbage collection work, if appropriate.
 * Return 0 if there is no more work to be done.
 * Typically performs an amount of work corresponding roughly
 * to marking from one page.  Does nothing if incremental collection is
 * disabled.  It is reasonable to call this in a wait loop
 * until it returns 0. Returns 0 if not in incremental mode.
 */
GC_EXPORTX(int) gcMinWork(NO_PARAMS);

/*
 * This sets the scan alignment. gcSetScanAlignment(4) says all pointers
 * will be found on a 4 boundary. gcSetScanAlignment(1) says pointers may
 * be on any byte boundary. This returns True on success False on failure.
 * It hopefully defaults to the values used by the compiler to align pointers
 * and should not be reset unless you force pointers to odd boundaries.
 * This is checked to be 8, 4, 2 or 1 and minamum value.
 */
GC_EXPORTX(int) gcSetScanAlignment(int align);

/* Get current scan Alignment */
GC_EXPORTX(int) gcGetScanAlignment(NO_PARAMS);

/*
 * Debugging (annotated) allocation.  gcCollect will check
 * objects allocated in this way for overwrites, etc. See
 * #ifdef GC_DEBUG at the end of this file.
 */
GC_EXPORTX(void *) __cdecl gcMallocDebug(size_t size_in_bytes,
				const char * descr_string, int descr_int);
GC_EXPORTX(void *) __cdecl gcMallocLeafDebug(size_t size_in_bytes,
  				       const char * descr_string, int descr_int);
GC_EXPORTX(void *) __cdecl gcMallocIgnoreOffPageDebug(size_t size_in_bytes,
  				const char * descr_string, int descr_int);
GC_EXPORTX(void *) __cdecl gcMallocLeafIgnoreOffPageDebug(size_t size_in_bytes,
  				       const char * descr_string, int descr_int);
GC_EXPORTX(void *) __cdecl gcMallocManualDebug(size_t size_in_bytes,
  				           const char * descr_string, int descr_int);
GC_EXPORTX(void) __cdecl gcFreeDebug(void * object_addr);
GC_EXPORTX(void *) __cdecl gcReallocDebug(void * old_object,
  			 	 size_t new_size_in_bytes,
  			 	 const char * descr_string, int descr_int);
GC_EXPORTX(void *) __cdecl gcGlobalMallocDebug(size_t size,
									const char * descr_string,
									int lineNo);

#define gcCalloc(size, num) gcMalloc((size) * (num))

/*
 * Finalization.  gcDeclareFinalizer[Offset] uses an ignore 
 * selfpointers form required by C++. The Offset form is required by C++.
 * See the C++ section of this file for an example.
 * gcDeclareFinalizerNoPointers declares the finalized object has no pointers
 * to other objects that it requires at finalization time.
 */
typedef void (* gcFinalizationProc)(void * obj);
GC_EXPORTX(void) gcRegisterFinalizer(void * obj,
		gcFinalizationProc fn, void * cd);
GC_EXPORTX(void) gcDeclareFinalizer(void * obj, gcFinalizationProc fn);
GC_EXPORTX(void) gcDeclareFinalizerNoPointers(void * obj, 
	  gcFinalizationProc fn, void * cd);
GC_EXPORTX(void) gcDeclareFinalizerOffset(void * obj,
		gcFinalizationProc fn, void * cd);

/*
 * The following routine may be used to break cycles between
 * finalizable objects, thus causing cyclic finalizable
 * objects to be finalized in the correct order.  Standard
 * use involves calling gcPtrNotUsedByFinalizer(&p)
 * where p is a pointer that is not used by finalization
 * code, and should not be considered in determining
 * finalization order.
 */
GC_EXPORTX(int) gcPtrNotUsedByFinalizer(void **link);

/*
 * If you have called gcDisappearingPtr(link, obj), then *link
 * will be automatically zeroed when the data pointed to by
 * obj becomes inaccessible. This will happen before any finalization
 * occurs.
 *
 * Returns 1 if link was already registered, 0 otherwise.
 *
 * gcDisappearingPtr is often used when implementing weak pointers
 * (pointers that are not traced during collection). By ensuring that
 * the weak pointer is zeroed if the data it is pointing to goes away,
 * the danger of following a loose weak pointer is eliminated.
 *
 * In this case, have link point to a location holding
 * a disguised pointer to obj.  (A pointer inside a "leaf"
 * object is efficiently disguised.) The pointer is zeroed
 * when obj becomes inaccessible. Each link may be registered only
 * once. However, it should be unregistered and reregistered if
 * the pointer is modified to point at a differenct object.
 *
 * Note that obj may be resurrected by another finalizer.
 */
GC_EXPORTX(int) gcDisappearingPtr(void ** link, void * obj);
GC_EXPORTX(int) gcUnregisterDisappearingPtr(void ** link);

/*
 * Converting a hidden pointer to a real pointer requires verifying
 * that the object still exists.  This involves acquiring the
 * allocator lock to avoid a race with the collector.
 */
typedef void * (*gcFnType)(void *);
GC_EXPORTX(void *) gcCallWithAllocLock(gcFnType fn, void * client_data);

/*
 * If p and q point to the same object returns p else calls gcAbort()
 * Succeeds if neither p nor q points to the heap.
 */
GC_EXPORTX(void *) gcSameObj(void *p, void *q);
GC_EXPORTX(void) gcSetDirty(void *);
GC_EXPORTX(int) gcInSameObj(void *, void *);

/*
 * Safer, but slow, pointer addition.  Probably useful mainly with
 * a preprocessor.  Useful only for heap pointers.
 */
#ifdef GC_DEBUG_BOUNDS_CHECK
#   define GC_PTR_ADD(x, n)  ((gcSameObj((void *)((x)+(n)), (void *)(x))), ((x)+(n)))
#else	/* !GC_DEBUG_BOUNDS_CHECK */
#   define GC_PTR_ADD(x, n) ((x)+(n))
#endif

/* Safer assignment of a pointer to a nonstack location.	*/
#ifdef GC_DEBUG_BOUNDS_CHECK
#   define GC_PTR_STORE(p, q) \
	(*(void **)gcIsVisible(p) = gcIsValidDisplacement(q))
#else /* !GC_DEBUG_BOUNDS_CHECK */
#   define GC_PTR_STORE(p, q) *((p) = (q))
#endif

/*
 * gcHidePointer takes a pointer and flips its bits so Great Circle
 * wont recognise it as a pointer. gcRevealPointer flips them back.
 */
# define gcHidePointer(p) (~(gcWord)(p))
# define gcRevealPointer(p) ((void *)(gcHidePointer(p)))

/*
 * Under Windows there are operating system calls to get memory
 * (Global|Local)|(Alloc|ReAlloc). By default, we pass these calls
 * on to Windows, although we still scan such memory for pointers.
 * You can redefine this behavior in your gcInitialize() function
 * by settin gcAllocBehavior to GC_INTERCEPT. In this case, Great
 * Circle will garbage collect memory allocated by (Global|Local)|(Alloc|ReAlloc)
 * except when allocated with the (GMEM|LMEM)_(MOVEABLE|DISCARDABLE) flags.
 */
#define GC_INTERCEPT		 0	/* intercept calls */
#define GC_PASS_THROUGH		 1	/* DEFAULT: pass through calls trace */
                                /* their results. */
#define GC_TRACE_ALL		 2  /* pass through calls trace their results */
                                /* on a per-object basis. */

GC_IMPORT int gcAllocBehavior;
GC_IMPORT int gcAllocWarn;	/* warnings for (Global|Local)|(Alloc|ReAlloc) */

GC_EXPORTX(const char *) gcGetDllName();
GC_IMPORT int gcDontInterceptCRunTimeDLL;

/*
 * Allocates a page, generally 4K, of objects and returns them as a list
 * linked through their first word.  Its use can greatly reduce lock 
 * contention problems in threaded systems, since the allocation lock 
 * can be acquired and released many fewer times. In unthreaded systems
 * this is pointless. These are always non debug objects.
 */
GC_EXPORTX(void *) gcMallocMany(size_t lb);

/* Retrive the next item in list reutrned by gcMallocMany */
#define GC_NEXT(p) (*(void **)(p)) 
 
#   define GC_INIT()


/*
 * Call to register root segments.
 */
GC_EXPORTX(void) gcRegisterDLL(char * static_root);

/* these are used to identify the library used */
GC_EXPORTX(const char *) gcLibrary(NO_PARAMS);    /* gcall etc */
GC_EXPORTX(const char *) gcCompiler(NO_PARAMS);   /* compiler used */
GC_EXPORTX(int) gcVersion(NO_PARAMS); /* version number * 100, 1.1 -> 110 */
GC_EXPORTX(int) gcBuildNo(NO_PARAMS); /* Build number */
GC_EXPORTX(int) gcThreads(NO_PARAMS); /* 1 if thread safe 0 otherwise */
GC_EXPORTX(long) gcEvaluationCopy();  /* Returns non zero for eval copies */

/*
 * gcFreeX is exactly like free but has a consistent interface.
 * some systems have a free that cleverly returns an int.
 */
GC_EXPORTX(void) gcFreeX(void *);

enum gcNewType {
	gcMemDefault = 0, /* don't change threads code uses values */
	gcMemAuto    = 1,
	gcMemLeaf    = 2,
	gcMemManual  = 3,
	gcMemAutoIgn = 4,
	gcMemLeafIgn = 5
};

#ifdef __cplusplus
    }  /* end of extern "C" */
/* C++ Interface to GCTransparent */







# include <new.h>
#define gcSetDirty(x)


#define GC_CLASS_HAS_POINTERS \
  void * operator new(size_t s) { return gcNewDefaultAuto(s); } \
  void * operator new(size_t s, char *f, int l) \
    { return gcNewDefaultAuto(s, f, l); } \
  void operator delete( void* obj ) { gcFreeX(obj); }
#define GC_CLASS_HAS_NO_POINTERS \
  void * operator new(size_t s) { return gcNewDefaultLeaf(s); } \
  void * operator new(size_t s, char *f, int l) \
    { return gcNewDefaultLeaf(s, f, l); } \
  void operator delete( void* obj ) { gcFreeX(obj); }
#define GC_CLASS_IS_MANUAL \
  void * operator new(size_t s) { return gcNewDefaultManual(s); } \
  void * operator new(size_t s, char *f, int l) \
    { return gcNewDefaultManual(s, f, l); } \
  void operator delete( void* obj ) { gcFreeX(obj); }


GC_EXPORTX(void *) gcNewDefaultAuto(size_t s);
GC_EXPORTX(void *) gcNewDefaultAuto(size_t s, const char *file, int line);
GC_EXPORTX(void *) gcNewDefaultLeaf(size_t s);
GC_EXPORTX(void *) gcNewDefaultLeaf(size_t s, const char *file, int line);
GC_EXPORTX(void *) gcNewDefaultManual(size_t s);
GC_EXPORTX(void *) gcNewDefaultManual(size_t s, const char *file, int line);

GC_EXPORTY(void *) __cdecl operator new(size_t size);
GC_EXPORTY(void *) __cdecl operator new(size_t size, const char *file, int line);
GC_EXPORTY(void) __cdecl operator delete(void *);



/*
 * Instances of classes derived from "gc" will be allocated in the 
 * collected heap by default, unless an explicit placement is
 * specified.
 */
GC_EXPORTY(class) gc {
public:
  GC_CLASS_HAS_POINTERS
  void* operator new(size_t, void *p) { return p; }
};

extern "C" {
  GC_EXPORTX(void) gcSetAllocator(gcNewType);
}

#define GC_NEW(x)					   (gcSetAllocator(gcMemAuto), new x)
#define GC_NEW_LEAF(x)				   (gcSetAllocator(gcMemLeaf), new x)
#define GC_NEW_MANUAL(x)			   (gcSetAllocator(gcMemManual), new x)
#define GC_NEW_IGNORE_OFF_PAGE(x)	   (gcSetAllocator(gcMemAutoIgn), new x)
#define GC_NEW_LEAF_IGNORE_OFF_PAGE(x) (gcSetAllocator(gcMemLeafIgn), new x)

#define GC_NEW_ARRAY(s, t) \
 (new gcArrayBase(GC_NEW(t[s]), s, sizeof(t)))
#define GC_NEW_LEAF_ARRAY(s, t) \
 (new gcArrayBase(GC_NEW_LEAF(t[s]), s, sizeof(t)))
#define GC_NEW_MANUAL_ARRAY(s, t) \
 (new gcArrayBase(GC_NEW_MANUAL(t[s]), s, sizeof(t)))
#define GC_NEW_LEAF_IGNORE_OFF_PAGE_ARRAY(s, t) \
 (new gcArrayBase(GC_NEW_LEAF_IGNORE_OFF_PAGE(t[s]), s, sizeof(t)))
#define GC_NEW_IGNORE_OFF_PAGE_ARRAY(s, t) \
 (new gcArrayBase(GC_NEW_IGNORE_OFF_PAGE(t[s]), s, sizeof(t)))
/*
 * Class gcLWCleanup behaves like gcCleanup except that it does not inherit
 * from class gc. Therefore, you must be sure that your class is being
 * allocated as garbage collected (e.g. if you are using the gcall library).
 * gcLWCleanup is useful when private inheritance is making class gc's
 * operator new inaccessible.
 */
GC_EXPORTY(class) gcLWCleanup {
public:
	inline gcLWCleanup();
inline virtual ~gcLWCleanup();
private:
	inline static void cleanup( void* obj );
};

class gcCleanup: virtual public gc, virtual public gcLWCleanup {};

/*
 * Instances of classes derived from "gcCleanup" will be allocated
 * in the collected heap by default.  When the collector discovers an
 * inaccessible object derived from "gcCleanup" or containing a
 * member derived from "gcCleanup", its destructors will be
 * invoked.
 */

inline gcLWCleanup::~gcLWCleanup() {
	 gcDeclareFinalizer(this, 0);
}

inline void gcLWCleanup::cleanup( void* obj ) {
	((gcLWCleanup*)obj)->~gcLWCleanup();
}

inline gcLWCleanup::gcLWCleanup() {
	 void* base;

	 if (0 != (base = gcBase((void *)this)))
		  gcDeclareFinalizerOffset(base,
								 (gcFinalizationProc)cleanup,
								 (void*)this);
}

#include <assert.h>

#define GC_TEMPLATE template<class T>


#ifndef GC_DEBUG
#define GC_ASSERT(cond, message)
#else
#define GC_ASSERT(cond, message) if (!(cond)) \
  gcErrorPrintf("%s\n", message);
#endif

/* Parent for wrapped data pointers and references. */
template<class T>
class gcWrap {
public:
  int gcPtrNotUsedByFinalizer() {
	return ::gcPtrNotUsedByFinalizer((void **)&data);
  }
protected:
  gcWrap() { 
	setPointer(); 
  }
  gcWrap(T *p) { 
	setPointer(p);
  }
  gcWrap(const gcWrap< T > &p) {
	setPointer(p);
  }
  /* This exists because stack frames may not be zeroed. */
  ~gcWrap() {
	setPointer();
  }
  void dirtyPointer() { 
	gcSetDirty(&data);
  }
  void setPointer() { 
	data = 0; 
  }
  void setPointer(T* p) { 
	dirtyPointer(); 
	data = p; 
  }
  void setPointer(const gcWrap< T > &p) { 
	dirtyPointer();	
	data = p.data; 
  }

  T* data;			/* The pointer to the actual object */
};


template<class T>
class gcPtr : public gcWrap<T> {
public:
	gcPtr()                           {}
	gcPtr(T *p) : gcWrap<T>(p)       {}
	gcPtr(const gcPtr< T > &p) : gcWrap<T>(p) {}
	T* operator=(T *x)                 { 
		setPointer(x); 
		return data; 
	}
	T* operator=(const gcPtr< T > &x) { 
		setPointer(x); 
		return data; 
	}
	operator T*()	const              { 
		return data; 
	}
	operator void*()	const              { 
		return (void *)data; 
	}
	T* operator()() const              { 
		return data; 
	}
	T* operator->() const              { 
		return data; 
	}
	int operator!() const              { 
		return data == 0; 
	}
	int operator==(const gcPtr< T > &x) const { 
		return data == x.data; 
	}
	int operator==(T *x) const         { 
		return data == x; 
	}
	int operator!=(const gcPtr< T > &x) const { 
		return data != x.data;	
	}
	int operator!=(T *x) const         { 
		return data != x; 
	}
	T& operator[](int n) const;
	T* operator+(int n) const;
	T* operator-(int n) const;
	T* operator+=(int n);
	T* operator-=(int n);
#ifdef GC_DEBUG_BOUNDS_CHECK
	T* operator=(int n) {
		GC_ASSERT(!n, "Invalid integer to pointer assignment");
		setPointer();
		return 0;
	}
	T& operator*() const {
		GC_ASSERT(data, "Dereference of null pointer");
		return *data;
	}
#else
	T* operator=(int)                  { 
		setPointer(); 
		return 0; 
	}
	T& operator*() const               { return *data; }
#endif
};

template<class T>
inline T& gcPtr<T>::operator[]( int n ) const {
	return *(data + n); 
}

template<class T>
inline 	T* gcPtr<T>::operator+(int n) const          { 
	return data + n; 
}

template<class T>
inline 	T* gcPtr<T>::operator-(int n) const          { 
	return data - n; 
}

template<class T>
inline 	T* gcPtr<T>::operator+=(int n)               { 
	return data = (data + n); 
}

template<class T>
inline	T* gcPtr<T>::operator-=(int n)               { 
	return data = (data - n); 
}

template<class T>
class gcRef : public gcWrap<T> {
	gcRef()                           {}
	gcRef(const T &x) : gcWrap<T>((T *)&x) {}
	gcRef(const gcRef< T > &x) : gcWrap<T>(x) {}
/* The next two operators may not inline right */
	void operator=(T &x)               { 
		*data = x; 
	}
	void operator=(const gcRef< T > &x) { 
		*data = x(); 
		x.dirtyPointer(); 
	}

	T& operator()() const              { 
		return *data; 
	}
	operator T&() const                { 
		return *data; 
	}
};

/* Return values for gcInBounds tests */
enum gcArrayTest {
	gcNotAnArray,
	gcPointerOk,
	gcPointerTooLow,
	gcPointerTooHigh,
	gcPointerAtEnd
};

/* Parent of all array class templates. */
class gcArrayBase : public gc {
public:	
	gcArrayBase(void *array, size_t count, size_t size) :
		gcData(array), gcCount(count), gcItemLen(size) {}

	operator void *() const {
		return gcData;
	}
	size_t size() const {
		return gcCount * gcItemLen;
	}
	void * gcArrayTop() const {		
		return (char *)gcData + size();
	}
	size_t len() const {
		return gcCount;
	}
	void setLen(size_t newLen) {
		GC_ASSERT((gcCount >= newLen), "Array length set too long");
		gcCount = newLen;
	}
	int gcValidReference(const void *p) {
		return p < gcArrayTop() && p >= (void *)*this;
	}
	void * operator +(size_t x) {
		return (char *)(void *)*this + (x * gcItemLen);
	} 
	gcArrayTest gcInBounds(const void *newP) const {
		gcArrayTest ii = ( gcArrayTest ) 0;
		if ((unsigned long)newP < (unsigned long)(void *)*this)
			ii = gcPointerTooLow;

		if ((unsigned long)newP > (unsigned long)gcArrayTop())
			ii = gcPointerTooHigh;
		if (!ii)
			ii = (newP == gcArrayTop()) ? gcPointerAtEnd : gcPointerOk;
		return ii;
	}

private:
	void *gcData;
	size_t gcCount, gcItemLen;
};

template<class T>
class gcArrayPtr {
protected:
	T *data;					/* Pointer to array item */
	gcArrayBase * array;		/* The pointer to the actual array base or zero */

	void dirtyPointer() { 
        gcSetDirty(&data);
	}
	void setPointer() { 
		data  = 0;
		array = 0;
	}
	void setPointer(T* p) { 
		dirtyPointer(); 
		data  = p; 
		array = 0;
	}
	void setPointer(const gcArrayPtr< T > &p) { 
		dirtyPointer();	
		data  = p.data; 
	    array = p.array;
	}
	void setPointer(gcArrayBase *p) { 
		dirtyPointer();	
		data  = (T*)(void *)*p; 
	    array = p;
	}
public:
	gcArrayPtr() { 
		setPointer(); 
	}
	gcArrayPtr(T *p) {
		setPointer(p);
	}
	gcArrayPtr(const gcArrayPtr< T > &p) {
		setPointer(p);
	}
	gcArrayPtr(gcArrayBase *p) {
		setPointer(p);
	}
	int gcPtrNotUsedByFinalizer() {
		::gcPtrNotUsedByFinalizer((void **)&array);
		return ::gcPtrNotUsedByFinalizer((void **)&data);
	}
	T* operator=(gcArrayBase *x) {
		setPointer(x);
		return data;
	}
	T* operator=(T *x) {
		array = 0;
		setPointer(x);
		return data;
	}
	T* operator=(const gcArrayPtr< T > &x) {
		setPointer(x);
		return data;
	}
	operator void*()	const              { 
		return (void *)data; 
	}
	T* operator()() const {
		return data;
	}
	int operator!() const {
		return data == 0;
	}
	int operator==(const gcArrayPtr< T > &x) const {
		return data == x.data;
	}
	int operator==(T *x) const {
		return data == x;
	}
	int operator!=(const gcArrayPtr< T > &x) const {
		return data != x.data;
	}
	int operator!=(T *x) const {
		return data != x;
	}
	T* operator+(int n) const {
                return data + n;
        }
	T* operator-(int n) const {
		return (*this) + -n;
	}
	T* operator+=(int n) {
		return data = (*this + n);
	}
	T* operator-=(int n) {
		return data = (*this + -n);
	}
	size_t len() const {
		return array ? array->len() : 0;
	}
	size_t size() const {
		return array ? array->size() : 0;
	}
	void setLen(size_t l) {
		if (array)
			array->setLen(l);
	}
#ifdef GC_DEBUG_BOUNDS_CHECK
	T* operator=(int n) {
		GC_ASSERT(!n, "Invalid integer to pointer assignment");
		setPointer();
		return 0;
	}																
	T& operator[](int n) {
		GC_ASSERT(array->gcValidReference((void *)(data + n)),
			"Invalid array reference");
		return *(*this + n);
	}
	T& operator	 *() const {
		GC_ASSERT(array->gcValidReference((void *)data),
			"Invalid array pointer dereferenced");
		return *data;
	}
#else
	T* operator=(int) {
		setPointer();
		return 0;
	}
	T& operator*() const {
		return *data;
	}
	T& operator[](int n) {
		return *(*this + n);
	}
#endif

	gcArrayTest gcInObject(void *loc) const {
		gcArrayTest ii = ( gcArrayTest ) 0;
		if (!data)
			ii = gcNotAnArray;
		else if (array) {
			if (loc < (void *)*array)
				ii = gcPointerTooLow;
			else if (loc > array->gcArrayTop())
				ii = gcPointerTooHigh;
			else if (loc == array->gcArrayTop())
				ii = gcPointerAtEnd;
			else
				ii = gcPointerOk;
		}
		else if (gcInSameObj((void *)data, (void *)loc))
			ii = gcPointerOk;
		else
			ii = ((void *)loc > (void *)data) ? gcPointerTooHigh : gcPointerTooLow;
		return (ii);
	}
	gcArrayTest gcInBounds(int n) const {
		return gcInObject(data + n);
	}
};

#endif /* __cplusplus */

# ifdef GC_DEBUG_LINE_NUMBERS
#   define malloc(sz) gcGlobalMallocDebug((sz), __FILE__, __LINE__)
#   define calloc(sz, cnt) gcGlobalMallocDebug((sz)*(cnt), __FILE__, __LINE__)
#   define gcMalloc(sz) gcMallocDebug((sz), __FILE__, __LINE__)
#   define gcMallocLeaf(sz) gcMallocLeafDebug((sz), __FILE__, __LINE__)
#   define gcMallocIgnoreOffPage(sz) gcMallocIgnoreOffPageDebug((sz), __FILE__, __LINE__)
#   define gcMallocLeafIgnoreOffPage(sz) gcMallocLeafIgnoreOffPageDebug((sz), __FILE__, __LINE__)
#   define gcMallocManual(sz) gcMallocManualDebug((sz), \
							__FILE__, __LINE__)
#   define gcRealloc(old, sz) gcReallocDebug((old), (sz), __FILE__, \
							       __LINE__)
#   define realloc(old, sz) gcReallocDebug((old), (sz), __FILE__, \
							       __LINE__)
#   define gcFree(p) gcFreeDebug(p)
# endif
#endif /* _GCT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\inc\clusdef.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    clusdef.h

Abstract:

    Common definitions for user-mode and kernel-mode components of the
    cluster project.

Author:

    Mike Massa (mikemas) 15-Feb-1997

Revision History:

--*/
#ifndef _CLUSDEF_H
#define _CLUSDEF_H


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

//
// Cluster node ID definition
//
typedef ULONG CL_NODE_ID;

#define ClusterMinNodeId         1
#define ClusterMinNodeIdString   L"1"
#define ClusterDefaultMaxNodes   16
#define ClusterAnyNodeId         0
#define ClusterInvalidNodeId     0xFFFFFFFF


//
// Default clusnet endpoint value assigned by IANA
//
#define CLUSNET_DEFAULT_ENDPOINT_STRING   L"3343"    // our UDP port number

//
// Default role for a cluster network.
//
#define CL_DEFAULT_NETWORK_ROLE    ClusterNetworkRoleInternalAndClient


//
// Cluster network ID definition
//
typedef ULONG CL_NETWORK_ID, *PCL_NETWORK_ID;

#define ClusterAnyNetworkId         0
#define ClusterInvalidNetworkId     0xFFFFFFFF

//
// ClusNet node communication state definition
//
typedef enum {
    ClusnetNodeCommStateOffline = 0,
    ClusnetNodeCommStateOfflinePending = 1,
    ClusnetNodeCommStateUnreachable = 2,
    ClusnetNodeCommStateOnlinePending = 3,
    ClusnetNodeCommStateOnline = 4
} CLUSNET_NODE_COMM_STATE, *PCLUSNET_NODE_COMM_STATE;

//
// ClusNet network state definition
//
typedef enum {
    ClusnetNetworkStateOffline = 0,
    ClusnetNetworkStateOfflinePending = 1,
    ClusnetNetworkStatePartitioned = 2,
    ClusnetNetworkStateOnlinePending = 3,
    ClusnetNetworkStateOnline = 4
} CLUSNET_NETWORK_STATE, *PCLUSNET_NETWORK_STATE;

//
// ClusNet interface state definition
//
typedef enum {
    ClusnetInterfaceStateOffline = 0,
    ClusnetInterfaceStateOfflinePending = 1,
    ClusnetInterfaceStateUnreachable = 2,
    ClusnetInterfaceStateOnlinePending = 3,
    ClusnetInterfaceStateOnline = 4
} CLUSNET_INTERFACE_STATE, *PCLUSNET_INTERFACE_STATE;

//
// ClusNet node membership state. This tracks the internal
// membership state maintained by the membership engine in the cluster
// service. This enum MUST start at zero since it is used as an index
// into a state table.
//

typedef enum {
    ClusnetNodeStateAlive = 0,
    ClusnetNodeStateJoining,
    ClusnetNodeStateDead,
    ClusnetNodeStateNotConfigured,
    ClusnetNodeStateLastEntry
} CLUSNET_NODE_STATE, *PCLUSNET_NODE_STATE;

//
// ClusNet Event definitions
//
typedef enum _CLUSNET_EVENT_TYPE {
    ClusnetEventNone                    = 0x00000000,
    ClusnetEventNodeUp                  = 0x00000001,
    ClusnetEventNodeDown                = 0x00000002,
    ClusnetEventPoisonPacketReceived    = 0x00000004,
    ClusnetEventHalt                    = 0x00000008,

    ClusnetEventNetInterfaceUp          = 0x00000010,
    ClusnetEventNetInterfaceUnreachable = 0x00000020,
    ClusnetEventNetInterfaceFailed      = 0x00000040,

    ClusnetEventAddAddress              = 0x00000100,
    ClusnetEventDelAddress              = 0x00000200,

    ClusnetEventMulticastSet            = 0x00001000,

    ClusnetEventAll                     = 0xFFFFFFFF
} CLUSNET_EVENT_TYPE, *PCLUSNET_EVENT_TYPE;

typedef struct {
    ULONG                 Epoch;
    CLUSNET_EVENT_TYPE    EventType;
    CL_NODE_ID            NodeId;
    CL_NETWORK_ID         NetworkId;
} CLUSNET_EVENT, *PCLUSNET_EVENT;

//
// ClusNet NTSTATUS codes are now located in ntstatus.h
//

#ifdef __cplusplus
}
#endif // __cplusplus


#endif //_CLUSDEF_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\inc\clrtldbg.h ===
/***
*ClRtlDbg.h - Supports debugging features for clusters (from the C runtime library).
*
*		Copyright (c) 1994-1998, Microsoft Corporation. All rights reserved.
*
*Purpose:
*		Support Cluster debugging features.
*
*		[Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __CLRTLDBG_H_
#define __CLRTLDBG_H_


#ifdef	__cplusplus
extern "C" {
#endif /* __cplusplus */


#ifndef CLRTL_INCLUDE_DEBUG_REPORTING

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

#define _CLRTL_ASSERT(expr) ((void)0)

#define _CLRTL_ASSERTE(expr) ((void)0)


#define _CLRTL_RPT0(rptno, msg)

#define _CLRTL_RPT1(rptno, msg, arg1)

#define _CLRTL_RPT2(rptno, msg, arg1, arg2)

#define _CLRTL_RPT3(rptno, msg, arg1, arg2, arg3)

#define _CLRTL_RPT4(rptno, msg, arg1, arg2, arg3, arg4)


#define _CLRTL_RPTF0(rptno, msg)

#define _CLRTL_RPTF1(rptno, msg, arg1)

#define _CLRTL_RPTF2(rptno, msg, arg1, arg2)

#define _CLRTL_RPTF3(rptno, msg, arg1, arg2, arg3)

#define _CLRTL_RPTF4(rptno, msg, arg1, arg2, arg3, arg4)

#define _ClRtlSetReportHook(f)			((void)0)
#define _ClRtlSetReportMode(t, f) 		((int)0)
#define _ClRtlSetReportFile(t, f) 		((void)0)

#define _ClRtlDbgBreak()				((void)0)


#else /* CLRTL_INCLUDE_DEBUG_REPORTING */


 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/


/* Define _CLRTLIMP */

#ifndef _CLRTLIMP
//#ifdef	_DLL
//#define _CLRTLIMP __declspec(dllimport)
//#else	/* ndef _DLL */
#define _CLRTLIMP
//#endif	/* _DLL */
#endif	/* _CLRTLIMP */

/* Define NULL pointer value */

#ifndef NULL
#ifdef	__cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

typedef void *_HFILE; /* file handle pointer */

#define _CLRTLDBG_WARN			0
#define _CLRTLDBG_ERROR			1
#define _CLRTLDBG_ASSERT 		2
#define _CLRTLDBG_ERRCNT 		3

#define _CLRTLDBG_MODE_FILE		0x1
#define _CLRTLDBG_MODE_DEBUG	0x2
#define _CLRTLDBG_MODE_WNDW		0x4
#define _CLRTLDBG_REPORT_MODE	-1

#define _CLRTLDBG_INVALID_HFILE ((_HFILE)-1)
#define _CLRTLDBG_HFILE_ERROR   ((_HFILE)-2)
#define _CLRTLDBG_FILE_STDOUT   ((_HFILE)-4)
#define _CLRTLDBG_FILE_STDERR   ((_HFILE)-5)
#define _CLRTLDBG_REPORT_FILE   ((_HFILE)-6)

//#if 	defined(_DLL) && defined(_M_IX86)
//#define _clrtlAssertBusy	 (*__p__clrtlAssertBusy())
//_CLRTLIMP long * __cdecl __p__clrtlAssertBusy(void);
//#else	/* !(defined(_DLL) && defined(_M_IX86)) */
//_CLRTLIMP extern long _clrtlAssertBusy;
//#endif	/* defined(_DLL) && defined(_M_IX86) */

typedef int (__cdecl * _CLRTL_REPORT_HOOK)(int, char *, int *);

_CLRTLIMP _CLRTL_REPORT_HOOK __cdecl _ClRtlSetReportHook(
		_CLRTL_REPORT_HOOK
		);

_CLRTLIMP int __cdecl _ClRtlSetReportMode(
		int,
		int
		);

_CLRTLIMP _HFILE __cdecl _ClRtlSetReportFile(
		int,
		_HFILE
		);

_CLRTLIMP int __cdecl _ClRtlDbgReport(
		int,
		const char *,
		int,
		const char *,
		const char *,
		...);

/* Asserts */

#define _CLRTL_ASSERT(expr) \
		do { if (!(expr) && \
				(1 == _ClRtlDbgReport(_CLRTLDBG_ASSERT, __FILE__, __LINE__, NULL, NULL))) \
			 _ClRtlDbgBreak(); } while (0)

#define _CLRTL_ASSERTE(expr) \
		do { if (!(expr) && \
				(1 == _ClRtlDbgReport(_CLRTLDBG_ASSERT, __FILE__, __LINE__, NULL, #expr))) \
			 _ClRtlDbgBreak(); } while (0)


/* Reports with no file/line info */

#define _CLRTL_RPT0(rptno, msg) \
		do { if ((1 == _ClRtlDbgReport(rptno, NULL, 0, NULL, "%s", msg))) \
				_ClRtlDbgBreak(); } while (0)

#define _CLRTL_RPT1(rptno, msg, arg1) \
		do { if ((1 == _ClRtlDbgReport(rptno, NULL, 0, NULL, msg, arg1))) \
				_ClRtlDbgBreak(); } while (0)

#define _CLRTL_RPT2(rptno, msg, arg1, arg2) \
		do { if ((1 == _ClRtlDbgReport(rptno, NULL, 0, NULL, msg, arg1, arg2))) \
				_ClRtlDbgBreak(); } while (0)

#define _CLRTL_RPT3(rptno, msg, arg1, arg2, arg3) \
		do { if ((1 == _ClRtlDbgReport(rptno, NULL, 0, NULL, msg, arg1, arg2, arg3))) \
				_ClRtlDbgBreak(); } while (0)

#define _CLRTL_RPT4(rptno, msg, arg1, arg2, arg3, arg4) \
		do { if ((1 == _ClRtlDbgReport(rptno, NULL, 0, NULL, msg, arg1, arg2, arg3, arg4))) \
				_ClRtlDbgBreak(); } while (0)


/* Reports with file/line info */

#define _CLRTL_RPTF0(rptno, msg) \
		do { if ((1 == _ClRtlDbgReport(rptno, __FILE__, __LINE__, NULL, "%s", msg))) \
				_ClRtlDbgBreak(); } while (0)

#define _CLRTL_RPTF1(rptno, msg, arg1) \
		do { if ((1 == _ClRtlDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1))) \
				_ClRtlDbgBreak(); } while (0)

#define _CLRTL_RPTF2(rptno, msg, arg1, arg2) \
		do { if ((1 == _ClRtlDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2))) \
				_ClRtlDbgBreak(); } while (0)

#define _CLRTL_RPTF3(rptno, msg, arg1, arg2, arg3) \
		do { if ((1 == _ClRtlDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3))) \
				_ClRtlDbgBreak(); } while (0)

#define _CLRTL_RPTF4(rptno, msg, arg1, arg2, arg3, arg4) \
		do { if ((1 == _ClRtlDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3, arg4))) \
				_ClRtlDbgBreak(); } while (0)

#if 	defined(_M_IX86) && !defined(_CLRTL_PORTABLE)
#define _ClRtlDbgBreak() __asm { int 3 }
#elif	defined(_M_ALPHA) && !defined(_CLRTL_PORTABLE)
void _BPT();
#pragma intrinsic(_BPT)
#define _ClRtlDbgBreak() _BPT()
#else
_CLRTLIMP void __cdecl _ClRtlDbgBreak(
		void
		);
#endif

#endif // CLRTL_INCLUDE_DEBUG_REPORTING

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif // __CLRTLDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\inc\cluster.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    cluster.h

Abstract:

    Top-level include file for all user-mode components in the cluster
    project.

Author:

    John Vert (jvert) 30-Nov-1995

Revision History:


Environment:

    User-mode only.

--*/

#ifndef _CLUSTER_H
#define _CLUSTER_H


#include "resapi.h"
#include "clusdef.h"
#include "clusudef.h"
#include "clusrtl.h"
#include "clusapi.h"


//
// Global Debugging Definitions
//

#if DBG

#define CL_SIG_FIELD                  DWORD    Signature;
#define CL_INIT_SIG(pstruct, sig)     ( (pstruct)->Signature = (sig) )
#define CL_ASSERT_SIG(pstruct, sig)   CL_ASSERT((pstruct)->Signature == (sig))

#else // DBG

#define CL_SIG_FIELD
#define CL_INIT_SIG(pstruct, sig)
#define CL_ASSERT_SIG(pstruct, sig)

#endif // DBG

#endif //_CLUSTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\inc\clusterwarnings.h ===
// This first line keeps us at least as stringent as the build:
// - from %_ntroot%\base\public\sdk\inc\warning.h
//
#include <warning.h>

/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    RHSWarnings.h

Abstract:
    This header turns on warnings for Level 3 that are normally
    associated with Level 4.

Author:

    Conor Morrison      X-1             17-Jan-2001

Revision History:
--*/
#ifndef IA64
#if 0
//! Would like to get these back in...
#pragma warning ( 3 : 4701 )      // local variable 'name' may be used without having been initialized
#pragma warning ( 3 : 4706 )      // assignment within conditional expression

// These warnings turned off to keep the noise down!
//
#pragma warning ( 3 : 4100 )      // 'identifier' : unreferenced formal parameter
#pragma warning ( 3 : 4201 )      // nonstandard extension used : nameless struct/union
#pragma warning ( 3 : 4127 )      // conditional expression is constant
#pragma warning ( 3 : 4211 )      // nonstandard extension used : redefined extern to static
#pragma warning ( 3 : 4232 )      // nonstandard extension used : 'identifier' : address of dllimport 'dllimport' is not static, identity not guaranteed
#pragma warning ( 3 : 4214 )      // nonstandard extension used : bit field types other than int
#pragma warning ( 3 : 4057 )      // 'operator' : 'identifier1' indirection to slightly different base types from 'identifier2'
#pragma warning ( 3 : 4245 )      // 'conversion' : conversion from 'type1' to 'type2', signed/unsigned mismatch
#pragma warning ( 3 : 4152 )      // non standard extension, function/data ptr conversion in expression
#pragma warning ( 3 : 4514 )      // unreferenced inline/local function has been removed
#pragma warning ( 3 : 4505 )      // 'function' : unreferenced local function has been removed
#pragma warning ( 3 : 4131 )      // 'function' : uses old-style declarator
#endif

#if 1
#pragma warning ( 3 : 4239 )      // nonstandard extension used : 'token' : conversion from 'type' to 'type'

#pragma warning ( 3 : 4019 )      // empty statement at global scope
#pragma warning ( 3 : 4032 )      // formal parameter 'number' has different type when promoted

#pragma warning ( 3 : 4061 )      // enumerate 'identifier' in switch of enum 'identifier' is not explicitly handled by a case label
#pragma warning ( 3 : 4092 )      // sizeof returns 'unsigned long'
#pragma warning ( 3 : 4112 )      // #line requires an integer between 1 and 32767
#pragma warning ( 3 : 4121 )      // 'symbol' : alignment of a member was sensitive to packing
#pragma warning ( 3 : 4125 )      // decimal digit terminates octal escape sequence
#pragma warning ( 3 : 4128 )      // storage-class specifier after type
#pragma warning ( 3 : 4130 )      // 'operator ' : logical operation on address of string constant
#pragma warning ( 3 : 4132 )      // 'object' : const object should be initialized
#pragma warning ( 3 : 4134 )      // conversion between pointers to members of same class
#pragma warning ( 3 : 4200 )      // nonstandard extension used : zero-sized array in struct/union
#pragma warning ( 3 : 4202 )      // nonstandard extension used : '...': prototype parameter in name list illegal
#pragma warning ( 3 : 4206 )      // nonstandard extension used : translation unit is empty
#pragma warning ( 3 : 4207 )      // nonstandard extension used : extended initializer form
#pragma warning ( 3 : 4208 )      // nonstandard extension used : delete [exp] - exp evaluated but ignored
#pragma warning ( 3 : 4209 )      // nonstandard extension used : benign typedef redefinition
#pragma warning ( 3 : 4210 )      // nonstandard extension used : function given file scope
#pragma warning ( 3 : 4212 )      // nonstandard extension used : function declaration used ellipsis
#pragma warning ( 3 : 4213 )      // nonstandard extension used : cast on l-value
#pragma warning ( 3 : 4220 )      // varargs matches remaining parameters
#pragma warning ( 3 : 4221 )      // nonstandard extension used : 'identifier' : cannot be initialized using address of automatic variable 
#pragma warning ( 3 : 4223 )      // nonstandard extension used : non-lvalue array converted to pointer
#pragma warning ( 3 : 4233 )      // nonstandard extension used : 'keyword' keyword only supported in C++, not C
#pragma warning ( 3 : 4234 )      // nonstandard extension used: 'keyword' keyword reserved for future use
#pragma warning ( 3 : 4235 )      // nonstandard extension used : 'keyword' keyword not supported in this product
#pragma warning ( 3 : 4236 )      // nonstandard extension used : 'keyword' is an obsolete keyword, see documentation for __declspec(dllexport )
#pragma warning ( 3 : 4238 )      // nonstandard extension used : class rvalue used as lvalue
#pragma warning ( 3 : 4244 )      // 'conversion' conversion from 'type1' to 'type2', possible loss of data
#pragma warning ( 3 : 4268 )      // 'identifier' : 'const' static/global data initialized with compiler generated default constructor fills the object with zeros
#pragma warning ( 3 : 4355 )      // 'this' : used in base member initializer list
#pragma warning ( 3 : 4504 )      // type still ambiguous after parsing 'number' tokens, assuming declaration
#pragma warning ( 3 : 4507 )      // explicit linkage specified after default linkage was used
#pragma warning ( 3 : 4515 )      // 'namespace' : namespace uses itself
#pragma warning ( 3 : 4516 )      // 'class::symbol' : access-declarations are deprecated; member using-declarations provide a better alternative
#pragma warning ( 3 : 4517 )      // access-declarations are deprecated; member using-declarations provice a better alternative
#pragma warning ( 3 : 4611 )      // interaction between '_setjmp' and C++ object destruction is non-portable
#pragma warning ( 3 : 4663 )      // C++ language change: to explicitly specialize class template 'identifier' use the following syntax:
#pragma warning ( 3 : 4665 )      // C++ language change: assuming 'declaration' is an explicit specialization of a function template
#pragma warning ( 3 : 4670 )      // 'identifier' : this base class is inaccessible
#pragma warning ( 3 : 4671 )      // 'identifier' : the copy constructor is inaccessible
#pragma warning ( 3 : 4672 )      // 'identifier1' : ambiguous. First seen as 'identifier2'
#pragma warning ( 3 : 4673 )      // throwing 'identifier' the following types will not be considered at the catch site
#pragma warning ( 3 : 4674 )      // 'identifier' : the destructor is inaccessible
#pragma warning ( 3 : 4699 )      // Note: pre-compiled header usage information message
#pragma warning ( 3 : 4705 )      // statement has no effect
#pragma warning ( 3 : 4709 )      // comma operator within array index expression
#pragma warning ( 3 : 4727 )      // conditional expression is constant

//#pragma warning ( 3 : 4710 )      // 'function' : function not inlined

#endif
#endif // ifndef IA64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\inc\clusverp.h ===
/****************************************************************************
 *                                                                          *
 *      clusverp.H        -- Version information for cluster builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION, VER_PRODUCTVERSION_STR and             *
 *      VER_PRODUCTBETA_STR values.                                         *
 *                                                                          *
 ****************************************************************************/

#include <ntverp.h>

//
// the following defines are used as internal version numbers to indicate
// the level of compatibility provided by this cluster service implmentation.
// These numbers are changed during product upgrades and are, essentially,
// a combination of the major, minor and QFE versions The QFE version info
// is not available but only as a text string from GetVersionEx hence we
// don't use that information directly.
//

#define CLUSTER_INTERNAL_CURRENT_MAJOR_VERSION 4
#define CLUSTER_INTERNAL_PREVIOUS_HIGHEST_VERSION 0x00030893
#define CLUSTER_INTERNAL_PREVIOUS_LOWEST_VERSION 0x000200e0

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

#define VER_CLUSTER_PRODUCTNAME_STR         "Microsoft(R) Cluster service"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\inc\clusrtl.h ===
/*++

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    clusrtl.h

Abstract:

    Header file for definitions and structures for the NT Cluster
    Run Time Library

Author:

    John Vert (jvert) 30-Nov-1995

Revision History:

--*/

#ifndef _CLUSRTL_INCLUDED_
#define _CLUSRTL_INCLUDED_


//
// Service Message IDs
//
#include "clusvmsg.h"

#include "resapi.h"
#include <aclapi.h>
#include <netcon.h>
#include <winioctl.h>

#ifdef __cplusplus
extern "C" {
#endif

//
//  Routine Description:
//
//      Initializes the cluster run time library.
//
//  Arguments:
//
//      DbgOutputToConsole - TRUE if the debug output should be written to a
//                           console window
//
//      DbgLogLevel - pointer to a DWORD that contains the current msg filter
//      level. checked by ClRtlDbgPrint.
//
//  Return Value:
//
//      ERROR_SUCCESS if the function succeeds.
//      A Win32 error code otherwise.
//

DWORD
ClRtlInitialize(
    IN  BOOL    DbgOutputToConsole,
    IN  PDWORD  DbgLogLevel
    );


//
//  Routine Description:
//
//      Cleans up the cluster run time library.
//
//  Arguments:
//
//      None.
//
//  Return Value:
//
//      None.
//
VOID
ClRtlCleanup(
    VOID
    );

//
//  Routine Description:
//
//      Checks to see if Services for MacIntosh is installed.
//
//  Arguments:
//
//      Pointer to boolean that tells if SFM is installed.
//
//  Return Value:
//
//      Status of request.
//

DWORD
ClRtlIsServicesForMacintoshInstalled(
    OUT BOOL * pfInstalled
    );

//////////////////////////////////////////////////////////////////////////
//
// Event logging interfaces
//
//
// There are three currently defined logging levels:
//     LOG_CRITICAL - fatal error, chaos and destruction will ensue
//     LOG_UNUSUAL  - unexpected event, but will be handled
//     LOG_NOISE    - normal occurence
//
//////////////////////////////////////////////////////////////////////////

#define LOG_CRITICAL 1
#define LOG_UNUSUAL  2
#define LOG_NOISE    3

//
// A few interfaces for reporting of errors.
//
VOID
ClRtlEventLogInit(
    VOID
    );
 
VOID
ClRtlEventLogCleanup(
    VOID
    );
 


VOID
ClusterLogFatalError(
    IN ULONG LogModule,
    IN ULONG Line,
    IN LPSTR File,
    IN ULONG ErrCode
    );

VOID
ClusterLogNonFatalError(
    IN ULONG LogModule,
    IN ULONG Line,
    IN LPSTR File,
    IN ULONG ErrCode
    );

VOID
ClusterLogAssertionFailure(
    IN ULONG LogModule,
    IN ULONG Line,
    IN LPSTR File,
    IN LPSTR Expression
    );

VOID
ClusterLogEvent0(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes
    );

VOID
ClusterLogEvent1(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1
    );

VOID
ClusterLogEvent2(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2
    );

VOID
ClusterLogEvent3(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2,
    IN LPCWSTR Arg3
    );

VOID
ClusterLogEvent4(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2,
    IN LPCWSTR Arg3,
    IN LPCWSTR Arg4
    );

//
//  Routine Description:
//
//      Prints a message to the debugger if running as a service
//      or the console window if running as a console app.
//
//  Arguments:
//
//      LogLevel - Supplies the logging level, one of
//                    LOG_CRITICAL 1
//                    LOG_UNUSUAL  2
//                    LOG_NOISE    3
//
//      FormatString     - Message string.
//
//      Any FormatMessage-compatible arguments to be inserted in the
//      ErrorMessage before it is logged.
//
//  Return Value:
//
//      None.
//
VOID
__cdecl
ClRtlDbgPrint(
    DWORD LogLevel,
    PCHAR FormatString,
    ...
    );

//
// Same as ClRtlDbgPrint, only uses a message ID instead of a string.
//
VOID
__cdecl
ClRtlMsgPrint(
    IN DWORD MessageId,
    ...
    );

//
// Same as ClRtlDbgPrint, only logs to a file instead of screen.
//
VOID
__cdecl
ClRtlLogPrint(
    DWORD LogLevel,
    PCHAR FormatString,
    ...
    );

//
// Macros/prototypes for unexpected error handling.
//

#define ARGUMENT_PRESENT( ArgumentPointer )   (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )


WINBASEAPI
BOOL
APIENTRY
IsDebuggerPresent(
    VOID
    );

#define CL_UNEXPECTED_ERROR(_errcode_)              \
    ClusterLogFatalError(LOG_CURRENT_MODULE,        \
                         __LINE__,                  \
                         __FILE__,                  \
                        (_errcode_))

#if DBG
#define CL_ASSERT( exp )                                    \
    if (!(exp)) {                                           \
        ClusterLogAssertionFailure(LOG_CURRENT_MODULE,      \
                                   __LINE__,                \
                                   __FILE__,                \
                                   #exp);                   \
    }

#define CL_LOGFAILURE( _errcode_ )                  \
ClusterLogNonFatalError(LOG_CURRENT_MODULE,         \
                         __LINE__,                  \
                         __FILE__,                  \
                        (_errcode_))
#else
#define CL_ASSERT( exp )
#define CL_LOGFAILURE( _errorcode_ )
#endif

// Use the following to put cluster specific errors in the event log

#define CL_LOGCLUSINFO( _errcode_ )        \
ClusterLogEvent0(LOG_NOISE,                \
                 LOG_CURRENT_MODULE,       \
                 __FILE__,                 \
                 __LINE__,                 \
                 (_errcode_),              \
                 0,                        \
                 NULL)

#define CL_LOGCLUSWARNING( _errcode_ )     \
ClusterLogEvent0(LOG_UNUSUAL,              \
                 LOG_CURRENT_MODULE,       \
                 __FILE__,                 \
                 __LINE__,                 \
                 (_errcode_),              \
                 0,                        \
                 NULL)


#define CL_LOGCLUSWARNING1(_msgid_,_arg1_)          \
    ClusterLogEvent1(LOG_UNUSUAL,                   \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_))

#define CL_LOGCLUSERROR( _errcode_ )        \
ClusterLogEvent0(LOG_CRITICAL,              \
                 LOG_CURRENT_MODULE,        \
                 __FILE__,                  \
                 __LINE__,                  \
                 (_errcode_),               \
                 0,                         \
                 NULL)

#define CL_LOGCLUSERROR1(_msgid_,_arg1_)            \
    ClusterLogEvent1(LOG_CRITICAL,                  \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_))

#define CL_LOGCLUSERROR2(_msgid_,_arg1_, _arg2_)    \
    ClusterLogEvent2(LOG_CRITICAL,                  \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_),                           \
                (_arg2_))


//////////////////////////////////////////////////////////////////////////
//
// General-purpose hash table package
//
//////////////////////////////////////////////////////////////////////////

#define MAX_CL_HASH  16                         // the size of the table

typedef struct _CL_HASH_ITEM {
    LIST_ENTRY ListHead;
    DWORD      Id;
    PVOID      pData;
} CL_HASH_ITEM, *PCL_HASH_ITEM;
    
typedef struct _CL_HASH {
    CRITICAL_SECTION Lock;
    BOOL             bRollover;                 // flag to handle rollover
    DWORD            LastId;                    // last id used
    DWORD            CacheFreeId[MAX_CL_HASH];  // a cache of available id's
    CL_HASH_ITEM     Head[MAX_CL_HASH];
} CL_HASH, *PCL_HASH;


VOID
ClRtlInitializeHash(
    IN PCL_HASH pTable
    );

DWORD
ClRtlInsertTailHash(
    IN PCL_HASH pTable,
    IN PVOID    pData,
    OUT LPDWORD pId
    );

PVOID
ClRtlGetEntryHash(
    IN PCL_HASH pTable,
    IN DWORD Id
    );

PVOID
ClRtlRemoveEntryHash(
    IN PCL_HASH pTable,
    IN DWORD Id
    );

VOID
ClRtlDeleteHash(
    IN PCL_HASH pTable
    );


//////////////////////////////////////////////////////////////////////////
//
// General-purpose queue package.
//
//////////////////////////////////////////////////////////////////////////
typedef struct _CL_QUEUE {
    LIST_ENTRY ListHead;
    CRITICAL_SECTION Lock;
    HANDLE Event;
    DWORD Count;
    HANDLE Abort;
} CL_QUEUE, *PCL_QUEUE;

DWORD
ClRtlInitializeQueue(
    IN PCL_QUEUE Queue
    );

VOID
ClRtlDeleteQueue(
    IN PCL_QUEUE Queue
    );

PLIST_ENTRY
ClRtlRemoveHeadQueue(
    IN PCL_QUEUE Queue
    );


typedef 
DWORD
(*CLRTL_CHECK_HEAD_QUEUE_CALLBACK)(
    IN PLIST_ENTRY ListEntry,
    IN PVOID Context
    );
/*++

Routine Description:

    Called by ClRtlRemoveHeadQueueTimeout to determine 
    whether or not an entry at the head of the queue is 
    appropriate to dequeue and return or not.

Arguments:

    ListEntry - value of the PLIST_ENTRY we're examining

    Context - caller-defined data

Return Value:

    ERROR_SUCCESS if it's appropriate to return the event.

    A Win32 error code if the initialization failed.  This value
    can be retrieved by calling GetLastError().

--*/

PLIST_ENTRY
ClRtlRemoveHeadQueueTimeout(
    IN PCL_QUEUE Queue,
    IN DWORD dwMilliseconds,
    IN CLRTL_CHECK_HEAD_QUEUE_CALLBACK pfnCallback,
    IN PVOID pvContext
    );
    
VOID
ClRtlInsertTailQueue(
    IN PCL_QUEUE Queue,
    IN PLIST_ENTRY Item
    );

VOID
ClRtlRundownQueue(
    IN PCL_QUEUE Queue,
    OUT PLIST_ENTRY ListHead
    );


//////////////////////////////////////////////////////////////////////////
//
// General-purpose buffer pool package.
//
//////////////////////////////////////////////////////////////////////////

//
// Buffer pool definition.
//
typedef struct _CLRTL_BUFFER_POOL *PCLRTL_BUFFER_POOL;


//
// Maximum number of buffers that can be allocated from a pool.
//
#define CLRTL_MAX_POOL_BUFFERS  0xFFFFFFFE


//
// Routines for utilizing buffer pools.
//
typedef
DWORD
(*CLRTL_BUFFER_CONSTRUCTOR)(
    PVOID Buffer
    );
/*++

Routine Description:

    Called to initialize a buffer which has been newly allocated
    from system memory.

Arguments:

    Buffer  - A pointer to the buffer to initialize.

Return Value:

    ERROR_SUCCESS if the initialization succeeded.

    A Win32 error code if the initialization failed.

--*/


typedef
VOID
(*CLRTL_BUFFER_DESTRUCTOR)(
    PVOID Buffer
    );
/*++

Routine Description:

    Called to cleanup a buffer which is about to be returned to
    system memory.

Arguments:

    Buffer  - A pointer to the buffer to cleanup.

Return Value:

    None.

--*/


PCLRTL_BUFFER_POOL
ClRtlCreateBufferPool(
    IN DWORD                      BufferSize,
    IN DWORD                      MaximumCached,
    IN DWORD                      MaximumAllocated,
    IN CLRTL_BUFFER_CONSTRUCTOR   Constructor,         OPTIONAL
    IN CLRTL_BUFFER_DESTRUCTOR    Destructor           OPTIONAL
    );
/*++

Routine Description:

    Creates a pool from which fixed-size buffers may be allocated.

Arguments:

    BufferSize        - Size of the buffers managed by the pool.

    MaximumCached     - The maximum number of buffers to cache in the pool.
                        Must be less than or equal to MaximumAllocated.

    MaximumAllocated  - The maximum number of buffers to allocate from
                        system memory. Must be less than or equal to
                        CLRTL_MAX_POOL_BUFFERS.

    Constructor       - An optional routine to be called when a new buffer
                        is allocated from system memory. May be NULL

    Destructor        - An optional routine to be called when a buffer
                        is returned to system memory. May be NULL.

Return Value:

    A pointer to the created buffer pool or NULL on error.
    Extended error information is available from GetLastError().

--*/


VOID
ClRtlDestroyBufferPool(
    IN PCLRTL_BUFFER_POOL  Pool
    );
/*++

Routine Description:

    Destroys a previously created buffer pool.

Arguments:

    Pool  - A pointer to the pool to destroy.

Return Value:

    None.

Notes:

    The pool will not actually be destroyed until all outstanding
    buffers have been returned. Each outstanding buffer is effectively
    a reference on the pool.

--*/


PVOID
ClRtlAllocateBuffer(
    IN PCLRTL_BUFFER_POOL Pool
    );
/*++

Routine Description:

    Allocates a buffer from a previously created buffer pool.

Arguments:

    Pool - A pointer to the pool from which to allocate the buffer.

Return Value:

    A pointer to the allocated buffer if the routine was successfull.
    NULL if the routine failed. Extended error information is available
    by calling GetLastError().

--*/


VOID
ClRtlFreeBuffer(
    PVOID Buffer
    );
/*++

Routine Description:

    Frees a buffer back to its owning pool.

Arguments:

    Buffer   - The buffer to free.

Return Value:

    None.

--*/



//////////////////////////////////////////////////////////////////////////
//
// General-purpose worker thread queue package.
//
//////////////////////////////////////////////////////////////////////////

typedef struct _CLRTL_WORK_ITEM *PCLRTL_WORK_ITEM;

typedef
VOID
(*PCLRTL_WORK_ROUTINE)(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    );
/*++

Routine Description:

    Called to process an item posted to a work queue.

Arguments:

    WorkItem          - The work item to process.

    Status            - If the work item represents a completed I/O operation,
                        this parameter contains the completion status of the
                        operation.

    BytesTransferred  - If the work item represents a completed I/O operation,
                        this parameter contains the number of bytes tranferred
                        during the operation. For other work items, the
                        semantics of this parameter are defined by the caller
                        of ClRtlPostItemWorkQueue.

    IoContext         - If the work item represents a completed I/O operation,
                        this parameter contains the context value associated
                        with the handle on which the I/O was submitted. For
                        other work items, the semantics of this parameter are
                        defined by the caller of ClRtlPostItemWorkQueue.

Return Value:

    None.

--*/


//
// Work Item Structure.
//
typedef struct _CLRTL_WORK_ITEM {
    OVERLAPPED             Overlapped;
    PCLRTL_WORK_ROUTINE    WorkRoutine;
    PVOID                  Context;
} CLRTL_WORK_ITEM;


//
// Work queue definition.
//
typedef struct _CLRTL_WORK_QUEUE  *PCLRTL_WORK_QUEUE;


//
// Routines For Utilizing Work Queues
//

#define ClRtlInitializeWorkItem(Item, Routine, Ctx)                   \
            ZeroMemory(&((Item)->Overlapped), sizeof(OVERLAPPED));    \
            (Item)->WorkRoutine = (Routine);                          \
            (Item)->Context = (Ctx);


PCLRTL_WORK_QUEUE
ClRtlCreateWorkQueue(
    IN DWORD  MaximumThreads,
    IN int    ThreadPriority
    );
/*++

Routine Description:

    Creates a work queue and a dynamic pool of threads to service it.

Arguments:

    MaximumThreads - The maximum number of threads to create to service
                     the queue.

    ThreadPriority - The priority level at which the queue worker threads
                     should run.

Return Value:

    A pointer to the created queue if the routine is successful.

    NULL if the routine fails. Call GetLastError for extended
    error information.

--*/


VOID
ClRtlDestroyWorkQueue(
    IN PCLRTL_WORK_QUEUE  WorkQueue
    );
/*++

Routine Description:

    Destroys a work queue and its thread pool.

Arguments:

    WorkQueue  - The queue to destroy.

Return Value:

    None.

Notes:

    The following rules must be observed in order to safely destroy a
    work queue:

        1) No new work items may be posted to the queue once all previously
           posted items have been processed by this routine.

        2) WorkRoutines must be able to process items until this
           call returns. After the call returns, no more items will
           be delivered from the specified queue.

    One workable cleanup procedure is as follows: First, direct the
    WorkRoutines to silently discard completed items. Next, eliminate
    all sources of new work. Finally, destroy the work queue. Note that
    when in discard mode, the WorkRoutines may not access any structures
    which will be destroyed by eliminating the sources of new work.

--*/


DWORD
ClRtlPostItemWorkQueue(
    IN PCLRTL_WORK_QUEUE  WorkQueue,
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              BytesTransferred,  OPTIONAL
    IN ULONG_PTR          IoContext          OPTIONAL
    );
/*++

Routine Description:

    Posts a specified work item to a specified work queue.

Arguments:

    WorkQueue         - A pointer to the work queue to which to post the item.

    WorkItem          - A pointer to the item to post.

    BytesTransferred  - If the work item represents a completed I/O operation,
                        this parameter contains the number of bytes
                        transferred during the operation. For other work items,
                        the semantics of this parameter may be defined by
                        the caller.

    IoContext         - If the work item represents a completed I/O operation,
                        this parameter contains the context value associated
                        with the handle on which the operation was submitted.
                        Of other work items, the semantics of this parameter
                        may be defined by the caller.

Return Value:

    ERROR_SUCCESS if the item was posted successfully.
    A Win32 error code if the post operation fails.

--*/


DWORD
ClRtlAssociateIoHandleWorkQueue(
    IN PCLRTL_WORK_QUEUE  WorkQueue,
    IN HANDLE             IoHandle,
    IN ULONG_PTR          IoContext
    );
/*++

Routine Description:

    Associates a specified I/O handle, opened for overlapped I/O
    completion, with a work queue. All pending I/O operations on
    the specified handle will be posted to the work queue when
    completed. An initialized CLRTL_WORK_ITEM must be used to supply
    the OVERLAPPED structure whenever an I/O operation is submitted on
    the specified handle.

Arguments:

    WorkQueue     - The work queue with which to associate the I/O handle.

    IoHandle      - The I/O handle to associate.

    IoContext     - A context value to associate with the specified handle.
                    This value will be supplied as a parameter to the
                    WorkRoutine which processes completions for this
                    handle.

Return Value:

    ERROR_SUCCESS if the association completes successfully.
    A Win32 error code if the association fails.

--*/


//////////////////////////////////////////////////////////////////////////
//
// Utilities for accessing the NT system registry.
//
//////////////////////////////////////////////////////////////////////////
DWORD
ClRtlRegQueryDword(
    IN  HKEY    hKey,
    IN  LPWSTR  lpValueName,
    OUT LPDWORD lpValue,
    IN  LPDWORD lpDefaultValue OPTIONAL
    );

DWORD
ClRtlRegQueryString(
    IN     HKEY     Key,
    IN     LPWSTR   ValueName,
    IN     DWORD    ValueType,
    IN     LPWSTR  *StringBuffer,
    IN OUT LPDWORD  StringBufferSize,
    OUT    LPDWORD  StringSize
    );


//////////////////////////////////////////////////////////////////////////
//
// Routines for groveling and managing network configuration.
// Currently, these are specific to TCP/IP.
//
//////////////////////////////////////////////////////////////////////////

//
// Transport interface information structure
//
// The "Ignore" field is intitialized to FALSE. If it is set to
// TRUE by an application, the enum search functions will ignore
// the entry.
//
typedef struct _CLRTL_NET_INTERFACE_INFO {
    struct _CLRTL_NET_INTERFACE_INFO *  Next;
    ULONG                               Context;
    ULONG                               Flags;
    ULONG                               InterfaceAddress;
    LPWSTR                              InterfaceAddressString;
    ULONG                               NetworkAddress;
    LPWSTR                              NetworkAddressString;
    ULONG                               NetworkMask;
    LPWSTR                              NetworkMaskString;
    BOOLEAN                             Ignore;
} CLRTL_NET_INTERFACE_INFO, *PCLRTL_NET_INTERFACE_INFO;

#define CLRTL_NET_INTERFACE_PRIMARY   0x00000001
#define CLRTL_NET_INTERFACE_DYNAMIC   0x00000002

//
// Adapter information structure
//
// The "Ignore" field is intitialized to FALSE. If it is set to
// TRUE by an application, the enum search functions will ignore
// the entry.
//
typedef struct _CLRTL_NET_ADAPTER_INFO {
    struct _CLRTL_NET_ADAPTER_INFO *   Next;
    LPWSTR                             ConnectoidName;    // INetConnection::get_Name
    LPWSTR                             DeviceGuid;        // GUID for INetConnection
    BSTR                               DeviceName;        // INetConnection::get_DeviceName
    LPWSTR                             AdapterDomainName; // adapter specific domain
    ULONG                              Index;
    ULONG                              Flags;
    NETCON_STATUS                      NCStatus;          // INetConnection::GetProperties->Status
    ULONG                              InterfaceCount;
    PCLRTL_NET_INTERFACE_INFO          InterfaceList;
    BOOLEAN                            Ignore;
    DWORD                              DnsServerCount;
    PDWORD                             DnsServerList;
} CLRTL_NET_ADAPTER_INFO, *PCLRTL_NET_ADAPTER_INFO;

#define CLRTL_NET_ADAPTER_HIDDEN      0x00000001


typedef struct {
    ULONG                    AdapterCount;
    PCLRTL_NET_ADAPTER_INFO  AdapterList;
} CLRTL_NET_ADAPTER_ENUM, *PCLRTL_NET_ADAPTER_ENUM;


PCLRTL_NET_ADAPTER_ENUM
ClRtlEnumNetAdapters(
    VOID
    );

VOID
ClRtlFreeNetAdapterEnum(
    IN PCLRTL_NET_ADAPTER_ENUM  AdapterEnum
    );

PCLRTL_NET_ADAPTER_INFO
ClRtlFindNetAdapterById(
    PCLRTL_NET_ADAPTER_ENUM   AdapterEnum,
    LPWSTR                    AdapterId
    );

PCLRTL_NET_INTERFACE_INFO
ClRtlFindNetInterfaceByNetworkAddress(
    IN PCLRTL_NET_ADAPTER_INFO   AdapterInfo,
    IN LPWSTR                    NetworkAddress
    );

PCLRTL_NET_ADAPTER_INFO
ClRtlFindNetAdapterByNetworkAddress(
    IN  PCLRTL_NET_ADAPTER_ENUM      AdapterEnum,
    IN  LPWSTR                       NetworkAddress,
    OUT PCLRTL_NET_INTERFACE_INFO *  InterfaceInfo
    );

PCLRTL_NET_ADAPTER_INFO
ClRtlFindNetAdapterByInterfaceAddress(
    IN  PCLRTL_NET_ADAPTER_ENUM      AdapterEnum,
    IN  LPWSTR                       InterfaceAddressString,
    OUT PCLRTL_NET_INTERFACE_INFO *  InterfaceInfo
    );

PCLRTL_NET_INTERFACE_INFO
ClRtlGetPrimaryNetInterface(
    IN PCLRTL_NET_ADAPTER_INFO  AdapterInfo
    );

VOID
ClRtlQueryTcpipInformation(
    OUT  LPDWORD   MaxAddressStringLength,
    OUT  LPDWORD   MaxEndpointStringLength,
    OUT  LPDWORD   TdiAddressInfoLength
    );

DWORD
ClRtlTcpipAddressToString(
    ULONG     AddressValue,
    LPWSTR *  AddressString
    );

DWORD
ClRtlTcpipStringToAddress(
    LPCWSTR AddressString,
    PULONG  AddressValue
    );

DWORD
ClRtlTcpipEndpointToString(
    USHORT    EndpointValue,
    LPWSTR *  EndpointString
    );

DWORD
ClRtlTcpipStringToEndpoint(
    LPCWSTR  EndpointString,
    PUSHORT  EndpointValue
    );

BOOL
ClRtlIsValidTcpipAddress(
    IN ULONG   Address
    );

BOOL
ClRtlIsDuplicateTcpipAddress(
    IN ULONG   Address
    );

BOOL
ClRtlIsValidTcpipSubnetMask(
    IN ULONG   SubnetMask
    );

BOOL
ClRtlIsValidTcpipAddressAndSubnetMask(
    IN ULONG   Address,
    IN ULONG   SubnetMask
    );

__inline
BOOL
ClRtlAreTcpipAddressesOnSameSubnet(
    ULONG Address1,
    ULONG Address2,
    ULONG SubnetMask
    )
{
    BOOL fReturn;

    if ( ( Address1 & SubnetMask ) == ( Address2 & SubnetMask ) )
    {
        fReturn = TRUE;
    }
    else
    {
        fReturn = FALSE;
    }

    return fReturn;
}

//#define ClRtlAreTcpipAddressesOnSameSubnet(_Addr1, _Addr2, _Mask) \
//            ( ((_Addr1 & _Mask) == (_Addr2 & _Mask)) ? TRUE : FALSE )


DWORD
ClRtlBuildTcpipTdiAddress(
    IN  LPWSTR    NetworkAddress,
    IN  LPWSTR    TransportEndpoint,
    OUT LPVOID *  TdiAddress,
    OUT LPDWORD   TdiAddressLength
    );

DWORD
ClRtlBuildLocalTcpipTdiAddress(
    IN  LPWSTR    NetworkAddress,
    OUT LPVOID    TdiAddress,
    OUT LPDWORD   TdiAddressLength
    );

DWORD
ClRtlParseTcpipTdiAddress(
    IN  LPVOID    TdiAddress,
    OUT LPWSTR *  NetworkAddress,
    OUT LPWSTR *  TransportEndpoint
    );

DWORD
ClRtlParseTcpipTdiAddressInfo(
    IN  LPVOID    TdiAddressInfo,
    OUT LPWSTR *  NetworkAddress,
    OUT LPWSTR *  TransportEndpoint
    );

//
// Validate network name
//
typedef enum CLRTL_NAME_STATUS {
    NetNameOk,
    NetNameEmpty,
    NetNameTooLong,
    NetNameInvalidChars,
    NetNameInUse,
    NetNameSystemError,
    NetNameDNSNonRFCChars
} CLRTL_NAME_STATUS;

BOOL
ClRtlIsNetNameValid(
    IN LPCWSTR NetName,
    OUT OPTIONAL CLRTL_NAME_STATUS *Result,
    IN BOOL CheckIfExists
    );


//
// Security related routines
//
LONG
MapSAToRpcSA(
    IN LPSECURITY_ATTRIBUTES lpSA,
    IN OUT struct _RPC_SECURITY_ATTRIBUTES *pRpcSA
    );

LONG
MapSDToRpcSD(
    IN PSECURITY_DESCRIPTOR lpSD,
    IN OUT struct _RPC_SECURITY_DESCRIPTOR *pRpcSD
    );

DWORD
ClRtlSetObjSecurityInfo(
    IN HANDLE           hObject,
    IN SE_OBJECT_TYPE   SeObjType,
    IN DWORD            dwAdminMask,
    IN DWORD            dwOwnerMask,
    IN DWORD            dwEveryOneMask
    );

DWORD
ClRtlFreeClusterServiceSecurityDescriptor( void );

DWORD
ClRtlBuildClusterServiceSecurityDescriptor(
    PSECURITY_DESCRIPTOR * poutSD
    );

DWORD
ClRtlEnableThreadPrivilege(
    IN  ULONG        Privilege,
    OUT BOOLEAN      *pWasEnabled
    );

DWORD
ClRtlRestoreThreadPrivilege(
    IN ULONG        Privilege,
    IN BOOLEAN      WasEnabled
    );

PSECURITY_DESCRIPTOR
ClRtlCopySecurityDescriptor(
    IN PSECURITY_DESCRIPTOR psd
    );

PSECURITY_DESCRIPTOR
ClRtlConvertClusterSDToNT4Format(
    IN PSECURITY_DESCRIPTOR psd
    );

PSECURITY_DESCRIPTOR
ClRtlConvertClusterSDToNT5Format(
    IN PSECURITY_DESCRIPTOR psd
    );

PSECURITY_DESCRIPTOR
ClRtlConvertFileShareSDToNT4Format(
    IN PSECURITY_DESCRIPTOR psd
    );

BOOL
ClRtlExamineSD(
    PSECURITY_DESCRIPTOR    psdSD,
    LPSTR                   pszPrefix
    );

VOID
ClRtlExamineMask(
    ACCESS_MASK amMask,
    LPSTR       lpszOldIndent
    );

DWORD
ClRtlBuildDefaultClusterSD(
    IN PSID                     pOwnerSid,
    OUT PSECURITY_DESCRIPTOR *  SD,
    OUT ULONG *                 SizeSD
    );

BOOL
ClRtlExamineClientToken(
    HANDLE  hClientToken,
    LPSTR   pszPrefix
    );

DWORD
ClRtlIsCallerAccountLocalSystemAccount(
    OUT PBOOL pbIsLocalSystemAccount
    );

//
// OS checker
//
DWORD
GetServicePack(
    VOID
    );

BOOL
ClRtlIsOSValid(
    VOID
    );

DWORD
ClRtlGetSuiteType(
    VOID
    );

BOOL
ClRtlIsOSTypeValid(
    VOID
    );

//
// A few MULTI_SZ string manipulation routines
//
DWORD
ClRtlMultiSzAppend(
    IN OUT LPWSTR *MultiSz,
    IN OUT LPDWORD StringLength,
    IN LPCWSTR lpString
    );

DWORD
ClRtlMultiSzRemove(
    IN LPWSTR lpszMultiSz,
    IN OUT LPDWORD StringLength,
    IN LPCWSTR lpString
    );

LPCWSTR
ClRtlMultiSzEnum(
    IN LPCWSTR MszString,
    IN DWORD   MszStringLength,
    IN DWORD   StringIndex
    );

DWORD
ClRtlMultiSzLength(
    IN LPCWSTR lpszMultiSz
    );

LPCWSTR
ClRtlMultiSzScan(
    IN LPCWSTR lpszMultiSz,
    IN LPCWSTR lpszString
    );

DWORD
ClRtlCreateDirectory(
    IN LPCWSTR lpszPath
    );

BOOL
WINAPI
ClRtlIsPathValid(
    IN LPCWSTR lpszPath
    );

DWORD
ClRtlGetClusterDirectory(
    IN LPWSTR   lpBuffer,
    IN DWORD    dwBufSize
    );

typedef LONG (*PFNCLRTLCREATEKEY)(
    IN PVOID ClusterKey,
    IN LPCWSTR lpszSubKey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PVOID * phkResult,
    OUT OPTIONAL LPDWORD lpdwDisposition
    );

typedef LONG (*PFNCLRTLOPENKEY)(
    IN PVOID ClusterKey,
    IN LPCWSTR lpszSubKey,
    IN REGSAM samDesired,
    OUT PVOID * phkResult
    );

typedef LONG (*PFNCLRTLCLOSEKEY)(
    IN PVOID ClusterKey
    );

typedef LONG (*PFNCLRTLENUMVALUE)(
    IN PVOID ClusterKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpszValueName,
    IN OUT LPDWORD lpcbValueName,
    OUT LPDWORD lpType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );

typedef LONG (*PFNCLRTLSETVALUE)(
    IN PVOID ClusterKey,
    IN LPCWSTR lpszValueName,
    IN DWORD dwType,
    IN CONST BYTE* lpData,
    IN DWORD cbData
    );

typedef LONG (*PFNCLRTLQUERYVALUE)(
    IN PVOID ClusterKey,
    IN LPCWSTR lpszValueName,
    OUT LPDWORD lpValueType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );



typedef DWORD (*PFNCLRTLDELETEVALUE)(
    IN PVOID ClusterKey,
    IN LPCWSTR lpszValueName
    );

typedef LONG (*PFNCLRTLLOCALCREATEKEY)(
    IN HANDLE hXsaction,
    IN PVOID ClusterKey,
    IN LPCWSTR lpszSubKey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PVOID * phkResult,
    OUT OPTIONAL LPDWORD lpdwDisposition
    );

typedef LONG (*PFNCLRTLLOCALSETVALUE)(
    IN HANDLE hXsaction,
    IN PVOID ClusterKey,
    IN LPCWSTR lpszValueName,
    IN DWORD dwType,
    IN CONST BYTE* lpData,
    IN DWORD cbData
    );

typedef LONG (*PFNCLRTLLOCALDELETEVALUE)(
    IN HANDLE hXsaction,
    IN PVOID ClusterKey,
    IN LPCWSTR lpszValueName
    );

typedef struct _CLUSTER_REG_APIS {
    PFNCLRTLCREATEKEY   pfnCreateKey;
    PFNCLRTLOPENKEY     pfnOpenKey;
    PFNCLRTLCLOSEKEY    pfnCloseKey;
    PFNCLRTLSETVALUE    pfnSetValue;
    PFNCLRTLQUERYVALUE  pfnQueryValue;
    PFNCLRTLENUMVALUE   pfnEnumValue;
    PFNCLRTLDELETEVALUE pfnDeleteValue;
    PFNCLRTLLOCALCREATEKEY      pfnLocalCreateKey;
    PFNCLRTLLOCALSETVALUE       pfnLocalSetValue;
    PFNCLRTLLOCALDELETEVALUE    pfnLocalDeleteValue;
} CLUSTER_REG_APIS, *PCLUSTER_REG_APIS;

DWORD
WINAPI
ClRtlEnumProperties(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT LPWSTR pszOutProperties,
    IN DWORD cbOutPropertiesSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ClRtlEnumPrivateProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    OUT LPWSTR pszOutProperties,
    IN DWORD cbOutPropertiesSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ClRtlGetProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ClRtlGetPrivateProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ClRtlGetPropertySize(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pnPropertyCount
    );

DWORD
WINAPI
ClRtlGetProperty(
    IN PVOID ClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    OUT PVOID * pOutPropertyItem,
    IN OUT LPDWORD pcbOutPropertyItemSize
    );

DWORD
WINAPI
ClRtlpSetPropertyTable(
    IN HANDLE hXsaction,
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL LPBYTE pOutParams
    );

DWORD
WINAPI
ClRtlpSetNonPropertyTable(
    IN HANDLE hXsaction,
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    );

DWORD
WINAPI
ClRtlSetPropertyParameterBlock(
    IN HANDLE hXsaction,
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE pInParams,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL LPBYTE pOutParams
    );

DWORD
WINAPI
ClRtlGetAllProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ClRtlGetPropertiesToParameterBlock(
    IN HKEY hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN OUT LPBYTE pOutParams,
    IN BOOL bCheckForRequiredProperties,
    OUT OPTIONAL LPWSTR * ppszNameOfPropInError
    );

DWORD
WINAPI
ClRtlPropertyListFromParameterBlock(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID  pOutPropertyList,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN const LPBYTE pInParams,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ClRtlGetUnknownProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ClRtlAddUnknownProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM ppPropertyTable,
    IN OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    IN OUT LPDWORD pcbBytesReturned,
    IN OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ClRtlpFindSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue,
    IN BOOL bReturnExpandedValue
    );

__inline
DWORD
WINAPI
ClRtlFindSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue
    )
{
    return ClRtlpFindSzProperty(
        pPropertyList,
        cbPropertyListSize,
        pszPropertyName,
        pszPropertyValue,
        FALSE /* bReturnExpandedValue */
        );

} //*** ClRtlFindSzProperty()

__inline
DWORD
WINAPI
ClRtlFindExpandSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue
    )
{
    return ClRtlpFindSzProperty(
        pPropertyList,
        cbPropertyListSize,
        pszPropertyName,
        pszPropertyValue,
        FALSE /* bReturnExpandedValue */
        );

} //*** ClRtlFindExpandSzProperty()

__inline
DWORD
WINAPI
ClRtlFindExpandedSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue
    )
{
    return ClRtlpFindSzProperty(
        pPropertyList,
        cbPropertyListSize,
        pszPropertyName,
        pszPropertyValue,
        TRUE /* bReturnExpandedValue */
        );

} //*** ClRtlFindExpandedSzProperty()

DWORD
WINAPI
ClRtlFindDwordProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPDWORD pdwPropertyValue
    );

DWORD
WINAPI
ClRtlFindLongProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPLONG plPropertyValue
    );

DWORD
WINAPI
ClRtlFindBinaryProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPBYTE * pbPropertyValue,
    OUT LPDWORD pcbPropertyValueSize
    );

DWORD
WINAPI
ClRtlFindMultiSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue,
    OUT LPDWORD pcbPropertyValueSize
    );

__inline
DWORD
WINAPI
ClRtlVerifyPropertyTable(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    OUT OPTIONAL LPBYTE pOutParams
    )
{
    return ClRtlpSetPropertyTable(
        NULL,
        NULL,
        NULL,
        pPropertyTable,
        Reserved,
        bAllowUnknownProperties,
        pInPropertyList,
        cbInPropertyListSize,
        FALSE, // bForceWrite
        pOutParams);
}

__inline
DWORD
WINAPI
ClRtlSetPropertyTable(
    IN HANDLE hXsaction,
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL LPBYTE pOutParams
    )
{
    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis == NULL) ){
        return(ERROR_BAD_ARGUMENTS);
    }
    return ClRtlpSetPropertyTable(
        hXsaction,
        hkeyClusterKey,
        pClusterRegApis,
        pPropertyTable,
        Reserved,
        bAllowUnknownProperties,
        pInPropertyList,
        cbInPropertyListSize,
        bForceWrite,
        pOutParams);
}

DWORD
WINAPI
ClRtlpSetPrivatePropertyList(
    IN HANDLE hXsaction,
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    );

__inline
DWORD
WINAPI
ClRtlVerifyPrivatePropertyList(
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    )
{
    return ClRtlpSetPrivatePropertyList( NULL, NULL, NULL, pInPropertyList, cbInPropertyListSize );
}

__inline
DWORD
WINAPI
ClRtlSetPrivatePropertyList(
    IN HANDLE hXsaction,
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    )
{
    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis == NULL) ){
        return(ERROR_BAD_ARGUMENTS);
    }
    return ClRtlpSetPrivatePropertyList(
        hXsaction,
        hkeyClusterKey,
        pClusterRegApis,
        pInPropertyList,
        cbInPropertyListSize
        );
}

DWORD
WINAPI
ClRtlGetBinaryValue(
    IN HKEY ClusterKey,
    IN LPCWSTR ValueName,
    OUT LPBYTE * OutValue,
    OUT LPDWORD OutValueSize,
    IN const PCLUSTER_REG_APIS pClusterRegApis
    );

LPWSTR
WINAPI
ClRtlGetSzValue(
    IN HKEY ClusterKey,
    IN LPCWSTR ValueName,
    IN const PCLUSTER_REG_APIS pClusterRegApis
    );

DWORD
WINAPI
ClRtlDupParameterBlock(
    OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    );

void
WINAPI
ClRtlFreeParameterBlock(
    IN OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    );

DWORD
WINAPI
ClRtlMarshallPropertyTable(
    IN PRESUTIL_PROPERTY_ITEM    pPropertyTable,
    IN OUT  DWORD                dwSize,
    IN OUT  LPBYTE               pBuffer,
    OUT     DWORD                *Required
    );

DWORD
WINAPI
ClRtlUnmarshallPropertyTable(
    IN OUT PRESUTIL_PROPERTY_ITEM   *ppPropertyTable,
    IN LPBYTE                       pBuffer
    );

LPWSTR
WINAPI
ClRtlExpandEnvironmentStrings(
    IN LPCWSTR pszSrc
    );


DWORD
WINAPI
ClRtlGetPropertyFormats(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pOutPropertyFormatList,
    IN DWORD cbOutPropertyFormatListSize,
    OUT LPDWORD pcbReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ClRtlGetPropertyFormat(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    OUT PVOID * pOutPropertyItem,
    IN OUT LPDWORD pcbOutPropertyItemSize
    );

DWORD
WINAPI
ClRtlGetPropertyFormatSize(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pnPropertyCount
    );

//
// Miscellaneous Routines
//
LPWSTR
ClRtlMakeGuid(
    VOID
    );

LPWSTR
ClRtlGetConnectoidName(
    INetConnection * NetConnection
    );

INetConnection *
ClRtlFindConnectoidByGuid(
    LPWSTR ConnectoidGuid
    );

INetConnection *
ClRtlFindConnectoidByName(
    LPCWSTR ConnectoidName
    );

DWORD
ClRtlSetConnectoidName(
    INetConnection *  NetConnection,
    LPWSTR            NewConnectoidName
    );


DWORD
ClRtlFindConnectoidByGuidAndSetName(
    LPWSTR ConnectoidGuid,
    LPWSTR NewConnectoidName
    );

DWORD
ClRtlFindConnectoidByNameAndSetName(
    LPWSTR ConnectoidName,
    LPWSTR NewConnectoidName
    );

///////////////////////////////////////////////////////////////////////////
//
//	General purpose Watchdog timer.
//
///////////////////////////////////////////////////////////////////////////


PVOID
ClRtlSetWatchdogTimer(
	DWORD timeout, 
	LPWSTR par
	);

VOID
ClRtlCancelWatchdogTimer(
	PVOID wTimer
	);

/* commented out 16 Nov 1998 by GalenB because the DS work has been postponed
//
// Active Directory Services (DS) Publication Routines
//
HRESULT
HrClRtlAddClusterNameToDS(
    const TCHAR *pClusterName,
    const HCLUSTER hCluster
);

HRESULT
HrClRtlMoveClusterNodeDS(
    const TCHAR *pClusterName,
    const HCLUSTER hCluster,
    const TCHAR *pNodeName
);
end of commented out code */

// Apis and defines for cluster installation state
// This enum is used to indicate the state of the Cluster Server installation.
// The registry key that indicates the state of the Cluster Server installation
// will be a DWORD representation of one of the following values.

typedef enum
{
   eClusterInstallStateUnknown,
   eClusterInstallStateFilesCopied,
   eClusterInstallStateConfigured,
   eClusterInstallStateUpgraded
} eClusterInstallState;

DWORD
ClRtlGetClusterInstallState(
    IN LPCWSTR pszNodeName,
    OUT eClusterInstallState * peState
    );

BOOL
ClRtlSetClusterInstallState(
    IN eClusterInstallState InstallState
    );

//
// Registry utilities routines
//
BOOL RegDelnode( HKEY hKeyRoot, const LPTSTR lpSubKey );

//
// Routine to get drive layout table
//
BOOL
ClRtlGetDriveLayoutTable(
    IN  HANDLE hDisk,
    OUT PDRIVE_LAYOUT_INFORMATION * DriveLayout,
    OUT PDWORD InfoSize OPTIONAL
    );

DWORD ClRtlGetDefaultNodeLimit( 
    IN DWORD SuiteType);

//
// If async event reporting is required,
// use the following function to set
// a work queue
//
VOID
ClRtlEventLogSetWorkQueue(
    PCLRTL_WORK_QUEUE WorkQueue
    );
    


//
// Fast check to see if a file or directory exists.
//
BOOL
ClRtlPathFileExists(
    LPWSTR pwszPath
    );

//
// set default failure actions in service controller 
//
DWORD
ClRtlSetSCMFailureActions(
    LPWSTR NodeName OPTIONAL
    );

//
// Initialize Wmi tracing (noop if wmi is disabled)
//
DWORD
ClRtlInitWmi(
    LPCWSTR ComponentName
    );    

//
// Get the cluster service domain account info
//
DWORD
ClRtlGetServiceAccountInfo(
    LPWSTR *    AccountBuffer
    );

//
// set the DACL for Winsta0 and its desktop such that any genapp process can
// access it
//
DWORD
ClRtlAddClusterServiceAccountToWinsta0DACL(
    VOID
    );

//
// Cleanup a node that has been evicted (requires cleanup COM component to be registered locally).
//
HRESULT ClRtlCleanupNode(
    const WCHAR * pcszEvictedNodeNameIn,
    DWORD dwDelayIn,
    DWORD dwTimeoutIn
    );

//
// Asynchronously cleanup a node that has been evicted.
//
HRESULT ClRtlAsyncCleanupNode(
      const WCHAR * pcszEvictedNodeNameIn
    , DWORD dwDelayIn
    , DWORD dwTimeoutIn
    );

//
// Find out if a registry value indicating that this node has been evicted, is set or not
//
DWORD
ClRtlHasNodeBeenEvicted(
    BOOL * pfNodeEvictedOut
    );

//
// Initiate operations that inform interested parties that the cluster
// service is starting up
//
HRESULT
ClRtlInitiateStartupNotification(
    void
    );

//
// get the domain account in the form of 'user\domain'
//
DWORD
ClRtlGetRunningAccountInfo(
    LPWSTR *    AccountBuffer
    );

//
// Checks if cluster version checking has been disabled on a particular computer.
//
DWORD 
ClRtlIsVersionCheckingDisabled(
      const WCHAR * pcszNodeNameIn
    , BOOL *        pfVerCheckDisabledOut
    );

#ifdef __cplusplus
}
#endif

#endif // ifndef _CLUSRTL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\inc\clusudef.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    clusudef.h

Abstract:

    This module contains definitions of constants used across
    multiple user-mode targets in the cluster project.

Revision History:


Environment:

    User-mode only.

--*/

#ifndef _CLUSUDEF_H_
#define _CLUSUDEF_H_

//default cluster settings
#define CLUSTER_SHUTDOWN_TIMEOUT    60      // default shutdown timeout in minutes

//
// Default group property definitions
//
#define CLUSTER_GROUP_DEFAULT_FAILOVER_THRESHOLD    10
#define CLUSTER_GROUP_DEFAULT_FAILOVER_PERIOD       6
#define CLUSTER_GROUP_DEFAULT_AUTO_FAILBACK_TYPE    ClusterGroupPreventFailback
#define CLUSTER_GROUP_FAILBACK_WINDOW_NONE          ((DWORD) -1)
#define CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_START CLUSTER_GROUP_FAILBACK_WINDOW_NONE
#define CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_END   CLUSTER_GROUP_FAILBACK_WINDOW_NONE
#define CLUSTER_GROUP_DEFAULT_LOADBAL_STATE         1

//
// Minimum group property definitions
//
#define CLUSTER_GROUP_MINIMUM_FAILOVER_THRESHOLD    0
#define CLUSTER_GROUP_MINIMUM_FAILOVER_PERIOD       0
#define CLUSTER_GROUP_MINIMUM_FAILBACK_WINDOW_START CLUSTER_GROUP_FAILBACK_WINDOW_NONE
#define CLUSTER_GROUP_MINIMUM_FAILBACK_WINDOW_END   CLUSTER_GROUP_FAILBACK_WINDOW_NONE

//
// Maximum group property definitions
//
#define CLUSTER_GROUP_MAXIMUM_FAILOVER_THRESHOLD    ((DWORD) -1)
#define CLUSTER_GROUP_MAXIMUM_FAILOVER_PERIOD       1193
#define CLUSTER_GROUP_MAXIMUM_AUTO_FAILBACK_TYPE    (ClusterGroupFailbackTypeCount - 1)
#define CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_START 23
#define CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_END   23

//
// Default resource property definitions
//
#define CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL  ((DWORD) -1)
#define CLUSTER_RESOURCE_DEFAULT_LOOKS_ALIVE        CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL
#define CLUSTER_RESOURCE_DEFAULT_IS_ALIVE           CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL
#define CLUSTER_RESOURCE_DEFAULT_RESTART_ACTION     ClusterResourceRestartNotify
#define CLUSTER_RESOURCE_DEFAULT_RESTART_THRESHOLD  3
#define CLUSTER_RESOURCE_DEFAULT_RESTART_PERIOD     (900 * 1000)
#define CLUSTER_RESOURCE_DEFAULT_RETRY_PERIOD_ON_FAILURE  ((DWORD)-1)
#define CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT    (3 * 60 * 1000)
#define CLUSTER_RESOURCE_DEFAULT_LOADBAL_STARTUP    (5 * 60 * 1000)
#define CLUSTER_RESOURCE_DEFAULT_LOADBAL_SAMPLE     (    10 * 1000)
#define CLUSTER_RESOURCE_DEFAULT_LOADBAL_ANALYSIS   (5 * 60 * 1000)
#define CLUSTER_RESOURCE_DEFAULT_PERSISTENT_STATE   ((DWORD) -1)

//
// Minimum resource property definitions
//
#define CLUSTER_RESOURCE_MINIMUM_LOOKS_ALIVE        10
#define CLUSTER_RESOURCE_MINIMUM_IS_ALIVE           10
#define CLUSTER_RESOURCE_MINIMUM_RESTART_THRESHOLD  0
#define CLUSTER_RESOURCE_MINIMUM_RESTART_PERIOD     0
#define CLUSTER_RESOURCE_MINIMUM_PENDING_TIMEOUT    10
#define CLUSTER_RESOURCE_MINIMUM_PERSISTENT_STATE   ((DWORD) -1)

//
// Maximum resource property definitions
//
#define CLUSTER_RESOURCE_MAXIMUM_LOOKS_ALIVE        ((DWORD) -1)
#define CLUSTER_RESOURCE_MAXIMUM_LOOKS_ALIVE_UI     ((DWORD) -2)
#define CLUSTER_RESOURCE_MAXIMUM_IS_ALIVE           ((DWORD) -1)
#define CLUSTER_RESOURCE_MAXIMUM_IS_ALIVE_UI        ((DWORD) -2)
#define CLUSTER_RESOURCE_MAXIMUM_RESTART_ACTION     (ClusterResourceRestartActionCount - 1)
#define CLUSTER_RESOURCE_MAXIMUM_RESTART_THRESHOLD  ((DWORD) -1)
#define CLUSTER_RESOURCE_MAXIMUM_RESTART_PERIOD     ((DWORD) -1)
#define CLUSTER_RESOURCE_MAXIMUM_PENDING_TIMEOUT    ((DWORD) -1)
#define CLUSTER_RESOURCE_MAXIMUM_PERSISTENT_STATE   1

//
// Default resource type property definitions
//
#define CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE     (5 * 1000)
#define CLUSTER_RESTYPE_DEFAULT_IS_ALIVE        (60 * 1000)
#define CLUSTER_RESTYPE_DEFAULT_QUORUM_CAPABLE  FALSE

//
// Minimum resource type property definitions
//
#define CLUSTER_RESTYPE_MINIMUM_LOOKS_ALIVE     10
#define CLUSTER_RESTYPE_MINIMUM_IS_ALIVE        10

//
// Maximum resource type property definitions
//
#define CLUSTER_RESTYPE_MAXIMUM_LOOKS_ALIVE     ((DWORD) -1)
#define CLUSTER_RESTYPE_MAXIMUM_IS_ALIVE        ((DWORD) -1)

//
// Default quorum definitions
//
#define CLUSTER_QUORUM_DEFAULT_MAX_LOG_SIZE     4 * 1024 * 1024  // 4096 K(4 Meg) PSS:Reqquest a higher sizes
#define CLUSTER_QUORUM_MIN_LOG_SIZE             32 * 1024 //32 K

#define CLUSREG_NAME_SVC_PARAM_NOVER_CHECK  L"NoVersionCheck"
#define CLUSREG_NAME_SVC_PARAM_NOREP_EVTLOGGING  L"NoRepEvtLogging"
#define CLUSREG_NAME_SVC_PARAM_RESTORE_DB  L"RestoreDatabase"
#define CLUSREG_NAME_SVC_PARAM_FORCE_RESTORE_DB  L"ForceRestoreDatabase"
#define CLUSREG_NAME_SVC_PARAM_QUORUM_DRIVE_LETTER  L"NewQuorumDriveLetter"
#define CLUSREG_NAME_SVC_PARAM_FORCE_QUORUM  L"ForceQuorum"
#define CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST L"ResourceDllUpgradeInProgressList"

//
// Key, value, and property names
//
#define CLUSREG_KEYNAME_CLUSTER             L"Cluster"
#define CLUSREG_KEYNAME_GROUPS              L"Groups"
#define CLUSREG_KEYNAME_NETWORKS            L"Networks"
#define CLUSREG_KEYNAME_NETINTERFACES       L"NetworkInterfaces"
#define CLUSREG_KEYNAME_NODES               L"Nodes"
#define CLUSREG_KEYNAME_QUORUM              L"Quorum"
#define CLUSREG_KEYNAME_RESOURCES           L"Resources"
#define CLUSREG_KEYNAME_RESOURCE_TYPES      L"ResourceTypes"
#define CLUSREG_KEYNAME_PARAMETERS          L"Parameters"
#define CLUSREG_KEYNAME_CLUSSVC_PARAMETERS  L"SYSTEM\\CurrentControlSet\\Services\\ClusSvc\\Parameters"
#define CLUSREG_KEYNAME_CLUSSVC             L"SYSTEM\\CurrentControlSet\\Services\\ClusSvc"
#define CLUSREG_KEYNAME_IMAGE_PATH          L"ImagePath"
#define CLUSREG_KEYNAME_WELCOME_UI          L"WelcomeUI"
#define CLUSREG_KEYNAME_RUNONCE             L"Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce"
#define CLUSREG_KEYNAME_NODE_DATA           L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Cluster Server"
#define CLUSREG_KEYNAME_PREV_OS_INFO        L"PreviousOSVersionInfo"

#define CLUSREG_NAME_EVICTION_STATE         L"NodeHasBeenEvicted"
#define CLUSREG_INSTALL_DIR_VALUE_NAME      L"ClusterInstallationDirectory"

#define CLUSREG_NAME_CHARACTERISTICS        L"Characteristics"
#define CLUSREG_NAME_FLAGS                  L"Flags"
#define CLUSREG_NAME_ADMIN_EXT              L"AdminExtensions"
#define CLUSREG_NAME_SECURITY_DLL_NAME      L"SecurityDLL"
#define CLUSREG_NAME_SECURITY_PACKAGE_LIST  L"SecurityPackageList"

#define CLUSREG_NAME_CLUS_NAME              L"ClusterName"
#define CLUSREG_NAME_CLUS_DESC              L"Description"
    // used for NT4 SDs
#define CLUSREG_NAME_CLUS_SECURITY          L"Security"
    // used for NT5 and higher SDs
#define CLUSREG_NAME_CLUS_SD                    L"Security Descriptor"
#define CLUSREG_NAME_CLUS_CLUSTER_NAME_RES      L"ClusterNameResource"
#define CLUSREG_NAME_CLUS_REG_SEQUENCE          L"RegistrySequence"
#define CLUSREG_NAME_CLUS_SHUTDOWN_TIMEOUT      L"ShutdownTimeout"
#define CLUSREG_NAME_CLUS_DEFAULT_NETWORK_ROLE  L"DefaultNetworkRole"
#define CLUSREG_NAME_CLUS_EVTLOG_PROPAGATION    L"EnableEventLogReplication"
#define CLUSREG_NAME_MAX_NODES              L"MaxNodesInCluster"

#define CLUSREG_NAME_NODE_NAME              L"NodeName"
#define CLUSREG_NAME_NODE_HIGHEST_VERSION   L"NodeHighestVersion"
#define CLUSREG_NAME_NODE_LOWEST_VERSION    L"NodeLowestVersion"
#define CLUSREG_NAME_NODE_DESC              L"Description"
#define CLUSREG_NAME_NODE_PAUSED            L"Paused"
#define CLUSREG_NAME_NODE_MAJOR_VERSION     L"MajorVersion"
#define CLUSREG_NAME_NODE_MINOR_VERSION     L"MinorVersion"
#define CLUSREG_NAME_NODE_BUILD_NUMBER      L"BuildNumber"
#define CLUSREG_NAME_NODE_CSDVERSION        L"CSDVersion"
#define CLUSREG_NAME_NODE_EVTLOG_PROPAGATION L"EnableEventLogReplication"
#define CLUSREG_NAME_QUORUM_ARBITRATION_TIMEOUT   L"QuorumArbitrationTimeMax"
#define CLUSREG_NAME_QUORUM_ARBITRATION_EQUALIZER L"QuorumArbitrationTimeMin"
#define CLUSREG_NAME_NODE_PRODUCT_SUITE     L"ProductSuite"
#define CLUSREG_NAME_DISABLE_GROUP_PREFERRED_OWNER_RANDOMIZATION    L"DisableGroupPreferredOwnerRandomization"

#define CLUSREG_NAME_GRP_NAME               L"Name"
#define CLUSREG_NAME_GRP_DESC               L"Description"
#define CLUSREG_NAME_GRP_PERSISTENT_STATE   L"PersistentState"
#define CLUSREG_NAME_GRP_FAILBACK_TYPE      L"AutoFailbackType"
#define CLUSREG_NAME_GRP_FAILBACK_WIN_START L"FailbackWindowStart"
#define CLUSREG_NAME_GRP_FAILBACK_WIN_END   L"FailbackWindowEnd"
#define CLUSREG_NAME_GRP_FAILOVER_THRESHOLD L"FailoverThreshold"
#define CLUSREG_NAME_GRP_FAILOVER_PERIOD    L"FailoverPeriod"
#define CLUSREG_NAME_GRP_PREFERRED_OWNERS   L"PreferredOwners"
#define CLUSREG_NAME_GRP_CONTAINS           L"Contains"
#define CLUSREG_NAME_GRP_LOADBAL_STATE      L"LoadBalState"
#define CLUSREG_NAME_GRP_ANTI_AFFINITY_CLASS_NAME L"AntiAffinityClassNames"

#define CLUSREG_NAME_RES_NAME               L"Name"
#define CLUSREG_NAME_RES_TYPE               L"Type"
#define CLUSREG_NAME_RES_DESC               L"Description"
#define CLUSREG_NAME_RES_DEBUG_PREFIX       L"DebugPrefix"
#define CLUSREG_NAME_RES_SEPARATE_MONITOR   L"SeparateMonitor"
#define CLUSREG_NAME_RES_PERSISTENT_STATE   L"PersistentState"
#define CLUSREG_NAME_RES_LOOKS_ALIVE        L"LooksAlivePollInterval"
#define CLUSREG_NAME_RES_IS_ALIVE           L"IsAlivePollInterval"
#define CLUSREG_NAME_RES_RESTART_ACTION     L"RestartAction"
#define CLUSREG_NAME_RES_RESTART_THRESHOLD  L"RestartThreshold"
#define CLUSREG_NAME_RES_RESTART_PERIOD     L"RestartPeriod"
#define CLUSREG_NAME_RES_RETRY_PERIOD_ON_FAILURE L"RetryPeriodOnFailure"
#define CLUSREG_NAME_RES_PENDING_TIMEOUT    L"PendingTimeout"
#define CLUSREG_NAME_RES_POSSIBLE_OWNERS    L"PossibleOwners"
#define CLUSREG_NAME_RES_DEPENDS_ON         L"DependsOn"
#define CLUSREG_NAME_RES_LOADBAL_STARTUP    L"LoadBalStartupInterval"
#define CLUSREG_NAME_RES_LOADBAL_SAMPLE     L"LoadBalSampleInterval"
#define CLUSREG_NAME_RES_LOADBAL_ANALYSIS   L"LoadBalAnalysisInterval"
#define CLUSREG_NAME_RES_LOADBAL_PROCESSOR  L"LoadBalMinProcessorUnits"
#define CLUSREG_NAME_RES_LOADBAL_MEMORY     L"LoadBalMinMemoryUnits"
#define CLUSREG_NAME_RES_USER_MODIFIED_POSSIBLE_LIST L"UserModifiedPossibleNodeList"

#define CLUSREG_NAME_RESTYPE_NAME           L"Name"
#define CLUSREG_NAME_RESTYPE_DESC           L"Description"
#define CLUSREG_NAME_RESTYPE_LOOKS_ALIVE    L"LooksAlivePollInterval"
#define CLUSREG_NAME_RESTYPE_IS_ALIVE       L"IsAlivePollInterval"
#define CLUSREG_NAME_RESTYPE_DLL_NAME       L"DllName"
#define CLUSREG_NAME_RESTYPE_DEBUG_PREFIX   L"DebugPrefix"
#define CLUSREG_NAME_RESTYPE_DEBUG_CTRLFUNC L"DebugControlFunctions"
#define CLUSREG_NAME_RESTYPE_POSSIBLE_NODES L"PossibleNodes"
#define CLUSREG_NAME_RESTYPE_ADMIN_EXTENSIONS L"AdminExtensions"

#define CLUSREG_NAME_NET_NAME               L"Name"
#define CLUSREG_NAME_NET_DESC               L"Description"
#define CLUSREG_NAME_NET_ROLE               L"Role"
#define CLUSREG_NAME_NET_PRIORITY           L"Priority"
#define CLUSREG_NAME_NET_TRANSPORT          L"Transport"
#define CLUSREG_NAME_NET_ADDRESS            L"Address"
#define CLUSREG_NAME_NET_ADDRESS_MASK       L"AddressMask"

#define CLUSREG_NAME_NETIFACE_NAME          L"Name"
#define CLUSREG_NAME_NETIFACE_DESC          L"Description"
#define CLUSREG_NAME_NETIFACE_NODE          L"Node"
#define CLUSREG_NAME_NETIFACE_NETWORK       L"Network"
#define CLUSREG_NAME_NETIFACE_ADAPTER_NAME  L"Adapter"
#define CLUSREG_NAME_NETIFACE_ADAPTER_ID    L"AdapterId"
#define CLUSREG_NAME_NETIFACE_ADDRESS       L"Address"
#define CLUSREG_NAME_NETIFACE_ENDPOINT      L"ClusnetEndpoint"
#define CLUSREG_NAME_NETIFACE_STATE         L"State"

#define CLUSREG_NAME_QUORUM_RESOURCE        L"Resource"
#define CLUSREG_NAME_QUORUM_PATH            L"Path"
#define CLUSREG_NAME_QUORUM_MAX_LOG_SIZE    L"MaxQuorumLogSize"
#define CLUSREG_NAME_CHECKPOINT_INTERVAL    L"CheckpointInterval"

#define CLUSREG_NAME_FAILURE_RETRY_COUNT        L"RetryCount"
#define CLUSREG_NAME_FAILURE_RETRY_INTERVAL     L"RetryInterval"

//
// Private property names
//
#define CLUSREG_NAME_PHYSDISK_SIGNATURE             L"Signature"
#define CLUSREG_NAME_PHYSDISK_DRIVE                 L"Drive"
#define CLUSREG_NAME_PHYSDISK_SKIPCHKDSK            L"SkipChkdsk"
#define CLUSREG_NAME_PHYSDISK_CONDITIONAL_MOUNT     L"ConditionalMount"
#define CLUSREG_NAME_PHYSDISK_USEMOUNTPOINTS        L"UseMountPoints"
#define CLUSREG_NAME_PHYSDISK_MPVOLGUIDS            L"MPVolGuids"
#define CLUSREG_NAME_PHYSDISK_VOLGUID               L"VolGuid"
#define CLUSREG_NAME_PHYSDISK_SERIALNUMBER          L"SerialNumber"
#define CLUSREG_NAME_GENAPP_COMMAND_LINE            L"CommandLine"
#define CLUSREG_NAME_GENAPP_CURRENT_DIRECTORY       L"CurrentDirectory"
#define CLUSREG_NAME_GENAPP_INTERACT_WITH_DESKTOP   L"InteractWithDesktop"
#define CLUSREG_NAME_GENAPP_USE_NETWORK_NAME        L"UseNetworkName"
#define CLUSREG_NAME_GENSCRIPT_SCRIPT_FILEPATH      L"ScriptFilepath"
#define CLUSREG_NAME_GENSVC_SERVICE_NAME            L"ServiceName"
#define CLUSREG_NAME_GENSVC_STARTUP_PARAMS          L"StartupParameters"
#define CLUSREG_NAME_GENSVC_USE_NETWORK_NAME        L"UseNetworkName"
#define CLUSREG_NAME_IPADDR_NETWORK                 L"Network"
#define CLUSREG_NAME_IPADDR_ADDRESS                 L"Address"
#define CLUSREG_NAME_IPADDR_SUBNET_MASK             L"SubnetMask"
#define CLUSREG_NAME_IPADDR_ENABLE_NETBIOS          L"EnableNetBIOS"
#define CLUSREG_NAME_NETNAME_NAME                   L"Name"
#define CLUSREG_NAME_NETNAME_REMAP_PIPE_NAMES       L"RemapPipeNames"
#define CLUSREG_NAME_NETNAME_REQUIRE_DNS            L"RequireDNS"
#define CLUSREG_NAME_NETNAME_REQUIRE_KERBEROS       L"RequireKerberos"
#define CLUSREG_NAME_NETNAME_STATUS_NETBIOS         L"StatusNetBIOS"
#define CLUSREG_NAME_NETNAME_STATUS_DNS             L"StatusDNS"
#define CLUSREG_NAME_NETNAME_STATUS_KERBEROS        L"StatusKerberos"
#define CLUSREG_NAME_PRTSPOOL_DEFAULT_SPOOL_DIR     L"DefaultSpoolDirectory"
#define CLUSREG_NAME_PRTSPOOL_DRIVER_DIRECTORY      L"ClusterDriverDirectory"
#define CLUSREG_NAME_PRTSPOOL_TIMEOUT               L"JobCompletionTimeout"
#define CLUSREG_NAME_FILESHR_SHARE_NAME             L"ShareName"
#define CLUSREG_NAME_FILESHR_PATH                   L"Path"
#define CLUSREG_NAME_FILESHR_REMARK                 L"Remark"
#define CLUSREG_NAME_FILESHR_MAX_USERS              L"MaxUsers"
#define CLUSREG_NAME_FILESHR_SECURITY               L"Security"
#define CLUSREG_NAME_FILESHR_SD                     L"Security Descriptor"
#define CLUSREG_NAME_FILESHR_SHARE_SUBDIRS          L"ShareSubDirs"
#define CLUSREG_NAME_FILESHR_HIDE_SUBDIR_SHARES     L"HideSubDirShares"
#define CLUSREG_NAME_FILESHR_IS_DFS_ROOT            L"IsDfsRoot"
#define CLUSREG_NAME_FILESHR_CSC_CACHE              L"CSCCache"
#define CLUSREG_NAME_DHCP_DATABASE_PATH             L"DatabasePath"
#define CLUSREG_NAME_DHCP_BACKUP_PATH               L"BackupPath"
#define CLUSREG_NAME_WINS_DATABASE_PATH             L"DatabasePath"
#define CLUSREG_NAME_WINS_BACKUP_PATH               L"BackupPath"

//
// Standard Resource Type Names
//
#define CLUS_RESTYPE_NAME_GENAPP            L"Generic Application"
#define CLUS_RESTYPE_NAME_GENSVC            L"Generic Service"
#define CLUS_RESTYPE_NAME_FTSET             L"Fault Tolerant Disk Set"
#define CLUS_RESTYPE_NAME_PHYS_DISK         L"Physical Disk"
#define CLUS_RESTYPE_NAME_IPADDR            L"IP Address"
#define CLUS_RESTYPE_NAME_NETNAME           L"Network Name"
#define CLUS_RESTYPE_NAME_FILESHR           L"File Share"
#define CLUS_RESTYPE_NAME_PRTSPLR           L"Print Spooler"
#define CLUS_RESTYPE_NAME_TIMESVC           L"Time Service"
#define CLUS_RESTYPE_NAME_LKQUORUM          L"Local Quorum"
#define CLUS_RESTYPE_NAME_DHCP              L"DHCP Service"
#define CLUS_RESTYPE_NAME_MSMQ              L"Microsoft Message Queue Server"
#define CLUS_RESTYPE_NAME_NEW_MSMQ          L"MSMQ"
#define CLUS_RESTYPE_DISPLAY_NAME_NEW_MSMQ  L"Message Queuing"
#define CLUS_RESTYPE_NAME_MSDTC             L"Distributed Transaction Coordinator"
#define CLUS_RESTYPE_NAME_WINS              L"WINS Service"
#define CLUS_RESTYPE_NAME_IIS4              L"IIS Server Instance"
#define CLUS_RESTYPE_NAME_SMTP              L"SMTP Server Instance"
#define CLUS_RESTYPE_NAME_NNTP              L"NNTP Server Instance"
#define CLUS_RESTYPE_NAME_GENSCRIPT         L"Generic Script"
#define CLUS_RESTYPE_NAME_MAJORITYNODESET   L"Majority Node Set"


#define CLUS_NAME_DEFAULT_FILESPATH L"MSCS\\"
#define MAJORITY_NODE_SET_DIRECTORY_PREFIX L"MNS."

//
// Misc. strings
//

#define  CLUSTER_SERVICE_NAME       L"ClusSvc"
#define  TIME_SERVICE_NAME          L"TimeServ"
#define  CLUSTER_DIRECTORY          L"%windir%\\cluster"
#define  CLUSTER_DATABASE_NAME      L"CLUSDB"
#define  CLUSTER_DATABASE_TMPBKP_NAME L"CLUSDB.BKP$"


#endif // _CLUSUDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\inc\cluswiz.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cluswiz.h

Abstract:

    Public header file for NT Cluster Wizards

Author:

    John Vert (jvert) 6/17/1996

Revision History:

--*/
#ifndef _CLUSTER_WIZ_
#define _CLUSTER_WIZ_

#ifdef __cplusplus
extern "C" {
#endif

typedef HPROPSHEETPAGE *LPHPROPSHEETPAGE;


BOOL WINAPI
ClusterWizInit(
    VOID
    );

LPHPROPSHEETPAGE WINAPI
ClusterWizGetServerPages(
    LPDWORD PageCount
    );

LPHPROPSHEETPAGE WINAPI
ClusterWizGetAdminPages(
    LPDWORD PageCount
    );

#ifdef __cplusplus
}
#endif

#endif // _CLUSTER_API_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\inc\diskarbp.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    diskarbp.h

Abstract:

    This module defines the structures that are used
    to perform disk arbitration in clusdisk\ driver
    and resdll\disks disk resource.
    
Authors:

    Gor Nishanov (t-gorn)     18-June-1998

Revision History:

--*/

#ifndef _DISK_ARBITRATE_P_
#define _DISK_ARBITRATE_P_

#ifndef min
#define min( a, b ) ((a) <= (b) ? (a) : (b))
#endif

typedef struct _START_RESERVE_DATA {
   ULONG  DiskSignature;
   ULONG  Version;   
   ULONG  ArbitrationSector;
   ULONG  SectorSize;
   USHORT NodeSignatureSize;
   UCHAR  NodeSignature[32]; // MAX_COMPUTERNAME_LENGTH + 1
} 
START_RESERVE_DATA, *PSTART_RESERVE_DATA;

#define START_RESERVE_DATA_V1_SIG (sizeof(START_RESERVE_DATA))

typedef struct _ARBITRATION_ID {
   LARGE_INTEGER SystemTime;
   LARGE_INTEGER SeqNo;
   UCHAR         NodeSignature[32];
} ARBITRATION_ID, *PARBITRATION_ID;

#define RESERVE_TIMER   3      // 3 seconds to perform reserves

//
// IOCTL_ARBITRATION_ESCAPE subcodes
//

typedef enum {
   AE_TEST,
   AE_READ,
   AE_WRITE,
   AE_POKE,
   AE_RESET,
   AE_RESERVE,
   AE_RELEASE,
   AE_SECTORSIZE
} ARBITRATION_ESCAPE_SUBCODES;

typedef struct _ARBITRATION_READ_WRITE_PARAMS {
   ULONG Operation;
   ULONG SectorSize;
   ULONG SectorNo;
   PVOID Buffer;
   ULONG Signature;
} ARBITRATION_READ_WRITE_PARAMS, * PARBITRATION_READ_WRITE_PARAMS;

#define ARBITRATION_READ_WRITE_PARAMS_SIZE sizeof(ARBITRATION_READ_WRITE_PARAMS)

#endif // _DISK_ARBITRATE_P_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\inc\cnetapi.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cnetapi.h

Abstract:

    Cluster Network driver control APIs

Author:

    Mike Massa (mikemas)  14-Feb-1997

Environment:

    User Mode.

Revision History:

--*/


#ifndef _CNETAPI_INCLUDED
#define _CNETAPI_INCLUDED


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


//
// Join Phases
//

typedef enum {
    ClusnetJoinPhase1 = 1,
    ClusnetJoinPhase2 = 2,
    ClusnetJoinPhase3 = 3,
    ClusnetJoinPhase4 = 4,
    ClusnetJoinPhaseAbort = 0xFFFFFFFF
}  CLUSNET_JOIN_PHASE;


//
// Event Handler Routines.
//
typedef
VOID
(*CLUSNET_NODE_UP_ROUTINE)(
    IN CL_NODE_ID   NodeId
    );

typedef
VOID
(*CLUSNET_NODE_DOWN_ROUTINE)(
    IN CL_NODE_ID   NodeId
    );

typedef
BOOL
(*CLUSNET_CHECK_QUORUM_ROUTINE)(
    VOID
    );

typedef
VOID
(*CLUSNET_HOLD_IO_ROUTINE)(
    VOID
    );

typedef
VOID
(*CLUSNET_RESUME_IO_ROUTINE)(
    VOID
    );

typedef
VOID
(*CLUSNET_HALT_ROUTINE)(
    IN DWORD HaltCode
    );

//
// Routines
//
HANDLE
ClusnetOpenControlChannel(
    IN ULONG ShareAccess
    );

#define ClusnetCloseControlChannel(_handle)  CloseHandle(_handle)

DWORD
ClusnetEnableShutdownOnClose(
    IN HANDLE  ControlChannel
    );

DWORD
ClusnetDisableShutdownOnClose(
    IN HANDLE  ControlChannel
    );

DWORD
ClusnetInitialize(
    IN HANDLE                             ControlChannel,
    IN CL_NODE_ID                         LocalNodeId,
    IN ULONG                              MaxNodes,
    IN CLUSNET_NODE_UP_ROUTINE            NodeUpRoutine,
    IN CLUSNET_NODE_DOWN_ROUTINE          NodeDownRoutine,
    IN CLUSNET_CHECK_QUORUM_ROUTINE       CheckQuorumRoutine,
    IN CLUSNET_HOLD_IO_ROUTINE            HoldIoRoutine,
    IN CLUSNET_RESUME_IO_ROUTINE          ResumeIoRoutine,
    IN CLUSNET_HALT_ROUTINE               HaltRoutine
    );

DWORD
ClusnetShutdown(
    IN HANDLE       ControlChannel
    );

DWORD
ClusnetRegisterNode(
    IN HANDLE       ControlChannel,
    IN CL_NODE_ID   NodeId
    );

DWORD
ClusnetDeregisterNode(
    IN HANDLE       ControlChannel,
    IN CL_NODE_ID   NodeId
    );

DWORD
ClusnetRegisterNetwork(
    IN HANDLE               ControlChannel,
    IN CL_NETWORK_ID        NetworkId,
    IN ULONG                Priority,
    IN BOOLEAN              Restricted
    );

DWORD
ClusnetDeregisterNetwork(
    IN HANDLE         ControlChannel,
    IN CL_NETWORK_ID  NetworkId
    );

DWORD
ClusnetRegisterInterface(
    IN  HANDLE               ControlChannel,
    IN  CL_NODE_ID           NodeId,
    IN  CL_NETWORK_ID        NetworkId,
    IN  ULONG                Priority,
    IN  PWSTR                AdapterId,
    IN  ULONG                AdapterIdLength,
    IN  PVOID                TdiAddress,
    IN  ULONG                TdiAddressLength,
    OUT PULONG               MediaStatus
    );

DWORD
ClusnetDeregisterInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    );

DWORD
ClusnetOnlineNodeComm(
    IN HANDLE      ControlChannel,
    IN CL_NODE_ID  NodeId
    );

DWORD
ClusnetOfflineNodeComm(
    IN HANDLE      ControlChannel,
    IN CL_NODE_ID  NodeId
    );

DWORD
ClusnetOnlineNetwork(
    IN  HANDLE          ControlChannel,
    IN  CL_NETWORK_ID   NetworkId,
    IN  PWCHAR          TdiProviderName,
    IN  PVOID           TdiBindAddress,
    IN  ULONG           TdiBindAddressLength,
    IN  LPWSTR          AdapterName,
    OUT PVOID           TdiBindAddressInfo,
    IN  PULONG          TdiBindAddressInfoLength
    );

DWORD
ClusnetOfflineNetwork(
    IN HANDLE         ControlChannel,
    IN CL_NETWORK_ID  NetworkId
    );

DWORD
ClusnetSetNetworkRestriction(
    IN HANDLE               ControlChannel,
    IN CL_NETWORK_ID        NetworkId,
    IN BOOLEAN              Restricted,
    IN ULONG                NewPriority
    );

DWORD
ClusnetGetNetworkPriority(
    IN HANDLE               ControlChannel,
    IN  CL_NETWORK_ID       NetworkId,
    OUT PULONG              Priority
    );

DWORD
ClusnetSetNetworkPriority(
    IN HANDLE               ControlChannel,
    IN CL_NETWORK_ID        NetworkId,
    IN ULONG                Priority
    );

DWORD
ClusnetGetInterfacePriority(
    IN HANDLE               ControlChannel,
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId,
    OUT PULONG              InterfacePriority,
    OUT PULONG              NetworkPriority
    );

DWORD
ClusnetSetInterfacePriority(
    IN HANDLE               ControlChannel,
    IN CL_NODE_ID           NodeId,
    IN CL_NETWORK_ID        NetworkId,
    IN ULONG                Priority
    );

DWORD
ClusnetGetNodeCommState(
    IN  HANDLE                    ControlChannel,
    IN  CL_NODE_ID                NodeId,
    OUT PCLUSNET_NODE_COMM_STATE  State
    );

DWORD
ClusnetGetNetworkState(
    IN  HANDLE                  ControlChannel,
    IN  CL_NETWORK_ID           NetworkId,
    OUT PCLUSNET_NETWORK_STATE  State
    );

DWORD
ClusnetGetInterfaceState(
    IN  HANDLE                    ControlChannel,
    IN  CL_NODE_ID                NodeId,
    IN  CL_NETWORK_ID             NetworkId,
    OUT PCLUSNET_INTERFACE_STATE  State
    );

#ifdef MM_IN_CLUSNET

DWORD
ClusnetFormCluster(
    IN HANDLE       ControlChannel,
    IN ULONG        ClockPeriod,
    IN ULONG        SendHBRate,
    IN ULONG        RecvHBRate
    );

DWORD
ClusnetJoinCluster(
    IN     HANDLE              ControlChannel,
    IN     CL_NODE_ID          JoiningNodeId,
    IN     CLUSNET_JOIN_PHASE  Phase,
    IN     ULONG               JoinTimeout,
    IN OUT PVOID *             MessageToSend,
    OUT    PULONG              MessageLength,
    OUT    PULONG              DestNodeMask
    );

VOID
ClusnetEndJoinCluster(
    IN HANDLE  ControlChannel,
    IN PVOID   LastSentMessage
    );

DWORD
ClusnetDeliverJoinMessage(
    IN HANDLE  ControlChannel,
    IN PVOID   Message,
    IN ULONG   MessageLength
    );

DWORD
ClusnetLeaveCluster(
    IN HANDLE       ControlChannel
    );

DWORD
ClusnetEvictNode(
    IN HANDLE       ControlChannel,
    IN ULONG        NodeId
    );

#endif // MM_IN_CLUSNET

DWORD
ClusnetGetNodeMembershipState(
    IN  HANDLE ControlChannel,
    IN  ULONG NodeId,
    OUT CLUSNET_NODE_STATE * State
    );

DWORD
ClusnetSetNodeMembershipState(
    IN  HANDLE ControlChannel,
    IN  ULONG NodeId,
    IN  CLUSNET_NODE_STATE State
    );

DWORD
ClusnetSetEventMask(
    IN  HANDLE              ControlChannel,
    IN  CLUSNET_EVENT_TYPE  EventMask
    );

DWORD
ClusnetGetNextEvent(
    IN  HANDLE          ControlChannel,
    OUT PCLUSNET_EVENT  Event,
    IN  LPOVERLAPPED    Overlapped  OPTIONAL
    );

DWORD
ClusnetHalt(
    IN  HANDLE  ControlChannel
    );

DWORD
ClusnetSetMemLogging(
    IN  HANDLE  ControlChannel,
    IN  ULONG   NumberOfEntires
    );

DWORD
ClusnetSendPoisonPacket(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId
    );

DWORD
ClusnetSetOuterscreen(
    IN HANDLE          ControlChannel,
    IN ULONG           Outerscreen
    );

DWORD
ClusnetRegroupFinished(
    IN HANDLE          ControlChannel,
    IN ULONG           NewEpoch
    );

DWORD
ClusnetImportSecurityContexts(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      JoiningNodeId,
    IN PWCHAR          PackageName,
    IN ULONG           SignatureSize,
    IN PVOID           ServerContext,
    IN PVOID           ClientContext
    );

DWORD
ClusnetReserveEndpoint(
    IN HANDLE   ControlChannel,
    IN PWSTR    EndpointString
    );

DWORD
ClusnetConfigureMulticast(
    IN HANDLE               ControlChannel,
    IN CL_NETWORK_ID        NetworkId,
    IN ULONG                MulticastNetworkBrand,
    IN PVOID                MulticastAddress,
    IN ULONG                MulticastAddressLength,
    IN PVOID                Key,
    IN ULONG                KeyLength,
    IN PVOID                Salt,
    IN ULONG                SaltLength
    );

DWORD
ClusnetGetMulticastReachableSet(
    IN  HANDLE               ControlChannel,
    IN  CL_NETWORK_ID        NetworkId,
    OUT ULONG              * NodeScreen
    );

#if DBG

//
// Test routines - available in debug builds only.
//

DWORD
ClusnetSetDebugMask(
    IN HANDLE   ControlChannel,
    ULONG       Mask
    );

DWORD
ClusnetOnlinePendingInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    );

DWORD
ClusnetOnlineInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    );

DWORD
ClusnetOfflineInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    );

DWORD
ClusnetFailInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    );

DWORD
ClusnetSendMmMsg(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN ULONG           Pattern
    );

#endif // DBG


#ifdef __cplusplus
}
#endif // __cplusplus


#endif  // ndef _CNETAPI_INCLUDED




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\baseclusterresources.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      BaseClusterActionResources.h
//
//  Description:
//      Contains the definition of the string ids used by this library.
//      This file will be included in the main resource header of the project.
//
//  Maintained By:
//      David Potter    (DavidP)    06-MAR-2001
//      Vij Vasu        (Vvasu)     03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

// The starting ID for these strings.
#define ID_BCA_START    1000

/////////////////////////////////////////////////////////////////////
// Error strings
/////////////////////////////////////////////////////////////////////

// An error occurred attempting to read the Cluster Service installation state.
#define IDS_ERROR_GETTING_INSTALL_STATE         ( ID_BCA_START + 1 )

// An error occurred during the cluster configuration. The installation state of the Cluster Service is not correct for this operation.
#define IDS_ERROR_INCORRECT_INSTALL_STATE       ( ID_BCA_START + 2 )

// An error occurred attempting to ensure exclusive cluster configuration access. The required semaphore could not be created.
#define IDS_ERROR_SEMAPHORE_CREATION            ( ID_BCA_START + 3 )

// An error occurred attempting to ensure exclusive cluster configuration access. Another configuration session may be in progress.
#define IDS_ERROR_SEMAPHORE_ACQUISITION         ( ID_BCA_START + 4 )

// An error occurred attempting to locate the Cluster Service binaries. A registry error has occurred.
#define IDS_ERROR_GETTING_INSTALL_DIR           ( ID_BCA_START + 5 )

// An error occurred attempting to open a registry key.
#define IDS_ERROR_REGISTRY_OPEN                 ( ID_BCA_START + 6 )

// An error occurred attempting to query a registry value.
#define IDS_ERROR_REGISTRY_QUERY                ( ID_BCA_START + 7 )

// An error occurred attempting to open the configuration INF file.
#define IDS_ERROR_INF_FILE_OPEN                 ( ID_BCA_START + 8 )

// An error occurred attempting to determine the amount of free disk space.
#define IDS_ERROR_GETTING_FREE_DISK_SPACE       ( ID_BCA_START + 9 )

// Cluster configuration cannot proceed. The disk space available to create the local quorum resource is insufficient.
#define IDS_ERROR_INSUFFICIENT_DISK_SPACE       ( ID_BCA_START + 10 )

// An error occurred while attempting to determine the file system type installed on a disk.
#define IDS_ERROR_GETTING_FILE_SYSTEM           ( ID_BCA_START + 11 )

// An error occurred attempting to create a service. This operation may succeed if retried after some time or after rebooting.
#define IDS_ERROR_SERVICE_CREATE                ( ID_BCA_START + 12 )

// An error occurred while attempting to clean up a service.
#define IDS_ERROR_SERVICE_CLEANUP               ( ID_BCA_START + 13 )

// An error occurred while attempting to open a handle to the Service Control Manager.
#define IDS_ERROR_OPEN_SCM                      ( ID_BCA_START + 14 )

// An error occurred while attempting to configure the ClusSvc service.
#define IDS_ERROR_CLUSSVC_CONFIG                ( ID_BCA_START + 15 )

// An error occurred attempting to set the directory id of the cluster service directory.
#define IDS_ERROR_SET_DIRID                     ( ID_BCA_START + 16 )

// An error occurred attempting to install the cluster network provider.
#define IDS_ERROR_CLUSNET_PROV_INSTALL          ( ID_BCA_START + 17 )

// An error occurred attempting to set a registry value.
#define IDS_ERROR_REGISTRY_SET                  ( ID_BCA_START + 18 )

// An error occurred attempting to rename a registry key.
#define IDS_ERROR_REGISTRY_RENAME               ( ID_BCA_START + 19 )

// An error occurred attempting to start a service.
#define IDS_ERROR_SERVICE_START                 ( ID_BCA_START + 20 )

// An error occurred attempting to stop a service.
#define IDS_ERROR_SERVICE_STOP                  ( ID_BCA_START + 21 )

// An error occurred attempting to open the LSA policy.
#define IDS_ERROR_LSA_POLICY_OPEN               ( ID_BCA_START + 22 )

// An error occurred while the cluster database was being cleaned up.
#define IDS_ERROR_CLUSDB_CLEANUP                ( ID_BCA_START + 23 )

// An error occurred while enable a privilege for a thread.
#define IDS_ERROR_ENABLE_THREAD_PRIVILEGE       ( ID_BCA_START + 24 )

// An error occurred attempting to create the cluster hive.
#define IDS_ERROR_CLUSDB_CREATE_HIVE            ( ID_BCA_START + 25 )

// An error occurred attempting to populate the cluster hive.
#define IDS_ERROR_CLUSDB_POPULATE_HIVE          ( ID_BCA_START + 26 )

// An error occurred attempting to delete a directory.
#define IDS_ERROR_REMOVE_DIR                    ( ID_BCA_START + 27 )

// An error occurred attempting to validate the cluster service account.
#define IDS_ERROR_VALIDATING_ACCOUNT            ( ID_BCA_START + 28 )

// An error occurred attempting to get the computer name.
#define IDS_ERROR_GETTING_COMPUTER_NAME         ( ID_BCA_START + 29 )

// An error occurred attempting to get a universally unique identifier (UUID).
#define IDS_ERROR_UUID_INIT                     ( ID_BCA_START + 30 )

// An error occurred attempting to create a registry key.
#define IDS_ERROR_REGISTRY_CREATE               ( ID_BCA_START + 31 )

// An error occurred attempting to customize the cluster group.
#define IDS_ERROR_CUSTOMIZE_CLUSTER_GROUP       ( ID_BCA_START + 32 )

// An error occurred attempting to create the quorum directory.
#define IDS_ERROR_QUORUM_DIR_CREATE             ( ID_BCA_START + 33 )

// An error occurred attempting to open a handle to the ClusDisk service.
#define IDS_ERROR_CLUSDISK_OPEN                 ( ID_BCA_START + 34 )

// An error occurred attempting to configure the ClusDisk service.
#define IDS_ERROR_CLUSDISK_CONFIGURE            ( ID_BCA_START + 35 )

// An error occurred attempting to initialize the state of the ClusDisk service.
#define IDS_ERROR_CLUSDISK_INITIALIZE           ( ID_BCA_START + 36 )

// An error occurred attempting to clean up the ClusDisk service.
#define IDS_ERROR_CLUSDISK_CLEANUP              ( ID_BCA_START + 37 )

// An error occurred attempting to set the cluster service installation state.
#define IDS_ERROR_SETTING_INSTALL_STATE         ( ID_BCA_START + 38 )

// An error occurred attempting to obtain the primary domain of this computer.
#define IDS_ERROR_GETTING_PRIMARY_DOMAIN        ( ID_BCA_START + 39 )

// This computer is not part of a domain. Cluster configuration cannot proceed.
#define IDS_ERROR_NO_DOMAIN                     ( ID_BCA_START + 40 )

// An error occurred attempting to get information about the administrators group.
#define IDS_ERROR_GET_ADMIN_GROUP_INFO          ( ID_BCA_START + 41 )

// An error occurred attempting to change membership in the administrators group.
#define IDS_ERROR_ADMIN_GROUP_ADD_REMOVE        ( ID_BCA_START + 42 )

// An error occurred attempting to configure the cluster service account rights.
#define IDS_ERROR_ACCOUNT_RIGHTS_CONFIG         ( ID_BCA_START + 43 )

// An error occurred attempting to initialize cluster formation.
#define IDS_ERROR_CLUSTER_FORM_INIT             ( ID_BCA_START + 44 )

// An error occurred attempting to send a status report.
#define IDS_ERROR_SENDING_REPORT                ( ID_BCA_START + 45 )

// The user has aborted the configuration operation.
#define IDS_USER_ABORT                          ( ID_BCA_START + 46 )

// The name of the network used by the cluster IP address is invalid.
#define IDS_ERROR_INVALID_IP_NET                ( ID_BCA_START + 47 )

// The cluster name is invalid.
#define IDS_ERROR_INVALID_CLUSTER_NAME          ( ID_BCA_START + 48 )

// The cluster service account name is invalid.
#define IDS_ERROR_INVALID_CLUSTER_ACCOUNT       ( ID_BCA_START + 49 )

// An error occurred attempting to initialize node cleanup.
#define IDS_ERROR_CLUSTER_CLEANUP_INIT          ( ID_BCA_START + 50 )

// An error occurred attempting to make miscellaneous changes.
#define IDS_ERROR_NODE_CONFIG                   ( ID_BCA_START + 51 )

// An error occurred attempting to clean up miscellaneous changes made when this computer became part of a cluster.
#define IDS_ERROR_NODE_CLEANUP                  ( ID_BCA_START + 52 )

// An error occurred attempting to initialize cluster join.
#define IDS_ERROR_CLUSTER_JOIN_INIT             ( ID_BCA_START + 53 )

// An error occurred attempting to get a token for the cluster service account. The reason for this failure may be that your user account does not have the privilege to act as part of the operating system. Contact your administrator to obtain this privilege.
#define IDS_ERROR_GETTING_ACCOUNT_TOKEN         ( ID_BCA_START + 54 )

// An error occurred attempting to initialize the cluster join.
#define IDS_ERROR_JOIN_CLUSTER_INIT             ( ID_BCA_START + 55 )

// An error occurred attempting to get the token for an account.
#define IDS_ERROR_GET_ACCOUNT_TOKEN             ( ID_BCA_START + 56 )

// An error occurred attempting to impersonate a user.
#define IDS_ERROR_IMPERSONATE_USER              ( ID_BCA_START + 57 )

// An error occurred attempting to verify if this node can interoperate with the sponsor cluster.
#define IDS_ERROR_JOIN_CHECK_INTEROP            ( ID_BCA_START + 58 )

// This computer cannot interoperate with the sponsor cluster due to a version incompatibility.
#define IDS_ERROR_JOIN_INCOMPAT_SPONSOR         ( ID_BCA_START + 59 )

// An error occurred attempting to add this computer to the sponsor cluster database.
#define IDS_ERROR_JOINING_SPONSOR_DB            ( ID_BCA_START + 60 )

// An error occurred attempting to get data about this computer from the sponsor cluster.
#define IDS_ERROR_GET_NEW_NODE_ID               ( ID_BCA_START + 61 )

// An error occurred attempting to evict this computer from the sponsor cluster.
#define IDS_ERROR_EVICTING_NODE                 ( ID_BCA_START + 62 )

// An error occurred attempting to synchronize the cluster database with the sponsor cluster.
#define IDS_ERROR_JOIN_SYNC_DB                  ( ID_BCA_START + 63 )

// An error occurred attempting to convert the cluster name to a NetBIOS name.
#define IDS_ERROR_CVT_CLUSTER_NAME              ( ID_BCA_START + 64 )

// The cluster binding string is invalid.
#define IDS_ERROR_INVALID_CLUSTER_BINDINGSTRING ( ID_BCA_START + 65 )


/////////////////////////////////////////////////////////////////////
// Notification strings
/////////////////////////////////////////////////////////////////////

// Starting cluster formation
#define IDS_TASK_FORMING_CLUSTER                ( ID_BCA_START + 800 )

// Cleaning up cluster database
#define IDS_TASK_CLEANINGUP_CLUSDB              ( ID_BCA_START + 801 )

// Creating cluster database
#define IDS_TASK_FORM_CREATING_CLUSDB           ( ID_BCA_START + 802 )

// Customizing cluster database
#define IDS_TASK_FORM_CUSTOMIZING_CLUSDB        ( ID_BCA_START + 803 )

// Configuring the ClusDisk service
#define IDS_TASK_CONFIG_CLUSDISK                ( ID_BCA_START + 804 )

// Starting the ClusDisk service
#define IDS_TASK_STARTING_CLUSDISK              ( ID_BCA_START + 805 )

// Creating the Cluster Network Provider service
#define IDS_TASK_CREATING_CLUSNET               ( ID_BCA_START + 806 )

// Starting the Cluster Network Provider service
#define IDS_TASK_STARTING_CLUSNET               ( ID_BCA_START + 807 )

// Creating the Cluster service
#define IDS_TASK_CREATING_CLUSSVC               ( ID_BCA_START + 808 )

// Starting the Cluster service
#define IDS_TASK_STARTING_CLUSSVC               ( ID_BCA_START + 809 )

// Configuring the cluster service account
#define IDS_TASK_CONFIG_CLUSSVC_ACCOUNT         ( ID_BCA_START + 810 )

// Performing miscellaneous configuration steps
#define IDS_TASK_CONFIG_NODE                    ( ID_BCA_START + 811 )

// Adding node to cluster
#define IDS_TASK_JOINING_CLUSTER                ( ID_BCA_START + 812 )

// Creating cluster database
#define IDS_TASK_JOIN_CREATING_CLUSDB           ( ID_BCA_START + 813 )

// Synchronizing the cluster database with the sponsor cluster
#define IDS_TASK_JOIN_SYNC_CLUSDB               ( ID_BCA_START + 814 )

// Initializing cluster join
#define IDS_TASK_JOIN_INIT                      ( ID_BCA_START + 815 )

// Initializing cluster formation
#define IDS_TASK_FORM_INIT                      ( ID_BCA_START + 816 )

// Adding the cluster service account to the local Administrators group
#define IDS_TASK_MAKING_CLUSSVC_ACCOUNT_ADMIN   ( ID_BCA_START + 817 )

// The cluster service account was already a member of the local Administrators group
#define IDS_TASK_CLUSSVC_ACCOUNT_ALREADY_ADMIN  ( ID_BCA_START + 818 )

// The ending ID for these strings.
#define ID_BCA_END      1999
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cactionlist.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CActionList.h
//
//  Description:
//      Header file for CActionList class.
//
//      The CActionList is a class the provides a functionality for a list of
//      actions. When an action list is committed, it commits each of the
//      actions in its list. Either the entire list is committed or none of
//      actions are.
//
//  Implementation Files:
//      CActionList.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CAction base class
#include "CAction.h"

// For the list class
#include "CList.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CActionList
//
//  Description:
//      The CActionList is a class the provides a functionality for a list of
//      actions. When an action list is committed, it commits each of the
//      actions in its list.
//
//      If any of the actions fail (indicated by throwing an exception), then 
//      all the committed actions are rolled back.
//
//      The CActionList derives from CAction since it can also be committed
//      or rolled back.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CActionList : public CAction
{
public:

    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Default constructor.
    CActionList();

    // Default virtual destructor.
    ~CActionList();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Base class method.
    // Commit this action list. This method has to be durable and consistent. It shoud
    // try as far as possible to be atomic.
    //
    void Commit();

    //
    // Base class method.
    // Rollback this action list. Be careful about throwing exceptions from this method
    // as a stack unwind might be in progress when this method is called.
    //
    void Rollback();

    // Add an action to the end of the list of actions to be performed.
    virtual void AppendAction( CAction * const paNewActionIn );

    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw();


protected:

    //////////////////////////////////////////////////////////////////////////
    // Protected type definitions
    //////////////////////////////////////////////////////////////////////////
    typedef CList<CAction *>    ActionPtrList;


    //////////////////////////////////////////////////////////////////////////
    // Protected accessor methods
    //////////////////////////////////////////////////////////////////////////

    // 
    // Pending action list accessor
    //
    ActionPtrList & AplGetPendingActionsList() throw()
    { 
        return m_aplPendingActions;
    }


    //////////////////////////////////////////////////////////////////////////
    // Protected member functions
    //////////////////////////////////////////////////////////////////////////

    // Call commit on the action list. Called by Commit().
    void CommitList( ActionPtrList::CIterator & rapliFirstUncommittedOut );

    // Rollback the already committed actions.
    void RollbackCommitted( const ActionPtrList::CIterator & rapliFirstUncommittedIn );


private:

    //////////////////////////////////////////////////////////////////////////
    // Private type definitions
    //////////////////////////////////////////////////////////////////////////
    typedef CAction BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // List of actions yet to be committed.
    ActionPtrList       m_aplPendingActions;

}; //*** class CActionList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cactionlist.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CActionList.cpp
//
//  Description:
//      Contains the definition of the CActionList class.
//
//  Documentation:
//      TODO: Add pointer to external documentation later.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// For the CActionList class
#include "CActionList.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CActionList::CActionList( void )
//
//  Description:
//      Default constructor of the CActionList class
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by CList::CList()
//
//--
//////////////////////////////////////////////////////////////////////////////
CActionList::CActionList( void )
{
    BCATraceScope( "" );

    SetRollbackPossible( true );

} //*** CActionList::CActionList()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CActionList::~CActionList( void )
//
//  Description:
//      Default destructor of the CActionList class. Deletes all the pointers
//      in the list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by CList::CList()
//
//--
//////////////////////////////////////////////////////////////////////////////
CActionList::~CActionList( void )
{
    BCATraceScope( "" );

    ActionPtrList::CIterator apliFirst = m_aplPendingActions.CiBegin();
    ActionPtrList::CIterator apliCurrent = m_aplPendingActions.CiEnd();

    while ( apliCurrent != apliFirst )
    {
        --apliCurrent;

        // Delete this action.
        delete (*apliCurrent);
    }
} //*** CActionList::~CActionList()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CActionList::Commit( void )
//
//  Description:
//      Commit this action list. This method iterates through the list
//      sequentially and commits each action in the list in turn. 
//
//      If the commits of any of the actions throws an exeption, then all the
//      previously committed actions are rolled back. This exception is then
//      thrown back up.      
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CActionList::Commit( void )
{
    BCATraceScope( "" );

    // Iterator positioned at the first uncommitted action just past the last committed action.
    ActionPtrList::CIterator apliFirstUncommitted = m_aplPendingActions.CiBegin();

    // Call the base class commit method.
    BaseClass::Commit();

    try
    {
        // Walk the list of pending actions and commit them.
        CommitList( apliFirstUncommitted );

    } // try:
    catch( ... )
    {
        // If we are here, then something went wrong with one of the actions.

        BCATraceMsg( "Caught exception during commit." );
        LogMsg( "An error has occurred. The performed actions will be rolled back." );

        //
        // Rollback all committed actions in the reverse order. apliFirstUncommitted
        // is at the first uncommitted action.
        // Catch any exceptions thrown during rollback to make sure that there 
        // is no collided unwind.
        //
        try
        {
            RollbackCommitted( apliFirstUncommitted );
        }
        catch( ... )
        {
            //
            // The rollback of the committed actions has failed.
            // There is nothing that we can do, is there?
            // We certainly cannot rethrow this exception, since
            // the exception that caused the rollback is more important.
            //

            THR( E_UNEXPECTED );

            BCATraceMsg( "Caught exception during rollback." );
            LogMsg( "THIS COMPUTER MAY BE IN AN INVALID STATE. An error has occurred during rollback. Rollback will be aborted." );

        } // catch: all

        // Rethrow the exception thrown by commit.
        throw;

    } // catch: all

    // If we are here, then everything went well.
    SetCommitCompleted();

} //*** CActionList::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CActionList::Rollback( void )
//
//  Description:
//      Rollback this action list. If this list was successfully committed, then
//      this method iterates through the list in the reverse order and rolls
//      back action in turn. 
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CActionList::Rollback( void )
{
    BCATraceScope( "[IUnknown]" );

    // Call the base class rollback method. 
    BaseClass::Rollback();

    LogMsg( "Attempting to rollback action list." );

    // Rollback all actions starting from the last one.
    RollbackCommitted( m_aplPendingActions.CiEnd() );

    SetCommitCompleted( false );

} //*** CActionList::Rollback()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CActionList::AppendAction()
//
//  Description:
//      Add an action to the end of the list of actions to be performed.
//
//  Arguments:
//      paNewActionIn
//          Pointer to the action that is to be added to the end of the
//          action list. This pointer cannot be NULL. The object pointed to by 
//          this pointer is deleted when this list is deleted.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CAssert
//          If paNewActionIn is NULL.
//
//      Any that are thrown by the underlying list.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CActionList::AppendAction( CAction * paNewActionIn )
{
    BCATraceScope( "" );

    // Temporarily assign pointer to smart pointer to make sure that it is
    // deleted if it is not added to the list.
    CSmartGenericPtr< CPtrTrait< CAction > >  sapTempSmartPtr( paNewActionIn );

    if ( paNewActionIn == NULL ) 
    {
        BCATraceMsg( "Cannot append NULL action pointer to list. Throwing CAssert" );
        THROW_ASSERT( 
              E_INVALIDARG
            , "CActionList::AppendAction() => Cannot append NULL action pointer to list"
            );

    } // if: the pointer to the action to be appended is NULL

    //
    BCATraceMsg1( "Appending action (paNewActionIn = %p) to list.", paNewActionIn );

    // Add action to the end of the list.
    m_aplPendingActions.Append( paNewActionIn );

    // The pointer has been added to the list. Give up ownership of the memory.
    sapTempSmartPtr.PRelease();

    // The rollback capability of the list is the AND of the corresponding property of its member actions.
    SetRollbackPossible( FIsRollbackPossible() && paNewActionIn->FIsRollbackPossible() );

    // Since a new action has been added, set commit completed to false.
    SetCommitCompleted( false );

} //*** CActionList::AppendAction()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CActionList::CommitList()
//
//  Description:
//      Commit the action list of this object. This function is called by
//      commit to avoid having loops in a try block.
//
//  Arguments:
//       rapliFirstUncommittedOut
//          An iterator that points to the first uncommitted action.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CActionList::CommitList( ActionPtrList::CIterator & rapliFirstUncommittedOut )
{
    BCATraceScope( "" );

    ActionPtrList::CIterator apliCurrent = m_aplPendingActions.CiBegin();
    ActionPtrList::CIterator apliLast = m_aplPendingActions.CiEnd();

    rapliFirstUncommittedOut = apliCurrent;

    while( apliCurrent != apliLast )
    {
        BCATraceMsg1( "About to commit action (pointer = %#p)", *apliCurrent );

        // Commit the current action.
         (*apliCurrent)->Commit();

        // Move to the next action.
        ++apliCurrent;

        // This is now the first uncommitted action.
        rapliFirstUncommittedOut = apliCurrent;

    } // while: there still are actions to be committed.

} //*** CActionList::CommitList()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CActionList::RollbackCommitted()
//
//  Description:
//      Rollback all actions that have been committed.
//
//  Arguments:
//       rapliFirstUncommittedIn
//          An iterator that points to the first uncommitted action.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CActionList::RollbackCommitted( const ActionPtrList::CIterator & rapliFirstUncommittedIn )
{
    BCATraceScope( "" );

    ActionPtrList::CIterator apliFirst = m_aplPendingActions.CiBegin();
    ActionPtrList::CIterator apliCurrent = rapliFirstUncommittedIn;

    while ( apliCurrent != apliFirst )
    {
        --apliCurrent;
        // apliCurrent is now at the last committed action.

        BCATraceMsg1( "About to rollback action (pointer = %#p)", *apliCurrent );

        // Rollback the last un-rolledback, committed action.

        if ( (*apliCurrent)->FIsRollbackPossible() )
        {
            (*apliCurrent)->Rollback();
        } // if: this action can be rolled back
        else
        {
            BCATraceMsg( "This action cannot be rolled back. Rollback will not proceed." );
            LogMsg( "THIS COMPUTER MAY BE IN AN INVALID STATE. Rollback was aborted." );
        } // else: this action cannot be rolled back
    } // while: more actions

} //*** CActionList::RollbackCommitted()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CActionList::UiGetMaxProgressTicks()
//
//  Description:
//      Returns the number of progress messages that this action will send.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
UINT
CActionList::UiGetMaxProgressTicks() const throw()
{
    UINT    uiRetVal = 0;

    ActionPtrList::CIterator apliCurrent = m_aplPendingActions.CiBegin();
    ActionPtrList::CIterator apliLast = m_aplPendingActions.CiEnd();

    while ( apliCurrent != apliLast )
    {
        uiRetVal += (*apliCurrent)->UiGetMaxProgressTicks();
        ++apliCurrent;
    }

    return uiRetVal;

} //*** CActionList::UiGetMaxProgressTicks()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\caction.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CAction.cpp
//
//  Description:
//      Contains the definition of the CAction class.
//
//  Documentation:
//      TODO: Add pointer to external documentation later.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 25-APR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// For the CAction class
#include "CAction.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CAction::Commit( void )
//
//  Description:
//      This function just checks to make sure that this action has not already
//      been commmitted.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CAssert
//          If the action has already been committed.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CAction::Commit( void )
{
    BCATraceScope( "" );

    // Has this action already been committed?
    if ( FIsCommitComplete() )
    {
        BCATraceMsg( "This action has already been committed. Throwing exception." );
        THROW_ASSERT( E_UNEXPECTED, "This action has already been committed." );
    } // if: already committed.

} //*** CAction::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CAction::Rollback( void )
//
//  Description:
//      Since the Commit() of this class does nothing, rollback does nothing
//      too. However, it checks to make sure that this action can indeed be
//      rolled back.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CAssert
//          If this action has not been committed yet or if rollback is not
//          possible.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CAction::Rollback( void )
{
    BCATraceScope( "" );

    // Check if this action list has completed successfully.
    if ( !FIsCommitComplete() )
    {
        // Cannot rollback an incomplete action.
        BCATraceMsg( "Cannot rollback - this action has not been committed. Throwing exception." );
        THROW_ASSERT( E_UNEXPECTED, "Cannot rollback - this action has been committed." );
    } // if: this action was not completed successfully

    // Check if this list can be rolled back.
    if ( !FIsRollbackPossible() )
    {
        // Cannot rollback an incompleted action.
        BCATraceMsg( "This action list cannot be rolled back." );
        THROW_ASSERT( E_UNEXPECTED, "This action does not allow rollbacks." );
    } // if: this action was not completed successfully

} //*** CAction::Rollback()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\caction.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CAction.h
//
//  Description:
//      Header file for CAction class.
//
//      The CAction is the base class for all the action classes. It is an
//      abstract class which encapsulates the concept of an action - something
//      that be committed or rolled back. See IMPORTANT NOTE in the comment above
//      the class declaration.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For HRESULT, WCHAR, etc.
#include <windef.h>


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CAction
//
//  Description:
//      The CAction is the base class for all the action classes. It is an
//      abstract class which encapsulates the concept of an action - something
//      that be committed or rolled back.
//
//      Typically, any class that derives from this class would also implement
//      other methods that allow for specifying what action would be performed
//      by the Commit() method.
//
//  IMPORTANT NOTE: 
//      An object of this class cannot be a part of a transaction at this stage
//      because many of the resources typically used by these actions (the registry,
//      the SCM database, etc.) do not do not support transactions.
//
//      However, a transaction-like behavior is required from each of these
//      actions. What is meant by transaction-like is that the commit and
//      rollback methods of objects of this class have to guarantee durability,
//      and consistency. While they need not be isolated, they should at least
//      try to be atomic (it may not always be possilbe to be atomic).
//
//      If any action cannot guarantee that it is at least consistency and
//      durability (and preferably atomicity) during its commit, then it should 
//      NOT derive from this class.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CAction
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Default constructor.
    CAction()
        : m_fCommitComplete( false )
        , m_fRollbackPossible( true )
    {}

    // Default virtual destructor.
    virtual 
        ~CAction() {}


    //////////////////////////////////////////////////////////////////////////
    // Pure virtual functions
    //////////////////////////////////////////////////////////////////////////

    //
    // Commit this action. This method has to be durable and consistent. It shoud
    // try as far as possible to be atomic.
    // The implementation of this method checks to see if the action has been committed
    // and throws an exception if it already has been committed.
    //
    virtual void
        Commit();

    //
    // Rollback this action. Be careful about throwing exceptions from this method
    // as a stack unwind might be in progress when this method is called.
    // The implementation of this method checks to see if the action has been committed
    // and if it can be rolled back and throws an exception otherwise.
    //
    virtual void
        Rollback();

    // Returns the number of progress messages that this action will send.
    virtual UINT
        UiGetMaxProgressTicks() const throw() { return 0; }


    //////////////////////////////////////////////////////////////////////////
    // Public accessor methods
    //////////////////////////////////////////////////////////////////////////

    // Has this action been successfully committed.
    bool 
        FIsCommitComplete() const throw() { return m_fCommitComplete; }

    // Can this action be rolled back.
    bool 
        FIsRollbackPossible() const throw() { return m_fRollbackPossible; }


protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected accessor methods
    //////////////////////////////////////////////////////////////////////////

    // Set the commit status.
    void
        SetCommitCompleted( bool fComplete = true ) throw() { m_fCommitComplete = fComplete; }

    // Indicate if rollback is possible
    void
        SetRollbackPossible( bool fPossible = true ) throw() { m_fRollbackPossible = fPossible; }


private:

    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Indicates if this action has been successfully committed or not.
    bool                m_fCommitComplete;

    // Indicates if this action can be rolled back or not.
    bool                m_fRollbackPossible;

}; //*** class CAction
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\bcatrace.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      BCATrace.h
//
//  Description:
//      Contains definition of a few macros and a class that helps in tracing.
//
//  Implementation Files:
//      None
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


#ifdef DEBUG


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


// For debugging functions.
#include "Debug.h"

// For Logging functions.
#include "Log.h"

// For PszTraceFindInterface()
#include "CiTracker.h"


//////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

#define BCA_TRACE_FLAGS static_cast< unsigned long >( mtfALWAYS )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  BCATraceMsg(
//      _pszfn
//      )
//
//  Description:
//      Displays file, line number, module and "_pszfn" only if the
//      mtfOUTPUTTODISK | mtfFunc is set in g_tfModule. "_pszfn" is the name of the
//      function just entered.
//
//  Arguments:
//      _pszfn  - Name of the function just entered.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define BCATraceMsg( _pszfn ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, BCA_TRACE_FLAGS, TEXT("| ") TEXT(_pszfn) ); \
        } \
    } while ( 0 )

//
// These next macros are just like TraceFunc except they take additional
// arguments to display the values passed into the function call. "_pszfn"
// should contain a printf string on how to display the arguments.
//

#define BCATraceMsg1( _pszfn, _arg1 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, BCA_TRACE_FLAGS, TEXT("| ") TEXT(_pszfn), _arg1 ); \
        } \
    } while ( 0 )

#define BCATraceMsg2( _pszfn, _arg1, _arg2 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, BCA_TRACE_FLAGS, TEXT("| ") TEXT(_pszfn), _arg1, _arg2 ); \
        } \
    } while ( 0 )
#define BCATraceMsg3( _pszfn, _arg1, _arg2, _arg3 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, BCA_TRACE_FLAGS, TEXT("| ") TEXT(_pszfn), _arg1, _arg2, _arg3 ); \
        } \
    } while ( 0 )
#define BCATraceMsg4( _pszfn, _arg1, _arg2, _arg3, _arg4 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, BCA_TRACE_FLAGS, TEXT("| ") TEXT(_pszfn), _arg1, _arg2, _arg3, _arg4 ); \
        } \
    } while ( 0 )
#define BCATraceMsg5( _pszfn, _arg1, _arg2, _arg3, _arg4, _arg5 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, BCA_TRACE_FLAGS, TEXT("| ") TEXT(_pszfn), _arg1, _arg2, _arg3, _arg4, _arg5 ); \
        } \
    } while ( 0 )

#define BCATraceMsg6( _pszfn, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, BCA_TRACE_FLAGS, TEXT("| ") TEXT(_pszfn), _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ); \
        } \
    } while ( 0 )


#define BCATraceScope( _szArgs ) \
    CBCATraceScope scopeTracker##__LINE__( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(__FUNCTION__) ); \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter( ); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(__FUNCTION__) TEXT("( ") TEXT(_szArgs) TEXT(" )")  ); \
    }

#define BCATraceScope1( _szArgs, _arg1 ) \
    CBCATraceScope scopeTracker##__LINE__( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(__FUNCTION__) ); \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter( ); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(__FUNCTION__) TEXT("( ") TEXT(_szArgs) TEXT(" )"), _arg1 ); \
    }

#define BCATraceScope2( _szArgs, _arg1, _arg2 ) \
    CBCATraceScope scopeTracker##__LINE__( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(__FUNCTION__) ); \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter( ); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(__FUNCTION__) TEXT("( ") TEXT(_szArgs) TEXT(" )"), _arg1, _arg2 ); \
    }

#define BCATraceScope3( _szArgs, _arg1, _arg2, _arg3 ) \
    CBCATraceScope scopeTracker##__LINE__( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(__FUNCTION__) ); \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter( ); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(__FUNCTION__) TEXT("( ") TEXT(_szArgs) TEXT(" )"), _arg1, _arg2, _arg3 ); \
    }

#define BCATraceScope4( _szArgs, _arg1, _arg2, _arg3, _arg4 ) \
    CBCATraceScope scopeTracker##__LINE__( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(__FUNCTION__) ); \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter( ); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(__FUNCTION__) TEXT("( ") TEXT(_szArgs) TEXT(" )"), _arg1, _arg2, _arg3, _arg4 ); \
    }

#define BCATraceScope5( _szArgs, _arg1, _arg2, _arg3, _arg4, _arg5 ) \
    CBCATraceScope scopeTracker##__LINE__( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(__FUNCTION__) ); \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter( ); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(__FUNCTION__) TEXT("( ") TEXT(_szArgs) TEXT(" )"), _arg1, _arg2, _arg3, _arg4, _arg5 ); \
    }

#define BCATraceQIScope( _riid, _ppv ) \
    CBCATraceScope scopeTracker##__LINE__( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(__FUNCTION__), _riid, _ppv )

//////////////////////////////////////////////////////////////////////////////
// Class Definitions
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CBCATraceScope
//
//  Description:
//      This class traces entry and exit of a scope. To use this class,
//      instantiate an object of this class in the scope to be traced.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CBCATraceScope
{
public:

    const TCHAR * const     m_pszFileName;
    const UINT              m_uiLine;
    const TCHAR * const     m_pszModuleName;
    const TCHAR * const     m_pszScopeName;

    // Constructor - prints function entry.
    CBCATraceScope(
          const TCHAR * const   pszFileNameIn
        , const UINT            uiLineIn
        , const TCHAR * const   pszModuleNameIn
        , const TCHAR * const   pszScopeNameIn
        )
        : m_pszFileName( pszFileNameIn )
        , m_uiLine( uiLineIn )
        , m_pszModuleName( pszModuleNameIn )
        , m_pszScopeName( pszScopeNameIn )
    {
    } //*** CBCATraceScope::CBCATraceScope( )

    // Constructor for QIs
    CBCATraceScope(
          const TCHAR * const   pszFileNameIn
        , const UINT            uiLineIn
        , const TCHAR * const   pszModuleNameIn
        , const TCHAR * const   pszScopeNameIn
        , REFIID                riid
        , void **               ppv
        )
        : m_pszFileName( pszFileNameIn )
        , m_uiLine( uiLineIn )
        , m_pszModuleName( pszModuleNameIn )
        , m_pszScopeName( pszScopeNameIn )
    {
        if ( g_tfModule != 0 )
        {
            WCHAR szGuid[ cchGUID_STRING_SIZE ];
            DebugIncrementStackDepthCounter( );
            TraceMessage(
                  m_pszFileName
                , m_uiLine
                , m_pszModuleName
                , mtfFUNC
                , TEXT("+ %s( [IUnknown] %s, ppv = %#x )")
                , m_pszScopeName
                , PszTraceFindInterface( riid, szGuid )
                , ppv
                );
        }

    } //*** CBCATraceScope::CBCATraceScope( )

    // Destructor - prints function exit.
    ~CBCATraceScope( void )
    {
        if ( g_tfModule != 0 )
        {
            TraceMessage(
                  m_pszFileName
                , m_uiLine
                , m_pszModuleName
                , mtfFUNC
                , TEXT("V %s")
                , m_pszScopeName
                );
            DebugDecrementStackDepthCounter( );
        }

    } //*** CBCATraceScope::~CBCATraceScope( )

}; //*** class CBCATraceScope

#else // ifdef DEBUG

// For Logging functions.
#include "Log.h"

#define BCATraceMsg( _pszfn )
#define BCATraceMsg1( _pszfn, _arg1 )
#define BCATraceMsg2( _pszfn, _arg1, _arg2 )
#define BCATraceMsg3( _pszfn, _arg1, _arg2, _arg3 )
#define BCATraceMsg4( _pszfn, _arg1, _arg2, _arg3, _arg4 )
#define BCATraceMsg5( _pszfn, _arg1, _arg2, _arg3, _arg4, _arg5 )
#define BCATraceMsg6( _pszfn, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 )
#define BCATraceScope( _szArgs )
#define BCATraceScope1( _szArgs, _arg1 )
#define BCATraceScope2( _szArgs, _arg1, _arg2 )
#define BCATraceScope3( _szArgs, _arg1, _arg2, _arg3 )
#define BCATraceScope4( _szArgs, _arg1, _arg2, _arg3, _arg4 )
#define BCATraceScope5( _szArgs, _arg1, _arg2, _arg3, _arg4, _arg5 )
#define BCATraceQIScope( _riid, _ppv )

#endif  // ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cbaseclusteraction.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CBaseClusterAction.cpp
//
//  Description:
//      Contains the definition of the CBaseClusterAction class.
//
//  Maintained By:
//      David Potter    (DavidP)    06-MAR-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// For the CBaseClusterAction class
#include "CBaseClusterAction.h"

// For OS version check and installation state functions.
#include "clusrtl.h"

// For the CEnableThreadPrivilege class.
#include "CEnableThreadPrivilege.h"

// For CLUSREG_INSTALL_DIR_VALUE_NAME
#include "clusudef.h"


//////////////////////////////////////////////////////////////////////////////
// Global variables
//////////////////////////////////////////////////////////////////////////////

// Name of the cluster configuration semaphore.
const WCHAR *  g_pszConfigSemaphoreName = L"Global\\Microsoft Cluster Configuration Semaphore";


//////////////////////////////////////////////////////////////////////////
// Macros definitions
//////////////////////////////////////////////////////////////////////////

// Name of the main cluster INF file.
#define CLUSTER_INF_FILE_NAME \
    L"ClCfgSrv.INF"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterAction::CBaseClusterAction
//
//  Description:
//      Default constructor of the CBaseClusterAction class
//
//  Arguments:
//      pbcaiInterfaceIn
//          Pointer to the interface class for this library.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusterAction::CBaseClusterAction( CBCAInterface * pbcaiInterfaceIn )
    : m_ebcaAction( eCONFIG_ACTION_NONE )
    , m_pbcaiInterface( pbcaiInterfaceIn )
{
    BCATraceScope( "" );

    DWORD           dwBufferSize    = 0;
    UINT            uiErrorLine     = 0;
    LPBYTE          pbTempPtr       = NULL;
    DWORD           dwError         = ERROR_SUCCESS;
    SmartSz         sszTemp;
    CRegistryKey    rkInstallDirKey;


    //
    // Perform a sanity check on the parameters used by this class
    //
    if ( pbcaiInterfaceIn == NULL )
    {
        BCATraceMsg( "The pointer to the interface object is NULL. Throwing exception." );
        THROW_ASSERT( E_INVALIDARG, "The pointer to the interface object is NULL" );
    } // if: the input pointer is NULL


    //
    // Get the cluster installation directory.
    //
    m_strClusterInstallDir.Empty();

    // Open the registry key.
    rkInstallDirKey.OpenKey(
          HKEY_LOCAL_MACHINE
        , CLUSREG_KEYNAME_NODE_DATA
        , KEY_READ
        );

    rkInstallDirKey.QueryValue( 
          CLUSREG_INSTALL_DIR_VALUE_NAME
        , &pbTempPtr
        , &dwBufferSize
        );

    // Memory will be freed when this function exits.
    sszTemp.Assign( reinterpret_cast< WCHAR * >( pbTempPtr ) );

    // Copy the path into the member variable.
    m_strClusterInstallDir = sszTemp.PMem();

    {
        // First, remove any trailing backslash characters from the quorum directory name.
        WCHAR       rgchQuorumDirName[ sizeof( CLUS_NAME_DEFAULT_FILESPATH ) / sizeof( *CLUS_NAME_DEFAULT_FILESPATH ) ];
        signed int  idxLastChar = sizeof( CLUS_NAME_DEFAULT_FILESPATH ) / sizeof( *CLUS_NAME_DEFAULT_FILESPATH ) - 1;

        wcsncpy(
              rgchQuorumDirName
            , CLUS_NAME_DEFAULT_FILESPATH
            , idxLastChar + 1
            );

        --idxLastChar;      // idxLastChar now points to the last non-null character

        // Iterate till we find the last character that is not a backspace.
        while ( ( idxLastChar >= 0 ) && ( rgchQuorumDirName[ idxLastChar ] == L'\\' ) )
        {
            --idxLastChar;
        }

        // idxLastChar now points to the last non-backspace character. Terminate the string after this character.
        rgchQuorumDirName[ idxLastChar + 1 ] = L'\0';

        // Determine the local quorum directory.
        m_strLocalQuorumDir = m_strClusterInstallDir + L"\\";
        m_strLocalQuorumDir += rgchQuorumDirName;
    }

    LogMsg( 
          "The cluster installation directory is '%s'. The localquorum directory is '%s'."
        , m_strClusterInstallDir.PszData()
        , m_strLocalQuorumDir.PszData()
        );
    BCATraceMsg2(
          "The cluster installation directory is '%s'. The localquorum directory is '%s'."
        , m_strClusterInstallDir.PszData()
        , m_strLocalQuorumDir.PszData()
        );


    //
    // Open the main cluster INF file.
    //
    m_strMainInfFileName = m_strClusterInstallDir + L"\\" CLUSTER_INF_FILE_NAME;

    m_sihMainInfFile.Assign(
        SetupOpenInfFile(
              m_strMainInfFileName.PszData()
            , NULL
            , INF_STYLE_WIN4
            , &uiErrorLine
            )
        );

    if ( m_sihMainInfFile.FIsInvalid() )
    {
        dwError = TW32( GetLastError() );

        LogMsg( "Could not open INF file '%s'. Error code = %#08x. Error line = %d. Cannot proceed.", m_strMainInfFileName.PszData(), dwError, uiErrorLine );
        BCATraceMsg3( "Could not open INF file '%s'. Error code = %#08x. Error line = %d. Throwing exception.", m_strMainInfFileName.PszData(), dwError, uiErrorLine );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_INF_FILE_OPEN );

    } // if: INF file could not be opened.

    BCATraceMsg1( "The INF file '%s' has been opened.", m_strMainInfFileName.PszData() );


    // Associate the cluster installation directory with the directory id CLUSTER_DIR_DIRID
    SetDirectoryId( m_strClusterInstallDir.PszData(), CLUSTER_DIR_DIRID );

    // Set the id for the local quorum directory.
    SetDirectoryId( m_strLocalQuorumDir.PszData(), CLUSTER_LOCALQUORUM_DIRID );

    //
    // Create a semaphore that will be used to make sure that only one commit is occurring
    // at a time. But do not acquire the semaphore now. It will be acquired later.
    //
    // Note that if this component is in an STA then, more than one instance of this
    // component may have the same thread excecuting methods when multiple configuration
    // sessions are started simultaneously. The way CreateMutex works, all components that
    // have the same thread running through them will successfully acquire the mutex.
    //
    SmartSemaphoreHandle smhConfigSemaphoreHandle( 
        CreateSemaphore( 
              NULL                      // Default security descriptor 
            , 1                         // Initial count.
            , 1                         // Maximum count.
            , g_pszConfigSemaphoreName  // Name of the semaphore
            )
        );

    // Check if creation failed.
    if ( smhConfigSemaphoreHandle.FIsInvalid() ) 
    {
        DWORD dwError = TW32( GetLastError() );

        LogMsg( "Semaphore '%ws' could not be created. Error %#08x. Cannot proceed.", g_pszConfigSemaphoreName, dwError );
        BCATraceMsg2( "Semaphore '%ws' could not be created. Error %#08x. Throwing exception.", g_pszConfigSemaphoreName, dwError );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_SEMAPHORE_CREATION );
    } // if: semaphore could not be created.

    m_sshConfigSemaphoreHandle = smhConfigSemaphoreHandle;

    //
    // Open and store the handle to the SCM. This will make life a lot easier for
    // other actions.
    //
    m_sscmhSCMHandle.Assign( OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS ) );

    // Could we get the handle to the SCM?
    if ( m_sscmhSCMHandle.FIsInvalid() )
    {
        DWORD dwError = TW32( GetLastError() );

        LogMsg( "Error %#08x occurred trying get a handle to the SCM. Cannot proceed.", dwError );
        BCATraceMsg1( "Error %#08x occurred trying get a handle to the SCM. Throwing exception.", dwError );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_OPEN_SCM );
    }

} //*** CBaseClusterAction::CBaseClusterAction()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterAction::~CBaseClusterAction
//
//  Description:
//      Destructor of the CBaseClusterAction class
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusterAction::~CBaseClusterAction( void ) throw()
{
} //*** CBaseClusterAction::~CBaseClusterAction()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CBaseClusterAction::Commit
//
//  Description:
//      Acquires a semaphore to prevent simultaneous configuration and commits
//      the action list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CAssert
//          If this object is not in the correct state when this function is
//          called.
//
//      Any exceptions thrown by functions called.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterAction::Commit( void )
{
    BCATraceScope( "" );

    DWORD   dwSemaphoreState;

    // Call the base class commit method.
    BaseClass::Commit();


    LogMsg( "Initiating cluster configuration." );

    //
    // Acquire the cluster configuration semaphore.
    // It is ok to use WaitForSingleObject() here instead of MsgWaitForMultipleObjects
    // since we are not blocking.
    //
    dwSemaphoreState = WaitForSingleObject( m_sshConfigSemaphoreHandle, 0 ); // zero timeout

    // Did we get the semaphore?
    if (  ( dwSemaphoreState != WAIT_ABANDONED )
       && ( dwSemaphoreState != WAIT_OBJECT_0 )
       )
    {
        DWORD dwError;

        if ( dwSemaphoreState == WAIT_FAILED )
        {
            dwError = TW32( GetLastError() );
        } // if: WaitForSingleObject failed.
        else
        {
            dwError = TW32( ERROR_LOCK_VIOLATION );
        } // else: could not get lock

        LogMsg( "Could not acquire configuration lock. Error %#08x. Aborting.", dwError );
        BCATraceMsg1( "Could not acquire configuration lock. Error %#08x. Throwing exception.", dwError );
        THROW_CONFIG_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_SEMAPHORE_ACQUISITION );
    } // if: semaphore acquisition failed

    // Assign the locked semaphore handle to a smart handle for safe release.
    SmartSemaphoreLock sslConfigSemaphoreLock( m_sshConfigSemaphoreHandle.HHandle() );

    BCATraceMsg( "Configuration semaphore acquired. Committing action list." );
    LogMsg( "The configuration lock has been acquired." );

    // Commit the action list.
    m_alActionList.Commit();

} //*** CBaseClusterAction::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CBaseClusterAction::Rollback
//
//  Description:
//      Performs the rolls back of the action committed by this object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by functions called.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterAction::Rollback( void )
{
    BCATraceScope( "" );

    // Call the base class rollback method. 
    BaseClass::Rollback();
    
    // Rollback the actions.
    m_alActionList.Rollback();

} //*** CBaseClusterAction::Rollback()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CBaseClusterAction::SetDirectoryId
//
//  Description:
//      Associate a particular directory with an id in the main INF file.
//
//  Arguments:
//      pcszDirectoryNameIn
//          The full path to the directory.
//
//      uiIdIn
//          The id to associate this directory with.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If SetupSetDirectoryId fails.
//
//  Remarks:
//      m_sihMainInfFile has to be valid before this function can be called.
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterAction::SetDirectoryId(
      const WCHAR * pcszDirectoryNameIn
    , UINT          uiIdIn 
    )
{
    if ( SetupSetDirectoryId( m_sihMainInfFile, uiIdIn, pcszDirectoryNameIn ) == FALSE )
    {
        DWORD dwError = TW32( GetLastError() );

        LogMsg( "Could not associate the directory '%ws' with the id %#x. Error %#08x. Cannot proceed.", pcszDirectoryNameIn, uiIdIn, dwError );
        BCATraceMsg3( "Could not associate the directory '%ws' with the id %#x. Error %#08x. Throwing exception.", pcszDirectoryNameIn, uiIdIn, dwError );
        
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_SET_DIRID );
    } // if: there was an error setting the directory id.
            
    BCATraceMsg2( "Directory id %d associated with '%ws'.", uiIdIn, pcszDirectoryNameIn );

} //*** CBaseClusterAction::SetDirectoryId()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cbaseclusteraddnode.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CBaseClusterAddNode.cpp
//
//  Description:
//      Contains the definition of the CBaseClusterAddNode class.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header file of this class.
#include "CBaseClusterAddNode.h"

// For OS version checking, installation state, etc.
#include "clusrtl.h"

// For CLUSTER_INTERNAL_CURRENT_MAJOR_VERSION and other version defines.
#include "clusverp.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterAddNode::CBaseClusterAddNode
//
//  Description:
//      Constructor of the CBaseClusterAddNode class.
//
//      This function also stores the parameters that are required for
//      cluster form and join. At this time, only minimal validation is done
//      on the these parameters.
//
//      This function also checks if the computer is in the correct state
//      for cluster configuration.
//
//  Arguments:
//      pbcaiInterfaceIn
//          Pointer to the interface class for this library.
//
//      pszClusterNameIn
//          Name of the cluster to be formed or joined.
//
//      pszClusterAccountNameIn
//      pszClusterAccountPwdIn
//      pszClusterAccountDomainIn
//          Specifies the account to be used as the cluster service account.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusterAddNode::CBaseClusterAddNode(
      CBCAInterface *   pbcaiInterfaceIn
    , const WCHAR *     pcszClusterNameIn
    , const WCHAR *     pcszClusterBindingStringIn
    , const WCHAR *     pcszClusterAccountNameIn
    , const WCHAR *     pcszClusterAccountPwdIn
    , const WCHAR *     pcszClusterAccountDomainIn
    )
    : BaseClass( pbcaiInterfaceIn )
    , m_strClusterAccountName( pcszClusterAccountNameIn )
    , m_strClusterAccountPwd( pcszClusterAccountPwdIn )
    , m_strClusterAccountDomain( pcszClusterAccountDomainIn )
    , m_strClusterBindingString( pcszClusterBindingStringIn )
    , m_fIsVersionCheckingDisabled( false )
{
    BCATraceScope( "" );

    DWORD       dwError = ERROR_SUCCESS;
    NTSTATUS    nsStatus;

    //
    // Perform a sanity check on the parameters used by this class
    //
    if ( ( pcszClusterNameIn == NULL ) || ( *pcszClusterNameIn == L'\0'  ) )
    {
        BCATraceMsg( "The cluster name is invalid. Throwing exception." );
        LogMsg( "The cluster name is invalid." );
        THROW_CONFIG_ERROR( E_INVALIDARG, IDS_ERROR_INVALID_CLUSTER_NAME );
    } // if: the cluster name is empty

    if ( ( pcszClusterAccountNameIn == NULL ) || ( *pcszClusterAccountNameIn == L'\0'  ) )
    {
        BCATraceMsg( "The cluster account name is empty. Throwing exception." );
        LogMsg( "The cluster account name is invalid." );
        THROW_CONFIG_ERROR( E_INVALIDARG, IDS_ERROR_INVALID_CLUSTER_ACCOUNT );
    } // if: the cluster account is empty

    //
    // Set the cluster name.  This method also converts the
    // cluster name to its NetBIOS name.
    //
    SetClusterName( pcszClusterNameIn );

    m_strClusterDomainAccount = m_strClusterAccountDomain + L"\\";
    m_strClusterDomainAccount += m_strClusterAccountName;

    //
    // Write parameters to log file.
    //
    LogMsg( "Cluster Name => '%s'", m_strClusterName.PszData() );
    LogMsg( "Cluster Service Account  => '%s'", m_strClusterDomainAccount.PszData() );


    //
    // Open a handle to the LSA policy. This is used by several action classes.
    //
    {
        LSA_OBJECT_ATTRIBUTES       loaObjectAttributes;
        LSA_HANDLE                  hPolicyHandle;

        ZeroMemory( &loaObjectAttributes, sizeof( loaObjectAttributes ) );

        nsStatus = LsaOpenPolicy(
              NULL                                  // System name
            , &loaObjectAttributes                  // Object attributes.
            , POLICY_ALL_ACCESS                     // Desired Access
            , &hPolicyHandle                        // Policy handle
            );

        if ( nsStatus != STATUS_SUCCESS )
        {
            LogMsg( "Error %#08x occurred trying to open the LSA Policy.", nsStatus );
            BCATraceMsg1( "Error %#08x occurred trying to open the LSA Policy.", nsStatus );
            THROW_RUNTIME_ERROR( nsStatus, IDS_ERROR_LSA_POLICY_OPEN );
        } // if LsaOpenPolicy failed.

        // Store the opened handle in the member variable.
        m_slsahPolicyHandle.Assign( hPolicyHandle );
    }

    //
    // Make sure that this computer is part of a domain.
    //
    {
        PPOLICY_PRIMARY_DOMAIN_INFO ppolDomainInfo = NULL;
        bool                        fIsPartOfDomain;

        // Get information about the primary domain of this computer.
        nsStatus = THR( LsaQueryInformationPolicy(
                              HGetLSAPolicyHandle()
                            , PolicyPrimaryDomainInformation
                            , reinterpret_cast< PVOID * >( &ppolDomainInfo )
                            ) );

        // Check if this computer is part of a domain and free the allocated memory.
        fIsPartOfDomain = ( ppolDomainInfo->Sid != NULL );
        LsaFreeMemory( ppolDomainInfo );

        if ( NT_SUCCESS( nsStatus ) == FALSE )
        {
            LogMsg( "Error %#08x occurred trying to obtain the primary domain of this computer. Cannot proceed.", dwError );
            BCATraceMsg1( "Error %#08x occurred trying to obtain the primary domain of this computer. Cannot proceed.", dwError );

            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_GETTING_PRIMARY_DOMAIN );
        } // LsaQueryInformationPolicy() failed.

        if ( ! fIsPartOfDomain )
        {
            THROW_CONFIG_ERROR( HRESULT_FROM_WIN32( ERROR_INVALID_DOMAINNAME ), IDS_ERROR_NO_DOMAIN );
        } // if: this computer is not a part of a domain
    }


    //
    // Lookup the cluster service account SID and store it.
    //

    do
    {
        DWORD           dwSidSize = 0;
        DWORD           dwDomainSize = 0;
        SID_NAME_USE    snuSidNameUse;

        // Find out how much space is required by the SID.
        if ( LookupAccountName(
                  NULL
                , m_strClusterDomainAccount.PszData()
                , NULL
                , &dwSidSize
                , NULL
                , &dwDomainSize
                , &snuSidNameUse
                )
             ==  FALSE
           )
        {
            dwError = GetLastError();

            if ( dwError != ERROR_INSUFFICIENT_BUFFER )
            {
                TW32( dwError );
                BCATraceMsg( "LookupAccountName() failed while querying for required buffer size." );
                break;
            } // if: something else has gone wrong.
            else
            {
                // This is expected.
                dwError = ERROR_SUCCESS;
            } // if: ERROR_INSUFFICIENT_BUFFER was returned.
        } // if: LookupAccountName failed

        // Allocate memory for the new SID and the domain name.
        m_sspClusterAccountSid.Assign( reinterpret_cast< SID * >( new BYTE[ dwSidSize ] ) );
        SmartSz sszDomainName( new WCHAR[ dwDomainSize ] );

        if ( m_sspClusterAccountSid.FIsEmpty() || sszDomainName.FIsEmpty() )
        {
            dwError = TW32( ERROR_OUTOFMEMORY );
            break;
        } // if: there wasn't enough memory for this SID.

        // Fill in the SID
        if ( LookupAccountName(
                  NULL
                , m_strClusterDomainAccount.PszData()
                , m_sspClusterAccountSid.PMem()
                , &dwSidSize
                , sszDomainName.PMem()
                , &dwDomainSize
                , &snuSidNameUse
                )
             ==  FALSE
           )
        {
            dwError = TW32( GetLastError() );
            BCATraceMsg( "LookupAccountName() failed while attempting to get the cluster account SID." );
            break;
        } // if: LookupAccountName failed
    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( dwError != ERROR_SUCCESS )
    {
        LogMsg( "Error %#08x occurred trying to validate the cluster service account. Cannot proceed.", dwError );
        BCATraceMsg1( "Error %#08x occurred trying to lookup the cluster service account. Throwing exception.", dwError );

        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_VALIDATING_ACCOUNT );
    } // if: we could not get the cluster account SID


    // Check if the installation state of the cluster binaries is correct.
    {
        eClusterInstallState    ecisInstallState;

        dwError = TW32( ClRtlGetClusterInstallState( NULL, &ecisInstallState ) );

        if ( dwError != ERROR_SUCCESS )
        {
            LogMsg( "Error %#08x occurred trying to get cluster installation state.", dwError );
            BCATraceMsg1( "Error %#08x occurred trying to get cluster installation state. Throwing exception.", dwError );

            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_GETTING_INSTALL_STATE );
        } // if: there was a problem getting the cluster installation state

        BCATraceMsg2(
              "Current install state = %d. Required %d."
            , ecisInstallState
            , eClusterInstallStateFilesCopied
            );

        //
        // The installation state should be that the binaries have been copied
        // but the cluster service has not been configured.
        //
        if ( ecisInstallState != eClusterInstallStateFilesCopied )
        {
            LogMsg( "The cluster installation state is set to %d. Expected %d. Cannot proceed.", ecisInstallState, eClusterInstallStateFilesCopied );
            BCATraceMsg1( "Cluster installation state is set to %d, which is incorrect. Throwing exception.", ecisInstallState );

            THROW_CONFIG_ERROR( HRESULT_FROM_WIN32( TW32( ERROR_INVALID_STATE ) ), IDS_ERROR_INCORRECT_INSTALL_STATE );
        } // if: the installation state is not correct

        LogMsg( "The cluster installation state is correct. Configuration can proceed." );
    }

    // Get the name and version information for this node.
    {
        m_dwComputerNameLen = sizeof( m_szComputerName );

        // Get the computer name.
        if ( GetComputerName( m_szComputerName, &m_dwComputerNameLen ) == FALSE )
        {
            dwError = TW32( GetLastError() );
            BCATraceMsg1( "GetComputerName() failed. Error code is %#08x. Throwing exception.", dwError );
            LogMsg( "Could not get the name of this computer. Error code is %#08x. Configuration cannot proceed.", dwError );
            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_GETTING_COMPUTER_NAME );
        } // if: GetComputerName() failed.

        m_dwNodeHighestVersion = CLUSTER_MAKE_VERSION( CLUSTER_INTERNAL_CURRENT_MAJOR_VERSION, VER_PRODUCTBUILD );
        m_dwNodeLowestVersion = CLUSTER_INTERNAL_PREVIOUS_HIGHEST_VERSION;

        BCATraceMsg4(
              "Computer Name = '%ws' (Length %d), NodeHighestVersion = %#08x, NodeLowestVersion = %#08x."
            , m_szComputerName
            , m_dwComputerNameLen
            , m_dwNodeHighestVersion
            , m_dwNodeLowestVersion
            );

        LogMsg(
              "Computer Name = '%ws' (Length %d), NodeHighestVersion = %#08x, NodeLowestVersion = %#08x."
            , m_szComputerName
            , m_dwComputerNameLen
            , m_dwNodeHighestVersion
            , m_dwNodeLowestVersion
            );
    }

} //***  CBaseClusterAddNode::CBaseClusterAddNode()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterAddNode::~CBaseClusterAddNode
//
//  Description:
//      Destructor of the CBaseClusterAddNode class
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusterAddNode::~CBaseClusterAddNode( void ) throw()
{
    BCATraceScope( "" );

} //*** CBaseClusterAddNode::~CBaseClusterAddNode()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterAddNode::SetClusterName
//
//  Description:
//      Set the name of the cluster being formed.
//
//  Arguments:
//      pszClusterNameIn    -- Name of the cluster.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterAddNode::SetClusterName(
    LPCWSTR pszClusterNameIn
    )
{
    BCATraceScope( "" );

    BOOL    fSuccess;
    DWORD   dwError;
    WCHAR   szClusterNetBIOSName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD   nSize = sizeof( szClusterNetBIOSName ) / sizeof( szClusterNetBIOSName[ 0 ] );

    m_strClusterName = pszClusterNameIn;

    fSuccess = DnsHostnameToComputerNameW(
                      pszClusterNameIn
                    , szClusterNetBIOSName
                    , &nSize
                    );
    if ( ! fSuccess )
    {
        dwError = TW32( GetLastError() );
        LogMsg( "Error %#08x occurred trying to convert the cluster name '%ls' to a NetBIOS name.", dwError, pszClusterNameIn );
        BCATraceMsg2( "Error %#08x occurred trying to convert the cluster name '%ls' to a NetBIOS name. Throwing exception.", dwError, pszClusterNameIn );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_CVT_CLUSTER_NAME );
    }

    m_strClusterNetBIOSName = szClusterNetBIOSName;

} //*** CBaseClusterAddNode::SetClusterName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cbaseclusteraction.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CBaseClusterAction.h
//
//  Description:
//      Header file for CBaseClusterAction class.
//
//      The CBaseClusterAction class is the base class for the other
//      base cluster action classes. The base cluster actions are forming a
//      cluster, joining a cluster, upgrade support and cleanup.
//
//      For each base cluster action, there is a class derived from this
//      class that performs the desired action. This class encapsulates
//      what is common to these actions.
//
//  Implementation Files:
//      CBaseClusterAction.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For MAX_PATH
#include <windows.h>

// For the CAction base class
#include "CAction.h"

// For the CActionList base class
#include "CActionList.h"

// For a few common definitions
#include "CommonDefs.h"

// For HINF, SetupCloseInfFile, etc.
#include <setupapi.h>

// For the CStr class.
#include "CStr.h"


//////////////////////////////////////////////////////////////////////////
// Forward declarations.
//////////////////////////////////////////////////////////////////////////

class CBCAInterface;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CBaseClusterAction
//
//  Description:
//      The CBaseClusterAction class is the base class for the other
//      base cluster action classes. The base cluster actions are forming a
//      cluster, joining a cluster, upgrade support and cleanup.
//
//      For each base cluster action, there is a class derived from this
//      class that performs the desired action. This class encapsulates
//      what is common to these actions.
//
//      An object of this class is intended for one time use only. That is,
//      after an object has been committed, it cannot be re-committed.
//
//      This class is intended to be used as a base class only. Therefore,
//      its constructors and destructors are protected
//
//--
//////////////////////////////////////////////////////////////////////////////
class CBaseClusterAction : public CAction
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Default destructor.
    virtual ~CBaseClusterAction() throw();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Base class method.
    // Commit this action. This method has to be durable and consistent. It shoud
    // try as far as possible to be atomic.
    //
    void Commit();

    //
    // Base class method.
    // Rollback this action. Be careful about throwing exceptions from this method
    // as a stack unwind might be in progress when this method is called.
    //
    void Rollback();


    //////////////////////////////////////////////////////////////////////////
    // Public accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the type of this action.
    EBaseConfigAction
        EbcaGetAction() const throw()
    {
        return m_ebcaAction;
    }

    // Get the cluster installation directory.
    const CStr &
        RStrGetClusterInstallDirectory() const throw()
    {
        return m_strClusterInstallDir;
    }

    // Get the localquorum directory.
    const CStr &
        RStrGetLocalQuorumDirectory() const throw()
    {
        return m_strLocalQuorumDir;
    }

    // Get the handle to the main INF file.
    HINF
        HGetMainInfFileHandle() const throw()
    {
        return m_sihMainInfFile;
    }

    // Get the name of the main INF file.
    const CStr &
        RStrGetMainInfFileName() const throw()
    {
        return m_strMainInfFileName;
    }

    // Get the handle to the SC Manager.
    SC_HANDLE
        HGetSCMHandle() const throw()
    {
        return m_sscmhSCMHandle;
    }

    // Get the interface pointer.
    CBCAInterface *
        PBcaiGetInterfacePointer() const throw() 
    {
        return m_pbcaiInterface;
    }


    //////////////////////////////////////////////////////////////////////////
    // Public member functions
    //////////////////////////////////////////////////////////////////////////

    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        //
        // The maximum progress ticks for this object comprises of:
        // - m_alActionList.UiGetMaxProgressTicks() => The progress ticks of
        //   the contained action objects.
        return m_alActionList.UiGetMaxProgressTicks();
    }


protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    //
    // Default constructor.
    // Reads the location of the cluster binaries from the registry,
    // opens the INF file, etc.
    //
    CBaseClusterAction( CBCAInterface * pbcaiInterfaceIn );


    //////////////////////////////////////////////////////////////////////////
    // Protected accessors
    //////////////////////////////////////////////////////////////////////////

    // Set the type of action being performed by this object.
    void
        SetAction( EBaseConfigAction ebcaAction )
    {
        m_ebcaAction = ebcaAction;
    }

    // Allow derived classes to modify this action list.
    CActionList &
        RalGetActionList() throw()
    {
        return m_alActionList;
    }

    // Associate a particular directory with an id in the main INF file.
    void
        SetDirectoryId( const WCHAR * pcszDirectoryNameIn, UINT uiIdIn );


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////

    // Class used to automatically release a semaphore.
    class CSemaphoreHandleTrait
    {
    public:
        //////////////////////////////////////////////////////////////////////////
        // Public types
        //////////////////////////////////////////////////////////////////////////
        typedef HANDLE ResourceType;


        //////////////////////////////////////////////////////////////////////////
        // Public methods
        //////////////////////////////////////////////////////////////////////////

        // A routine used to close a handle.
        static void CloseRoutine( ResourceType hResourceIn )
        {
            ReleaseSemaphore( hResourceIn, 1, NULL );
        } //*** CloseRoutine()

        // Get the null value for this type.
        static ResourceType HGetNullValue()
        {
            return NULL;
        } //*** HGetNullValue()

    }; //*** class CSemaphoreHandleTrait

    // A class that automatically releases a signalled semaphore.
    typedef CSmartResource< CSemaphoreHandleTrait > SmartSemaphoreLock;

    // The base class for this class.
    typedef CAction BaseClass;

    // A smart INF file handle.
    typedef CSmartResource<
        CHandleTrait<
              HINF 
            , VOID
            , SetupCloseInfFile
            , INVALID_HANDLE_VALUE
            >
        >
        SmartInfHandle;

    // Smart semaphore type
    typedef CSmartResource< CHandleTrait< HANDLE, BOOL, CloseHandle > > SmartSemaphoreHandle;


    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CBaseClusterAction( const CBaseClusterAction & );

    // Assignment operator
    const CBaseClusterAction & operator =( const CBaseClusterAction & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Pointer to the interface class.
    CBCAInterface *         m_pbcaiInterface;

    // Action to be performed.
    EBaseConfigAction       m_ebcaAction;

    // The list of actions to be performed by this action.
    CActionList             m_alActionList;

    // The installation directory of the cluster binaries.
    CStr                    m_strClusterInstallDir;

    // The directory used to store the localquorum files.
    CStr                    m_strLocalQuorumDir;

    // Name of the main INF file.
    CStr                    m_strMainInfFileName;

    // A handle to the main INF file.
    SmartInfHandle          m_sihMainInfFile;

    // A semaphore used to ensure that only one configuration is in progress.
    SmartSemaphoreHandle     m_sshConfigSemaphoreHandle;

    // A smart handle to the Service Control Manager.
    SmartSCMHandle          m_sscmhSCMHandle;

}; //*** class CBaseClusterAction
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cbaseclustercleanup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CBaseClusterCleanup.h
//
//  Description:
//      Header file for CBaseClusterCleanup class.
//
//      The CBaseClusterCleanup class is a class that encapsulates the
//      cleanup of a node after it has been evicted from a cluster.
//
//  Implementation Files:
//      CBaseClusterCleanup.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 29-APR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the base class of this class.
#include "CBaseClusterAction.h"

// For the CStr class.
#include "CStr.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CBaseClusterCleanup
//
//  Description:
//      The CBaseClusterCleanup class is a class that encapsulates the
//      cleanup of a node after it has been evicted from a cluster.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CBaseClusterCleanup : public CBaseClusterAction
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CBaseClusterCleanup(
          CBCAInterface *   pbcaiInterfaceIn
        );

    // Default destructor.
    ~CBaseClusterCleanup() throw();


    //////////////////////////////////////////////////////////////////////////
    // Public member functions
    //////////////////////////////////////////////////////////////////////////

    // Cleanup this node.
    void 
        Commit();

    // Rolling back a cleanup operation.
    void 
        Rollback();


    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        return BaseClass::UiGetMaxProgressTicks();
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CBaseClusterAction BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

}; //*** class CBaseClusterCleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cbaseclustercleanup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CBaseClusterCleanup.cpp
//
//  Description:
//      Contains the definition of the CBaseClusterCleanup class.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 30-APR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// For ClRtlGetClusterInstallState()
#include "clusrtl.h"

// The header file of this class.
#include "CBaseClusterCleanup.h"

// For the CBCAInterface class.
#include "CBCAInterface.h"

// For the CClusSvcCleanup action
#include "CClusSvcCleanup.h"

// For the CClusDBCleanup action
#include "CClusDBCleanup.h"

// For the CClusDiskCleanup action
#include "CClusDiskCleanup.h"

// For the CClusNetCleanup action
#include "CClusNetCleanup.h"

// For the CNodeCleanup action
#include "CNodeCleanup.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterCleanup::CBaseClusterCleanup
//
//  Description:
//      Constructor of the CBaseClusterCleanup class.
//
//      This function also stores the parameters that are required for
//      cluster cleanup.
//
//      This function also checks if the computer is in the correct state
//      for cleanup.
//
//  Arguments:
//      pbcaiInterfaceIn
//          Pointer to the interface class for this library.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CConfigError
//          If the OS version is incorrect or if the installation state.
//
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusterCleanup::CBaseClusterCleanup(
      CBCAInterface *   pbcaiInterfaceIn
    )
    : BaseClass( pbcaiInterfaceIn )
{
    BCATraceScope( "" );
    LogMsg( "The current cluster configuration task is: Node Cleanup." );

    // Check if the installation state of the cluster binaries is correct.
    {
        eClusterInstallState    ecisInstallState;

        DWORD dwError = TW32( ClRtlGetClusterInstallState( NULL, &ecisInstallState ) );

        if ( dwError != ERROR_SUCCESS )
        {
            LogMsg( "Error %#x occurred trying to get cluster installation state.", dwError );
            BCATraceMsg1( "Error %#x occurred trying to get cluster installation state. Throwing exception.", dwError );

            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_GETTING_INSTALL_STATE );
        } // if: there was a problem getting the cluster installation state

        BCATraceMsg3( 
              "Current install state = %d. Required %d or %d."
            , ecisInstallState
            , eClusterInstallStateConfigured
            , eClusterInstallStateUpgraded
            );
        
        //
        // The installation state for this node to be cleaned up should be that the cluster service
        // has been configured or that it has been upgraded.
        //
        if ( ( ecisInstallState != eClusterInstallStateConfigured ) && ( ecisInstallState != eClusterInstallStateUpgraded ) )
        {
            LogMsg( "The cluster installation state is set to %d. Expected %d or %d. Cannot proceed.", ecisInstallState, eClusterInstallStateConfigured, eClusterInstallStateUpgraded );
            BCATraceMsg1( "Cluster installation state is set to %d, which is incorrect. Throwing exception.", ecisInstallState );

            THROW_CONFIG_ERROR( HRESULT_FROM_WIN32( TW32( ERROR_INVALID_STATE ) ), IDS_ERROR_INCORRECT_INSTALL_STATE );
        } // if: the installation state is not correct

        LogMsg( "The cluster installation state is correct. Configuration can proceed." );
    }

    //
    // Create a list of actions to be performed.
    // The order of appending actions is significant.
    //

    // Add the action to clean up the ClusNet service. 
    // The ClusNet service depends on the ClusSvc service and therefore cannot be 
    // stopped if the ClusSvc service is running. So, the ClusSvc service should not be
    // running when the Commit() method of this class is called.
    RalGetActionList().AppendAction( new CClusNetCleanup( this ) );

    // Add the action to clean up the ClusDisk service.
    RalGetActionList().AppendAction( new CClusDiskCleanup( this ) );

    // Add the action to clean up the cluster database.
    RalGetActionList().AppendAction( new CClusDBCleanup( this ) );

    // Add the action to clean up miscellenous actions we performed when this node joined the cluster.
    RalGetActionList().AppendAction( new CNodeCleanup( this ) );

    // Add the action to clean up the cluster service. Clean this up last for two reasons:
    // 1. The install state is changed by this action.
    // 2. If cleanup aborted for some reason and the cluster service is not deleted, it will
    //    reinitiate cleanup the next time it starts.
    RalGetActionList().AppendAction( new CClusSvcCleanup( this ) );


    // Indicate if this action can be rolled back or not.
    SetRollbackPossible( RalGetActionList().FIsRollbackPossible() );

    // Indicate that a node should be cleaned up during commit.
    SetAction( eCONFIG_ACTION_CLEANUP );

    LogMsg( "Initialization for node cleanup complete." );

} //***  CBaseClusterCleanup::CBaseClusterCleanup()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterCleanup::~CBaseClusterCleanup
//
//  Description:
//      Destructor of the CBaseClusterCleanup class
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusterCleanup::~CBaseClusterCleanup( void ) throw()
{
    BCATraceScope( "" );

} //*** CBaseClusterCleanup::~CBaseClusterCleanup()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CBaseClusterCleanup::Commit
//
//  Description:
//      Clean up this node. This function cannot be called when the cluster
//      service is running.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any exceptions thrown by functions called.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterCleanup::Commit( void )
{
    BCATraceScope( "" );

    LogMsg( "Initiating cluster node cleanup." );

    // Call the base class commit routine. This commits the action list.
    BaseClass::Commit();

    // If we are here, then everything went well.
    SetCommitCompleted( true );

} //*** CBaseClusterCleanup::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CBaseClusterCleanup::Rollback
//
//  Description:
//      Performs the rolls back of the action committed by this object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by functions called.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterCleanup::Rollback( void )
{
    BCATraceScope( "" );

    // Rollback the actions.
    BaseClass::Rollback();

    SetCommitCompleted( false );

} //*** CBaseClusterCleanup::Rollback()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cbaseclusterform.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CBaseClusterForm.cpp
//
//  Description:
//      Contains the definition of the CBaseClusterForm class.
//
//  Documentation:
//      TODO: Add pointer to external documentation later.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header file of this class.
#include "CBaseClusterForm.h"

// For the CClusSvcAccountConfig action
#include "CClusSvcAccountConfig.h"

// For the CClusNetCreate action
#include "CClusNetCreate.h"

// For the CClusDiskForm action
#include "CClusDiskForm.h"

// For the CClusDBForm action
#include "CClusDBForm.h"

// For the CClusSvcCreate action
#include "CClusSvcCreate.h"

// For the CNodeConfig action
#include "CNodeConfig.h"


//////////////////////////////////////////////////////////////////////////
// Macros definitions
//////////////////////////////////////////////////////////////////////////

// The minimum amount of free space in bytes, required by the
// localquorum resource (5 Mb)
#define LOCALQUORUM_MIN_FREE_DISK_SPACE 5242880

// Name of the file system required by the local quorum resource
#define LOCALQUORUM_FILE_SYSTEM L"NTFS"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterForm::CBaseClusterForm
//
//  Description:
//      Constructor of the CBaseClusterForm class.
//
//      This function also stores the parameters that are required for
//      cluster formation.
//
//  Arguments:
//      pbcaiInterfaceIn
//          Pointer to the interface class for this library.
//
//      pszClusterNameIn
//          Name of the cluster to be formed.
//
//      pszClusterAccountNameIn
//      pszClusterAccountPwdIn
//      pszClusterAccountDomainIn
//          Specifies the account to be used as the cluster service account.
//
//      dwClusterIPAddressIn
//      dwClusterIPSubnetMaskIn
//      pszClusterIPNetworkIn
//          Specifies the IP address and network of the cluster IP address.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CConfigError
//          If the OS version is incorrect or if the installation state
//          of the cluster binaries is wrong.
//
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusterForm::CBaseClusterForm(
      CBCAInterface *   pbcaiInterfaceIn
    , const WCHAR *     pcszClusterNameIn
    , const WCHAR *     pszClusterBindingStringIn
    , const WCHAR *     pcszClusterAccountNameIn
    , const WCHAR *     pcszClusterAccountPwdIn
    , const WCHAR *     pcszClusterAccountDomainIn
    , DWORD             dwClusterIPAddressIn
    , DWORD             dwClusterIPSubnetMaskIn
    , const WCHAR *     pszClusterIPNetworkIn
    )
    : BaseClass(
            pbcaiInterfaceIn
          , pcszClusterNameIn
          , pszClusterBindingStringIn
          , pcszClusterAccountNameIn
          , pcszClusterAccountPwdIn
          , pcszClusterAccountDomainIn
          )
    , m_dwClusterIPAddress( dwClusterIPAddressIn )
    , m_dwClusterIPSubnetMask( dwClusterIPSubnetMaskIn )
    , m_strClusterIPNetwork( pszClusterIPNetworkIn )

{
    BCATraceScope( "" );
    LogMsg( "The current cluster configuration task is: Cluster Formation." );

    CStatusReport   srInitForm(
          PBcaiGetInterfacePointer()
        , TASKID_Major_Configure_Cluster_Services
        , TASKID_Minor_Initializing_Cluster_Form
        , 0, 1
        , IDS_TASK_FORM_INIT
        );

    // Send the next step of this status report.
    srInitForm.SendNextStep( S_OK );

    //
    // Write parameters to log file.
    //
    LogMsg(
          "Cluster IP Address       => %d.%d.%d.%d"
        , ( m_dwClusterIPAddress & 0x000000FF )
        , ( m_dwClusterIPAddress & 0x0000FF00 ) >> 8
        , ( m_dwClusterIPAddress & 0x00FF0000 ) >> 16
        , ( m_dwClusterIPAddress & 0xFF000000 ) >> 24
        );

    LogMsg(
          "Subnet Mask              => %d.%d.%d.%d"
        , ( m_dwClusterIPSubnetMask & 0x000000FF )
        , ( m_dwClusterIPSubnetMask & 0x0000FF00 ) >> 8
        , ( m_dwClusterIPSubnetMask & 0x00FF0000 ) >> 16
        , ( m_dwClusterIPSubnetMask & 0xFF000000 ) >> 24
        );

    LogMsg( "Cluster IP Network name => '%s'", m_strClusterIPNetwork.PszData() );


    //
    // Perform a sanity check on the parameters used by this class
    //
    if ( ( pszClusterIPNetworkIn == NULL ) || ( *pszClusterIPNetworkIn == L'\0'  ) )
    {
        BCATraceMsg( "The cluster IP Network name is empty. Throwing exception." );
        LogMsg( "The cluster IP Network name is invalid." );
        THROW_CONFIG_ERROR( THR( E_INVALIDARG ), IDS_ERROR_INVALID_IP_NET );
    } // if: the cluster IP network name is empty


    //
    // Make sure that there is enough free space under the cluster directory.
    // The quorum logs for the localquorum resource will be under this directory.
    //
    {
        BOOL            fSuccess;
        ULARGE_INTEGER  uliFreeBytesAvailToUser;
        ULARGE_INTEGER  uliTotalBytes;
        ULARGE_INTEGER  uliTotalFree;
        ULARGE_INTEGER  uliRequired;

        uliRequired.QuadPart = LOCALQUORUM_MIN_FREE_DISK_SPACE;

        fSuccess = GetDiskFreeSpaceEx(
              RStrGetClusterInstallDirectory().PszData()
            , &uliFreeBytesAvailToUser
            , &uliTotalBytes
            , &uliTotalFree
            );

        if ( fSuccess == 0 )
        {
            DWORD dwError = TW32( GetLastError() );

            LogMsg( "Error %#08x occurred trying to get free disk space.", dwError );
            BCATraceMsg1( "Error %#08x occurred trying to get free disk space. Throwing exception.", dwError );

            THROW_RUNTIME_ERROR(
                  HRESULT_FROM_WIN32( dwError )
                , IDS_ERROR_GETTING_FREE_DISK_SPACE
                );
        } // if: GetDiskFreeSpaceEx failed

        LogMsg(
              "Free space required = %#x%08x bytes. Available = %#x%08x bytes."
            , uliRequired.HighPart
            , uliRequired.LowPart
            , uliFreeBytesAvailToUser.HighPart
            , uliFreeBytesAvailToUser.LowPart
            );

        if ( uliFreeBytesAvailToUser.QuadPart < uliRequired.QuadPart )
        {
            LogMsg( "There isn't enough free space for the localquorum resource. Form cannot proceed." );
            BCATraceMsg( "There isn't enough free space for the localquorum resource. Throwing exception." );

            THROW_CONFIG_ERROR(
                  HRESULT_FROM_WIN32( THR( ERROR_DISK_FULL ) )
                , IDS_ERROR_INSUFFICIENT_DISK_SPACE
                );
        } // if: there isn't enough free space for localquorum.

        LogMsg( "There is enough free space for the localquorum resource. Form can proceed." );
    }

/*
//
// KB: Vij Vasu (VVasu) 07-SEP-2000. Localquorum no longer needs NTFS disks
// The code below has been commented out since it is no longer required that
// localquorum resources use NTFS disks. This was confirmed by SunitaS.
//

    //
    // Make sure that the drive on which the cluster binaries are installed has NTFS
    // on it. This is required by the localquorum resource.
    //
    {
        WCHAR   szVolumePathName[ MAX_PATH ];
        WCHAR   szFileSystemName[ MAX_PATH ];
        BOOL    fSuccess;

        fSuccess = GetVolumePathName(
              RStrGetClusterInstallDirectory().PszData()
            , szVolumePathName
            , sizeof( szVolumePathName ) / sizeof( szVolumePathName[ 0 ] )
            );

        if ( fSuccess == 0 )
        {
            DWORD dwError = TW32( GetLastError() );

            LogMsg( "Error %#08x occurred trying to get file system type. Form cannot proceed.", dwError );
            BCATraceMsg1( "Error %#08x occurred trying to get file system type. Throwing exception.", dwError );

            THROW_RUNTIME_ERROR(
                  HRESULT_FROM_WIN32( dwError )
                , IDS_ERROR_GETTING_FILE_SYSTEM
                );
        } // if: GetVolumePathName failed

        BCATraceMsg1( "The volume path name of the disk on which the cluster binaries reside is '%ws'.", szVolumePathName );

        fSuccess = GetVolumeInformation(
                      szVolumePathName                                                  // root directory
                    , NULL                                                              // volume name buffer
                    , 0                                                                 // length of name buffer
                    , NULL                                                              // volume serial number
                    , NULL                                                              // maximum file name length
                    , NULL                                                              // file system options
                    , szFileSystemName                                                  // file system name buffer
                    , sizeof( szFileSystemName ) / sizeof( szFileSystemName[ 0 ] )      // length of file system name buffer
                    );

        if ( fSuccess == 0 )
        {
            DWORD dwError = TW32( GetLastError() );

            LogMsg( "Error %#08x occurred trying to get file system type. Form cannot proceed.", dwError );
            BCATraceMsg1( "Error %#08x occurred trying to get file system type. Throwing exception.", dwError );

            THROW_RUNTIME_ERROR(
                  HRESULT_FROM_WIN32( dwError )
                , IDS_ERROR_GETTING_FILE_SYSTEM
                );
        } // if: GetVolumeInformation failed

        BCATraceMsg3(
              "The file system on '%ws' is '%ws'. Required file system is '%s'."
            , szVolumePathName
            , szFileSystemName
            , LOCALQUORUM_FILE_SYSTEM
            );


        if ( _wcsicmp( szFileSystemName, LOCALQUORUM_FILE_SYSTEM ) != 0 )
        {
            LogMsg( "LocalQuorum resource cannot be created on non-NTFS disk '%ws'. Form cannot proceed.", szVolumePathName );
            BCATraceMsg1( "LocalQuorum resource cannot be created on non-NTFS disk '%ws'. Throwing exception.", szVolumePathName );

            // MUSTDO - must define proper HRESULT for this error. ( Vvasu - 10 Mar 2000 )
            THROW_CONFIG_ERROR(
                  HRESULT_FROM_WIN32( TW32( ERROR_UNRECOGNIZED_MEDIA ) )
                , IDS_ERROR_INCORRECT_INSTALL_STATE
                );
        } // if: the file system is not correct.

        LogMsg( "LocalQuorum resource will be created on disk '%ws'. Form can proceed.", szVolumePathName );
    }
*/

    //
    // Create a list of actions to be performed.
    // The order of appending actions is significant.
    //

    // Add the action to configure the cluster service account.
    RalGetActionList().AppendAction( new CClusSvcAccountConfig( this ) );

    // Add the action to create the ClusNet service.
    RalGetActionList().AppendAction( new CClusNetCreate( this ) );

    // Add the action to create the ClusDisk service.
    RalGetActionList().AppendAction( new CClusDiskForm( this ) );

    // Add the action to create the cluster database.
    RalGetActionList().AppendAction( new CClusDBForm( this ) );

    // Add the action to create the ClusSvc service.
    RalGetActionList().AppendAction( new CClusSvcCreate( this ) );

    // Add the action to perform miscellaneous tasks.
    RalGetActionList().AppendAction( new CNodeConfig( this ) );


    // Indicate if rollback is possible or not.
    SetRollbackPossible( RalGetActionList().FIsRollbackPossible() );

    // Indicate that a cluster should be formed during commit.
    SetAction( eCONFIG_ACTION_FORM );

    // Send the last step of a status report.
    srInitForm.SendNextStep( S_OK );

    LogMsg( "Initialization for cluster formation complete." );

} //***  CBaseClusterForm::CBaseClusterForm()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterForm::~CBaseClusterForm
//
//  Description:
//      Destructor of the CBaseClusterForm class
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusterForm::~CBaseClusterForm( void ) throw()
{
    BCATraceScope( "" );

} //*** CBaseClusterForm::~CBaseClusterForm()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CBaseClusterForm::Commit
//
//  Description:
//      Form the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any exceptions thrown by functions called.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterForm::Commit( void )
{
    BCATraceScope( "" );

    CStatusReport srFormingCluster(
          PBcaiGetInterfacePointer()
        , TASKID_Major_Configure_Cluster_Services
        , TASKID_Minor_Forming_Node
        , 0, 1
        , IDS_TASK_FORMING_CLUSTER
        );

    LogMsg( "Initiating cluster formation." );

    // Send the next step of this status report.
    srFormingCluster.SendNextStep( S_OK );

    // Call the base class commit routine. This commits the action list.
    BaseClass::Commit();

    // If we are here, then everything went well.
    SetCommitCompleted( true );

    // Send the last step of this status report.
    srFormingCluster.SendNextStep( S_OK );

} //*** CBaseClusterForm::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CBaseClusterForm::Rollback
//
//  Description:
//      Performs the rolls back of the action committed by this object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by functions called.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterForm::Rollback( void )
{
    BCATraceScope( "" );

    // Rollback the actions.
    BaseClass::Rollback();

    SetCommitCompleted( false );

} //*** CBaseClusterForm::Rollback()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cbaseclusterform.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CBaseClusterForm.h
//
//  Description:
//      Header file for CBaseClusterForm class.
//
//      The CBaseClusterForm class is a class that encapsulates the
//      formation of a cluster.
//
//  Implementation Files:
//      CBaseClusterForm.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the base class of this class.
#include "CBaseClusterAddNode.h"

// For ClusterMinNodeIdString
#include <clusdef.h>

// For the CStr class.
#include "CStr.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CBaseClusterForm
//
//  Description:
//      The CBaseClusterForm class is a class that encapsulates the
//      formation of a cluster.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CBaseClusterForm : public CBaseClusterAddNode
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CBaseClusterForm(
          CBCAInterface *   pbcaiInterfaceIn
        , const WCHAR *     pcszClusterNameIn
        , const WCHAR *     pcszClusterBindingStringIn
        , const WCHAR *     pcszClusterAccountNameIn
        , const WCHAR *     pcszClusterAccountPwdIn
        , const WCHAR *     pcszClusterAccountDomainIn
        , DWORD             dwClusterIPAddressIn
        , DWORD             dwClusterIPSubnetMaskIn
        , const WCHAR *     pszClusterIPNetworkIn
        );

    // Default destructor.
    ~CBaseClusterForm( void ) throw();


    //////////////////////////////////////////////////////////////////////////
    // Public accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the cluster IP address.
    DWORD
        DwGetIPAddress( void ) const throw() { return m_dwClusterIPAddress; }

    // Get the cluster IP subnet mask.
    DWORD
        DwGetIPSubnetMask( void ) const throw() { return m_dwClusterIPSubnetMask; }

    // Get the network used for the cluster IP address
    const CStr &
        RStrGetClusterIPNetwork( void ) const throw() { return m_strClusterIPNetwork; }

    // Get the NodeId of this node.
    virtual const WCHAR *
        PszGetNodeIdString( void ) const throw() { return ClusterMinNodeIdString; }


    //////////////////////////////////////////////////////////////////////////
    // Public member functions
    //////////////////////////////////////////////////////////////////////////

    // Form the cluster.
    void
        Commit( void );

    // Rollback a created cluster.
    void
        Rollback( void );

    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        // The extra tick if for the "Form starting" notification.
        return BaseClass::UiGetMaxProgressTicks() + 1;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CBaseClusterAddNode BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Cluster IP address and network information.
    DWORD                   m_dwClusterIPAddress;
    DWORD                   m_dwClusterIPSubnetMask;
    CStr                    m_strClusterIPNetwork;

}; //*** class CBaseClusterForm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cbaseclusteraddnode.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CBaseClusterAddNode.h
//
//  Description:
//      Header file for CBaseClusterAddNode class.
//
//      The CBaseClusterAddNode class is a class that captures the commonality
//      between forming and joining a cluster.
//
//  Implementation Files:
//      CBaseClusterAddNode.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the base class of this class.
#include "CBaseClusterAction.h"

// For LsaClose, LSA_HANDLE, etc.
#include <ntsecapi.h>

// For the CStr class.
#include "CStr.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CBaseClusterAddNode
//
//  Description:
//      The CBaseClusterAddNode class is a class that captures the commonality
//      between forming and joining a cluster.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CBaseClusterAddNode : public CBaseClusterAction
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the name of the cluster being formed or joined.
    const CStr &
        RStrGetClusterName( void ) const throw() { return m_strClusterName; }

    // Get the NetBIOS name of the cluster being formed or joined.
    const CStr &
        RStrGetClusterNetBIOSName( void ) const throw() { return m_strClusterNetBIOSName; }

    // Get the name of this node.
    const WCHAR *
        PszGetNodeName( void ) const throw() { return m_szComputerName; }

    // Get the length of the name of this node..
    DWORD
        DwGetNodeNameLength( void ) const throw() { return m_dwComputerNameLen; }

    // Get the node highest version.
    DWORD
        DwGetNodeHighestVersion( void ) const throw() { return m_dwNodeHighestVersion; }

    // Get the node lowest version.
    DWORD
        DwGetNodeLowestVersion( void ) const throw() { return m_dwNodeLowestVersion; }

    // Get the cluster service account name.
    const CStr &
        RStrGetServiceAccountName( void ) const throw() { return m_strClusterAccountName; }

    // Get the cluster service account domain.
    const CStr &
        RStrGetServiceAccountDomain( void ) const throw() { return m_strClusterAccountDomain; }

    // Get the cluster service domain account
    const CStr &
        RStrGetServiceDomainAccountName( void ) const throw() { return m_strClusterDomainAccount; }

    // Get the cluster service account password.
    const CStr &
        RStrGetServiceAccountPassword( void ) const throw() { return m_strClusterAccountPwd; }

    // Get the cluster binding string.
    const CStr &
        RStrGetClusterBindingString( void ) const throw() { return m_strClusterBindingString; }

    // Get the SID of the cluster service account.
    SID *
        PSidGetServiceAccountSID( void ) const throw() { return m_sspClusterAccountSid.PMem(); }

    // Get the LSA policy handle.
    LSA_HANDLE
        HGetLSAPolicyHandle( void ) const throw() { return m_slsahPolicyHandle.HHandle(); }

    // Get the NodeId of this node.
    virtual const WCHAR *
        PszGetNodeIdString( void ) const throw() = 0;

    // Indicates if version checking is disabled or not.
    bool
        FIsVersionCheckingDisabled( void ) const throw() { return m_fIsVersionCheckingDisabled; }


protected:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CBaseClusterAddNode(
          CBCAInterface * pbcaiInterfaceIn
        , const WCHAR *     pcszClusterNameIn
        , const WCHAR *     pszClusterBindingStringIn
        , const WCHAR *     pcszClusterAccountNameIn
        , const WCHAR *     pcszClusterAccountPwdIn
        , const WCHAR *     pcszClusterAccountDomainIn
        );

    // Default destructor.
    ~CBaseClusterAddNode( void ) throw();


    //////////////////////////////////////////////////////////////////////////
    // Protected accessors
    //////////////////////////////////////////////////////////////////////////

    // Set the name of the cluster being formed.
    void
        SetClusterName( const WCHAR * pszClusterNameIn );

    // Set the cluster service account name.
    void
        SetServiceAccountName( const WCHAR * pszClusterAccountNameIn )
    {
        m_strClusterAccountName = pszClusterAccountNameIn;
    }

    // Set the cluster service account domain.
    void
        SetServiceAccountDomain( const WCHAR * pszClusterAccountDomainIn )
    {
        m_strClusterAccountDomain = pszClusterAccountDomainIn;
    }

    // Set the cluster service account password.
    void
        SetServiceAccountPassword( const WCHAR * pszClusterAccountPwdIn )
    {
        m_strClusterAccountPwd = pszClusterAccountPwdIn;
    }

    void
        SetVersionCheckingDisabled( bool fDisabledIn = true )
    {
        m_fIsVersionCheckingDisabled = fDisabledIn;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CBaseClusterAction  BaseClass;

    typedef CSmartGenericPtr< CPtrTrait< SID > >  SmartSIDPtr;

    typedef CSmartResource<
        CHandleTrait<
              LSA_HANDLE
            , NTSTATUS
            , LsaClose
            >
        >
        SmartLSAHandle;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Name of the cluster
    CStr                    m_strClusterName;
    CStr                    m_strClusterNetBIOSName;

    // Name and version information of this computer
    WCHAR                   m_szComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD                   m_dwComputerNameLen;
    DWORD                   m_dwNodeHighestVersion;
    DWORD                   m_dwNodeLowestVersion;
    bool                    m_fIsVersionCheckingDisabled;

    // Cluster service account information.
    CStr                    m_strClusterAccountName;
    CStr                    m_strClusterAccountPwd;
    CStr                    m_strClusterAccountDomain;
    CStr                    m_strClusterDomainAccount;
    CStr                    m_strClusterBindingString;
    SmartSIDPtr             m_sspClusterAccountSid;

    // Smart handle to the LSA policy.
    SmartLSAHandle          m_slsahPolicyHandle;

}; //*** class CBaseClusterAddNode
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cbcainterface.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CBCAInterface.cpp
//
//  Description:
//      This file contains the implementation of the CBCAInterface
//      class.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Header File:
//      CBCAInterface.h
//
//  Maintained By:
//      Vij Vasu (VVasu) 07-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "pch.h"

// The header file for this class
#include "CBCAInterface.h"

// For TraceInterface
#include "CITracker.h"

// Needed by Dll.h
#include "CFactory.h"

// For g_cObjects
#include "Dll.h"

// For the CBaseClusterForm class
#include "CBaseClusterForm.h"

// For the CBaseClusterJoin class
#include "CBaseClusterJoin.h"

// For the CBaseClusterCleanup class
#include "CBaseClusterCleanup.h"

// For the exception classes
#include "Exceptions.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CBCAInterface" );


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::CBCAInterface( void )
//
//  Description:
//      Constructor of the CBCAInterface class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBCAInterface::CBCAInterface( void )
    : m_cRef( 1 )
    , m_fCommitComplete( false )
    , m_fRollbackPossible( false )
    , m_lcid( LOCALE_SYSTEM_DEFAULT )
    , m_fCallbackSupported( false )
{
    BCATraceScope( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    BCATraceMsg1( "Component count = %d.", g_cObjects );

} //*** CBCAInterface::CBCAInterface


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::~CBCAInterface( void)
//
//  Description:
//      Destructor of the CBCAInterface class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBCAInterface::~CBCAInterface( void )
{
    BCATraceScope( "" );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    BCATraceMsg1( "Component count = %d.", g_cObjects );

} //*** CBCAInterface::~CBCAInterface


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CBCAInterface::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//  Description:
//      Creates a CBCAInterface instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CBCAInterface::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    BCATraceScope( "" );

    HRESULT hr = E_INVALIDARG;

    CBCAInterface *     pbcaInterface;

    pbcaInterface = new CBCAInterface();
    if ( pbcaInterface != NULL )
    {
        hr = THR(
                pbcaInterface->QueryInterface(
                      IID_IUnknown
                    , reinterpret_cast< void ** >( ppunkOut )
                    )
                );

        pbcaInterface->Release( );

    } // if: error allocating object
    else
    {
        hr = THR( E_OUTOFMEMORY );

    } // else: out of memory

    BCATraceMsg1( "*ppunkOut = %p.", *ppunkOut );

    BCATraceMsg1( "hr = %#08x", hr );
    return hr;

} //*** CBCAInterface::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CBCAInterface::AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CBCAInterface::AddRef( void )
{
    BCATraceScope( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    BCATraceMsg1( "m_cRef = %d", m_cRef );

    return m_cRef;

} //*** CBCAInterface::AddRef()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CBCAInterface::Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CBCAInterface::Release( void )
{
    BCATraceScope( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    BCATraceMsg1( "m_cRef = %d", m_cRef );

    if ( m_cRef == 0 )
    {
        TraceDo( delete this );
        return 0;
    } // if: reference count decremented to zero

    return m_cRef;

} //*** CBCAInterface::Release()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CBCAInterface::QueryInterface()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      IN  REFIID  riidIn,
//          Id of interface requested.
//
//      OUT void ** ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBCAInterface::QueryInterface( REFIID riidIn, void ** ppvOut )
{
    BCATraceQIScope( riidIn, ppvOut );

    HRESULT hr = S_OK;

    if ( ppvOut != NULL )
    {
        if ( IsEqualIID( riidIn, IID_IUnknown ) )
        {
            *ppvOut = static_cast< IClusCfgBaseCluster * >( this );
        } // if: IUnknown
        else if ( IsEqualIID( riidIn, IID_IClusCfgBaseCluster ) )
        {
            *ppvOut = TraceInterface( __THISCLASS__, IClusCfgBaseCluster, this, 0 );
        } // else if:
        else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
        {
            *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        } // else if:
        else
        {
            hr = THR( E_NOINTERFACE );
        } // else

        if ( SUCCEEDED( hr ) )
        {
            ((IUnknown *) *ppvOut)->AddRef( );
        } // if: success
        else
        {
            *ppvOut = NULL;
        } // else: something failed

    } // if: the output pointer was valid
    else
    {
        hr = THR( E_INVALIDARG );
    } // else: the output pointer is invalid


    return hr;

} //*** CBCAInterface::QueryInterface()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::Initialize()
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      punkCallbackIn
//          Pointer to the IUnknown interface of a component that implements
//          the IClusCfgCallback interface.
//
//      lcidIn
//          Locale id for this component.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBCAInterface::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    BCATraceScope( "[IClusCfgInitialize]" );

    HRESULT hrRetVal = S_OK;

    // Store the locale id in the member variable.
    m_lcid = lcidIn;

    do
    {
        // Indicate that SendStatusReports will not be supported unless a non-
        // NULL callback interface pointer was specified.  This is done in
        // the constructor as well, but is also done here since this method
        // could be called multiple times.
        SetCallbackSupported( false );

        if ( punkCallbackIn == NULL )
        {
            BCATraceMsg( "Callback pointer is NULL. No notifications will be sent." );
            LogMsg( "No notifications will be sent." );
            break;
        }

        BCATraceMsg( "The callback pointer is not NULL." );

        // Try and get the "normal" callback interface.
        hrRetVal = THR( m_spcbCallback.HrQueryAndAssign( punkCallbackIn ) );

        if ( FAILED( hrRetVal ) )
        {
            BCATraceMsg( "Could not get pointer to the callback interface. No notifications will be sent." );
            LogMsg( "An error occurred trying to get a pointer to the callback interface. No notifications will be sent." );
            break;
        } // if: we could not get the callback interface

        SetCallbackSupported( true );

        BCATraceMsg( "Progress messages will be sent." );
        LogMsg( "Progress messages will be sent." );
    }
    while( false ); // Dummy do-while loop to avoid gotos

    BCATraceMsg1( "hrRetVal = %#08x", hrRetVal );
    return hrRetVal;

} //*** CBCAInterface::Initialize()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CBCAInterface::SetForm()
//
//  Description:
//      Indicate that a cluster is to be formed with this computer as the first node.
//
//  Arguments:
//      const WCHAR *    pcszClusterNameIn
//          Name of the cluster to be formed.
//
//      const WCHAR *    pcszClusterAccountNameIn
//      const WCHAR *    pcszClusterAccountPwdIn
//      const WCHAR *    pcszClusterAccountDomainIn
//          Information about the cluster service account.
//
//      const DWORD      dwClusterIPAddressIn
//      const DWORD      dwClusterIPSubnetMaskIn
//      const WCHAR *    pcszClusterIPNetworkIn
//          Information about the cluster IP address
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBCAInterface::SetForm(
      const WCHAR *    pcszClusterNameIn
    , const WCHAR *    pcszClusterBindingStringIn
    , const WCHAR *    pcszClusterAccountNameIn
    , const WCHAR *    pcszClusterAccountPwdIn
    , const WCHAR *    pcszClusterAccountDomainIn
    , const DWORD      dwClusterIPAddressIn
    , const DWORD      dwClusterIPSubnetMaskIn
    , const WCHAR *    pcszClusterIPNetworkIn
    )
{
    BCATraceScope( "[IClusCfgBaseCluster]" );

    HRESULT hrRetVal = S_OK;

    // Set the thread locale.
    if ( SetThreadLocale( m_lcid ) == FALSE )
    {
        DWORD dwError = TW32( GetLastError() );

        // If SetThreadLocale() fails, do not abort. Just log the error.
        BCATraceMsg1( "Error %#08x occurred trying to set the thread locale.", dwError );
        LogMsg( "Error %#08x occurred trying to set the thread locale.", dwError );

    } // if: SetThreadLocale() failed

    try
    {
        BCATraceMsg( "Initializing cluster formation." );
        LogMsg( "Initializing cluster formation." );

        // Reset these state variables, to account for exceptions.
        SetRollbackPossible( false );
        // Setting this to true prevents Commit from being called while we are
        // in this routine or if this routine doesn't complete successfully.
        SetCommitCompleted( true );

        {
            // Create a CBaseClusterForm object and assign it to a smart pointer.
            SmartBCAPointer spbcaTemp(
                new CBaseClusterForm(
                      this
                    , pcszClusterNameIn
                    , pcszClusterBindingStringIn
                    , pcszClusterAccountNameIn
                    , pcszClusterAccountPwdIn
                    , pcszClusterAccountDomainIn
                    , dwClusterIPAddressIn
                    , dwClusterIPSubnetMaskIn
                    , pcszClusterIPNetworkIn
                    )
                );

            if ( spbcaTemp.FIsEmpty() )
            {
                BCATraceMsg( "Could not allocate memory for the CBaseClusterForm() object. Throwing an exception." );
                LogMsg( "Could not initialize cluster formation. A memory allocation failure occurred." );
                THROW_RUNTIME_ERROR( E_OUTOFMEMORY, IDS_ERROR_CLUSTER_FORM_INIT );
            } // if: the memory allocation failed.

            //
            // If the creation succeeded store the pointer in a member variable for
            // use during commit.
            //
            m_spbcaCurrentAction = spbcaTemp;
        }

        LogMsg( "Initialization completed. A cluster will be formed on commit." );

        // Indicate if rollback is possible.
        SetRollbackPossible( m_spbcaCurrentAction->FIsRollbackPossible() );

        // Indicate that this action has not been committed.
        SetCommitCompleted( false );

    } // try: to initialize cluster formation
    catch( CAssert & raExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( raExceptionObject ) );

    } // catch( CAssert & )
    catch( CExceptionWithString & resExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( resExceptionObject ) );

    } // catch( CExceptionWithString & )
    catch( CException & reExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( reExceptionObject ) );

    } // catch( CException &  )
    catch( ... )
    {
        // Catch everything. Do not let any exceptions pass out of this function.
        hrRetVal = THR( HrProcessException() );
    } // catch all

    BCATraceMsg1( "hrRetVal = %#08x", hrRetVal );
    return hrRetVal;

} //*** CBCAInterface::SetForm()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CBCAInterface::SetJoin()
//
//  Description:
//      Indicate that this computer should be added to a cluster.
//
//  Arguments:
//      const WCHAR *    pcszClusterNameIn
//          Name of the cluster to be joined.
//
//      const WCHAR *    pcszClusterAccountNameIn
//      const WCHAR *    pcszClusterAccountPwdIn
//      const WCHAR *    pcszClusterAccountDomainIn
//          Information about the cluster service account.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBCAInterface::SetJoin(
      const WCHAR *    pcszClusterNameIn
    , const WCHAR *    pcszClusterBindingStringIn
    , const WCHAR *    pcszClusterAccountNameIn
    , const WCHAR *    pcszClusterAccountPwdIn
    , const WCHAR *    pcszClusterAccountDomainIn
    )
{
    BCATraceScope( "[IClusCfgBaseCluster]" );

    HRESULT hrRetVal = S_OK;

    // Set the thread locale.
    if ( SetThreadLocale( m_lcid ) == FALSE )
    {
        DWORD dwError = TW32( GetLastError() );

        // If SetThreadLocale() fails, do not abort. Just log the error.
        BCATraceMsg1( "Error %#08x occurred trying to set the thread locale.", dwError );
        LogMsg( "Error %#08x occurred trying to set the thread locale.", dwError );

    } // if: SetThreadLocale() failed

    try
    {
        BCATraceMsg( "Initializing cluster join." );
        LogMsg( "Initializing cluster join." );

        // Reset these state variables, to account for exceptions.
        SetRollbackPossible( false );
        // Setting this to true prevents Commit from being called while we are
        // in this routine or if this routine doesn't complete successfully.
        SetCommitCompleted( true );

        {
            // Create a CBaseClusterJoin object and assign it to a smart pointer.
            SmartBCAPointer spbcaTemp(
                new CBaseClusterJoin(
                      this
                    , pcszClusterNameIn
                    , pcszClusterBindingStringIn
                    , pcszClusterAccountNameIn
                    , pcszClusterAccountPwdIn
                    , pcszClusterAccountDomainIn
                    )
                );

            if ( spbcaTemp.FIsEmpty() )
            {
                BCATraceMsg( "Could not allocate memory for the CBaseClusterJoin() object. Throwing an exception." );
                LogMsg( "Could not initialize cluster join. A memory allocation failure occurred." );
                THROW_RUNTIME_ERROR( E_OUTOFMEMORY, IDS_ERROR_CLUSTER_JOIN_INIT );
            } // if: the memory allocation failed.

            //
            // If the creation succeeded store the pointer in a member variable for
            // use during commit.
            //
            m_spbcaCurrentAction = spbcaTemp;
        }

        LogMsg( "Initialization completed. This computer will join a cluster on commit." );

        // Indicate if rollback is possible.
        SetRollbackPossible( m_spbcaCurrentAction->FIsRollbackPossible() );

        // Indicate that this action has not been committed.
        SetCommitCompleted( false );

    } // try: to initialize cluster join
    catch( CAssert & raExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( raExceptionObject ) );

    } // catch( CAssert & )
    catch( CExceptionWithString & resExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( resExceptionObject ) );

    } // catch( CExceptionWithString & )
    catch( CException & reExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( reExceptionObject ) );

    } // catch( CException &  )
    catch( ... )
    {
        // Catch everything. Do not let any exceptions pass out of this function.
        hrRetVal = THR( HrProcessException() );
    } // catch all

    BCATraceMsg1( "hrRetVal = %#08x", hrRetVal );
    return hrRetVal;

} //*** CBCAInterface::SetJoin()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CBCAInterface::SetCleanup()
//
//  Description:
//      Indicate that this node needs to be cleaned up. The ClusSvc service
//      should not be running when this action is committed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBCAInterface::SetCleanup()
{
    BCATraceScope( "[IClusCfgBaseCluster]" );

    HRESULT hrRetVal = S_OK;

    // Set the thread locale.
    if ( SetThreadLocale( m_lcid ) == FALSE )
    {
        DWORD dwError = TW32( GetLastError() );

        // If SetThreadLocale() fails, do not abort. Just log the error.
        BCATraceMsg1( "Error %#08x occurred trying to set the thread locale.", dwError );
        LogMsg( "Error %#08x occurred trying to set the thread locale.", dwError );

    } // if: SetThreadLocale() failed

    try
    {
        BCATraceMsg( "Initializing node clean up." );
        LogMsg( "Initializing node clean up." );

        // Reset these state variables, to account for exceptions.
        SetRollbackPossible( false );
        // Setting this to true prevents Commit from being called while we are
        // in this routine or if this routine doesn't complete successfully.
        SetCommitCompleted( true );

        {
            // Create a CBaseClusterCleanup object and assign it to a smart pointer.
            SmartBCAPointer spbcaTemp( new CBaseClusterCleanup( this ) );

            if ( spbcaTemp.FIsEmpty() )
            {
                BCATraceMsg( "Could not allocate memory for the CBaseClusterCleanup() object. Throwing an exception." );
                LogMsg( "Could not initialize node clean up. A memory allocation failure occurred." );
                THROW_RUNTIME_ERROR( E_OUTOFMEMORY, IDS_ERROR_CLUSTER_CLEANUP_INIT );
            } // if: the memory allocation failed.

            //
            // If the creation succeeded store the pointer in a member variable for
            // use during commit.
            //
            m_spbcaCurrentAction = spbcaTemp;
        }

        LogMsg( "Initialization completed. This node will be cleaned up on commit." );

        // Indicate if rollback is possible.
        SetRollbackPossible( m_spbcaCurrentAction->FIsRollbackPossible() );

        // Indicate that this action has not been committed.
        SetCommitCompleted( false );

    } // try: to initialize node clean up
    catch( CAssert & raExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( raExceptionObject ) );

    } // catch( CAssert & )
    catch( CExceptionWithString & resExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( resExceptionObject ) );

    } // catch( CExceptionWithString & )
    catch( CException & reExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( reExceptionObject ) );

    } // catch( CException &  )
    catch( ... )
    {
        // Catch everything. Do not let any exceptions pass out of this function.
        hrRetVal = THR( HrProcessException() );
    } // catch all

    BCATraceMsg1( "hrRetVal = %#08x", hrRetVal );
    return hrRetVal;

} //*** CBCAInterface::SetCleanup()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CBCAInterface::Commit( void )
//
//  Description:
//      Perform the action indicated by a previous call to one of the SetXXX
//      routines.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      E_FAIL
//          If this commit has already been performed.
//
//      E_INVALIDARG
//          If no action has been set using a SetXXX call.
//
//      Other HRESULTs
//          If the call failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBCAInterface::Commit( void )
{
    BCATraceScope( "[IClusCfgBaseCluster]" );

    HRESULT hrRetVal = S_OK;

    // Set the thread locale.
    if ( SetThreadLocale( m_lcid ) == FALSE )
    {
        DWORD dwError = TW32( GetLastError() );

        // If SetThreadLocale() fails, do not abort. Just log the error.
        BCATraceMsg1( "Error %#08x occurred trying to set the thread locale.", dwError );
        LogMsg( "Error %#08x occurred trying to set the thread locale.", dwError );

    } // if: SetThreadLocale() failed

    do
    {
        // Has this action already been committed?
        if ( FIsCommitComplete() )
        {
            BCATraceMsg( "The desired cluster configuration has already been performed." );
            LogMsg( "The desired cluster configuration has already been performed." );
            hrRetVal = THR( E_FAIL );  // BUGBUG: 29-JAN-2001 DavidP  Replace E_FAIL
            break;
        } // if: already committed

        // Check if the arguments to commit have been set.
        if ( m_spbcaCurrentAction.FIsEmpty() )
        {
            BCATraceMsg( "Commit was called when an operation has not been specified." );
            LogMsg( "Commit was called when an operation has not been specified." );
            hrRetVal = THR( E_INVALIDARG );    // BUGBUG: 29-JAN-2001 DavidP  Replace E_INVALIDARG
            break;
        } // if: the pointer to the action to be committed is NULL

        LogMsg( "About to perform the desired cluster configuration." );

        // Commit the desired action.
        try
        {
            m_spbcaCurrentAction->Commit();
            LogMsg( "Cluster configuration completed successfully." );

            // If we are here, then everything has gone well.
            SetCommitCompleted( true );

        } // try: to commit the desired action.
        catch( CAssert & raExceptionObject )
        {
            // Process the exception.
            hrRetVal = THR( HrProcessException( raExceptionObject ) );

        } // catch( CAssert & )
        catch( CExceptionWithString & resExceptionObject )
        {
            // Process the exception.
            hrRetVal = THR( HrProcessException( resExceptionObject ) );

        } // catch( CExceptionWithString & )
        catch( CException & reExceptionObject )
        {
            // Process the exception.
            hrRetVal = THR( HrProcessException( reExceptionObject ) );

        } // catch( CException &  )
        catch( ... )
        {
            // Catch everything. Do not let any exceptions pass out of this function.
            hrRetVal = THR( HrProcessException() );
        } // catch all
    }
    while( false ); // dummy do-while loop to avoid gotos

    BCATraceMsg1( "hrRetVal = %#08x", hrRetVal );
    return hrRetVal;

} //*** CBCAInterface::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CBCAInterface::Rollback( void )
//
//  Description:
//      Rollback a committed configuration.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      E_FAIL
//          If this action cannot be rolled back or if it has not yet been
//          committed successfully.
//
//      E_INVALIDARG
//          If no action has been set using a SetXXX call.
//
//      Other HRESULTs
//          If the call failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBCAInterface::Rollback( void )
{
    BCATraceScope( "[IClusCfgCallback]" );

    HRESULT hrRetVal = S_OK;

    do
    {
        // Check if this action list has completed successfully.
        if ( !FIsCommitComplete() )
        {
            // Cannot rollback an incomplete action.
            BCATraceMsg( "Cannot rollback - action not yet committed." );
            LogMsg( "Cannot rollback - action not yet committed." );
            hrRetVal = THR( E_FAIL );  // BUGBUG: 29-JAN-2001 DavidP  Replace E_FAIL
            break;

        } // if: this action was not completed successfully

        // Check if this action can be rolled back.
        if ( !FIsRollbackPossible() )
        {
            // Cannot rollback an incompleted action.
            BCATraceMsg( "This action cannot be rolled back." );
            LogMsg( "This action cannot be rolled back." ); // BUGBUG: 29-JAN-2001 DavidP  Why?
            hrRetVal = THR( E_FAIL );  // BUGBUG: 29-JAN-2001 DavidP  Replace E_FAIL
            break;

        } // if: this action was not completed successfully

        // Check if the arguments to rollback have been set.
        if ( m_spbcaCurrentAction.FIsEmpty() )
        {
            BCATraceMsg( "Rollback was called when an operation has not been specified." );
            LogMsg( "Rollback was called when an operation has not been specified." );
            hrRetVal = THR( E_INVALIDARG );    // BUGBUG: 29-JAN-2001 DavidP  Replace E_INVALIDARG
            break;
        } // if: the pointer to the action to be committed is NULL


        LogMsg( "About to rollback the cluster configuration just committed." );

        // Commit the desired action.
        try
        {
            m_spbcaCurrentAction->Rollback();
            LogMsg( "Cluster configuration rolled back." );

            // If we are here, then everything has gone well.
            SetCommitCompleted( false );

        } // try: to rollback the desired action.
        catch( CAssert & raExceptionObject )
        {
            // Process the exception.
            hrRetVal = THR( HrProcessException( raExceptionObject ) );

        } // catch( CAssert & )
        catch( CExceptionWithString & resExceptionObject )
        {
            // Process the exception.
            hrRetVal = THR( HrProcessException( resExceptionObject ) );

        } // catch( CExceptionWithString & )
        catch( CException & reExceptionObject )
        {
            // Process the exception.
            hrRetVal = THR( HrProcessException( reExceptionObject ) );

        } // catch( CException &  )
        catch( ... )
        {
            // Catch everything. Do not let any exceptions pass out of this function.
            hrRetVal = THR( HrProcessException() );
        } // catch all
    }
    while( false ); // dummy do-while loop to avoid gotos

    BCATraceMsg1( "hrRetVal = %#08x", hrRetVal );
    return hrRetVal;

} //*** CBCAInterface::Rollback()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CBCAInterface::SendStatusReport
//
//  Description:
//      Send a progress notification [ string id overload ].
//
//  Arguments:
//      clsidTaskMajorIn
//      clsidTaskMinorIn
//          GUIDs identifying the notification.
//
//      ulMinIn
//      ulMaxIn
//      ulCurrentIn
//          Values that indicate the percentage of this task that is
//          completed.
//
//      hrStatusIn
//          Error code.
//
//      uiDescriptionStringIdIn
//          String ID of the description of the notification.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      CAbortException
//          If the configuration was aborted.
//
//  Remarks:
//      In the current implementation, IClusCfgCallback::SendStatusReport
//      returns E_ABORT to indicate that the user wants to abort
//      the cluster configuration.
//--
//////////////////////////////////////////////////////////////////////////////
void
CBCAInterface::SendStatusReport(
      const CLSID &   clsidTaskMajorIn
    , const CLSID &   clsidTaskMinorIn
    , ULONG           ulMinIn
    , ULONG           ulMaxIn
    , ULONG           ulCurrentIn
    , HRESULT         hrStatusIn
    , UINT            uiDescriptionStringIdIn
    , bool            fIsAbortAllowedIn         // = true
    )
{
    BCATraceScope( "uiDescriptionStringIdIn" );

    HRESULT hrRetVal = S_OK;

    if ( FIsCallbackSupported() )
    {
        CStr strDescription;

        // Lookup the string using the string Id.
        strDescription.LoadString( g_hInstance, uiDescriptionStringIdIn );

        // Send progress notification ( call the overloaded function )
        SendStatusReport(
              clsidTaskMajorIn
            , clsidTaskMinorIn
            , ulMinIn
            , ulMaxIn
            , ulCurrentIn
            , hrStatusIn
            , strDescription.PszData()
            , fIsAbortAllowedIn
            );
    } // if: callbacks are supported
    else
    {
        BCATraceMsg( "Callbacks are not supported. Doing nothing." );
    } // else: callbacks are not supported

} //*** CBCAInterface::SendStatusReport()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CBCAInterface::SendStatusReport
//
//  Description:
//      Send a progress notification [ string overload ].
//
//  Arguments:
//      clsidTaskMajorIn
//      clsidTaskMinorIn
//          GUIDs identifying the notification.
//
//      ulMinIn
//      ulMaxIn
//      ulCurrentIn
//          Values that indicate the percentage of this task that is
//          completed.
//
//      hrStatusIn
//          Error code.
//
//      pcszDescriptionStringIn
//          String ID of the description of the notification.
//
//      fIsAbortAllowedIn
//          An optional parameter indicating if this configuration step can
//          be aborted or not. Default value is true.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      CAbortException
//          If the configuration was aborted.
//
//  Remarks:
//      In the current implementation, IClusCfgCallback::SendStatusReport
//      returns E_ABORT to indicate that the user wants to abort
//      the cluster configuration.
//--
//////////////////////////////////////////////////////////////////////////////
void
CBCAInterface::SendStatusReport(
      const CLSID &   clsidTaskMajorIn
    , const CLSID &   clsidTaskMinorIn
    , ULONG           ulMinIn
    , ULONG           ulMaxIn
    , ULONG           ulCurrentIn
    , HRESULT         hrStatusIn
    , const WCHAR *   pcszDescriptionStringIn
    , bool            fIsAbortAllowedIn         // = true
    )
{
    BCATraceScope1( "pcszDescriptionStringIn = '%ls'", pcszDescriptionStringIn );

    HRESULT     hrRetVal = S_OK;
    FILETIME    ft;

    do
    {
        CSmartResource<
            CHandleTrait<
                  BSTR
                , void
                , SysFreeString
                , reinterpret_cast< LPOLESTR >( NULL )
                >
            > sbstrDescription;

        if ( !FIsCallbackSupported() )
        {
            // Nothing needs to be done.
            break;
        } // if: callbacks are not supported

        if ( pcszDescriptionStringIn != NULL )
        {
            // Convert the string to a BSTR.
            sbstrDescription.Assign( SysAllocString( pcszDescriptionStringIn ) );

            // Did the conversion succeed?
            if ( sbstrDescription.FIsInvalid() )
            {
                BCATraceMsg( "Could not convert description string to BSTR." );
                LogMsg( "Could not convert description string to BSTR." );
                hrRetVal = E_OUTOFMEMORY;
                break;
            } // if: the string lookup failed.
        } // if: the description string is not NULL

        GetSystemTimeAsFileTime( &ft );

        //
        //  TODO:   21 NOV 2000 GalenB
        //
        //  I don't know why the two new args cannot be NULL?
        //  When they are NULL something throws and exception from
        //  somewhere...

        // Send progress notification
        hrRetVal = THR(
            m_spcbCallback->SendStatusReport(
                  NULL
                , clsidTaskMajorIn
                , clsidTaskMinorIn
                , ulMinIn
                , ulMaxIn
                , ulCurrentIn
                , hrStatusIn
                , sbstrDescription.HHandle()
                , &ft
                , L""
                )
            );

        // Has the user requested an abort?
        if ( hrRetVal == E_ABORT )
        {
            LogMsg( "A request to abort the configuration has been recieved." );
            if ( fIsAbortAllowedIn )
            {
                LogMsg( "Configuration will be aborted." );
                BCATraceMsg( "Aborting configuration." );
                THROW_ABORT( E_ABORT, IDS_USER_ABORT );
            } // if: this operation can be aborted
            else
            {
                LogMsg( "This configuration operation cannot be aborted. Request will be ignored." );
                BCATraceMsg( "This configuration operation cannot be aborted. Request will be ignored." );
            } // else: this operation cannot be aborted
        } // if: the user has indicated that that configuration should be aborted
        else
        {
            if ( FAILED( hrRetVal ) )
            {
                LogMsg( "Error %#08x has occurred - no more status messages will be sent.", hrRetVal );
                BCATraceMsg1( "Error %#08x occurred - no more status messages will be sent.", hrRetVal );

                // Disable all further callbacks.
                SetCallbackSupported( false );
            } // if: something went wrong trying to send a status report
        } // else: abort was not requested
    }
    while( false ); // dummy do-while loop to avoid gotos

    if ( FAILED( hrRetVal ) )
    {
        LogMsg( "Error %#08x occurred trying send a status message.", hrRetVal );
        BCATraceMsg1( "Error %#08x occurred trying send a status message. Throwing exception.", hrRetVal );
        THROW_RUNTIME_ERROR( hrRetVal, IDS_ERROR_SENDING_REPORT );
    } // if: an error occurred

} //*** CBCAInterface::SendStatusReport()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CBCAInterface::QueueStatusReportCompletion
//
//  Description:
//      Queue a status report for sending when an exception is caught.
//
//  Arguments:
//      clsidTaskMajorIn
//      clsidTaskMinorIn
//          GUIDs identifying the notification.
//
//      ulMinIn
//      ulMaxIn
//          Values that indicate the range of steps for this report.
//
//      uiDescriptionStringIdIn
//          String ID of the description of the notification.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any thrown by CList::Append()
//--
//////////////////////////////////////////////////////////////////////////////
void
CBCAInterface::QueueStatusReportCompletion(
      const CLSID &   clsidTaskMajorIn
    , const CLSID &   clsidTaskMinorIn
    , ULONG           ulMinIn
    , ULONG           ulMaxIn
    , UINT            uiDescriptionStringIdIn
    )
{
    BCATraceScope( "" );

    // Queue the status report only if callbacks are supported.
    if ( m_fCallbackSupported )
    {
        // Append this status report to the end of the pending list.
        m_prlPendingReportList.Append(
            SPendingStatusReport(
                  clsidTaskMajorIn
                , clsidTaskMinorIn
                , ulMinIn
                , ulMaxIn
                , uiDescriptionStringIdIn
                )
            );
    }

} //*** CBCAInterface::QueueStatusReportCompletion()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CBCAInterface::CompletePendingStatusReports
//
//  Description:
//      Send all the status reports that were queued for sending when an
//      exception occurred. This function is meant to be called from an exception
//      handler when an exception is caught.
//
//  Arguments:
//      hrStatusIn
//          The error code to be sent with the pending status reports.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None, since this function is usually called in an exception handler.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBCAInterface::CompletePendingStatusReports( HRESULT hrStatusIn ) throw()
{
    BCATraceScope( "" );

    if ( m_fCallbackSupported )
    {
        try
        {
            PendingReportList::CIterator    ciCurrent   = m_prlPendingReportList.CiBegin();
            PendingReportList::CIterator    ciLast      = m_prlPendingReportList.CiEnd();

            // Iterate through the list of pending status reports and send each pending report.
            while ( ciCurrent != ciLast )
            {
                // Send the current status report.
                SendStatusReport(
                      ciCurrent->m_clsidTaskMajor
                    , ciCurrent->m_clsidTaskMinor
                    , ciCurrent->m_ulMin
                    , ciCurrent->m_ulMax
                    , ciCurrent->m_ulMax
                    , hrStatusIn
                    , ciCurrent->m_uiDescriptionStringId
                    , false
                    );

                // Move to the next one.
                m_prlPendingReportList.DeleteAndMoveToNext( ciCurrent );

            } // while: the pending status report list is not empty

        } // try: to send status report
        catch( ... )
        {
            THR( E_UNEXPECTED );

            // Nothing can be done here if the sending of the status report fails.
            BCATraceMsg( "An exception has occurred trying to complete pending status messages. It will not be propagated." );
            LogMsg( "An unexpected error has occurred trying to complete pending status messages. It will not be propagated." );
        } // catch: all exceptions

    } // if: callbacks are supported

    // Empty the pending status report list.
    m_prlPendingReportList.Empty();

} //*** CBCAInterface::CompletePendingStatusReports()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CBCAInterface::HrProcessException
//
//  Description:
//      Process an exception that should be shown to the user.
//
//  Arguments:
//      CExceptionWithString & resExceptionObjectInOut
//          The exception object that has been caught.
//
//  Return Value:
//      The error code stored in the exception object.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CBCAInterface::HrProcessException(
    CExceptionWithString & resExceptionObjectInOut
    ) throw()
{
    BCATraceScope( "resExceptionObjectInOut" );

    LogMsg(
          TEXT("A runtime error has occurred in file '%s', line %d. Error code is %#08x.") SZ_NEWLINE
          TEXT("  The error string is '%s'.")
        , resExceptionObjectInOut.PszGetThrowingFile()
        , resExceptionObjectInOut.UiGetThrowingLine()
        , resExceptionObjectInOut.HrGetErrorCode()
        , resExceptionObjectInOut.StrGetErrorString().PszData()
        );

    BCATraceMsg3(
          "A runtime error has occurred in file '%s', line %d. Error code is %#08x."
        , resExceptionObjectInOut.PszGetThrowingFile()
        , resExceptionObjectInOut.UiGetThrowingLine()
        , resExceptionObjectInOut.HrGetErrorCode()
        );

    BCATraceMsg1(
          "  The error string is '%s'."
        , resExceptionObjectInOut.StrGetErrorString().PszData()
        );

    // If the user has not been notified
    if ( !resExceptionObjectInOut.FHasUserBeenNotified() )
    {
        try
        {
            SendStatusReport(
                  TASKID_Major_Configure_Cluster_Services
                , TASKID_Minor_Rolling_Back_Cluster_Configuration
                , 1, 1, 1
                , resExceptionObjectInOut.HrGetErrorCode()
                , resExceptionObjectInOut.StrGetErrorString().PszData()
                , false                                     // fIsAbortAllowedIn
                );

            resExceptionObjectInOut.SetUserNotified();

        } // try: to send status report
        catch( ... )
        {
            THR( E_UNEXPECTED );

            // Nothing can be done here if the sending of the status report fails.
            BCATraceMsg( "An exception has occurred trying to send a progress notification. It will not be propagated." );
            LogMsg( "An unexpected error has occurred trying to send a progress notification. It will not be propagated." );
        } // catch: all exceptions
    } // if: the user has not been notified of this exception

    // Complete sending pending status reports.
    CompletePendingStatusReports( resExceptionObjectInOut.HrGetErrorCode() );

    return resExceptionObjectInOut.HrGetErrorCode();

} //*** CBCAInterface::HrProcessException()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CBCAInterface::HrProcessException
//
//  Description:
//      Process an assert exception.
//
//  Arguments:
//      const CAssert & rcaExceptionObjectIn
//          The exception object that has been caught.
//
//  Return Value:
//      The error code stored in the exception object.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CBCAInterface::HrProcessException(
    const CAssert & rcaExceptionObjectIn
    ) throw()
{
    BCATraceScope( "rcaExceptionObjectIn" );

    LogMsg(
          TEXT("An assertion has failed in file '%s', line %d. Error code is %#08x.") SZ_NEWLINE
          TEXT("  The error string is '%s'.")
        , rcaExceptionObjectIn.PszGetThrowingFile()
        , rcaExceptionObjectIn.UiGetThrowingLine()
        , rcaExceptionObjectIn.HrGetErrorCode()
        , rcaExceptionObjectIn.StrGetErrorString().PszData()
        );

    BCATraceMsg3(
          "An assertion has failed in file '%s', line %d. Error code is %#08x."
        , rcaExceptionObjectIn.PszGetThrowingFile()
        , rcaExceptionObjectIn.UiGetThrowingLine()
        , rcaExceptionObjectIn.HrGetErrorCode()
        );

    BCATraceMsg1(
          "  The error string is '%s'."
        , rcaExceptionObjectIn.StrGetErrorString().PszData()
        );

    // Complete sending pending status reports.
    CompletePendingStatusReports( rcaExceptionObjectIn.HrGetErrorCode() );

    return rcaExceptionObjectIn.HrGetErrorCode();

} //*** CBCAInterface::HrProcessException()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CBCAInterface::HrProcessException
//
//  Description:
//      Process a general exception.
//
//  Arguments:
//      const CException & rceExceptionObjectIn
//          The exception object that has been caught.
//
//  Return Value:
//      The error code stored in the exception object.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CBCAInterface::HrProcessException(
    const CException & rceExceptionObjectIn
    ) throw()
{
    BCATraceScope( "roeExceptionObjectIn" );

    LogMsg(
          "An exception has occurred in file '%s', line %d. Error code is %#08x."
        , rceExceptionObjectIn.PszGetThrowingFile()
        , rceExceptionObjectIn.UiGetThrowingLine()
        , rceExceptionObjectIn.HrGetErrorCode()
        );

    BCATraceMsg3(
          "An exception has occurred in file '%s', line %d. Error code is %#08x."
        , rceExceptionObjectIn.PszGetThrowingFile()
        , rceExceptionObjectIn.UiGetThrowingLine()
        , rceExceptionObjectIn.HrGetErrorCode()
        );

    // Complete sending pending status reports.
    CompletePendingStatusReports( rceExceptionObjectIn.HrGetErrorCode() );

    return rceExceptionObjectIn.HrGetErrorCode();

} //*** CBCAInterface::HrProcessException()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CBCAInterface::HrProcessException
//
//  Description:
//      Process an unknown exception.
//
//  Arguments:
//      None.

//  Return Value:
//      E_UNEXPECTED
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CBCAInterface::HrProcessException( void ) throw()
{
    BCATraceScope( "void" );

    LogMsg( "An unknown exception (for example, an access violation) has occurred." );
    BCATraceMsg( "An unknown exception (for example, an access violation) has occurred." );

    // Complete sending pending status reports.
    CompletePendingStatusReports( E_UNEXPECTED );

    return E_UNEXPECTED;

} //*** CBCAInterface::HrProcessException()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdb.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CClusDB.cpp
//
//  Description:
//      Contains the definition of the CClusDB class.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// For setupapi functions
#include <setupapi.h>

// The header for this file
#include "CClusDB.h"

// For the CBaseClusterAction class
#include "CBaseClusterAction.h"

// For g_GenericSetupQueueCallback and other global functions
#include "GlobalFuncs.h"

// For CEnableThreadPrivilege
#include "CEnableThreadPrivilege.h"

// For ClRtlSetObjSecurityInfo() and other functions.
#include "clusrtl.h"


//////////////////////////////////////////////////////////////////////////
// Macros definitions
//////////////////////////////////////////////////////////////////////////

// Section in the INF file that deals with cleaning up the cluster database
#define CLUSDB_CLEANUP_INF_SECTION_NAME     L"ClusDB_Cleanup"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDB::CClusDB()
//
//  Description:
//      Constructor of the CClusDB class
//
//  Arguments:
//      pbcaParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CAssert
//          If the parameters are incorrect.
//
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDB::CClusDB(
      CBaseClusterAction *  pbcaParentActionIn
    )
    : m_pbcaParentAction( pbcaParentActionIn )
{

    BCATraceScope( "" );

    if ( m_pbcaParentAction == NULL) 
    {
        BCATraceMsg( "Pointers to the parent action is NULL. Throwing exception." );
        THROW_ASSERT( 
              E_INVALIDARG
            , "CClusDB::CClusDB() => Required input pointer in NULL"
            );
    } // if: the parent action pointer is NULL

} //*** CClusDB::CClusDB()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDB::~CClusDB()
//
//  Description:
//      Destructor of the CClusDB class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDB::~CClusDB( void )
{
    BCATraceScope( "" );

} //*** CClusDB::~CClusDB()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDB::CreateHive()
//
//  Description:
//      Creates the cluster cluster hive in the registry.
//
//  Arguments:
//      pbcaClusterActionIn
//          Pointer to the CBaseClusterAction object which contains this object.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the called functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDB::CreateHive( CBaseClusterAction * pbcaClusterActionIn )
{
    BCATraceScope( "" );
    LogMsg( "Attempting to create the cluster hive in the registry." );

    OBJECT_ATTRIBUTES   oaClusterHiveKey;
    OBJECT_ATTRIBUTES   oaClusterHiveFile;

    HRESULT             hrStatus = STATUS_SUCCESS;

    do
    {
        CStr                strClusterHiveFileName( pbcaClusterActionIn->RStrGetClusterInstallDirectory() );
        UNICODE_STRING      ustrClusterHiveFileName;
        UNICODE_STRING      ustrClusterHiveKeyName;
        
        strClusterHiveFileName += L"\\" CLUSTER_DATABASE_NAME;

        BCATraceMsg1( "The cluster hive backing file is '%s'.", strClusterHiveFileName.PszData() );

        //
        // Enable the SE_RESTORE_PRIVILEGE.
        //
        // What we are doing here is that we are creating an object of
        // type CEnableThreadPrivilege. This object enables the privilege
        // in the constructor and restores it to its original state in the destructor.
        //
        CEnableThreadPrivilege etpAcquireRestorePrivilege( SE_RESTORE_NAME );

        //
        // Convert the DOS file name to NT file name.
        // WARNING: This function call allocates memory in the RTL heap and it is not being
        // assigned to a smart pointer. Make sure that we do not call any functions that
        // could throw an exception till this memory is freed.
        //

        if ( RtlDosPathNameToNtPathName_U( 
                   strClusterHiveFileName.PszData()
                 , &ustrClusterHiveFileName
                 , NULL
                 , NULL
                 )
             == FALSE
           )
        {
            BCATraceMsg1( "RtlDosPathNameToNtPathName failed. Making up error code %#08x.", STATUS_OBJECT_PATH_INVALID );

            // Use the most appropriate error code.
            hrStatus = STATUS_OBJECT_PATH_INVALID;

            break;
        } // if: we could not convert from the dos file name to the nt file name

        InitializeObjectAttributes( 
              &oaClusterHiveFile
            , &ustrClusterHiveFileName
            , OBJ_CASE_INSENSITIVE
            , NULL
            , NULL
            );

        RtlInitUnicodeString( &ustrClusterHiveKeyName, L"\\Registry\\Machine\\" CLUSREG_KEYNAME_CLUSTER );

        InitializeObjectAttributes( 
              &oaClusterHiveKey
            , &ustrClusterHiveKeyName
            , OBJ_CASE_INSENSITIVE
            , NULL
            , NULL
            );

        //
        // This function creates an empty hive and the backing file and log. The calling thread must
        // have the SE_RESTORE_PRIVILEGE privilege enabled.
        //
        hrStatus = THR( NtLoadKey2( &oaClusterHiveKey, &oaClusterHiveFile, REG_NO_LAZY_FLUSH ) );

        // Free allocated memory before throwing exception.
        RtlFreeHeap( RtlProcessHeap(), 0, ustrClusterHiveFileName.Buffer );

        if ( NT_ERROR( hrStatus ) )
        {
            BCATraceMsg1( "NtLoadKey2 returned error code %#08x.", hrStatus );
            break;
        } // if: something went wrong with NtLoadKey2

        BCATraceMsg( "NtLoadKey2 was successful." );

        // Set the security descriptor on the hive.
        {
            DWORD dwError;

            // Open the cluster hive key.
            CRegistryKey rkClusterHive( HKEY_LOCAL_MACHINE, CLUSREG_KEYNAME_CLUSTER, KEY_ALL_ACCESS );

            dwError = TW32( ClRtlSetObjSecurityInfo(
                                  rkClusterHive.HGetKey()
                                , SE_REGISTRY_KEY
                                , KEY_ALL_ACCESS
                                , KEY_ALL_ACCESS
                                , KEY_READ
                                ) );

            if ( dwError != ERROR_SUCCESS )
            {
                hrStatus = HRESULT_FROM_WIN32( dwError );
                BCATraceMsg1( "Error %#08x occurred trying set the cluster hive security.", hrStatus );
                break;
            } // if: ClRtlSetObjSecurityInfo failed

            // Flush the changes to the registry.
            RegFlushKey( rkClusterHive.HGetKey() );
        }

        // At this point, the cluster hive has been created.
        LogMsg( "The cluster hive has been created." );
    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( NT_ERROR( hrStatus ) )
    {
        LogMsg( "Error %#08x occurred trying to create the cluster hive.", hrStatus );
        BCATraceMsg1( "Error %#08x occurred trying to create the cluster hive. Throwing exception.", hrStatus );
        THROW_RUNTIME_ERROR(
              hrStatus
            , IDS_ERROR_CLUSDB_CREATE_HIVE
            );
    } // if: something went wrong.

} //*** CClusDB::CreateHive()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDB::CleanupHive()
//
//  Description:
//      Unload the cluster hive and delete the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDB::CleanupHive( void )
{
    BCATraceScope( "" );

    DWORD   dwError = ERROR_SUCCESS;

    do
    {
        HKEY        hTempKey;

        // Check if the cluster hive is loaded before attempting to unload it.
        if ( RegOpenKeyEx( 
                  HKEY_LOCAL_MACHINE
                , CLUSREG_KEYNAME_CLUSTER
                , 0
                , KEY_READ
                , &hTempKey
                )
             == ERROR_SUCCESS
           )
        {
            RegCloseKey( hTempKey );

            //
            // Enable the SE_RESTORE_PRIVILEGE.
            //
            // What we are doing here is that we are creating an object of
            // type CEnableThreadPrivilege. This object enables the privilege
            // in the constructor and restores it to its original state in the destructor.
            //
            CEnableThreadPrivilege etpAcquireRestorePrivilege( SE_RESTORE_NAME );

            //
            // Unload the cluster hive, so that it can be deleted. Note, thread must
            // have SE_RESTORE_PRIVILEGE enabled.
            //
            dwError = RegUnLoadKey(
                  HKEY_LOCAL_MACHINE
                , CLUSREG_KEYNAME_CLUSTER
                );

            // MUSTDO: Check if ERROR_FILE_NOT_FOUND is an acceptable return value.
            if ( dwError != ERROR_SUCCESS )
            {
                LogMsg( "Error %#08x occurred while trying to unload the cluster hive.", dwError );
                BCATraceMsg( "RegUnLoadKey returned an error while trying to unload the cluster hive." );
                break;
            } // if: the hive could not be unloaded.

            BCATraceMsg( "The cluster hive has been unloaded." );
            LogMsg( "The cluster hive has been unloaded." );

        } // if: the cluster hive is loaded
        else
        {
            LogMsg( "The cluster hive was not loaded." );
            BCATraceMsg( "The cluster hive was not loaded." );
        } // else: the cluster hive is not loaded


        //
        // Process ClusDB cleanup section in the INF file.
        // This will delete the cluster database file and the log file.
        //
        if ( SetupInstallFromInfSection(
              NULL                                          // optional, handle of a parent window
            , m_pbcaParentAction->HGetMainInfFileHandle()   // handle to the INF file
            , CLUSDB_CLEANUP_INF_SECTION_NAME               // name of the Install section
            , SPINST_FILES                                  // which lines to install from section
            , NULL                                          // optional, key for registry installs
            , NULL                                          // optional, path for source files
            , 0                                             // optional, specifies copy behavior
            , g_GenericSetupQueueCallback                   // optional, specifies callback routine
            , NULL                                          // optional, callback routine context
            , NULL                                          // optional, device information set
            , NULL                                          // optional, device info structure
            ) == FALSE
           )
        {
            dwError = GetLastError();
            LogMsg( "Error %#08x occurred while trying to clean up the cluster database files.", dwError );
            BCATraceMsg( "Setup API returned an error while trying to cleanup the cluster database." );
            break;
        } // if: SetupInstallServicesFromInfSection failed

        LogMsg( "The cluster database files have been cleaned up." );

    }
    while( false ); // dummy do-while loop to avoid gotos

    if ( dwError != ERROR_SUCCESS )
    {
        LogMsg( "Error %#08x occurred while trying to cleanup the cluster database.", dwError );
        BCATraceMsg1( "Error %#08x occurred while trying to cleanup the cluster database. Throwing exception.", dwError );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_CLUSDB_CLEANUP );
    }

} //*** CClusDB::CleanupHive()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cbcainterface.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CBCAInterface.h
//
//  Description:
//      This file contains the declaration of the CBCAInterface
//      class. This class implements the IClusCfgBaseCluster interface.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Implementation Files:
//      CBCAInterface.cpp
//
//  Maintained By:
//      Vij Vasu (VVasu) 07-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For IUnknown
#include <unknwn.h>

// For IClusCfgBaseCluster
// For IClusCfgInitialize
// For IClusCfgCallback
#include "ClusCfgServer.h"
#include "ClusCfgPrivate.h"

// For CSmartIfacePtr
#include "SmartClasses.h"

// For the a few common types and definitions
#include "CommonDefs.h"

// For the CStr class
#include "CStr.h"

// For the CList class
#include "CList.h"


//////////////////////////////////////////////////////////////////////////
// Forward declarations.
//////////////////////////////////////////////////////////////////////////

class CBaseClusterAction;
class CException;
class CExceptionWithString;
class CAssert;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CBCAInterface
//
//  Description:
//      This class implements the IClusCfgBaseCluster interface.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CBCAInterface
    : public IClusCfgBaseCluster
    , public IClusCfgInitialize
{
public:
    //////////////////////////////////////////////////////////////////////////
    // IUnknown methods
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD( QueryInterface )( REFIID riidIn, void ** ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgBaseCluster methods
    //////////////////////////////////////////////////////////////////////////

    // Indicate that a cluster is to be formed.
    STDMETHOD( SetForm )(
          const WCHAR *    pcszClusterNameIn
        , const WCHAR *    pcszClusterBindingStringIn
        , const WCHAR *    pcszClusterAccountNameIn
        , const WCHAR *    pcszClusterAccountPwdIn
        , const WCHAR *    pcszClusterAccountDomainIn
        , const DWORD      dwClusterIPAddressIn
        , const DWORD      dwClusterIPSubnetMaskIn
        , const WCHAR *    pcszClusterIPNetworkIn
        );

    // Indicate that this node should be added to a cluster.
    STDMETHOD( SetJoin )(
          const WCHAR *    pcszClusterNameIn
        , const WCHAR *    pcszClusterBindingStringIn
        , const WCHAR *    pcszClusterAccountNameIn
        , const WCHAR *    pcszClusterAccountPwdIn
        , const WCHAR *    pcszClusterAccountDomainIn
        );

    // Indicate that this node needs to be cleaned up.
    STDMETHOD( SetCleanup )( void );

    // Commit the action desired.
    STDMETHOD( Commit )( void );

    // Rollback the committed action.
    STDMETHOD( Rollback )( void );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgInitialize methods
    //////////////////////////////////////////////////////////////////////////

    // Initialize this object.
    STDMETHOD( Initialize )(
          IUnknown *   punkCallbackIn
        , LCID         lcidIn
        );


    //////////////////////////////////////////////////////////////////////////
    //  Other public methods
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // Send progress notification [ string id overload ]
    void
        SendStatusReport(
              const CLSID &   clsidTaskMajorIn
            , const CLSID &   clsidTaskMinorIn
            , ULONG           ulMinIn
            , ULONG           ulMaxIn
            , ULONG           ulCurrentIn
            , HRESULT         hrStatusIn
            , UINT            uiDescriptionStringIdIn
            , bool            fIsAbortAllowedIn = true
            );

    // Send progress notification [ string overload ]
    void
        SendStatusReport(
              const CLSID &   clsidTaskMajorIn
            , const CLSID &   clsidTaskMinorIn
            , ULONG           ulMinIn
            , ULONG           ulMaxIn
            , ULONG           ulCurrentIn
            , HRESULT         hrStatusIn
            , const WCHAR *   pcszDescriptionStringIn
            , bool            fIsAbortAllowedIn = true
            );

    // Queue a status report to be sent when an exception is caught.
    void
        QueueStatusReportCompletion(
              const CLSID &   clsidTaskMajorIn
            , const CLSID &   clsidTaskMinorIn
            , ULONG           ulMinIn
            , ULONG           ulMaxIn
            , UINT            uiDescriptionStringIdIn
            );

    // Process an exception that should be shown to the user.
    HRESULT
        HrProcessException( CExceptionWithString & resExceptionObjectInOut ) throw();

    // Process an assert exception.
    HRESULT
        HrProcessException( const CAssert & rcaExceptionObjectIn ) throw();

    // Process a general exception.
    HRESULT
        HrProcessException( const CException & rceExceptionObjectIn ) throw();

    // Process an unknown exception.
    HRESULT
        HrProcessException( void ) throw();


    //////////////////////////////////////////////////////////////////////////
    // Public accessor methods
    //////////////////////////////////////////////////////////////////////////

    // Has this action been successfully committed?
    bool
        FIsCommitComplete() const throw() { return m_fCommitComplete; }

    // Can this action be rolled back?
    bool
        FIsRollbackPossible() const throw() { return m_fRollbackPossible; }

    // Are callbacks supported?
    bool
        FIsCallbackSupported() const throw() { return m_fCallbackSupported; }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////

    // Smart pointer to a base cluster action.
    typedef CSmartGenericPtr< CPtrTrait< CBaseClusterAction > > SmartBCAPointer;

    // Structure that holds the data required to send pending status reports.
    struct SPendingStatusReport
    {
        const CLSID     m_clsidTaskMajor;
        const CLSID     m_clsidTaskMinor;
        ULONG           m_ulMin;
        ULONG           m_ulMax;
        UINT            m_uiDescriptionStringId;

        // Constructor
        SPendingStatusReport(
              const CLSID &   rclsidTaskMajorIn
            , const CLSID &   rclsidTaskMinorIn
            , ULONG           ulMinIn
            , ULONG           ulMaxIn
            , UINT            uiDescriptionStringIdIn
            )
            : m_clsidTaskMajor( rclsidTaskMajorIn )
            , m_clsidTaskMinor( rclsidTaskMinorIn )
            , m_ulMin( ulMinIn )
            , m_ulMax( ulMaxIn )
            , m_uiDescriptionStringId( uiDescriptionStringIdIn )
        {
        } //*** SPendingStatusReport()

    }; // struct SPendingStatusReport

    // List of pending status reports
    typedef CList< SPendingStatusReport > PendingReportList;


    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    //
    // Private constructors, destructor and assignment operator.
    // All of these methods are private for two reasons:
    // 1. Lifetimes of objects of this class are controlled by S_HrCreateInstance and Release.
    // 2. Copying of an object of this class is prohibited.
    //

    // Default constructor.
    CBCAInterface( void );

    // Destructor.
    ~CBCAInterface( void );

    // Copy constructor.
    CBCAInterface( const CBCAInterface & );

    // Assignment operator.
    CBCAInterface & operator =( const CBCAInterface & );


    //////////////////////////////////////////////////////////////////////////
    // Private accessor methods
    //////////////////////////////////////////////////////////////////////////

    // Set the commit status.
    void
        SetCommitCompleted( bool fComplete = true ) throw() { m_fCommitComplete = fComplete; }

    // Indicate if rollback is possible
    void
        SetRollbackPossible( bool fPossible = true ) throw() { m_fRollbackPossible = fPossible; }

    // Indicate if callbacks are supported or not.
    void
        SetCallbackSupported( bool fSupported = true ) throw() { m_fCallbackSupported = fSupported; }


    //////////////////////////////////////////////////////////////////////////
    //  Other private methods
    //////////////////////////////////////////////////////////////////////////

    // Send all those status reports that were supposed to be sent
    void
        CompletePendingStatusReports( HRESULT hrStatusIn ) throw();


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Indicates if this action has been successfully committed or not.
    bool                m_fCommitComplete;

    // Indicates if this action can be rolled back or not.
    bool                m_fRollbackPossible;

    // Indicates if callbacks are supported or not.
    bool                m_fCallbackSupported;

    // Reference count for this object.
    LONG                m_cRef;

    // The locale id.
    LCID                m_lcid;

    // Pointer to the action to be performed during Commit()
    SmartBCAPointer     m_spbcaCurrentAction;

    // Pointer to the synchronous callback interface.
    CSmartIfacePtr< IClusCfgCallback > m_spcbCallback;

    // List of status reports that need to be send when an exception is caught.
    PendingReportList   m_prlPendingReportList;

}; //*** class CBCAInterface
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdb.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusDB.h
//
//  Description:
//      Header file for CClusDB class.
//      The CClusDB class performs operations that are common to many
//      configuration tasks of the cluster database.
//
//  Implementation Files:
//      CClusDB.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CAction base class
#include "CAction.h"

// For SetupInstallFromInfSection
#include <setupapi.h>


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterAction;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusDB
//
//  Description:
//      The CClusDB class performs operations that are common to many
//      configuration tasks of the cluster database.
//
//      This class is intended to be used as the base class for other cluster
//      database related action classes.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusDB : public CAction
{
protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusDB(
          CBaseClusterAction * pbcaParentActionIn
        );

    // Default destructor.
    ~CClusDB();


    //////////////////////////////////////////////////////////////////////////
    // Protected methods
    //////////////////////////////////////////////////////////////////////////

    // Cleanup and remove the hive.
    void
        CleanupHive();

    // Create the cluster hive in the registry.
    void
        CreateHive( CBaseClusterAction * pbcaClusterActionIn );

    
    //////////////////////////////////////////////////////////////////////////
    // Protected accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the parent action
    CBaseClusterAction *
        PbcaGetParent() throw()
    {
        return m_pbcaParentAction;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CClusDB( const CClusDB & );

    // Assignment operator
    const CClusDB & operator =( const CClusDB & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Pointer to the base cluster action of which this action is a part.
    CBaseClusterAction *    m_pbcaParentAction;

}; //*** class CClusDB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cbaseclusterjoin.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CBaseClusterJoin.cpp
//
//  Description:
//      Contains the definition of the CBaseClusterJoin class.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// For various RPC functions
#include <Rpcdce.h>

// The header file of this class.
#include "CBaseClusterJoin.h"

// For the CClusNetCreate action
#include "CClusNetCreate.h"

// For the CClusDiskJoin class
#include "CClusDiskJoin.h"

// For the CClusDBJoin action
#include "CClusDBJoin.h"

// For the CClusSvcCreate action
#include "CClusSvcCreate.h"

// For the CNodeConfig action
#include "CNodeConfig.h"

// For the CImpersonateUser class.
#include "CImpersonateUser.h"

// For CsRpcGetJoinVersionData() and constants like JoinVersion_v2_0_c_ifspec
#include <ClusRPC.h>

// For ClRtlIsVersionCheckingDisabled()
#include <ClusRTL.h>

// For CLUSTER_INTERNAL_CURRENT_MAJOR_VERSION
#include <ClusVerp.h>


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterJoin::CBaseClusterJoin
//
//  Description:
//      Constructor of the CBaseClusterJoin class.
//
//      This function also stores the parameters that are required to add this
//      node to a cluster.
//
//  Arguments:
//      pbcaiInterfaceIn
//          Pointer to the interface class for this library.
//
//      pcszClusterNameIn
//          Name of the cluster to be joined.
//
//      pcszClusterAccountNameIn
//      pcszClusterAccountPwdIn
//      pcszClusterAccountDomainIn
//          Specifies the account to be used as the cluster service account.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CConfigError
//          If the OS version is incorrect or if the installation state
//          of the cluster binaries is wrong.
//
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusterJoin::CBaseClusterJoin(
      CBCAInterface *   pbcaiInterfaceIn
    , const WCHAR *     pcszClusterNameIn
    , const WCHAR *     pcszClusterBindingStringIn
    , const WCHAR *     pcszClusterAccountNameIn
    , const WCHAR *     pcszClusterAccountPwdIn
    , const WCHAR *     pcszClusterAccountDomainIn
    )
    : BaseClass(
            pbcaiInterfaceIn
          , pcszClusterNameIn
          , pcszClusterBindingStringIn
          , pcszClusterAccountNameIn
          , pcszClusterAccountPwdIn
          , pcszClusterAccountDomainIn
          )
{
    BCATraceScope( "" );
    LogMsg( "[BC] The current cluster configuration task is: Cluster Join." );

    if ( ( pcszClusterBindingStringIn == NULL ) || ( *pcszClusterBindingStringIn == L'\0'  ) )
    {
        LogMsg( "[BC] The cluster binding string is empty." );
        THROW_CONFIG_ERROR( E_INVALIDARG, IDS_ERROR_INVALID_CLUSTER_BINDINGSTRING );
    } // if: the cluster account is empty

    CStatusReport   srInitJoin(
          PBcaiGetInterfacePointer()
        , TASKID_Major_Configure_Cluster_Services
        , TASKID_Minor_Initializing_Cluster_Join
        , 0, 1
        , IDS_TASK_JOIN_INIT
        );

    // Send the next step of this status report.
    srInitJoin.SendNextStep( S_OK );


    // Create an object of the CClusSvcAccountConfig class and store a pointer to it.
    // This object will be used during Commit() of this action. This object is not
    // added to the action list below since the cluster service account has to be
    // configured before the sponsor cluster can be contacted.
    m_spacAccountConfigAction.Assign( new CClusSvcAccountConfig( this ) );
    if ( m_spacAccountConfigAction.FIsEmpty() )
    {
        LogMsg( "[BC] A memory allocation error occurred trying to configure the cluster service account." );
        BCATraceMsg1( "A memory allocation error occurred trying to configure the cluster service account (%d bytes). Throwing exception.", sizeof( CClusSvcAccountConfig ) );
        THROW_RUNTIME_ERROR( E_OUTOFMEMORY, IDS_ERROR_JOIN_CLUSTER_INIT );
    } // if: memory allocation failed


    //
    // Create a list of actions to be performed.
    // The order of appending actions is significant.
    //

    // Add the action to create the ClusNet service.
    RalGetActionList().AppendAction( new CClusNetCreate( this ) );

    // Add the action to create the ClusDisk service.
    RalGetActionList().AppendAction( new CClusDiskJoin( this ) );

    // Add the action to create the cluster database.
    RalGetActionList().AppendAction( new CClusDBJoin( this ) );

    // Add the action to create the ClusSvc service.
    RalGetActionList().AppendAction( new CClusSvcCreate( this ) );

    // Add the action to perform miscellaneous tasks.
    RalGetActionList().AppendAction( new CNodeConfig( this ) );


    // Indicate if rollback is possible or not.
    SetRollbackPossible( m_spacAccountConfigAction->FIsRollbackPossible() && RalGetActionList().FIsRollbackPossible() );

    // Indicate that this node should be added to a cluster during commit.
    SetAction( eCONFIG_ACTION_JOIN );

    // Send the last step of a status report.
    srInitJoin.SendNextStep( S_OK );

    LogMsg( "[BC] Initialization for cluster join complete." );

} //***  CBaseClusterJoin::CBaseClusterJoin()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterJoin::~CBaseClusterJoin
//
//  Description:
//      Destructor of the CBaseClusterJoin class
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusterJoin::~CBaseClusterJoin() throw()
{
    BCATraceScope( "" );

} //*** CBaseClusterJoin::~CBaseClusterJoin()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CBaseClusterJoin::Commit
//
//  Description:
//      Join the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any exceptions thrown by functions called.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterJoin::Commit()
{
    BCATraceScope( "" );
    LogMsg( "[BC] Initiating cluster join." );

    CStatusReport   srJoiningCluster(
          PBcaiGetInterfacePointer()
        , TASKID_Major_Configure_Cluster_Services
        , TASKID_Minor_Joining_Node
        , 0, 1
        , IDS_TASK_JOINING_CLUSTER
        );

    // Send the next step of this status report.
    srJoiningCluster.SendNextStep( S_OK );

    try
    {
        // First configure the cluster service account - this is required to get the account token.
        m_spacAccountConfigAction->Commit();


        // Get the cluster service account token and store it for later use.
        {
            // Get the account token.
            HANDLE hServiceAccountToken = HGetAccountToken(
                  RStrGetServiceAccountName().PszData()
                , RStrGetServiceAccountPassword().PszData()
                , RStrGetServiceAccountDomain().PszData()
                );

            // Store it in a member variable. This variable automatically closes the token on destruction.
            m_satServiceAccountToken.Assign( hServiceAccountToken );

            LogMsg( "[BC] Got the cluster service account token." );
        }

        //
        // In the scope below, the cluster service account is impersonated, so that we can communicate with the
        // sponsor cluster
        //
        {
            DWORD sc;
            BOOL  fIsVersionCheckingDisabled;

            BCATraceMsg( "Impersonating the cluster service account before communicating with the sponsor cluster." );

            // Impersonate the cluster service account, so that we can contact the sponsor cluster.
            // The impersonation is automatically ended when this object is destroyed.
            CImpersonateUser    ciuImpersonateClusterServiceAccount( HGetClusterServiceAccountToken() );

            // Check if version checking is disabled on the sponsor cluster.
            sc = ClRtlIsVersionCheckingDisabled( RStrGetClusterBindingString().PszData(), &fIsVersionCheckingDisabled );
            if ( sc != ERROR_SUCCESS )
            {
                LogMsg(
                      "[BC] Error %#08x occurred trying to determine if version checking is enabled on the node {%ws} with binding string {%ws}."
                    , sc
                    , RStrGetClusterName().PszData()
                    , RStrGetClusterBindingString().PszData()
                    );

                LogMsg( "[BC] This is not a fatal error. Assuming that version checking is required." );

                fIsVersionCheckingDisabled = FALSE;
            } // if: an error occurred trying to determine if version checking is disabled or not

            // Store the result since it will be used later when we try to create the cluster service on this computer.
            SetVersionCheckingDisabled( fIsVersionCheckingDisabled != FALSE );

            if ( fIsVersionCheckingDisabled != FALSE )
            {
                LogMsg( "[BC] Cluster version checking is disabled on the sponsor node." );
            } // if: version checking is disabled
            else
            {
                // Make sure the this node can interoperate with the sponsor cluster. Note, this call uses
                // the cluster service account token got above.
                CheckInteroperability();
            } // else: version checking is enabled

            // Get a binding handle to the extrocluster join interface and store it.
            InitializeJoinBinding();
        } //

        // Call the base class commit routine. This commits the rest of the action list.
        BaseClass::Commit();

    } // try:
    catch( ... )
    {
        // If we are here, then something went wrong with one of the actions.

        LogMsg( "[BC] An error has occurred. The performed actions will be rolled back." );

        //
        // Rollback all committed actions in the reverse order.
        // Catch any exceptions thrown during rollback to make sure that there
        // is no collided unwind.
        //
        try
        {
            // If we are here, then it means that something has gone wrong in the try block above.
            // Of the two actions committed, only m_spacAccountConfigAction needs to be rolled back.
            // This is because, if BaseClass::Commit() was successful, we wouldn't be here!
            if ( m_spacAccountConfigAction->FIsCommitComplete() )
            {
                if ( m_spacAccountConfigAction->FIsRollbackPossible() )
                {
                    m_spacAccountConfigAction->Rollback();
                } // if: this action can be rolled back
                else
                {
                    LogMsg( "[BC] THIS COMPUTER MAY BE IN AN INVALID STATE. Rollback was aborted." );
                } // else: this action cannot be rolled back
            } // if: the cluster service account has been configured
            else
            {
                BCATraceMsg( "There is no need to cleanup this action since no part of it committed successfully." );
            } // else: the cluster service account has not been configured
        }
        catch( ... )
        {
            //
            // The rollback of the committed actions has failed.
            // There is nothing that we can do, is there?
            // We certainly cannot rethrow this exception, since
            // the exception that caused the rollback is more important.
            //
            THR( E_UNEXPECTED );

            LogMsg( "[BC] THIS COMPUTER MAY BE IN AN INVALID STATE. An error has occurred during rollback. Rollback will be aborted." );

        } // catch: all

        // Rethrow the exception thrown by commit.
        throw;

    } // catch: all

    // If we are here, then everything went well.
    SetCommitCompleted( true );

    // Send the last step of this status report.
    srJoiningCluster.SendNextStep( S_OK );

} //*** CBaseClusterJoin::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CBaseClusterJoin::Rollback
//
//  Description:
//      Performs the rolls back of the action committed by this object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by functions called.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterJoin::Rollback()
{
    BCATraceScope( "" );

    // Rollback the actions.
    BaseClass::Rollback();

    // Rollback the configuration of the cluster service account.
    m_spacAccountConfigAction->Rollback();

    SetCommitCompleted( false );

} //*** CBaseClusterJoin::Rollback()



//////////////////////////////////////////////////////////////////////////////
//++
//
//  HANDLE
//  CBaseClusterJoin::HGetAccountToken
//
//  Description:
//      Gets a handle to an account token. This token is an impersonation
//      token.
//
//  Arguments:
//      pcszAccountNameIn
//      pcszAccountPwdIn
//      pcszAccountDomainIn
//          Specifies the account whose token is to be retrieved.
//
//  Return Value:
//      Handle to the desired token. This has to be closed using CloseHandle().
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
HANDLE
CBaseClusterJoin::HGetAccountToken(
      const WCHAR *     pcszAccountNameIn
    , const WCHAR *     pcszAccountPwdIn
    , const WCHAR *     pcszAccountDomainIn
    )
{
    BCATraceScope( "" );

    HANDLE hAccountToken = NULL;

    if (    LogonUser(
                  const_cast< LPWSTR >( pcszAccountNameIn )
                , const_cast< LPWSTR >( pcszAccountDomainIn )
                , const_cast< LPWSTR >( pcszAccountPwdIn )
                , LOGON32_LOGON_SERVICE
                , LOGON32_PROVIDER_DEFAULT
                , &hAccountToken
                )
         == FALSE
       )
    {
        DWORD sc = TW32( GetLastError() );

        if ( ( pcszAccountDomainIn != NULL ) && ( pcszAccountNameIn != NULL ) )
        {
            BCATraceMsg3( "Error %#08x occurred trying to get a token for the account '%ws\\%ws'. Throwing exception.", sc, pcszAccountDomainIn, pcszAccountNameIn );
            LogMsg( "[BC] Error %#08x occurred trying to get a token for the account '%ws\\%ws'.", sc, pcszAccountDomainIn, pcszAccountNameIn );
        } // if: the account and domain strings are not NULL
        else
        {
            BCATraceMsg1( "Error %#08x occurred trying to get a token for the account. Throwing exception.", sc );
            LogMsg( "[BC] Error %#08x occurred trying to get a token for the account.", sc );
        } // else: either the account or the domain name is NULL

        THROW_RUNTIME_ERROR(
              HRESULT_FROM_WIN32( sc )
            , IDS_ERROR_GET_ACCOUNT_TOKEN
            );
    } // if: LogonUser() fails

    return hAccountToken;

} //*** CBaseClusterJoin::HGetAccountToken()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CBaseClusterJoin::CheckInteroperability
//
//  Description:
//      This functions checks to see if this node can interoperate with the
//      sponsor cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      CConfigError
//          If this node cannot interoperate with the sponsor.
//
//  Remarks:
//      The thread calling this function should be running in the context of an
//      account that has access to the sponsor cluster.
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterJoin::CheckInteroperability( void )
{
    BCATraceScope( "" );

    RPC_STATUS          rsError = RPC_S_OK;
    RPC_BINDING_HANDLE  rbhBindingHandle = NULL;
    SmartRpcBinding     srbBindingHandle;

    do
    {
        LPWSTR              pszBindingString = NULL;
        SmartRpcString      srsBindingString( &pszBindingString );

        // Create a string binding handle.
        {

            LogMsg(
                      L"[BC] Creating a binding string handle for cluster {%ws} with binding string {%ws} to check interoperability."
                    , RStrGetClusterName().PszData()
                    , RStrGetClusterBindingString().PszData()
                    );

            rsError = TW32( RpcStringBindingComposeW(
                          L"6e17aaa0-1a47-11d1-98bd-0000f875292e"
                        , L"ncadg_ip_udp"
                        , const_cast< LPWSTR >( RStrGetClusterBindingString().PszData() )
                        , NULL
                        , NULL
                        , &pszBindingString
                        ) );
            if ( rsError != RPC_S_OK )
            {
                LogMsg( L"[BC] An error occurred trying to compose an RPC string binding." );
                break;
            } // if: RpcStringBindingComposeW() failed

            // No need to free pszBindingString - srsBindingString will automatically free it.
        }

        // Get the actual binding handle
        {

            rsError = TW32( RpcBindingFromStringBindingW( pszBindingString, &rbhBindingHandle ) );
            if ( rsError != RPC_S_OK )
            {
                LogMsg( L"[BC] An error occurred trying to get an RPC binding handle from a string binding." );
                break;
            } // if: RpcBindingFromStringBindingW() failed

            // No need to free rbhBindingHandle - srbBindingHandle will automatically free it.
            srbBindingHandle.Assign( rbhBindingHandle );
        }

        // Resolve the binding handle
        {
            rsError = TW32( RpcEpResolveBinding( rbhBindingHandle, JoinVersion_v2_0_c_ifspec ) );
            if ( rsError != RPC_S_OK )
            {
                LogMsg( L"[BC] An error occurred trying to resolve the RPC binding handle." );
                break;
            } // if: RpcEpResolveBinding() failed
        }

        // Set RPC security
        {
            rsError = TW32( RpcBindingSetAuthInfoW(
                              rbhBindingHandle
                            , NULL
                            , RPC_C_AUTHN_LEVEL_CONNECT
                            , RPC_C_AUTHN_WINNT
                            , NULL
                            , RPC_C_AUTHZ_NAME
                            ) );
            if ( rsError != RPC_S_OK )
            {
                LogMsg( L"[BC] An error occurred trying to set security on the binding handle." );
                break;
            } // if: RpcBindingSetAuthInfoW() failed
        }
    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( rsError != RPC_S_OK )
    {
        LogMsg(
              "[BC] Error %#08x occurred trying to connect to the sponsor cluster for an interoperability check with binding string {%ws}."
            , rsError
            , RStrGetClusterBindingString().PszData()
            );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( rsError ), IDS_ERROR_JOIN_CHECK_INTEROP );
    } // if: something has gone wrong

    LogMsg( L"[BC] Got RPC binding handle to check interoperability without any problems." );

    //
    // Get and verify the sponsor version
    //
    {
        DWORD                   dwSponsorNodeId;
        DWORD                   dwClusterHighestVersion;
        DWORD                   dwClusterLowestVersion;
        DWORD                   dwJoinStatus;
        DWORD                   sc;
        DWORD                   dwNodeHighestVersion = DwGetNodeHighestVersion();
        DWORD                   dwNodeLowestVersion = DwGetNodeLowestVersion();
        bool                    fVersionMismatch = false;


        //
        // From Whistler onwards, CsRpcGetJoinVersionData() will return a failure code in its last parameter
        // if the version of this node is not compatible with the sponsor version. Prior to this, the last
        // parameter always contained a success value and the cluster versions had to be compared subsequent to this
        // call. This will, however, still have to be done as long as interoperability with Win2K
        // is a requirement, since Win2K sponsors do not return an error in the last parameter.
        //

        sc = TW32( CsRpcGetJoinVersionData(
                              rbhBindingHandle
                            , 0
                            , dwNodeHighestVersion
                            , dwNodeLowestVersion
                            , &dwSponsorNodeId
                            , &dwClusterHighestVersion
                            , &dwClusterLowestVersion
                            , &dwJoinStatus
                            ) );

        if ( sc != ERROR_SUCCESS )
        {
            LogMsg( "[BC] Error %#08x occurred trying to verify if this node can interoperate with the sponsor cluster.", sc );
            BCATraceMsg1( "Error %#08x occurred trying to verify if this node can interoperate with the sponsor cluster. Throwing exception.", sc );
            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_JOIN_CHECK_INTEROP );
        } // if: CsRpcGetJoinVersionData() failed

        BCATraceMsg4(
              "( Node Highest, Node Lowest ) = ( %#08x, %#08x ), ( Cluster Highest, Cluster Lowest ) = ( %#08x, %#08x )."
            , dwNodeHighestVersion
            , dwNodeLowestVersion
            , dwClusterHighestVersion
            , dwClusterLowestVersion
            );

        if ( dwJoinStatus == ERROR_SUCCESS )
        {
            DWORD   dwClusterMajorVersion = CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion );

//            Assert( dwClusterMajorVersion > ( CLUSTER_INTERNAL_CURRENT_MAJOR_VERSION - 1 ) );

            //
            //  Only want to join clusters that are no more than one version back.
            //
            if ( dwClusterMajorVersion < ( CLUSTER_INTERNAL_CURRENT_MAJOR_VERSION - 1 ) )
            {
                fVersionMismatch = true;
            } // if:
        } // if:  the join status was ok
        else
        {
            fVersionMismatch = true;
        } // else: join is not possible

        if ( fVersionMismatch )
        {
            LogMsg( "[BC] This node cannot interoperate with the sponsor cluster.", sc );
            BCATraceMsg1( "This node cannot interoperate with the sponsor cluster. Throwing exception.", sc );
            THROW_CONFIG_ERROR( HRESULT_FROM_WIN32( TW32( ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE ) ), IDS_ERROR_JOIN_INCOMPAT_SPONSOR );
        } // if: there was a version mismatch
        else
        {
            LogMsg( "[BC] This node is compatible with the sponsor cluster." );
            BCATraceMsg( "This node is compatible with the sponsor cluster." );
        } // else: this node can join the cluster
    }

} //*** CBaseClusterJoin::CheckInteroperability()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CBaseClusterJoin::InitializeJoinBinding
//
//  Description:
//      Get a binding handle to the extrocluster join interface and store it.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//  Remarks:
//      The thread calling this function should be running in the context of an
//      account that has access to the sponsor cluster.
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterJoin::InitializeJoinBinding( void )
{
    BCATraceScope( "" );

    RPC_STATUS          rsError = RPC_S_OK;
    RPC_BINDING_HANDLE  rbhBindingHandle = NULL;

    do
    {
        LPWSTR              pszBindingString = NULL;
        SmartRpcString      srsBindingString( &pszBindingString );

        // Create a string binding handle.
        {
            LogMsg(
                  L"[BC] Creating a string binding handle for cluster {%ws} using binding string {%ws} for extro cluster join."
                , RStrGetClusterName().PszData()
                , RStrGetClusterBindingString().PszData()
                );

            rsError = TW32( RpcStringBindingComposeW(
                                  L"ffe561b8-bf15-11cf-8c5e-08002bb49649"
                                , L"ncadg_ip_udp"
                                , const_cast< LPWSTR >( RStrGetClusterBindingString().PszData() )
                                , NULL
                                , NULL
                                , &pszBindingString
                                ) );
            if ( rsError != RPC_S_OK )
            {
                LogMsg( L"[BCAn error occurred trying to compose an RPC string binding." );
                break;
            } // if: RpcStringBindingComposeW() failed

            // No need to free pszBindingString - srsBindingString will automatically free it.
        }

        // Get the actual binding handle
        {

            rsError = TW32( RpcBindingFromStringBindingW( pszBindingString, &rbhBindingHandle ) );
            if ( rsError != RPC_S_OK )
            {
                LogMsg( L"[BC] An error occurred trying to get an RPC binding handle from a string binding." );
                break;
            } // if: RpcBindingFromStringBindingW() failed

            // No need to free rbhBindingHandle - m_srbJoinBinding will automatically free it.
            m_srbJoinBinding.Assign( rbhBindingHandle );
        }

        // Resolve the binding handle
        {
            rsError = TW32( RpcEpResolveBinding( rbhBindingHandle, ExtroCluster_v2_0_c_ifspec ) );
            if ( rsError != RPC_S_OK )
            {
                LogMsg( L"[BC] An error occurred trying to resolve the RPC binding handle." );
                break;
            } // if: RpcEpResolveBinding() failed
        }

        // Set RPC security
        {
            rsError = TW32( RpcBindingSetAuthInfoW(
                                  rbhBindingHandle
                                , NULL
                                , RPC_C_AUTHN_LEVEL_CONNECT
                                , RPC_C_AUTHN_WINNT
                                , NULL
                                , RPC_C_AUTHZ_NAME
                                ) );
            if ( rsError != RPC_S_OK )
            {
                LogMsg( L"[BC] An error occurred trying to set security on the binding handle." );
                break;
            } // if: RpcBindingSetAuthInfoW() failed
        }

        // Make sure that the server is who it claims to be.
        rsError = TW32( TestRPCSecurity( rbhBindingHandle ) );
        if ( rsError != RPC_S_OK )
        {
            LogMsg( L"[BC] An error occurred trying to test RPC security." );
            break;
        } // if: TestRPCSecurity() failed
    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( rsError != RPC_S_OK )
    {
        LogMsg( "[BC] Error %#x occurred trying to get a handle to the extrocluster join interface.", rsError );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( rsError ), IDS_ERROR_JOIN_CLUSTER_INIT );
    } // if: something has gone wrong

    LogMsg( L"[BC] Got RPC binding handle for extro cluster join without any problems." );

} //*** CBaseClusterJoin::InitializeJoinBinding()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cbaseclusterjoin.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CBaseClusterJoin.h
//
//  Description:
//      Header file for CBaseClusterJoin class.
//
//      The CBaseClusterJoin class is a class that encapsulates the
//      action of add a node to a cluster.
//
//  Implementation Files:
//      CBaseClusterJoin.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the base class of this class.
#include "CBaseClusterAddNode.h"

// For the CStr class.
#include "CStr.h"

// For a few smart classes
#include "SmartClasses.h"

// For the cluster API functions and types
#include "ClusAPI.h"

// For the CClusSvcAccountConfig action
#include "CClusSvcAccountConfig.h"


//////////////////////////////////////////////////////////////////////////
// Type definitions
//////////////////////////////////////////////////////////////////////////

// Class used to automatically release a RPC binding handle.
class CRPCBindingHandleTrait
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public types
    //////////////////////////////////////////////////////////////////////////
    typedef RPC_BINDING_HANDLE ResourceType;


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    // A routine used to close a handle.
    static void CloseRoutine( ResourceType hResourceIn )
    {
        RpcBindingFree( &hResourceIn );
    } //*** CloseRoutine()

    // Get the null value for this type.
    static ResourceType HGetNullValue()
    {
        return NULL;
    } //*** HGetNullValue()

}; //*** class CRPCBindingHandleTrait

// A smart RPC binding handle
typedef CSmartResource< CRPCBindingHandleTrait > SmartRpcBinding;

// Smart handle to a cluster.
typedef CSmartResource<
    CHandleTrait<
          HCLUSTER
        , BOOL
        , CloseCluster
        , reinterpret_cast< HCLUSTER >( NULL )
        >
    > SmartClusterHandle;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CBaseClusterJoin
//
//  Description:
//      The CBaseClusterJoin class is a class that encapsulates the
//      action of add a node to a cluster.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CBaseClusterJoin : public CBaseClusterAddNode
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CBaseClusterJoin(
          CBCAInterface *   pbcaiInterfaceIn
        , const WCHAR *     pcszClusterNameIn
        , const WCHAR *     pcszClusterBindingStringIn
        , const WCHAR *     pcszClusterAccountNameIn
        , const WCHAR *     pcszClusterAccountPwdIn
        , const WCHAR *     pcszClusterAccountDomainIn
        );

    // Default destructor.
    ~CBaseClusterJoin( void ) throw();


    //////////////////////////////////////////////////////////////////////////
    // Public accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the NodeId of this node.
    virtual const WCHAR *
        PszGetNodeIdString( void ) const throw() { return m_strNodeId.PszData(); }

    // Set the NodeId of this node.
    void
        SetNodeIdString( const WCHAR * pcszNodeIdIn ) { m_strNodeId = pcszNodeIdIn; }

    // Get a handle to the cluster service account token.
    HANDLE
        HGetClusterServiceAccountToken( void ) const throw() { return m_satServiceAccountToken.HHandle(); }

    RPC_BINDING_HANDLE
        RbhGetJoinBindingHandle( void ) const throw() { return m_srbJoinBinding.HHandle(); }


    //////////////////////////////////////////////////////////////////////////
    // Public member functions
    //////////////////////////////////////////////////////////////////////////

    // Join the cluster.
    void
        Commit( void );

    // Rollback a created cluster.
    void
        Rollback( void );

    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks( void ) const throw()
    {
        // The extra tick if for the "Join starting" notification.
        return BaseClass::UiGetMaxProgressTicks() + 1;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////

    // The base class of this class
    typedef CBaseClusterAddNode BaseClass;

    // A smart handle to an account token.
    typedef CSmartResource< CHandleTrait< HANDLE, BOOL, CloseHandle > > SmartAccountToken;

    // A smart handle to an RPC string.
    typedef CSmartResource<
        CHandleTrait<
              LPWSTR *
            , RPC_STATUS
            , RpcStringFreeW
            , reinterpret_cast< LPWSTR * >( NULL )
            >
        >
        SmartRpcString;

    typedef CSmartGenericPtr< CPtrTrait< CClusSvcAccountConfig > > SmartAccountConfigPtr;


    //////////////////////////////////////////////////////////////////////////
    // Public member functions
    //////////////////////////////////////////////////////////////////////////

    // Get a handle to a an account token. Note, this token is an impersonation token.
    HANDLE
        HGetAccountToken(
              const WCHAR *     pcszAccountNameIn
            , const WCHAR *     pcszAccountPwdIn
            , const WCHAR *     pcszAccountDomainIn
            );

    // Check and see if this node can interoperate with the sponsor cluster.
    void
        CheckInteroperability( void );

    // Get a binding handle to the extrocluster join interface and store it.
    void
        InitializeJoinBinding( void );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Node Id of this node.
    CStr                            m_strNodeId;

    // Token for the cluster service account.
    SmartAccountToken               m_satServiceAccountToken;

    // Binding handle to the extrocluster join interface.
    SmartRpcBinding                 m_srbJoinBinding;

    // A smart pointer to a CClusSvcAccountConfig object.
    SmartAccountConfigPtr           m_spacAccountConfigAction;

}; //*** class CBaseClusterJoin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdbcleanup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusDBCleanup.h
//
//  Description:
//      Header file for CClusDBCleanup class.
//      The CClusDBCleanup class is an action that cleans up the cluster database.
//
//  Implementation Files:
//      CClusDBCleanup.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 01-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CClusDB base class
#include "CClusDB.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterCleanup;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusDBCleanup
//
//  Description:
//      The CClusDBCleanup class is an action that clean up the cluster database.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusDBCleanup : public CClusDB
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusDBCleanup( CBaseClusterCleanup * pbccParentActionIn );

    // Default destructor.
    ~CClusDBCleanup();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Clean up the ClusDB service.
    //
    void Commit();

    //
    // Rollback this cleanup.
    //
    void Rollback();


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CClusDB BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

}; //*** class CClusDBCleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdbcleanup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CClusDBCleanup.cpp
//
//  Description:
//      Contains the definition of the CClusDBCleanup class.
//
//  Documentation:
//      TODO: Add pointer to external documentation later.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 01-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header for this file
#include "CClusDBCleanup.h"

// For the CBaseClusterCleanup class.
#include "CBaseClusterCleanup.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBCleanup::CClusDBCleanup()
//
//  Description:
//      Constructor of the CClusDBCleanup class
//
//  Arguments:
//      pbccParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusDBCleanup::CClusDBCleanup( CBaseClusterCleanup * pbccParentActionIn )
    : BaseClass( pbccParentActionIn )
{

    BCATraceScope( "" );

    // It is currently not possible to rollback a cleanup.
    SetRollbackPossible( false );

} //*** CClusDBCleanup::CClusDBCleanup()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBCleanup::~CClusDBCleanup( void )
//
//  Description:
//      Destructor of the CClusDBCleanup class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDBCleanup::~CClusDBCleanup( void )
{
    BCATraceScope( "" );

} //*** CClusDBCleanup::~CClusDBCleanup()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDBCleanup::Commit( void )
//
//  Description:
//      Cleanup the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBCleanup::Commit( void )
{
    BCATraceScope( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    // Cleanup the cluster database.
    CleanupHive();

    // If we are here, then everything went well.
    SetCommitCompleted( true );

} //*** CClusDBCleanup::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDBCleanup::Rollback( void )
//
//  Description:
//      Rollback the cleanup the database. This is currently not supported.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBCleanup::Rollback( void )
{
    BCATraceScope( "" );

    // Call the base class rollback method. This will throw an exception since
    // SetRollbackPossible( false ) was called in the constructor.

    BaseClass::Rollback();

    SetCommitCompleted( false );

} //*** CClusDBCleanup::Rollback()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdisk.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusDisk.h
//
//  Description:
//      Header file for CClusDisk class.
//      The CClusDisk class performs operations that are common to the 
//      configuration of the ClusDisk service.
//
//  Implementation Files:
//      CClusDisk.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CAction base class
#include "CAction.h"

// For the CService class
#include "CService.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterAction;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusDisk
//
//  Description:
//      The CClusDisk class performs operations that are common to many
//      configuration tasks of the ClusDisk service.
//
//      This class is intended to be used as the base class for other ClusDisk
//      related action classes.
//
//      NOTE: Currently, once started, the ClusDisk service cannot be stopped.
//      As a result, when a computer is evicted from a cluster, the ClusDisk
//      service is disabled and detached from all disks, but not stopped.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusDisk : public CAction
{
protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusDisk(
          CBaseClusterAction * pbcaParentActionIn
        );

    // Default destructor.
    ~CClusDisk();


    //////////////////////////////////////////////////////////////////////////
    // Protected methods
    //////////////////////////////////////////////////////////////////////////

    // Enable and start service.
    void
        ConfigureService();

    // Disable and cleanup the service.
    void
        CleanupService();


    // Initialize the state of the service.
    bool
        FInitializeState();


    // Detach ClusDisk from all disks it is attached to.
    void
        DetachFromAllDisks();

    // Attach to specified disks.
    void
        AttachToDisks(
          DWORD   rgdwSignatureArrayIn[]
        , UINT    uiArraySizeIn
        );

    // Detach from specified disks.
    void
        DetachFromDisks(
          DWORD   rgdwSignatureArrayIn[]
        , UINT    uiArraySizeIn
        );

    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        // Two notifications are sent:
        // 1. When the service is created.
        // 2. When the service starts.
        return 2;
    }


    //////////////////////////////////////////////////////////////////////////
    // Protected accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the ClusDisk service object.
    CService &
        RcsGetService() throw()
    {
        return m_cservClusDisk;
    }

    // Get the parent action
    CBaseClusterAction *
        PbcaGetParent() throw()
    {
        return m_pbcaParentAction;
    }

    // Get the handle to the ClusDisk service.
    SC_HANDLE
        SchGetServiceHandle() const throw()
    {
        return m_sscmhServiceHandle.HHandle();
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CClusDisk( const CClusDisk & );

    // Assignment operator
    const CClusDisk & operator =( const CClusDisk & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // The CService object representing the ClusDisk service.
    CService                m_cservClusDisk;

    // A handle to this service.
    SmartSCMHandle          m_sscmhServiceHandle;

    // Pointer to the base cluster action of which this action is a part.
    CBaseClusterAction *    m_pbcaParentAction;

}; //*** class CClusDisk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdbjoin.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CClusDBJoin.cpp
//
//  Description:
//      Contains the definition of the CClusDBJoin class.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header for this file
#include "CClusDBJoin.h"

// For the CBaseClusterJoin class.
#include "CBaseClusterJoin.h"

// For the CImpersonateUser class.
#include "CImpersonateUser.h"

// For ClRtlGetSuiteType()
#include "clusrtl.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBJoin::CClusDBJoin()
//
//  Description:
//      Constructor of the CClusDBJoin class
//
//  Arguments:
//      m_pcjClusterJoinIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDBJoin::CClusDBJoin( CBaseClusterJoin * pcjClusterJoinIn )
    : BaseClass( pcjClusterJoinIn )
    , m_pcjClusterJoin( pcjClusterJoinIn )
    , m_fHasNodeBeenAddedToSponsorDB( false )
{

    BCATraceScope( "" );

    SetRollbackPossible( true );

} //*** CClusDBJoin::CClusDBJoin()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBJoin::~CClusDBJoin()
//
//  Description:
//      Destructor of the CClusDBJoin class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDBJoin::~CClusDBJoin()
{
    BCATraceScope( "" );

} //*** CClusDBJoin::~CClusDBJoin()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDBJoin::Commit()
//
//  Description:
//      Create the cluster database. If anything goes wrong with the creation,
//      cleanup the tasks already done.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBJoin::Commit( void )
{
    BCATraceScope( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    //
    // Perform a ClusDB cleanup just to make sure that we do not use some files left over
    // from a previous install, aborted uninstall, etc.
    //

    LogMsg( "Cleaning up old cluster database files that may already exist before starting creation." );

    {
        CStatusReport   srCleanDB(
              PbcaGetParent()->PBcaiGetInterfacePointer()
            , TASKID_Major_Configure_Cluster_Services
            , TASKID_Minor_Cleaning_Up_Cluster_Database
            , 0, 1
            , IDS_TASK_CLEANINGUP_CLUSDB
            );

        // Send the next step of this status report.
        srCleanDB.SendNextStep( S_OK );

        CleanupHive();

        // Send the last step of this status report.
        srCleanDB.SendNextStep( S_OK );
    }

    try
    {
        // Create the cluster database
        Create();

    } // try:
    catch( ... )
    {
        // If we are here, then something went wrong with the create.

        BCATraceMsg( "Caught exception during commit." );

        //
        // Cleanup anything that the failed join might have done.
        // Catch any exceptions thrown during Cleanup to make sure that there
        // is no collided unwind.
        //
        try
        {
            // Cleanup the database.
            Cleanup();
        }
        catch( ... )
        {
            //
            // The rollback of the committed action has failed.
            // There is nothing that we can do.
            // We certainly cannot rethrow this exception, since
            // the exception that caused the rollback is more important.
            //

            THR( E_UNEXPECTED );

            BCATraceMsg( "Caught exception during cleanup." );
            LogMsg( "THIS COMPUTER MAY BE IN AN INVALID STATE. An error has occurred during cleanup." );

        } // catch: all

        // Rethrow the exception thrown by commit.
        throw;

    } // catch: all

    // If we are here, then everything went well.
    SetCommitCompleted( true );

} //*** CClusDBJoin::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDBJoin::Rollback()
//
//  Description:
//      Unload the cluster hive and cleanup any associated files.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBJoin::Rollback( void )
{
    BCATraceScope( "" );

    // Call the base class rollback method.
    BaseClass::Rollback();

    // Undo the actions performed by.
    Cleanup();

    SetCommitCompleted( false );

} //*** CClusDBJoin::Rollback()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDBJoin::Create()
//
//  Description:
//      Create the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the called functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBJoin::Create( void )
{
    BCATraceScope( "" );
    LogMsg( "Attempting to create the cluster database required to join a cluster." );

    DWORD               dwError = ERROR_SUCCESS;
    SmartFileHandle     sfhClusDBFile;


    {
        //
        // Get the full path and name of the cluster database file.
        //
        CStr                strClusterHiveFileName( PbcaGetParent()->RStrGetClusterInstallDirectory() );
        strClusterHiveFileName += L"\\" CLUSTER_DATABASE_NAME;

        BCATraceMsg1( "The cluster hive backing file is '%s'.", strClusterHiveFileName.PszData() );


        //
        // Create the cluster database file.
        //
        sfhClusDBFile.Assign(
            CreateFile(
                  strClusterHiveFileName.PszData()
                , GENERIC_READ | GENERIC_WRITE
                , 0
                , NULL
                , CREATE_ALWAYS
                , 0
                , NULL
                )
            );

        if ( sfhClusDBFile.FIsInvalid() )
        {
            dwError = TW32( GetLastError() );
            LogMsg( "Error %#08x occurred trying to create the cluster database file.", dwError );
            BCATraceMsg1( "Error %#08x occurred trying to create the cluster database file. Throwing exception.", dwError );
            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_JOIN_SYNC_DB );
        } // if: CreateFile() failed

        // Store the file handle just obtained in a member variable so that it can be used during Synchronize()
        // Note, this file is closed when sfhClusDBFile goes out of scope, so m_hClusDBFile should not be used
        // outside this function or any function that this function calls.
        m_hClusDBFile = sfhClusDBFile.HHandle();
    }


    //
    // In the scope below, the cluster service account is impersonated, so that we can communicate with the
    // sponsor cluster
    //
    {
        BCATraceMsg( "Attempting to impersonate the cluster service account." );

        // Impersonate the cluster service account, so that we can contact the sponsor cluster.
        // The impersonation is automatically ended when this object is destroyed.
        CImpersonateUser ciuImpersonateClusterServiceAccount( m_pcjClusterJoin->HGetClusterServiceAccountToken() );


        // Add this node to the sponsor cluster database
        do
        {
            DWORD dwSuiteType = ClRtlGetSuiteType();

            m_fHasNodeBeenAddedToSponsorDB = false;

            BCATraceMsg2( "Trying to add node '%s' (suite type %d) to the sponsor cluster database.",
                  m_pcjClusterJoin->PszGetNodeName()
                , dwSuiteType
                );

            dwError = TW32( JoinAddNode3(
                                  m_pcjClusterJoin->RbhGetJoinBindingHandle()
                                , m_pcjClusterJoin->PszGetNodeName()
                                , m_pcjClusterJoin->DwGetNodeHighestVersion()
                                , m_pcjClusterJoin->DwGetNodeLowestVersion()
                                , dwSuiteType
                                ) );

            if ( dwError != ERROR_SUCCESS )
            {
                BCATraceMsg( "JoinAddNode3 has failed." );
                break;
            } // if: JoinAddNode3() failed

            // Set the flag that indicates that the sponsor database has been modified, so that
            // we can undo this if we need to rollback or cleanup.
            m_fHasNodeBeenAddedToSponsorDB = true;
        }
        while( false ); // dummy do while loop to avoid gotos.

        if ( dwError != ERROR_SUCCESS )
        {
            LogMsg( "Error %#08x occurred trying to add this node to the sponsor cluster database.", dwError );
            BCATraceMsg1( "Error %#08x occurred trying to add this node to the sponsor cluster database. Throwing exception.", dwError );
            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_JOINING_SPONSOR_DB );
        } // if: something has gone wrong

        BCATraceMsg( "This node has been successfully added to the sponsor cluster database." );

        // Get the node id of the newly formed node.
        do
        {
            // Smart handle to sponsor cluster
            SmartClusterHandle  schSponsorCluster;

            // Smart handle to this node
            SmartNodeHandle     snhThisNodeHandle;

            //
            // Get a handle to the sponsor cluster.
            //
            {
                BCATraceMsg( "Trying to open a handle to the sponsor cluster." );

                // Open a handle to the sponsor cluster.
                HCLUSTER hSponsorCluster = OpenCluster( m_pcjClusterJoin->RStrGetClusterBindingString().PszData() );

                // Assign it to a smart handle for safe release.
                schSponsorCluster.Assign( hSponsorCluster );
            }

            // Did we succeed in opening a handle to the sponsor cluster?
            if ( schSponsorCluster.FIsInvalid() )
            {
                dwError = TW32( GetLastError() );
                BCATraceMsg( "An error occurred trying to open a handle to the sponsor cluster." );
                break;
            } // if: OpenCluster() failed


            //
            // Get a handle to this node.
            //
            {
                BCATraceMsg( "Trying to open a handle to this node." );

                // Open a handle to this node.
                HNODE hThisNode = OpenClusterNode( schSponsorCluster.HHandle(), m_pcjClusterJoin->PszGetNodeName() );

                // Assign it to a smart handle for safe release.
                snhThisNodeHandle.Assign( hThisNode );
            }

            // Did we succeed in opening a handle to this node?
            if ( snhThisNodeHandle.FIsInvalid() )
            {
                dwError = TW32( GetLastError() );
                BCATraceMsg( "An error occurred trying to open a handle to this node." );
                break;
            } // if: OpenClusterNode() failed

            // Get the node id string.
            {
                DWORD       cchIdSize = 0;
                SmartSz     sszNodeId;

                dwError = GetClusterNodeId(
                                  snhThisNodeHandle.HHandle()
                                , NULL
                                , &cchIdSize
                                );

                if ( ( dwError != ERROR_SUCCESS ) && ( dwError != ERROR_MORE_DATA ) )
                {
                    TW32( dwError );
                    BCATraceMsg( "GetClusterNodeId() could not get the required length of the node id buffer.");
                    break;
                } // if: GetClusterNodeId() failed

                // cchIdSize returned by the above call is the count of characters and does not include the space for
                // the terminating NULL.
                ++cchIdSize;

                sszNodeId.Assign( new WCHAR[ cchIdSize ] );
                if ( sszNodeId.FIsEmpty() )
                {
                    dwError = TW32( ERROR_OUTOFMEMORY );
                    BCATraceMsg1( "A memory allocation failure occurred trying to allocate %d characters.", cchIdSize );
                    break;
                } // if: memory allocation failed

                dwError = TW32( GetClusterNodeId(
                                      snhThisNodeHandle.HHandle()
                                    , sszNodeId.PMem()
                                    , &cchIdSize
                                    ) );

                if ( dwError != ERROR_SUCCESS )
                {
                    BCATraceMsg( "GetClusterNodeId() failed to get the node id of this node.");
                    break;
                } // if: GetClusterNodeId() failed

                BCATraceMsg1( "The node id of this node is '%s'.", sszNodeId.PMem() );

                // Set the node id for later use.
                m_pcjClusterJoin->SetNodeIdString( sszNodeId.PMem() );
            }

        }
        while( false ); // dummy do while loop to avoid gotos.

        if ( dwError != ERROR_SUCCESS )
        {
            LogMsg( "Error %#08x occurred trying to get the node id of this node.", dwError );
            BCATraceMsg1( "Error %#08x occurred trying to get the node id of this node. Throwing exception.", dwError );
            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_GET_NEW_NODE_ID );
        } // if: something has gone wrong


        {
            CStatusReport   srSyncDB(
                  PbcaGetParent()->PBcaiGetInterfacePointer()
                , TASKID_Major_Configure_Cluster_Services
                , TASKID_Minor_Join_Sync_Cluster_Database
                , 0, 1
                , IDS_TASK_JOIN_SYNC_CLUSDB
                );

            // Send the next step of this status report.
            srSyncDB.SendNextStep( S_OK );

            // Synchronize the cluster database.
            Synchronize();

            // Send the last step of this status report.
            srSyncDB.SendNextStep( S_OK );
        }
    }

    LogMsg( "The cluster database has been successfully created and synchronized with the sponsor cluster." );

} //*** CClusDBJoin::Create()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDBJoin::Cleanup()
//
//  Description:
//      Cleanup the effects of Create()
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the called functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBJoin::Cleanup( void )
{
    BCATraceScope( "" );
    LogMsg( "Attempting to cleanup the cluster database." );

    DWORD               dwError = ERROR_SUCCESS;

    //
    // Check if we added this node to the sponsor cluster database. If so, remove it from there.
    //
    if ( m_fHasNodeBeenAddedToSponsorDB )
    {
        BCATraceMsg( "Attempting to impersonate the cluster service account." );

        // Impersonate the cluster service account, so that we can contact the sponsor cluster.
        // The impersonation is automatically ended when this object is destroyed.
        CImpersonateUser ciuImpersonateClusterServiceAccount( m_pcjClusterJoin->HGetClusterServiceAccountToken() );


        // Remove this node from the sponsor cluster database
        do
        {
            // Smart handle to sponsor cluster
            SmartClusterHandle  schSponsorCluster;

            // Smart handle to this node
            SmartNodeHandle     snhThisNodeHandle;

            //
            // Get a handle to the sponsor cluster.
            //
            {
                BCATraceMsg( "Trying to open a handle to the sponsor cluster." );

                // Open a handle to the sponsor cluster.
                HCLUSTER hSponsorCluster = OpenCluster( m_pcjClusterJoin->RStrGetClusterBindingString().PszData() );

                // Assign it to a smart handle for safe release.
                schSponsorCluster.Assign( hSponsorCluster );
            }

            // Did we succeed in opening a handle to the sponsor cluster?
            if ( schSponsorCluster.FIsInvalid() )
            {
                dwError = TW32( GetLastError() );
                BCATraceMsg( "An error occurred trying to open a handle to the sponsor cluster." );
                break;
            } // if: OpenCluster() failed


            //
            // Get a handle to this node.
            //
            {
                BCATraceMsg( "Trying to open a handle to this node." );

                // Open a handle to this node.
                HNODE hThisNode = OpenClusterNode( schSponsorCluster.HHandle(), m_pcjClusterJoin->PszGetNodeName() );

                if ( hThisNode == NULL )
                {
                    dwError = TW32( GetLastError() );
                    BCATraceMsg( "An error has occurred trying to open a handle to this node." );
                    break;
                } // if: OpenClusterNode() failed.

                // Assign it to a smart handle for safe release.
                snhThisNodeHandle.Assign( hThisNode );
            }

            dwError = TW32( EvictClusterNode( snhThisNodeHandle.HHandle() ) );
            if ( dwError != ERROR_SUCCESS )
            {
                BCATraceMsg( "An error has occurred trying to evict this node from the sponsor cluster." );
                break;
            } // if: EvictClusterNode() failed
        }
        while( false ); // dummy do while loop to avoid gotos.

        if ( dwError != ERROR_SUCCESS )
        {
            LogMsg( "Error %#08x occurred trying to remove this node from the sponsor cluster database.", dwError );
            BCATraceMsg1( "Error %#08x occurred trying to remove this node from the sponsor cluster database. Throwing exception.", dwError );
            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_EVICTING_NODE );
        } // if: something has gone wrong

        BCATraceMsg( "This node has been successfully removed from the sponsor cluster database." );
    } // if: we had added this node to the sponsor cluster database

    // Cleanup  the cluster hive
    CleanupHive();

} //*** Cleanup()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDBJoin::Synchronize()
//
//  Description:
//      Synchronize the cluster database with the sponsor cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the called functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBJoin::Synchronize( void )
{
    BCATraceScope( "" );
    LogMsg( "Attempting to synchronize the cluster database with the sponsor cluster." );

    DWORD               dwError = ERROR_SUCCESS;

    do
    {
        //
        // Initialize the byte pipe.
        //

        m_bpBytePipe.state = reinterpret_cast< char * >( this );
        m_bpBytePipe.alloc = S_BytePipeAlloc;
        m_bpBytePipe.push = S_BytePipePush;
        m_bpBytePipe.pull = S_BytePipePull;


        //
        // Synchronize the database
        //
        dwError = TW32( DmSyncDatabase( m_pcjClusterJoin->RbhGetJoinBindingHandle(), m_bpBytePipe ) );
        if ( dwError != ERROR_SUCCESS )
        {
            BCATraceMsg( "An error occurred trying to suck the database down from the sponsor cluster." );
            break;
        } // if: DmSyncDatabase() failed

    }
    while( false ); // Dummy do-while loop to avoid gotos.

    if ( dwError != ERROR_SUCCESS )
    {
        LogMsg( "Error %#08x occurred trying to synchronize the cluster database with the sponsor cluster.", dwError );
        BCATraceMsg1( "Error %#08x occurred trying trying to synchronize the cluster database with the sponsor cluster. Throwing exception.", dwError );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_JOIN_SYNC_DB );
    } // if: something has gone wrong

    LogMsg( "The cluster database has been synchronized with the sponsor cluster." );

} //*** Synchronize()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  static void
//  CClusDBJoin::S_BytePipePush()
//
//  Description:
//      Callback function used by RPC to push data.
//
//  Arguments:
//      pchStateIn
//          State of the byte pipe
//
//      pchBufferIn
//      ulBufferSizeIn
//          Buffer contained the pushed data and its size.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      RPC Exceptions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBJoin::S_BytePipePush(
      char *                pchStateIn
    , unsigned char *       pchBufferIn
    , unsigned long         ulBufferSizeIn
    )
{
    CClusDBJoin * pThis = reinterpret_cast< CClusDBJoin * >( pchStateIn );

    if ( ulBufferSizeIn != 0 )
    {
        DWORD   dwBytesWritten;

        if (    WriteFile(
                      pThis->m_hClusDBFile
                    , pchBufferIn
                    , ulBufferSizeIn
                    , &dwBytesWritten
                    , NULL
                    )
             == 0
           )
        {
            DWORD   dwError = GetLastError();
            RpcRaiseException( dwError );
        } // if: WriteFile() failed

    } // if: the buffer is non-empty

} //*** CClusDBJoin::S_BytePipePush()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  static void
//  CClusDBJoin::S_BytePipePull()
//
//  Description:
//      Callback function used by RPC to pull data.
//
//  Arguments:
//      pchStateIn
//          State of the byte pipe
//
//      pchBufferIn
//      ulBufferSizeIn
//          Buffer contained the pushed data and its size.
//
//      pulWrittenOut
//          Pointer to the number of bytes actually filled into the buffer.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      RPC Exceptions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBJoin::S_BytePipePull(
      char *                pchStateIn
    , unsigned char *       pchBufferIn
    , unsigned long         ulBufferSizeIn
    , unsigned long *       pulWrittenOut
    )
{
    CClusDBJoin * pThis = reinterpret_cast< CClusDBJoin * >( pchStateIn );

    if ( ulBufferSizeIn != 0 )
    {
        if (    ReadFile(
                      pThis->m_hClusDBFile
                    , pchBufferIn
                    , ulBufferSizeIn
                    , pulWrittenOut
                    , NULL
                    )
             == 0
           )
        {
            DWORD   dwError = TW32( GetLastError() );
            RpcRaiseException( dwError );
        } // if: ReadFile() failed

    } // if:  the buffer is non-empty

} //*** CClusDBJoin::S_BytePipePull()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  static void
//  CClusDBJoin::S_BytePipeAlloc()
//
//  Description:
//      Callback function used by RPC to allocate a buffer.
//
//  Arguments:
//      pchStateIn
//          State of the file pipe
//
//      ulRequestedSizeIn
//          Requested size of the buffer

//      ppchBufferOut
//          Pointer to the buffer pointer
//
//      pulActualSizeOut
//          Pointer to the actual size of the allocated buffer
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBJoin::S_BytePipeAlloc(
      char *                pchStateIn
    , unsigned long         ulRequestedSizeIn
    , unsigned char **      ppchBufferOut
    , unsigned long  *      pulActualSizeOut
    )
{
    CClusDBJoin * pThis = reinterpret_cast< CClusDBJoin * >( pchStateIn );

    *ppchBufferOut = reinterpret_cast< unsigned char * >( pThis->m_rgbBytePipeBuffer );
    *pulActualSizeOut = ( ulRequestedSizeIn < pThis->ms_nFILE_PIPE_BUFFER_SIZE ) ? ulRequestedSizeIn : pThis->ms_nFILE_PIPE_BUFFER_SIZE;

} //*** CClusDBJoin::S_BytePipeAlloc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdbform.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusDBForm.h
//
//  Description:
//      Header file for CClusDBForm class.
//      The CClusDBForm class is an action that creates the cluster database
//      during a cluster formation.
//
//  Implementation Files:
//      CClusDBForm.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CClusDB base class
#include "CClusDB.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterForm;



//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusDBForm
//
//  Description:
//      The CClusDBForm class is an action that creates the cluster database
//      during a cluster formation.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusDBForm : public CClusDB
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusDBForm( CBaseClusterForm * pcfClusterFormIn );

    // Default destructor.
    ~CClusDBForm();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Create the ClusDB.
    //
    void Commit();

    //
    // Rollback this creation.
    //
    void Rollback();


    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        //
        // The three notifications are:
        // 1. Cleaning up any old cluster database files that may exist.
        // 2. Creating cluster database.
        // 3. Customizing cluster database.
        //
        return 3;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CClusDB BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private methods
    //////////////////////////////////////////////////////////////////////////

    // Create the cluster database.
    void Create();

    // Make the entries required by the cluster service in the hive.
    void PopulateHive( CBaseClusterForm * pcfClusterFormIn );

    // Customize the cluster group and the core resources.
    void CustomizeClusterGroup(
          CBaseClusterForm * pcfClusterFormIn
        , CRegistryKey &     rkClusterHiveRootIn
        );

}; //*** class CClusDBForm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdiskcleanup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CClusDiskCleanup.cpp
//
//  Description:
//      Contains the definition of the CClusDiskCleanup class.
//
//  Documentation:
//      TODO: Add pointer to external documentation later.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 01-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header for this file
#include "CClusDiskCleanup.h"

// For the CBaseClusterCleanup class.
#include "CBaseClusterCleanup.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDiskCleanup::CClusDiskCleanup()
//
//  Description:
//      Constructor of the CClusDiskCleanup class
//
//  Arguments:
//      pbccParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusDiskCleanup::CClusDiskCleanup( CBaseClusterCleanup * pbccParentActionIn )
    : BaseClass( pbccParentActionIn )
{

    BCATraceScope( "" );

    // It is currently not possible to rollback a cleanup.
    SetRollbackPossible( false );

} //*** CClusDiskCleanup::CClusDiskCleanup()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDiskCleanup::~CClusDiskCleanup()
//
//  Description:
//      Destructor of the CClusDiskCleanup class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDiskCleanup::~CClusDiskCleanup()
{
    BCATraceScope( "" );

} //*** CClusDiskCleanup::~CClusDiskCleanup()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDiskCleanup::Commit( void )
//
//  Description:
//      Clean up the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDiskCleanup::Commit( void )
{
    BCATraceScope( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    // Cleanup the ClusDisk service.
    CleanupService();

    // If we are here, then everything went well.
    SetCommitCompleted( true );

} //*** CClusDiskCleanup::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDiskCleanup::Rollback( void )
//
//  Description:
//      Rollback the cleanup the service. This is currently not supported.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDiskCleanup::Rollback( void )
{
    BCATraceScope( "" );

    // Call the base class rollback method. This will throw an exception since
    // SetRollbackPossible( false ) was called in the constructor.

    BaseClass::Rollback();

    SetCommitCompleted( false );

} //*** CClusDiskCleanup::Rollback()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdbform.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CClusDBForm.cpp
//
//  Description:
//      Contains the definition of the CClusDBForm class.
//
//  Documentation:
//      TODO: Add pointer to external documentation later.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// For cluster registry key and value names.
#include "clusudef.h"

// For ClRtlSetObjSecurityInfo() and other functions.
#include "clusrtl.h"

// The header for this file
#include "CClusDBForm.h"

// For the CBaseClusterForm class.
#include "CBaseClusterForm.h"

// For UUID related utilities.
#include "CUuid.h"

// For CEnableThreadPrivilege
#include "CEnableThreadPrivilege.h"

// For the CStr class.
#include "CStr.h"

// For sending status reports.
#include "CStatusReport.h"

// For DwRemoveDirectory()
#include "Common.h"

// For inet_ntoa
#include <winsock2.h>


//////////////////////////////////////////////////////////////////////////
// Macros definitions
//////////////////////////////////////////////////////////////////////////

// Section in the INF file that deals with populating the cluster hive.
#define CLUSDB_POPULATE_INF_SECTION_NAME                L"ClusDB_Form"

// A placeholder for the cluster group key name in the cluster registry.
#define CLUSREG_KEYNAME_CLUSTERGROUP_PLACEHOLDER        L"ClusterGroupGUIDPlaceholder"

// A placeholder for the cluster name resource key name in the cluster registry.
#define CLUSREG_KEYNAME_CLUSTERNAME_RES_PLACEHOLDER     L"ClusterNameResGUIDPlaceHolder"

// A placeholder for the cluster IP address resource key name in the cluster registry.
#define CLUSREG_KEYNAME_CLUSTERIP_RES_PLACEHOLDER       L"ClusterIPAddrResGUIDPlaceHolder"

// A placeholder for the local quorum resource key name in the cluster registry.
#define CLUSREG_KEYNAME_LOCALQUORUM_RES_PLACEHOLDER     L"LocalQuorumResGUIDPlaceHolder"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBForm::CClusDBForm()
//
//  Description:
//      Constructor of the CClusDBForm class
//
//  Arguments:
//      pfaParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDBForm::CClusDBForm( CBaseClusterForm * pfaParentActionIn )
    : BaseClass( pfaParentActionIn )
{

    BCATraceScope( "" );

    SetRollbackPossible( true );

} //*** CClusDBForm::CClusDBForm()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBForm::~CClusDBForm()
//
//  Description:
//      Destructor of the CClusDBForm class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDBForm::~CClusDBForm( void )
{
    BCATraceScope( "" );

} //*** CClusDBForm::~CClusDBForm()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDBForm::Commit()
//
//  Description:
//      Create the cluster database. If anything goes wrong with the creation,
//      cleanup the tasks already done.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBForm::Commit( void )
{
    BCATraceScope( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    //
    // Perform a ClusDB cleanup just to make sure that we do not use some files left over
    // from a previous install, aborted uninstall, etc.
    //

    LogMsg( "Cleaning up old cluster database files that may already exist before starting creation." );

    {
        CStatusReport   srCleanDB(
              PbcaGetParent()->PBcaiGetInterfacePointer()
            , TASKID_Major_Configure_Cluster_Services
            , TASKID_Minor_Cleaning_Up_Cluster_Database
            , 0, 1
            , IDS_TASK_CLEANINGUP_CLUSDB
            );

        // Send the next step of this status report.
        srCleanDB.SendNextStep( S_OK );

        CleanupHive();

        // Send the last step of this status report.
        srCleanDB.SendNextStep( S_OK );
    }

    try
    {
        // Create the cluster database
        Create();
        
    } // try:
    catch( ... )
    {
        // If we are here, then something went wrong with the create.

        BCATraceMsg( "Caught exception during commit." );

        //
        // Cleanup anything that the failed form might have done.
        // Catch any exceptions thrown during Cleanup to make sure that there 
        // is no collided unwind.
        //
        try
        {
            CleanupHive();
        }
        catch( ... )
        {
            //
            // The rollback of the committed action has failed.
            // There is nothing that we can do.
            // We certainly cannot rethrow this exception, since
            // the exception that caused the rollback is more important.
            //
            THR( E_UNEXPECTED );

            BCATraceMsg( "Caught exception during cleanup." );
            LogMsg( "THIS COMPUTER MAY BE IN AN INVALID STATE. An error has occurred during cleanup." );
        } // catch: all

        // Rethrow the exception thrown by commit.
        throw;

    } // catch: all

    // If we are here, then everything went well.
    SetCommitCompleted( true );

} //*** CClusDBForm::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDBForm::Rollback()
//
//  Description:
//      Unload the cluster hive and cleanup any associated files.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBForm::Rollback( void )
{
    BCATraceScope( "" );

    // Call the base class rollback method. 
    BaseClass::Rollback();

    // Cleanup the cluster database.
    CleanupHive();

    SetCommitCompleted( false );

} //*** CClusDBForm::Rollback()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDBForm::Create()
//
//  Description:
//      Create the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CAssert
//          The parent action of this action is not CBaseClusterForm
//
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the called functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBForm::Create( void )
{
    BCATraceScope( "" );
    LogMsg( "Attempting to create the cluster database required to form a cluster." );

    DWORD               dwError = ERROR_SUCCESS;

    OBJECT_ATTRIBUTES   oaClusterHiveKey;
    OBJECT_ATTRIBUTES   oaClusterHiveFile;

    HRESULT             hrStatus = STATUS_SUCCESS;

    // Get the parent action pointer.
    CBaseClusterForm *  pcfClusterForm = dynamic_cast< CBaseClusterForm *>( PbcaGetParent() );

    CStatusReport       srCustomizingDB(
          PbcaGetParent()->PBcaiGetInterfacePointer()
        , TASKID_Major_Configure_Cluster_Services
        , TASKID_Minor_Form_Customizing_Cluster_Database
        , 0, 1
        , IDS_TASK_FORM_CUSTOMIZING_CLUSDB
        );

    // If the parent action of this action is not CBaseClusterForm
    if ( pcfClusterForm == NULL )
    {
        THROW_ASSERT( E_POINTER, "The parent action of this action is not CBaseClusterForm." );
    } // an invalid pointer was passed in.

    // Create the cluster hive.
    {
        CStatusReport   srCreatingDB(
              PbcaGetParent()->PBcaiGetInterfacePointer()
            , TASKID_Major_Configure_Cluster_Services
            , TASKID_Minor_Form_Creating_Cluster_Database
            , 0, 1
            , IDS_TASK_FORM_CREATING_CLUSDB
            );

        // Send the next step of this status report.
        srCreatingDB.SendNextStep( S_OK );

        // Create an empty cluster hive in the registry.
        CreateHive( pcfClusterForm );

        // Send the last step of this status report.
        srCreatingDB.SendNextStep( S_OK );
    }

    // Send the next step of this status report.
    srCustomizingDB.SendNextStep( S_OK );

    // Fill up the newly created hive.
    PopulateHive( pcfClusterForm );

    //
    // Create the quorum directory and set its security attributes.
    //
    do
    {
        HANDLE          hQuorumDirHandle;
        const WCHAR *   pcszQuorumDir = pcfClusterForm->RStrGetLocalQuorumDirectory().PszData();

        // First, remove the local quorum directory, if it exists.
        dwError = TW32( DwRemoveDirectory( pcszQuorumDir ) );
        if ( dwError != ERROR_SUCCESS )
        {
            BCATraceMsg2( "The local quorum directory '%s' already exists, but error %#x occurred trying to remove it.\n", pcszQuorumDir, dwError );
            LogMsg( "The local quorum directory '%s' already exists, but error %#x occurred trying to remove it.\n", pcszQuorumDir, dwError );
            break;
        } // if: we could not remove the local quorum directory

        if ( CreateDirectory( pcszQuorumDir, NULL ) == FALSE )
        {
            dwError = TW32( GetLastError() );
            BCATraceMsg1( "Failed to create directory '%ws'", pcszQuorumDir );
            break;
        } // if: the localquorum directory could not be created

        //
        // Enable the SE_BACKUP_PRIVILEGE and SE_RESTORE_PRIVILEGE.
        //
        // What we are doing here is that we are creating an object of
        // type CEnableThreadPrivilege. This object enables the privilege
        // in the constructor and restores it to its original state in the destructor.
        //

        CEnableThreadPrivilege etpAcquireBackupPrivilege( SE_BACKUP_NAME );
        CEnableThreadPrivilege etpAcquireRestorePrivilege( SE_RESTORE_NAME );

        //
        // Open a handle to the quorum directory. The calling thread should have SE_BACKUP_PRIVILEGE and
        // SE_RESTORE_PRIVILEGE enabled.
        //
        hQuorumDirHandle = CreateFile(
                              pcszQuorumDir
                            , GENERIC_ALL
                            , FILE_SHARE_WRITE
                            , NULL
                            , OPEN_EXISTING
                            , FILE_FLAG_BACKUP_SEMANTICS
                            , NULL 
                            );

        if ( hQuorumDirHandle == INVALID_HANDLE_VALUE )
        {
            // The directory does not exist. This is an error.
            dwError = TW32( GetLastError() );
            BCATraceMsg1( "The directory '%ws' does not exist.", pcszQuorumDir );
            break;
        } // if: the quorum directory does not exist.

        // Set the security for this directory.
        dwError = TW32( ClRtlSetObjSecurityInfo(
                              hQuorumDirHandle
                            , SE_FILE_OBJECT
                            , GENERIC_ALL
                            , GENERIC_ALL
                            , GENERIC_READ
                            ) );

        // First close the handle we opened.
        CloseHandle( hQuorumDirHandle );

        if ( dwError != ERROR_SUCCESS )
        {
            // ClRtlSetObjSecurityInfo() failed.
            BCATraceMsg( "ClRtlSetObjSecurityInfo() failed." );
            break;
        } // if: ClRtlSetObjSecurityInfo() failed
    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( dwError != ERROR_SUCCESS )
    {
        LogMsg( "Error %#08x occurred while trying to create the local quorum directory.", dwError );
        BCATraceMsg1( "Error %#08x occurred while trying to create the local quorum directory. Throwing exception.", dwError );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_QUORUM_DIR_CREATE );
    } // if: something went wrong.

    // Send the last step of this status report.
    srCustomizingDB.SendNextStep( S_OK );

} //*** CClusDBForm::Create()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDBForm::PopulateHive()
//
//  Description:
//      Make the entries required by the cluster service in the hive.
//
//  Arguments:
//      pcfClusterFormIn
//          Pointer to the CBaseClusterForm object which contains this object.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the called functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBForm::PopulateHive( CBaseClusterForm * pcfClusterFormIn )
{
    BCATraceScope( "" );
    LogMsg( "Populating the cluster hive." );

    DWORD dwError = ERROR_SUCCESS;

    do
    {
        DWORD                   dwSDSize = 0;

        CRegistryKey rkClusterHiveRoot(
              HKEY_LOCAL_MACHINE
            , CLUSREG_KEYNAME_CLUSTER
            , KEY_ALL_ACCESS
            );

        if ( SetupInstallFromInfSection(
              NULL                                          // optional, handle of a parent window
            , pcfClusterFormIn->HGetMainInfFileHandle()     // handle to the INF file
            , CLUSDB_POPULATE_INF_SECTION_NAME              // name of the Install section
            , SPINST_REGISTRY                               // which lines to install from section
            , rkClusterHiveRoot.HGetKey()                   // optional, key for registry installs
            , NULL                                          // optional, path for source files
            , 0                                             // optional, specifies copy behavior
            , NULL                                          // optional, specifies callback routine
            , NULL                                          // optional, callback routine context
            , NULL                                          // optional, device information set
            , NULL                                          // optional, device info structure
            ) == FALSE
           )
        {
            dwError = TW32( GetLastError() );
            LogMsg( "Error %#08x occurred while trying to populate the cluster hive.", dwError );
            BCATraceMsg( "Setup API returned an error while trying to populate the cluster hive." );
            break;
        } // if: SetupInstallServicesFromInfSection failed

        LogMsg( "Basic hive structure created." );

        // Set the cluster name.
        rkClusterHiveRoot.SetValue(
              CLUSREG_NAME_CLUS_NAME
            , REG_SZ
            , reinterpret_cast< const BYTE * >( pcfClusterFormIn->RStrGetClusterNetBIOSName().PszData() )
            , ( pcfClusterFormIn->RStrGetClusterNetBIOSName().NGetLen() + 1 ) * sizeof( WCHAR )
            );

        //
        // Set the default cluster security descriptor.
        //
        {
            SECURITY_DESCRIPTOR *   psdSecurityDescriptor = NULL;

            // Form the security descriptor.
            dwError = TW32( ClRtlBuildDefaultClusterSD(
                                  pcfClusterFormIn->PSidGetServiceAccountSID()
                                , reinterpret_cast< void ** >( &psdSecurityDescriptor )
                                , &dwSDSize
                                ) );

            // Assign it to a smart pointer for safe release.
            CSmartResource<
                CHandleTrait< 
                      HLOCAL
                    , HLOCAL
                    , LocalFree
                    >
                >
                smartSD( reinterpret_cast< HLOCAL >( psdSecurityDescriptor ) );

            if ( dwError != ERROR_SUCCESS )
            {
                BCATraceMsg( "ClRtlBuildDefaultClusterSD() failed." );
                break;
            } // if: ClRtlBuildDefaultClusterSD() failed.

            // Set the security descriptor in the registry.
            rkClusterHiveRoot.SetValue(
                  CLUSREG_NAME_CLUS_SD
                , REG_BINARY
                , reinterpret_cast< const BYTE * >( psdSecurityDescriptor )
                , dwSDSize
                );

            // Set the NT4 version of the security descriptor in the registry.
            rkClusterHiveRoot.SetValue(
                  CLUSREG_NAME_CLUS_SECURITY
                , REG_BINARY
                , reinterpret_cast< const BYTE * >( psdSecurityDescriptor )
                , dwSDSize
                );
        }

        LogMsg( "Cluster common properties set." );

        //
        // Set the values under the HKLM\Cluster\Nodes key.
        //
        {
            DWORD   dwTemp;

            CRegistryKey rkNodesKey(
                  rkClusterHiveRoot.HGetKey()
                , CLUSREG_KEYNAME_NODES
                , KEY_WRITE
                );

            CRegistryKey rkThisNodeKey;

            // Create a subkey for this node.
            rkThisNodeKey.CreateKey(
                  rkNodesKey.HGetKey()
                , pcfClusterFormIn->PszGetNodeIdString()
                );

            // Set the node name.
            rkThisNodeKey.SetValue(
                  CLUSREG_NAME_NODE_NAME
                , REG_SZ
                , reinterpret_cast< const BYTE *>( pcfClusterFormIn->PszGetNodeName() )
                , ( pcfClusterFormIn->DwGetNodeNameLength() + 1 ) * sizeof( WCHAR )
                );

            // Set the node highest version.
            dwTemp = pcfClusterFormIn->DwGetNodeHighestVersion();
            rkThisNodeKey.SetValue(
                  CLUSREG_NAME_NODE_HIGHEST_VERSION
                , REG_DWORD
                , reinterpret_cast< const BYTE *>( &dwTemp )
                , sizeof( dwTemp )
                );

            // Set the node lowest version.
            dwTemp = pcfClusterFormIn->DwGetNodeLowestVersion();
            rkThisNodeKey.SetValue(
                  CLUSREG_NAME_NODE_LOWEST_VERSION
                , REG_DWORD
                , reinterpret_cast< const BYTE *>( &dwTemp )
                , sizeof( dwTemp )
                );
        }

        LogMsg( "Cluster node subtree customized." );

        // Customize the cluster group and the core resources.
        CustomizeClusterGroup( pcfClusterFormIn, rkClusterHiveRoot );

        // Flush the changes to the registry.
        RegFlushKey( rkClusterHiveRoot.HGetKey() );

        LogMsg( "Cluster hive successfully populated." );
    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( dwError != ERROR_SUCCESS )
    {
        LogMsg( "Error %#08x occurred while trying to populate the cluster hive.", dwError );
        BCATraceMsg1( "Error %#08x occurred while trying to populate the cluster hive. Throwing exception.", dwError );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_CLUSDB_POPULATE_HIVE );
    } // if: something went wrong.

} //*** CClusDBForm::PopulateHive()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDBForm::CustomizeClusterGroup()
//
//  Description:
//      Customize the cluster group and the core resources.
//
//  Arguments:
//      pcfClusterFormIn
//          Pointer to the CBaseClusterForm object which contains this object.
//
//      rkClusterHiveRootIn
//          A CRegistryKey object representing the  root of the cluster hive.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the called functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBForm::CustomizeClusterGroup(
      CBaseClusterForm * pcfClusterFormIn
    , CRegistryKey &     rkClusterHiveRootIn
    )
{
    BCATraceScope( "" );

    // UUIDs of the cluster group and core resources.
    CUuid           uuidClusterGroupUuid;
    CUuid           uuidClusterIPAddressResourceUuid;
    CUuid           uuidClusterNameResourceUuid;
    CUuid           uuidLocalQuorumResourceUuid;

    // The lengths of the string versions of the above UUIDs.
    UINT            uiGroupUuidLen          = wcslen( uuidClusterGroupUuid.PszGetUuidString() );
    UINT            uiIPUuidLen             = wcslen( uuidClusterIPAddressResourceUuid.PszGetUuidString() );
    UINT            uiNameUuidLen           = wcslen( uuidClusterNameResourceUuid.PszGetUuidString() );
    UINT            uiLocalQuorumUuidLen    = wcslen( uuidLocalQuorumResourceUuid.PszGetUuidString() );

    UINT            uiUuidLen;

    // Length of the multisz string that can hold the above resource UUIDs.
    uiUuidLen = 
        ( ( uiIPUuidLen + 1 )
        + ( uiNameUuidLen + 1 )
        + ( uiLocalQuorumUuidLen + 1 )
        + 1
        );

    // Allocate a buffer for this multisz string.
    SmartSz  sszResourceUuids( new WCHAR[ uiUuidLen ] );

    // Was the memory successfully allocated?
    if ( sszResourceUuids.FIsEmpty() )
    {
        BCATraceMsg1( "Could not allocate %d character in memory. Throwing an exception.", uiUuidLen );
        THROW_RUNTIME_ERROR(
              E_OUTOFMEMORY
            , IDS_ERROR_CUSTOMIZE_CLUSTER_GROUP
            );
    } // if: memory allocation failed.

    //
    // Fill this buffer with the uuids of the core resources.
    //

    // Make sure that the IP address uuid is the first string in this multisz string.
    // This is buffer is reused during setting of the network name dependency on the 
    // IP address resource.
    CopyMemory( 
          sszResourceUuids.PMem()
        , uuidClusterIPAddressResourceUuid.PszGetUuidString()
        , ( uiIPUuidLen + 1 ) * sizeof( WCHAR )
        );

    CopyMemory( 
          sszResourceUuids.PMem() + uiIPUuidLen + 1
        , uuidClusterNameResourceUuid.PszGetUuidString()
        , ( uiNameUuidLen + 1 ) * sizeof( WCHAR )
        );

    CopyMemory( 
          sszResourceUuids.PMem() + uiIPUuidLen + uiNameUuidLen + 2 
        , uuidLocalQuorumResourceUuid.PszGetUuidString()
        , ( uiLocalQuorumUuidLen + 1 ) * sizeof( WCHAR )
        );

    ( sszResourceUuids.PMem() )[ uiUuidLen - 1 ] = L'\0';


    //
    // Customize the cluster group.
    //
    {
        CRegistryKey    rkClusterGroupKey(
              rkClusterHiveRootIn.HGetKey()
            , CLUSREG_KEYNAME_GROUPS L"\\" CLUSREG_KEYNAME_CLUSTERGROUP_PLACEHOLDER
            , KEY_WRITE
            );

        // Replace the placeholder for the cluster group key with an actual UUID.
        rkClusterGroupKey.RenameKey( uuidClusterGroupUuid.PszGetUuidString() );

        // Set the list of contained resources uuids.
        rkClusterGroupKey.SetValue(
              CLUSREG_NAME_GRP_CONTAINS
            , REG_MULTI_SZ
            , reinterpret_cast< const BYTE * >( sszResourceUuids.PMem() )
            , uiUuidLen * sizeof( WCHAR )
            );

        BCATraceMsg( "Cluster group customized." );
    }

    //
    // Customize the localquorum resource and update the HKLM\Quorum key.
    //
    {
        CRegistryKey    rkLocalQuorumResourceKey(
              rkClusterHiveRootIn.HGetKey()
            , CLUSREG_KEYNAME_RESOURCES L"\\" CLUSREG_KEYNAME_LOCALQUORUM_RES_PLACEHOLDER
            , KEY_WRITE
            );

        CRegistryKey    rkQuorumKey(
              rkClusterHiveRootIn.HGetKey()
            , CLUSREG_KEYNAME_QUORUM
            , KEY_WRITE
            );

        // Replace the placeholder for the localquorum resource key with an actual UUID.
        rkLocalQuorumResourceKey.RenameKey( uuidLocalQuorumResourceUuid.PszGetUuidString() );

        // Set the uuid of the localquorum resource under the HKLM\Quorum key
        rkQuorumKey.SetValue(
              CLUSREG_NAME_QUORUM_RESOURCE
            , REG_SZ
            , reinterpret_cast< const BYTE * >( uuidLocalQuorumResourceUuid.PszGetUuidString() )
            , ( uiLocalQuorumUuidLen + 1 ) * sizeof( WCHAR )
            );

        BCATraceMsg( "Localquorum resource customized." );
    }

    //
    // Set the cluster IP address resource private properties.
    //
    {
        CRegistryKey    rkClusterIPResourceKey(
              rkClusterHiveRootIn.HGetKey()
            , CLUSREG_KEYNAME_RESOURCES L"\\" CLUSREG_KEYNAME_CLUSTERIP_RES_PLACEHOLDER
            , KEY_WRITE
            );

        LPSTR           pszAddr;    // don't free!
        WCHAR           szIPBuffer[ 3 + 1 + 3 + 1 + 3 + 1 + 3 + 1 ]; // "xxx.xxx.xxx.xxx\0"
        DWORD           dwTemp;

        // Replace the placeholder for the cluster IP address resource key with an actual UUID.
        rkClusterIPResourceKey.RenameKey( uuidClusterIPAddressResourceUuid.PszGetUuidString() );

        // Create the cluster IP address parameters registry key.
        CRegistryKey    rkIPResParams;
        
        rkIPResParams.CreateKey(
              rkClusterIPResourceKey.HGetKey()
            , CLUSREG_KEYNAME_PARAMETERS
            );

        // Format the cluster IP address into a dotted quad.
        dwTemp = pcfClusterFormIn->DwGetIPAddress();
        pszAddr = inet_ntoa( * (struct in_addr *) &dwTemp );
        if ( pszAddr == NULL )
        {
            LogMsg( "inet_ntoa() returned NULL. Mapping it to E_OUTOFMEMORY." );
            THROW_RUNTIME_ERROR( E_OUTOFMEMORY, IDS_ERROR_CLUSDB_POPULATE_HIVE );
        }
        mbstowcs( szIPBuffer, pszAddr, strlen(pszAddr) + 1 );

        // Write the IP address to the registry.
        rkIPResParams.SetValue(
              CLUSREG_NAME_IPADDR_ADDRESS
            , REG_SZ
            , reinterpret_cast< const BYTE * >( szIPBuffer )
            , ( wcslen( szIPBuffer ) + 1 ) * sizeof(WCHAR)
            );

        // Format the cluster IP subnet mask into a dotted quad.
        dwTemp = pcfClusterFormIn->DwGetIPSubnetMask();
        pszAddr = inet_ntoa( * (struct in_addr *) &dwTemp );
        if ( pszAddr == NULL )
        {
            LogMsg( "inet_ntoa() returned NULL. Mapping it to E_OUTOFMEMORY." );
            THROW_RUNTIME_ERROR( E_OUTOFMEMORY, IDS_ERROR_CLUSDB_POPULATE_HIVE );
        }
        mbstowcs( szIPBuffer, pszAddr, strlen( pszAddr ) + 1 );

        // Write the IP subnet mask to the registry.
        rkIPResParams.SetValue(
              CLUSREG_NAME_IPADDR_SUBNET_MASK
            , REG_SZ
            , reinterpret_cast< const BYTE * >( szIPBuffer )
            , ( wcslen( szIPBuffer ) + 1 ) * sizeof(WCHAR)
            );

        // Write the IP address network to the registry.
        rkIPResParams.SetValue(
              CLUSREG_NAME_IPADDR_NETWORK
            , REG_SZ
            , reinterpret_cast< const BYTE * >( pcfClusterFormIn->RStrGetClusterIPNetwork().PszData() )
            , ( pcfClusterFormIn->RStrGetClusterIPNetwork().NGetLen() + 1 ) * sizeof( WCHAR )
            );

        BCATraceMsg( "IP address resource customized." );
    }

    //
    // Set the cluster network name resource private properties and dependencies.
    //
    {
        CRegistryKey    rkClusterNameResourceKey(
              rkClusterHiveRootIn.HGetKey()
            , CLUSREG_KEYNAME_RESOURCES L"\\" CLUSREG_KEYNAME_CLUSTERNAME_RES_PLACEHOLDER
            , KEY_WRITE
            );

        // Replace the placeholder for the network name resource key with an actual UUID.
        rkClusterNameResourceKey.RenameKey( uuidClusterNameResourceUuid.PszGetUuidString() );

        //
        // Indicate that the network name resource depends on the IP address resource.
        //
        ( sszResourceUuids.PMem() )[ uiIPUuidLen + 1 ] = L'\0';

        rkClusterNameResourceKey.SetValue(
              CLUSREG_NAME_RES_DEPENDS_ON
            , REG_MULTI_SZ
            , reinterpret_cast< const BYTE * >( sszResourceUuids.PMem() )
            , ( uiIPUuidLen + 2 ) * sizeof( WCHAR )
            );

        //
        // Create the cluster name parameters registry key.
        //
        CRegistryKey    rkNetNameResParams;
        
        rkNetNameResParams.CreateKey(
              rkClusterNameResourceKey.HGetKey()
            , CLUSREG_KEYNAME_PARAMETERS
            );

        // Write the cluster name to the registry.
        rkNetNameResParams.SetValue(
              CLUSREG_NAME_NETNAME_NAME
            , REG_SZ
            , reinterpret_cast< const BYTE * >( pcfClusterFormIn->RStrGetClusterNetBIOSName().PszData() )
            , ( pcfClusterFormIn->RStrGetClusterNetBIOSName().NGetLen() + 1 ) * sizeof( WCHAR )
            );

        // Store the UUID of the network name resource under HKLM\Cluster\ClusterNameResource.
        rkClusterHiveRootIn.SetValue(
              CLUSREG_NAME_CLUS_CLUSTER_NAME_RES
            , REG_SZ
            , reinterpret_cast< const BYTE * >( uuidClusterNameResourceUuid.PszGetUuidString() )
            , ( uiNameUuidLen + 1 ) * sizeof( WCHAR )
            );


        BCATraceMsg( "Network name resource customized." );
    }

    LogMsg( "Cluster group and core resources customized." );

} //*** CClusDBForm::CustomizeClusterGroup()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdbjoin.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusDBJoin.h
//
//  Description:
//      Header file for CClusDBJoin class.
//      The CClusDBJoin class is an action that creates the cluster database
//      during a cluster join.
//
//  Implementation Files:
//      CClusDBJoin.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CClusDB base class
#include "CClusDB.h"

// For HNODE
#include <ClusAPI.h>

// For BYTE_PIPE, JoinAddNode3() and DmSyncDatabase()
#include "ClusRPC.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterJoin;



//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusDBJoin
//
//  Description:
//      The CClusDBJoin class is an action that creates the cluster database
//      during a cluster join.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusDBJoin : public CClusDB
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusDBJoin( CBaseClusterJoin * pcjClusterJoinIn );

    // Default destructor.
    ~CClusDBJoin();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Create the ClusDB.
    //
    void Commit();

    //
    // Rollback this creation.
    //
    void Rollback();


    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        //
        // The three notifications are:
        // 1. Cleaning up any old cluster database files that may exist.
        // 2. Creating cluster database.
        // 3. Synchronizing cluster database.
        //
        return 3;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////

    // The base class of this class.
    typedef CClusDB BaseClass;

    // Smart handle to a cluster node.
    typedef CSmartResource<
        CHandleTrait<
              HNODE
            , BOOL
            , CloseClusterNode
            , reinterpret_cast< HNODE >( NULL )
            >
        >
        SmartNodeHandle;
                    
    // Smart file handle
    typedef CSmartResource< CHandleTrait< HANDLE, BOOL, CloseHandle, INVALID_HANDLE_VALUE > > SmartFileHandle;


    //////////////////////////////////////////////////////////////////////////
    // Private methods
    //////////////////////////////////////////////////////////////////////////

    // Create the cluster database
    void
        Create();

    // Cleanup the cluster database
    void
        Cleanup();

    // Synchronize the cluster database with the sponsor cluster.
    void Synchronize();


    // Callback function used by RPC to push data.
    static void
        S_BytePipePush(
              char *            pchStateIn
            , unsigned char *   pchBufferIn
            , unsigned long     ulBufferSizeIn
            );

    // Callback function used by RPC to pull data.
    static void
        S_BytePipePull(
              char *            pchStateIn
            , unsigned char *   pchBufferIn
            , unsigned long     ulBufferSizeIn
            , unsigned long *   pulWrittenOut
            );


    // Callback function used by RPC to allocate a buffer.
    static void
        S_BytePipeAlloc(
              char *            pchStateIn
            , unsigned long     ulRequestedSizeIn
            , unsigned char **  ppchBufferOut
            , unsigned long  *  pulActualSizeOut
            );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Size of the byte pipe buffer
    static const int    ms_nFILE_PIPE_BUFFER_SIZE = 4096;
    
    // Handle to the local cluster DB file.
    HANDLE              m_hClusDBFile;
    
    //  Indicates if this node has been added to the sponsor database or not.
    bool                m_fHasNodeBeenAddedToSponsorDB;

    // Pointer to the parent of this action.
    CBaseClusterJoin *  m_pcjClusterJoin;

    // Pipe used by RPC to get the sponsor cluster database across.
    BYTE_PIPE           m_bpBytePipe;

    // Buffer used by the byte pipe.
    BYTE                m_rgbBytePipeBuffer[ ms_nFILE_PIPE_BUFFER_SIZE ];

}; //*** class CClusDBJoin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdisk.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CClusDisk.cpp
//
//  Description:
//      Contains the definition of the CClusDisk class.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header for this file
#include "CClusDisk.h"

// Required by clusdisk.h
#include <ntddscsi.h>

// For IOCTL_DISK_CLUSTER_ATTACH and IOCTL_DISK_CLUSTER_DETACH
#include <clusdisk.h>


//////////////////////////////////////////////////////////////////////////////
// Macros
//////////////////////////////////////////////////////////////////////////////

// The name of the ClusDisk service
#define CLUSDISK_SERVICE_NAME           L"ClusDisk"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisk::CClusDisk()
//
//  Description:
//      Constructor of the CClusDisk class. Opens a handle to the service.
//
//  Arguments:
//      pbcaParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CAssert
//          If the parameters are incorrect.
//
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusDisk::CClusDisk(
      CBaseClusterAction *  pbcaParentActionIn
    )
    : m_cservClusDisk( CLUSDISK_SERVICE_NAME )
    , m_pbcaParentAction( pbcaParentActionIn )
{

    BCATraceScope( "" );

    if ( m_pbcaParentAction == NULL)
    {
        TraceFlow( "Pointers to the parent action is NULL. Throwing exception." );
        THROW_ASSERT(
              E_INVALIDARG
            , "CClusDisk::CClusDisk() => Required input pointer in NULL"
            );
    } // if: the parent action pointer is NULL

    //
    // The ClusDisk service has been created at the time the cluster binaries were
    // installed. So, get a handle to the ClusDisk service.
    //

    SmartSCMHandle  sscmhTempHandle(
        OpenService(
              pbcaParentActionIn->HGetSCMHandle()
            , CLUSDISK_SERVICE_NAME
            , SERVICE_ALL_ACCESS
            )
        );

    // Did we get a handle to the service?
    if ( sscmhTempHandle.FIsInvalid() )
    {
        DWORD   dwError = TW32( GetLastError() );

        LogMsg( "Error %#08x occurred trying to open a handle to the ClusDisk service.", dwError );
        TraceFlow1( "Error %#08x occurred trying to open a handle to the ClusDisk service. Throwing exception.", dwError );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_CLUSDISK_OPEN );
    } // if: OpenService failed

    // Initialize the member variable.
    m_sscmhServiceHandle = sscmhTempHandle;

} //*** CClusDisk::CClusDisk()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisk::~CClusDisk()
//
//  Description:
//      Destructor of the CClusDisk class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDisk::~CClusDisk( void )
{
    BCATraceScope( "" );

} //*** CClusDisk::~CClusDisk()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDisk::ConfigureService()
//
//  Description:
//      This function enables and starts the ClusDisk service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDisk::ConfigureService( void )
{
    BCATraceScope( "" );
    LogMsg( "Configuring the ClusDisk service." );

    bool fIsRunning;

    {
        CStatusReport   srConfigClusDisk(
              PbcaGetParent()->PBcaiGetInterfacePointer()
            , TASKID_Major_Configure_Cluster_Services
            , TASKID_Minor_Configuring_ClusDisk_Service
            , 0, 1
            , IDS_TASK_CONFIG_CLUSDISK
            );

        // Send the next step of this status report.
        srConfigClusDisk.SendNextStep( S_OK );

        //
        // First, initialize the ClusDisk service to make sure that it does not retain
        // any state from another cluster that this node may have been a part of.
        //
        fIsRunning = FInitializeState();

        //
        // Enable the service.
        //
        if ( ChangeServiceConfig(
                  m_sscmhServiceHandle.HHandle()    // handle to service
                , SERVICE_NO_CHANGE                 // type of service
                , SERVICE_SYSTEM_START              // when to start service
                , SERVICE_NO_CHANGE                 // severity of start failure
                , NULL                              // service binary file name
                , NULL                              // load ordering group name
                , NULL                              // tag identifier
                , NULL                              // array of dependency names
                , NULL                              // account name
                , NULL                              // account password
                , NULL                              // display name
                )
             == FALSE
           )
        {
            DWORD dwError = TW32( GetLastError() );

            LogMsg( "Could not enable the ClusDisk service. Error %#08x.", dwError );
            TraceFlow1( "ChangeServiceConfig() failed with error %#08x. Throwing exception.", dwError );

            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_CLUSDISK_CONFIGURE );
        } // if: we could not enable the service.

        // Send the last step of this status report.
        srConfigClusDisk.SendNextStep( S_OK );
    }

    LogMsg( "The ClusDisk service has been enabled." );

    {
        UINT    cQueryCount = 10;

        CStatusReport   srStartClusDisk(
              PbcaGetParent()->PBcaiGetInterfacePointer()
            , TASKID_Major_Configure_Cluster_Services
            , TASKID_Minor_Starting_ClusDisk_Service
            , 1, cQueryCount + 2    // we will send at most cQueryCount reports while waiting for the service to start (the two extra sends are below)
            , IDS_TASK_STARTING_CLUSDISK
            );

        // Send the next step of this status report.
        srStartClusDisk.SendNextStep( S_OK );

        // This call does not actually create the service - it creates the registry entries needed
        // by ClusDisk.
        m_cservClusDisk.Create( m_pbcaParentAction->HGetMainInfFileHandle() );

        // If the service was not already running, start the service.
        if ( ! fIsRunning )
        {
            m_cservClusDisk.Start(
                  m_pbcaParentAction->HGetSCMHandle()
                , true              // wait for the service to start
                , 500               // wait 500ms between queries for status.
                , cQueryCount       // query cQueryCount times.
                , &srStartClusDisk  // status report to be sent while waiting for the service to start
                );
        } // if: ClusDisk was not already running.
        else
        {
            // Nothing more need be done.
            TraceFlow( "ClusDisk is already running." );
        } // else: ClusDisk is already running.

        LogMsg( "The ClusDisk service has been successfully configured and started." );

        // Send the last step of this status report.
        srStartClusDisk.SendLastStep( S_OK );
    }

} //*** CClusDisk::ConfigureService()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDisk::CleanupService()
//
//  Description:
//      This function enables and starts the ClusDisk service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDisk::CleanupService( void )
{
    BCATraceScope( "" );
    LogMsg( "Cleaning up the ClusDisk service." );

    //
    // First, initialize the ClusDisk service to make sure that it does not retain
    // any state from this cluster.
    //
    FInitializeState();

    //
    // Disable the service.
    //
    if ( ChangeServiceConfig(
              m_sscmhServiceHandle.HHandle()    // handle to service
            , SERVICE_NO_CHANGE                 // type of service
            , SERVICE_DISABLED                  // when to start service
            , SERVICE_NO_CHANGE                 // severity of start failure
            , NULL                              // service binary file name
            , NULL                              // load ordering group name
            , NULL                              // tag identifier
            , NULL                              // array of dependency names
            , NULL                              // account name
            , NULL                              // account password
            , NULL                              // display name
            )
         == FALSE
       )
    {
        DWORD dwError = TW32( GetLastError() );

        LogMsg( "Could not disable the ClusDisk service. Error %#08x.", dwError );
        TraceFlow1( "ChangeServiceConfig() failed with error %#08x. Throwing exception.", dwError );

        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_CLUSDISK_CLEANUP );
    } // if: we could not enable the service.

    LogMsg( "The ClusDisk service has been successfully cleaned up and disabled." );

} //*** CClusDisk::CleanupService()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  bool
//  CClusDisk::FInitializeState()
//
//  Description:
//      This function initializes the ClusDisk service and brings it back to
//      its ground state.
//
//      If the service is running, then ClusDisk is asked to detach
//      itself from all the disks that it is currently attached to.
//
//      If the service is not running, then its parameters key is deleted
//      so as to prevent ClusDisk from reusing any keys leftover from a previous
//      cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Returns true is the service was running before the initialization began.
//      Returns false if it was not.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
bool
CClusDisk::FInitializeState( void )
{
    BCATraceScope( "" );

    LogMsg( "Initializing ClusDisk service state.");

    bool            fIsRunning;
    DWORD   dwError = ERROR_SUCCESS;

    do
    {
        SERVICE_STATUS  ssStatus;

        //
        // Check if the service is running.
        //
        ZeroMemory( &ssStatus, sizeof( ssStatus ) );

        // Query the service for its status.
        if ( QueryServiceStatus(
                m_sscmhServiceHandle.HHandle()
                , &ssStatus
                )
             == 0
           )
        {
            dwError = TW32( GetLastError() );
            TraceFlow1( "Error %#08x occurred while trying to query ClusDisk status. Throwing exception.", dwError );

            break;
        } // if: we could not query the service for its status.

        if ( ssStatus.dwCurrentState == SERVICE_RUNNING )
        {
            TraceFlow( "The ClusDisk service is already running. It will be detached from all disks." );
            LogMsg( "The ClusDisk service is already running. It will be detached from all disks." );

            // ClusDisk is running.
            fIsRunning = true;

            // Make sure that it is not attached to any disks already.
            DetachFromAllDisks();
        } // if: the service is running.
        else
        {
            if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
            {
                TraceFlow( "The ClusDisk service is not running. Its registry will be cleaned up." );
                LogMsg( "The ClusDisk service is not running. Its registry will be cleaned up." );

                // ClusDisk is not running.
                fIsRunning = false;

                // Call the cleanup routine of the embedded service object.
                m_cservClusDisk.Cleanup( m_pbcaParentAction->HGetMainInfFileHandle() );
            } // if: the service is stopped
            else
            {
                dwError = TW32( ERROR_INVALID_HANDLE_STATE );
                TraceFlow1( "ClusDisk is in an incorrect state (%#08x).", ssStatus.dwCurrentState );
                break;
            } // else: the service is in some other state.
        } // else: ClusDisk is not running.
    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( dwError != ERROR_SUCCESS )
    {
        LogMsg( "Error %#08x occurred trying initialize the ClusDisk service state.", dwError );
        TraceFlow1( "Error %#08x occurred trying initialize the ClusDisk service state. Throwing exception.", dwError );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_CLUSDISK_INITIALIZE );
    } // if: something has gone wrong

    LogMsg( "The ClusDisk service state has been successfully initialized.");

    return fIsRunning;

} //*** CClusDisk::FInitializeState()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDisk::DetachFromAllDisks()
//
//  Description:
//      This function detaches ClusDisk from all the disks that it is currently
//      attached to. A prerequisite for calling this function is that the
//      ClusDisk service is running.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDisk::DetachFromAllDisks( void )
{
    BCATraceScope( "" );

    LONG                lError = ERROR_SUCCESS;

    LogMsg( "Detaching the ClusDisk service from all disks." );

    do
    {
        CRegistryKey        rkSignaturesKey;
        DWORD               dwSignatureCount = 0;
        DWORD               dwMaxSignatureNameLen = 0;
        DWORD               dwSignatureIndex = 0;

        // Try and open the ClusDisk signatures key.
        try
        {
            rkSignaturesKey.OpenKey(
                  HKEY_LOCAL_MACHINE
                , L"System\\CurrentControlSet\\Services\\ClusDisk\\Parameters\\Signatures"
                , KEY_ALL_ACCESS
                );
        } // try: to open the ClusDisk signatures key.
        catch( CRuntimeError & rteException )
        {
            //
            // If we are here, then OpenKey threw a CRuntimeError.Check if the
            // error was ERROR_FILE_NOT_FOUND. This means that the key does
            // not exist and we are done.
            //
            // Otherwise, some other error ocurred, so rethrow the exception.
            //

            if ( rteException.HrGetErrorCode() == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
            {
                // There is nothing else to do.
                break;
            } // if: the ClusDisk parameters key does not exist.

            // Some other error occurred.
            throw;
        } // catch( CRuntimeError & )

        //
        // Find out the number of signatures and the maximum length of the signature
        // key names.
        //
        lError = TW32( RegQueryInfoKey(
                          rkSignaturesKey.HGetKey()     // handle to key
                        , NULL                          // class buffer
                        , NULL                          // size of class buffer
                        , NULL                          // reserved
                        , &dwSignatureCount             // number of subkeys
                        , &dwMaxSignatureNameLen        // longest subkey name
                        , NULL                          // longest class string
                        , NULL                          // number of value entries
                        , NULL                          // longest value name
                        , NULL                          // longest value data
                        , NULL                          // descriptor length
                        , NULL                          // last write time
                        ) );

        if ( lError != ERROR_SUCCESS )
        {
            TraceFlow( "RegQueryInfoKey() failed." );
            break;
        } // if: RegQueryInfoKey() failed.

        // Account for the terminating '\0'
        ++dwMaxSignatureNameLen;

        // Allocate the memory required to hold the signatures.
        CSmartGenericPtr< CArrayPtrTrait< DWORD > > rgdwSignatureArrayIn( new DWORD[ dwSignatureCount ] );
        if ( rgdwSignatureArrayIn.FIsEmpty() )
        {
            lError = TW32( ERROR_OUTOFMEMORY );
            TraceFlow1( "Could not allocate %d bytes required for the signature array.", dwSignatureCount );
            break;
        } // if:memory allocation failed.

        // Allocate the memory required for the signature string.
        SmartSz sszSignatureKeyName( new WCHAR[ dwMaxSignatureNameLen ] );
        if ( sszSignatureKeyName.FIsEmpty() )
        {
            lError = TW32( ERROR_OUTOFMEMORY );
            TraceFlow1( "Could not allocate %d bytes required for the longest signature key name.", dwMaxSignatureNameLen );
            break;
        } // if:memory allocation failed.


        //
        // Iterate through the list of signatures that ClusDisk is currently attached
        // to and add each of them to the array of signatures. We cannot detach as
        // we enumerate since ClusDisk removes the signature key when it detaches from
        // a disk and RegEnumKeyEx requires that the key being enumerated not change
        // during an enumeration.
        //
        do
        {
            DWORD       dwTempSize = dwMaxSignatureNameLen;
            WCHAR *     pwcCharPtr;

            lError = RegEnumKeyEx(
                              rkSignaturesKey.HGetKey()
                            , dwSignatureIndex
                            , sszSignatureKeyName.PMem()
                            , &dwTempSize
                            , NULL
                            , NULL
                            , NULL
                            , NULL
                            );

            if ( lError != ERROR_SUCCESS )
            {
                if ( lError == ERROR_NO_MORE_ITEMS )
                {
                    lError = ERROR_SUCCESS;
                } // if: we are at the end of the enumeration
                else
                {
                    TW32( lError );
                    TraceFlow1( "RegEnumKeyEx() has failed. Index = %d.", dwSignatureIndex );
                } // else: something else went wrong

                break;
            } // if: RegEnumKeyEx() did not succeed

            TraceFlow2( "Signature %d is '%s'.", dwSignatureIndex + 1, sszSignatureKeyName.PMem() );

            // Convert the key name to a hex number.
            ( rgdwSignatureArrayIn.PMem() )[ dwSignatureIndex ] =
                wcstoul( sszSignatureKeyName.PMem(), &pwcCharPtr, 16 );

            // Did the conversion succeed.
            if ( sszSignatureKeyName.PMem() == pwcCharPtr )
            {
                lError = TW32( ERROR_INVALID_PARAMETER );
                TraceFlow( "_wcstoul() failed." );
                break;
            } // if: the conversion of the signature string to a number failed.

            // Increment the index.
            ++dwSignatureIndex;
        }
        while( true ); // loop infinitely

        if ( lError != ERROR_SUCCESS )
        {
            break;
        } // if: something went wrong

        // Detach ClusDisks from all the disks we found it attached to.
        DetachFromDisks(
              rgdwSignatureArrayIn.PMem()
            , dwSignatureCount
            );

    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( lError != ERROR_SUCCESS )
    {
        LogMsg( "Error %#08x occurred trying detach ClusDisk from all the disks.", lError );
        TraceFlow1( "Error %#08x trying detach ClusDisk from all the disks. Throwing exception.", lError );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( lError ), IDS_ERROR_CLUSDISK_INITIALIZE );
    } // if: something has gone wrong

    LogMsg( "The ClusDisk service has been successfully detached from all disks." );

} //*** CClusDisk::DetachFromAllDisks()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDisk::DetachFromDisks()
//
//  Description:
//      This function detaches ClusDisk from the disks specified
//      by a list of signatures. A prerequisite for calling this function is
//      that the ClusDisk service is running.
//
//  Arguments:
//      rgdwSignatureArrayIn
//          Array of signatures of disks to detach from.
//
//      uiArraySizeIn
//          Number of signatures in above array.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDisk::DetachFromDisks(
      DWORD   rgdwSignatureArrayIn[]
    , UINT    uiArraySizeIn
    )
{
    BCATraceScope( "" );

    NTSTATUS            ntStatus = STATUS_SUCCESS;
    UNICODE_STRING      ustrClusDiskDeviceName;
    OBJECT_ATTRIBUTES   oaClusDiskAttrib;
    HANDLE              hClusDisk;
    IO_STATUS_BLOCK     iosbIoStatusBlock;
    DWORD               dwTempSize = 0;

    TraceFlow1( "Trying to detach from %d disks.", uiArraySizeIn );

    //
    //  If the list is empty then leave since there are no disks to detach
    //  from.
    //
    if ( ( uiArraySizeIn == 0 ) || ( rgdwSignatureArrayIn == NULL ) )
    {
        goto Cleanup;
    } // if:

    // Initialize the unicode string with the name of the ClusDisk device.
    RtlInitUnicodeString( &ustrClusDiskDeviceName, L"\\Device\\ClusDisk0" );

    InitializeObjectAttributes(
          &oaClusDiskAttrib
        , &ustrClusDiskDeviceName
        , OBJ_CASE_INSENSITIVE
        , NULL
        , NULL
        );

    TraceFlow( "Trying to get a handle to the ClusDisk device." );

    // Get a handle to the ClusDisk device.
    ntStatus = THR( NtCreateFile(
                          &hClusDisk
                        , SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA
                        , &oaClusDiskAttrib
                        , &iosbIoStatusBlock
                        , NULL
                        , FILE_ATTRIBUTE_NORMAL
                        , FILE_SHARE_READ | FILE_SHARE_WRITE
                        , FILE_OPEN
                        , 0
                        , NULL
                        , 0
                        ) );
    if ( NT_SUCCESS( ntStatus ) == FALSE )
    {
        TraceFlow( "NtCreateFile has failed." );
        goto Cleanup;
    } // if: NtCreateFile failed.

    {   // new block so that that the file handle is closed.
        // Assign the opened file handle to a smart handle for safe closing.
        CSmartResource<
            CHandleTrait<
                  HANDLE
                , NTSTATUS
                , NtClose
                >
            > snthClusDiskHandle( hClusDisk );

        // Detach ClusDisk from this disk.
        if ( DeviceIoControl(
                  hClusDisk
                , IOCTL_DISK_CLUSTER_DETACH_LIST
                , rgdwSignatureArrayIn
                , uiArraySizeIn * sizeof( rgdwSignatureArrayIn[ 0 ] )
                , NULL
                , 0
                , &dwTempSize
                , FALSE
                )
             == FALSE
            )
        {
            ntStatus = TW32( GetLastError() );
            ntStatus = HRESULT_FROM_WIN32( ntStatus );
            TraceFlow( "DeviceIoControl() failed for signature list" );
        } // if: DeviceIoControl() failed
    }

Cleanup:

    if ( ntStatus != STATUS_SUCCESS )
    {
        LogMsg( "Error %#08x occurred trying detach ClusDisk from a disk.", ntStatus );
        TraceFlow1( "Error %#08x trying detach ClusDisk from a disk. Throwing exception.", ntStatus );
        THROW_RUNTIME_ERROR( ntStatus, IDS_ERROR_CLUSDISK_INITIALIZE );
    } // if: something has gone wrong

} //*** CClusDisk::DetachFromDisks()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDisk::AttachToDisks()
//
//  Description:
//      This function attaches ClusDisk to the disks specified
//      by a list of signatures. A prerequisite for calling this function is
//      that the ClusDisk service is running.
//
//  Arguments:
//      rgdwSignatureArrayIn
//          Array of signatures of disks to attach to.
//
//      uiArraySizeIn
//          Number of signatures in above array.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDisk::AttachToDisks(
      DWORD   rgdwSignatureArrayIn[]
    , UINT    uiArraySizeIn
    )
{
    BCATraceScope( "" );

    NTSTATUS            ntStatus = STATUS_SUCCESS;
    UNICODE_STRING      ustrClusDiskDeviceName;
    OBJECT_ATTRIBUTES   oaClusDiskAttrib;
    HANDLE              hClusDisk;
    IO_STATUS_BLOCK     iosbIoStatusBlock;
    DWORD               dwTempSize = 0;

    TraceFlow1( "Trying to attach to %d disks.", uiArraySizeIn );

    //
    //  If the list is empty then leave since there are no disks to attach
    //  to.
    //
    if ( ( uiArraySizeIn == 0 ) || ( rgdwSignatureArrayIn == NULL ) )
    {
        goto Cleanup;
    } // if:

    // Initialize the unicode string with the name of the ClusDisk device.
    RtlInitUnicodeString( &ustrClusDiskDeviceName, L"\\Device\\ClusDisk0" );

    InitializeObjectAttributes(
          &oaClusDiskAttrib
        , &ustrClusDiskDeviceName
        , OBJ_CASE_INSENSITIVE
        , NULL
        , NULL
        );

    TraceFlow( "Trying to get a handle to the ClusDisk device." );

    // Get a handle to the ClusDisk device.
    ntStatus = THR( NtCreateFile(
                          &hClusDisk
                        , SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA
                        , &oaClusDiskAttrib
                        , &iosbIoStatusBlock
                        , NULL
                        , FILE_ATTRIBUTE_NORMAL
                        , FILE_SHARE_READ | FILE_SHARE_WRITE
                        , FILE_OPEN
                        , 0
                        , NULL
                        , 0
                        ) );
    if ( NT_SUCCESS( ntStatus ) == FALSE )
    {
        TraceFlow( "NtCreateFile has failed." );
        goto Cleanup;
    } // if: NtCreateFile failed.

    {   // new block so that that the file handle is closed.
        // Assign the opened file handle to a smart handle for safe closing.
        CSmartResource<
            CHandleTrait<
                  HANDLE
                , NTSTATUS
                , NtClose
                >
            > snthClusDiskHandle( hClusDisk );

        // Attach ClusDisk to this signature list.
        if ( DeviceIoControl(
                  hClusDisk
                , IOCTL_DISK_CLUSTER_ATTACH_LIST
                , rgdwSignatureArrayIn
                , uiArraySizeIn * sizeof( rgdwSignatureArrayIn[0] )
                , NULL
                , 0
                , &dwTempSize
                , FALSE
                )
             == FALSE
            )
        {
            ntStatus = GetLastError();
            ntStatus = HRESULT_FROM_WIN32( TW32( ntStatus ) );
            TraceFlow( "DeviceIoControl() failed for signature list" );
        } // if: DeviceIoControl() failed
    }

Cleanup:

    if ( ntStatus != STATUS_SUCCESS )
    {
        LogMsg( "Error %#08x occurred trying attach ClusDisk to a disk.", ntStatus );
        TraceFlow1( "Error %#08x trying attach ClusDisk to a disk. Throwing exception.", ntStatus );
        THROW_RUNTIME_ERROR( ntStatus, IDS_ERROR_CLUSDISK_INITIALIZE );
    } // if: something has gone wrong

} //*** CClusDisk::AttachToDisks()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdiskcleanup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusDiskCleanup.h
//
//  Description:
//      Header file for CClusDiskCleanup class.
//      The CClusDiskCleanup class is an action that cleans up the ClusDisk service.
//
//  Implementation Files:
//      CClusDiskCleanup.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 01-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CClusDisk base class
#include "CClusDisk.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterCleanup;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusDiskCleanup
//
//  Description:
//      The CClusDiskCleanup class is an action that clean up the ClusDisk service.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusDiskCleanup : public CClusDisk
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusDiskCleanup( CBaseClusterCleanup * pbccParentActionIn );

    // Default destructor.
    ~CClusDiskCleanup();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Clean up the ClusDisk service.
    //
    void Commit();

    //
    // Rollback this cleanup.
    //
    void Rollback();


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CClusDisk BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

}; //*** class CClusDiskCleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdiskform.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusDiskForm.h
//
//  Description:
//      Header file for CClusDiskForm class.
//      The CClusDiskJoin class is an action that configures the ClusDisk
//      service during a form.
//
//  Implementation Files:
//      CClusDiskForm.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CClusDisk base class
#include "CClusDisk.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterForm;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusDiskForm
//
//  Description:
//      The CClusDiskJoin class is an action that configures the ClusDisk
//      service during a form.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusDiskForm : public CClusDisk
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusDiskForm(
          CBaseClusterForm * pbcfParentActionIn
        );

    // Default destructor.
    ~CClusDiskForm();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Create the ClusDisk service.
    //
    void Commit();

    //
    // Rollback this creation.
    //
    void Rollback();


    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        return BaseClass::UiGetMaxProgressTicks();
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CClusDisk BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

}; //*** class CClusDiskForm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdiskjoin.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CClusDiskJoin.cpp
//
//  Description:
//      Contains the definition of the CClusDiskJoin class.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header for this file
#include "CClusDiskJoin.h"

// For the CBaseClusterJoin class.
#include "CBaseClusterJoin.h"

// For the CImpersonateUser class.
#include "CImpersonateUser.h"

// For the ResUtil functions
#include "ResAPI.h"


//////////////////////////////////////////////////////////////////////////////
// Macro definitions
//////////////////////////////////////////////////////////////////////////////

// Name of the private property of a physical disk resouce that has its signature.
#define PHYSICAL_DISK_SIGNATURE_PRIVPROP_NAME   L"Signature"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDiskJoin::CClusDiskJoin()
//
//  Description:
//      Constructor of the CClusDiskJoin class
//
//  Arguments:
//      pbcjParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusDiskJoin::CClusDiskJoin(
      CBaseClusterJoin *     pbcjParentActionIn
    )
    : BaseClass( pbcjParentActionIn )
    , m_nSignatureArraySize( 0 )
    , m_nSignatureCount( 0 )
{

    BCATraceScope( "" );

    SetRollbackPossible( true );

} //*** CClusDiskJoin::CClusDiskJoin()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDiskJoin::~CClusDiskJoin()
//
//  Description:
//      Destructor of the CClusDiskJoin class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDiskJoin::~CClusDiskJoin( void )
{
    BCATraceScope( "" );

} //*** CClusDiskJoin::~CClusDiskJoin()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDiskJoin::Commit()
//
//  Description:
//      Configure and start the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDiskJoin::Commit( void )
{
    BCATraceScope( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    try
    {
        // Create and start the service.
        ConfigureService();

        // Try and attach to all the disks that the sponsor knows about.
        AttachToClusteredDisks();

    } // try:
    catch( ... )
    {
        // If we are here, then something went wrong with the create.

        BCATraceMsg( "Caught exception during commit." );

        //
        // Cleanup anything that the failed create might have done.
        // Catch any exceptions thrown during Cleanup to make sure that there
        // is no collided unwind.
        //
        try
        {
            CleanupService();
        }
        catch( ... )
        {
            //
            // The rollback of the committed action has failed.
            // There is nothing that we can do.
            // We certainly cannot rethrow this exception, since
            // the exception that caused the rollback is more important.
            //

            THR( E_UNEXPECTED );

            BCATraceMsg( "Caught exception during cleanup." );
            LogMsg( "THIS COMPUTER MAY BE IN AN INVALID STATE. An error has occurred during cleanup." );

        } // catch: all

        // Rethrow the exception thrown by commit.
        throw;

    } // catch: all

    // If we are here, then everything went well.
    SetCommitCompleted( true );

} //*** CClusDiskJoin::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDiskJoin::Rollback()
//
//  Description:
//      Cleanup the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDiskJoin::Rollback( void )
{
    BCATraceScope( "" );

    // Call the base class rollback method.
    BaseClass::Rollback();

    // Cleanup the service.
    CleanupService();

    SetCommitCompleted( false );

} //*** CClusDiskJoin::Rollback()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDiskJoin::AttachToClusteredDisks()
//
//  Description:
//      Get the signatures of all disks that have been clustered from the sponsor.
//      Attach to all these disks.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDiskJoin::AttachToClusteredDisks( void )
{
    BCATraceScope( "" );

    DWORD dwError = ERROR_SUCCESS;

    // Get the parent action pointer.
    CBaseClusterJoin * pcjClusterJoin = dynamic_cast< CBaseClusterJoin *>( PbcaGetParent() );

    // If the parent action of this action is not CBaseClusterJoin
    if ( pcjClusterJoin == NULL )
    {
        THROW_ASSERT( E_POINTER, "The parent action of this action is not CBaseClusterJoin." );
    } // an invalid pointer was passed in.


    //
    // Connect to the sponsor cluster and get the signatures of all clustered disks.
    //
    do
    {
        // Smart handle to sponsor cluster
        SmartClusterHandle schSponsorCluster;

        BCATraceMsg( "Attempting to impersonate the cluster service account." );

        // Impersonate the cluster service account, so that we can contact the sponsor cluster.
        // The impersonation is automatically ended when this object is destroyed.
        CImpersonateUser ciuImpersonateClusterServiceAccount( pcjClusterJoin->HGetClusterServiceAccountToken() );

        {
            BCATraceMsg( "Trying to open a handle to the sponsor cluster." );

            // Open a handle to the sponsor cluster.
            HCLUSTER hSponsorCluster = OpenCluster( pcjClusterJoin->RStrGetClusterBindingString().PszData() );

            // Assign it to a smart handle for safe release.
            schSponsorCluster.Assign( hSponsorCluster );
        }

        // Did we succeed in opening a handle to the sponsor cluster?
        if ( schSponsorCluster.FIsInvalid() )
        {
            dwError = TW32( GetLastError() );
            BCATraceMsg( "An error occurred trying to open a handle to the sponsor cluster." );
            LogMsg( "An error occurred trying to open a handle to the sponsor cluster." );
            break;
        } // if: OpenCluster() failed

        BCATraceMsg1( "Enumerating all '%s' resources in the cluster.", CLUS_RESTYPE_NAME_PHYS_DISK );

        // Enumerate all the physical disk resouces in the cluster and get their signatures.
        dwError = TW32( ResUtilEnumResourcesEx(
                              schSponsorCluster.HHandle()
                            , NULL
                            , CLUS_RESTYPE_NAME_PHYS_DISK
                            , S_DwResourceEnumCallback
                            , this
                            ) );

        if ( dwError != ERROR_SUCCESS )
        {
            // Free the signature array.
            m_rgdwSignatureArray.PRelease();
            m_nSignatureArraySize = 0;
            m_nSignatureCount = 0;

            BCATraceMsg( "An error occurred trying enumerate resources in the sponsor cluster." );
            LogMsg( "An error occurred trying enumerate resources in the sponsor cluster." );
            break;
        } // if: ResUtilEnumResourcesEx() failed
    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( dwError != ERROR_SUCCESS )
    {
        LogMsg( "Error %#08x occurred trying to attach to the disks in the sponsor cluster.", dwError );
        BCATraceMsg1( "Error %#08x occurred trying to attach to the disks in the sponsor cluster. Throwing exception.", dwError );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_CLUSDISK_CONFIGURE );
    } // if: something has gone wrong
    else
    {
        BCATraceMsg1( "Attaching to the %d disks in the sponsor cluster.", m_nSignatureCount );

        AttachToDisks(
          m_rgdwSignatureArray.PMem()
        , m_nSignatureCount
        );
    } // else: everything has gone well so far

} //*** CClusDiskJoin::AttachToClusteredDisks()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusDiskJoin::DwAddSignature()
//
//  Description:
//      Add a signature to the array of signatures of disks that ClusDisk should
//      attach to. If the array is already full, grow the array.
//
//  Arguments:
//      dwSignatureIn
//          Signature to be added to the array.
//
//  Return Value:
//      ERROR_SUCCESS
//          If everything was ok.
//
//      Other Win32 error codes on failure.
//
//  Exceptions Thrown:
//      None. This function is called from a callback routine and therefore
//      cannot throw any exceptions.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
CClusDiskJoin::DwAddSignature( DWORD dwSignatureIn ) throw()
{
    BCATraceScope( "" );

    DWORD dwError = ERROR_SUCCESS;

    do
    {
        // Is the capacity of the array reached?
        if ( m_nSignatureCount == m_nSignatureArraySize )
        {
            // Increase the array size by a random amount.
            const int nGrowSize = 256;

            BCATraceMsg2( "Signature count has reached array size ( %d ). Growing array by %d.", m_nSignatureArraySize, nGrowSize );

            m_nSignatureArraySize += nGrowSize;

            // Grow the array.
            DWORD * pdwNewArray = new DWORD[ m_nSignatureArraySize ];

            if ( pdwNewArray == NULL )
            {
                BCATraceMsg1( "Memory allocation failed trying to allocate %d DWORDs.", m_nSignatureArraySize );
                dwError = TW32( ERROR_OUTOFMEMORY );
                break;
            } // if: memory allocation failed

            // Copy the old array into the new one.
            CopyMemory( pdwNewArray, m_rgdwSignatureArray.PMem(), m_nSignatureCount * sizeof( SmartDwordArray::DataType ) );

            // Free the old array and store the new one.
            m_rgdwSignatureArray.Assign( pdwNewArray );

        } // if: the array capacity has been reached

        // Store the new signature in next array location
        ( m_rgdwSignatureArray.PMem() )[ m_nSignatureCount ] = dwSignatureIn;

        ++m_nSignatureCount;

        BCATraceMsg2( "Signature %#08X added to array. There are now %d signature in the array.", dwSignatureIn, m_nSignatureCount );
    }
    while( false ); // dummy do-while loop to avoid gotos.

    BCATraceMsg1( "Return value is %d.", dwError );
    return dwError;

} //*** CClusDiskJoin::DwAddSignature()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  static DWORD
//  CClusDiskJoin::S_DwResourceEnumCallback()
//
//  Description:
//      This function is called back for every physical disk resouce by
//      ResUtilEnumResourcesEx() as a part of enumerating resources.
//      This function gets the signature of the current physical disk
//      resource and stores it in the object that initiated the enumeration
//      ( the pointer to the object is in parameter 4 ).
//
//  Arguments:
//      HCLUSTER      hClusterIn
//          Handle to the cluster whose resources are being enumerated.
//
//      HRESOURCE     hSelfIn
//          hSelfIn passed to ResUtilEnumResourcesEx(), if any.
//
//      HRESOURCE     hCurrentResourceIn
//          Handle to the current resource.
//
//      PVOID         pvParamIn
//          Pointer to the object of this class that initiated this enumeration.
//
//  Return Value:
//      ERROR_SUCCESS
//          If everything was ok.
//
//      Other Win32 error codes on failure.
//          Returning an error code will terminate the enumeration.
//
//  Exceptions Thrown:
//      None. This function is called from a callback routine and therefore
//      cannot throw any exceptions.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
CClusDiskJoin::S_DwResourceEnumCallback(
      HCLUSTER      hClusterIn
    , HRESOURCE     hSelfIn
    , HRESOURCE     hCurrentResourceIn
    , PVOID         pvParamIn
    )
{
    BCATraceScope( "" );

    DWORD               dwError = ERROR_SUCCESS;
    CClusDiskJoin *     pcdjThisObject = reinterpret_cast< CClusDiskJoin * >( pvParamIn );

    // Get the 'Signature' private property of this physical disk.
    do
    {
        SmartByteArray  sbaPropertyBuffer;
        DWORD           dwBytesReturned = 0;
        DWORD           dwBufferSize;
        DWORD           dwSignature = 0;

        BCATraceMsg1( "Trying to get the signature of the disk resource whose handle is %p.", hCurrentResourceIn );

        // Get the size of the buffer required to hold all the private properties of this resource.
        dwError = ClusterResourceControl(
                          hCurrentResourceIn
                        , NULL
                        , CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES
                        , NULL
                        , 0
                        , NULL
                        , 0
                        , &dwBytesReturned
                        );

        if ( ( dwError != ERROR_MORE_DATA ) && ( dwError != ERROR_SUCCESS ) )
        {
            // Something went wrong.
            TW32( dwError );
            BCATraceMsg( "ClusterResourceControl() failed while trying to get the size of the property buffer." );
            break;
        } // if: the return value of ClusterResourceControl() was not ERROR_MORE_DATA

        dwBufferSize = dwBytesReturned;

        // Allocate the memory required for the property buffer.
        sbaPropertyBuffer.Assign( new BYTE[ dwBufferSize ] );
        if ( sbaPropertyBuffer.FIsEmpty() )
        {
            BCATraceMsg1( "Memory allocation failed trying to allocate %d bytes.", dwBufferSize );
            dwError = TW32( ERROR_OUTOFMEMORY );
            break;
        } // if: memory allocation failed


        // Get the all the private properties of this resource.
        dwError = TW32( ClusterResourceControl(
                              hCurrentResourceIn
                            , NULL
                            , CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES
                            , NULL
                            , 0
                            , sbaPropertyBuffer.PMem()
                            , dwBufferSize
                            , &dwBytesReturned
                            ) );

        if ( dwError != ERROR_SUCCESS )
        {
            BCATraceMsg( "ClusterResourceControl() failed while trying to get the properties of the current resource." );
            break;
        } // if: an error occurring trying to get the private properties.

        // Get the signature of this disk resource.
        dwError = TW32( ResUtilFindDwordProperty(
                              sbaPropertyBuffer.PMem()
                            , dwBufferSize
                            , PHYSICAL_DISK_SIGNATURE_PRIVPROP_NAME
                            , &dwSignature
                            ) );

        if ( dwError != ERROR_SUCCESS )
        {
            BCATraceMsg( "An error has occurred trying to get the signature from the property buffer." );
            break;
        } // if: we could not get the signature

        dwError = TW32( pcdjThisObject->DwAddSignature( dwSignature ) );
        if ( dwError != ERROR_SUCCESS )
        {
            BCATraceMsg( "An error has occurred trying to add the signature to the signature array." );
            break;
        } // if: we could not store the signature
    }
    while( false ); // dummy do-while loop to avoid gotos.

    BCATraceMsg1( "Return value is %d.", dwError );
    return dwError;

} //*** CClusDiskJoin::S_DwResourceEnumCallback()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdiskjoin.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusDiskJoin.h
//
//  Description:
//      Header file for CClusDiskJoin class.
//      The CClusDiskJoin class is an action that configures the ClusDisk
//      service during a join.
//
//  Implementation Files:
//      CClusDiskJoin.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CClusDisk base class
#include "CClusDisk.h"

// For the cluster API functions and types
#include "ClusAPI.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterJoin;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusDiskJoin
//
//  Description:
//      The CClusDiskJoin class is an action that configures the ClusDisk
//      service during a join.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusDiskJoin : public CClusDisk
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusDiskJoin(
          CBaseClusterJoin * pbcjParentActionIn
        );

    // Default destructor.
    ~CClusDiskJoin();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Create the ClusDisk service.
    //
    void Commit();

    //
    // Rollback this creation.
    //
    void Rollback();


    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        return BaseClass::UiGetMaxProgressTicks();
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////

    // The base class of this class.
    typedef CClusDisk BaseClass;

    // Smart array of DWORDS
    typedef CSmartGenericPtr< CArrayPtrTrait< DWORD > > SmartDwordArray;


    //////////////////////////////////////////////////////////////////////////
    // Private methods
    //////////////////////////////////////////////////////////////////////////

    // Attach to all the disks that the sponsor cluster cares about.
    void
        AttachToClusteredDisks();

    // Add a signature to the signature array.
    DWORD
        DwAddSignature( DWORD dwSignatureIn ) throw();


    // A function that is called back during resource enumeration.
    static DWORD 
        S_DwResourceEnumCallback(
              HCLUSTER      hClusterIn
            , HRESOURCE     hSelfIn
            , HRESOURCE     hCurrentResourceIn
            , PVOID         pvParamIn
            );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // An array of signatures of disk to which ClusDisk should attach.
    SmartDwordArray     m_rgdwSignatureArray;

    // Current size of the signature array.
    int                 m_nSignatureArraySize;

    // Number of signatures currently in the array.
    int                 m_nSignatureCount;

}; //*** class CClusDiskJoin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdiskform.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CClusDiskForm.cpp
//
//  Description:
//      Contains the definition of the CClusDiskForm class.
//
//  Documentation:
//      TODO: Add pointer to external documentation later.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header for this file
#include "CClusDiskForm.h"

// For the CBaseClusterForm class.
#include "CBaseClusterForm.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDiskForm::CClusDiskForm()
//
//  Description:
//      Constructor of the CClusDiskForm class
//
//  Arguments:
//      pbcfParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusDiskForm::CClusDiskForm(
      CBaseClusterForm *     pbcfParentActionIn
    )
    : BaseClass( pbcfParentActionIn )
{

    BCATraceScope( "" );

    SetRollbackPossible( true );

} //*** CClusDiskForm::CClusDiskForm()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDiskForm::~CClusDiskForm( void )
//
//  Description:
//      Destructor of the CClusDiskForm class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDiskForm::~CClusDiskForm( void )
{
    BCATraceScope( "" );

} //*** CClusDiskForm::~CClusDiskForm()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDiskForm::Commit( void )
//
//  Description:
//      Configure and start the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDiskForm::Commit( void )
{
    BCATraceScope( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    try
    {
        // Create and start the service.
        ConfigureService();

    } // try:
    catch( ... )
    {
        // If we are here, then something went wrong with the create.

        BCATraceMsg( "Caught exception during commit." );

        //
        // Cleanup anything that the failed create might have done.
        // Catch any exceptions thrown during Cleanup to make sure that there 
        // is no collided unwind.
        //
        try
        {
            CleanupService();
        }
        catch( ... )
        {
            //
            // The rollback of the committed action has failed.
            // There is nothing that we can do.
            // We certainly cannot rethrow this exception, since
            // the exception that caused the rollback is more important.
            //

            THR( E_UNEXPECTED );

            BCATraceMsg( "Caught exception during cleanup." );
            LogMsg( "THIS COMPUTER MAY BE IN AN INVALID STATE. An error has occurred during cleanup." );

        } // catch: all

        // Rethrow the exception thrown by commit.
        throw;

    } // catch: all

    // If we are here, then everything went well.
    SetCommitCompleted( true );

} //*** CClusDiskForm::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusDiskForm::Rollback( void )
//
//  Description:
//      Cleanup the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDiskForm::Rollback( void )
{
    BCATraceScope( "" );

    // Call the base class rollback method. 
    BaseClass::Rollback();

    // Cleanup the service.
    CleanupService();

    SetCommitCompleted( false );

} //*** CClusDiskForm::Rollback()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusnetcleanup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CClusNetCleanup.cpp
//
//  Description:
//      Contains the definition of the CClusNetCleanup class.
//
//  Documentation:
//      TODO: Add pointer to external documentation later.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 01-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header for this file
#include "CClusNetCleanup.h"

// For the CBaseClusterCleanup class.
#include "CBaseClusterCleanup.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetCleanup::CClusNetCleanup()
//
//  Description:
//      Constructor of the CClusNetCleanup class
//
//  Arguments:
//      pbccParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusNetCleanup::CClusNetCleanup( CBaseClusterCleanup * pbccParentActionIn )
    : BaseClass( pbccParentActionIn )
{

    BCATraceScope( "" );

    // It is currently not possible to rollback a cleanup.
    SetRollbackPossible( false );

} //*** CClusNetCleanup::CClusNetCleanup()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetCleanup::~CClusNetCleanup( void )
//
//  Description:
//      Destructor of the CClusNetCleanup class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusNetCleanup::~CClusNetCleanup( void )
{
    BCATraceScope( "" );

} //*** CClusNetCleanup::~CClusNetCleanup()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusNetCleanup::Commit( void )
//
//  Description:
//      Clean up the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusNetCleanup::Commit( void )
{
    BCATraceScope( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    // Cleanup the ClusNet service.
    CleanupService();

    // If we are here, then everything went well.
    SetCommitCompleted( true );

} //*** CClusNetCleanup::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusNetCleanup::Rollback( void )
//
//  Description:
//      Rollback the cleanup the service. This is currently not supported.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusNetCleanup::Rollback( void )
{
    BCATraceScope( "" );

    // Call the base class rollback method. This will throw an exception since
    // SetRollbackPossible( false ) was called in the constructor.

    BaseClass::Rollback();

    SetCommitCompleted( false );

} //*** CClusNetCleanup::Rollback()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusnet.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CClusNet.cpp
//
//  Description:
//      Contains the definition of the CClusNet class.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header for this file
#include "CClusNet.h"

extern "C"
{
// Required by the winsock functions
#include <winsock2.h>

// For the winsock MigrateWinsockConfiguration function.
#include <wsasetup.h>

// For the winsock WSHGetWinsockMapping function.
#include <wsahelp.h>
}

// For the definition of SOCKADDR_CLUSTER
#include <wsclus.h>


//////////////////////////////////////////////////////////////////////////////
// Macros
//////////////////////////////////////////////////////////////////////////////

// The name of the ClusNet service
#define CLUSNET_SERVICE_NAME L"ClusNet"

// Registry location of the ClusNet winsock entries key
#define CLUSNET_WINSOCK_KEY  L"System\\CurrentControlSet\\Services\\ClusNet\\Parameters\\Winsock"

// Name of the ClusNet winsock mapping registry value
#define CLUSNET_WINSOCK_MAPPING L"Mapping"

// Name of the ClusNet winsock minimum socket address length registry value
#define CLUSNET_WINSOCK_MINSOCKADDRLEN L"MinSockaddrLength"

// Name of the ClusNet winsock maximum socket address length registry value
#define CLUSNET_WINSOCK_MAXSOCKADDRLEN L"MaxSockaddrLength"

// Name of the DLL containing the WinSock cluster helper functions
#define WSHCLUS_DLL_NAME L"WSHClus.dll"

// Name of the winsock parameters key.
#define WINSOCK_PARAMS_KEY L"System\\CurrentControlSet\\Services\\WinSock\\Parameters"

// Name of the winsock transports registry key.
#define WINSOCK_PARAMS_TRANSPORT_VAL L"Transports"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNet::CClusNet()
//
//  Description:
//      Constructor of the CClusNet class
//
//  Arguments:
//      pbcaParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CAssert
//          If the parameters are incorrect.
//
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusNet::CClusNet(
      CBaseClusterAction *  pbcaParentActionIn
    )
    : m_cservClusNet( CLUSNET_SERVICE_NAME )
    , m_pbcaParentAction( pbcaParentActionIn )
{

    BCATraceScope( "" );

    if ( m_pbcaParentAction == NULL) 
    {
        BCATraceMsg( "Pointers to the parent action is NULL. Throwing exception." );
        THROW_ASSERT( 
              E_INVALIDARG
            , "CClusNet::CClusNet() => Required input pointer in NULL"
            );
    } // if: the parent action pointer is NULL

} //*** CClusNet::CClusNet()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNet::~CClusNet( void )
//
//  Description:
//      Destructor of the CClusNet class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusNet::~CClusNet( void )
{
    BCATraceScope( "" );

} //*** CClusNet::~CClusNet()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusNet::ConfigureService()
//
//  Description:
//      Installs the cluster network transport.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusNet::ConfigureService( void )
{
    BCATraceScope( "" );

    DWORD                   dwMappingSize = 0;
    DWORD                   dwSocketAddrLen = sizeof( SOCKADDR_CLUSTER );
    DWORD                   dwError = ERROR_SUCCESS;
    WSA_SETUP_DISPOSITION   wsdDisposition;


    {
        CStatusReport   srCreatingClusNet(
              PbcaGetParent()->PBcaiGetInterfacePointer()
            , TASKID_Major_Configure_Cluster_Services
            , TASKID_Minor_Creating_ClusNet_Service
            , 0, 1
            , IDS_TASK_CREATING_CLUSNET
            );

        LogMsg( "Creating the Cluster Network Provider." );

        // Send the next step of this status report.
        srCreatingClusNet.SendNextStep( S_OK );

        // Create the clusnet service.
        m_cservClusNet.Create( m_pbcaParentAction->HGetMainInfFileHandle() );


        LogMsg( "Setting Cluster Network Provider service parameters." );

        CRegistryKey    regClusNetWinsockKey( 
              HKEY_LOCAL_MACHINE
            , CLUSNET_WINSOCK_KEY
            , KEY_ALL_ACCESS
            );

        //
        // Install the cluster network provider. A part of the required registry entries have
        // already been made when the service was created.
        //

        {
            //
            // The WSHClus DLL has to be loaded dynamically. Due to the decision to put the
            // code for the client side and the server side of ClusCfg in the same DLL, we
            // cannot implicitly link to any DLL that is not present on the client side even
            // if the functions in the DLL are called only on the server side.
            //

            typedef CSmartResource<
                CHandleTrait< 
                      HMODULE
                    , BOOL
                    , FreeLibrary
                    , reinterpret_cast< HMODULE >( NULL )
                    >
                > SmartModuleHandle;

            // Type of the WSHGetWinsockMapping function.
            typedef DWORD ( * WSHGetWinsockMappingFunctionType )( PWINSOCK_MAPPING, DWORD );

            // Pointer to the WSHGetWinsockMapping function.
            WSHGetWinsockMappingFunctionType pWSHGetWinsockMapping;

            // Get the full path the WSHClus DLL.
            CStr strWSHClusDllPath( m_pbcaParentAction->RStrGetClusterInstallDirectory() );
            strWSHClusDllPath += L"\\" WSHCLUS_DLL_NAME;

            // Load the library and store the handle in a smart  pointer for safe release.
            SmartModuleHandle smhWSHClusDll( LoadLibrary( strWSHClusDllPath.PszData() ) );


            if ( smhWSHClusDll.FIsInvalid() )
            {
                dwError = TW32( GetLastError() );

                LogMsg( "LoadLibrary() retured error %#08x trying to load '%s'. Aborting.", dwError, strWSHClusDllPath.PszData() );
                BCATraceMsg2( "LoadLibrary() retured error %#08x trying to load '%s'. Throwing an exception.", dwError, strWSHClusDllPath.PszData() );
                THROW_RUNTIME_ERROR(
                      HRESULT_FROM_WIN32( dwError )
                    , IDS_ERROR_CLUSNET_PROV_INSTALL
                    );
            } // if: LoadLibrary failed.

            pWSHGetWinsockMapping = reinterpret_cast< WSHGetWinsockMappingFunctionType >( 
                GetProcAddress( smhWSHClusDll.HHandle(), "WSHGetWinsockMapping" )
                );

            if ( pWSHGetWinsockMapping == NULL )
            {
                dwError = TW32( GetLastError() );

                BCATraceMsg1( "GetProcAddress() retured error %#08x. Throwing an exception.", dwError );
                THROW_RUNTIME_ERROR(
                      HRESULT_FROM_WIN32( dwError )
                    , IDS_ERROR_CLUSNET_PROV_INSTALL
                    );
            } // if: GetProcAddress() failed

            // Get WinSock mapping data
            dwMappingSize = pWSHGetWinsockMapping( NULL, 0 );

            CSmartGenericPtr< CPtrTrait< WINSOCK_MAPPING > >
                swmWinSockMapping( reinterpret_cast< WINSOCK_MAPPING * >( new BYTE[ dwMappingSize ] ) );

            if ( swmWinSockMapping.FIsEmpty() )
            {
                LogMsg( "A memory allocation failure occurred while setting Cluster Network Provider service parameters." );
                BCATraceMsg1( "Could not allocate %d bytes of memory for WinSock mapping. Throwing exception.", dwMappingSize );
                THROW_RUNTIME_ERROR(
                      E_OUTOFMEMORY
                    , IDS_ERROR_CLUSNET_PROV_INSTALL
                    );
            } // if: we could not allocate memory for the winsock mapping.


            // Get the winsock mapping.
            dwMappingSize = pWSHGetWinsockMapping( swmWinSockMapping.PMem(), dwMappingSize );

            // Write it to the registry.
            BCATraceMsg2( "Writing registry value HKLM\\%s\\%s.", CLUSNET_WINSOCK_KEY, CLUSNET_WINSOCK_MAPPING );
            regClusNetWinsockKey.SetValue( 
                  CLUSNET_WINSOCK_MAPPING
                , REG_BINARY
                , reinterpret_cast< const BYTE *>( swmWinSockMapping.PMem() )
                , dwMappingSize
                );
        }

        //
        // Write the minimum and maximum socket address length to the registry.
        //
        BCATraceMsg2( "Writing registry value HKLM\\%s\\%s.", CLUSNET_WINSOCK_KEY, CLUSNET_WINSOCK_MINSOCKADDRLEN );
        regClusNetWinsockKey.SetValue( 
              CLUSNET_WINSOCK_MINSOCKADDRLEN
            , REG_DWORD
            , reinterpret_cast< const BYTE *>( &dwSocketAddrLen )
            , sizeof( dwSocketAddrLen )
            );

        BCATraceMsg2( "Writing registry value HKLM\\%s\\%s.", CLUSNET_WINSOCK_KEY, CLUSNET_WINSOCK_MAXSOCKADDRLEN );
        regClusNetWinsockKey.SetValue( 
              CLUSNET_WINSOCK_MAXSOCKADDRLEN 
            , REG_DWORD
            , reinterpret_cast< const BYTE *>( &dwSocketAddrLen )
            , sizeof( dwSocketAddrLen )
            );

        //
        // Poke winsock to update the Winsock2 config
        //
        BCATraceMsg( "About to migrate winsock configuration." );
        dwError = TW32( MigrateWinsockConfiguration( &wsdDisposition, NULL, NULL ) );

        if ( dwError != ERROR_SUCCESS )
        {
            LogMsg( "Error %#08x occurred while trying to migrate the Winsock Configuration.", dwError );
            BCATraceMsg1( "MigrateWinsockConfiguration has returned error %#08x. Throwing exception.", dwError );
            THROW_RUNTIME_ERROR(
                  HRESULT_FROM_WIN32( dwError )
                , IDS_ERROR_CLUSNET_PROV_INSTALL
                );
        } // if: an error occurred poking winsock.

        // Send the last step of this status report.
        srCreatingClusNet.SendNextStep( S_OK );
    }

    {
        UINT    cQueryCount = 10;

        CStatusReport   srStartingClusNet(
              PbcaGetParent()->PBcaiGetInterfacePointer()
            , TASKID_Major_Configure_Cluster_Services
            , TASKID_Minor_Starting_ClusNet_Service
            , 0, cQueryCount + 2    // we will send at most cQueryCount reports while waiting for the service to start (the two extra sends are below)
            , IDS_TASK_STARTING_CLUSNET
            );

        // Send the next step of this status report.
        srStartingClusNet.SendNextStep( S_OK );

        // Start the service.
        m_cservClusNet.Start(
              m_pbcaParentAction->HGetSCMHandle()
            , true                  // wait for the service to start
            , 500                   // wait 500ms between queries for status.
            , cQueryCount           // query cQueryCount times.
            , &srStartingClusNet    // status report to be sent while waiting for the service to start
            );

        // Send the last step of this status report.
        srStartingClusNet.SendLastStep( S_OK );
    }

} //*** CClusNet::ConfigureService()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusNet::CleanupService()
//
//  Description:
//      Remove ClusNet from the Winsock transports list. Delete the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusNet::CleanupService( void )
{
    BCATraceScope( "" );

    DWORD                   dwError = ERROR_SUCCESS;
    WCHAR *                 pmszTransportList = NULL;
    DWORD                   cbBufSize = 0;
    DWORD                   cbBufRemaining = 0;
    UINT                    uiClusNetNameLenPlusOne = wcslen( CLUSNET_SERVICE_NAME ) + 1;
    UINT                    cbClusNetNameSize = uiClusNetNameLenPlusOne * sizeof( WCHAR );
    WSA_SETUP_DISPOSITION   wsdDisposition;


    LogMsg( "Stopping the Cluster Network Provider service." );

    // Stop the service.
    m_cservClusNet.Stop(
          m_pbcaParentAction->HGetSCMHandle()
        , 500       // wait 500ms between queries for status.
        , 10        // query 10 times.
        );

    LogMsg( "Cleaning up the Cluster Network Provider service." );

    // Clean up the ClusNet service.
    m_cservClusNet.Cleanup( m_pbcaParentAction->HGetMainInfFileHandle() );

    // Open the winsock registry key.
    CRegistryKey    regWinsockKey( 
          HKEY_LOCAL_MACHINE
        , WINSOCK_PARAMS_KEY
        , KEY_ALL_ACCESS
        );

    //
    // Remove the cluster network provider from the Winsock transports list.
    //

    BCATraceMsg( "Reading the Winsock transport list." );

    regWinsockKey.QueryValue(
          WINSOCK_PARAMS_TRANSPORT_VAL
        , reinterpret_cast< LPBYTE * >( &pmszTransportList )
        , &cbBufSize
        );

    //
    // Assign the pointer to the allocated buffer to a smart pointer for automatic
    // release.
    //
    SmartSz sszTransports( pmszTransportList );


    // Remove the string "ClusNet" from the multisz list.
    BCATraceMsg( "Removing ClusNet from the Winsock transport list." );

    cbBufRemaining = cbBufSize;
    while ( *pmszTransportList != L'\0' )
    {
        UINT    uiCurStrLenPlusOne = wcslen( pmszTransportList ) + 1;

        // If this string is ClusNet
        if (    ( uiCurStrLenPlusOne == uiClusNetNameLenPlusOne )
             && ( _wcsicmp( pmszTransportList, CLUSNET_SERVICE_NAME ) == 0 )
           )
        {
            // Remove this string from the list
            cbBufSize -= cbClusNetNameSize;

            // Decrement the amount of buffer yet unparsed.
            cbBufRemaining -= cbClusNetNameSize;

            MoveMemory( 
                  pmszTransportList
                , pmszTransportList + uiClusNetNameLenPlusOne
                , cbBufRemaining
                );
        } // if: this string is "ClusNet"
        else
        {
            // Decrement the amount of buffer yet unparsed.
            cbBufRemaining -= uiCurStrLenPlusOne * sizeof( *pmszTransportList );

            // Move to the next string
            pmszTransportList += uiCurStrLenPlusOne;
        } // else: this string is not "ClusNet"

    } // while: the transport list has not been completely parsed.


    BCATraceMsg( "Writing the Winsock transport list back to the registry." );

    // Write the new list back into the registry.
    regWinsockKey.SetValue(
          WINSOCK_PARAMS_TRANSPORT_VAL
        , REG_MULTI_SZ
        , reinterpret_cast< BYTE * >( sszTransports.PMem() )
        , cbBufSize
        );

    //
    // Poke winsock to update the Winsock2 config
    //
    BCATraceMsg( "About to migrate winsock configuration." );
    dwError = TW32( MigrateWinsockConfiguration( &wsdDisposition, NULL, NULL ) );

    if ( dwError != ERROR_SUCCESS )
    {
        LogMsg( "Error %#08x occurred while trying to migrate the Winsock Configuration.", dwError );
        BCATraceMsg1( "MigrateWinsockConfiguration has returned error %#08x. Throwing exception.", dwError );
        THROW_RUNTIME_ERROR(
              HRESULT_FROM_WIN32( dwError )
            , IDS_ERROR_CLUSNET_PROV_INSTALL
            );
    } // if: an error occurred poking winsock.

} //*** CClusNet::CleanupService()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusnet.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusNet.h
//
//  Description:
//      Header file for CClusNet class.
//      The CClusNet class performs operations that are common to many
//      configuration tasks of the ClusSvc service.
//
//  Implementation Files:
//      CClusNet.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CAction base class
#include "CAction.h"

// For the CService class
#include "CService.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterAction;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusNet
//
//  Description:
//      The CClusNet class performs operations that are common to many
//      configuration tasks of the ClusSvc service.
//
//      This class is intended to be used as the base class for other ClusNet
//      related action classes.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusNet : public CAction
{
protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusNet(
          CBaseClusterAction * pbcaParentActionIn
        );

    // Default destructor.
    ~CClusNet();


    //////////////////////////////////////////////////////////////////////////
    // Protected methods
    //////////////////////////////////////////////////////////////////////////

    // Create and configure the service.
    void
        ConfigureService();

    // Cleanup and remove the service.
    void
        CleanupService();

    
    //////////////////////////////////////////////////////////////////////////
    // Protected accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the ClusNet service object.
    CService &
        RcsGetService() throw()
    {
        return m_cservClusNet;
    }

    // Get the parent action
    CBaseClusterAction *
        PbcaGetParent() throw()
    {
        return m_pbcaParentAction;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CClusNet( const CClusNet & );

    // Assignment operator
    const CClusNet & operator =( const CClusNet & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // The CService object representing the ClusNet service.
    CService                m_cservClusNet;

    // Pointer to the base cluster action of which this action is a part.
    CBaseClusterAction *    m_pbcaParentAction;

}; //*** class CClusNet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusnetcleanup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusNetCleanup.h
//
//  Description:
//      Header file for CClusNetCleanup class.
//      The CClusNetCleanup class is an action that cleans up the ClusNet service.
//
//  Implementation Files:
//      CClusNetCleanup.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 01-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CClusNet base class
#include "CClusNet.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterCleanup;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusNetCleanup
//
//  Description:
//      The CClusNetCleanup class is an action that clean up the ClusNet service.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusNetCleanup : public CClusNet
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusNetCleanup( CBaseClusterCleanup * pbccParentActionIn );

    // Default destructor.
    ~CClusNetCleanup();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Clean up the ClusNet service.
    //
    void Commit();

    //
    // Rollback this cleanup.
    //
    void Rollback();


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CClusNet BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

}; //*** class CClusNetCleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusnetcreate.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusNetCreate.h
//
//  Description:
//      Header file for CClusNetCreate class.
//
//      The CClusNetCreate class creates and configures the ClusNet service.
//      This class can be used during both form and join operations.
//
//  Implementation Files:
//      CClusNetCreate.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CClusNet base class
#include "CClusNet.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterAddNode;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusNetCreate
//
//  Description:
//      The CClusNetCreate class performs operations that are common to many
//      configuration tasks.
//
//      This class is intended to be used as the base class for other ClusNet
//      related action classes.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusNetCreate : public CClusNet
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusNetCreate(
          CBaseClusterAddNode * pbcanParentActionIn
        );

    // Default destructor.
    ~CClusNetCreate();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    // Create the ClusNet service.
    void Commit();

    // Rollback this creation.
    void Rollback();

    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        // Two notifications are sent:
        // 1. When the service is created.
        // 2. When the service starts.
        return 2;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CClusNet BaseClass;

}; //*** class CClusNetCreate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclussvc.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusSvc.h
//
//  Description:
//      Header file for CClusSvc class.
//      The CClusSvc class performs operations that are common to many
//      configuration tasks of the ClusSvc service.
//
//  Implementation Files:
//      CClusSvc.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CAction base class
#include "CAction.h"

// For the CService class
#include "CService.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterAction;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusSvc
//
//  Description:
//      The CClusSvc class performs operations that are common to many
//      configuration tasks of the ClusSvc service.
//
//      This class is intended to be used as the base class for other ClusSvc
//      related action classes.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusSvc : public CAction
{
protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusSvc(
          CBaseClusterAction * pbcaParentActionIn
        );

    // Default destructor.
    ~CClusSvc();


    //////////////////////////////////////////////////////////////////////////
    // Protected methods
    //////////////////////////////////////////////////////////////////////////

    // Create and configure the service.
    void
        ConfigureService(
              const WCHAR *     pszClusterDomainAccountNameIn
            , const WCHAR *     pszClusterAccountPwdIn
            , const WCHAR *     pszNodeIdString
            , bool              fIsVersionCheckingDisabledIn
            );

    // Cleanup and remove the service.
    void
        CleanupService();


    //////////////////////////////////////////////////////////////////////////
    // Protected accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the ClusSvc service object.
    CService &
        RcsGetService() throw()
    {
        return m_cservClusSvc;
    }

    // Get the parent action
    CBaseClusterAction *
        PbcaGetParent() throw()
    {
        return m_pbcaParentAction;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CClusSvc( const CClusSvc & );

    // Assignment operator
    const CClusSvc & operator =( const CClusSvc & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // The CService object representing the ClusSvc service.
    CService                m_cservClusSvc;

    // Pointer to the base cluster action of which this action is a part.
    CBaseClusterAction *    m_pbcaParentAction;

}; //*** class CClusSvc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclussvc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CClusSvc.cpp
//
//  Description:
//      Contains the definition of the CClusSvc class.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header for this file
#include "CClusSvc.h"

// For DwRemoveDirectory()
#include "Common.h"

// To set the failure actions of the cluster service.
#include "clusrtl.h"


//////////////////////////////////////////////////////////////////////////////
// Macros
//////////////////////////////////////////////////////////////////////////////

// Name of the NodeId cluster service parameter registry value.
#define CLUSSVC_NODEID_VALUE   L"NodeId"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvc::CClusSvc()
//
//  Description:
//      Constructor of the CClusSvc class
//
//  Arguments:
//      pbcaParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CAssert
//          If the parameters are incorrect.
//
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusSvc::CClusSvc(
      CBaseClusterAction *  pbcaParentActionIn
    )
    : m_cservClusSvc( CLUSTER_SERVICE_NAME )
    , m_pbcaParentAction( pbcaParentActionIn )
{

    BCATraceScope( "" );

    if ( m_pbcaParentAction == NULL) 
    {
        BCATraceMsg( "Pointers to the parent action is NULL. Throwing exception." );
        THROW_ASSERT( 
              E_INVALIDARG
            , "CClusSvc::CClusSvc() => Required input pointer in NULL"
            );
    } // if: the parent action pointer is NULL

} //*** CClusSvc::CClusSvc()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvc::~CClusSvc( void )
//
//  Description:
//      Destructor of the CClusSvc class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusSvc::~CClusSvc( void )
{
    BCATraceScope( "" );

} //*** CClusSvc::~CClusSvc()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusSvc::ConfigureService()
//
//  Description:
//      Create the service, set the failure actions and the service account.
//      Then start the service.
//
//  Arguments:
//      pszClusterDomainAccountNameIn
//      pszClusterAccountPwdIn
//          Information about the account to be used as the cluster service
//          account.
//
//      pszNodeIdString
//          String containing the Id of this node.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvc::ConfigureService(
      const WCHAR *     pszClusterDomainAccountNameIn
    , const WCHAR *     pszClusterAccountPwdIn
    , const WCHAR *     pszNodeIdStringIn
    , bool              fIsVersionCheckingDisabledIn
    )
{
    BCATraceScope( "" );

    DWORD           dwError = ERROR_SUCCESS;

    CStatusReport   srCreatingClusSvc(
          PbcaGetParent()->PBcaiGetInterfacePointer()
        , TASKID_Major_Configure_Cluster_Services
        , TASKID_Minor_Creating_Cluster_Service
        , 0, 2
        , IDS_TASK_CREATING_CLUSSVC
        );

    LogMsg( "Configuring the Cluster service." );

    // Send the next step of this status report.
    srCreatingClusSvc.SendNextStep( S_OK );

    // Create the cluster service.
    m_cservClusSvc.Create( m_pbcaParentAction->HGetMainInfFileHandle() );

    do
    {
        LogMsg( "Setting the Cluster service account information." );


        // Open a smart handle to the cluster service.
        SmartSCMHandle  sscmhClusSvcHandle(
            OpenService(
                  m_pbcaParentAction->HGetSCMHandle()
                , CLUSTER_SERVICE_NAME
                , SERVICE_CHANGE_CONFIG
                )
            );


        if ( sscmhClusSvcHandle.FIsInvalid() )
        {
            dwError = TW32( GetLastError() );
            BCATraceMsg( "OpenService() failed." );
            break;
        } // if: we could not open a handle to the cluster service.

        //
        // Set the service account information.
        //
        {
            if ( 
                 ChangeServiceConfig(
                      sscmhClusSvcHandle
                    , SERVICE_NO_CHANGE
                    , SERVICE_NO_CHANGE
                    , SERVICE_NO_CHANGE
                    , NULL
                    , NULL
                    , NULL
                    , NULL
                    , pszClusterDomainAccountNameIn
                    , pszClusterAccountPwdIn
                    , NULL
                    ) 
                 == FALSE
               )
            {
                dwError = TW32( GetLastError() );
                BCATraceMsg1( 
                      "ChangeServiceConfig() failed. Account = '%ws'."
                    , pszClusterDomainAccountNameIn
                    );
                break;
            } // if: we could not set the account information.
        }

        LogMsg( "Setting the Cluster service failure actions." );

        // Set the failure actions of the cluster service service.
        dwError = TW32( ClRtlSetSCMFailureActions( NULL ) );
        if ( dwError != ERROR_SUCCESS )
        {
            BCATraceMsg( "ClRtlSetSCMFailureActions() failed." );
            break;
        } // if: the service failure actions couldn't be set

        LogMsg( "Setting the Cluster service parameters." );

        // Send the next step of this status report.
        srCreatingClusSvc.SendNextStep( S_OK );

        {
            CRegistryKey rkClusSvcParams;
            
            // Open the parameters key or create it if it does not exist.
            rkClusSvcParams.CreateKey(
                  HKEY_LOCAL_MACHINE
                , CLUSREG_KEYNAME_CLUSSVC_PARAMETERS
                , KEY_WRITE
                );

            // Set the NodeId string.
            rkClusSvcParams.SetValue(
                  CLUSSVC_NODEID_VALUE
                , REG_SZ
                , reinterpret_cast< const BYTE * >( pszNodeIdStringIn )
                , ( wcslen( pszNodeIdStringIn ) + 1 ) * sizeof( *pszNodeIdStringIn )
                );

            // If version checking has been disabled, set a flag in the service parameters
            // to indicate this.
            if ( fIsVersionCheckingDisabledIn )
            {
                DWORD   dwNoVersionCheck = 1;

                rkClusSvcParams.SetValue(
                      CLUSREG_NAME_SVC_PARAM_NOVER_CHECK
                    , REG_DWORD
                    , reinterpret_cast< const BYTE * >( &dwNoVersionCheck )
                    , sizeof( dwNoVersionCheck )
                    );

                BCATraceMsg( "Cluster version checking has been disabled on this computer." );
                LogMsg( "Cluster version checking has been disabled on this computer." );
            } // if: version checking has been disabled
        }

        //
        // Set the cluster installation state.
        //
        if ( ClRtlSetClusterInstallState( eClusterInstallStateConfigured ) == FALSE )
        {
            dwError = TW32( GetLastError() );
            LogMsg( "Could not set the cluster installation state." );
            BCATraceMsg( "Could not set the cluster installation state. Throwing exception." );

            break;
        } // ClRtlSetClusterInstallState() failed.

    }
    while( false ); // dummy do-while loop to avoid gotos

    if ( dwError != ERROR_SUCCESS )
    {
        LogMsg( "Error %#08x occurred trying configure the ClusSvc service.", dwError );
        BCATraceMsg1( "Error %#08x occurred trying configure the ClusSvc service. Throwing exception.", dwError );
        THROW_RUNTIME_ERROR(
              HRESULT_FROM_WIN32( dwError )
            , IDS_ERROR_CLUSSVC_CONFIG
            );
    } // if; there was an error getting the handle.

    // Send the next step of this status report.
    srCreatingClusSvc.SendNextStep( S_OK );

    {
        UINT    cQueryCount = 200;

        CStatusReport   srStartingClusSvc(
              PbcaGetParent()->PBcaiGetInterfacePointer()
            , TASKID_Major_Configure_Cluster_Services
            , TASKID_Minor_Starting_Cluster_Service
            , 0, cQueryCount + 2    // we will send at most cQueryCount reports while waiting for the service to start (the two extra sends are below)
            , IDS_TASK_STARTING_CLUSSVC
            );

        // Send the next step of this status report.
        srStartingClusSvc.SendNextStep( S_OK );

        // Start the service.
        m_cservClusSvc.Start(
              m_pbcaParentAction->HGetSCMHandle()
            , true                  // wait for the service to start
            , 1500                  // wait 1.5 seconds between queries for status.
            , cQueryCount           // query cQueryCount times
            , &srStartingClusSvc    // status report to be sent while waiting for the service to start
            );

        // Send the last step of this status report.
        srStartingClusSvc.SendLastStep( S_OK );
    }

} //*** CClusSvc::ConfigureService()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusSvc::CleanupService( void )
//
//  Description:
//      Stop, cleanup and remove the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvc::CleanupService( void )
{
    BCATraceScope( "" );

    LogMsg( "Trying to stop the Cluster Service." );

    // Stop the service.
    m_cservClusSvc.Stop(
          m_pbcaParentAction->HGetSCMHandle()
        , 5000      // wait 5 seconds between queries for status.
        , 60        // query 60 times ( 5 minutes )
        );

    //
    // Restore the cluster installation state.
    //
    if ( ClRtlSetClusterInstallState( eClusterInstallStateFilesCopied ) == FALSE )
    {
        DWORD dwError = GetLastError();

        LogMsg( "Could not set the cluster installation state." );
        BCATraceMsg( "Could not set the cluster installation state. Throwing exception." );

        THROW_RUNTIME_ERROR(
              HRESULT_FROM_WIN32( dwError )
            , IDS_ERROR_SETTING_INSTALL_STATE
            );
    } // ClRtlSetClusterInstallState() failed.

    LogMsg( "Cleaning up Cluster Service." );

    m_cservClusSvc.Cleanup( m_pbcaParentAction->HGetMainInfFileHandle() );

    // Cleanup the local quorum directory.
    {
        DWORD           dwError = ERROR_SUCCESS;
        const WCHAR *   pcszQuorumDir = m_pbcaParentAction->RStrGetLocalQuorumDirectory().PszData();

        dwError = TW32( DwRemoveDirectory( pcszQuorumDir ) );
        if ( dwError != ERROR_SUCCESS )
        {
            BCATraceMsg2( "The local quorum directory '%s' cannot be removed. Non-fatal error %#x occurred.\n", pcszQuorumDir, dwError );
            LogMsg( "The local quorum directory '%s' cannot be removed. Non-fatal error %#x occurred.\n", pcszQuorumDir, dwError );
        } // if: we could not remove the local quorum directory
    }

} //*** CClusSvc::CleanupService()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclusnetcreate.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CClusNetCreate.cpp
//
//  Description:
//      Contains the definition of the CClusNetCreate class.
//
//  Documentation:
//      TODO: Add pointer to external documentation later.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header for this file
#include "CClusNetCreate.h"

// For the CBaseClusterAddNode class.
#include "CBaseClusterAddNode.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetCreate::CClusNetCreate()
//
//  Description:
//      Constructor of the CClusNetCreate class
//
//  Arguments:
//      pbcaParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CAssert
//          If the parameters are incorrect.
//
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusNetCreate::CClusNetCreate(
      CBaseClusterAddNode * pbcanParentActionIn
    )
    : BaseClass( pbcanParentActionIn )
{

    BCATraceScope( "" );

    SetRollbackPossible( true );

} //*** CClusNetCreate::CClusNetCreate()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetCreate::~CClusNetCreate( void )
//
//  Description:
//      Destructor of the CClusNetCreate class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusNetCreate::~CClusNetCreate( void )
{
    BCATraceScope( "" );

} //*** CClusNetCreate::~CClusNetCreate()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusNetCreate::Commit( void )
//
//  Description:
//      Create and start the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusNetCreate::Commit( void )
{
    BCATraceScope( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    try
    {

        ConfigureService();

    } // try:
    catch( ... )
    {
        // If we are here, then something went wrong with the create.

        BCATraceMsg( "Caught exception during commit." );

        //
        // Cleanup anything that the failed create might have done.
        // Catch any exceptions thrown during Cleanup to make sure that there 
        // is no collided unwind.
        //
        try
        {
            CleanupService( );
        }
        catch( ... )
        {
            //
            // The rollback of the committed action has failed.
            // There is nothing that we can do.
            // We certainly cannot rethrow this exception, since
            // the exception that caused the rollback is more important.
            //

            THR( E_UNEXPECTED );

            BCATraceMsg( "Caught exception during cleanup." );
            LogMsg( "THIS COMPUTER MAY BE IN AN INVALID STATE. An error has occurred during cleanup." );

        } // catch: all

        // Rethrow the exception thrown by commit.
        throw;

    } // catch: all

    // If we are here, then everything went well.
    SetCommitCompleted( true );

} //*** CClusNetCreate::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusNetCreate::Rollback( void )
//
//  Description:
//      Cleanup the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusNetCreate::Rollback( void )
{
    BCATraceScope( "" );

    // Call the base class rollback method. 
    BaseClass::Rollback();

    // Cleanup this action.
    CleanupService();

    SetCommitCompleted( false );

} //*** CClusNetCreate::Rollback()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclussvcaccountconfig.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CClusSvcAccountConfig.cpp
//
//  Description:
//      Contains the definition of the CClusSvcAccountConfig class.
//
//  Maintained By:
//      David Potter    (DavidP)    30-MAR-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CClusSvcAccountConfig.h"

// For the CBaseClusterAddNode class.
#include "CBaseClusterAddNode.h"

// For the net local group functions.
#include <lmaccess.h>

// For NERR_Success
#include <lmerr.h>


//////////////////////////////////////////////////////////////////////////////
// Global Variables
//////////////////////////////////////////////////////////////////////////////

// Array of the names of rights to be granted to the cluster service account.
static const WCHAR * const gs_rgpcszRightsArray[] = {
      SE_SERVICE_LOGON_NAME
    , SE_BACKUP_NAME
    , SE_RESTORE_NAME
    , SE_INCREASE_QUOTA_NAME
    , SE_INC_BASE_PRIORITY_NAME
    , SE_TCB_NAME
    };

const UINT gc_uiRightsArraySize = sizeof( gs_rgpcszRightsArray ) / sizeof( gs_rgpcszRightsArray[0] );


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcAccountConfig::CClusSvcAccountConfig()
//
//  Description:
//      Constructor of the CClusSvcAccountConfig class
//
//  Arguments:
//      pbcanParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusSvcAccountConfig::CClusSvcAccountConfig(
      CBaseClusterAddNode *     pbcanParentActionIn
    )
    : m_pbcanParentAction( pbcanParentActionIn )
    , m_fWasAreadyInGroup( true )
    , m_fRightsGrantSuccessful( false )
    , m_fRemoveAllRights( false )

{
    BCATraceScope( "" );

    DWORD   dwError = ERROR_SUCCESS;
    UINT    uiIndex;

    // Indicate that action can be rolled back.
    SetRollbackPossible( true );

    do
    {
        PSID                        psidAdministrators      = NULL;
        SID_IDENTIFIER_AUTHORITY    siaNtAuthority          = SECURITY_NT_AUTHORITY;

        DWORD           dwNameSize = 0;
        DWORD           dwDomainSize = 0;
        SID_NAME_USE    snuSidNameUse;

        //
        // Get the Admins SID
        //
        if ( AllocateAndInitializeSid( 
                  &siaNtAuthority                   // identifier authority
                , 2                                 // count of subauthorities
                , SECURITY_BUILTIN_DOMAIN_RID       // subauthority 0
                , DOMAIN_ALIAS_RID_ADMINS           // subauthority 1
                , 0                                 // subauthority 2
                , 0                                 // subauthority 3
                , 0                                 // subauthority 4
                , 0                                 // subauthority 5
                , 0                                 // subauthority 6
                , 0                                 // subauthority 7
                , &psidAdministrators               // pointer to pointer to SID
                ) 
             == 0
           ) 
        {
            DWORD dwError = TW32( GetLastError() );
            TraceFlow1( "Error %#08x occurred trying get the Administrators group SID.", dwError );
            break;
        } // if: AllocateAndInitializeSid() failed

        // Assign the allocated SID to to the member variable.
        m_ssidAdminSid.Assign( psidAdministrators );


        //
        // Look up the administrators group name and store it.
        //

        // Find out how much space is required by the name.
        if ( LookupAccountSid(
                  NULL
                , psidAdministrators
                , NULL
                , &dwNameSize
                , NULL
                , &dwDomainSize
                , &snuSidNameUse
                )
             ==  FALSE
           )
        {
            dwError = GetLastError();

            if ( dwError != ERROR_INSUFFICIENT_BUFFER )
            {
                TW32( dwError );
                TraceFlow( "LookupAccountSid() failed while querying for required buffer size." );
                break;
            } // if: something else has gone wrong.
            else
            {
                // This is expected.
                dwError = ERROR_SUCCESS;
            } // if: ERROR_INSUFFICIENT_BUFFER was returned.
        } // if: LookupAccountSid failed

        // Allocate memory for the admin group name and the domain name.
        m_sszAdminGroupName.Assign( new WCHAR[ dwNameSize ] );
        
        SmartSz sszDomainName( new WCHAR[ dwDomainSize ] );

        if ( m_sszAdminGroupName.FIsEmpty() || sszDomainName.FIsEmpty() )
        {
            dwError = ERROR_OUTOFMEMORY;
            break;
        } // if: there wasn't enough memory

        // Get the admin group name.
        if ( LookupAccountSid(
                  NULL
                , psidAdministrators
                , m_sszAdminGroupName.PMem()
                , &dwNameSize
                , sszDomainName.PMem()
                , &dwDomainSize
                , &snuSidNameUse
                )
             ==  FALSE
           )
        {
            dwError = GetLastError();
            TraceFlow( "LookupAccountSid() failed while attempting to get the admin group name." );
            break;
        } // if: LookupAccountSid failed

    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( dwError != ERROR_SUCCESS )
    {
        LogMsg( "Error %#08x occurred trying to get information about the administrators group.", dwError );
        TraceFlow1( "Error %#08x occurred trying to get information about the administrators group. Throwing exception.", dwError );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_GET_ADMIN_GROUP_INFO );
    } // if: something went wrong.

} //*** CClusSvcAccountConfig::CClusSvcAccountConfig()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcAccountConfig::~CClusSvcAccountConfig()
//
//  Description:
//      Destructor of the CClusSvcAccountConfig class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusSvcAccountConfig::~CClusSvcAccountConfig( void )
{
    BCATraceScope( "" );

} //*** CClusSvcAccountConfig::~CClusSvcAccountConfig()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusSvcAccountConfig::Commit()
//
//  Description:
//      Grant the required rights to the account.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvcAccountConfig::Commit( void )
{
    BCATraceScope( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    try
    {
        // Configure the account.
        ConfigureAccount();

    } // try:
    catch( ... )
    {
        // If we are here, then something went wrong with the create.

        TraceFlow( "Caught exception during commit." );

        //
        // Cleanup anything that the failed create might have done.
        // Catch any exceptions thrown during Cleanup to make sure that there 
        // is no collided unwind.
        //
        try
        {
            RevertAccount();
        }
        catch( ... )
        {
            //
            // The rollback of the committed action has failed.
            // There is nothing that we can do.
            // We certainly cannot rethrow this exception, since
            // the exception that caused the rollback is more important.
            //

            THR( E_UNEXPECTED );

            TraceFlow( "Caught exception during cleanup." );
            LogMsg( "THIS COMPUTER MAY BE IN AN INVALID STATE. An error has occurred during cleanup." );

        } // catch: all

        // Rethrow the exception thrown by commit.
        throw;

    } // catch: all

    // If we are here, then everything went well.
    SetCommitCompleted( true );

} //*** CClusSvcAccountConfig::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusSvcAccountConfig::Rollback()
//
//  Description:
//      Roll the account back to the state it was in before we tried to
//      grant it the required privileges.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvcAccountConfig::Rollback( void )
{
    BCATraceScope( "" );

    // Call the base class rollback method. 
    BaseClass::Rollback();

    // Bring the account back to its original state.
    RevertAccount();

    SetCommitCompleted( false );

} //*** CClusSvcAccountConfig::Rollback()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusSvcAccountConfig::ConfigureAccount()
//
//  Description:
//      Grant the account that will be the cluster service account the requried
//      privileges.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvcAccountConfig::ConfigureAccount( void )
{
    BCATraceScope( "" );

    typedef CSmartResource<
        CHandleTrait< 
              PLSA_UNICODE_STRING
            , NTSTATUS
            , reinterpret_cast< NTSTATUS (*)( PLSA_UNICODE_STRING ) >( LsaFreeMemory )
            , reinterpret_cast< PLSA_UNICODE_STRING >( NULL )
            >
        >
        SmartLsaUnicodeStringPtr;

    NTSTATUS                ntStatus;
    PLSA_UNICODE_STRING     plusAccountRights = NULL;
    ULONG                   ulOriginalRightsCount = 0;
    ULONG                   rgulToBeGrantedIndex[ gc_uiRightsArraySize ];
    ULONG                   ulIndex;
    ULONG                   ulIndexInner;
    DWORD                   dwError;

    CStatusReport           srConfigAcct(
          m_pbcanParentAction->PBcaiGetInterfacePointer()
        , TASKID_Major_Configure_Cluster_Services
        , TASKID_Minor_Configuring_Cluster_Service_Account
        , 0, 1
        , IDS_TASK_CONFIG_CLUSSVC_ACCOUNT
        );


    // Send the next step of this status report.
    srConfigAcct.SendNextStep( S_OK );

    // Add the cluster service account to the local admin group.
    m_fWasAreadyInGroup = FChangeAdminGroupMembership( 
          m_pbcanParentAction->PSidGetServiceAccountSID()
        , true 
        );

    LogMsg( "Determining the rights that need to be granted to the cluster service account." );

    // Get the list of rights already granted to the cluster service account.
    ntStatus = LsaEnumerateAccountRights(
                          m_pbcanParentAction->HGetLSAPolicyHandle()
                        , m_pbcanParentAction->PSidGetServiceAccountSID()
                        , &plusAccountRights
                        , &ulOriginalRightsCount
                        );

    if ( ntStatus != STATUS_SUCCESS )
    {
        //
        // LSA returns this error code if the account has no rights granted or denied to it
        // locally. This is not an error as far as we are concerned.
        //
        if ( ntStatus == STATUS_OBJECT_NAME_NOT_FOUND  )
        { 
            ntStatus = STATUS_SUCCESS;
            TraceFlow( "The account has no locally assigned rights." );
            m_fRemoveAllRights = true;
            plusAccountRights = NULL;
            ulOriginalRightsCount = 0;
        } // if: the account does not have any rights assigned locally to it.
        else
        {
            THR( ntStatus );
            LogMsg( "Error %#08x occurred trying to enumerate the cluster service account rights.", ntStatus );
            TraceFlow1( "Error %#08x occurred trying to enumerate the cluster service account rights. Throwing exception", ntStatus );

            THROW_RUNTIME_ERROR( ntStatus, IDS_ERROR_ACCOUNT_RIGHTS_CONFIG );
        } // else: something went wrong.
    } // if: LsaEnumerateAccountRights() failed

    // Store the account rights just enumerated in a smart pointer for automatic release.
    SmartLsaUnicodeStringPtr splusOriginalRights( plusAccountRights );

    // Initialize the count of rights to be granted.
    m_ulRightsToBeGrantedCount = 0;

    // Determine which of the rights that we are going to grant the account are already granted.
    for ( ulIndex = 0; ulIndex < gc_uiRightsArraySize; ++ulIndex )
    {
        bool fRightAlreadyGranted = false;

        for ( ulIndexInner = 0; ulIndexInner < ulOriginalRightsCount; ++ulIndexInner )
        {
            const WCHAR *   pchGrantedRight         = plusAccountRights[ ulIndexInner ].Buffer;
            USHORT          usCharCount             = plusAccountRights[ ulIndexInner ].Length / sizeof( *pchGrantedRight );
            const WCHAR *   pcszToBeGrantedRight    = gs_rgpcszRightsArray[ ulIndex ];

            // Do our own string compare since LSA_UNICODE_STRING may not be '\0' terminated.
            while ( ( usCharCount > 0 ) && ( *pcszToBeGrantedRight != L'\0' ) )
            {
                if ( *pchGrantedRight != *pcszToBeGrantedRight )
                {
                    break;
                } // if: the current characters are not the same.

                --usCharCount;
                ++pcszToBeGrantedRight;
                ++pchGrantedRight;
            } // while: there are still characters to be compared

            // The strings are equal.
            if ( ( usCharCount == 0 ) && ( *pcszToBeGrantedRight == L'\0' ) )
            {
                fRightAlreadyGranted = true;
                break;
            } // if: the strings are equal

        } // for: loop through the list of rights already granted to the account

        // Is the current right already granted.
        if ( ! fRightAlreadyGranted )
        {
            // The current right is not already granted.
            rgulToBeGrantedIndex[ m_ulRightsToBeGrantedCount ] = ulIndex;

            // One more right to be granted.
            ++m_ulRightsToBeGrantedCount;
        } // if: the current right was not already granted
    } // for: loop through the list of rights that we want to grant the account

    //
    // Create an array of LSA_UNICODE_STRINGs of right names to be granted and store it in the
    // member variable.
    //
    m_srglusRightsToBeGrantedArray.Assign( new LSA_UNICODE_STRING[ m_ulRightsToBeGrantedCount ] );

    if ( m_srglusRightsToBeGrantedArray.FIsEmpty() )
    {
        LogMsg( "A memory allocation error occurred trying to grant account rights." );
        TraceFlow1( "Could not allocate %d bytes of memory. Throwing exception.", m_ulRightsToBeGrantedCount );
        THROW_RUNTIME_ERROR(
              E_OUTOFMEMORY
            , IDS_ERROR_ACCOUNT_RIGHTS_CONFIG
            );
    } // if: memory allocation failed.

    // Initialize the array.
    for ( ulIndex = 0; ulIndex < m_ulRightsToBeGrantedCount; ++ ulIndex )
    {
        ULONG   ulCurrentRightIndex = rgulToBeGrantedIndex[ ulIndex ];

        TraceFlow1( "The '%ws' right will be granted.", gs_rgpcszRightsArray[ ulCurrentRightIndex ] );

        // Add it to the list of rights to be granted.
        InitLsaString( 
              const_cast< WCHAR * >( gs_rgpcszRightsArray[ ulCurrentRightIndex ] )
            , m_srglusRightsToBeGrantedArray.PMem() + ulIndex
            );

    } // for: iterate through the list of rights that need to be granted

    // Grant the rights.
    ntStatus = THR( LsaAddAccountRights(
                          m_pbcanParentAction->HGetLSAPolicyHandle()
                        , m_pbcanParentAction->PSidGetServiceAccountSID()
                        , m_srglusRightsToBeGrantedArray.PMem()
                        , m_ulRightsToBeGrantedCount
                        ) );

    if ( ntStatus != STATUS_SUCCESS )
    {
        LogMsg( "Error %#08x occurred trying to grant the cluster service account rights.", ntStatus );
        TraceFlow1( "Error %#08x occurred trying to grant the cluster service account rights. Throwing exception", ntStatus );

        THROW_RUNTIME_ERROR( ntStatus, IDS_ERROR_ACCOUNT_RIGHTS_CONFIG );
    } // if: LsaAddAccountRights() failed

    m_fRightsGrantSuccessful = true;

    // Send the last step of this status report.
    srConfigAcct.SendNextStep( S_OK );

} //*** CClusSvcAccountConfig::ConfigureAccount()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusSvcAccountConfig::RevertAccount()
//
//  Description:
//      Bring the account back to its original state.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvcAccountConfig::RevertAccount( void )
{
    BCATraceScope( "" );

    // Check if we granted any rights to the service account. If we did, revoke them.
    if ( m_fRightsGrantSuccessful )
    {
        NTSTATUS ntStatus;

        // Revoke the rights.
        ntStatus = THR( LsaRemoveAccountRights(
                              m_pbcanParentAction->HGetLSAPolicyHandle()
                            , m_pbcanParentAction->PSidGetServiceAccountSID()
                            , m_fRemoveAllRights
                            , m_srglusRightsToBeGrantedArray.PMem()
                            , m_ulRightsToBeGrantedCount
                            ) );

        if ( ntStatus != STATUS_SUCCESS )
        {
            LogMsg( "Error %#08x occurred trying to remove the granted cluster service account rights.", ntStatus );
            TraceFlow1( "Error %#08x occurred trying to remove the granted the cluster service account rights. Throwing exception", ntStatus );

            THROW_RUNTIME_ERROR( ntStatus, IDS_ERROR_ACCOUNT_RIGHTS_CONFIG );
        } // if: LsaRemoveAccountRights() failed
    } // if: we granted the service account any rights.

    // Check if we added the account to the admin group. If we did, remove it.
    if ( ! m_fWasAreadyInGroup )
    {
        FChangeAdminGroupMembership( m_pbcanParentAction->PSidGetServiceAccountSID(), false );
    } // if: we added the account to the admin group.

} //*** CClusSvcAccountConfig::RevertAccount()



//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusSvcAccountConfig::InitLsaString()
//
//  Description:
//      Initialize a LSA_UNICODE_STRING structure
//
//  Arguments:
//      pszSourceIn
//          The string used to initialize the unicode string structure.
//
//      plusUnicodeStringOut,
//          The output unicode string structure.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvcAccountConfig::InitLsaString(
      LPWSTR pszSourceIn
    , PLSA_UNICODE_STRING plusUnicodeStringOut
    )
{
    if ( pszSourceIn == NULL ) 
    {
        plusUnicodeStringOut->Buffer = NULL;
        plusUnicodeStringOut->Length = 0;
        plusUnicodeStringOut->MaximumLength = 0;

    } // if: input string is NULL
    else
    {
        plusUnicodeStringOut->Buffer = pszSourceIn;
        plusUnicodeStringOut->Length = static_cast< USHORT >( wcslen( pszSourceIn ) * sizeof( *pszSourceIn ) );
        plusUnicodeStringOut->MaximumLength = static_cast< USHORT >( plusUnicodeStringOut->Length + sizeof( *pszSourceIn ) );

    } // else: input string is not NULL

} //*** CClusSvcAccountConfig::InitLsaString()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  bool
//  CClusSvcAccountConfig::FChangeAdminGroupMembership()
//
//  Description:
//      Adds/removes an account to/from the administrators group.
//
//  Arguments:
//      psidAccountSidIn
//          Pointer to the SID the of account to add/remove to/from administrators
//          group.
//
//      fAddIn
//          The account is added to the administrators group if this parameter
//          is true. The account is removed from the group otherwise.
//
//  Return Value:
//      true if the accound was already present/absent in/from the group. 
//      false otherwise.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
bool CClusSvcAccountConfig::FChangeAdminGroupMembership(
      PSID psidAccountSidIn
    , bool fAddIn
    )
{
    BCATraceScope( "" );

    bool                        fWasAlreadyInGroup          = false;
    LOCALGROUP_MEMBERS_INFO_0   lgmiLocalGroupMemberInfo;
    NET_API_STATUS              nasStatus;

    lgmiLocalGroupMemberInfo.lgrmi0_sid = psidAccountSidIn;

    if ( fAddIn )
    {
        CStatusReport   srAddAcctToAdminGroup(
                              m_pbcanParentAction->PBcaiGetInterfacePointer()
                            , TASKID_Major_Configure_Cluster_Services
                            , TASKID_Minor_Make_Cluster_Service_Account_Admin
                            , 0, 1
                            , IDS_TASK_MAKING_CLUSSVC_ACCOUNT_ADMIN
                            );

        srAddAcctToAdminGroup.SendNextStep( S_OK );

        nasStatus = NetLocalGroupAddMembers(
                          NULL
                        , m_sszAdminGroupName.PMem()
                        , 0
                        , reinterpret_cast< LPBYTE >( &lgmiLocalGroupMemberInfo )
                        , 1
                        );

        if ( nasStatus == ERROR_MEMBER_IN_ALIAS )
        {
            LogMsg( "The account was already a member of the admin group." );
            TraceFlow( "The account was already a member of the admin group." );
            nasStatus = NERR_Success;
            fWasAlreadyInGroup = true;
            srAddAcctToAdminGroup.SendLastStep( S_OK, IDS_TASK_CLUSSVC_ACCOUNT_ALREADY_ADMIN );
        } // if: the account was already a member of the admin group.
        else
        {
            if ( nasStatus == NERR_Success )
            {
                TraceFlow( "The account has been added to the admin group." );
                srAddAcctToAdminGroup.SendLastStep( S_OK );
                fWasAlreadyInGroup = false;

            } // if: everything was ok
            else
            {
                HRESULT hr = HRESULT_FROM_WIN32( TW32( nasStatus ) );
                srAddAcctToAdminGroup.SendLastStep( hr );
                TraceFlow( "NetLocalGroupAddMembers() returned an error." );
            } // else: something went wrong
        } // else: the account was not already a member of the admin group.
    } // if: the account has to be added to the admin group
    else
    {
        LogMsg( "The account needs to be removed from the administrators group." );
        TraceFlow( "The account needs to be removed from the administrators group." );

        nasStatus = NetLocalGroupDelMembers(
                          NULL
                        , m_sszAdminGroupName.PMem()
                        , 0
                        , reinterpret_cast< LPBYTE >( &lgmiLocalGroupMemberInfo )
                        , 1
                        );

        if ( nasStatus == ERROR_NO_SUCH_MEMBER )
        {
            LogMsg( "The account was not a member of the admin group to begin with." );
            TraceFlow( "The account was not a member of the admin group to begin with." );
            nasStatus = NERR_Success;
            fWasAlreadyInGroup = false;
        } // if: the account was not a member of the admin group.
        else
        {
            if ( nasStatus == NERR_Success )
            {
                TraceFlow( "The account has been deleted from the admin group." );
                fWasAlreadyInGroup = true;
            } // if: everything was ok
            else
            {
                TW32( nasStatus );
                TraceFlow( "NetLocalGroupDelMembers() returned an error." );
            } // else: something went wrong
        } // else; the account was a member of the admin group.
    } // else: the account has to be deleted from the admin group

    if ( nasStatus != ERROR_SUCCESS )
    {
        LogMsg( "Error %#08x occurred trying to change membership in administrators group.", nasStatus );
        TraceFlow1( "Error %#08x occurred trying to change membership in administrators group. Throwing exception.", nasStatus );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( nasStatus ), IDS_ERROR_ADMIN_GROUP_ADD_REMOVE );
    } // if: something went wrong.
    else
    {
        LogMsg( "The account was successfully added/deleted to/from the group '%s'.", m_sszAdminGroupName.PMem() );
        TraceFlow1( "The account was successfully added/deleted to/from the group '%s'.", m_sszAdminGroupName.PMem() );
    } // else: everything was hunky-dory

    return fWasAlreadyInGroup;

} //*** CClusSvcAccountConfig::FChangeAdminGroupMembership()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclussvcaccountconfig.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusSvcAccountConfig.h
//
//  Description:
//      Header file for CClusSvcAccountConfig class.
//      The CClusSvcAccountConfig class is an action that grants 
//      the required rights to the cluster service account.
//
//  Implementation Files:
//      CClusSvcAccountConfig.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CAction base class
#include "CAction.h"

// For LsaClose, LSA_HANDLE, etc.
#include <ntsecapi.h>


//////////////////////////////////////////////////////////////////////////
// Forward declarations
//////////////////////////////////////////////////////////////////////////

// The parent action of this action.
class CBaseClusterAddNode;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusSvcAccountConfig
//
//  Description:
//      The CClusSvcAccountConfigAccountConfig class is an action that grants 
//      the required rights to the cluster service account.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusSvcAccountConfig : public CAction
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusSvcAccountConfig( CBaseClusterAddNode * pbcanParentActionIn );

    // Default destructor.
    ~CClusSvcAccountConfig();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Grant the required rights to the account.
    //
    void Commit();

    //
    // Revert the account to its previous state.
    //
    void Rollback();


    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        //
        // The notification is:
        // 1. Configuring the cluster service account
        //
        return 1;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private type definitions
    //////////////////////////////////////////////////////////////////////////
    typedef CAction BaseClass;

    typedef CSmartResource< CHandleTrait< PSID, PVOID, FreeSid > > SmartSid;

    typedef CSmartGenericPtr< CArrayPtrTrait< LSA_UNICODE_STRING > > SmartLSAUnicodeStringArray;


    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CClusSvcAccountConfig( const CClusSvcAccountConfig & );

    // Assignment operator
    CClusSvcAccountConfig & operator =( const CClusSvcAccountConfig & );

    // Assign the required rights to the account.
    void
        ConfigureAccount();

    // Undo the changes made in ConfigureAccount()
    void
        RevertAccount();

    // Initialize an LSA_UNICODE_STRING structure.
    void
    InitLsaString(
          LPWSTR pszSourceIn
        , PLSA_UNICODE_STRING plusUnicodeStringOut
        );

    // Add/remove an account from the administrators account.
    bool
        FChangeAdminGroupMembership( PSID psidAccountSidIn, bool fAddIn );

    
    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Pointer the parent of this action.
    CBaseClusterAddNode *           m_pbcanParentAction;

    // SID of the administrators group.
    SmartSid                        m_ssidAdminSid;

    // Name of the administrators group.
    SmartSz                         m_sszAdminGroupName;

    // Indicates if the cluster service account was already in the admin group or not.
    bool                            m_fWasAreadyInGroup;

    // List of unicode strings containing names of rights to be granted.
    SmartLSAUnicodeStringArray      m_srglusRightsToBeGrantedArray;

    // Number of strings in the above array.
    ULONG                           m_ulRightsToBeGrantedCount;

    // Indicate if all the rights assigned to this account should be removed.
    bool                            m_fRemoveAllRights;

    // Were any rights granted to the account.
    bool                            m_fRightsGrantSuccessful;

}; //*** class CClusSvcAccountConfig
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclussvccleanup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusSvcCleanup.h
//
//  Description:
//      Header file for CClusSvcCleanup class.
//      The CClusSvcCleanup class is an action that cleans up the cluster service.
//
//  Implementation Files:
//      CClusSvcCleanup.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 01-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CClusSvc base class
#include "CClusSvc.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterCleanup;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusSvcCleanup
//
//  Description:
//      The CClusSvcCleanup class is an action that clean up the ClusSvc service.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusSvcCleanup : public CClusSvc
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusSvcCleanup( CBaseClusterCleanup * pbccParentActionIn );

    // Default destructor.
    ~CClusSvcCleanup();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Clean up the ClusSvc service.
    //
    void Commit();

    //
    // Rollback this cleanup.
    //
    void Rollback();


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CClusSvc BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

}; //*** class CClusSvcCleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclussvccleanup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CClusSvcCleanup.cpp
//
//  Description:
//      Contains the definition of the CClusSvcCleanup class.
//
//  Documentation:
//      TODO: Add pointer to external documentation later.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 01-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header for this file
#include "CClusSvcCleanup.h"

// For the CBaseClusterCleanup class.
#include "CBaseClusterCleanup.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcCleanup::CClusSvcCleanup()
//
//  Description:
//      Constructor of the CClusSvcCleanup class
//
//  Arguments:
//      pbccParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusSvcCleanup::CClusSvcCleanup( CBaseClusterCleanup * pbccParentActionIn )
    : BaseClass( pbccParentActionIn )
{

    BCATraceScope( "" );

    // It is currently not possible to rollback a cleanup.
    SetRollbackPossible( false );

} //*** CClusSvcCleanup::CClusSvcCleanup()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcCleanup::~CClusSvcCleanup( void )
//
//  Description:
//      Destructor of the CClusSvcCleanup class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusSvcCleanup::~CClusSvcCleanup( void )
{
    BCATraceScope( "" );

} //*** CClusSvcCleanup::~CClusSvcCleanup()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusSvcCleanup::Commit( void )
//
//  Description:
//      Clean up the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvcCleanup::Commit( void )
{
    BCATraceScope( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    // Cleanup the cluster service.
    CleanupService();

    // If we are here, then everything went well.
    SetCommitCompleted( true );

} //*** CClusSvcCleanup::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusSvcCleanup::Rollback( void )
//
//  Description:
//      Rollback the cleanup the service. This is currently not supported.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvcCleanup::Rollback( void )
{
    BCATraceScope( "" );

    // Call the base class rollback method. This will throw an exception since
    // SetRollbackPossible( false ) was called in the constructor.

    BaseClass::Rollback();

    SetCommitCompleted( false );

} //*** CClusSvcCleanup::Rollback()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cenablethreadprivilege.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CEnableThreadPrivilege.cpp
//
//  Description:
//      Contains the definition of the CEnableThreadPrivilege class.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header for this file
#include "CEnableThreadPrivilege.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnableThreadPrivilege::CEnableThreadPrivilege
//
//  Description:
//      Constructor of the CEnableThreadPrivilege class. Enables the specified
//      privilege.
//
//  Arguments:
//      pcszPrivilegeNameIn
//          Name of the privilege to be enabled.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnableThreadPrivilege::CEnableThreadPrivilege( const WCHAR * pcszPrivilegeNameIn )
    : m_hThreadToken( NULL )
    , m_fPrivilegeEnabled( false )
{
    BCATraceScope1( "pcszPrivilegeNameIn = '%ws'", pcszPrivilegeNameIn );

    DWORD               dwError         = ERROR_SUCCESS;

    do
    {
        TOKEN_PRIVILEGES    tpPrivilege;
        DWORD               dwReturnLength  = sizeof( m_tpPreviousState );
        DWORD               dwBufferLength  = sizeof( tpPrivilege );

        // Open the current thread token.
        if ( OpenThreadToken( 
                  GetCurrentThread()
                , TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY
                , TRUE
                , &m_hThreadToken
                )
             == FALSE
           )
        {
            dwError = GetLastError();

            // If the thread has no token, then default to the process token.
            if ( dwError == ERROR_NO_TOKEN )
            {
                BCATraceMsg( "The thread has no token. Trying to open the process token." );

                if ( OpenProcessToken(
                          GetCurrentProcess()
                        , TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY
                        , &m_hThreadToken
                        )
                     == FALSE
                )
                {
                    dwError = TW32( GetLastError() );
                    BCATraceMsg1( "Error %#08x occurred trying to open the process token.", dwError );
                    break;
                } // if: OpenProcessToken() failed.

                // The process token was opened. All is well.
                dwError = ERROR_SUCCESS;

            } // if: the thread has no token
            else
            {
                TW32( dwError );
                BCATraceMsg1( "Error %#08x occurred trying to open the thread token.", dwError );
                break;
            } // if: some other error occurred
        } // if: OpenThreadToken() failed

        //
        // Initialize the TOKEN_PRIVILEGES structure.
        //
        tpPrivilege.PrivilegeCount = 1;

        if ( LookupPrivilegeValue( NULL, pcszPrivilegeNameIn, &tpPrivilege.Privileges[0].Luid ) == FALSE )
        {
            dwError = TW32( GetLastError() );
            BCATraceMsg1( "Error %#08x occurred trying to lookup privilege value.", dwError );
            break;
        } // if: LookupPrivilegeValue() failed

        tpPrivilege.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        // Enable the desired privilege.
        if ( AdjustTokenPrivileges(
                  m_hThreadToken
                , FALSE
                , &tpPrivilege
                , dwBufferLength
                , &m_tpPreviousState
                , &dwReturnLength
                )
             == FALSE
           )
        {
            dwError = TW32( GetLastError() );
            BCATraceMsg1( "Error %#08x occurred trying to enable the privilege.", dwError );
            break;
        } // if: AdjustTokenPrivileges() failed

        LogMsg( "Privilege '%ws' enabled for the current thread.", pcszPrivilegeNameIn );

        // Set a flag if the privilege was not already enabled.
        m_fPrivilegeEnabled = ( m_tpPreviousState.Privileges[0].Attributes != SE_PRIVILEGE_ENABLED );
    }
    while( false ); // dummy do-while loop to avoid gotos

    if ( dwError != ERROR_SUCCESS )
    {
        LogMsg( "Error %#08x occurred trying to enable privilege '%ws'.", dwError, pcszPrivilegeNameIn );
        BCATraceMsg2( "Error %#08x occurred trying to enable privilege '%ws'. Throwing exception.", dwError, pcszPrivilegeNameIn );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_ENABLE_THREAD_PRIVILEGE );
    } // if:something went wrong

} //*** CEnableThreadPrivilege::CEnableThreadPrivilege()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnableThreadPrivilege::~CEnableThreadPrivilege
//
//  Description:
//      Destructor of the CEnableThreadPrivilege class. Restores the specified
//      privilege to its original state.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnableThreadPrivilege::~CEnableThreadPrivilege( void ) throw()
{
    BCATraceScope( "" );

    DWORD dwError = ERROR_SUCCESS;

    if ( m_fPrivilegeEnabled )
    {
        if ( AdjustTokenPrivileges(
                  m_hThreadToken
                , FALSE
                , &m_tpPreviousState
                , sizeof( m_tpPreviousState )
                , NULL
                , NULL
                )
             == FALSE
           )
        {
            dwError = TW32( GetLastError() );
            LogMsg( "Error %#08x occurred trying to restore privilege.", dwError );
            BCATraceMsg1( "Error %#08x occurred trying to restore privilege.", dwError );
        } // if: AdjustTokenPrivileges() failed
        else
        {
            LogMsg( "Privilege restored.", dwError );
        } // else: no errors

    } // if: the privilege was successfully enabled in the constructor
    else
    {
        LogMsg( "Privilege was enabled to begin with. Doing nothing.", dwError );
    }

    if ( m_hThreadToken != NULL )
    {
        CloseHandle( m_hThreadToken );
    } // if: the thread handle was opened

} //*** CEnableThreadPrivilege::~CEnableThreadPrivilege()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cenablethreadprivilege.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CEnableThreadPrivilege.h
//
//  Description:
//      Header file for CEnableThreadPrivilege class.
//
//      The CEnableThreadPrivilege class enables a certain privilege for the
//      current thread in its constructor and automatically restores the
//      thread privileges in the destructor.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the TOKEN_PRIVILEGES structure.
#include <ntseapi.h>


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnableThreadPrivilege
//
//  Description:
//      The CEnableThreadPrivilege class enables a certain privilege for the
//      current thread in its constructor and automatically restores the
//      thread privileges in the destructor.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnableThreadPrivilege
{
public:

    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Construtor. Enables the privilege
    CEnableThreadPrivilege( const WCHAR * pcszPrivilegeNameIn );

    // Destructor. Restore the original state of the privilege.
    ~CEnableThreadPrivilege() throw();

private:

    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CEnableThreadPrivilege( const CEnableThreadPrivilege & );

    // Assignment operator
    const CEnableThreadPrivilege & operator =( const CEnableThreadPrivilege & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Previous state of this privilege.
    TOKEN_PRIVILEGES    m_tpPreviousState;

    // Handle to the token for the thread that created this object.
    HANDLE              m_hThreadToken;

    // Indicates if the privilege was successfully enabled or not.
    bool                m_fPrivilegeEnabled;

}; //*** class CEnableThreadPrivilege
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cexception.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CException.h
//
//  Description:
//      This file contains the declarations of base class for all exception
//      classes.
//
//  Implementation File:
//      None.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 26-APR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For HRESULT, WCHAR, etc.
#include <windef.h>


//////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

//
// Shorthand for throwing different exceptions.
//

#define THROW_EXCEPTION( _hrErrorCode ) \
    throw CException( _hrErrorCode, TEXT( __FILE__ ), __LINE__ )



//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CException
//
//  Description:
//      The CException is the base class for all exceptions thrown by
//      functions defined in this library.
//
//      An object of this class must have the m_hrErrorCode, m_pszFile and
//      m_uiLineNumber members initialized.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CException
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CException( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pszFileNameIn
        , UINT          uiLineNumberIn
        ) throw()
        : m_hrErrorCode( hrErrorCodeIn )
        , m_pszFileName( pszFileNameIn )
        , m_uiLineNumber( uiLineNumberIn )
    {
    }

    // Copy constructor.
    CException( const CException & ceSrcIn ) throw()
        : m_hrErrorCode( ceSrcIn.m_hrErrorCode )
        , m_pszFileName( ceSrcIn.m_pszFileName )
        , m_uiLineNumber( ceSrcIn.m_uiLineNumber )
    {
    }

    // Default virtual destructor.
    virtual 
        ~CException() throw() {}


    //////////////////////////////////////////////////////////////////////////
    // Public Methods
    //////////////////////////////////////////////////////////////////////////

    // Assignment operator.
    const CException & 
        operator =( const CException & ceSrcIn ) throw()
    {
        m_hrErrorCode = ceSrcIn.m_hrErrorCode;
        m_pszFileName = ceSrcIn.m_pszFileName;
        m_uiLineNumber = ceSrcIn.m_uiLineNumber;
        return *this;
    }

    //
    // Accessor methods.
    //
    HRESULT
        HrGetErrorCode() const throw() { return m_hrErrorCode; }

    void
        SetErrorCode( HRESULT hrNewCode ) throw() { m_hrErrorCode = hrNewCode; }

    const WCHAR *
        PszGetThrowingFile() const throw() { return m_pszFileName; }

    UINT
        UiGetThrowingLine() const throw() { return m_uiLineNumber; }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private members
    //////////////////////////////////////////////////////////////////////////

    // Default construction is not allowed.
    CException();


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////
    HRESULT         m_hrErrorCode;
    const WCHAR *   m_pszFileName;
    UINT            m_uiLineNumber;

}; //*** class CException
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cimpersonateuser.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CImpersonateUser.cpp
//
//  Description:
//      Contains the definition of the CImpersonateUser class.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 16-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header for this file
#include "CImpersonateUser.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CImpersonateUser::CImpersonateUser
//
//  Description:
//      Constructor of the CImpersonateUser class. Begins impersonating the
//      user specified by the argument.
//
//  Arguments:
//      hUserToken
//          Handle to the user account token to impersonate
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
CImpersonateUser::CImpersonateUser( HANDLE hUserToken )
    : m_hThreadToken( NULL )
    , m_fWasImpersonating( false )
{
    BCATraceScope1( "hUserToken = %p", hUserToken );

    DWORD dwError = ERROR_SUCCESS;

    do
    {

        // Check if this thread is already impersonating a client.
        {
            if (    OpenThreadToken(
                          GetCurrentThread()
                        , TOKEN_ALL_ACCESS
                        , FALSE
                        , &m_hThreadToken
                        )
                 == FALSE
               )
            {
                dwError = GetLastError();

                if ( dwError == ERROR_NO_TOKEN )
                {
                    // There is no thread token, so we are not impersonating - this is ok.
                    BCATraceMsg( "This thread is not impersonating anyone." );
                    m_fWasImpersonating = false;
                    dwError = ERROR_SUCCESS;
                } // if: there is no thread token
                else
                {
                    TW32( dwError );
                    BCATraceMsg( "OpenThreadToken() failed." );
                    break;
                } // else: something really went wrong
            } // if: OpenThreadToken() failed
            else
            {
                TOKEN_TYPE  ttTokenType;
                DWORD       dwReturnLength;

                if (    GetTokenInformation(
                              m_hThreadToken
                            , TokenType
                            , &ttTokenType
                            , sizeof( ttTokenType )
                            , &dwReturnLength
                            )
                     == FALSE
                   )
                {
                    dwError = TW32( GetLastError() );
                    BCATraceMsg( "GetTokenInformation() failed." );
                    break;
                } // if: GetTokenInformation() failed
                else
                {
                    m_fWasImpersonating = ( ttTokenType == TokenImpersonation );
                    BCATraceMsg1( "Is this thread impersonating anyone? %d ( 0 = No ).", m_fWasImpersonating );
                } // else: GetTokenInformation() succeeded
            } // else: OpenThreadToken() succeeded
        }


        // Try to impersonate the user.
        if ( ImpersonateLoggedOnUser( hUserToken ) == FALSE )
        {
            dwError = TW32( GetLastError() );
            BCATraceMsg( "ImpersonateLoggedOnUser() failed." );
            break;
        } // if: ImpersonateLoggedOnUser() failed

        BCATraceMsg( "Impersonation succeeded." );
    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( dwError != ERROR_SUCCESS )
    {
        LogMsg( "Error %#08x occurred trying to impersonate a user.", dwError );
        BCATraceMsg1( "Error %#08x occurred trying to impersonate a user. Throwing exception.", dwError );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_IMPERSONATE_USER );
    } // if:something went wrong

} //*** CImpersonateUser::CImpersonateUser()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CImpersonateUser::~CImpersonateUser
//
//  Description:
//      Destructor of the CImpersonateUser class. Reverts to the original token.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CImpersonateUser::~CImpersonateUser( void ) throw()
{
    BCATraceScope( "" );

    if ( m_fWasImpersonating )
    {
        // Try to revert to the previous impersonation.
        if ( ImpersonateLoggedOnUser( m_hThreadToken ) == FALSE )
        {
            // Something failed - nothing much we can do here
            DWORD dwError = TW32( GetLastError() );

            LogMsg( "!!! WARNING !!! Error %#08x occurred trying to revert to previous impersonation. Application may not run properly.", dwError );
            BCATraceMsg1( "!!! WARNING !!! Error %#08x occurred trying to revert to previous impersonation. Cannot throw exception from destructor. Application may not run properly.", dwError );

        } // if: ImpersonateLoggedOnUser() failed
        else
        {
            BCATraceMsg( "Successfully reverted to previous impersonation." );
        } // else: ImpersonateLoggedOnUser() succeeded    
    } // if: we were impersonating someone when we started
    else
    {
        // Try to revert to self.
        if ( RevertToSelf() == FALSE )
        {
            DWORD dwError = TW32( GetLastError() );

            LogMsg( "!!! WARNING !!! Error %#08x occurred trying to revert to self. Application may not run properly.", dwError );
            BCATraceMsg1( "!!! WARNING !!! Error %#08x occurred trying to revert to self. Cannot throw exception from destructor. Application may not run properly.", dwError );

        } // if: RevertToSelf() failed
        else
        {
            BCATraceMsg( "Successfully reverted to self." );
        } // else: RevertToSelf() succeeded
    } // else: we weren't impersonating anyone to begin with

} //*** CImpersonateUser::~CImpersonateUser()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cimpersonateuser.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CImpersonateUser.h
//
//  Description:
//      Header file for CImpersonateUser class.
//
//      The CImpersonateUser class begins impersonating a user in its 
//      constructor and automatically reverts to the original token in
//      the destructor.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 16-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CImpersonateUser
//
//  Description:
//      The CImpersonateUser class begins impersonating a user in its 
//      constructor and automatically reverts to the original token in
//      the destructor.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CImpersonateUser
{
public:

    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Construtor. Start impersonating the user whose token is passed in.
    CImpersonateUser( HANDLE hUserToken );

    // Destructor. Revert to the original token.
    ~CImpersonateUser() throw();

private:

    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CImpersonateUser( const CImpersonateUser & );

    // Assignment operator
    const CImpersonateUser & operator =( const CImpersonateUser & );


    //////////////////////////////////////////////////////////////////////////
    // Private member data
    //////////////////////////////////////////////////////////////////////////

    // Handle to the token for the thread before the impersonation began.
    HANDLE              m_hThreadToken;

    // Indicates if this thread was already impersonating a client when this
    // object was constructed.
    bool        m_fWasImpersonating;

}; //*** class CImpersonateUser
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclussvccreate.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusSvcCreate.h
//
//  Description:
//      Header file for CClusSvcCreate class.
//      The CClusSvcCreate class is an action that creates the cluster service.
//
//  Implementation Files:
//      CClusSvcCreate.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CClusSvc base class
#include "CClusSvc.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterAddNode;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusSvcCreate
//
//  Description:
//      The CClusSvcCreate class is an action that creates the ClusSvc service.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusSvcCreate : public CClusSvc
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusSvcCreate(
          CBaseClusterAddNode * pbcanParentActionIn
        );

    // Default destructor.
    ~CClusSvcCreate();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Create the ClusSvc service.
    //
    void Commit();

    //
    // Rollback this creation.
    //
    void Rollback();


    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        // Two notifications are sent:
        // 1. When the service is created.
        // 2. When the service starts.
        return 2;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CClusSvc BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

}; //*** class CClusSvcCreate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cclussvccreate.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CClusSvcCreate.cpp
//
//  Description:
//      Contains the definition of the CClusSvcCreate class.
//
//  Documentation:
//      TODO: Add pointer to external documentation later.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header for this file
#include "CClusSvcCreate.h"

// For the CBaseClusterAddNode class.
#include "CBaseClusterAddNode.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcCreate::CClusSvcCreate()
//
//  Description:
//      Constructor of the CClusSvcCreate class
//
//  Arguments:
//      pbcanParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusSvcCreate::CClusSvcCreate(
      CBaseClusterAddNode *     pbcanParentActionIn
    )
    : BaseClass( pbcanParentActionIn )
{

    BCATraceScope( "" );

    SetRollbackPossible( true );

} //*** CClusSvcCreate::CClusSvcCreate()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvcCreate::~CClusSvcCreate( void )
//
//  Description:
//      Destructor of the CClusSvcCreate class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusSvcCreate::~CClusSvcCreate( void )
{
    BCATraceScope( "" );

} //*** CClusSvcCreate::~CClusSvcCreate()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusSvcCreate::Commit( void )
//
//  Description:
//      Create and start the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CAssert
//          If the base parent of this action is not CBaseClusterAddNode.
//
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvcCreate::Commit( void )
{
    BCATraceScope( "" );

    // Get the parent action pointer.
    CBaseClusterAddNode *  pcanClusterAddNode = dynamic_cast< CBaseClusterAddNode *>( PbcaGetParent() );

    // If the parent action of this action is not CBaseClusterForm
    if ( pcanClusterAddNode == NULL )
    {
        THROW_ASSERT( E_POINTER, "The parent action of this action is not CBaseClusterAddNode." );
    } // an invalid pointer was passed in.

    // Call the base class commit method.
    BaseClass::Commit();

    try
    {
        // Create the service.
        ConfigureService(
              pcanClusterAddNode->RStrGetServiceDomainAccountName().PszData()
            , pcanClusterAddNode->RStrGetServiceAccountPassword().PszData()
            , pcanClusterAddNode->PszGetNodeIdString()
            , pcanClusterAddNode->FIsVersionCheckingDisabled()
            );

    } // try:
    catch( ... )
    {
        // If we are here, then something went wrong with the create.

        BCATraceMsg( "Caught exception during commit." );

        //
        // Cleanup anything that the failed create might have done.
        // Catch any exceptions thrown during Cleanup to make sure that there 
        // is no collided unwind.
        //
        try
        {
            CleanupService();
        }
        catch( ... )
        {
            //
            // The rollback of the committed action has failed.
            // There is nothing that we can do.
            // We certainly cannot rethrow this exception, since
            // the exception that caused the rollback is more important.
            //

            THR( E_UNEXPECTED );

            BCATraceMsg( "Caught exception during cleanup." );
            LogMsg( "THIS COMPUTER MAY BE IN AN INVALID STATE. An error has occurred during cleanup." );

        } // catch: all

        // Rethrow the exception thrown by commit.
        throw;

    } // catch: all

    // If we are here, then everything went well.
    SetCommitCompleted( true );

} //*** CClusSvcCreate::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusSvcCreate::Rollback( void )
//
//  Description:
//      Cleanup the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvcCreate::Rollback( void )
{
    BCATraceScope( "" );

    // Call the base class rollback method. 
    BaseClass::Rollback();

    // Cleanup the service.
    CleanupService();

    SetCommitCompleted( false );

} //*** CClusSvcCreate::Rollback()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\clist.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CList.h
//
//  Description:
//      Header file for CList template class.
//
//      CList is a template class the provides the functionality of a linked
//      list. It has an CIterator that allows both forward and reverse
//      traversal.
//
//      This class is intended to be used instead of std::list since the
//      use of STL is prohibited in our project.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 24-APR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include files
//////////////////////////////////////////////////////////////////////////////

// For the CException class
#include "CException.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  template< class t_Ty >
//  class CList
//
//  Description:
//      CList is a template class the provides the functionality of a linked
//      list. It has an CIterator that allows both forward and reverse
//      traversal.
//
//      This class is implemented as a circular doubly linked list.
//--
//////////////////////////////////////////////////////////////////////////////
template< class t_Ty >
class CList
{
private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    class CNode
    {
    public:
        // Constructor
        CNode( const t_Ty & rtyDataIn, CNode * pNextIn, CNode *pPrevIn )
            : m_tyData( rtyDataIn )
            , m_pNext( pNextIn )
            , m_pPrev( pPrevIn )
        {
        } //*** CNode()

        // Member data
        t_Ty        m_tyData;
        CNode *     m_pNext;
        CNode *     m_pPrev;
    }; //*** class CNode


public:
    //////////////////////////////////////////////////////////////////////////
    // Public types
    //////////////////////////////////////////////////////////////////////////

    class CIterator;
    friend class CIterator;

    // The iterator for this list
    class CIterator 
    {
    public:
        CIterator( CNode * pNodeIn = NULL ) throw()
            : m_pNode( pNodeIn )
        {} //*** CIterator()

        t_Ty & operator*() const throw()
        {
            return m_pNode->m_tyData;
        } //*** operator*()

        t_Ty * operator->() const throw()
        {
            return &( m_pNode->m_tyData );
        } //*** operator->()

        CIterator & operator++()
        {
            m_pNode = m_pNode->m_pNext;
            return *this;
        } //*** operator++()

        CIterator & operator--()
        {
            m_pNode = m_pNode->m_pPrev;
            return *this;
        } //*** operator--()

        bool operator==( const CIterator & rRHSIn ) const throw()
        {
            return ( m_pNode == rRHSIn.m_pNode );
        } //*** operator==()

        bool operator!=( const CIterator & rRHSIn ) const throw()
        {
            return ( m_pNode != rRHSIn.m_pNode );
        } //*** operator!=()

        CNode * PGetNodePtr() const throw()
        {
            return m_pNode;
        } //*** PGetNodePtr()

    private:
        class CList;
        friend class CList;

        CNode * m_pNode;

    }; //*** class CIterator


public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Default constructor
    CList()
        : m_cSize( 0 )
    {
        // The list is never empty. It always has the special "head" node.

        // The reinterpret_cast is required to prevent the constructor of t_Ty
        // from being called when the head node is created.
        m_pHead = reinterpret_cast< CNode * >( new char[ sizeof( *m_pHead ) ] );
        if ( m_pHead == NULL )
        {
            THROW_EXCEPTION( E_OUTOFMEMORY );
        } // if: memory allocation failed

        m_pHead->m_pNext = m_pHead;
        m_pHead->m_pPrev = m_pHead;
    } //*** CList()

    // Default destructor
    ~CList()
    {
        Empty();

        // Cast to void * to prevent destructor call
        delete reinterpret_cast< void * >( m_pHead );
    } //*** ~CList()


    //////////////////////////////////////////////////////////////////////////
    // Member functions
    //////////////////////////////////////////////////////////////////////////

    // Add to the end of the list
    void Append( const t_Ty & rctyNewDataIn )
    {
        InsertAfter( m_pHead->m_pPrev, rctyNewDataIn );
    } //*** Append()


    // Add a new node after the input node
    void InsertAfter( const CIterator & rciNodeIn, const t_Ty & rctyDataIn )
    {
        CNode * pNode = rciNodeIn.PGetNodePtr();

        CNode * pNewNode = new CNode( rctyDataIn, pNode->m_pNext, pNode );
        if ( pNewNode == NULL )
        {
            THROW_EXCEPTION( E_OUTOFMEMORY );
        } // if: memory allocation failed

        pNode->m_pNext->m_pPrev = pNewNode;
        pNode->m_pNext = pNewNode;

        ++m_cSize;
    } //*** InsertAfter()


    // Delete a node. After this operation the input iterator points to the next node.
    void DeleteAndMoveToNext( CIterator & riNodeIn )
    {
        CNode * pNode = riNodeIn.PGetNodePtr();

        // Move to the next node.
        ++riNodeIn;

        pNode->m_pNext->m_pPrev = pNode->m_pPrev;
        pNode->m_pPrev->m_pNext = pNode->m_pNext;

        delete pNode;

        --m_cSize;
    } //*** Delete()

    // Delete all the elements in this list.
    void Empty()
    {
        CIterator ciCurNode( m_pHead->m_pNext );
        while( m_cSize != 0 )
        {
            DeleteAndMoveToNext( ciCurNode );
        } // while: the list is not empty
    } //*** Empty()

    // Return an iterator pointing to the first element in the list
    CIterator CiBegin() const throw()
    {
        return CIterator( m_pHead->m_pNext );
    } //*** CiBegin()

    // Return an iterator pointing past the last element in the list.
    CIterator CiEnd() const throw()
    {
        return CIterator( m_pHead );
    } //*** CiEnd()

    // Get a count of the number of elements in the list.
    int CGetSize() const throw()
    {
        return m_cSize;
    } //*** CGetSize()


private:
    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CList( const CList & );

    // Assignment operator
    const CList & operator=( const CList & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Pointer to the head of the list
    CNode *     m_pHead;

    // Count of the number of elements in the list
    int         m_cSize;

}; //*** class CList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cnodeconfig.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CNodeConfig.cpp
//
//  Description:
//      Contains the definition of the CNodeConfig class.
//
//  Documentation:
//      TODO: Add pointer to external documentation later.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header for this file
#include "CNodeConfig.h"

// For the CBaseClusterAddNode class.
#include "CBaseClusterAddNode.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeConfig::CNodeConfig()
//
//  Description:
//      Constructor of the CNodeConfig class
//
//  Arguments:
//      pbcanParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CNodeConfig::CNodeConfig(
      CBaseClusterAddNode *     pbcanParentActionIn
    )
    : CNode( pbcanParentActionIn )
{
    BCATraceScope( "" );

    // Indicate that action can be rolled back.
    SetRollbackPossible( true );

} //*** CNodeConfig::CNodeConfig()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeConfig::~CNodeConfig( void )
//
//  Description:
//      Destructor of the CNodeConfig class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CNodeConfig::~CNodeConfig( void )
{
    BCATraceScope( "" );

} //*** CNodeConfig::~CNodeConfig()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CNodeConfig::Commit( void )
//
//  Description:
//      Perform the node specific configuration steps.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CNodeConfig::Commit( void )
{
    BCATraceScope( "" );

    CStatusReport   srConfigNode(
          PbcaGetParent()->PBcaiGetInterfacePointer()
        , TASKID_Major_Configure_Cluster_Services
        , TASKID_Minor_Configuring_Cluster_Node
        , 0, 1
        , IDS_TASK_CONFIG_NODE
        );

    // Get the parent action pointer.
    CBaseClusterAddNode *  pcanClusterAddNode = dynamic_cast< CBaseClusterAddNode *>( PbcaGetParent() );

    // If the parent action of this action is not CBaseClusterForm
    if ( pcanClusterAddNode == NULL )
    {
        THROW_ASSERT( E_POINTER, "The parent action of this action is not CBaseClusterAddNode." );
    } // an invalid pointer was passed in.

    // Call the base class commit method.
    BaseClass::Commit();

    // Send the next step of this status report.
    srConfigNode.SendNextStep( S_OK );

    try
    {
        LogMsg( "Making miscellaneous changes to the node." );

        // Configure the node.
        Configure( pcanClusterAddNode->RStrGetClusterName() );

    } // try:
    catch( ... )
    {
        // If we are here, then something went wrong with the configuration.

        BCATraceMsg( "Caught exception during commit." );

        //
        // Cleanup anything that the failed commit might have done.
        // Catch any exceptions thrown during Cleanup to make sure that there 
        // is no collided unwind.
        //
        try
        {
            Cleanup();
        }
        catch( ... )
        {
            //
            // The rollback of the committed action has failed.
            // There is nothing that we can do.
            // We certainly cannot rethrow this exception, since
            // the exception that caused the rollback is more important.
            //

            THR( E_UNEXPECTED );

            BCATraceMsg( "Caught exception during cleanup." );
            LogMsg( "THIS COMPUTER MAY BE IN AN INVALID STATE. An error has occurred during cleanup." );

        } // catch: all

        // Rethrow the exception thrown by commit.
        throw;

    } // catch: all

    // If we are here, then everything went well.
    SetCommitCompleted( true );

    // Send the last step of this status report.
    srConfigNode.SendNextStep( S_OK );

} //*** CNodeConfig::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CNodeConfig::Rollback( void )
//
//  Description:
//      Roll the node back to the state it was in before we tried to
//      configure it.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CNodeConfig::Rollback( void )
{
    BCATraceScope( "" );

    // Call the base class rollback method. 
    BaseClass::Rollback();

    // Bring the node back to its original state.
    Cleanup();

    SetCommitCompleted( false );

} //*** CNodeConfig::Rollback()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cnodecleanup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CNodeCleanup.cpp
//
//  Description:
//      Contains the definition of the CNodeCleanup class.
//
//  Documentation:
//      TODO: Add pointer to external documentation later.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 01-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header for this file
#include "CNodeCleanup.h"

// For the CBaseClusterCleanup class.
#include "CBaseClusterCleanup.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCleanup::CNodeCleanup()
//
//  Description:
//      Constructor of the CNodeCleanup class
//
//  Arguments:
//      pbccParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CNodeCleanup::CNodeCleanup( CBaseClusterCleanup * pbccParentActionIn )
    : BaseClass( pbccParentActionIn )
{

    BCATraceScope( "" );

    // It is currently not possible to rollback a cleanup.
    SetRollbackPossible( false );

} //*** CNodeCleanup::CNodeCleanup()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCleanup::~CNodeCleanup( void )
//
//  Description:
//      Destructor of the CNodeCleanup class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CNodeCleanup::~CNodeCleanup( void )
{
    BCATraceScope( "" );

} //*** CNodeCleanup::~CNodeCleanup()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CNodeCleanup::Commit( void )
//
//  Description:
//      Cleans up a node that is no longer a part of a cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CNodeCleanup::Commit( void )
{
    BCATraceScope( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    // Cleanup the miscellaneous entries made when this node joined a cluster.
    Cleanup();

    // If we are here, then everything went well.
    SetCommitCompleted( true );

} //*** CNodeCleanup::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CNodeCleanup::Rollback( void )
//
//  Description:
//      Rollback the cleanup of this node. This is currently not supported.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CNodeCleanup::Rollback( void )
{
    BCATraceScope( "" );

    // Call the base class rollback method. This will throw an exception since
    // SetRollbackPossible( false ) was called in the constructor.

    BaseClass::Rollback();

    SetCommitCompleted( false );

} //*** CNodeCleanup::Rollback()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\commondefs.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CommonDefs.h
//
//  Description:
//      This file contains a few definitions common to many classes and files.
//
//  Implementation Files:
//      None
//
//  Maintained By:
//      Vij Vasu (Vvasu) 12-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For some basic types
#include <windows.h>

// For smart classes
#include "SmartClasses.h"

// For DIRID_USER
#include <setupapi.h>

// For IUnknown
#include <Unknwn.h>

//////////////////////////////////////////////////////////////////////////
// Macros definitions
//////////////////////////////////////////////////////////////////////////

// Directory id of the cluster files directory (currently 0x8000, defined in setupapi.h )
#define CLUSTER_DIR_DIRID                   ( DIRID_USER + 0 )

// Directory id of the localquorum directory.
#define CLUSTER_LOCALQUORUM_DIRID           ( DIRID_USER + 1 )


//////////////////////////////////////////////////////////////////////////
// Type definitions
//////////////////////////////////////////////////////////////////////////

// Types of cluster configuration actions.
typedef enum
{
      eCONFIG_ACTION_NONE = -1
    , eCONFIG_ACTION_FORM
    , eCONFIG_ACTION_JOIN
    , eCONFIG_ACTION_CLEANUP
    , eCONFIG_ACTION_UPGRADE
    , eCONFIG_ACTION_MAX
} EBaseConfigAction;


//
// Smart classes
//

// Smart WCHAR array.
typedef CSmartGenericPtr< CPtrTrait< WCHAR > >    SmartSz;

// Smart BYTE array.
typedef CSmartGenericPtr< CArrayPtrTrait< BYTE > >     SmartByteArray;

// Smart SC Manager handle.
typedef CSmartResource<
    CHandleTrait< 
          SC_HANDLE
        , BOOL
        , CloseServiceHandle
        , reinterpret_cast< SC_HANDLE >( NULL )
        >
    > SmartSCMHandle;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cnodeconfig.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CNodeConfig.h
//
//  Description:
//      Header file for CNodeConfig class.
//      The CNodeConfig class is an action that performs configuration tasks
//      related to the node being configured. These tasks are not directly
//      related to the cluster service itself, but needed by it. An example,
//      of such a task is to make set the power management scheme of the
//      node to 'Always On'. This class is used during join or form only.
//
//  Implementation Files:
//      CNodeConfig.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CNode base class
#include "CNode.h"


//////////////////////////////////////////////////////////////////////////
// Forward declarations
//////////////////////////////////////////////////////////////////////////

// The parent action of this action.
class CBaseClusterAddNode;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CNodeConfig
//
//  Description:
//      The CNodeConfig class is an action that performs configuration tasks
//      related to the node being configured. These tasks are not directly
//      related to the cluster service itself, but needed by it. An example,
//      of such a task is to make set the power management scheme of the
//      node to 'Always On'.  This class is used during join or form only.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CNodeConfig : public CNode
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CNodeConfig( CBaseClusterAddNode * pbcanParentActionIn );

    // Default destructor.
    ~CNodeConfig();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Grant the required rights to the account.
    //
    void Commit();

    //
    // Revert the account to its previous state.
    //
    void Rollback();


    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        //
        // The notification is:
        // 1. Performing node specific configuration
        //
        return 1;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private type definitions
    //////////////////////////////////////////////////////////////////////////
    typedef CNode BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CNodeConfig( const CNodeConfig & );

    // Assignment operator
    CNodeConfig & operator =( const CNodeConfig & );

    
    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

}; //*** class CNodeConfig
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cnodecleanup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CNodeCleanup.h
//
//  Description:
//      Header file for CNodeCleanup class.
//      The CNodeCleanup class is an action that cleans up a node that is no
//      longer a part of a cluster.
//
//  Implementation Files:
//      CNodeCleanup.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 01-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CNode base class
#include "CNode.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterCleanup;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CNodeCleanup
//
//  Description:
//      The CNodeCleanup class is an action that cleans up a node that is no
//      longer a part of a cluster.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CNodeCleanup : public CNode
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CNodeCleanup( CBaseClusterCleanup * pbccParentActionIn );

    // Default destructor.
    ~CNodeCleanup();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Clean up the Node service.
    //
    void Commit();

    //
    // Rollback this cleanup.
    //
    void Rollback();


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CNode BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

}; //*** class CNodeCleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cnode.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CNode.h
//
//  Description:
//      Header file for CNode class.
//      The CNode class is a base class for action classes that perform
//      configuration tasks related to the node being configured.
//
//  Implementation Files:
//      CNode.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CAction base class
#include "CAction.h"

// For the SmartSz typedef
#include "CommonDefs.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterAction;
class CStr;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CNode
//
//  Description:
//      The CNode class is a base class for action classes that perform
//      configuration tasks related to the node being configured.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CNode : public CAction
{
protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CNode( CBaseClusterAction * pbcaParentActionIn );

    // Default destructor.
    ~CNode();


    //////////////////////////////////////////////////////////////////////////
    // Protected methods
    //////////////////////////////////////////////////////////////////////////

    // Configure this node.
    void
        Configure( const CStr & rcstrClusterNameIn );

    // Clean up the changes made to this node when it joined a cluster.
    void
        Cleanup();


    //////////////////////////////////////////////////////////////////////////
    // Protected accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the parent action
    CBaseClusterAction *
        PbcaGetParent() throw()
    {
        return m_pbcaParentAction;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CNode( const CNode & );

    // Assignment operator
    const CNode & operator =( const CNode & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Pointer to the base cluster action of which this action is a part.
    CBaseClusterAction *    m_pbcaParentAction;

    // Did we change the cluster adminstrator connections list?
    bool                    m_fChangedConnectionsList;

    // The cluster administrator connections list before we changed it.
    SmartSz                 m_sszOldConnectionsList;

}; //*** class CNode
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cnode.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CNode.cpp
//
//  Description:
//      Contains the definition of the CNode class.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header for this file
#include "CNode.h"

// For the CRegistryKey class
#include "CRegistryKey.h"

// For the CStr class
#include "CStr.h"


//////////////////////////////////////////////////////////////////////////////
// Macros
//////////////////////////////////////////////////////////////////////////////

// Names of the sections in the main INF file which deal with node configuration
// and cleanup.
#define NODE_CONFIG_INF_SECTION         L"Node_Create"
#define NODE_CLEANUP_INF_SECTION        L"Node_Cleanup"

// Registry key storing the list of connections for the cluster administrator
#define CLUADMIN_CONNECTIONS_KEY_NAME       L"Software\\Microsoft\\Cluster Administrator\\Connections"

// Name of the registry value storing the list of connections for the cluster administrator
#define CLUADMIN_CONNECTIONS_VALUE_NAME     L"Connections"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNode::CNode()
//
//  Description:
//      Constructor of the CNode class
//
//  Arguments:
//      pbcaParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CAssert
//          If the parameters are incorrect.
//
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CNode::CNode(
      CBaseClusterAction *  pbcaParentActionIn
    )
    : m_pbcaParentAction( pbcaParentActionIn )
    , m_fChangedConnectionsList( false )
{
    BCATraceScope( "" );

    if ( m_pbcaParentAction == NULL) 
    {
        BCATraceMsg( "Pointers to the parent action is NULL. Throwing exception." );
        THROW_ASSERT( 
              E_INVALIDARG
            , "CNode::CNode() => Required input pointer in NULL"
            );
    } // if: the parent action pointer is NULL

} //*** CNode::CNode()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNode::~CNode()
//
//  Description:
//      Destructor of the CNode class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CNode::~CNode( void )
{
    BCATraceScope( "" );

} //*** CNode::~CNode()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CNode::Configure()
//
//  Description:
//      Make the changes that need to be made when a node becomes part of a
//      cluster. 
//
//  Arguments:
//      rcstrClusterNameIn
//          Name of the cluster being configured. 
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CNode::Configure( const CStr & rcstrClusterNameIn )
{
    BCATraceScope( "" );

    //
    // Validate the parameter
    //
    if ( rcstrClusterNameIn.FIsEmpty() )
    {
        BCATraceMsg( "The name of the cluster is empty. Throwing exception." );
        THROW_ASSERT( E_INVALIDARG, "The name of the cluster cannot be empty." );
    } // if: the cluster name is not valid

    BCATraceMsg( "Attempting to make miscellaneous changes to the node." );

    // Process the registry keys.
    if ( SetupInstallFromInfSection(
          NULL                                                      // optional, handle of a parent window
        , m_pbcaParentAction->HGetMainInfFileHandle()               // handle to the INF file
        , NODE_CONFIG_INF_SECTION                                   // name of the Install section
        , SPINST_REGISTRY                                           // which lines to install from section
        , NULL                                                      // optional, key for registry installs
        , NULL                                                      // optional, path for source files
        , NULL                                                      // optional, specifies copy behavior
        , NULL                                                      // optional, specifies callback routine
        , NULL                                                      // optional, callback routine context
        , NULL                                                      // optional, device information set
        , NULL                                                      // optional, device info structure
        ) == FALSE
       )
    {
        DWORD   dwError = TW32( GetLastError() );

        BCATraceMsg1( "Setup API returned error %#08x while trying to make miscellaneous changes to the node. Throwing exception.", dwError );
        LogMsg( "Error %#08x occurred while trying to make miscellaneous changes to the node.", dwError );

        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_NODE_CONFIG );
    } // if: SetupInstallFromInfSection failed

    //
    // Add the name of the cluster that this node is a part of to the list of connections
    // that will be opened when the cluster administrator is started on this node.
    // The list of connections is a comma separated list of cluster names.
    //

    BCATraceMsg1( "Adding the cluster name '%s' to the list of cluadmin connections.", rcstrClusterNameIn.PszData() );

    // Reset the state.
    m_fChangedConnectionsList = false;
    m_sszOldConnectionsList.PRelease();

    do
    {
        WCHAR *         pszConnectionsValue = NULL;
        DWORD           cbConnectionsValueSize = 0;
        DWORD           cchOldListLen = 0;
        CRegistryKey    rkConnectionsKey;

        BCATraceMsg( "Trying to read the existing connections list." );

        // Open the cluster administrator connections key. Create it if it does not exist.
        rkConnectionsKey.CreateKey(
              HKEY_CURRENT_USER
            , CLUADMIN_CONNECTIONS_KEY_NAME
            );

        try
        {
            // Try and get the current value
            rkConnectionsKey.QueryValue(
                  CLUADMIN_CONNECTIONS_VALUE_NAME
                , reinterpret_cast< LPBYTE * >( &pszConnectionsValue )
                , &cbConnectionsValueSize
                );

        } // try: to read the "Connections" value
        catch( CRuntimeError & crte )
        {
            // Check if this error occurred because the value did not exist
            if ( crte.HrGetErrorCode() == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
            {
                BCATraceMsg1( "The registry value '%s' does not exist. This is ok and is not an error.", CLUADMIN_CONNECTIONS_VALUE_NAME );
                LogMsg( "The registry value '%s' does not exist. This is ok and is not an error.", CLUADMIN_CONNECTIONS_VALUE_NAME );
                cchOldListLen = 0;
            } // if: the value does not exist
            else
            {
                throw;
            } // else: something else is wrong - rethrow the exception

        } // catch: the run time error that occurred

        // Number of characters in the old list, including the terminating NULL.
        cchOldListLen = cbConnectionsValueSize / sizeof( *pszConnectionsValue );

        if ( cchOldListLen <= 1 )
        {
            BCATraceMsg( "There are no existing cluadmin connections. Creating a new list with just one name in it." );

            // Write the cluster name to the value
            rkConnectionsKey.SetValue(
                  CLUADMIN_CONNECTIONS_VALUE_NAME
                , REG_SZ
                , reinterpret_cast< const BYTE * >( rcstrClusterNameIn.PszData() )
                , ( rcstrClusterNameIn.NGetLen() + 1 ) * sizeof( WCHAR )
                );

            // We have changed the connections list.
            m_fChangedConnectionsList = true;
        } // if: there are no existing connections
        else
        {
            WCHAR *         pszSubString = NULL;
            bool            fIsInList = false;

            BCATraceMsg1( "The existing list of cluadmin connections is '%s'.", pszConnectionsValue );

            //
            // Is the cluster name already in the list of connections?
            //

            pszSubString = wcsstr( pszConnectionsValue, rcstrClusterNameIn.PszData() );
            while ( pszSubString != NULL )
            {
                //
                // The cluster name is a substring of the list.
                // Make sure that the cluster name is not a proper substring of an cluster name already in the list.
                //
                if (   (                                            
                            ( pszSubString == pszConnectionsValue )             // the substring was found at the beginning of the string
                         || ( *( pszSubString - 1 ) == L',' )                   // or the character before the substring is a comma
                       )                                                        // AND            
                    && (    ( *( pszSubString + rcstrClusterNameIn.NGetLen() ) == L'\0' )     // the character after the substring is a '\0'
                         || ( *( pszSubString + rcstrClusterNameIn.NGetLen() ) == L',' )      // or character after the substring is a comma
                       )                                                        
                   )
                {
                    fIsInList = true;
                    break;
                } // if: the cluster name is not a proper substring of a cluster name that is already in the list

                // Continue searching.
                pszSubString = wcsstr( pszSubString + rcstrClusterNameIn.NGetLen(), rcstrClusterNameIn.PszData() );
            } // while: the cluster name is a substring of the list of existing connections

            if ( fIsInList )
            {
                // Nothing more to be done.
                BCATraceMsg1( "The cluster '%s' is already in the list of connections.", rcstrClusterNameIn.PszData() );
                break;
            } // if: the cluster name is already in the list

            BCATraceMsg1( "The cluster '%s' is not in the list of connections.", rcstrClusterNameIn.PszData() );

            // Store the current value in the member variable for restoration in case of error.
            m_sszOldConnectionsList.Assign( pszConnectionsValue );

            // Set the new connections value.
            {
                // Define a string to hold the new connections value. Preallocate its buffer.
                CStr            strNewConnectionsValue(
                      cchOldListLen                 // length of the old list ( including terminating '\0' )
                    + 1                             // for the comma
                    + rcstrClusterNameIn.NGetLen()  // length of the cluster name( including terminating '\0' )
                    );

                //
                // Form the new list
                //
                strNewConnectionsValue = rcstrClusterNameIn;
                strNewConnectionsValue += L",";
                strNewConnectionsValue += m_sszOldConnectionsList.PMem();

                BCATraceMsg1( "Writing the new list of connections '%s'.", strNewConnectionsValue.PszData() );

                // Write the new list.
                rkConnectionsKey.SetValue(
                      CLUADMIN_CONNECTIONS_VALUE_NAME
                    , REG_SZ
                    , reinterpret_cast< const BYTE * >( strNewConnectionsValue.PszData() )
                    , ( strNewConnectionsValue.NGetLen() + 1 ) * sizeof( WCHAR )
                    );

                // We have changed the connections list.
                m_fChangedConnectionsList = true;
            }

        } // else: there are existing connections
    }
    while( false ); // dummy do-while loop to avoid gotos
    
    BCATraceMsg( "The changes were made successfully." );

} //*** CNode::Configure()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CNode::Cleanup()
//
//  Description:
//      Clean up the changes made to this node when it became part of a cluster.
//      Note that the changes made during Configure() are not really undone here -
//      we just bring the node back to an acceptable state. This is because,
//      without a transactional registry, it will be very diffult to get 
//      the registry back to the exact state it was in before Configure() was
//      called.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CNode::Cleanup( void )
{
    BCATraceScope( "" );

    BCATraceMsg( "Attempting to cleanup changes made when this node was made a part of a cluster." );

    // Process the registry keys.
    if ( SetupInstallFromInfSection(
          NULL                                                      // optional, handle of a parent window
        , m_pbcaParentAction->HGetMainInfFileHandle()               // handle to the INF file
        , NODE_CLEANUP_INF_SECTION                                  // name of the Install section
        , SPINST_REGISTRY                                           // which lines to install from section
        , NULL                                                      // optional, key for registry installs
        , NULL                                                      // optional, path for source files
        , NULL                                                      // optional, specifies copy behavior
        , NULL                                                      // optional, specifies callback routine
        , NULL                                                      // optional, callback routine context
        , NULL                                                      // optional, device information set
        , NULL                                                      // optional, device info structure
        ) == FALSE                                
       )
    {
        DWORD   dwError = TW32( GetLastError() );

        BCATraceMsg1( "Setup API returned error %#08x while trying to cleanup miscellaneous changes. Throwing exception.", dwError );
        LogMsg( "Error %#08x occurred while trying to clean up miscellaneous changes.", dwError );

        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_NODE_CLEANUP );
    } // if: SetupInstallFromInfSection failed

    if ( m_fChangedConnectionsList )
    {
        BCATraceMsg1( "Restoring the list of cluster administrator connections to '%s'", m_sszOldConnectionsList.PMem() );

        // Open the cluster administrator connections key.
        CRegistryKey    rkConnectionsKey(
              HKEY_CURRENT_USER
            , CLUADMIN_CONNECTIONS_KEY_NAME
            );

        // Write the old list back.
        rkConnectionsKey.SetValue(
              CLUADMIN_CONNECTIONS_VALUE_NAME
            , REG_SZ
            , reinterpret_cast< const BYTE * >( m_sszOldConnectionsList.PMem() )
            , ( wcslen( m_sszOldConnectionsList.PMem() ) + 1 ) * sizeof( WCHAR )
            );

    } // if: we changed the list of cluadmin connections

    BCATraceMsg( "The cleanup was successfully." );

} //*** CNode::Cleanup()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cregistrykey.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CRegistryKey.cpp
//
//  Description:
//      Contains the definition of the CRegistryKey class.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegistryKey::CRegistryKey()
//
//  Description:
//      Default constructor of the CRegistryKey class
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CRegistryKey::CRegistryKey( void ) throw()
{
    BCATraceScope( "" );

} //*** CRegistryKey::CRegistryKey()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegistryKey::CRegistryKey()
//
//  Description:
//      Constructor of the CRegistryKey class. Opens the specified key.
//
//  Arguments:
//      hKeyParentIn
//          Handle to the parent key.
//
//      pszSubKeyNameIn
//          Name of the subkey.
//
//      samDesiredIn
//          Access rights desired. Defaults to KEY_ALL_ACCESS
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any thrown by functions called.
//
//--
//////////////////////////////////////////////////////////////////////////////
CRegistryKey::CRegistryKey(
      HKEY          hKeyParentIn
    , const WCHAR * pszSubKeyNameIn
    , REGSAM        samDesiredIn
    )
{
    BCATraceScope( "" );

    OpenKey( hKeyParentIn, pszSubKeyNameIn, samDesiredIn );

} //*** CRegistryKey::CRegistryKey()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegistryKey::~CRegistryKey()
//
//  Description:
//      Default destructor of the CRegistryKey class
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CRegistryKey::~CRegistryKey( void ) throw()
{
    BCATraceScope( "" );

} //*** CRegistryKey::~CRegistryKey()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CRegistryKey::OpenKey()
//
//  Description:
//      Opens the specified key.
//
//  Arguments:
//      hKeyParentIn
//          Handle to the parent key.
//
//      pszSubKeyNameIn
//          Name of the subkey.
//
//      samDesiredIn
//          Access rights desired. Defaults to KEY_ALL_ACCESS
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CRegistryKey::OpenKey(
      HKEY          hKeyParentIn
    , const WCHAR * pszSubKeyNameIn
    , REGSAM        samDesiredIn
    )
{
    BCATraceScope3( "hKeyParentIn = %p, pszSubKeyNameIn = '%ws', samDesiredIn = %#x", hKeyParentIn, pszSubKeyNameIn == NULL ? L"<null>" : pszSubKeyNameIn, samDesiredIn );

    HKEY    hTempKey = NULL;
    LONG    lRetVal;

    lRetVal = TW32( RegOpenKeyEx(
                          hKeyParentIn
                        , pszSubKeyNameIn
                        , 0
                        , samDesiredIn
                        , &hTempKey
                        ) );

    // Was the key opened properly?
    if ( lRetVal != ERROR_SUCCESS )
    {
        BCATraceMsg2( "RegOpenKeyEx( '%ws' ) retured error %#08x. Throwing an exception.", pszSubKeyNameIn, lRetVal );
        LogMsg( "CRegistryKey::OpenKey - RegOpenKeyEx( '%ws' ) retured error %#08x. Throwing an exception.", pszSubKeyNameIn, lRetVal );

        THROW_RUNTIME_ERROR(
              HRESULT_FROM_WIN32( lRetVal )
            , IDS_ERROR_REGISTRY_OPEN
            );
    } // if: RegOpenKeyEx failed.

    BCATraceMsg1( "Handle to key = %p", hTempKey );

    // Store the opened key in the member variable.
    m_shkKey.Assign( hTempKey );

} //*** CRegistryKey::OpenKey()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CRegistryKey::CreateKey()
//
//  Description:
//      Creates the specified key. If the key already exists, this functions
//      opens the key.
//
//  Arguments:
//      hKeyParentIn
//          Handle to the parent key.
//
//      pszSubKeyNameIn
//          Name of the subkey.
//
//      samDesiredIn
//          Access rights desired. Defaults to KEY_ALL_ACCESS
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CRegistryKey::CreateKey(
      HKEY          hKeyParentIn
    , const WCHAR * pszSubKeyNameIn
    , REGSAM        samDesiredIn
    )
{
    BCATraceScope3( "hKeyParentIn = %p, pszSubKeyNameIn = '%ws', samDesiredIn = %#x", hKeyParentIn, pszSubKeyNameIn == NULL ? L"<null>" : pszSubKeyNameIn, samDesiredIn );
    if ( pszSubKeyNameIn == NULL )
    {
        BCATraceMsg( "Key = NULL. This is an error! Throwing exception." );
        THROW_ASSERT( E_INVALIDARG, "The name of the subkey cannot be NULL." );
    }

    HKEY    hTempKey = NULL;
    LONG    lRetVal;

    lRetVal = TW32( RegCreateKeyEx(
                          hKeyParentIn
                        , pszSubKeyNameIn
                        , 0
                        , NULL
                        , REG_OPTION_NON_VOLATILE
                        , samDesiredIn
                        , NULL
                        , &hTempKey
                        , NULL
                        ) );

    // Was the key opened properly?
    if ( lRetVal != ERROR_SUCCESS )
    {
        BCATraceMsg2( "RegCreateKeyEx( '%ws' ) retured error %#08x. Throwing an exception.", pszSubKeyNameIn, lRetVal );
        LogMsg( "CRegistryKey::CreateKey - RegCreateKeyEx( '%ws' ) retured error %#08x.", pszSubKeyNameIn, lRetVal );

        THROW_RUNTIME_ERROR(
              HRESULT_FROM_WIN32( lRetVal )
            , IDS_ERROR_REGISTRY_CREATE
            );
    } // if: RegCreateKeyEx failed.

    BCATraceMsg1( "Handle to key = %p", hTempKey );

    // Store the opened key in the member variable.
    m_shkKey.Assign( hTempKey );

} //*** CRegistryKey::CreateKey()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CRegistryKey::QueryValue()
//
//  Description:
//      Reads a value under this key. The memory for this value is allocated
//      by this function. The caller is responsible for freeing this memory.
//
//  Arguments:
//      pszValueNameIn
//          Name of the value to read.
//
//      ppbDataOut
//          Pointer to the pointer to the data. Cannot be NULL.
//
//      pdwDataSizeInBytesOut
//          Number of bytes allocated in the data buffer. Cannot be NULL.
//
//      pdwTypeOut
//          Pointer to the type of the value.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      CAssert
//          If the parameters are incorrect.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CRegistryKey::QueryValue(
      const WCHAR *   pszValueNameIn
    , LPBYTE *        ppbDataOut
    , LPDWORD         pdwDataSizeBytesOut
    , LPDWORD         pdwTypeOut
    ) const
{
    BCATraceScope1( "pszValueNameIn = '%ws'", pszValueNameIn == NULL ? L"<null>" : pszValueNameIn );

    LONG            lRetVal         = ERROR_SUCCESS;
    DWORD           cbBufferSize    = 0;
    DWORD           dwType          = REG_SZ;

    // Check parameters
    if (  ( pdwDataSizeBytesOut == NULL )
       || ( ppbDataOut == NULL )
       )
    {
        BCATraceMsg( "One of the required input pointers is NULL. Throwing exception." );
        THROW_ASSERT(
              E_INVALIDARG
            , "CRegistryKey::QueryValue() => Required input pointer in NULL"
            );
    } // if: parameters are invalid.


    // Initialize outputs.
    *ppbDataOut = NULL;
    *pdwDataSizeBytesOut = 0;

    // Get the required size of the buffer.
    lRetVal = TW32( RegQueryValueEx(
                          m_shkKey.HHandle()    // handle to key to query
                        , pszValueNameIn        // address of name of value to query
                        , 0                     // reserved
                        , NULL                  // address of buffer for value type
                        , NULL                  // address of data buffer
                        , &cbBufferSize         // address of data buffer size
                        ) );

    if ( lRetVal != ERROR_SUCCESS )
    {
        BCATraceMsg2( "RegQueryValueEx( '%ws' ) retured error %#08x. Throwing an exception.", pszValueNameIn, lRetVal );
        LogMsg( "CRegistryKey::QueryValue - RegQueryValueEx( '%ws' ) retured error %#08x.", pszValueNameIn, lRetVal );

        THROW_RUNTIME_ERROR(
              HRESULT_FROM_WIN32( lRetVal )
            , IDS_ERROR_REGISTRY_QUERY
            );
    }

    SmartByteArray sbaBuffer( new BYTE[ cbBufferSize ] );

    if ( sbaBuffer.FIsEmpty() )
    {
        BCATraceMsg1( "Could not allocate %d bytes of memory. Throwing an exception.", cbBufferSize );
        LogMsg( "CRegistryKey::QueryValue - Could not allocate %d bytes of memory.", lRetVal );
        THROW_RUNTIME_ERROR(
              THR( E_OUTOFMEMORY )
            , IDS_ERROR_REGISTRY_QUERY
            );
    }

    // Read the value.
    lRetVal = TW32( RegQueryValueEx(
                          m_shkKey.HHandle()    // handle to key to query
                        , pszValueNameIn        // address of name of value to query
                        , 0                     // reserved
                        , &dwType               // address of buffer for value type
                        , sbaBuffer.PMem()      // address of data buffer
                        , &cbBufferSize         // address of data buffer size
                        ) );

    // Was the key read properly?
    if ( lRetVal != ERROR_SUCCESS )
    {
        BCATraceMsg2( "RegQueryValueEx( '%ws' ) retured error %#08x. Throwing an exception.", pszValueNameIn, lRetVal );
        LogMsg( "CRegistryKey::QueryValue - RegQueryValueEx( '%ws' ) retured error %#08x.", pszValueNameIn, lRetVal );

        THROW_RUNTIME_ERROR(
              HRESULT_FROM_WIN32( lRetVal )
            , IDS_ERROR_REGISTRY_QUERY
            );
    } // if: RegQueryValueEx failed.


    *ppbDataOut = sbaBuffer.PRelease();
    *pdwDataSizeBytesOut = cbBufferSize;

    if ( pdwTypeOut != NULL )
    {
        *pdwTypeOut = dwType;
    }

} //*** CRegistryKey::QueryValue()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CRegistryKey::SetValue()
//
//  Description:
//      Writes a value under this key.
//
//  Arguments:
//      pszValueNameIn
//          Name of the value to be set.
//
//      cpbDataIn
//          Pointer to the pointer to the data buffer.
//
//      dwDataSizeInBytesIn
//          Number of bytes in the data buffer.
//
//      pdwTypeIn
//          Type of the value.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CRegistryKey::SetValue(
      const WCHAR *   pszValueNameIn
    , DWORD           dwTypeIn
    , const BYTE *    cpbDataIn
    , DWORD           dwDataSizeBytesIn
    ) const
{
    BCATraceScope5(
          "HKEY = %p, pszValueNameIn = '%s', dwTypeIn = %d, cpbDataIn = %p, dwDataSizeBytesIn = %d."
        , m_shkKey.HHandle()
        , pszValueNameIn
        , dwTypeIn
        , cpbDataIn
        , dwDataSizeBytesIn
        );

    DWORD dwRetVal = TW32( RegSetValueEx(
                                  m_shkKey.HHandle()
                                , pszValueNameIn
                                , 0
                                , dwTypeIn
                                , cpbDataIn
                                , dwDataSizeBytesIn
                                ) );

    if ( dwRetVal != ERROR_SUCCESS )
    {
        BCATraceMsg2( "RegSetValueEx( '%s' ) retured error %#x. Throwing an exception.", pszValueNameIn, dwRetVal );
        LogMsg( "CRegistryKey::SetValue - RegSetValueEx( '%s' ) retured error %#x.", pszValueNameIn, dwRetVal );

        THROW_RUNTIME_ERROR(
              HRESULT_FROM_WIN32( dwRetVal )
            , IDS_ERROR_REGISTRY_SET
            );
    } // if: RegSetValueEx failed.

} //*** CRegistryKey::SetValue()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CRegistryKey::RenameKey()
//
//  Description:
//      Rename this key.
//
//  Arguments:
//      pszNewNameIn
//          The new name for this key.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//  IMPORTANT NOTE:
//      This function calls the NtRenameKey API with the handle returned by
//      RegOpenKeyEx. This will work as long as we are not dealing with a
//      remote registry key.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CRegistryKey::RenameKey(
      const WCHAR *   pszNewNameIn
    )
{
    BCATraceScope2(
          "HKEY = %p, pszNewNameIn = '%s'."
        , m_shkKey.HHandle()
        , pszNewNameIn
        );

    UNICODE_STRING  ustrNewName;
    DWORD           dwRetVal = ERROR_SUCCESS;

    RtlInitUnicodeString( &ustrNewName, pszNewNameIn );

    // Begin_Replace00
    //
    // BUGBUG: Vij Vasu (Vvasu) 10-APR-2000
    // Dynamically linking to NtDll.dll to allow testing on Win2K
    // Replace the section below ( Begin_Replace00 to End-Replace00 ) with
    // the single marked statment ( Begin_Replacement00 to End_Replacement00 ).
    //

    {
        typedef CSmartResource<
            CHandleTrait<
                  HMODULE
                , BOOL
                , FreeLibrary
                , reinterpret_cast< HMODULE >( NULL )
                >
            > SmartModuleHandle;

        SmartModuleHandle smhNtDll( LoadLibrary( L"NtDll.dll" ) );

        if ( smhNtDll.FIsInvalid() )
        {
            dwRetVal = GetLastError();

            BCATraceMsg1( "LoadLibrary() retured error %#08x. Throwing an exception.", dwRetVal );

            THROW_RUNTIME_ERROR(
                  dwRetVal                  // NTSTATUS codes are compatible with HRESULTS
                , IDS_ERROR_REGISTRY_RENAME
                );
        } // if: LoadLibrary failed.

        FARPROC pNtRenameKey = GetProcAddress( smhNtDll.HHandle(), "NtRenameKey" );

        if ( pNtRenameKey == NULL )
        {
            dwRetVal = GetLastError();

            BCATraceMsg1( "GetProcAddress() retured error %#08x. Throwing an exception.", dwRetVal );

            THROW_RUNTIME_ERROR(
                  dwRetVal                  // NTSTATUS codes are compatible with HRESULTS
                , IDS_ERROR_REGISTRY_RENAME
                );
        } // if: GetProcAddress() failed

        dwRetVal = ( reinterpret_cast< NTSTATUS (*)( HANDLE, PUNICODE_STRING ) >( pNtRenameKey ) )(
              m_shkKey.HHandle()
            , &ustrNewName
            );
    }

    // End_Replace00
    /* Begin_Replacement00 - delete this line
    dwRetVal = NtRenameKey(
          m_shkKey.HHandle()
        , &ustrNewName
        );
    End_Replacement00 - delete this line */

    if ( NT_ERROR( dwRetVal ) )
    {
        BCATraceMsg2( "NtRenameKey( '%ws' ) retured error %#08x. Throwing an exception.", pszNewNameIn, dwRetVal );
        LogMsg( "CRegistryKey::RenameKey - NtRenameKey( '%ws' ) retured error %#08x.", pszNewNameIn, dwRetVal );

        THROW_RUNTIME_ERROR(
              dwRetVal                  // NTSTATUS codes are compatible with HRESULTS
            , IDS_ERROR_REGISTRY_RENAME
            );
    } // if: RegRenameKeyEx failed.

} //*** CRegistryKey::RenameKey()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cregistrykey.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CRegistryKey.h
//
//  Description:
//      Header file for CRegistryKey class.
//
//      The CRegistry class is the representation of a registry key.
//      See IMPORTANT NOTE in the class description.
//
//  Implementation Files:
//      CRegistryKey.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

#include <windows.h>

// For smart classes
#include "SmartClasses.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CRegistryKey
//
//  Description:
//      The CRegistry class is the representation of a registry key.
//
//  IMPORTANT NOTE: 
//      Due to the contained smart handle object, objects of this class 
//      have destructive copy semantics. That is, copying an object of this
//      class will invalidate the source object.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CRegistryKey
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Default constructor.
    CRegistryKey() throw();

    // Constructor that opens the key.
    CRegistryKey(
          HKEY          hKeyParentIn
        , const WCHAR * pszSubKeyNameIn
        , REGSAM        samDesiredIn = KEY_ALL_ACCESS
        );

    // Default destructor.
    ~CRegistryKey();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    // Open this key.
    void 
    OpenKey(
          HKEY          hKeyParentIn
        , const WCHAR * pszSubKeyNameIn
        , REGSAM        samDesiredIn  = KEY_ALL_ACCESS
        );

    // Create this key. Open it if it already exists.
    void 
    CreateKey(
          HKEY          hKeyParentIn
        , const WCHAR * pszSubKeyNameIn
        , REGSAM        samDesiredIn  = KEY_ALL_ACCESS
        );

    // Read a value under this key.
    void QueryValue(
          const WCHAR *   pszValueNameIn
        , LPBYTE *        ppbDataOut
        , LPDWORD         pdwDataSizeBytesOut
        , LPDWORD         pdwTypeOut    = NULL
        ) const;

    // Write a value under this key.
    void SetValue(
          const WCHAR *   pszValueNameIn
        , DWORD           dwTypeIn
        , const BYTE *    cpbDataIn
        , DWORD           dwDataSizeBytesIn
        ) const;

    //
    // Rename this key.
    // Note: This function calls the NtRenameKey API with the handle returned by 
    // RegOpenKeyEx. This will work as long as we are not dealing with a remote 
    // registry key.
    //
    void RenameKey( const WCHAR * pszNewNameIn );


    //////////////////////////////////////////////////////////////////////////
    // Public accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the handle to the registry key.
    HKEY HGetKey()
    {
        return m_shkKey.HHandle();
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private type definitions
    //////////////////////////////////////////////////////////////////////////

    // Smart registry key
    typedef CSmartResource<
        CHandleTrait< 
              HKEY 
            , LONG
            , RegCloseKey
            , reinterpret_cast< HKEY >( NULL )
            >
        >
        SmartHKey;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////
    SmartHKey   m_shkKey;

}; //*** class CRegistryKey
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cstatusreport.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CStatusReport.h
//
//  Description:
//      Header file for CStatusReport class.
//
//      CStatusReport is a class the provides the functionality sending a
//      status report.
//
//  Implementation File:
//      CStatusReport.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    30-MAR-2001
//      Vij Vasu        (Vvasu)     05-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include files
//////////////////////////////////////////////////////////////////////////////

// For the logging and tracing functions
#include "BCATrace.h"

// A few common declarations
#include "CommonDefs.h"

// For the exceptions thrown by this class.
#include "Exceptions.h"

// For the CBCAInterface class
#include "CBCAInterface.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CStatusReport
//
//  Description:
//      CStatusReport is a class the provides the functionality sending a
//      status report. Each status report can have a number of steps. For
//      example, the task of creating the cluster service could have 4 steps,
//
//      The user interface is so designed that if the first step of a report is
//      sent, the last one has to be sent as well, even if an error occurs after
//      sending the first one. This class queues the last status report for 
//      sending in case and exception occurs and the last report has not been
//      sent yet.
//
//      It is not possible to send the last, outstanding status report from the
//      destructor of this class since the error code contained in the exception 
//      that is causing this object to be destroyed is not known. So, this last
//      status report is queued with the CBCAInterface object which will send this
//      report once the exception has been caught.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CStatusReport
{
public:

    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CStatusReport(
          CBCAInterface * pbcaiInterfaceIn
        , const CLSID &   clsidTaskMajorIn
        , const CLSID &   clsidTaskMinorIn
        , ULONG           ulMinIn
        , ULONG           ulMaxIn
        , UINT            idsDescriptionStringIdIn
        )
        : m_pbcaiInterface( pbcaiInterfaceIn )
        , m_clsidTaskMajor( clsidTaskMajorIn )
        , m_clsidTaskMinor( clsidTaskMinorIn )
        , m_ulMin( ulMinIn )
        , m_ulMax( ulMaxIn )
        , m_ulNext( ulMinIn )
        , m_idsDescriptionStringId( idsDescriptionStringIdIn )
        , m_fLastStepSent( false )
    {
        BCATraceScope( "" );

        // Validate the parameters.
        if (    ( pbcaiInterfaceIn == NULL )
             || ( ulMinIn > ulMaxIn )
           )
        {
            THR( E_INVALIDARG );
            THROW_ASSERT( E_INVALIDARG, "The parameters for this status report are invalid." );
        } // if: the parameters are invalid

    } //*** CStatusReport::CStatusReport()


    // Default destructor.
    ~CStatusReport( void )
    {
        BCATraceScope( "" );

        // If the last step has not been sent, queue it for sending. This is most probably because
        // an exception has occurred (if no exception has occurred and the last step has not been
        // sent, then it is a programming error).
        if ( ! m_fLastStepSent )
        {
            // The last step has not been sent.

            // Don't throw exceptions from destructor. An unwind may already be in progress.
            try
            {
                // Queue the last step for sending. The CBCAInterface object will fill in the
                // error code from the current exception and send this report.
                m_pbcaiInterface->QueueStatusReportCompletion(
                      m_clsidTaskMajor
                    , m_clsidTaskMinor
                    , m_ulMin
                    , m_ulMax
                    , m_idsDescriptionStringId
                    );
            }
            catch( ... )
            {
                // Catch all errors. Do not rethrow this exception - the app may be terminated due to
                // a collided unwind - so log the error.

                THR( E_UNEXPECTED );

                TraceFlow( "Caught an exception while trying to send the last step of a status report." );
                LogMsg( "An unexpected error has occurred trying to send a status report during cleanup." );
            }
        }
    } //*** CStatusReport::~CStatusReport()


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    // Send the next step of this report.
    void SendNextStep( HRESULT hrStatusIn, UINT idsDescriptionStringIdIn = 0 )
    {
        BCATraceScope( "" );

        if ( m_fLastStepSent )
        {
            TraceFlow( "The last step for this status report has already been sent! Throwing exception." );
            LogMsg( "The last step for this status report has already been sent!" );
            THR( E_INVALIDARG );
            THROW_ASSERT( E_INVALIDARG, "The last step for this status report has already been sent." );
        } // if: the last step has already been sent
        else
        {
            if ( idsDescriptionStringIdIn == 0 )
            {
                idsDescriptionStringIdIn = m_idsDescriptionStringId;
            }

            m_pbcaiInterface->SendStatusReport(
                  m_clsidTaskMajor
                , m_clsidTaskMinor
                , m_ulMin
                , m_ulMax
                , m_ulNext
                , hrStatusIn
                , idsDescriptionStringIdIn
                );

            ++m_ulNext;

            m_fLastStepSent = ( m_ulNext > m_ulMax );
        } // else: the last step has not been sent

    } //*** CStatusReport::SendNextStep()

    // Send the last step of this report, if it hasn't been sent already.
    void SendLastStep( HRESULT hrStatusIn, UINT idsDescriptionStringIdIn = 0 )
    {
        BCATraceScope( "" );

        if ( m_fLastStepSent )
        {
            TraceFlow( "The last step for this status report has already been sent! Throwing exception." );
            LogMsg( "The last step for this status report has already been sent!" );
            THR( E_INVALIDARG );
            THROW_ASSERT( E_INVALIDARG, "The last step for this status report has already been sent." );
        } // if: the last step has already been sent
        else
        {
            if ( idsDescriptionStringIdIn == 0 )
            {
                idsDescriptionStringIdIn = m_idsDescriptionStringId;
            }

            m_pbcaiInterface->SendStatusReport(
                  m_clsidTaskMajor
                , m_clsidTaskMinor
                , m_ulMin
                , m_ulMax
                , m_ulMax
                , hrStatusIn
                , idsDescriptionStringIdIn
                );

            m_fLastStepSent = true;
        } // else: the last step has not been sent

    } //*** CStatusReport::SendLastStep()


private:

    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Pointer to the interface class.
    CBCAInterface *         m_pbcaiInterface;
    
    // The major and minor class id to be sent with this status report.
    CLSID                   m_clsidTaskMajor;
    CLSID                   m_clsidTaskMinor;

    // The range for this status report
    ULONG                   m_ulMin;
    ULONG                   m_ulMax;
    ULONG                   m_ulNext;

    // The string id of the description to be sent with this status report
    UINT                    m_idsDescriptionStringId;

    // Flag to indicate if the last step has been sent.
    bool                    m_fLastStepSent;

}; //*** class CStatusReport
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cservice.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CService.h
//
//  Description:
//      Header file for CService class.
//
//      The CService class is provides several routines that aid in
//      configuring a service.
//
//  Implementation Files:
//      CService.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 13-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For basic types
#include <windows.h>

// For HINF
#include <setupapi.h>

// For the string class
#include "CommonDefs.h"

// For the CStr class.
#include "CStr.h"


//////////////////////////////////////////////////////////////////////////
// Forward declarations
//////////////////////////////////////////////////////////////////////////
class CStatusReport;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CService
//
//  Description:
//      The CService class is provides several routines that aid in
//      configuring a service.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CService
{
public:
    
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CService(
        const WCHAR *       pszNameIn
        )
        : m_strName( pszNameIn)
    {
    }

    // Destructor
    ~CService() {}


    //////////////////////////////////////////////////////////////////////////
    // Public member functions
    //////////////////////////////////////////////////////////////////////////

    // Create this service in the SCM database.
    void
        Create( HINF hInfHandleIn );

    // Erase this service from the SCM database.
    void
        Cleanup( HINF hInfHandleIn );

    // Start this service.
    void
        Start(
              SC_HANDLE             hServiceControlManagerIn      
            , bool                  fWaitForServiceStartIn      = true
            , ULONG                 ulQueryIntervalMilliSecIn   = 500
            , UINT                  cQueryCountIn               = 10
            , CStatusReport *       pStatusReportIn             = NULL
            );

    // Stop this service.
    void 
        Stop(
              SC_HANDLE             hServiceControlManagerIn      
            , ULONG                 ulQueryIntervalMilliSecIn   = 500
            , UINT                  cQueryCountIn               = 10
            , CStatusReport *       pStatusReportIn             = NULL
            );


    // Enable the service
private:

    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CService( const CService & );

    // Assignment operator
    const CService & operator =( const CService & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // The name of this service.
    CStr                m_strName;

}; // class CService
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cstr.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CStr.cpp
//
//  Description:
//      Contains the definition of the CStr class.
//
//  Documentation:
//      TODO: Add pointer to external documentation later.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The header file of this class
#include "CStr.h"

// For the exceptions thrown by CStr
#include "CException.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CStr::LoadString()
//
//  Description:
//      Lookup a string in a string table using a string id.
//
//  Arguments:
//      hInstIn
//          Instance handle of the module containing the string table resource.
//
//      uiStringIdIn
//          Id of the string to look up
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CException
//          If the lookup fails.
//
//  Remarks:
//      This function cannot load a zero length string.
//--
//////////////////////////////////////////////////////////////////////////////
void
CStr::LoadString( HINSTANCE hInstIn, UINT nStringIdIn )
{
    UINT        uiCurrentSize = 0;
    TCHAR *     pszCurrentString = NULL;
    UINT        uiReturnedStringLen = 0;

    do
    {
        // Free the string allocated in the previous iteration.
        delete pszCurrentString;

        // Grow the current string by an arbitrary amount.
        uiCurrentSize += 256;

        pszCurrentString = new TCHAR[ uiCurrentSize ];
        if ( pszCurrentString == NULL )
        {
            THROW_EXCEPTION( E_OUTOFMEMORY );
        } // if: the memory allocation has failed

        uiReturnedStringLen = ::LoadString(
                                  hInstIn
                                , nStringIdIn
                                , pszCurrentString
                                , uiCurrentSize
                                );

        if ( uiReturnedStringLen == 0 )
        {
            HRESULT hrRetVal = TW32( GetLastError() );
            hrRetVal = HRESULT_FROM_WIN32( hrRetVal );
            delete pszCurrentString;

            THROW_EXCEPTION( hrRetVal );

        } // if: LoadString() had an error

        ++uiReturnedStringLen;
    }
    while( uiCurrentSize <= uiReturnedStringLen );

    // Free the existing string.
    Free();

    // Store details about the newly allocated string in the member variables.
    m_pszData = pszCurrentString;
    m_nLen = uiReturnedStringLen;
    m_cchBufferSize = uiCurrentSize;

} //*** CStr::LoadString()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CStr::AllocateBuffer( UINT cchBufferSizeIn )
//
//  Description:
//      Allocate a buffer of cchBufferSizeIn characters. If the existing buffer is not
//      smaller than cchBufferSizeIn characters, nothing is done. Otherwise, a new
//      buffer is allocated and the old contents are filled into this buffer.
//
//  Arguments:
//      cchBufferSizeIn
//          Required size of the new buffer in characters.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CException
//          If the memory allocation fails.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CStr::AllocateBuffer( UINT cchBufferSizeIn )
{
    // Check if the buffer is already big enough
    if ( m_cchBufferSize < cchBufferSizeIn )
    {
        TCHAR * psz = new TCHAR[ cchBufferSizeIn ];
        if ( psz == NULL )
        {
            THROW_EXCEPTION( E_OUTOFMEMORY );
        } // if: memory allocation failed

        // Copy the old data into the new buffer.
        _tcsncpy( psz, m_pszData, m_nLen + 1 );

        if ( m_pszData != &ms_chNull )
        {
            delete m_pszData;
        } // if: the pointer was dynamically allocated

        m_pszData = psz;
        m_cchBufferSize = cchBufferSizeIn;
    }
} //*** AllocateBuffer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cstr.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CStr.h
//
//  Description:
//      Header file for CStr class.
//
//      CStr is a class the provides the functionality of a string of
//      characters.
//
//      This class is intended to be used instead of std::string since the
//      use of STL is prohibited in our project.
//
//  Implementation File:
//      CStr.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 24-APR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include files
//////////////////////////////////////////////////////////////////////////////

// For a few platform SDK functions
#include <windows.h>
#include <tchar.h>


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CStr
//
//  Description:
//      CStr is a class the provides the functionality of a string of
//      characters.
//
//      This class uses TCHAR instead of WCHAR to allow for different types
//      of characters.
//--
//////////////////////////////////////////////////////////////////////////////
class CStr
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Default constructor
    CStr( void ) throw()
        : m_pszData( const_cast< TCHAR *>( &ms_chNull ) )
        , m_nLen( 0 )
        , m_cchBufferSize( 0 )
    {
    } //*** CStr()

    // Copy constructor
    CStr( const CStr & rcstrSrcIn )
        : m_pszData( const_cast< TCHAR *>( &ms_chNull ) )
        , m_nLen( 0 )
        , m_cchBufferSize( 0 )
    {
        Assign( rcstrSrcIn );

    }  //*** CStr( const CStr & )

    // Construct using string ID
    CStr( HINSTANCE hInstanceIn, UINT nStringIdIn )
        : m_pszData( const_cast< TCHAR *>( &ms_chNull ) )
        , m_nLen( 0 )
        , m_cchBufferSize( 0 )
    {
        LoadString( hInstanceIn, nStringIdIn );

    } //*** CStr( HINSTANCE, UINT )

    // Construct using string
    CStr( const TCHAR * pcszSrcIn )
        : m_pszData( const_cast< TCHAR *>( &ms_chNull ) )
        , m_nLen( 0 )
        , m_cchBufferSize( 0 )
    {
        Assign( pcszSrcIn );

    } //*** CStr( const TCHAR * )

    // Construct using buffer size
    CStr( UINT cchBufferSize, TCHAR chInitialChar = ms_chNull )
        : m_pszData( const_cast< TCHAR *>( &ms_chNull ) )
        , m_nLen( 0 )
        , m_cchBufferSize( 0 )
    {
        if ( cchBufferSize > 0 )
        {
            AllocateBuffer( cchBufferSize );

            _tcsnset( m_pszData, chInitialChar, cchBufferSize );
            m_pszData[ cchBufferSize - 1 ] = ms_chNull;
            m_nLen = _tcslen( m_pszData );
        }
    } //*** CStr( UINT cchBufferSize, TCHAR chInitialChar )

    // Destructor
    ~CStr( void ) throw()
    {
        Free();

    } //*** ~CStr()


    //////////////////////////////////////////////////////////////////////////
    // Public member functions
    //////////////////////////////////////////////////////////////////////////

    // Assign another CStr to this one.
    void Assign( const CStr & rcstrSrcIn )
    {
        UINT nSrcLen = rcstrSrcIn.m_nLen;

        if ( nSrcLen != 0 )
        {
            AllocateBuffer( nSrcLen + 1 );
            m_nLen = nSrcLen;
            _tcsncpy( m_pszData, rcstrSrcIn.m_pszData, nSrcLen + 1 );
        } // if: the source string is not empty
        else
        {
            // Clean up existing string.
            Empty();
        } // if: the source string is empty

    } //*** Assign( const CStr & )

    // Assign a character string to this one.
    void Assign( const TCHAR * pcszSrcIn )
    {
        if ( ( pcszSrcIn != NULL ) && ( *pcszSrcIn != ms_chNull ) )
        {
            UINT nSrcLen = _tcslen( pcszSrcIn );

            AllocateBuffer( nSrcLen + 1 );
            m_nLen = nSrcLen;
            _tcsncpy( m_pszData, pcszSrcIn, nSrcLen + 1 );
        } // if: the source string is not NULL
        else
        {
            // Clean up existing string.
            Empty();
        } // else: the source string is NULL

    } //*** Assign( const TCHAR * )

    // Free the buffer for this string
    void Free( void ) throw()
    {
        if ( m_pszData != &ms_chNull )
        {
            delete m_pszData;
        } // if: the pointer was dynamically allocated

        m_pszData = const_cast< TCHAR * >( &ms_chNull );
        m_nLen = 0;
        m_cchBufferSize = 0;
    } //*** Free()

    // Empty this string
    void Empty( void ) throw()
    {
        if ( m_nLen != 0 )
        {
            *m_pszData = ms_chNull;
            m_nLen = 0;
        } // if: the string is not already empty
    } //*** Empty()

    // Load a string from the resource table and assign it to this string.
    void LoadString( HINSTANCE hInstIn, UINT nStringIdIn );


    //////////////////////////////////////////////////////////////////////////
    // Public accessors
    //////////////////////////////////////////////////////////////////////////

    // Get a pointer to the underlying string
    const TCHAR * PszData( void ) const throw()
    {
        return m_pszData;

    } //*** PszData()


    // Get the length of the string.
    UINT NGetLen( void ) const throw()
    {
        return m_nLen;

    } //*** NGetLen()

    // Get the size of the string buffer.
    UINT NGetSize( void ) const throw()
    {
        return m_cchBufferSize;

    } //*** NGetSize()

    // Is this string empty?
    bool FIsEmpty( void ) const throw()
    {
        return ( m_nLen == 0 );

    } //*** FIsEmpty()


    //////////////////////////////////////////////////////////////////////////
    // Public operators
    //////////////////////////////////////////////////////////////////////////

    // Assignment operator ( const CStr & )
    const CStr & operator=( const CStr & rcstrSrcIn )
    {
        Assign( rcstrSrcIn );
        return *this;

    } //*** operator=( const CStr & )

    // Assignment operator ( const TCHAR * )
    const CStr & operator=( const TCHAR * pcszSrcIn )
    {
        Assign( pcszSrcIn );
        return *this;

    } //*** operator=( const TCHAR * )

    // Concatenation operator ( const CStr & )
    CStr operator+( const CStr & rcstrSrcIn ) const
    {
        CStr strReturn( m_nLen + rcstrSrcIn.m_nLen + 1 );

        strReturn.Assign( *this );
        strReturn.Concatenate( rcstrSrcIn.m_pszData, rcstrSrcIn.m_nLen );

        return strReturn;

    } //*** operator+( const CStr & )

    // Concatenation operator ( const TCHAR * )
    CStr operator+( const TCHAR * pcszSrcIn ) const
    {

        if ( ( pcszSrcIn != NULL ) && ( *pcszSrcIn != ms_chNull ) )
        {
            UINT nSrcLen = _tcslen( pcszSrcIn );
            CStr strReturn( m_nLen + nSrcLen + 1);

            strReturn.Assign( *this );
            strReturn.Concatenate( pcszSrcIn, nSrcLen );

            return strReturn;
        } // if: the string to be concatenated is not empty
        else
        {
            return *this;
        } // else: the string to be concatenated is empty

    } //*** operator+( const TCHAR * )

    // Append operator ( const CStr & )
    const CStr & operator+=( const CStr & rcstrSrcIn )
    {
        Concatenate( rcstrSrcIn.m_pszData, rcstrSrcIn.m_nLen );
        return *this;

    } //*** operator+( const CStr & )

    // Append operator ( const TCHAR * )
    const CStr & operator+=( const TCHAR * pcszSrcIn )
    {
        if ( ( pcszSrcIn != NULL ) && ( *pcszSrcIn != ms_chNull ) )
        {
            UINT nSrcLen = _tcslen( pcszSrcIn );
            Concatenate( pcszSrcIn, nSrcLen );
        } // if: the string to be appended is not empty

        return *this;

    } //*** operator+( const TCHAR * )


private:
    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Allocate a buffer of the required size.
    void AllocateBuffer( UINT cchBufferSizeIn );

    // Concatenation function.
    void Concatenate(
          const TCHAR * pcszStr2In
        , UINT nStr2LenIn
        )
    {
        AllocateBuffer( m_nLen + nStr2LenIn + 1);

        // Copy the strings to the destination.
        _tcsncpy( m_pszData + m_nLen, pcszStr2In, nStr2LenIn + 1 );
        m_nLen += nStr2LenIn;

    } //*** Concatenate()


    //////////////////////////////////////////////////////////////////////////
    // Private class data
    //////////////////////////////////////////////////////////////////////////

    // The NULL character. All empty CStrs point here.
    static const TCHAR ms_chNull = '\0';


    //////////////////////////////////////////////////////////////////////////
    // Private member data
    //////////////////////////////////////////////////////////////////////////
    TCHAR *     m_pszData;
    UINT        m_nLen;
    UINT        m_cchBufferSize;

}; //*** class CStr
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cservice.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CService.cpp
//
//  Description:
//      Contains the definition of the CService class.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header file for this class.
#include "CService.h"

// For the CStr class.
#include "CStr.h"

// For the CStatusReport class
#include "CStatusReport.h"


//////////////////////////////////////////////////////////////////////////////
// Macros
//////////////////////////////////////////////////////////////////////////////

// String added to end of service name to get INF file section for create
#define SERVICE_CREATE_SECTION_SUFFIX L"_Create"

// String added to end of service name to get INF file section for cleanup
#define SERVICE_CLEANUP_SECTION_SUFFIX L"_Cleanup"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CService::Create()
//
//  Description:
//      This function creates an entry for the service with the SCM. It does
//      this by using the SetupAPI to process service and registry related
//      entries in a section named <ServiceName>_Create in the INF file that
//      is passed in.
//
//      For example, if this object represents the ClusSvc service, then,
//      when this function is called, the AddService and the AddReg entries
//      under the [ClusSvc_Create] section are processed in the INF file
//      whose handle is hInfHandleIn.
//
//  Arguments:
//      hInfHandleIn
//          Handle to the INF file that contains the required sections
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CService::Create( 
    HINF hInfHandleIn 
    )
{
    BCATraceScope1( "Service Name = '%s'", m_strName.PszData() );
    LogMsg( "Attempting to create the '%s' service.", m_strName.PszData() );

    DWORD   dwError = ERROR_SUCCESS;
    CStr    strSectionName = m_strName + SERVICE_CREATE_SECTION_SUFFIX;

    // Process the service section
    if ( SetupInstallServicesFromInfSection(
          hInfHandleIn
        , strSectionName.PszData()
        , 0
        ) == FALSE
       )
    {
        dwError = TW32( GetLastError() );
        goto Cleanup;
    } // if: SetupInstallServicesFromInfSection failed


    // Process the registry keys.
    if ( SetupInstallFromInfSection(
          NULL                      // optional, handle of a parent window
        , hInfHandleIn              // handle to the INF file
        , strSectionName.PszData()     // name of the Install section
        , SPINST_REGISTRY           // which lines to install from section
        , NULL                      // optional, key for registry installs
        , NULL                      // optional, path for source files
        , NULL                      // optional, specifies copy behavior
        , NULL                      // optional, specifies callback routine
        , NULL                      // optional, callback routine context
        , NULL                      // optional, device information set
        , NULL                      // optional, device info structure
        ) == FALSE
       )
    {
        dwError = TW32( GetLastError() );
        goto Cleanup;
    } // if: SetupInstallFromInfSection failed

    LogMsg( "The '%s' service has been successfully created.", m_strName.PszData() );

Cleanup:
    if ( dwError != ERROR_SUCCESS )
    {
        BCATraceMsg1( "Setup API returned error %#08x while trying to create the service. Throwing exception.", dwError );
        LogMsg( "Error %#08x occurred while trying to create the '%s' service.", dwError, m_strName.PszData() );

        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_SERVICE_CREATE );
    }

} //*** CService::Create()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CService::Cleanup()
//
//  Description:
//      This function cleans up a service by deregistering it with the SCM and by
//      deleting any required registry entries. It does this by using the 
//      SetupAPI to process service and registry related entries in a
//      section named <ServiceName>_Cleanup in the INF file that is passed in.
//
//      For example, if this object represents the ClusSvc service, then,
//      when this function is called, the DelService and the DelReg entries
//      under the [ClusSvc_Cleanup] section are processed in the INF file
//      whose handle is hInfHandleIn.
//
//  Arguments:
//      hInfHandleIn
//          Handle to the INF file that contains the required sections
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CService::Cleanup( 
    HINF hInfHandleIn 
    )
{
    BCATraceScope1( "Service Name = '%s'", m_strName.PszData() );
    LogMsg( "Attempting to clean up the '%s' service.", m_strName.PszData() );

    DWORD   dwError = ERROR_SUCCESS;
    CStr    strSectionName = m_strName + SERVICE_CLEANUP_SECTION_SUFFIX;

    // Process the service section
    if ( SetupInstallServicesFromInfSection(
          hInfHandleIn
        , strSectionName.PszData()
        , 0
        ) == FALSE
       )
    {
        dwError = TW32( GetLastError() );
        goto Cleanup;
    } // if: SetupInstallServicesFromInfSection failed

    // Process the registry keys.
    if ( SetupInstallFromInfSection(
          NULL                      // optional, handle of a parent window
        , hInfHandleIn              // handle to the INF file
        , strSectionName.PszData()     // name of the Install section
        , SPINST_REGISTRY           // which lines to install from section
        , NULL                      // optional, key for registry installs
        , NULL                      // optional, path for source files
        , NULL                      // optional, specifies copy behavior
        , NULL                      // optional, specifies callback routine
        , NULL                      // optional, callback routine context
        , NULL                      // optional, device information set
        , NULL                      // optional, device info structure
        ) == FALSE
       )
    {
        dwError = TW32( GetLastError() );
        goto Cleanup;
    } // if: SetupInstallFromInfSection failed

    LogMsg( "The '%s' service has been successfully cleaned up.", m_strName.PszData() );

Cleanup:
    if ( dwError != ERROR_SUCCESS )
    {
        BCATraceMsg1( "Setup API returned error %#08x while trying to clean up the service. Throwing exception.", dwError );
        LogMsg( "Error %#08x occurred while trying to clean up the '%s' service.", dwError, m_strName.PszData() );

        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_SERVICE_CLEANUP );
    }

} //*** CService::Cleanup()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CService::Start()
//
//  Description:
//      Instructs the SCM to start the service. If fWaitForServiceStartIn is 
//      true, this function tests cQueryCountIn times to see if the service has 
//      started, checking every ulQueryIntervalMilliSecIn milliseconds.
//
//      fWaitForServiceStartIn is false, this function returns immediately.
//
//  Arguments:
//      hServiceControlManagerIn
//          Handle to the service control manager.
//
//      fWaitForServiceStartIn
//          If true, this function waits for the service to finish starting
//          before returning. The default value is true.
//
//      ulQueryIntervalMilliSecIn
//          Number of milliseconds between checking to see if the service
//          has started. The default value is 500 milliseconds.
//          This argument is used only if fWaitForServiceStartIn is true.
//
//      cQueryCountIn
//          The number of times this function will query the service to see
//          if it has started. An exception is thrown if the service is not
//          running even after querying it ulQueryCountIn times. The default 
//          value is 10 times.
//          This argument is used only if fWaitForServiceStartIn is true.
//
//      pStatusReportIn
//          A pointer to the status report that should be sent while waiting for
//          the service to start. This argument is NULL by default.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      CConfigError
//          If the service is not running even after the timeout has expired.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CService::Start(
      SC_HANDLE             hServiceControlManagerIn      
    , bool                  fWaitForServiceStartIn
    , ULONG                 ulQueryIntervalMilliSecIn
    , UINT                  cQueryCountIn
    , CStatusReport *       pStatusReportIn
    )
{
    BCATraceScope1( "Service Name = '%s'", m_strName.PszData() );
    LogMsg( "Attempting to start the '%s' service.", m_strName.PszData() );

    DWORD   dwError = ERROR_SUCCESS;
    bool    fStarted = false;   // Has the service been started?
    UINT    cNumberOfQueries;   // The number of times we have queried the service.

    // Handle to the service.
    SmartSCMHandle  sscmhServiceHandle(
        OpenService(
              hServiceControlManagerIn
            , m_strName.PszData()
            , SERVICE_START | SERVICE_QUERY_STATUS
            )
        );

    if ( sscmhServiceHandle.FIsInvalid() )
    {
        dwError = TW32( GetLastError() );
        BCATraceMsg1( "Error %#08x occurred while trying to open the service. Throwing exception.", dwError );
        goto Cleanup;
    } // if: the handle to the service could not be opened.


    // Try and start the service.
    if ( StartService( sscmhServiceHandle.HHandle(), 0, NULL ) == 0 )
    {
        dwError = GetLastError();

        if ( dwError == ERROR_SERVICE_ALREADY_RUNNING )
        {
            BCATraceMsg( "The service is already running." );

            // The service is already running. Change the error code to success.
            dwError = ERROR_SUCCESS;
        } // if: the service is already running.
        else
        {
            TW32( dwError );
            BCATraceMsg1( "Error %#08x occurred while trying to start the service. Throwing exception.", dwError );
        }

        // There is nothing else to do.
        goto Cleanup;
    } // if: an error occurred trying to start the service.

    // If we are here, then the service may not have started yet.

    // Has the caller requested that we wait for the service to start?
    if ( ! fWaitForServiceStartIn )
    {
        LogMsg( "Not waiting to see if the service has started or not." );
        BCATraceMsg( "Not waiting to see if the service has started or not." );

        goto Cleanup;
    } // if: no waiting is required.

    // We have to wait for the service to start.
    cNumberOfQueries = 0;

    do
    {
        SERVICE_STATUS  ssStatus;

        ZeroMemory( &ssStatus, sizeof( ssStatus ) );

        // Query the service for its status.
        if ( QueryServiceStatus(
                sscmhServiceHandle.HHandle()
                , &ssStatus
                )
             == 0
           )
        {
            dwError = TW32( GetLastError() );
            BCATraceMsg1( "Error %#08x occurred while trying to query service status. Throwing exception.", dwError );

            break;
        } // if: we could not query the service for its status.

        // Check if the service has posted an error.
        if ( ssStatus.dwWin32ExitCode != ERROR_SUCCESS )
        {
            dwError = TW32( ssStatus.dwWin32ExitCode );
            if ( dwError == ERROR_SERVICE_SPECIFIC_ERROR )
            {
                BCATraceMsg( "This is a service specific error code." );
                dwError = TW32( ssStatus.dwServiceSpecificExitCode );
            }

            BCATraceMsg1( "The service has returned error %#08x to query service status. Throwing exception.", dwError );
            break;
        } // if: the service itself has posted an error.

        if ( ssStatus.dwCurrentState == SERVICE_RUNNING )
        {
            fStarted = true;
            break;
        } // if: the service is running.

        ++cNumberOfQueries;

        // Send a progress report if the caller had passed in a valid pointer.
        if ( pStatusReportIn != NULL )
        {
            pStatusReportIn->SendNextStep( S_OK );
        } // if: a status report needs to be sent while we wait

        // Wait for the specified time.
        Sleep( ulQueryIntervalMilliSecIn );

    } 
    while ( cNumberOfQueries < cQueryCountIn ); // while: loop for the required number of queries

    if ( dwError != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: something went wrong.

    if ( ! fStarted )
    {
        BCATraceMsg1( "The service could not be started. Throwing exception.", cQueryCountIn );
        THROW_CONFIG_ERROR( HRESULT_FROM_WIN32( TW32( ERROR_SERVICE_NOT_ACTIVE ) ), IDS_ERROR_SERVICE_START );
    } // if: the maximum number of queries have been made and the service is not running.

Cleanup:
    if ( dwError != ERROR_SUCCESS )
    {
        LogMsg( "Error %#08x occurred trying to start the '%s' service.", dwError, m_strName.PszData() );

        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_SERVICE_START );
    } // if: something has gone wrong
    else
    {
        LogMsg( "The '%s' service has been successfully started.", m_strName.PszData() );
    } // else: nothing went wrong.

} //*** CService::Start()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CService::Stop()
//
//  Description:
//      Instructs the SCM to stop the service. If fWaitForServiceStop is 
//      true, this function tests cQueryCountIn times to see if the service has 
//      stopped, checking every ulQueryIntervalMilliSecIn milliseconds.
//
//  Arguments:
//      hServiceControlManagerIn
//          Handle to the service control manager.
//
//      ulQueryIntervalMilliSecIn
//          Number of milliseconds between checking to see if the service
//          has stopped. The default value is 500 milliseconds.
//
//      cQueryCountIn
//          The number of times this function will query the service to see
//          if it has stopped. An exception is thrown if the service is not
//          running even after querying it ulQueryCountIn times. The default 
//          value is 10 times.
//
//      pStatusReportIn
//          A pointer to the status report that should be sent while waiting for
//          the service to stop. This argument is NULL by default.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      CConfigError
//          If the service has not stopped even after the timeout has expired.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CService::Stop(
      SC_HANDLE             hServiceControlManagerIn      
    , ULONG                 ulQueryIntervalMilliSecIn
    , UINT                  cQueryCountIn
    , CStatusReport *       pStatusReportIn
    )
{
    BCATraceScope( "" );

    DWORD           dwError = ERROR_SUCCESS;
    SERVICE_STATUS  ssStatus;               // The service status structure.
    bool            fStopped = false;       // Has the service been stopped?
    UINT            cNumberOfQueries = 0;   // The number of times we have queried the service
                                            //   (not including the initial state query).

    LogMsg( "Attempting to stop the '%s' service.", m_strName.PszData() );
    BCATraceMsg1( "Attempting to stop the '%s' service.", m_strName.PszData() );

    // Smart handle to the service being stopped.
    SmartSCMHandle  sscmhServiceHandle(
        OpenService(
              hServiceControlManagerIn
            , m_strName.PszData()
            , SERVICE_STOP | SERVICE_QUERY_STATUS
            )
        );

    // Check if we could open a handle to the service.
    if ( sscmhServiceHandle.FIsInvalid() )
    {
        // We could not get a handle to the service.
        dwError = GetLastError();

        // Check if the service exists.
        if ( dwError == ERROR_SERVICE_DOES_NOT_EXIST )
        {
            // Nothing needs to be done here.
            BCATraceMsg1( "The '%s' service does not exist, so it is not running. Nothing needs to be done to stop it.", m_strName.PszData() );
            LogMsg( "The '%s' service does not exist, so it is not running. Nothing needs to be done to stop it.", m_strName.PszData() );
            dwError = ERROR_SUCCESS;
        } // if: the service does not exist
        else
        {
            // Something else has gone wrong.
            TW32( dwError );
            BCATraceMsg2( "Error %#08x occurred trying to open the '%s' service.", dwError, m_strName.PszData() );
            LogMsg( "Error %#08x occurred trying to open the '%s' service.", dwError, m_strName.PszData() );
        } // else: the service exists

        goto Cleanup;
    } // if: the handle to the service could not be opened.


    BCATraceMsg( "Querying the service for its initial state." );

    // Query the service for its initial state.
    ZeroMemory( &ssStatus, sizeof( ssStatus ) );
    if ( QueryServiceStatus( sscmhServiceHandle.HHandle(), &ssStatus ) == 0 )
    {
        dwError = TW32( GetLastError() );
        LogMsg( "Error %#08x occurred while trying to query the initial state of the '%s' service.", dwError, m_strName.PszData() );
        BCATraceMsg2( "Error %#08x occurred while trying to query the initial state of the '%s' service.", dwError, m_strName.PszData() );
        goto Cleanup;
    } // if: we could not query the service for its status.

    // If the service has stopped, we have nothing more to do.
    if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
    {
        // Nothing needs to be done here.
        BCATraceMsg1( "The '%s' service is not running. Nothing needs to be done to stop it.", m_strName.PszData() );
        LogMsg( "The '%s' service is not running. Nothing needs to be done to stop it.", m_strName.PszData() );
        goto Cleanup;
    } // if: the service has stopped.


    // If we are here, the service is running.
    BCATraceMsg( "The service is running." );


    //
    // Try and stop the service.
    //

    // If the service is stopping on its own, no need to send the stop control code.
    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
    {
        BCATraceMsg( "The service is stopping on its own. The stop control code will not be sent." );
    } // if: the service is stopping already
    else
    {
        BCATraceMsg( "The stop control code will be sent now." );

        ZeroMemory( &ssStatus, sizeof( ssStatus ) );
        if ( ControlService( sscmhServiceHandle.HHandle(), SERVICE_CONTROL_STOP, &ssStatus ) == 0 )
        {
            dwError = GetLastError();
            if ( dwError == ERROR_SERVICE_NOT_ACTIVE )
            {
                LogMsg( "The '%s' service is not running. Nothing more needs to be done here.", m_strName.PszData() );
                BCATraceMsg1( "The '%s' service is not running. Nothing more needs to be done here.", m_strName.PszData() );

                // The service is not running. Change the error code to success.
                dwError = ERROR_SUCCESS;
            } // if: the service is already running.
            else
            {
                TW32( dwError );
                LogMsg( "Error %#08x occurred trying to stop the '%s' service.", dwError, m_strName.PszData() );
                BCATraceMsg2( "Error %#08x occurred trying to stop the '%s' service.", dwError, m_strName.PszData() );
            }

            // There is nothing else to do.
            goto Cleanup;
        } // if: an error occurred trying to stop the service.
    } // else: the service has to be instructed to stop


    // Query the service for its state now and wait till the timeout expires
    cNumberOfQueries = 0;
    do
    {
        // Query the service for its status.
        ZeroMemory( &ssStatus, sizeof( ssStatus ) );
        if ( QueryServiceStatus( sscmhServiceHandle.HHandle(), &ssStatus ) == 0 )
        {
            dwError = TW32( GetLastError() );
            LogMsg( "Error %#08x occurred while trying to query the state of the '%s' service.", dwError, m_strName.PszData() );
            BCATraceMsg2( "Error %#08x occurred while trying to query the state of the '%s' service.", dwError, m_strName.PszData() );
            break;
        } // if: we could not query the service for its status.

        // If the service has stopped, we have nothing more to do.
        if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
        {
            // Nothing needs to be done here.
            BCATraceMsg( "The service has been stopped." );
            fStopped = true;
            dwError = ERROR_SUCCESS;
            break;
        } // if: the service has stopped.

        // Check if the timeout has expired
        if ( cNumberOfQueries >= cQueryCountIn )
        {
            BCATraceMsg( "The service stop wait timeout has expired." );
            break;
        } // if: number of queries has exceeded the maximum specified

        BCATraceMsg2( 
              "Waiting for %d milliseconds before querying service status again. %d such queries remaining."
            , ulQueryIntervalMilliSecIn
            , cQueryCountIn - cNumberOfQueries
            );

        ++cNumberOfQueries;

        // Send a progress report if the caller had passed in a valid pointer.
        if ( pStatusReportIn != NULL )
        {
            pStatusReportIn->SendNextStep( S_OK );
        } // if: a status report needs to be sent while we wait

         // Wait for the specified time.
        Sleep( ulQueryIntervalMilliSecIn );

    }
    while( true ); // while: loop infinitely

    if ( dwError != ERROR_SUCCESS )
        goto Cleanup;

    if ( ! fStopped )
    {
        dwError = TW32( ERROR_SERVICE_REQUEST_TIMEOUT );
        LogMsg( "The '%s' service has not stopped even after %d queries.", m_strName.PszData(), cQueryCountIn );
        BCATraceMsg2( "The '%s' service has not stopped even after %d queries.", m_strName.PszData(), cQueryCountIn );
        goto Cleanup;
    } // if: the maximum number of queries have been made and the service is not running.

    LogMsg( "The '%s' service was successfully stopped.", m_strName.PszData() );
    BCATraceMsg1( "The '%s' service was successfully stopped.", m_strName.PszData() );

Cleanup:
    if ( dwError != ERROR_SUCCESS )
    {
        BCATraceMsg2( "Error %#08x has occurred trying to stop the '%s' service. Throwing exception.", dwError, m_strName.PszData() );
        LogMsg( "Error %#08x has occurred trying to stop the '%s' service.", dwError, m_strName.PszData() );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( dwError ), IDS_ERROR_SERVICE_STOP );
    } // if: something has gone wrong

} //*** CService::Stop()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cstrwrapper.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CStrWrapper.cpp
//
//  Description:
//      This is a dummy file that just includes the precompiled header file
//      for this project and the CStr.cpp file. The reason for doing this
//      is that the files CStr.cpp and CStr.h are intended for use in
//      other projects as well and including pch.h directly in CStr.cpp
//      will make it more diffult to copy and use in other projects.
//
//  Documentation:
//      TODO: Add pointer to external documentation later.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 27-APR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header file for this project
#include "pch.h"

// The implementation file for the CStr class. See the 'Description' field
// in the file comment for more details.
#include "CStr.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cuuid.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CUuid.cpp
//
//  Description:
//      Contains the definition of the CUuid class.
//
//  Documentation:
//      TODO: Add pointer to external documentation later.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 24-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// The header file for this class.
#include "CUuid.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUuid::CUuid( void )
//
//  Description:
//      Default constructor of the CUuid class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
CUuid::CUuid( void )
{
    RPC_STATUS  rsStatus = RPC_S_OK;

    m_pszStringUuid = NULL;

    do
    {
        // Create a UUID.
        rsStatus = UuidCreate( &m_uuid );
        if ( rsStatus != RPC_S_OK )
        {
            BCATraceMsg( "UuidCreate() failed." );
            break;
        } // if: UuidCreate() failed

        // Convert it to a string.
        rsStatus = UuidToString( &m_uuid, &m_pszStringUuid );
        if ( rsStatus != RPC_S_OK )
        {
            BCATraceMsg( "UuidToString() failed." );
            break;
        } // if: UuidToStrin() failed
    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( rsStatus != RPC_S_OK )
    {
        BCATraceMsg1( "Error %#08x occurred trying to initialize the UUID. Throwing exception.", rsStatus );
        THROW_RUNTIME_ERROR( rsStatus, IDS_ERROR_UUID_INIT );
    } // if: something has gone wrong

} //*** CUuid::CUuid()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUuid::~CUuid( void )
//
//  Description:
//      Destructor of the CUuid class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      None. 
//
//--
//////////////////////////////////////////////////////////////////////////////
CUuid::~CUuid( void )
{
    if ( m_pszStringUuid != NULL )
    {
        RpcStringFree( &m_pszStringUuid );
    } // if: the string is not NULL

} //*** CUuid::~CUuid()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\listtest\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////


#if DBG==1 || defined( _DEBUG )
#define DEBUG
#endif

#include <windows.h>

extern HINSTANCE g_hInstance;

// For the debugging macros.
#include "debug.h"

#include "DebugSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\globalfuncs.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      GlobalFuncs.h
//
//  Description:
//      Contains the declarations of a few unrelated global functions
//
//  Implementation Files:
//      GlobalFuncs.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Global function declarations.
//////////////////////////////////////////////////////////////////////////

// Generic callback function used by setupapi file operations.
UINT
CALLBACK
g_GenericSetupQueueCallback(
      PVOID     pvContextIn         // context used by the callback routine
    , UINT      uiNotificationIn    // queue notification
    , UINT_PTR  uiParam1In          // additional notification information
    , UINT_PTR  uiParam2In          // additional notification information
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file for the BaseCluster library.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Macro Definitions
//////////////////////////////////////////////////////////////////////////////

#if DBG==1 || defined( _DEBUG )
#define DEBUG
#define USES_SYSALLOCSTRING
#endif


////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The next three files have to be the first files to be included.If nt.h comes
// after windows.h, NT_INCLUDED will not be defined and so, winnt.h will be
// included. This will give errors later, if ntdef.h is included. But ntdef has
// types which winnt.h does not have, so the chicken and egg problem.
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <ComCat.h>

// For debugging functions.
#include <debug.h>

// For logging functions.
#include <debug.h>

// For tracing macros specific to this project
#include "BCATrace.h"

// Contains setup API function declarations
#include <setupapi.h>

// For serveral common macros
#include <clusudef.h>

// A few common declarations
#include "CommonDefs.h"

// For the CStr class
#include "CStr.h"

// For resource ids
#include "BaseClusterResources.h"

// For smart classes
#include "SmartClasses.h"

// For the exception classes.
#include "Exceptions.h"

// For CAction
#include "CAction.h"

// For the CBaseClusterAction class
#include "CBaseClusterAction.h"

// For the CRegistryKey class
#include "CRegistryKey.h"

// For the notification guids.
#include <Guids.h>

// For published ClusCfg guids
#include <ClusCfgGuids.h>

// For the CBCAInterface class.
#include "CBCAInterface.h"

// For the CStatusReport class
#include "CStatusReport.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\globalfuncs.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      GlobalFuncs.cpp
//
//  Description:
//      Contains the definitions of a few unrelated global functions
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"

// For setupapi functions and constants.
#include <setupapi.h>

// Needed by Dll.h
#include "CFactory.h"

// For g_hInstance
#include "Dll.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  UINT
//  g_GenericSetupQueueCallback
//
//  Description:
//      A generic callback used by SetupAPI file operations.
//
//  Arguments:
//      pvContextIn
//          Context used by this function. Ignored.
//
//      uiNotificationIn
//          The type of notification being sent.
//
//      uiParam1In
//      uiParam2In
//          Additional notification information.
//
//
//  Return Value:
//      During the SPFILENOTIFY_DELETEERROR notification, FILEOP_SKIP is returned
//      if the file does not exist. Otherwise, FILEOP_ABORT is returned.
//
//      FILEOP_DOIT is returned in all other cases.
//
//  Exceptions Thrown:
//      None
//
//--
//////////////////////////////////////////////////////////////////////////////
UINT
CALLBACK
g_GenericSetupQueueCallback(
      PVOID     // pvContextIn         // context used by the callback routine
    , UINT      uiNotificationIn    // queue notification
    , UINT_PTR  uiParam1In          // additional notification information
    , UINT_PTR  // uiParam2In          // additional notification information
    )
{
    BCATraceScope( "" );

    UINT    uiRetVal = FILEOP_DOIT;

    switch( uiNotificationIn )
    {
        case SPFILENOTIFY_DELETEERROR:
        {
            // For this notification uiParam1In is a pointer to a FILEPATHS structure.
            FILEPATHS * pfFilePaths = reinterpret_cast< FILEPATHS * >( uiParam1In );

            if ( pfFilePaths->Win32Error == ERROR_FILE_NOT_FOUND )
            {
                // If the file to be deleted was not found, just skip it.
                uiRetVal = FILEOP_SKIP;
            } // if: the file to be deleted does not exist.
            else
            {
                BCATraceMsg2( 
                      "g_GenericSetupQueueCallback() => Error %#08x has occurred while deleting a file '%s'. Aborting."
                    , pfFilePaths->Win32Error
                    , pfFilePaths->Target
                    );

                uiRetVal = FILEOP_ABORT;
            } // else: some other error occurred.
        }
        break;
    }

    return uiRetVal;

} //*** g_GenericSetupQueueCallback()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\exceptions.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Exceptions.h
//
//  Description:
//      This file contains the declarations of many exception classes.
//
//  Implementation File:
//      None.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For HRESULT, WCHAR, etc.
#include <windef.h>

// For the base class of all exceptions
#include "CException.h"

// For the CStr class
#include "CStr.h"


//////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

//
// Shorthand for throwing different exceptions.
//

#define THROW_ASSERT( _hrErrorCode, _pszMessage ) \
    throw CAssert( _hrErrorCode, TEXT( __FILE__ ), __LINE__, TEXT( _pszMessage ) )

#define THROW_RUNTIME_ERROR( _hrErrorCode, _stringId ) \
    throw CRuntimeError( _hrErrorCode, TEXT( __FILE__ ), __LINE__, _stringId )

#define THROW_CONFIG_ERROR( _hrErrorCode, _stringId ) \
    throw CConfigError( _hrErrorCode, TEXT( __FILE__ ), __LINE__, _stringId )

#define THROW_ABORT( _hrErrorCode, _stringId ) \
    throw CAbortException( _hrErrorCode, TEXT( __FILE__ ), __LINE__, _stringId )


//////////////////////////////////////////////////////////////////////
// External variable declarations
//////////////////////////////////////////////////////////////////////////////

// Handle to the instance of this DLL
extern HINSTANCE g_hInstance;



//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CExceptionWithString
//
//  Description:
//      The class is a CException with an additional message string.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CExceptionWithString : public CException
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public type definitions
    //////////////////////////////////////////////////////////////////////////
    typedef CException BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor ( string id overload )
    CExceptionWithString( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , UINT          uiErrorStringIdIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn )
        , m_fHasUserBeenNotified( false )
    {
        AssignString( uiErrorStringIdIn );
    }

    // Constructor ( character string overload )
    CExceptionWithString( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , const WCHAR * pcszErrorStringIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn )
        , m_fHasUserBeenNotified( false )
    {
        AssignString( pcszErrorStringIn );
    }

    // Copy constructor.
    CExceptionWithString( const CExceptionWithString & cesuSrcIn )  throw()
        : BaseClass( cesuSrcIn )
        , m_fHasUserBeenNotified( cesuSrcIn.m_fHasUserBeenNotified )
    {
        AssignString( cesuSrcIn.m_strErrorString );
    }

    // Default destructor.
    ~CExceptionWithString() throw() {}



    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    // Assignment operator.
    const CExceptionWithString & 
        operator =( const CExceptionWithString & cesuSrcIn ) throw()
    {
        *( static_cast< BaseClass * >( this ) ) = cesuSrcIn;
        AssignString( cesuSrcIn.m_strErrorString );
        m_fHasUserBeenNotified = cesuSrcIn.m_fHasUserBeenNotified;
        return *this;
    }

    //
    // Accessor methods.
    //
    const CStr &
        StrGetErrorString() const throw() { return m_strErrorString; }

    void
        SetErrorString( const WCHAR * pcszSrcIn ) throw()
    {
        AssignString( pcszSrcIn );
    }

    bool
        FHasUserBeenNotified() const throw() { return m_fHasUserBeenNotified; }

    void
        SetUserNotified( bool fNotifiedIn = true ) throw() { m_fHasUserBeenNotified = fNotifiedIn; }

private:
    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Function to set the member string ( string id overload ).
    void AssignString( UINT uiStringIdIn ) throw()
    {
        try
        {
            m_strErrorString.Empty();
            m_strErrorString.LoadString( g_hInstance, uiStringIdIn );
        }
        catch( ... )
        {
            // If an error has occurred, nothing can be done - we are most probably in a stack unwind anyway.
            THR( E_UNEXPECTED );
        } // catch all: cannot let an exception propagate out of any of the methods of this class
    }

    // Function to set the member string ( character string overload ).
    void AssignString( const WCHAR * pcszSrcIn ) throw()
    {
        try
        {
            m_strErrorString.Empty();
            m_strErrorString.Assign( pcszSrcIn );
        }
        catch( ... )
        {
            // If an error has occurred, nothing can be done - we are most probably in a stack unwind anyway.
            THR( E_UNEXPECTED );
        } // catch all: cannot let an exception propagate out of any of the methods of this class
    }


    // Function to set the member string ( CStr overload ).
    void AssignString( const CStr & rcstrSrcIn ) throw()
    {
        try
        {
            m_strErrorString.Empty();
            m_strErrorString.Assign( rcstrSrcIn );
        }
        catch( ... )
        {
            // If an error has occurred, nothing can be done - we are most probably in a stack unwind anyway.
            THR( E_UNEXPECTED );
        } // catch all: cannot let an exception propagate out of any of the methods of this class
    }


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////
    CStr            m_strErrorString;

    // Indicates if the user has been notified about this exception or not.
    bool            m_fHasUserBeenNotified;

}; //*** class CExceptionWithString


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CAssert
//
//  Description:
//      This class of exceptions is used to represent programming errors or 
//      invalid assumptions.
//
//      The accompanying message is not expected to be localized.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CAssert : public CExceptionWithString
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public type definitions
    //////////////////////////////////////////////////////////////////////////
    typedef CExceptionWithString BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // CAssert ( string id overload ).
    CAssert( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , UINT          uiErrorStringIdIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn, uiErrorStringIdIn )
    {
    }

    // Constructor ( character string overload )
    CAssert( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , const WCHAR * pcszErrorStringIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn, pcszErrorStringIn )
    {
    }


}; //*** class CAssert


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CRuntimeError
//
//  Description:
//      This class of exceptions is used to signal runtime errors such as memory
//      exhaustion, failure of Win32 API calls, etc.
//
//      The accompanying message may be shown to the user and should therefore
//      be localized.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CRuntimeError : public CExceptionWithString
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public type definitions
    //////////////////////////////////////////////////////////////////////////
    typedef CExceptionWithString BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor ( string id overload ).
    CRuntimeError( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , UINT          uiErrorStringIdIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn, uiErrorStringIdIn )
    {
    }

    // Constructor ( character string overload )
    CRuntimeError( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , const WCHAR * pcszErrorStringIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn, pcszErrorStringIn )
    {
    }

}; //*** class CRuntimeError


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CAbortException
//
//  Description:
//      This exception is thrown to indicate that the configuration operation
//      was aborted.
//
//      The accompanying message may be shown to the user and should therefore
//      be localized.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CAbortException : public CExceptionWithString
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public type definitions
    //////////////////////////////////////////////////////////////////////////
    typedef CExceptionWithString BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor ( string id overload ).
    CAbortException( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , UINT          uiErrorStringIdIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn, uiErrorStringIdIn )
    {
    }

    // Constructor ( character string overload )
    CAbortException( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , const WCHAR * pcszErrorStringIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn, pcszErrorStringIn )
    {
    }

}; //*** class CAbortException


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CConfigError
//
//  Description:
//      This class of exceptions is used to signal errors related to cluster
//      configuration. For example, an object of this class is thrown if the
//      OS version of the computer cannot support the requested configuration
//      step.
//
//      The accompanying message may be shown to the user and should therefore
//      be localized.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CConfigError : public CExceptionWithString
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public type definitions
    //////////////////////////////////////////////////////////////////////////
    typedef CExceptionWithString BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor ( string id overload )
    CConfigError( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , UINT          uiErrorStringIdIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn, uiErrorStringIdIn )
    {
    }

    // Constructor ( character string overload )
    CConfigError( 
          HRESULT       hrErrorCodeIn
        , const WCHAR * pcszFileNameIn
        , UINT          uiLineNumberIn
        , const WCHAR * pcszErrorStringIn
        ) throw()
        : BaseClass( hrErrorCodeIn, pcszFileNameIn, uiLineNumberIn, pcszErrorStringIn )
    {
    }

}; //*** class CConfigError
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\cuuid.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CUuid.h
//
//  Description:
//      Header file for CUuid class.
//
//      CUuid is a representation of a UUID (universally unique identifier)
//
//  Implementation Files:
//      CUuid.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// Required by Rpcdce.h
#include "rpc.h"

// For UUID and related functions.
#include <Rpcdce.h>


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CUuid
//
//  Description:
//      CUuid is a representation of a UUID (universally unique identifier)
//
//--
//////////////////////////////////////////////////////////////////////////////
class CUuid
{
public:

    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Default constructor.
    CUuid();

    // Default destructor.
    ~CUuid();


    //////////////////////////////////////////////////////////////////////////
    // Public accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the string that represents this UUID.
    const WCHAR *
        PszGetUuidString() const throw() { return m_pszStringUuid; }

    // Get the UUID of this object.
    const UUID &
        UuidGetUuid() const throw() { return m_uuid; }


private:

    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    UUID        m_uuid;
    WCHAR *     m_pszStringUuid;

}; //*** class CUuid
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\listtest\listtest.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ListTest.cpp
//
//  Description:
//      Main file for the application used to test CList
//
//  Documentation:
//      No documention for the test harness.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#if DBG==1 || defined( _DEBUG )
#define DEBUG
#endif

#include <windows.h>

HINSTANCE g_hInstance;
LPVOID    g_GlobalMemoryList = NULL;    // Global memory tracking list

// For the debugging macros.
#include "debug.h"

// For printf
#include <stdio.h>

// For CList
#include "CList.h"

// Globals
int g_nPrintDepth = 1;

DEFINE_MODULE( "ListTest" )

// Test class
class CTestClass
{
public:
    static int ms_nObjectNo;
    int m_nId;

    CTestClass()
    {
        ++ms_nObjectNo;
        m_nId  = ms_nObjectNo;
        wprintf( L"%*cConstructing CTestClass object %d\n", g_nPrintDepth, L' ', ms_nObjectNo );
    }

    CTestClass( const CTestClass & src )
    {
        ++ms_nObjectNo;
        m_nId  = src.m_nId;
        wprintf( L"%*cConstructing CTestClass object %d\n", g_nPrintDepth, L' ', ms_nObjectNo );
    }

    ~CTestClass()
    {
        wprintf( L"%*cDestroying CTestClass object %d\n", g_nPrintDepth, L' ', ms_nObjectNo );
        --ms_nObjectNo;
    }

private:
    const CTestClass & operator=( const CTestClass & );

}; //*** class CTestClass

int CTestClass::ms_nObjectNo = 0;

void PrintId( CList< CTestClass >::CIterator & iter )
{
    wprintf( L"%d", iter->m_nId );
}


void PrintId( CList< CTestClass * >::CIterator & iter )
{
    wprintf( L"%d", (*iter)->m_nId );
}


void PrintId( CList< int >::CIterator & iter )
{
    wprintf( L"%d", *iter );
}


template< class t_Ty > void PrintForwardList( CList<t_Ty> & l )
{
    g_nPrintDepth += 4;
    wprintf( L"%*cPrinting forward list element ids...\n", g_nPrintDepth, L' ' );

    CList<t_Ty>::CIterator s = l.CiBegin();
    CList<t_Ty>::CIterator e = l.CiEnd();

    wprintf( L"%*c+ ", g_nPrintDepth, L' ' );
    while( s != e )
    {
        PrintId( s );
        wprintf( L" " );
        ++s;
    }

    wprintf( L" +\n" );

    g_nPrintDepth -= 4;
}

template< class t_Ty > void PrintReverseList( CList<t_Ty> & l )
{
    g_nPrintDepth += 4;
    wprintf( L"%*cPrinting reverse list element ids...\n", g_nPrintDepth, L' ' );

    CList<t_Ty>::CIterator s = l.CiEnd();
    CList<t_Ty>::CIterator e = l.CiEnd();

    wprintf( L"%*c+ ", g_nPrintDepth, L' ' );

    --s;
    while( s != e )
    {
        PrintId( s );
        wprintf( L" " );
        --s;
    }

    wprintf( L"+\n" );

    g_nPrintDepth -= 4;
}

template< class t_Ty > void CheckSize( CList<t_Ty> & l, int size )
{
    if ( l.CGetSize() != size )
    {
        wprintf( L"%*cERROR: The list should be %d. It is %d.\n", g_nPrintDepth, L' ', size, l.CGetSize() );
        throw L"List size";
    }
}

// Test a list of integers
template< class t_Ty > void TestList( t_Ty array[], int arrSize ) 
{
    int idx;

    wprintf( L"%*c|-------------------------------------------------------------------|\n", g_nPrintDepth, L' ' );
    g_nPrintDepth += 4;


    wprintf( L"\n%*cConstructing empty list.\n", g_nPrintDepth, L' ' );
    CList<t_Ty> l;
    CheckSize( l, 0 );

    {
        CList<t_Ty>::CIterator b = l.CiBegin();
        CList<t_Ty>::CIterator e = l.CiEnd();

        wprintf( L"\n%*cChecking if beginning and end of empty list are the same... ", g_nPrintDepth, L' ' );
        if ( ( b == e ) && !( b != e ) )
        {
            wprintf( L"Passed\n" );
        }
        else
        {
            wprintf( L"Failed\n" );
            throw L"Empty list iterator";
        }
    }

    wprintf( L"\n%*cPrinting empty list...\n", g_nPrintDepth, L' ' );
    PrintForwardList( l );
    PrintReverseList( l );

    {
        wprintf( L"\n%*cAdding one element to list\n", g_nPrintDepth, L' ' );
        
        l.Append( array[0] );
        CheckSize( l, 1 );

        PrintForwardList( l );
        PrintReverseList( l );
    }

    {
        wprintf( L"\n%*cAdding %d more elements\n", g_nPrintDepth, L' ', arrSize - 1 );
        CList<t_Ty>::CIterator iter = l.CiBegin();

        for ( idx = 1; idx < arrSize; )
        {
            l.InsertAfter( iter, array[idx] );
            ++iter;
            ++idx;
            CheckSize( l, idx );
        }

        PrintForwardList( l );
        PrintReverseList( l );
    }

    {
        wprintf( L"\n%*cDeleting elements\n", g_nPrintDepth, L' ', arrSize - 1 );
        CList<t_Ty>::CIterator iter = l.CiBegin();
        CList<t_Ty>::CIterator end = l.CiEnd();

        idx = arrSize;
        while( iter != end )
        {
            --idx;
            l.DeleteAndMoveToNext( iter );
            CheckSize( l, idx );
        }

        PrintForwardList( l );
        PrintReverseList( l );
    }

    g_nPrintDepth -= 4;
    wprintf( L"%*c|-------------------------------------------------------------------|\n", g_nPrintDepth, L' ' );
}


int __cdecl wmain( void )
{
    int nRetVal = 0;

    g_hInstance = GetModuleHandle( NULL );

    TraceInitializeProcess( NULL, NULL );
    TraceCreateMemoryList( g_GlobalMemoryList );

    g_tfModule = mtfMEMORYLEAKS;

    try
    {
        {
            wprintf( L"%*cTesting CTestClass list.\n", g_nPrintDepth, L' ' );
            CTestClass arr[ 4 ];

            TestList< CTestClass >( arr, 4 );
        }

        {
            wprintf( L"\n%*cTesting CTestClass pointer list.\n", g_nPrintDepth, L' ' );

            CTestClass * arr[ 5 ];
            int idx;

            for ( idx = 0; idx < 5; ++idx )
                arr[idx] = new CTestClass;

            TestList< CTestClass * >( arr, 5 );

            for ( idx = 0; idx < 5; ++idx )
                delete arr[idx];

        }

        {
            int arr[] = { 1, 2, 3, 4 };

            wprintf( L"\n%*cTesting int list.\n", g_nPrintDepth, L' ' );
            TestList< int >( arr, sizeof( arr ) / sizeof( arr[0] ) );
        }
    }
    catch( WCHAR * pszTestName )
    {
        wprintf( L"Test '%s' failed.\n", pszTestName );
    }
    catch( ... )
    {
        wprintf( L"Caught an unknown exception.\n" );
        nRetVal = 1;
    }

    TraceTerminateMemoryList( g_GlobalMemoryList );
    TraceTerminateProcess( NULL, NULL );

    return nRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\test\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file for the ClusOCM DLL.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Macro Definitions
//////////////////////////////////////////////////////////////////////////////

#if DBG==1 || defined( _DEBUG )
#define DEBUG
#endif

////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>
// For wprintf
#include <stdio.h>

// For smart classes
#include "SmartClasses.h"

// For IClusCfgBaseCluster
#include "ClusCfgServer.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\test\ccluscfgcallback.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusCfgCallback.h
//
//  Description:
//      Header file for CClusCfgCallback.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


#pragma once


////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the IClusCfgCallback interface
#include "ClusCfgServer.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgCallback
//
//  Description:
//      This class implements the IClusCfgBaseCluster interface.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgCallback
    : public IClusCfgCallback
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructor and Destructor
    //////////////////////////////////////////////////////////////////////////

    // Constructor
    CClusCfgCallback( void );

    // Destructor
    ~CClusCfgCallback( void );


    //////////////////////////////////////////////////////////////////////////
    // IUnknown methods
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgCallback methods
    //////////////////////////////////////////////////////////////////////////
    STDMETHOD( SendStatusReport )(
            BSTR        bstrNodeNameIn,
            CLSID       clsidTaskMajorIn,
            CLSID       clsidTaskMinorIn,
            ULONG       ulMinIn,
            ULONG       ulMaxIn,
            ULONG       ulCurrentIn,
            HRESULT     hrStatusIn,
            BSTR        bstrDescriptionIn,
            FILETIME *  pftTimeIn,
            BSTR        bstrReferenceIn
            );

    //////////////////////////////////////////////////////////////////////////
    //  Other public methods
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

private:
    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Reference count for this object.
    LONG                m_cRef;

}; //*** class CClusCfgCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\test\ccluscfgcallback.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusCfgCallback.cpp
//
//  Description:
//      This file contains the implementation of the CClusCfgCallback
//      class.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Header File:
//      CClusCfgCallback.h
//
//  Maintained By:
//      Vij Vasu (VVasu) 07-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "pch.h"
#include "CClusCfgCallback.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::CClusCfgCallback()
//
//  Description:
//      Constructor of the CClusCfgCallback class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgCallback::CClusCfgCallback( void )
    : m_cRef( 1 )
{
} //*** CClusCfgCallback::CClusCfgCallback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::~CClusCfgCallback()
//
//  Description:
//      Destructor of the CClusCfgCallback class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgCallback::~CClusCfgCallback( void )
{
} //*** CClusCfgCallback::~CClusCfgCallback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CClusCfgCallback::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//  Description:
//      Creates a CClusCfgCallback instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface to the newly create object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCallback::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    CClusCfgCallback *  pccb;
    HRESULT hr;

    pccb = new CClusCfgCallback();
    if ( pccb != NULL )
    {
        hr = pccb->QueryInterface( IID_IUnknown, reinterpret_cast< void ** >( ppunkOut ) );
        pccb->Release( );

    } // if: error allocating object
    else
    {
        hr = E_OUTOFMEMORY;
    } // else: out of memory

    return hr;

} //*** CClusCfgCallback::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusCfgCallback::AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgCallback::AddRef( void )
{
    InterlockedIncrement( &m_cRef );
    return m_cRef;

} //*** CClusCfgCallback::AddRef()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusCfgCallback::Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgCallback::Release( void )
{
    InterlockedDecrement( &m_cRef );

    if ( m_cRef == 0 )
    {
        delete this;
        return 0;
    } // if: reference count decremented to zero

    return m_cRef;

} //*** CClusCfgCallback::Release()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgCallback::QueryInterface()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCallback::QueryInterface( REFIID  riid, void ** ppv )
{

    HRESULT hr = S_OK;

    if ( ppv != NULL )
    {
        if ( IsEqualIID( riid, IID_IUnknown ) )
        {
             *ppv = static_cast< IClusCfgCallback * >( this );
        } // if: IUnknown
        else if ( IsEqualIID( riid, IID_IClusCfgCallback ) )
        {
            *ppv = static_cast< IClusCfgCallback * >( this );
        } // else if:
        else
        {
            hr = E_NOINTERFACE;
        } // else

        if ( SUCCEEDED( hr ) )
        {
            ((IUnknown *) *ppv)->AddRef( );
        } // if: success
        else
        {
            *ppv = NULL;
        } // else: something failed

    } // if: the output pointer was valid
    else
    {
        hr = E_INVALIDARG;
    } // else: the output pointer is invalid

    return hr;

} //*** CClusCfgCallback::QueryInterface()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CClusCfgCallback::SendStatusReport
//
//  Description:
//      Handle a progress notification
//
//  Arguments:
//      bstrNodeNameIn
//          Name of the node that sent the status report.
//
//      clsidTaskMajorIn
//      clsidTaskMinorIn
//          GUID identifying the notification.
//
//      ulMinIn
//      ulMaxIn
//      ulCurrentIn
//          Values that indicate the percentage of this task that is
//          completed.
//
//      hrStatusIn
//          Error code.
//
//      bstrDescriptionIn
//          String describing the notification.
//
//  Return Value:
//      Always
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCallback::SendStatusReport(
      BSTR          bstrNodeNameIn
    , CLSID         clsidTaskMajorIn
    , CLSID         clsidTaskMinorIn
    , ULONG         ulMinIn
    , ULONG         ulMaxIn
    , ULONG         ulCurrentIn
    , HRESULT       hrStatusIn
    , BSTR          bstrDescriptionIn
    , FILETIME *    pftTimeIn
    , BSTR          bstrReferenceIn
    ) throw()
{
    wprintf( L"Notification ( %d, %d, %d ) =>\n  '%s' ( Error Code %#X )\n", ulMinIn, ulMaxIn, ulCurrentIn, bstrDescriptionIn, hrStatusIn );

    return S_OK;

} //*** CClusCfgCallback::SendStatusReport()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\test\baseclustertest.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      BaseClusterTest.h
//
//  Description:
//      Header file for BaseClusterTest.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


#pragma once


////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>


////////////////////////////////////////////////////////////////////////////////
// Function declarations
//////////////////////////////////////////////////////////////////////////////

void ShowUsage();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\basecluster\test\baseclustertest.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      BaseClusterTest.cpp
//
//  Description:
//      Main file for the test harness executable.
//      Initializes tracing, parses command line and actually call the 
//      BaseClusCfg functions.
//
//  Documentation:
//      No documention for the test harness.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <stdio.h>
#include <objbase.h>
#include <limits.h>

#include <initguid.h>
#include "guids.h"

#include "CClusCfgCallback.h"


// Show help for this executable.
void ShowUsage()
{
    wprintf( L"\nThe syntax of this command is:\n" );
    wprintf( L"\nBaseClusterTest.exe [computer-name] {<options>}\n" );
    wprintf( L"\n<options> =\n" );
    wprintf( L"  /FORM NAME= cluster-name DOMAIN= account-domain ACCOUNT= clussvc-account\n" );
    wprintf( L"        PASSWORD= account-password IPADDR= ip-address(hex)\n" );
    wprintf( L"        SUBNET= ip-subnet-mask(hex) NICNAME= ip-nic-name\n\n" );
    wprintf( L"  /JOIN NAME= cluster-name DOMAIN= account-domain ACCOUNT= clussvc-account\n" );
    wprintf( L"        PASSWORD= account-password\n\n" );
    wprintf( L"  /CLEANUP\n" );
    wprintf( L"\nNotes:\n" );
    wprintf( L"- A space is required after an '=' sign.\n" );
    wprintf( L"- The order for the parameters has to be the same as shown above.\n" );
}


// Create the BaseCluster component.
HRESULT HrInitComponent(
      COSERVERINFO *  pcoServerInfoPtrIn
    , CSmartIfacePtr< IClusCfgBaseCluster > & rspClusCfgBaseClusterIn
    )
{
    HRESULT hr = S_OK;

    do
    {
        MULTI_QI mqiInterfaces[] = 
        {
            { &IID_IClusCfgBaseCluster, NULL, S_OK },
            { &IID_IClusCfgInitialize, NULL, S_OK }
        };

        //
        // Create and initialize the BaseClusterAction component
        //

        hr = CoCreateInstanceEx(
                  CLSID_ClusCfgBaseCluster
                , NULL
                , CLSCTX_LOCAL_SERVER 
                , pcoServerInfoPtrIn
                , sizeof( mqiInterfaces ) / sizeof( mqiInterfaces[0] )
                , mqiInterfaces
                );

        // Store the retrieved pointers in smart pointers for safe release.
        rspClusCfgBaseClusterIn.Attach( 
              reinterpret_cast< IClusCfgBaseCluster * >( mqiInterfaces[0].pItf )
            );


        CSmartIfacePtr< IClusCfgInitialize > spClusCfgInitialize;
        
        spClusCfgInitialize.Attach( reinterpret_cast< IClusCfgInitialize * >( mqiInterfaces[1].pItf ) );

        // Check if CoCreateInstanceEx() worked.
        if ( FAILED( hr ) && ( hr != CO_S_NOTALLINTERFACES ) )
        {
            wprintf( L"Could not create the BaseCluster component. Error %#X.\n", hr );
            break;
        } // if: CoCreateInstanceEx() failed

        // Check if we got the pointer to the IClusCfgBaseCluster interface.
        hr = mqiInterfaces[0].hr;
        if ( FAILED( hr ) )
        {
            // We cannot do anything without this pointer - bail.
            wprintf( L"Could not get the IClusCfgBaseCluster pointer. Error %#X.\n", hr );
            break;
        } // if: we could not get a pointer to the IClusCfgBaseCluster interface

        //
        // Check if we got a pointer to the IClusCfgInitialize interface
        hr = mqiInterfaces[1].hr;
        if ( hr == S_OK )
        {
            // We got the pointer - initialize the component.

            IUnknown * punk = NULL;
            IClusCfgCallback * pccb = NULL;

            hr = CClusCfgCallback::S_HrCreateInstance( &punk );
            if ( FAILED( hr ) )
            {
                wprintf( L"Could not initalize callback component. Error %#X.\n", hr );
                break;
            }

            hr = punk->QueryInterface< IClusCfgCallback >( &pccb );
            punk->Release( );
            if ( FAILED( hr ) )
            {
                wprintf( L"Could not find IClusCfgCallback on CClusCfgCallback object. Error %#X.\n", hr );
                break;
            }

            hr = spClusCfgInitialize->Initialize( pccb, LOCALE_SYSTEM_DEFAULT );

            if ( pccb != NULL )
            {
                pccb->Release();
            } // if: we created a callback, release it.

            if ( FAILED( hr ) )
            {
                if ( hr == HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) )
                {
                    wprintf( L"Access was denied trying to initialize the BaseCluster component. This may be because remote callbacks are not supported. However, configuration will proceed.\n" );
                    hr = ERROR_SUCCESS;
                } // if: the error was ERROR_ACCESS_DENIED
                else
                {
                    wprintf( L"Could not initialize the BaseCluster component. Error %#X occurred. Configuration will be aborted.\n", hr );
                    break;
                } // else: some other error occurred.
            } // if: something went wrong during initialization

        } // if: we got a pointer to the IClusCfgInitialize interface
        else
        {
            wprintf( L"The BaseCluster component does not provide notifications.\n" );
            if ( hr != E_NOINTERFACE )
            {
                break;
            } // if: the interface is supported, but something else went wrong.

            //
            // If the interface is not support, that is ok. It just means that
            // initialization is not required.
            //
            hr = S_OK;
        } // if: we did not get a pointer to the IClusCfgInitialize interface
    }
    while( false );

    return hr;
}


HRESULT HrFormCluster(
      int argc
    , WCHAR *argv[]
    , CSmartIfacePtr< IClusCfgBaseCluster > & rspClusCfgBaseClusterIn
    )
{
    HRESULT hr = S_OK;
    bool fSyntaxError = false;

    do
    {
        if ( argc != 16 )
        {
            wprintf( L"FORM: Incorrect number of parameters.\n" );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        wprintf( L"Trying to form a cluster...\n");

        // Cluster name.
        if ( _wcsicmp( argv[2], L"NAME=" ) != 0 )
        {
            wprintf( L"Expected 'NAME='. Got '%s'.\n", argv[2] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        WCHAR * pszClusterName = argv[3];
        wprintf( L"  Cluster Name = '%s'\n", pszClusterName );

        // Cluster account domain
        if ( _wcsicmp( argv[4], L"DOMAIN=" ) != 0 )
        {
            wprintf( L"Expected 'DOMAIN='. Got '%s'.\n", argv[4] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }
        
        WCHAR * pszClusterAccountDomain = argv[5];
        wprintf( L"  Cluster Account Domain = '%s'\n", pszClusterAccountDomain );


        // Cluster account name.
        if ( _wcsicmp( argv[6], L"ACCOUNT=" ) != 0 )
        {
            wprintf( L"Expected 'ACCOUNT='. Got '%s'.\n", argv[6] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        WCHAR * pszClusterAccountName = argv[7];
        wprintf( L"  Cluster Account Name = '%s'\n", pszClusterAccountName );


        // Cluster account password.
        if ( _wcsicmp( argv[8], L"PASSWORD=" ) != 0 )
        {
            wprintf( L"Expected 'PASSWORD='. Got '%s'.\n", argv[8] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        WCHAR * pszClusterAccountPwd = argv[9];
        wprintf( L"  Cluster Account Password = '%s'\n", pszClusterAccountPwd );


        // Cluster IP address.
        if ( _wcsicmp( argv[10], L"IPADDR=" ) != 0 )
        {
            wprintf( L"Expected 'IPADDR='. Got '%s'.\n", argv[10] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        WCHAR * pTemp;

        ULONG ulClusterIPAddress = wcstoul( argv[11], &pTemp, 16 );
        if (   ( ( argv[11] + wcslen( argv[11] ) ) != pTemp )
            || ( ulClusterIPAddress == ULONG_MAX ) )
        {
            wprintf( L"Could not convert '%s' to an IP address.\n", argv[11] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }
        wprintf(
              L"  Cluster IP Address = %d.%d.%d.%d\n"
            , ( ulClusterIPAddress & 0xFF000000 ) >> 24
            , ( ulClusterIPAddress & 0x00FF0000 ) >> 16
            , ( ulClusterIPAddress & 0x0000FF00 ) >> 8
            , ( ulClusterIPAddress & 0x000000FF )
            );


        // Cluster IP subnet mask.
        if ( _wcsicmp( argv[12], L"SUBNET=" ) != 0 )
        {
            wprintf( L"Expected 'SUBNET='. Got '%s'.\n", argv[12] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        ULONG ulClusterIPSubnetMask = wcstoul( argv[13], &pTemp, 16 );
        if (   ( ( argv[13] + wcslen( argv[13] ) ) != pTemp )
            || ( ulClusterIPAddress == ULONG_MAX ) )
        {
            wprintf( L"Could not convert '%s' to a subnet mask.\n", argv[13] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }
        wprintf(
              L"  Cluster IP subnet mask = %d.%d.%d.%d\n"
            , ( ulClusterIPSubnetMask & 0xFF000000 ) >> 24
            , ( ulClusterIPSubnetMask & 0x00FF0000 ) >> 16
            , ( ulClusterIPSubnetMask & 0x0000FF00 ) >> 8
            , ( ulClusterIPSubnetMask & 0x000000FF )
            );


        // Cluster IP NIC name.
        if ( _wcsicmp( argv[14], L"NICNAME=" ) != 0 )
        {
            wprintf( L"Expected 'NICNAME='. Got '%s'.\n", argv[14] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        WCHAR * pszClusterIPNetwork = argv[15];
        wprintf( L"  Name of the NIC for the cluster IP address = '%s'\n", pszClusterIPNetwork );


        // Indicate that a cluster should be formed when Commit() is called.
        hr = rspClusCfgBaseClusterIn->SetForm(
                  pszClusterName
                , pszClusterAccountName
                , pszClusterAccountPwd
                , pszClusterAccountDomain
                , ulClusterIPAddress
                , ulClusterIPSubnetMask
                , pszClusterIPNetwork
                );

        if ( FAILED( hr ) )
        {
            wprintf( L"Error %#X occurred trying to set cluster form parameters.\n", hr );
            break;
        } // if: SetForm() failed.

        // Initiate cluster formation.
        hr = rspClusCfgBaseClusterIn->Commit();
        if ( hr != S_OK )
        {
            wprintf( L"Error %#X occurred trying to form the cluster.\n", hr );
            break;
        } // if: Commit() failed.

        wprintf( L"Cluster successfully formed.\n" );
    }
    while( false );

    if ( fSyntaxError )
    {
        ShowUsage();
    }

    return hr;
}


HRESULT HrJoinCluster(
      int argc
    , WCHAR *argv[]
    , CSmartIfacePtr< IClusCfgBaseCluster > & rspClusCfgBaseClusterIn
    )
{
    HRESULT hr = S_OK;
    bool fSyntaxError = false;

    do
    {
        if ( argc != 10 )
        {
            wprintf( L"JOIN: Incorrect number of parameters.\n" );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        wprintf( L"Trying to join a cluster...\n");

        // Cluster name.
        if ( _wcsicmp( argv[2], L"NAME=" ) != 0 )
        {
            wprintf( L"Expected 'NAME='. Got '%s'.\n", argv[2] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        WCHAR * pszClusterName = argv[3];
        wprintf( L"  Cluster Name = '%s'\n", pszClusterName );

        // Cluster account domain
        if ( _wcsicmp( argv[4], L"DOMAIN=" ) != 0 )
        {
            wprintf( L"Expected 'DOMAIN='. Got '%s'.\n", argv[4] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }
        
        WCHAR * pszClusterAccountDomain = argv[5];
        wprintf( L"  Cluster Account Domain = '%s'\n", pszClusterAccountDomain );


        // Cluster account name.
        if ( _wcsicmp( argv[6], L"ACCOUNT=" ) != 0 )
        {
            wprintf( L"Expected 'ACCOUNT='. Got '%s'.\n", argv[6] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        WCHAR * pszClusterAccountName = argv[7];
        wprintf( L"  Cluster Account Name = '%s'\n", pszClusterAccountName );


        // Cluster account password.
        if ( _wcsicmp( argv[8], L"PASSWORD=" ) != 0 )
        {
            wprintf( L"Expected 'PASSWORD='. Got '%s'.\n", argv[8] );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        WCHAR * pszClusterAccountPwd = argv[9];
        wprintf( L"  Cluster Account Password = '%s'\n", pszClusterAccountPwd );


        // Indicate that a cluster should be joined when Commit() is called.
        hr = rspClusCfgBaseClusterIn->SetJoin(
                  pszClusterName
                , pszClusterAccountName
                , pszClusterAccountPwd
                , pszClusterAccountDomain
                );

        if ( FAILED( hr ) )
        {
            wprintf( L"Error %#X occurred trying to set cluster join parameters.\n", hr );
            break;
        } // if: SetJoin() failed.

        // Initiate cluster join.
        hr = rspClusCfgBaseClusterIn->Commit();
        if ( hr != S_OK )
        {
            wprintf( L"Error %#X occurred trying to join the cluster.\n", hr );
            break;
        } // if: Commit() failed.

        wprintf( L"Cluster join successful.\n" );
    }
    while( false );

    if ( fSyntaxError )
    {
        ShowUsage();
    }

    return hr;
}


HRESULT HrCleanupNode(
      int argc
    , WCHAR *argv[]
    , CSmartIfacePtr< IClusCfgBaseCluster > & rspClusCfgBaseClusterIn
    )
{
    HRESULT hr = S_OK;
    bool fSyntaxError = false;

    do
    {
        if ( argc != 2 )
        {
            wprintf( L"CLEANUP: Incorrect number of parameters.\n" );
            fSyntaxError = true;
            hr = E_INVALIDARG;
            break;
        }

        wprintf( L"Trying to cleanup node...\n");

        // Indicate that the node should be cleaned up when Commit() is called.
        hr = rspClusCfgBaseClusterIn->SetCleanup();

        if ( FAILED( hr ) )
        {
            wprintf( L"Error %#X occurred trying to set node cleanup parameters.\n", hr );
            break;
        } // if: SetCleanup() failed.

        // Initiate node cleanup.
        hr = rspClusCfgBaseClusterIn->Commit();
        if ( hr != S_OK )
        {
            wprintf( L"Error %#X occurred trying to clean up the node.\n", hr );
            break;
        } // if: Commit() failed.

        wprintf( L"Node successfully cleaned up.\n" );
    }
    while( false );

    if ( fSyntaxError )
    {
        ShowUsage();
    }

    return hr;
}


// The main function for this program.
int __cdecl wmain( int argc, WCHAR *argv[] )
{
    HRESULT hr = S_OK;

    // Initialize COM
    CoInitializeEx( 0, COINIT_MULTITHREADED );

    wprintf( L"\n" );

    do
    {
        COSERVERINFO    coServerInfo;
        COAUTHINFO      coAuthInfo;
        COSERVERINFO *  pcoServerInfoPtr = NULL;
        WCHAR **        pArgList = argv;
        int             nArgc = argc;

        CSmartIfacePtr< IClusCfgBaseCluster > spClusCfgBaseCluster;

        if ( nArgc <= 1 )
        {
            ShowUsage();
            break;
        }

        // Check if a computer name is specified.
        if ( *pArgList[1] != '/' )
        {
            coAuthInfo.dwAuthnSvc = RPC_C_AUTHN_WINNT;
            coAuthInfo.dwAuthzSvc = RPC_C_AUTHZ_NONE;
            coAuthInfo.pwszServerPrincName = NULL;
            coAuthInfo.dwAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
            coAuthInfo.dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
            coAuthInfo.pAuthIdentityData = NULL;
            coAuthInfo.dwCapabilities = EOAC_NONE;
            
            coServerInfo.dwReserved1 = 0;
            coServerInfo.pwszName = pArgList[1];
            coServerInfo.pAuthInfo = &coAuthInfo;
            coServerInfo.dwReserved2 = 0;

            pcoServerInfoPtr = &coServerInfo;

            wprintf( L"Attempting cluster configuration on computer '%s'.\n", pArgList[1] );

            // Consume the arguments
            ++pArgList;
            --nArgc;
        }
        else
        {
            wprintf( L"Attempting cluster configuration on this computer.\n" );
        }

        // Initialize the BaseCluster component.
        hr = HrInitComponent( pcoServerInfoPtr, spClusCfgBaseCluster );
        if ( FAILED( hr ) )
        {
            wprintf( L"HrInitComponent() failed. Cannot configure cluster. Error %#X.\n", hr );
            break;
        }

        // Parse the command line for options
        if ( _wcsicmp( pArgList[1], L"/FORM" ) == 0 )
        {
            hr = HrFormCluster( nArgc, pArgList, spClusCfgBaseCluster );
            if ( FAILED( hr ) )
            {
                wprintf( L"HrFormCluster() failed. Cannot form cluster. Error %#X.\n", hr );
                break;
            }
        } // if: form
        else if ( _wcsicmp( pArgList[1], L"/JOIN" ) == 0 )
        {
            hr = HrJoinCluster( nArgc, pArgList, spClusCfgBaseCluster );
            if ( FAILED( hr ) )
            {
                wprintf( L"HrJoinCluster() failed. Cannot join cluster. Error %#X.\n", hr );
                break;
            }
        } // else if: join
        else if ( _wcsicmp( pArgList[1], L"/CLEANUP" ) == 0 )
        {
            hr = HrCleanupNode( nArgc, pArgList, spClusCfgBaseCluster );
            if ( FAILED( hr ) )
            {
                wprintf( L"HrFormCluster() failed. Cannot clean up node. Error %#X.\n", hr );
                break;
            }
        } // else if: cleanup
        else
        {
            wprintf( L"Invalid option '%s'.\n", pArgList[1] );
            ShowUsage();
        } // else: invalid option
    }
    while( false ); // dummy do-while loop to avoid gotos.

    CoUninitialize();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\common\cbaseinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CBaseInfo.h
//
//  Description:
//      This file contains the declaration of the CBaseInfo
//      class heirarchy.
//
//      The class CBaseInfo is the base class of methods that abstract the
//      ClusAPI into objects with identical methods for open, close, & control.
//
//  Documentation:
//
//  Implementation Files:
//      CBaseInfo.cpp
//
//  Maintained By:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once


//
// CtlCodeEnum
//
typedef enum _CtlCodeEnum
{
    CONTROL_UNKNOWN                     = 0x00,
    CONTROL_ADD_CRYPTO_CHECKPOINT,
    CONTROL_ADD_REGISTRY_CHECKPOINT,
    CONTROL_GET_REGISTRY_CHECKPOINTS,
    CONTROL_GET_CRYPTO_CHECKPOINTS,
    CONTROL_DELETE_CRYPTO_CHECKPOINT,
    CONTROL_DELETE_REGISTRY_CHECKPOINT,

    CONTROL_VALIDATE_COMMON_PROPERTIES,
    CONTROL_VALIDATE_PRIVATE_PROPERTIES,
    CONTROL_ENUM_COMMON_PROPERTIES,
    CONTROL_ENUM_PRIVATE_PROPERTIES,
    CONTROL_GET_RO_COMMON_PROPERTIES,
    CONTROL_GET_RO_PRIVATE_PROPERTIES,
    CONTROL_GET_COMMON_PROPERTIES,
    CONTROL_GET_PRIVATE_PROPERTIES,
    CONTROL_SET_COMMON_PROPERTIES,
    CONTROL_SET_PRIVATE_PROPERTIES,

    CONTROL_GET_TYPE,
    CONTROL_GET_NAME,
    CONTROL_GET_ID,
    CONTROL_GET_FLAGS,
    CONTROL_GET_CLASS_INFO,
    CONTROL_GET_NETWORK_NAME,
    CONTROL_GET_CHARACTERISTICS,
    CONTROL_GET_REQUIRED_DEPENDENCIES,

    CONTROL_STORAGE_GET_DISK_INFO,
    CONTROL_STORAGE_IS_PATH_VALID,
    CONTROL_STORAGE_GET_AVAILABLE_DISKS,

    CONTROL_QUERY_DELETE,

} CtlCodeEnum;



//
// Class CBaseInfo
//   This is the base class for the heirarchy.
//
class CBaseInfo
{
private:
    IClusterHandleProvider * m_pICHProvider;

public:

    IClusterHandleProvider * getClusterHandleProvider() { return m_pICHProvider; };

    HCLUSTER getClusterHandle( void );

    HRESULT GetPropertyStringHelper( CBasePropList& cplIn, const WCHAR * pszPropertyIn, BSTR * pbstrResultOut );
    HRESULT GetPropertyDwordHelper( CBasePropList& cplIn, const WCHAR * pszPropertyIn, DWORD * pdwValueOut );
    HRESULT GetPropertyStringValue( CtlCodeEnum cceIn, const WCHAR * pszPropertyIn, BSTR * pbstrResultOut );
    HRESULT GetPropertyDwordValue( CtlCodeEnum cceIn, const WCHAR * pszPropertyIn, DWORD * pdwValueOut );
    HRESULT SetClusterHandleProvider( IClusterHandleProvider * pICHPIn );

    DWORD Control( CtlCodeEnum cceIn, VOID * pvBufferIn, DWORD dwLengthIn, VOID * pvBufferOut, DWORD dwBufferLength, DWORD * dwLengthOut, HNODE hHostNode = NULL )
    {
        DWORD sc;
        DWORD dw = ToCode( cceIn );
        if( dw == 0 )
        {
            sc = ERROR_INVALID_PARAMETER;
        }
        else
        {
            sc = Control( dw, pvBufferIn, dwLengthIn, pvBufferOut, dwBufferLength, dwLengthOut, hHostNode );
        }
        return sc;
    }


public:
    CBaseInfo( void );
    virtual ~CBaseInfo( void );

    virtual DWORD   ToCode( CtlCodeEnum )
    {
        return 0;
    }

    virtual HRESULT Close( void );
    virtual HRESULT Open( BSTR bstrName ) = 0;
    virtual DWORD   Control( DWORD dwEnum, VOID * pvBufferIn, DWORD dwLengthIn, VOID * pvBufferOut, DWORD dwBufferLength, DWORD * dwLengthOut, HNODE hHostNode = NULL ) = 0;

};

//
// CBaseClusterInfo
//
class CBaseClusterInfo
: public CBaseInfo
{
public:
    virtual HRESULT Close( void );
    virtual HRESULT Open( BSTR bstrName );
    virtual DWORD   Control( DWORD dwEnum, VOID * pvBufferIn, DWORD dwLengthIn, VOID * pvBufferOut, DWORD dwBufferLength, DWORD * dwLengthOut, HNODE hHostNode = NULL );
    virtual DWORD   ToCode( CtlCodeEnum cceIn );

};

//
// CBaseClusterGroupInfo
//
class CBaseClusterGroupInfo
: public CBaseInfo
{
public:
    HGROUP        m_hGroup;

    virtual HRESULT Close( void );
    virtual HRESULT Open( BSTR bstrGroupName );
    virtual DWORD   Control( DWORD dwEnum, VOID * pvBufferIn, DWORD dwLengthIn, VOID * pvBufferOut, DWORD dwBufferLength, DWORD * dwLengthOut, HNODE hHostNode = NULL );
    virtual DWORD   ToCode( CtlCodeEnum cceIn );

};

//
// CBaseClusterResourceInfo
//
class CBaseClusterResourceInfo
: public CBaseInfo
{
public:
    HRESOURCE  m_hResource;

    virtual HRESULT Close( void );
    virtual HRESULT Open( BSTR bstrResourceName );
    virtual DWORD   Control( DWORD dwEnum, VOID * pvBufferIn, DWORD dwLengthIn, VOID * pvBufferOut, DWORD dwBufferLength, DWORD * dwLengthOut, HNODE hHostNode = NULL );
    virtual DWORD   ToCode( CtlCodeEnum cceIn );
};

//
// CBaseClusterNodeInfo
//
class CBaseClusterNodeInfo
: public CBaseInfo
{
public:
    HNODE      m_hNode;

    virtual HRESULT Close( void );
    virtual HRESULT Open( BSTR bstrNodeName );
    virtual DWORD   Control( DWORD dwEnum, VOID * pvBufferIn, DWORD dwLengthIn, VOID * pvBufferOut, DWORD dwBufferLength, DWORD * dwLengthOut, HNODE hHostNode = NULL );
    virtual DWORD   ToCode( CtlCodeEnum cceIn );

};

//
//  CBaseClusterNetworkInfo
//
class CBaseClusterNetworkInfo
: public CBaseInfo
{
public:
    HNETWORK   m_hNetwork;

    virtual HRESULT Close( void );
    virtual HRESULT Open( BSTR bstrNetworkName );
    virtual DWORD   Control( DWORD dwEnum, VOID * pvBufferIn, DWORD dwLengthIn, VOID * pvBufferOut, DWORD dwBufferLength, DWORD * dwLengthOut, HNODE hHostNode = NULL );
    virtual DWORD   ToCode( CtlCodeEnum cceIn );
};


//
// CBaseClusterNetInterfaceInfo
//
class CBaseClusterNetInterfaceInfo
: public CBaseInfo
{
public:
    HNETINTERFACE m_hNetworkInterface;

    virtual HRESULT Close( void );
    virtual HRESULT Open( BSTR bstrNetworkName );
    virtual DWORD   Control( DWORD dwEnum, VOID * pvBufferIn, DWORD dwLengthIn, VOID * pvBufferOut, DWORD dwBufferLength, DWORD * dwLengthOut, HNODE hHostNode = NULL );
    virtual DWORD   ToCode( CtlCodeEnum cceIn );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\common\cbaseinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CBaseInfo.cpp
//
//  Description:
//      This file contains the implementation of the  CBaseInfo
//      class heirarchy.  They are wrappers for the ClusterApi methods.
//
//
//  Documentation:
//
//  Maintained By:
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "CBaseInfo.h"

DEFINE_THISCLASS("CBaseInfo")


CBaseInfo::CBaseInfo( void )
{
    m_pICHProvider = NULL;
}

CBaseInfo::~CBaseInfo( void )
{
    TraceFunc( "" );

    Close();

    if ( m_pICHProvider )
    {
        m_pICHProvider->Release();
    } // if:

    TraceFuncExit();
}

HRESULT CBaseInfo::Close( void )
{
    return S_FALSE;
}

HCLUSTER CBaseInfo::getClusterHandle( void )
{
    HCLUSTER hCluster = NULL;

    if ( m_pICHProvider != NULL )
    {
        m_pICHProvider->GetClusterHandle( & hCluster );
    }

    return hCluster;
}

HRESULT CBaseInfo::SetClusterHandleProvider( IClusterHandleProvider * pICHPIn )
{
    TraceFunc( "" );
    Assert( m_pICHProvider == NULL );
    Assert( pICHPIn != NULL );

    m_pICHProvider = pICHPIn;
    m_pICHProvider->AddRef();

    Assert( m_pICHProvider == pICHPIn );

    HRETURN( S_OK );
}

HRESULT CBaseInfo::GetPropertyStringValue(
    CtlCodeEnum     cceIn,
    const WCHAR *   pszPropertyIn,
    BSTR *          pbstrResultOut
    )
{
    TraceFunc( "" );
    Assert( pbstrResultOut != NULL );
    Assert( pszPropertyIn != NULL );

    DWORD           sc;
    HRESULT         hr = S_OK;
    CBasePropList   cpl;

    sc = TW32( cpl.ScGetProperties( *this, ToCode( cceIn ) ) );
    if ( sc == ERROR_SUCCESS )
    {
        hr = THR( GetPropertyStringHelper( cpl, pszPropertyIn, pbstrResultOut ) );
    }
    else
    {
        hr = HRESULT_FROM_WIN32( sc );
    }

    HRETURN( hr );

}

HRESULT CBaseInfo::GetPropertyStringHelper(
    CBasePropList & cplIn,
    const WCHAR *   pszPropertyIn,
    BSTR *          pbstrResultOut
    )
{
    TraceFunc( "" );
    Assert( pbstrResultOut != NULL );
    Assert( pszPropertyIn != NULL );

    DWORD                   sc;
    HRESULT                 hr = S_OK;
    CLUSPROP_BUFFER_HELPER  cpbh;

    sc = TW32( cplIn.ScMoveToPropertyByName( pszPropertyIn ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Exit;
    } // if:

    cpbh = cplIn.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    *pbstrResultOut = TraceSysAllocString( cpbh.pStringValue->sz );
    if ( *pbstrResultOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
    } // if:

Exit:
    HRETURN( hr );
}

HRESULT CBaseInfo::GetPropertyDwordValue(
    CtlCodeEnum     cceIn,
    const WCHAR *   pszPropertyIn,
    DWORD *         pdwValueOut
    )
{
    TraceFunc( "" );
    Assert( pdwValueOut != NULL );
    Assert( pszPropertyIn != NULL );

    DWORD           sc;
    HRESULT         hr = S_OK;
    CBasePropList   cpl;

    sc = TW32( cpl.ScGetProperties( *this, ToCode( cceIn ) ) );
    if ( sc == ERROR_SUCCESS )
    {
        hr = THR( GetPropertyDwordHelper( cpl, pszPropertyIn, pdwValueOut ) );
    }
    else
    {
        hr = HRESULT_FROM_WIN32( sc );
    }

    HRETURN( hr );

}

HRESULT CBaseInfo::GetPropertyDwordHelper(
    CBasePropList & cplIn,
    const WCHAR *   pszPropertyIn,
    DWORD *         pdwValueOut
    )
{
    TraceFunc( "" );
    Assert( pdwValueOut != NULL );
    Assert( pszPropertyIn != NULL );

    DWORD                   sc;
    HRESULT                 hr = S_OK;
    CLUSPROP_BUFFER_HELPER  cpbh;

    sc = TW32( cplIn.ScMoveToPropertyByName( pszPropertyIn ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Exit;
    }

    cpbh = cplIn.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_DWORD );

    *pdwValueOut = cpbh.pDwordValue->dw;

Exit:

    HRETURN( hr );

}

//////////////////////////////////////////////////////////////////////////////
// CBaseClusterInfo
//////////////////////////////////////////////////////////////////////////////
HRESULT CBaseClusterInfo::Close( void )
{
    return S_FALSE;
}

HRESULT CBaseClusterInfo::Open( BSTR bstrNameIn )
{
    TraceFunc( "" );

    HRESULT                     hr = S_FALSE;
    HCLUSTER                    hCluster = getClusterHandle();
    IUnknown *                  punk          = NULL;
    IClusterHandleProvider *    piCHProvider  = NULL;

    if ( hCluster == NULL )
    {
        CHandleProvider::S_HrCreateInstance( &punk );

        hr = punk->TypeSafeQI( IClusterHandleProvider, &piCHProvider );
        if ( SUCCEEDED( hr ))
        {
            hr = piCHProvider->OpenCluster( bstrNameIn );
            if ( SUCCEEDED( hr ) )
            {
                hr = SetClusterHandleProvider( piCHProvider );
            }
        }
    }

    if ( punk )
    {
        punk->Release();
    }

    if ( piCHProvider )
    {
        piCHProvider->Release();
    }

    HRETURN( hr );
}

DWORD CBaseClusterInfo::Control(
    DWORD   dwEnum,
    VOID *  pvBufferIn,
    DWORD   dwLengthIn,
    VOID *  pvBufferOut,
    DWORD   dwBufferLength,
    DWORD * pdwLengthOut,
    HNODE   hHostNode
    )
{
    TraceFunc( "" );

    DWORD       sc;
    HCLUSTER    hCluster = getClusterHandle();

    if ( hCluster == NULL )
    {
        sc = TW32( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    sc = ClusterControl( hCluster, hHostNode, dwEnum, pvBufferIn, dwLengthIn, pvBufferOut, dwBufferLength, pdwLengthOut );
    if ( ( sc != ERROR_MORE_DATA ) && ( sc != ERROR_SUCCESS ) )
    {
        TW32( sc );
    } // if:

Exit:

    RETURN( sc );

}

//////////////////////////////////////////////////////////////////////////////
// CBaseClusterGroupInfo
//////////////////////////////////////////////////////////////////////////////
HRESULT CBaseClusterGroupInfo::Close( )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;

    if ( m_hGroup )
    {
        hr = S_OK;
        CloseClusterGroup( m_hGroup );
    }

    HRETURN( hr );

}

HRESULT CBaseClusterGroupInfo::Open( BSTR bstrGroupName )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    HCLUSTER  hCluster = getClusterHandle();
    if ( hCluster == NULL )
    {
        hr = THR( E_FAIL );
        goto Exit;
    }

    m_hGroup = OpenClusterGroup( hCluster, bstrGroupName );
    if ( m_hGroup == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
    }

Exit:

    HRETURN( hr );

}

DWORD CBaseClusterGroupInfo::Control(
    DWORD   dwEnum,
    VOID *  pvBufferIn,
    DWORD   dwLengthIn,
    VOID *  pvBufferOut,
    DWORD   dwBufferLength,
    DWORD * pdwLengthOut,
    HNODE   hHostNode
    )
{
    TraceFunc( "" );

    DWORD   sc;

    if ( m_hGroup == NULL )
    {
        sc = TW32( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    sc = ClusterGroupControl( m_hGroup , hHostNode, dwEnum, pvBufferIn, dwLengthIn, pvBufferOut, dwBufferLength, pdwLengthOut );
    if ( ( sc != ERROR_MORE_DATA ) && ( sc != ERROR_SUCCESS ) )
    {
        TW32( sc );
    } // if:

Exit:

    RETURN( sc );

}


//////////////////////////////////////////////////////////////////////////////
// CBaseClusterGroupInfo
//////////////////////////////////////////////////////////////////////////////
HRESULT CBaseClusterResourceInfo::Close( void )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;

    if ( m_hResource )
    {
        hr = S_OK;
        CloseClusterResource( m_hResource );
    }

    HRETURN( hr );

}

HRESULT CBaseClusterResourceInfo::Open( BSTR bstrResourceName )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    HCLUSTER  hCluster = getClusterHandle();
    if ( hCluster == NULL )
    {
        hr = THR( E_FAIL );
        goto Exit;
    }

    m_hResource = OpenClusterResource( hCluster, bstrResourceName );
    if ( m_hResource == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
    }

Exit:

    HRETURN( hr );

}

DWORD CBaseClusterResourceInfo::Control(
    DWORD   dwEnum,
    VOID *  pvBufferIn,
    DWORD   dwLengthIn,
    VOID *  pvBufferOut,
    DWORD   dwBufferLength,
    DWORD * pdwLengthOut,
    HNODE   hHostNode
    )
{
    TraceFunc( "" );

    DWORD   sc;

    if ( m_hResource == NULL )
    {
        sc = TW32( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    sc = ClusterResourceControl( m_hResource, hHostNode, dwEnum, pvBufferIn, dwLengthIn, pvBufferOut, dwBufferLength, pdwLengthOut );
    if ( ( sc != ERROR_MORE_DATA ) && ( sc != ERROR_SUCCESS ) )
    {
        TW32( sc );
    } // if:

Exit:

    RETURN( sc );

}


//////////////////////////////////////////////////////////////////////////////
// CBaseClusterGroupInfo
//////////////////////////////////////////////////////////////////////////////
HRESULT CBaseClusterNodeInfo::Close( void )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;

    if ( m_hNode )
    {
        hr = S_OK;
        CloseClusterNode( m_hNode );
    }

    HRETURN( hr );

}

HRESULT CBaseClusterNodeInfo::Open( BSTR bstrNodeName )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    HCLUSTER  hCluster = getClusterHandle();
    if ( hCluster == NULL )
    {
        hr = THR( E_FAIL );
        goto Exit;
    }

    m_hNode = OpenClusterNode( hCluster, bstrNodeName );
    if ( m_hNode == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
    }

Exit:

    HRETURN( hr );

}

DWORD CBaseClusterNodeInfo::Control(
    DWORD   dwEnum,
    VOID *  pvBufferIn,
    DWORD   dwLengthIn,
    VOID *  pvBufferOut,
    DWORD   dwBufferLength,
    DWORD * pdwLengthOut,
    HNODE   hHostNode
    )
{
    TraceFunc( "" );

    DWORD   sc;

    if ( m_hNode == NULL )
    {
        sc = TW32( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    sc = ClusterNodeControl( m_hNode, hHostNode, dwEnum, pvBufferIn, dwLengthIn, pvBufferOut, dwBufferLength, pdwLengthOut );
    if ( ( sc != ERROR_MORE_DATA ) && ( sc != ERROR_SUCCESS ) )
    {
        TW32( sc );
    } // if:

Exit:

    RETURN( sc );

}


//////////////////////////////////////////////////////////////////////////////
// CBaseClusterGroupInfo
//////////////////////////////////////////////////////////////////////////////
HRESULT CBaseClusterNetworkInfo::Close( void  )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;

    if ( m_hNetwork )
    {
        hr = S_OK;
        CloseClusterNetwork( m_hNetwork );
    }

    HRETURN( hr );

}


HRESULT CBaseClusterNetworkInfo::Open( BSTR bstrNetworkName )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    HCLUSTER  hCluster = getClusterHandle();
    if ( hCluster == NULL )
    {
        hr = THR( E_FAIL );
        goto Exit;
    }

    m_hNetwork = OpenClusterNetwork( hCluster, bstrNetworkName );
    if ( m_hNetwork == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
    }

Exit:

    HRETURN( hr );

}

DWORD CBaseClusterNetworkInfo::Control(
    DWORD   dwEnum,
    VOID *  pvBufferIn,
    DWORD   dwLengthIn,
    VOID *  pvBufferOut,
    DWORD   dwBufferLength,
    DWORD * pdwLengthOut,
    HNODE   hHostNode
    )
{
    TraceFunc( "" );

    DWORD   sc;

    if ( m_hNetwork == NULL )
    {
        sc = TW32( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    sc = ClusterNetworkControl( m_hNetwork, hHostNode, dwEnum, pvBufferIn, dwLengthIn, pvBufferOut, dwBufferLength, pdwLengthOut );
    if ( ( sc != ERROR_MORE_DATA ) && ( sc != ERROR_SUCCESS ) )
    {
        TW32( sc );
    } // if:

Exit:

    RETURN( sc );

}


//////////////////////////////////////////////////////////////////////////////
// CBaseClusterGroupInfo
//////////////////////////////////////////////////////////////////////////////
HRESULT CBaseClusterNetInterfaceInfo::Close( void )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;

    if ( m_hNetworkInterface )
    {
        hr = S_OK;
        CloseClusterNetInterface( m_hNetworkInterface );
    }

    HRETURN( hr );

}

HRESULT CBaseClusterNetInterfaceInfo::Open( BSTR bstrNetworkInterfaceName )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    HCLUSTER  hCluster = getClusterHandle();

    if ( hCluster == NULL )
    {
        hr = THR( E_FAIL );
        goto Exit;
    }

    m_hNetworkInterface = OpenClusterNetInterface( hCluster, bstrNetworkInterfaceName );
    if ( m_hNetworkInterface == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
    }

Exit:

    HRETURN( hr );

}

DWORD CBaseClusterNetInterfaceInfo::Control(
    DWORD   dwEnum,
    VOID *  pvBufferIn,
    DWORD   dwLengthIn,
    VOID *  pvBufferOut,
    DWORD   dwBufferLength,
    DWORD * pdwLengthOut,
    HNODE   hHostNode
    )
{
    TraceFunc( "" );

    DWORD   sc;

    if ( m_hNetworkInterface == NULL )
    {
        sc = TW32( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    sc = ClusterNetInterfaceControl( m_hNetworkInterface, hHostNode, dwEnum, pvBufferIn, dwLengthIn, pvBufferOut, dwBufferLength, pdwLengthOut );
    if ( ( sc != ERROR_MORE_DATA ) && ( sc != ERROR_SUCCESS ) )
    {
        TW32( sc );
    } // if:

Exit:

    RETURN( sc );

}



//////////////////////////////////////////////////////////////////////////////
// ToCode
//
//  These methods translate the CtlCodeEnums to the appropriate control code
//  for each class.
//
//
/////////////////////////////////////////////////////////////////

 DWORD CBaseClusterInfo::ToCode( CtlCodeEnum cceIn )
{
    TraceFunc( "" );

    DWORD dwResult = 0;

    switch( cceIn )
    {
    case CONTROL_UNKNOWN:
        dwResult = CLUSCTL_CLUSTER_UNKNOWN;
        break;

    case CONTROL_VALIDATE_COMMON_PROPERTIES:
        dwResult = CLUSCTL_CLUSTER_VALIDATE_COMMON_PROPERTIES;
        break;
    case CONTROL_VALIDATE_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_CLUSTER_VALIDATE_PRIVATE_PROPERTIES;
        break;
    case CONTROL_ENUM_COMMON_PROPERTIES:
        dwResult = CLUSCTL_CLUSTER_ENUM_COMMON_PROPERTIES;
        break;
    case CONTROL_ENUM_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_CLUSTER_ENUM_PRIVATE_PROPERTIES;
        break;
    case CONTROL_GET_RO_COMMON_PROPERTIES:
        dwResult = CLUSCTL_CLUSTER_GET_RO_COMMON_PROPERTIES;
        break;
    case CONTROL_GET_RO_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_CLUSTER_GET_RO_PRIVATE_PROPERTIES;
        break;
    case CONTROL_GET_COMMON_PROPERTIES:
        dwResult = CLUSCTL_CLUSTER_GET_COMMON_PROPERTIES;
        break;
    case CONTROL_GET_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_CLUSTER_GET_PRIVATE_PROPERTIES;
        break;
    case CONTROL_SET_COMMON_PROPERTIES:
        dwResult = CLUSCTL_CLUSTER_SET_COMMON_PROPERTIES;
        break;
    case CONTROL_SET_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_CLUSTER_SET_PRIVATE_PROPERTIES;
        break;

    case CONTROL_GET_TYPE:
    case CONTROL_GET_NAME:
    case CONTROL_GET_ID:
    case CONTROL_GET_FLAGS:
    case CONTROL_GET_CLASS_INFO:
    case CONTROL_GET_NETWORK_NAME:
    case CONTROL_GET_CHARACTERISTICS:
    case CONTROL_GET_REQUIRED_DEPENDENCIES:

    case CONTROL_STORAGE_GET_DISK_INFO:
    case CONTROL_STORAGE_IS_PATH_VALID:
    case CONTROL_STORAGE_GET_AVAILABLE_DISKS:
    case CONTROL_QUERY_DELETE:

    case CONTROL_ADD_CRYPTO_CHECKPOINT:
    case CONTROL_ADD_REGISTRY_CHECKPOINT:
    case CONTROL_GET_REGISTRY_CHECKPOINTS:
    case CONTROL_GET_CRYPTO_CHECKPOINTS:
    case CONTROL_DELETE_CRYPTO_CHECKPOINT:
    case CONTROL_DELETE_REGISTRY_CHECKPOINT:
    default:
        dwResult = 0;
    }

    RETURN( dwResult );

}

 DWORD CBaseClusterGroupInfo::ToCode( CtlCodeEnum cceIn )
{
    TraceFunc( "" );

    DWORD dwResult = 0;

    switch( cceIn )
    {
    case CONTROL_UNKNOWN:
        dwResult = CLUSCTL_GROUP_UNKNOWN;
        break;

    case CONTROL_VALIDATE_COMMON_PROPERTIES:
        dwResult = CLUSCTL_GROUP_VALIDATE_COMMON_PROPERTIES;
        break;
    case CONTROL_VALIDATE_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_GROUP_VALIDATE_PRIVATE_PROPERTIES;
        break;
    case CONTROL_ENUM_COMMON_PROPERTIES:
        dwResult = CLUSCTL_GROUP_ENUM_COMMON_PROPERTIES;
        break;
    case CONTROL_ENUM_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_GROUP_ENUM_PRIVATE_PROPERTIES;
        break;
    case CONTROL_GET_RO_COMMON_PROPERTIES:
        dwResult = CLUSCTL_GROUP_GET_RO_COMMON_PROPERTIES;
        break;
    case CONTROL_GET_RO_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_GROUP_GET_RO_PRIVATE_PROPERTIES;
        break;
    case CONTROL_GET_COMMON_PROPERTIES:
        dwResult = CLUSCTL_GROUP_GET_COMMON_PROPERTIES;
        break;
    case CONTROL_GET_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES;
        break;
    case CONTROL_SET_COMMON_PROPERTIES:
        dwResult = CLUSCTL_GROUP_SET_COMMON_PROPERTIES;
        break;
    case CONTROL_SET_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES;
        break;

    case CONTROL_GET_NAME:
        dwResult = CLUSCTL_GROUP_GET_NAME;
        break;
    case CONTROL_GET_ID:
        dwResult = CLUSCTL_GROUP_GET_ID;
        break;
    case CONTROL_GET_FLAGS:
        dwResult = CLUSCTL_GROUP_GET_FLAGS;
        break;
    case CONTROL_GET_CHARACTERISTICS:
        dwResult = CLUSCTL_GROUP_GET_CHARACTERISTICS;
        break;
    case CONTROL_QUERY_DELETE:
        dwResult = CLUSCTL_GROUP_QUERY_DELETE;
        break;


    case CONTROL_GET_CLASS_INFO:
    case CONTROL_GET_NETWORK_NAME:
    case CONTROL_GET_TYPE:
    case CONTROL_GET_REQUIRED_DEPENDENCIES:

    case CONTROL_STORAGE_GET_DISK_INFO:
    case CONTROL_STORAGE_IS_PATH_VALID:
    case CONTROL_STORAGE_GET_AVAILABLE_DISKS:

    case CONTROL_ADD_CRYPTO_CHECKPOINT:
    case CONTROL_ADD_REGISTRY_CHECKPOINT:
    case CONTROL_GET_REGISTRY_CHECKPOINTS:
    case CONTROL_GET_CRYPTO_CHECKPOINTS:
    case CONTROL_DELETE_CRYPTO_CHECKPOINT:
    case CONTROL_DELETE_REGISTRY_CHECKPOINT:
    default:
        dwResult = 0;
    }


    RETURN( dwResult );

}

 DWORD CBaseClusterResourceInfo::ToCode( CtlCodeEnum cceIn )
{
    TraceFunc( "" );

    DWORD dwResult = 0;

    switch( cceIn )
    {
    case CONTROL_UNKNOWN:
        dwResult = CLUSCTL_RESOURCE_UNKNOWN;
        break;

    case CONTROL_VALIDATE_COMMON_PROPERTIES:
        dwResult = CLUSCTL_RESOURCE_VALIDATE_COMMON_PROPERTIES;
        break;
    case CONTROL_VALIDATE_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES;
        break;
    case CONTROL_ENUM_COMMON_PROPERTIES:
        dwResult = CLUSCTL_RESOURCE_ENUM_COMMON_PROPERTIES;
        break;
    case CONTROL_ENUM_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES;
        break;
    case CONTROL_GET_RO_COMMON_PROPERTIES:
        dwResult = CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES;
        break;
    case CONTROL_GET_RO_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_RESOURCE_GET_RO_PRIVATE_PROPERTIES;
        break;
    case CONTROL_GET_COMMON_PROPERTIES:
        dwResult = CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES;
        break;
    case CONTROL_GET_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES;
        break;
    case CONTROL_SET_COMMON_PROPERTIES:
        dwResult = CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES;
        break;
    case CONTROL_SET_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES;
        break;

    case CONTROL_GET_TYPE:
        dwResult = CLUSCTL_RESOURCE_GET_RESOURCE_TYPE;
        break;
    case CONTROL_GET_NAME:
        dwResult = CLUSCTL_RESOURCE_GET_NAME;
        break;
    case CONTROL_GET_ID:
        dwResult = CLUSCTL_RESOURCE_GET_ID;
        break;
    case CONTROL_GET_FLAGS:
        dwResult = CLUSCTL_RESOURCE_GET_FLAGS;
        break;
    case CONTROL_GET_CLASS_INFO:
        dwResult = CLUSCTL_RESOURCE_GET_CLASS_INFO;
        break;
    case CONTROL_GET_NETWORK_NAME:
        dwResult = CLUSCTL_RESOURCE_GET_NETWORK_NAME;
        break;
    case CONTROL_GET_CHARACTERISTICS:
        dwResult = CLUSCTL_RESOURCE_GET_CHARACTERISTICS;
        break;
    case CONTROL_GET_REQUIRED_DEPENDENCIES:
        dwResult = CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES;
        break;

    case CONTROL_ADD_CRYPTO_CHECKPOINT:
        dwResult = CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT;
        break;
    case CONTROL_ADD_REGISTRY_CHECKPOINT:
        dwResult = CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT;
        break;
    case CONTROL_GET_REGISTRY_CHECKPOINTS:
        dwResult = CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS;
        break;
    case CONTROL_GET_CRYPTO_CHECKPOINTS:
        dwResult = CLUSCTL_RESOURCE_GET_CRYPTO_CHECKPOINTS;
        break;
    case CONTROL_DELETE_CRYPTO_CHECKPOINT:
        dwResult = CLUSCTL_RESOURCE_DELETE_CRYPTO_CHECKPOINT;
        break;
    case CONTROL_DELETE_REGISTRY_CHECKPOINT:
        dwResult = CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT;
        break;

    case CONTROL_STORAGE_GET_DISK_INFO:
        dwResult = CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO;
        break;
    case CONTROL_STORAGE_IS_PATH_VALID:
        dwResult = CLUSCTL_RESOURCE_STORAGE_IS_PATH_VALID;
        break;
    case CONTROL_QUERY_DELETE:
        dwResult = CLUSCTL_RESOURCE_QUERY_DELETE;
        break;

    case CONTROL_STORAGE_GET_AVAILABLE_DISKS:
    default:
        dwResult = 0;
    }


    RETURN( dwResult );

}


DWORD
CBaseClusterNodeInfo::ToCode( CtlCodeEnum cceIn )
{
    TraceFunc( "" );

    DWORD dwResult = 0;

    switch( cceIn )
    {
    case CONTROL_UNKNOWN:
        dwResult = CLUSCTL_NODE_UNKNOWN;
        break;

    case CONTROL_VALIDATE_COMMON_PROPERTIES:
        dwResult = CLUSCTL_NODE_VALIDATE_COMMON_PROPERTIES;
        break;
    case CONTROL_VALIDATE_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_NODE_VALIDATE_PRIVATE_PROPERTIES;
        break;
    case CONTROL_ENUM_COMMON_PROPERTIES:
        dwResult = CLUSCTL_NODE_ENUM_COMMON_PROPERTIES;
        break;
    case CONTROL_ENUM_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_NODE_ENUM_PRIVATE_PROPERTIES;
        break;
    case CONTROL_GET_RO_COMMON_PROPERTIES:
        dwResult = CLUSCTL_NODE_GET_RO_COMMON_PROPERTIES;
        break;
    case CONTROL_GET_RO_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_NODE_GET_RO_PRIVATE_PROPERTIES;
        break;
    case CONTROL_GET_COMMON_PROPERTIES:
        dwResult = CLUSCTL_NODE_GET_COMMON_PROPERTIES;
        break;
    case CONTROL_GET_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_NODE_GET_PRIVATE_PROPERTIES;
        break;
    case CONTROL_SET_COMMON_PROPERTIES:
        dwResult = CLUSCTL_NODE_SET_COMMON_PROPERTIES;
        break;
    case CONTROL_SET_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_NODE_SET_PRIVATE_PROPERTIES;
        break;

    case CONTROL_GET_NAME:
        dwResult = CLUSCTL_NODE_GET_NAME;
        break;
    case CONTROL_GET_ID:
        dwResult = CLUSCTL_NODE_GET_ID;
        break;
    case CONTROL_GET_FLAGS:
        dwResult = CLUSCTL_NODE_GET_FLAGS;
        break;
    case CONTROL_GET_CHARACTERISTICS:
        dwResult = CLUSCTL_NODE_GET_CHARACTERISTICS;
        break;

    case CONTROL_GET_TYPE:
    case CONTROL_GET_CLASS_INFO:
    case CONTROL_GET_NETWORK_NAME:
    case CONTROL_GET_REQUIRED_DEPENDENCIES:

    case CONTROL_STORAGE_GET_DISK_INFO:
    case CONTROL_STORAGE_IS_PATH_VALID:
    case CONTROL_STORAGE_GET_AVAILABLE_DISKS:
    case CONTROL_QUERY_DELETE:

    case CONTROL_ADD_CRYPTO_CHECKPOINT:
    case CONTROL_ADD_REGISTRY_CHECKPOINT:
    case CONTROL_GET_REGISTRY_CHECKPOINTS:
    case CONTROL_GET_CRYPTO_CHECKPOINTS:
    case CONTROL_DELETE_CRYPTO_CHECKPOINT:
    case CONTROL_DELETE_REGISTRY_CHECKPOINT:
    default:
        dwResult = 0;
    }


    RETURN( dwResult );

}

DWORD
CBaseClusterNetworkInfo::ToCode( CtlCodeEnum cceIn )
{
    TraceFunc( "" );

    DWORD dwResult = 0;

    switch( cceIn )
    {
    case CONTROL_UNKNOWN:
        dwResult = CLUSCTL_NETWORK_UNKNOWN;
        break;

    case CONTROL_VALIDATE_COMMON_PROPERTIES:
        dwResult = CLUSCTL_NETWORK_VALIDATE_COMMON_PROPERTIES;
        break;
    case CONTROL_VALIDATE_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_NETWORK_VALIDATE_PRIVATE_PROPERTIES;
        break;
    case CONTROL_ENUM_COMMON_PROPERTIES:
        dwResult = CLUSCTL_NETWORK_ENUM_COMMON_PROPERTIES;
        break;
    case CONTROL_ENUM_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_NETWORK_ENUM_PRIVATE_PROPERTIES;
        break;
    case CONTROL_GET_RO_COMMON_PROPERTIES:
        dwResult = CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES;
        break;
    case CONTROL_GET_RO_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_NETWORK_GET_RO_PRIVATE_PROPERTIES;
        break;
    case CONTROL_GET_COMMON_PROPERTIES:
        dwResult = CLUSCTL_NETWORK_GET_COMMON_PROPERTIES;
        break;
    case CONTROL_GET_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_NETWORK_GET_PRIVATE_PROPERTIES;
        break;
    case CONTROL_SET_COMMON_PROPERTIES:
        dwResult = CLUSCTL_NETWORK_SET_COMMON_PROPERTIES;
        break;
    case CONTROL_SET_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_NETWORK_SET_PRIVATE_PROPERTIES;
        break;

    case CONTROL_GET_NAME:
        dwResult = CLUSCTL_NETWORK_GET_NAME;
        break;
    case CONTROL_GET_ID:
        dwResult = CLUSCTL_NETWORK_GET_ID;
        break;
    case CONTROL_GET_FLAGS:
        dwResult = CLUSCTL_NETWORK_GET_FLAGS;
        break;
    case CONTROL_GET_CHARACTERISTICS:
        dwResult = CLUSCTL_NETWORK_GET_CHARACTERISTICS;
        break;

    case CONTROL_GET_TYPE:
    case CONTROL_GET_CLASS_INFO:
    case CONTROL_GET_NETWORK_NAME:
    case CONTROL_GET_REQUIRED_DEPENDENCIES:

    case CONTROL_STORAGE_GET_DISK_INFO:
    case CONTROL_STORAGE_IS_PATH_VALID:
    case CONTROL_STORAGE_GET_AVAILABLE_DISKS:
    case CONTROL_QUERY_DELETE:

    case CONTROL_ADD_CRYPTO_CHECKPOINT:
    case CONTROL_ADD_REGISTRY_CHECKPOINT:
    case CONTROL_GET_REGISTRY_CHECKPOINTS:
    case CONTROL_GET_CRYPTO_CHECKPOINTS:
    case CONTROL_DELETE_CRYPTO_CHECKPOINT:
    case CONTROL_DELETE_REGISTRY_CHECKPOINT:
    default:
        dwResult = 0;
    }


    RETURN( dwResult );
}

DWORD
CBaseClusterNetInterfaceInfo::ToCode( CtlCodeEnum cceIn )
{
    TraceFunc( "" );

    DWORD dwResult = 0;

    switch( cceIn )
    {
    case CONTROL_UNKNOWN:
        dwResult = CLUSCTL_NETINTERFACE_UNKNOWN;
        break;

    case CONTROL_VALIDATE_COMMON_PROPERTIES:
        dwResult = CLUSCTL_NETINTERFACE_VALIDATE_COMMON_PROPERTIES;
        break;
    case CONTROL_VALIDATE_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_NETINTERFACE_VALIDATE_PRIVATE_PROPERTIES;
        break;
    case CONTROL_ENUM_COMMON_PROPERTIES:
        dwResult = CLUSCTL_NETINTERFACE_ENUM_COMMON_PROPERTIES;
        break;
    case CONTROL_ENUM_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_NETINTERFACE_ENUM_PRIVATE_PROPERTIES;
        break;
    case CONTROL_GET_RO_COMMON_PROPERTIES:
        dwResult = CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES;
        break;
    case CONTROL_GET_RO_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_NETINTERFACE_GET_RO_PRIVATE_PROPERTIES;
        break;
    case CONTROL_GET_COMMON_PROPERTIES:
        dwResult = CLUSCTL_NETINTERFACE_GET_COMMON_PROPERTIES;
        break;
    case CONTROL_GET_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES;
        break;
    case CONTROL_SET_COMMON_PROPERTIES:
        dwResult = CLUSCTL_NETINTERFACE_SET_COMMON_PROPERTIES;
        break;
    case CONTROL_SET_PRIVATE_PROPERTIES:
        dwResult = CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES;
        break;

    case CONTROL_GET_NAME:
        dwResult = CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES;
        break;
    case CONTROL_GET_ID:
        dwResult = CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES;
        break;
    case CONTROL_GET_FLAGS:
        dwResult = CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES;
        break;
    case CONTROL_GET_CHARACTERISTICS:
        dwResult = CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES;
        break;

    case CONTROL_GET_CLASS_INFO:
    case CONTROL_GET_NETWORK_NAME:
    case CONTROL_GET_REQUIRED_DEPENDENCIES:
    case CONTROL_GET_TYPE:

    case CONTROL_STORAGE_GET_DISK_INFO:
    case CONTROL_STORAGE_IS_PATH_VALID:
    case CONTROL_STORAGE_GET_AVAILABLE_DISKS:
    case CONTROL_QUERY_DELETE:

    case CONTROL_ADD_CRYPTO_CHECKPOINT:
    case CONTROL_ADD_REGISTRY_CHECKPOINT:
    case CONTROL_GET_REGISTRY_CHECKPOINTS:
    case CONTROL_GET_CRYPTO_CHECKPOINTS:
    case CONTROL_DELETE_CRYPTO_CHECKPOINT:
    case CONTROL_DELETE_REGISTRY_CHECKPOINT:
    default:
        dwResult = 0;
    }


    RETURN( dwResult );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\common\ccluscfgcredentials.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgCredentials.h
//
//  Description:
//      This file contains the declaration of the CClusCfgCredentials
//      class.
//
//      The class CClusCfgCredentials is the representation of
//      account credentials. It implements the IClusCfgCredentials interface.
//
//  Documentation:
//
//  Implementation Files:
//      CClusCfgCredentials.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 17-May-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgCredentials
//
//  Description:
//      The class CClusCfgCredentials is the representation of a
//      cluster.
//
//  Interfaces:
//      IClusCfgCredentials
//      IClusCfgInitialize
//      IClusCfgSetCredentials
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgCredentials
    : public IClusCfgCredentials
    , public IClusCfgInitialize
    , public IClusCfgSetCredentials
{
public:
    //
    // Public constructors and destructors
    //

    CClusCfgCredentials( void );
    virtual ~CClusCfgCredentials( void );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces.
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgCredentials Interfaces.
    //

    STDMETHOD( SetCredentials )( LPCWSTR pcszUserIn, LPCWSTR pcszDomainIn, LPCWSTR pcszPasswordIn );

    STDMETHOD( GetCredentials )( BSTR * pbstrUserOut, BSTR * pbstrDomainOut, BSTR * pbstrPasswordOut );

    //
    // IClusCfgSetCredentials Interfaces.
    //

    STDMETHOD( SetDomainCredentials )( LPCWSTR pcszCredentials );

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

private:

    struct AccountInfo
    {
        BSTR bstrName;
        BSTR bstrPassword;
        BSTR bstrDomain;
    };

    //
    // Private member functions and data
    //

    LONG                    m_cRef;
    LCID                    m_lcid;
    IClusCfgCallback *      m_picccCallback;
    struct AccountInfo      m_aiInfo;

    // Private copy constructor to prevent copying.
    CClusCfgCredentials( const CClusCfgCredentials & nodeSrc );

    // Private assignment operator to prevent copying.
    const CClusCfgCredentials & operator = ( const CClusCfgCredentials & nodeSrc );

    HRESULT HrInit( void );

}; //*** Class CClusCfgCredentials
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\common\chandleprovider.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CHandleProvider.h
//
//  Description:
//      HandleProvider definition.
//
//  Implementation:
//      CHandleProvider.cpp
//
//  Maintained By:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CHandleProvider :
    public IClusterHandleProvider
{
private:
    // IUnknown
    LONG                m_cRef;

    // IClusterHandleProvider
    HCLUSTER            m_hCluster;
    BSTR                m_bstrClusterName;

public:
    CHandleProvider();
    ~CHandleProvider();

    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );
    
    // IClusterHandleProvider
    STDMETHOD( OpenCluster )( BSTR bstrClusterName );
    STDMETHOD( GetClusterHandle )( HCLUSTER * pphClusterHandleOut );
    
    STDMETHOD( Init )( void );  
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\common\ccluscfgcredentials.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgCredentials.cpp
//
//  Description:
//      This file contains the definition of the CClusCfgCredentials
//      class.
//
//      The class CClusCfgCredentials is the representation of
//      account credentials. It implements the IClusCfgCredentials interface.
//
//  Documentation:
//
//  Header File:
//      CClusCfgCredentials.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 17-May-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CClusCfgCredentials.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusCfgCredentials" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCredentials class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::S_HrCreateInstance()
//
//  Description:
//      Create a CClusCfgCredentials instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CClusCfgCredentials instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCredentials::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr;
    CClusCfgCredentials *   lpccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Exit;
    } // if:

    lpccs = new CClusCfgCredentials();
    if ( lpccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Exit;
    } // if: error allocating object

    hr = THR( lpccs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Exit;
    } // if: HrInit() failed

    hr = THR( lpccs->TypeSafeQI( IUnknown, ppunkOut ) );

Exit:

    if ( FAILED( hr ) )
    {
        LogMsg( L"Server: CClusCfgCredentials::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( lpccs != NULL )
    {
        lpccs->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgCredentials::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::CClusCfgCredentials()
//
//  Description:
//      Constructor of the CClusCfgCredentials class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgCredentials::CClusCfgCredentials( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_aiInfo.bstrName == NULL );
    Assert( m_aiInfo.bstrPassword == NULL );
    Assert( m_aiInfo.bstrDomain == NULL );

    Assert( m_picccCallback == NULL );

    TraceFuncExit();

} //*** CClusCfgCredentials::CClusCfgCredentials


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::~CClusCfgCredentials()
//
//  Description:
//      Desstructor of the CClusCfgCredentials class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgCredentials::~CClusCfgCredentials( void )
{
    TraceFunc( "" );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    TraceSysFreeString( m_aiInfo.bstrName );
    TraceSysFreeString( m_aiInfo.bstrPassword );
    TraceSysFreeString( m_aiInfo.bstrDomain );

    TraceFuncExit();

} //*** CClusCfgCredentials::~CClusCfgCredentials


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterConfiguration -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusCfgCredentials:: [IUNKNOWN] AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgCredentials::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CClusCfgCredentials::AddRef()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusCfgCredentials:: [IUNKNOWN] Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgCredentials::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef > 0 )
    {
        RETURN( m_cRef );
    } // if: reference count greater than zero

    TraceDo( delete this );

    RETURN( 0 );

} //*** CClusCfgCredentials::Release()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials:: [INKNOWN] QueryInterface()
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCredentials::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IClusCfgCredentials * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgCredentials ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgCredentials, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgSetCredentials ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgSetCredentials, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN_IGNORESTDMARSHALLING1( hr, riid, IID_IClusCfgWbemServices );

} //*** CClusCfgCredentials::QueryInterface()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCredentials -- IClusCfgInitialze interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::Initialize()
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCredentials::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    Assert( m_picccCallback == NULL );

    if ( punkCallbackIn != NULL )
    {
        hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );
    } // if:

    HRETURN( hr );

} //*** CClusCfgCredentials::Initialize()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCredentials -- IClusCfgCredentials interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::GetCredentials()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCredentials::GetCredentials(
    BSTR * pbstrNameOut,
    BSTR * pbstrDomainOut,
    BSTR * pbstrPasswordOut
    )
{
    TraceFunc( "[IClusCfgCredentials]" );

    HRESULT hr;

    //
    //  Only return the requested parameters. If an argument is NULL,
    //  that means the caller did not want to retrieve that piece of
    //  information.
    //

    if ( pbstrNameOut != NULL )
    {
        *pbstrNameOut = SysAllocString( m_aiInfo.bstrName );
        if ( ( *pbstrNameOut == NULL ) && ( m_aiInfo.bstrName != NULL ) )
        {
            goto OutOfMemory;
        } // if:

    } // if:

    if ( pbstrPasswordOut != NULL )
    {
        *pbstrPasswordOut = SysAllocString( m_aiInfo.bstrPassword );
        if ( ( *pbstrPasswordOut == NULL ) && ( m_aiInfo.bstrPassword != NULL ) )
        {
            goto OutOfMemory;
        } // if:

    } // if:

    if ( pbstrDomainOut != NULL )
    {
        *pbstrDomainOut = SysAllocString( m_aiInfo.bstrDomain );
        if ( ( *pbstrDomainOut == NULL ) && ( m_aiInfo.bstrDomain != NULL ) )
        {
            goto OutOfMemory;
        } // if:

    } // if:

    hr = S_OK;
    goto Exit;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

Exit:

    HRETURN( hr );

} //*** CClusCfgCredentials::GetCredentials()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::SetCredentials()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCredentials::SetCredentials(
    LPCWSTR pcszNameIn,
    LPCWSTR pcszDomainIn,
    LPCWSTR pcszPasswordIn
    )
{
    TraceFunc( "[IClusCfgCredentials]" );

    HRESULT hr = S_OK;
//    HANDLE  hToken = NULL;
    BSTR    bstrNewName = NULL;
    BSTR    bstrNewDomain = NULL;
    BSTR    bstrNewPassword = NULL;

    //
    //  Logon the passed in user to ensure that it is valid.
    //
    /*
    //
    //  KB: 04 May 2000 GalenB
    //
    //  New for Whistler...  You no longer have to grant your processes TCB privilege. But it doesn't seem to work!
    //
    if ( !LogonUser( pcszNameIn, pcszDomainIn, pcszPasswordIn, LOGON32_LOGON_BATCH, LOGON32_PROVIDER_DEFAULT, &hToken ) )
    {
        DWORD   sc;

        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32(  );
        goto CleanUp;
    } // if:
    */
    if ( pcszNameIn != NULL )
    {
        bstrNewName = TraceSysAllocString( pcszNameIn );
        if ( bstrNewName == NULL )
        {
            goto OutOfMemory;
        } // if:
    } // if:

    if ( pcszPasswordIn != NULL )
    {
        bstrNewPassword = TraceSysAllocString( pcszPasswordIn );
        if ( bstrNewPassword == NULL )
        {
            goto OutOfMemory;
        } // if:
    } // if:

    if ( pcszDomainIn != NULL )
    {
        bstrNewDomain = TraceSysAllocString( pcszDomainIn );
        if ( bstrNewDomain == NULL )
        {
            goto OutOfMemory;
        } // if:
    } // if:

    if ( bstrNewName != NULL )
    {
        TraceSysFreeString( m_aiInfo.bstrName );
    } // if:

    if ( bstrNewPassword != NULL )
    {
        TraceSysFreeString( m_aiInfo.bstrPassword );
    } // if:

    if ( bstrNewDomain != NULL )
    {
        TraceSysFreeString( m_aiInfo.bstrDomain );
    } // if:

    m_aiInfo.bstrName = bstrNewName;
    m_aiInfo.bstrPassword = bstrNewPassword;
    m_aiInfo.bstrDomain = bstrNewDomain;

    goto CleanUp;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

CleanUp:

//    if ( hToken != NULL )
//    {
//        CloseHandle( hToken );
//    } // if:

    HRETURN( hr );

} //*** CClusCfgCredentials::SetCredentials()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCredentials -- IClusCfgSetCredentials interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::SetDomainCredentials()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCredentials::SetDomainCredentials( LPCWSTR pcszCredentials )
{
    TraceFunc( "[IClusSetCfgCredentials]" );

    HRESULT hr = S_OK;
    WCHAR * psz;

    if ( pcszCredentials == NULL )
    {
        hr = THR( E_POINTER );
        LogMsg( L"Server: CClusCfgCredentials::SetDomainCredentials() was given a NULL pointer argument." );
        goto Exit;
    } // if:

    //
    //  Are the credentials in domain\user format?
    //
    psz = wcschr( pcszCredentials, L'\\' );
    if ( psz != NULL )
    {
        *psz = L'\0';
        psz++;

        m_aiInfo.bstrDomain = TraceSysAllocString( pcszCredentials );
        if ( m_aiInfo.bstrDomain == NULL )
        {
            goto OutOfMemory;
        } // if:

        m_aiInfo.bstrName = TraceSysAllocString( psz );
        if ( m_aiInfo.bstrName == NULL )
        {
            goto OutOfMemory;
        } // if:

        goto Exit;
    } // if:

    //
    //  Are the credentials in user@domain format?
    //
    psz = wcschr( pcszCredentials, L'@' );
    if ( psz != NULL )
    {
        *psz = L'\0';
        psz++;

        m_aiInfo.bstrName = TraceSysAllocString( pcszCredentials );
        if ( m_aiInfo.bstrName == NULL )
        {
            goto OutOfMemory;
        } // if:

        m_aiInfo.bstrDomain = TraceSysAllocString( psz );
        if ( m_aiInfo.bstrDomain == NULL )
        {
            goto OutOfMemory;
        } // if:

        goto Exit;
    } // if:

    //
    //  Must be local, simply rememeber then as the user and get the machine name for the domain.
    //
    m_aiInfo.bstrName = TraceSysAllocString( pcszCredentials );
    if ( m_aiInfo.bstrName == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( HrGetComputerName( ComputerNameDnsFullyQualified, &m_aiInfo.bstrDomain ) );

    goto Exit;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

Exit:

    HRETURN( hr );

} //*** CClusCfgCredentials::SetDomainCredentials()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCredentials class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCredentials::HrInit()
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCredentials::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CClusCfgCredentials::HrInit()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\common\clusterutils.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ClusterUtils.h
//
//  Description:
//      This file contains the declaration of the ClusterUtils
//      functions.
//
//
//  Documentation:
//
//  Implementation Files:
//      ClusterUtils.cpp
//
//  Maintained By:
//
//////////////////////////////////////////////////////////////////////////////


#pragma once

//
// Cluster API Functions.
//
HRESULT HrIsCoreResource( HRESOURCE hResIn );
HRESULT HrIsResourceOfType( HRESOURCE hResIn, const WCHAR * pszResourceTypeIn );
HRESULT HrGetIPAddressInfo( HRESOURCE hResIn, ULONG * pulIPAddress, ULONG * pulSubnetMask );
HRESULT HrLoadCredentials( BSTR bstrMachine, IClusCfgSetCredentials * piCCSC );
HRESULT HrGetNodeNameHostingResource( HCLUSTER hClusterIn, HRESOURCE hResIn, BSTR * pbstrNameOut );
HRESULT HrGetNodeNameHostingCluster( HCLUSTER hClusterIn, BSTR * pbstrNodeName );
HRESULT HrGetIPAddressOfCluster( HCLUSTER hClusterIn, ULONG * pulIPAddress, ULONG * pulSubnetMask,  BSTR * pbstrNetworkName );
HRESULT HrGetDependentIPAddressInfo( HCLUSTER hClusterIn, HRESOURCE hResIn, ULONG * pulIPAddress, ULONG * pulNetworkMask,  BSTR * pbstrNetworkName );
HRESULT HrGetNetworkOfCluster( HCLUSTER hClusterIn, BSTR * pbstrNetworkName );
HRESULT HrGetSCSIInfo( HRESOURCE hResIn, CLUS_SCSI_ADDRESS  * pCSAOut, DWORD * pdwSignatureOut, DWORD * pdwDiskNumberOut );
HRESULT HrGetClusterInformation( HCLUSTER hClusterIn, BSTR * pbstrClusterNameOut, CLUSTERVERSIONINFO * pcviOut );

HRESULT HrGetClusterResourceState(
      HRESOURCE                 hResourceIn
    , BSTR *                    pbstrNodeNameOut
    , BSTR *                    pbstrGroupNameOut
    , CLUSTER_RESOURCE_STATE *  pcrsStateOut
    );

HRESULT
HrGetClusterQuorumResource(
      HCLUSTER  hClusterIn
    , BSTR *    pbstrResourceNameOut
    , BSTR *    pbstrDeviceNameOut
    , DWORD *   pdwMaxQuorumLogSizeOut
    );



//
// String manipulation functions.
//
HRESULT HrSeparateDomainAndName( BSTR bstrNameIn, BSTR * pbstrDomainOut, BSTR * pbstrNameOut );
HRESULT HrAppendDomainToName( BSTR bstrNameIn, BSTR bstrDomainIn, BSTR * pbstrDomainNameOut );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\common\cbaseproplist.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2000 Microsoft Corporation
//
//  Module Name:
//      CBasePropList.cpp
//
//  Description:
//      Implementation of the CBasePropList class.
//
//  Documentation:
//
//  Header File:
//      CBasePropList.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 31-MAY-2000
//
/////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CBaseInfo.h"
#include "CBasePropList.h"


/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

const int BUFFER_GROWTH_FACTOR = 256;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CchMultiSz
//
//  Description:
//      Length of all of the substrings of a multisz string minus the final NULL.
//
//      (i.e., includes the nulls of the substrings, excludes the final null)
//      multiszlen( "abcd\0efgh\0\0" => 5 + 5 = 10
//
//  Arguments:
//      psz     [IN] The string to get the length of.
//
//  Return Value:
//      Count of characters in the multisz or 0 if empty.
//
//--
/////////////////////////////////////////////////////////////////////////////
static size_t CchMultiSz(
    IN LPCWSTR psz
    )
{
    Assert( psz != NULL );

    size_t  _cchTotal = 0;
    size_t  _cchChars;

    while ( *psz != L'\0' )
    {
        _cchChars = lstrlenW( psz ) + 1;

        _cchTotal += _cchChars;
        psz += _cchChars;
    } // while: pointer not stopped on EOS

    return _cchTotal;

} //*** CchMultiSz

/////////////////////////////////////////////////////////////////////////////
//++
//
//  NCompareMultiSz
//
//  Description:
//      Compare two MULTI_SZ buffers.
//
//  Arguments:
//      pszSource   [IN] The source string.
//      pszTarget   [IN] The target string.
//
//  Return Value:
//      If the string pointed to by pszSource is less than the string pointed
//      to by pszTarget, the return value is negative. If the string pointed
//      to by pszSource is greater than the string pointed to by pszTarget,
//      the return value is positive. If the strings are equal, the return value
//      is zero.
//
//--
/////////////////////////////////////////////////////////////////////////////
static int NCompareMultiSz(
    IN LPCWSTR pszSource,
    IN LPCWSTR pszTarget
    )
{
    Assert( pszSource != NULL );
    Assert( pszTarget != NULL );

    while ( ( *pszSource != L'\0' ) && ( *pszTarget != L'\0') )
    {
        //
        // Move to end of strings.
        //
        while ( ( *pszSource != L'\0' ) && ( *pszTarget != L'\0') && ( *pszSource == *pszTarget ) )
        {
            ++pszSource;
            ++pszTarget;
        } // while: pointer not stopped on EOS

        //
        // If strings are the same, skip past terminating NUL.
        // Otherwise exit the loop.
        if ( ( *pszSource == L'\0' ) && ( *pszTarget == L'\0') )
        {
            ++pszSource;
            ++pszTarget;
        } // if: both stopped on EOS
        else
        {
            break;
        } // else: stopped because something is not equal -- wr are done.

    } // while: pointer not stopped on EOS

    return *pszSource - *pszTarget;

} //*** NCompareMultiSz()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CBasePropValueList class
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropValueList::ScMoveToFirstValue
//
//  Description:
//      Move the cursor to the first value in the value list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS   Position moved to the first value successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropValueList::ScMoveToFirstValue( void )
{
    Assert( m_cbhValueList.pb != NULL );

    DWORD   _sc;

    m_cbhCurrentValue = m_cbhValueList;
    m_cbDataLeft = m_cbDataSize;
    m_bAtEnd = FALSE;

    if ( m_cbhCurrentValue.pSyntax->dw == CLUSPROP_SYNTAX_ENDMARK )
    {
        _sc = ERROR_NO_MORE_ITEMS;
    } // if: no items in the value list
    else
    {
        _sc = ERROR_SUCCESS;
    } // else: items exist in the value list

    return _sc;

} //*** CBasePropValueList::ScMoveToFirstValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropValueList::ScMoveToNextValue
//
//  Description:
//      Move the cursor to the next value in the list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS       Position moved to the next value successfully.
//      ERROR_NO_MORE_ITEMS Already at the end of the list.
//      ERROR_INVALID_DATA  Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropValueList::ScMoveToNextValue( void )
{
    Assert( m_cbhCurrentValue.pb != NULL );

    DWORD                   _sc     = ERROR_NO_MORE_ITEMS;
    DWORD                   _cbDataSize;
    CLUSPROP_BUFFER_HELPER  _cbhCurrentValue;

    _cbhCurrentValue = m_cbhCurrentValue;

    do
    {
        //
        // Don't try to move if we're already at the end.
        //
        if ( m_bAtEnd )
        {
            break;
        } // if: already at the end of the list

        //
        // Make sure the buffer is big enough for the value header.
        //
        if ( m_cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data left

        //
        // Calculate how much to advance buffer pointer.
        //
        _cbDataSize = sizeof( *_cbhCurrentValue.pValue )
                    + ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );

        //
        // Make sure the buffer is big enough for the value header,
        // the data itself, and the endmark.
        //
        if ( m_cbDataLeft < _cbDataSize + sizeof( CLUSPROP_SYNTAX ) )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data left

        //
        // Move past the current value to the next value's syntax.
        //
        _cbhCurrentValue.pb += _cbDataSize;

        //
        // This test will ensure that the value is always valid since we won't
        // advance if the next thing is the endmark.
        //
        if ( _cbhCurrentValue.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK )
        {
            m_cbhCurrentValue = _cbhCurrentValue;
            m_cbDataLeft -= _cbDataSize;
            _sc = ERROR_SUCCESS;
        } // if: next value's syntax is not the endmark
        else
        {
            m_bAtEnd = TRUE;
        } // else: next value's syntax is the endmark
    } while ( 0 );

    return _sc;

} //*** CBasePropValueList::ScMoveToNextValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropValueList::ScCheckIfAtLastValue
//
//  Description:
//      Indicate whether we are on the last value in the list or not.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS       Not currently at the last value in the list.
//      ERROR_NO_MORE_ITEMS Currently at the last value in the list.
//      ERROR_INVALID_DATA  Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropValueList::ScCheckIfAtLastValue( void )
{
    Assert( m_cbhCurrentValue.pb != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    CLUSPROP_BUFFER_HELPER  _cbhCurrentValue;
    DWORD                   _cbDataSize;

    _cbhCurrentValue = m_cbhCurrentValue;

    do
    {
        //
        // Don't try to recalculate if we already know
        // we're at the end of the list.
        //
        if ( m_bAtEnd )
        {
            break;
        } // if: already at the end of the list

        //
        // Make sure the buffer is big enough for the value header.
        //
        if ( m_cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data left

        //
        // Calculate how much to advance buffer pointer.
        //
        _cbDataSize = sizeof( *_cbhCurrentValue.pValue )
                    + ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );

        //
        // Make sure the buffer is big enough for the value header,
        // the data itself, and the endmark.
        //
        if ( m_cbDataLeft < _cbDataSize + sizeof( CLUSPROP_SYNTAX ) )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data left

        //
        // Move past the current value to the next value's syntax.
        //
        _cbhCurrentValue.pb += _cbDataSize;

        //
        // We are on the last value if the next thing after this value
        // is an endmark.
        //
        if ( _cbhCurrentValue.pSyntax->dw == CLUSPROP_SYNTAX_ENDMARK )
        {
            _sc = ERROR_NO_MORE_ITEMS;
        } // if: next value's syntax is the endmark
    } while ( 0 );

    return _sc;

} //*** CBasePropValueList::ScCheckIfAtLastValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropValueList::ScAllocValueList
//
//  Description:
//      Allocate a value list buffer that's big enough to hold the next
//      value.
//
//  Arguments:
//      cbMinimum   [IN] Minimum size of the value list.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropValueList::ScAllocValueList( IN DWORD cbMinimum )
{
    Assert( cbMinimum > 0 );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbTotal = 0;

    //
    // Add the size of the item count and final endmark.
    //
    cbMinimum += sizeof( CLUSPROP_VALUE );
    _cbTotal = m_cbDataSize + cbMinimum;

    if ( m_cbBufferSize < _cbTotal )
    {
        PBYTE   _pbNewValuelist = NULL;

        cbMinimum = max( BUFFER_GROWTH_FACTOR, cbMinimum );
        _cbTotal = m_cbDataSize + cbMinimum;

        //
        // Allocate and zero a new buffer.
        //
        _pbNewValuelist = new BYTE[ _cbTotal ];
        if ( _pbNewValuelist != NULL )
        {
            ZeroMemory( _pbNewValuelist, _cbTotal );

            //
            // If there was a previous buffer, copy it and the delete it.
            //
            if ( m_cbhValueList.pb != NULL )
            {
                if ( m_cbDataSize != 0 )
                {
                    CopyMemory( _pbNewValuelist, m_cbhValueList.pb, m_cbDataSize );
                } // if: data already exists in buffer

                delete [] m_cbhValueList.pb;
                m_cbhCurrentValue.pb = _pbNewValuelist + (m_cbhCurrentValue.pb - m_cbhValueList.pb);
            } // if: there was a previous buffer
            else
            {
                m_cbhCurrentValue.pb = _pbNewValuelist + sizeof( DWORD ); // move past prop count
            } // else: no previous buffer

            //
            // Save the new buffer.
            //
            m_cbhValueList.pb = _pbNewValuelist;
            m_cbBufferSize = _cbTotal;
        } // if: allocation succeeded
        else
        {
            _sc = ERROR_NOT_ENOUGH_MEMORY;
        } // else: allocation failed
    } // if: buffer isn't big enough

    return _sc;

} //*** CBasePropValueList::ScAllocValueList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropValueList::ScGetResourceValueList
//
//  Description:
//      Get value list of a resource.
//
//  Arguments:
//      hResource       [IN] Handle for the resource to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropValueList::ScGetValueList(
    IN CBaseInfo &  cBaseInfo,
    IN DWORD        dwControlCode,
    IN HNODE        hHostNode,
    IN LPVOID       lpInBuffer,
    IN DWORD        cbInBufferSize
    )
{
    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cb = 512;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get values.
    //
    _sc = ScAllocValueList( _cb );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = cBaseInfo.Control(
                        dwControlCode,
                        lpInBuffer,
                        cbInBufferSize,
                        m_cbhValueList.pb,
                        m_cbBufferSize,
                        &_cb,
                        hHostNode
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = ScAllocValueList( _cb );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = cBaseInfo.Control(
                                dwControlCode,
                                lpInBuffer,
                                cbInBufferSize,
                                m_cbhValueList.pb,
                                m_cbBufferSize,
                                &_cb,
                                hHostNode
                                );
            } // if: ScAllocValueList succeeded
        } // if: buffer too small
    } // if: ScAllocValueList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeleteValueList();
    } // if: error getting properties.
    else
    {
        m_cbDataSize = _cb;
        m_cbDataLeft = _cb;
    } // else: no errors

    return _sc;

} //*** CBasePropValueList::ScGetValueList()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CBasePropList class
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::ScCopy
//
//  Description:
//      Copy a property list.  This function is equivalent to an assignment
//      operator.  Since this operation can fail, no assignment operator is
//      provided.
//
//  Arguments:
//      pcplPropList    [IN] The proplist to copy into this instance.
//      cbListSize      [IN] The total size of the prop list.
//
//  Return Value:
//      Win32 status code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropList::ScCopy(
    IN const PCLUSPROP_LIST pcplPropList,
    IN DWORD                cbListSize
    )
{
    Assert( pcplPropList != NULL );

    DWORD   _sc = ERROR_SUCCESS;

    //
    // Clean up any vestiges of a previous prop list.
    //
    if ( m_cbhPropList.pb != NULL )
    {
        DeletePropList();
    } // if: the current list is not empty

    //
    // Allocate the new property list buffer.  If successful,
    // copy the source list.
    //
    m_cbhPropList.pb = new BYTE[ cbListSize ];
    if ( m_cbhPropList.pb != NULL )
    {
        CopyMemory( m_cbhPropList.pList, pcplPropList, cbListSize );
        m_cbBufferSize = cbListSize;
        m_cbDataSize   = cbListSize;
        m_cbDataLeft   = cbListSize;
        _sc = ScMoveToFirstProperty();
    } // if: new succeeded
    else
    {
        _sc = ERROR_NOT_ENOUGH_MEMORY;
    } // else:

    return _sc;

} //*** CBasePropList::ScCopy()

////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::ScMoveToFirstProperty
//
//  Description:
//      Move the cursor to the first propery in the list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS       Position moved to the first property successfully.
//      ERROR_NO_MORE_ITEMS There are no properties in the list.
//      ERROR_INVALID_DATA  Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropList::ScMoveToFirstProperty( void )
{
    Assert( m_cbhPropList.pb != NULL );
    Assert( m_cbDataSize >= sizeof( m_cbhPropList.pList->nPropertyCount ) );

    DWORD                   _sc;
    DWORD                   _cbDataLeft;
    DWORD                   _cbDataSize;
    CLUSPROP_BUFFER_HELPER  _cbhCurrentValue;

    do
    {
        //
        // Make sure the buffer is big enough for the list header.
        //
        if ( m_cbDataSize < sizeof( m_cbhPropList.pList->nPropertyCount ) )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data

        //
        // Set the property counter to the number of properties in the list.
        //
        m_nPropsRemaining = m_cbhPropList.pList->nPropertyCount;

        //
        // Point the name pointer to the first name in the list.
        //
        m_cbhCurrentPropName.pName = &m_cbhPropList.pList->PropertyName;
        m_cbDataLeft = m_cbDataSize - sizeof( m_cbhPropList.pList->nPropertyCount );

        //
        // Check to see if there are any properties in the list.
        //
        if ( m_nPropsRemaining == 0 )
        {
            _sc = ERROR_NO_MORE_ITEMS;
            break;
        } // if: no properties in the list

        //
        // Make sure the buffer is big enough for the first property name.
        //
        if ( m_cbDataLeft < sizeof( *m_cbhCurrentPropName.pName ) )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data left

        //
        // Calculate how much to advance the buffer pointer.
        //
        _cbDataSize = sizeof( *m_cbhCurrentPropName.pName )
                    + ALIGN_CLUSPROP( m_cbhCurrentPropName.pName->cbLength );

        //
        // Make sure the buffer is big enough for the name header
        // and the data itself.
        //
        if ( m_cbDataLeft < _cbDataSize )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data left

        //
        // Point the value buffer to the first value in the list.
        //
        _cbhCurrentValue.pb = m_cbhCurrentPropName.pb + _cbDataSize;
        _cbDataLeft = m_cbDataLeft - _cbDataSize;
        m_pvlValues.Init( _cbhCurrentValue, _cbDataLeft );

        //
        // Indicate we are successful.
        //
        _sc = ERROR_SUCCESS;

    } while ( 0 );

    return _sc;

} //*** CBasePropList::ScMoveToFirstProperty

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::ScMoveToNextProperty
//
//  Description:
//      Move the cursor to the next property in the list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS       Position moved to the next property successfully.
//      ERROR_NO_MORE_ITEMS Already at the end of the list.
//      ERROR_INVALID_DATA  Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropList::ScMoveToNextProperty( void )
{
    Assert( m_cbhPropList.pb != NULL );
    Assert( m_pvlValues.CbhValueList().pb != NULL );

    DWORD                   _sc;
    DWORD                   _cbNameSize;
    DWORD                   _cbDataLeft;
    DWORD                   _cbDataSize;
    CLUSPROP_BUFFER_HELPER  _cbhCurrentValue;
    CLUSPROP_BUFFER_HELPER  _cbhPropName;

    _cbhCurrentValue = m_pvlValues;
    _cbDataLeft = m_pvlValues.CbDataLeft();

    //
    // If we aren't already at the last property, attempt to move to the next one.
    //
    _sc = ScCheckIfAtLastProperty();
    if ( _sc == ERROR_SUCCESS )
    {
        do
        {
            //
            // Make sure the buffer is big enough for the value header.
            //
            if ( _cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
            {
                _sc = ERROR_INVALID_DATA;
                break;
            } // if: not enough data left

            //
            // Careful!  Add offset only to cbhCurrentValue.pb.  Otherwise
            // pointer arithmetic will give undesirable results.
            //
            while ( _cbhCurrentValue.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK )
            {
                //
                // Make sure the buffer is big enough for the value
                // and an endmark.
                //
                _cbDataSize = sizeof( *_cbhCurrentValue.pValue )
                            + ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );
                if ( _cbDataLeft < _cbDataSize + sizeof( *_cbhCurrentValue.pSyntax ) )
                {
                    _sc = ERROR_INVALID_DATA;
                    break;
                } // if: not enough data left

                //
                // Advance past the value.
                //
                _cbhCurrentValue.pb += _cbDataSize;
                _cbDataLeft -= _cbDataSize;
            } // while: not at endmark

            if ( _sc != ERROR_SUCCESS )
            {
                break;
            } // if: error occurred in loop

            //
            // Advanced past the endmark.
            // Size check already performed in above loop.
            //
            _cbDataSize = sizeof( *_cbhCurrentValue.pSyntax );
            _cbhCurrentValue.pb += _cbDataSize;
            _cbDataLeft -= _cbDataSize;

            //
            // Point the name pointer to the next name in the list.
            //
            _cbhPropName = _cbhCurrentValue;
            Assert( _cbDataLeft == m_cbDataSize - (_cbhPropName.pb - m_cbhPropList.pb) );

            //
            // Calculate the size of the name with header.
            // Make sure the buffer is big enough for the name and an endmark.
            //
            if ( _cbDataLeft < sizeof( *_cbhPropName.pName ) )
            {
                _sc = ERROR_INVALID_DATA;
                break;
            } // if: not enough data
            _cbNameSize = sizeof( *_cbhPropName.pName )
                        + ALIGN_CLUSPROP( _cbhPropName.pName->cbLength );
            if ( _cbDataLeft < _cbNameSize + sizeof( CLUSPROP_SYNTAX ) )
            {
                _sc = ERROR_INVALID_DATA;
                break;
            } // if: not enough data

            //
            // Point the value buffer to the first value in the list.
            //
            _cbhCurrentValue.pb = _cbhPropName.pb + _cbNameSize;
            m_cbhCurrentPropName = _cbhPropName;
            m_cbDataLeft = _cbDataLeft - _cbNameSize;
            m_pvlValues.Init( _cbhCurrentValue, m_cbDataLeft );

            //
            // We've successfully advanced to the next property,
            // so there is now one fewer property remaining.
            //
            --m_nPropsRemaining;
            Assert( m_nPropsRemaining >= 1 );

            _sc = ERROR_SUCCESS;

        } while ( 0 );
    } // if: not at last property

    return _sc;

} //*** CBasePropList::ScMoveToNextProperty()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::ScMoveToPropertyByName
//
//  Description:
//      Find the passed in property name in the proplist.  Note that the
//      cursor is reset to the beginning at the beginning of the routine and
//      the current state of the cursor is lost.
//
//  Arguments:
//      pwszPropName    [IN] Name of the property
//
//  Return Value:
//      TRUE if the property was found, FALSE if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropList::ScMoveToPropertyByName( IN LPCWSTR pwszPropName )
{
    Assert( m_cbhPropList.pb != NULL );

    DWORD   _sc;

    _sc = ScMoveToFirstProperty();
    if ( _sc == ERROR_SUCCESS )
    {
        do
        {
            //
            // See if this is the specified property.  If so, we're done.
            //
            if ( lstrcmpiW( m_cbhCurrentPropName.pName->sz, pwszPropName ) == 0 )
            {
                break;
            } // if: property found

            //
            // Advance to the next property.
            //
            _sc = ScMoveToNextProperty();

        } while ( _sc == ERROR_SUCCESS );   // do-while: not end of list
    } // if: successfully moved to the first property

    return _sc;

} //*** ClusPropList::ScMoveToPropertyByName( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::ScAllocPropList
//
//  Description:
//      Allocate a property list buffer that's big enough to hold the next
//      property.
//
//  Arguments:
//      cbMinimum   [IN] Minimum size of the property list.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropList::ScAllocPropList( IN DWORD cbMinimum )
{
    Assert( cbMinimum > 0 );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbTotal = 0;

    //
    // Add the size of the item count and final endmark.
    //
    cbMinimum += sizeof( CLUSPROP_VALUE );
    _cbTotal = m_cbDataSize + cbMinimum;

    if ( m_cbBufferSize < _cbTotal )
    {
        PBYTE   _pbNewProplist = NULL;

        cbMinimum = max( BUFFER_GROWTH_FACTOR, cbMinimum );
        _cbTotal = m_cbDataSize + cbMinimum;

        //
        // Allocate and zero a new buffer.
        //
        _pbNewProplist = new BYTE[ _cbTotal ];
        if ( _pbNewProplist != NULL )
        {
            ZeroMemory( _pbNewProplist, _cbTotal );

            //
            // If there was a previous buffer, copy it and the delete it.
            //
            if ( m_cbhPropList.pb != NULL )
            {
                if ( m_cbDataSize != 0 )
                {
                    CopyMemory( _pbNewProplist, m_cbhPropList.pb, m_cbDataSize );
                } // if: data already exists in buffer

                delete [] m_cbhPropList.pb;
                m_cbhCurrentProp.pb = _pbNewProplist + (m_cbhCurrentProp.pb - m_cbhPropList.pb);
            } // if: there was a previous buffer
            else
            {
                m_cbhCurrentProp.pb = _pbNewProplist + sizeof( DWORD ); // move past prop count
            } // else: no previous buffer

            //
            // Save the new buffer.
            //
            m_cbhPropList.pb = _pbNewProplist;
            m_cbBufferSize = _cbTotal;
        } // if: allocation succeeded
        else
        {
            _sc = ERROR_NOT_ENOUGH_MEMORY;
        } // else: allocation failed
    } // if: buffer isn't big enough

    return _sc;

} //*** CBasePropList::ScAllocPropList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::ScAddProp
//
//  Description:
//      Add a string property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      pwszValue       [IN] Value of the property to set in the list.
//      pwszPrevValue   [IN] Previous value of the property.
//
//  Return Value:
//      ERROR_SUCCESS or other Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropList::ScAddProp(
    IN LPCWSTR  pwszName,
    IN LPCWSTR  pwszValue,
    IN LPCWSTR  pwszPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    BOOL                    _bValuesDifferent = TRUE;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_SZ            _pValue;

    if (( pwszPrevValue != NULL ) && ( lstrcmpW( pwszValue, pwszPrevValue ) == 0 ))
    {
        _bValuesDifferent = FALSE;
    } // if: we have a prev value and the values are the same

    //
    // If we should always add, or if the new value and the previous value
    // are not equal, add the property to the property list.
    //
    if ( m_bAlwaysAddProp || _bValuesDifferent )
    {
        DWORD   _cbNameSize;
        DWORD   _cbDataSize;
        DWORD   _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbDataSize = (lstrlenW( pwszValue ) + 1) * sizeof( WCHAR );
        _cbValueSize = sizeof( CLUSPROP_SZ )
                    + ALIGN_CLUSPROP( _cbDataSize )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pStringValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CBasePropList::ScAddProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::ScAddMultiSzProp
//
//  Description:
//      Add a string property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      pwszValue       [IN] Value of the property to set in the list.
//      pwszPrevValue   [IN] Previous value of the property.
//
//  Return Value:
//      ERROR_SUCCESS or other Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropList::ScAddMultiSzProp(
    IN LPCWSTR  pwszName,
    IN LPCWSTR  pwszValue,
    IN LPCWSTR  pwszPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    BOOL                    _bValuesDifferent = TRUE;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_MULTI_SZ      _pValue;

    if ( ( pwszPrevValue != NULL ) && ( NCompareMultiSz( pwszValue, pwszPrevValue ) == 0 ) )
    {
        _bValuesDifferent = FALSE;
    } // if: we have a prev value and the values are the same

    //
    // If we should always add, or if the new value and the previous value
    // are not equal, add the property to the property list.
    //
    if ( m_bAlwaysAddProp || _bValuesDifferent )
    {
        DWORD   _cbNameSize;
        DWORD   _cbDataSize;
        DWORD   _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbDataSize = static_cast< DWORD >( (CchMultiSz( pwszValue ) + 1) * sizeof( WCHAR ) );
        _cbValueSize = sizeof( CLUSPROP_SZ )
                    + ALIGN_CLUSPROP( _cbDataSize )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pMultiSzValue;
            CopyMultiSzProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CBasePropList::ScAddMultiSzProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::ScAddExpandSzProp
//
//  Description:
//      Add an EXPAND_SZ string property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      pwszValue       [IN] Value of the property to set in the list.
//      pwszPrevValue   [IN] Previous value of the property.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropList::ScAddExpandSzProp(
    IN LPCWSTR  pwszName,
    IN LPCWSTR  pwszValue,
    IN LPCWSTR  pwszPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    BOOL                    _bValuesDifferent = TRUE;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_SZ            _pValue;

    if ( ( pwszPrevValue != NULL ) && ( lstrcmpW( pwszValue, pwszPrevValue ) == 0 ) )
    {
        _bValuesDifferent = FALSE;
    } // if: we have a prev value and the values are the same

    //
    // If we should always add, or if the new value and the previous value
    // are not equal, add the property to the property list.
    //
    if ( m_bAlwaysAddProp || _bValuesDifferent )
    {
        DWORD   _cbNameSize;
        DWORD   _cbDataSize;
        DWORD   _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbDataSize = (lstrlenW( pwszValue ) + 1) * sizeof( WCHAR );
        _cbValueSize = sizeof( CLUSPROP_SZ )
                    + ALIGN_CLUSPROP( _cbDataSize )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pStringValue;
            CopyExpandSzProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CBasePropList::ScAddExpandSzProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::ScAddProp
//
//  Description:
//      Add a DWORD property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      nValue          [IN] Value of the property to set in the list.
//      nPrevValue      [IN] Previous value of the property.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropList::ScAddProp(
    IN LPCWSTR  pwszName,
    IN DWORD    nValue,
    IN DWORD    nPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_DWORD         _pValue;

    if ( m_bAlwaysAddProp || ( nValue != nPrevValue ) )
    {
        DWORD   _cbNameSize;
        DWORD   _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbValueSize = sizeof( CLUSPROP_DWORD )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pDwordValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, nValue );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CBasePropList::ScAddProp( DWORD )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::ScAddProp
//
//  Description:
//      Add a LONG property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      nValue          [IN] Value of the property to set in the list.
//      nPrevValue      [IN] Previous value of the property.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropList::ScAddProp(
    IN LPCWSTR  pwszName,
    IN LONG     nValue,
    IN LONG     nPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_LONG          _pValue;

    if ( m_bAlwaysAddProp || ( nValue != nPrevValue ) )
    {
        DWORD   _cbNameSize;
        DWORD   _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbValueSize = sizeof( CLUSPROP_LONG )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pLongValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, nValue );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CBasePropList::ScAddProp( LONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::ScAddProp
//
//  Description:
//      Add a binary property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      pbValue         [IN] Value of the property to set in the list.
//      cbValue         [IN] Count of bytes in pbValue.
//      pbPrevValue     [IN] Previous value of the property.
//      cbPrevValue     [IN] Count of bytes in pbPrevValue.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropList::ScAddProp(
    IN LPCWSTR          pwszName,
    IN const PBYTE      pbValue,
    IN DWORD            cbValue,
    IN const PBYTE      pbPrevValue,
    IN DWORD            cbPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    BOOL                    bChanged = FALSE;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_BINARY        _pValue;

    //
    // Determine if the buffer has changed.
    //
    if ( m_bAlwaysAddProp || (cbValue != cbPrevValue) )
    {
        bChanged = TRUE;
    } // if: always adding the property or the value size changed
    else if ( ( cbValue != 0 ) && ( cbPrevValue != 0 ) )
    {
        bChanged = memcmp( pbValue, pbPrevValue, cbValue ) != 0;
    } // else if: value length changed

    if ( bChanged )
    {
        DWORD   _cbNameSize;
        DWORD   _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbValueSize = sizeof( CLUSPROP_BINARY )
                    + ALIGN_CLUSPROP( cbValue )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pBinaryValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pbValue, cbValue );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CBasePropList::ScAddProp( PBYTE )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::ScAddProp
//
//  Routine Description:
//      Add a ULONGLONG property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      ullValue        [IN] Value of the property to set in the list.
//      ullPrevValue    [IN] Previous value of the property.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropList::ScAddProp(
    IN LPCWSTR      pwszName,
    IN ULONGLONG    ullValue,
    IN ULONGLONG    ullPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                       _sc = ERROR_SUCCESS;
    PCLUSPROP_PROPERTY_NAME     _pName;
    PCLUSPROP_ULARGE_INTEGER    _pValue;

    if ( m_bAlwaysAddProp || ( ullValue != ullPrevValue ) )
    {
        DWORD   _cbNameSize;
        DWORD   _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbValueSize = sizeof( CLUSPROP_ULARGE_INTEGER )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pULargeIntegerValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, ullValue );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CBasePropList::ScAddProp( ULONGLONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::ScSetPropToDefault
//
//  Description:
//      Add a property to the property list so that it will revert to its
//      default value.
//
//  Arguments:
//      pwszName    [IN] Name of the property.
//      cpfPropFmt  [IN] Format of property
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropList::ScSetPropToDefault(
    IN LPCWSTR                  pwszName,
    IN CLUSTER_PROPERTY_FORMAT  cpfPropFmt
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    DWORD                   _cbNameSize;
    DWORD                   _cbValueSize;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_VALUE         _pValue;

    // Calculate sizes and make sure we have a property list.
    _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
    _cbValueSize = sizeof( CLUSPROP_BINARY )
                + sizeof( CLUSPROP_SYNTAX ); // value list endmark

    _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
    if ( _sc == ERROR_SUCCESS )
    {
        //
        // Set the property name.
        //
        _pName = m_cbhCurrentProp.pName;
        CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
        m_cbhCurrentProp.pb += _cbNameSize;

        //
        // Set the property value.
        //
        _pValue = m_cbhCurrentProp.pValue;
        CopyEmptyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, cpfPropFmt );
        m_cbhCurrentProp.pb += _cbValueSize;

        //
        // Increment the property count and buffer size.
        //
        m_cbhPropList.pList->nPropertyCount++;
        m_cbDataSize += _cbNameSize + _cbValueSize;
    } // if:

    return _sc;

} //*** CBasePropList::ScSetPropToDefault()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::CopyProp
//
//  Description:
//      Copy a string property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of string.
//      psz         [IN] String to copy.
//      cbsz        [IN] Count of bytes in pwsz string.  If specified as 0,
//                      the the length will be determined by a call to strlen.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropList::CopyProp(
    OUT PCLUSPROP_SZ            pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN LPCWSTR                  psz,
    IN size_t                   cbsz        // = 0
    )
{
    Assert( pprop != NULL );
    Assert( psz != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_SZ;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    if ( cbsz == 0 )
    {
        cbsz = (lstrlenW( psz ) + 1) * sizeof( WCHAR );
    } // if: zero size specified
    Assert( cbsz == (lstrlenW( psz ) + 1) * sizeof( WCHAR ) );
    pprop->cbLength = static_cast< DWORD >( cbsz );
    lstrcpyW( pprop->sz, psz );

    //
    // Set an endmark.
    //
    _cbhProps.pStringValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cbsz );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CBasePropList::CopyProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::CopyMultiSzProp
//
//  Description:
//      Copy a MULTI_SZ string property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of string.
//      psz         [IN] String to copy.
//      cbsz        [IN] Count of bytes in psz string.  If specified as 0,
//                      the the length will be determined by calls to strlen.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropList::CopyMultiSzProp(
    OUT PCLUSPROP_MULTI_SZ      pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN LPCWSTR                  psz,
    IN size_t                   cbsz
    )
{
    Assert( pprop != NULL );
    Assert( psz != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_MULTI_SZ;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    if ( cbsz == 0 )
    {
        cbsz = (CchMultiSz( psz ) + 1) * sizeof( WCHAR );
    } // if: zero size specified
    Assert( cbsz == (CchMultiSz( psz ) + 1) * sizeof( WCHAR ) );
    pprop->cbLength = static_cast< DWORD >( cbsz );
    CopyMemory( pprop->sz, psz, cbsz );

    //
    // Set an endmark.
    //
    _cbhProps.pMultiSzValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pMultiSzValue ) + ALIGN_CLUSPROP( cbsz );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CBasePropList::CopyMultiSzProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::CopyExpandSzProp
//
//  Description:
//      Copy an EXPAND_SZ string property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of string.
//      psz         [IN] String to copy.
//      cbsz        [IN] Count of bytes in psz string.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropList::CopyExpandSzProp(
    OUT PCLUSPROP_SZ            pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN LPCWSTR                  psz,
    IN size_t                   cbsz
    )
{
    Assert( pprop != NULL );
    Assert( psz != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_EXPAND_SZ;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    if ( cbsz == 0 )
    {
        cbsz = (lstrlenW( psz ) + 1) * sizeof( WCHAR );
    } // if: cbsz == 0
    Assert( cbsz == (lstrlenW( psz ) + 1) * sizeof( WCHAR ) );
    pprop->cbLength = static_cast< DWORD >( cbsz );
    lstrcpyW( pprop->sz, psz );

    //
    // Set an endmark.
    //
    _cbhProps.pStringValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cbsz );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CBasePropList::CopyExpandSzProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::CopyProp
//
//  Description:
//      Copy a DWORD property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of DWORD.
//      nValue      [IN] Property value to copy.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropList::CopyProp(
    OUT PCLUSPROP_DWORD         pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN DWORD                    nValue
    )
{
    Assert( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_DWORD;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    pprop->cbLength = sizeof( DWORD );
    pprop->dw = nValue;

    //
    // Set an endmark.
    //
    _cbhProps.pDwordValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pDwordValue );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CBasePropList::CopyProp( DWORD )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::CopyProp
//
//  Description:
//      Copy a LONG property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of LONG.
//      nValue      [IN] Property value to copy.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropList::CopyProp(
    OUT PCLUSPROP_LONG          pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN LONG                     nValue
    )
{
    Assert( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_LONG;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    pprop->cbLength = sizeof( DWORD );
    pprop->l = nValue;

    //
    // Set an endmark.
    //
    _cbhProps.pLongValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pLongValue );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CBasePropList::CopyProp( LONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::CopyProp
//
//  Description:
//      Copy a ULONGLONG property to a property structure.
//
//  Arguments:
//      pprop       [OUT]   Property structure to fill.
//      proptype    [IN]    Type of LONG.
//      nValue      [IN]    Property value to copy.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropList::CopyProp(
    OUT PCLUSPROP_ULARGE_INTEGER    pprop,
    IN  CLUSTER_PROPERTY_TYPE       proptype,
    IN  ULONGLONG                   nValue
    )
{
    Assert( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_ULARGE_INTEGER;
    pprop->Syntax.wType = static_cast< WORD >( proptype );
    pprop->cbLength = sizeof( ULONGLONG );
    pprop->li.QuadPart = nValue;

    //
    // Set an endmark.
    //
    _cbhProps.pULargeIntegerValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pULargeIntegerValue );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CBasePropList::CopyProp( ULONGLONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::CopyProp
//
//  Description:
//      Copy a binary property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of string.
//      pb          [IN] Block to copy.
//      cbsz        [IN] Count of bytes in pb buffer.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropList::CopyProp(
    OUT PCLUSPROP_BINARY        pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN const PBYTE              pb,
    IN size_t                   cb
    )
{
    Assert( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_BINARY;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    pprop->cbLength = static_cast< DWORD >( cb );
    if ( cb > 0 )
    {
        CopyMemory( pprop->rgb, pb, cb );
    } // if: non-zero data length

    //
    // Set an endmark.
    //
    _cbhProps.pBinaryValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cb );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CBasePropList::CopyProp( PBYTE )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::CopyEmptyProp
//
//  Description:
//      Copy an empty property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of property.
//      cpfPropFmt  [IN] Format of property.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropList::CopyEmptyProp(
    OUT PCLUSPROP_VALUE         pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN CLUSTER_PROPERTY_FORMAT  cptPropFmt
    )
{
    Assert( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = static_cast< WORD >( cptPropFmt );
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    pprop->cbLength = 0;

    //
    // Set an endmark.
    //
    _cbhProps.pValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pValue );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CBasePropList::CopyEmptyProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropList::ScGetNodeProperties
//
//  Description:
//      Get properties on a node.
//
//  Arguments:
//      hNode           [IN] Handle for the node to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropList::ScGetProperties(
    IN CBaseInfo &  cBaseInfo,
    IN DWORD        dwControlCode,
    IN HNODE        hHostNode,
    IN LPVOID       lpInBuffer,
    IN DWORD        cbInBufferSize
    )
{
    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = ScAllocPropList( _cbProps );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = cBaseInfo.Control(
                        dwControlCode,
                        lpInBuffer,
                        cbInBufferSize,
                        m_cbhPropList.pb,
                        m_cbBufferSize,
                        &_cbProps,
                        hHostNode
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = ScAllocPropList( ++_cbProps );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = cBaseInfo.Control(
                                dwControlCode,
                                lpInBuffer,
                                cbInBufferSize,
                                m_cbhPropList.pb,
                                m_cbBufferSize,
                                &_cbProps,
                                hHostNode
                                );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting properties.
    else
    {
        m_cbDataSize = _cbProps;
        m_cbDataLeft = _cbProps;
    } // else: no errors

    return _sc;

} //*** CBasePropList::ScGetProperties()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\common\cbaseproplist.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2000 Microsoft Corporation
//
//  Module Name:
//      CBasePropList.h
//
//  Implementation File:
//      PropList.cpp
//
//  Description:
//      Definition of the CClusPropList class.
//
//  Author:
//      David Potter (davidp)   February 24, 1997
//
//  Revision History:
//      12/18/1998  GalenB  Added MoveFirst, MoveNext, and other parsing
//                          methods.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

#define ASSERT Assert

class CBaseObjectProperty;
class CBasePropValueList;
class CBasePropList;
class CBaseInfo;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CBasePropValueList
//
//  Description:
//      Describes a cluster property list.
//
//  Inheritance:
//      CBasePropValueList
//      CObject (MFC only)
//
//--
/////////////////////////////////////////////////////////////////////////////

class CBasePropValueList
{
public:
    //
    // Construction.
    //

    // Default constructor
    CBasePropValueList( void )
        : m_cbDataSize( 0 )
        , m_cbDataLeft( 0 )
        , m_cbBufferSize( 0 )
        , m_bAtEnd( FALSE )
    {
        m_cbhValueList.pb = NULL;
        m_cbhCurrentValue.pb = NULL;

    } //*** CBasePropValueList()

    // Copy constructor.
    CBasePropValueList( IN const CBasePropValueList & rcpvl )
        : m_cbBufferSize( 0 )
        , m_bAtEnd( FALSE )
    {
        Init( rcpvl );

    } //*** CBasePropValueList()

    // Buffer helper constructor.
    CBasePropValueList( IN CLUSPROP_BUFFER_HELPER cbhValueList, IN DWORD cbDataSize )
        : m_cbBufferSize( 0 )
        , m_bAtEnd( FALSE )
    {
        Init( cbhValueList, cbDataSize );

    } //*** CBasePropValueList()

    // Destructor
    ~CBasePropValueList( void )
    {
        DeleteValueList();

    } //*** ~CBasePropValueList()

    // Initialize the value list
    void Init( IN const CBasePropValueList & rcpvl )
    {
        ASSERT( m_cbBufferSize == 0 );

        m_cbhValueList      = rcpvl.m_cbhValueList;
        m_cbhCurrentValue   = rcpvl.m_cbhCurrentValue;
        m_cbDataSize        = rcpvl.m_cbDataSize;
        m_cbDataLeft        = rcpvl.m_cbDataLeft;
        m_bAtEnd            = rcpvl.m_bAtEnd;

    } //*** Init()

    // Initialize the value list from a buffer helper
    void Init( IN const CLUSPROP_BUFFER_HELPER cbhValueList, IN DWORD cbDataSize )
    {
        ASSERT( m_cbBufferSize == 0 );

        m_cbhValueList      = cbhValueList;
        m_cbhCurrentValue   = cbhValueList;
        m_cbDataSize        = cbDataSize;
        m_cbDataLeft        = cbDataSize;
        m_bAtEnd            = FALSE;

    } //*** Init()

    // Assignment operator
    void operator=( IN const CBasePropValueList & rcpvl )
    {
        ASSERT( m_cbBufferSize == 0 );

        m_cbhValueList      = rcpvl.m_cbhValueList;
        m_cbhCurrentValue   = rcpvl.m_cbhCurrentValue;
        m_cbDataSize        = rcpvl.m_cbDataSize;
        m_cbDataLeft        = rcpvl.m_cbDataLeft;
        m_bAtEnd            = rcpvl.m_bAtEnd;

    } //*** operator=()

public:
    //
    // Accessor methods.
    //

    // Buffer helper cast operator to access the current value
    operator const CLUSPROP_BUFFER_HELPER( void ) const
    {
        return m_cbhCurrentValue;

    } //*** operator CLUSPROP_BUFFER_HELPER()

    // Access the value list
    CLUSPROP_BUFFER_HELPER CbhValueList( void ) const
    {
        return m_cbhValueList;

    } //*** CbhValueList()

    // Access the current value
    CLUSPROP_BUFFER_HELPER CbhCurrentValue( void ) const
    {
        return m_cbhCurrentValue;

    } //*** CbhCurrentValue()

    // Access the format of the current value
    CLUSTER_PROPERTY_FORMAT CpfCurrentValueFormat( void ) const
    {
        return static_cast< CLUSTER_PROPERTY_FORMAT >( m_cbhCurrentValue.pValue->Syntax.wFormat );

    } //*** CpfCurrentValueFormat()

    // Access the type of the current value
    CLUSTER_PROPERTY_TYPE CptCurrentValueType( void ) const
    {
        return static_cast< CLUSTER_PROPERTY_TYPE >( m_cbhCurrentValue.pValue->Syntax.wType );

    } //*** CptCurrentValueType()

    // Access the syntax of the current value
    CLUSTER_PROPERTY_SYNTAX CpsCurrentValueSyntax( void ) const
    {
        return static_cast< CLUSTER_PROPERTY_SYNTAX >( m_cbhCurrentValue.pValue->Syntax.dw );

    } //*** CpsCurrentValueSyntax()

    // Access the length of the data of the current value
    DWORD CbCurrentValueLength( void ) const
    {
        DWORD cbLength;

        if ( m_cbhCurrentValue.pb == NULL )
        {
            cbLength = 0;
        } // if: no value list allocated yet
        else
        {
            cbLength = m_cbhCurrentValue.pValue->cbLength;
        } // else: value list allocated

        return cbLength;

    } //*** CbCurrentValueLength()

    // Access size of the data in the buffer.
    DWORD CbDataSize( void ) const
    {
        return m_cbDataSize;

    } //*** CbDataSize()

    // Access amount of data left in buffer after current value
    DWORD CbDataLeft( void ) const
    {
        return m_cbDataLeft;

    } //*** CbDataLeft()

public:
    //
    // Parsing methods.
    //

    // Move to the first value in the list
    DWORD ScMoveToFirstValue( void );

    // Move the value after the current one in the list
    DWORD ScMoveToNextValue( void );

    // Query whether we are at the last value in the list or not
    DWORD ScCheckIfAtLastValue( void );

public:
    //
    // Methods for building a value list.
    //

    // Allocate a value list
    DWORD ScAllocValueList( IN DWORD cbMinimum );

    // Delete the value list buffer and cleanup support variables
    void DeleteValueList( void )
    {
        //
        // If m_cbBufferSize is greater then 0 then we allocated the value list.
        // If it's zero then the value list is a part of the property list in
        // CClusPropList.
        //
        if ( m_cbBufferSize > 0 )
        {
            delete [] m_cbhValueList.pb;
            m_cbhValueList.pb = NULL;
            m_cbhCurrentValue.pb = NULL;
            m_cbBufferSize = 0;
            m_cbDataSize = 0;
            m_cbDataLeft = 0;
            m_bAtEnd = FALSE;
        } // if: we allocated anything

    } //*** DeletePropList()

    // Get a value list from a resource
    DWORD ScGetValueList(
        IN CBaseInfo &  cBaseInfo,
        IN DWORD        dwControlCode,
        IN HNODE        hHostNode       = NULL,
        IN LPVOID       lpInBuffer      = NULL,
        IN DWORD        cbInBufferSize  = 0

    );

private:
    CLUSPROP_BUFFER_HELPER  m_cbhValueList;     // Pointer to the value list for parsing.
    CLUSPROP_BUFFER_HELPER  m_cbhCurrentValue;  // Pointer to the current value for parsing.
    DWORD                   m_cbDataSize;       // Amount of data in the buffer.
    DWORD                   m_cbDataLeft;       // Amount of data left in buffer after current value.
    DWORD                   m_cbBufferSize;     // Size of the buffer if we allocated it.
    BOOL                    m_bAtEnd;           // Indicates whether at last value in list.

}; //*** class CBasePropValueList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CBasePropList
//
//  Description:
//      Describes a cluster property list.
//
//  Inheritance:
//      CClusPropList
//      CObject (MFC only)
//
//--
/////////////////////////////////////////////////////////////////////////////

class CBasePropList
{
public:
    //
    // Construction.
    //

    // Default constructor
    CBasePropList( IN BOOL bAlwaysAddProp = FALSE )
        : m_bAlwaysAddProp( bAlwaysAddProp )
        , m_cbBufferSize( 0 )
        , m_cbDataSize( 0 )
        , m_cbDataLeft( 0 )
        , m_nPropsRemaining( 0 )
    {
        m_cbhPropList.pList     = NULL;
        m_cbhCurrentProp.pb     = NULL;
        m_cbhCurrentPropName.pb = NULL;

    } //*** CClusPropList()

    // Destructor
    ~CBasePropList( void )
    {
        DeletePropList();

    } //*** ~CClusPropList()

    // Copy list into this list (like assignment operator)
    DWORD ScCopy( IN const PCLUSPROP_LIST pcplPropList, IN DWORD cbListSize );

    // Delete the property list buffer and cleanup support variables
    void DeletePropList( void )
    {
        delete [] m_cbhPropList.pb;
        m_cbhPropList.pb = NULL;
        m_cbhCurrentProp.pb = NULL;
        m_cbhCurrentPropName.pb = NULL;
        m_cbBufferSize = 0;
        m_cbDataSize = 0;
        m_cbDataLeft = 0;

    } //*** DeletePropList()

protected:
    //
    // Attributes.
    //

    BOOL                    m_bAlwaysAddProp;       // Indicate if properties should be added even if not different.
    CLUSPROP_BUFFER_HELPER  m_cbhPropList;          // Pointer to the beginning of the list.
    CLUSPROP_BUFFER_HELPER  m_cbhCurrentProp;       // Pointer to the current property.
    DWORD                   m_cbBufferSize;         // Allocated size of the buffer.
    DWORD                   m_cbDataSize;           // Amount of data in the buffer.
    DWORD                   m_cbDataLeft;           // Amount of data left in buffer after current value.

private:
    CLUSPROP_BUFFER_HELPER  m_cbhCurrentPropName;   // Pointer to the current name for parsing
    DWORD                   m_nPropsRemaining;      // Used by BMoveToNextProperty() to track end of list.
    CBasePropValueList      m_pvlValues;            // Helper class for value list of current property.

public:
    //
    // Accessor methods.
    //

    // Access the values of the current property
    const CBasePropValueList & RPvlPropertyValue( void )
    {
        return m_pvlValues;

    } //*** RPvlPropertyValue()

    // Access the property list
    operator PCLUSPROP_LIST( void ) const
    {
        return m_cbhPropList.pList;

    } //*** operator PCLUSPROP_LIST()

    // Access allocated size of the buffer
    DWORD CbBufferSize( void ) const
    {
        return m_cbBufferSize;

    } //*** CbBufferSize()

    // Access the name of the current property
    LPCWSTR PszCurrentPropertyName( void ) const
    {
        return m_cbhCurrentPropName.pName->sz;

    } //*** PszCurrentPropertyName()

    // Access the current property name as a buffer helper
    const CLUSPROP_BUFFER_HELPER CbhCurrentPropertyName( void )
    {
        return m_cbhCurrentPropName;

    } //*** CbhCurrentPropertyName()

    // Access value list of the current property as a buffer helper
    const CLUSPROP_BUFFER_HELPER CbhCurrentValueList( void )
    {
        return m_pvlValues.CbhValueList();

    } //*** CbhCurrentValueList()

    // Access current value of the current property as a buffer helper
    const CLUSPROP_BUFFER_HELPER CbhCurrentValue( void )
    {
        return m_pvlValues.CbhCurrentValue();

    } //*** CbhCurrentValue()

    // Access the format of the current value of the current property
    CLUSTER_PROPERTY_FORMAT CpfCurrentValueFormat( void ) const
    {
        return m_pvlValues.CpfCurrentValueFormat();

    } //*** CpfCurrentValueFormat()

    // Access the type of the current value of the current property
    CLUSTER_PROPERTY_TYPE CptCurrentValueType( void ) const
    {
        return m_pvlValues.CptCurrentValueType();

    } //*** CptCurrentValueType()

    // Access the syntax of the current value of the current property
    CLUSTER_PROPERTY_SYNTAX CpsCurrentValueSyntax( void ) const
    {
        return m_pvlValues.CpsCurrentValueSyntax();

    } //*** CpsCurrentValueSyntax()

    // Access the length of the current value of the current property
    DWORD CbCurrentValueLength( void ) const
    {
        return m_pvlValues.CbCurrentValueLength();

    } //*** CbCurrentValueLength()

    PCLUSPROP_LIST Plist( void )
    {
        return m_cbhPropList.pList;

    } //*** Plist()

    const CLUSPROP_BUFFER_HELPER CbhPropList( void ) const
    {
        return m_cbhPropList;

    } //*** CbhPropList()

    PBYTE PbPropList( void ) const
    {
        return m_cbhPropList.pb;

    } //*** PbPropList()

    DWORD CbPropList( void ) const
    {
        return m_cbDataSize + sizeof( CLUSPROP_SYNTAX ); /*endmark*/

    } //*** CbPropList()

    // Access amount of data left in buffer after current value
    DWORD CbDataLeft( void ) const
    {
        return m_cbDataLeft;

    } //*** CbDataLeft()

    DWORD Cprops( void ) const
    {
        if ( m_cbhPropList.pb == NULL )
        {
            return 0;
        } // if:  no buffer yet

        return m_cbhPropList.pList->nPropertyCount;

    } //*** Cprops()

public:
    //
    // Parsing methods.
    //

    // Initialize the size after getting properties from an external source
    void InitSize( IN DWORD cbSize )
    {
        ASSERT( m_cbhPropList.pb != NULL );
        ASSERT( m_cbBufferSize > 0 );

        m_cbDataSize = cbSize;
        m_cbDataLeft = cbSize;

    } //*** InitSize()

    // Move to the first property in the list
    DWORD ScMoveToFirstProperty( void );

    // Move the property after the current one in the list
    DWORD ScMoveToNextProperty( void );

    // Move to a property by specifying its name
    DWORD ScMoveToPropertyByName( IN LPCWSTR pwszPropName );

    // Move to the first value in the current property
    DWORD ScMoveToFirstPropertyValue( void )
    {
        return m_pvlValues.ScMoveToFirstValue();

    } //*** ScMoveToFirstPropertyValue()

    // Move the the value after the current on in the current property
    DWORD ScMoveToNextPropertyValue( void )
    {
        return m_pvlValues.ScMoveToNextValue();

    } //*** ScMoveToNextPropertyValue()

    // Query whether we are at the last property in the list or not
    DWORD ScCheckIfAtLastProperty( void ) const
    {
        DWORD _sc;

        if ( m_nPropsRemaining <= 1 )
        {
            _sc = ERROR_NO_MORE_ITEMS;
        } // if:  at the last property
        else
        {
            _sc = ERROR_SUCCESS;
        } // else:  not at the last property

        return _sc;

    } //*** ScCheckIfAtLastProperty()

    // Query whether the list is empty or not
    BOOL BIsListEmpty( void ) const
    {
        ASSERT( m_cbhPropList.pb != NULL );
        ASSERT( m_cbDataSize >= sizeof( m_cbhPropList.pList->nPropertyCount ) );

        return m_cbhPropList.pList->nPropertyCount == 0;

    } //*** BIsListEmpty()

public:
    //
    // Methods for building a property list.
    //

    // Allocate a property list
    DWORD ScAllocPropList( IN DWORD cbMinimum );

    void ClearPropList( void )
    {
        m_cbDataSize = 0;
        m_cbDataLeft = 0;

        if ( m_cbBufferSize != 0 )
        {
            ZeroMemory( m_cbhPropList.pb, m_cbBufferSize );
            m_cbhCurrentProp.pb = m_cbhPropList.pb + sizeof( m_cbhPropList.pList->nPropertyCount );
            m_cbhCurrentPropName = m_cbhCurrentProp;
        } // if:  buffer already allocated

    } //*** ClearPropList()

    DWORD ScAddProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

    DWORD ScAddExpandSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

    DWORD ScAddMultiSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

    DWORD ScAddProp( IN LPCWSTR pwszName, IN DWORD nValue, IN DWORD nPrevValue );

    DWORD ScAddProp( IN LPCWSTR pwszName, IN LONG nValue, IN LONG nPrevValue );

    DWORD ScAddProp( IN LPCWSTR pwszName, IN ULONGLONG ullValue, IN ULONGLONG ullPrevValue );

    DWORD ScSetPropToDefault( IN LPCWSTR pwszName, IN CLUSTER_PROPERTY_FORMAT propfmt );

    DWORD ScAddProp(
            IN LPCWSTR      pwszName,
            IN const PBYTE  pbValue,
            IN DWORD        cbValue,
            IN const PBYTE  pbPrevValue,
            IN DWORD        cbPrevValue
            );

    DWORD ScAddProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue )
    {
        return ScAddProp( pwszName, pwszValue, NULL );

    } //*** ScAddProp()

    DWORD ScAddExpandSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue )
    {
        return ScAddExpandSzProp( pwszName, pwszValue, NULL );

    } //*** ScAddExpandSzProp()

public:
    //
    // Get Property methods.
    //

    DWORD ScGetProperties(
                        IN CBaseInfo &  cBaseInfo,
                        IN DWORD        dwControlCode,
                        IN HNODE        hHostNode       = NULL,
                        IN LPVOID       lpInBuffer      = NULL,
                        IN DWORD        cbInBufferSize  = 0
                        );

// Implementation
protected:
    void CopyProp(
            IN PCLUSPROP_SZ             pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN LPCWSTR                  psz,
            IN size_t                   cbsz = 0
            );

    void CopyExpandSzProp(
            IN PCLUSPROP_SZ             pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN LPCWSTR                  psz,
            IN size_t                   cbsz = 0
            );

    void CopyMultiSzProp(
            IN PCLUSPROP_MULTI_SZ       pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN LPCWSTR                  psz,
            IN size_t                   cbsz = 0
            );

    void CopyProp(
            IN PCLUSPROP_DWORD          pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN DWORD                    nValue
            );

    void CopyProp(
            IN PCLUSPROP_LONG           pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN LONG                     nValue
            );

    void CopyProp(
            OUT PCLUSPROP_ULARGE_INTEGER    pprop,
            IN  CLUSTER_PROPERTY_TYPE       proptype,
            IN  ULONGLONG                   nValue
            );

    void CopyProp(
            IN PCLUSPROP_BINARY         pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN const PBYTE              pb,
            IN size_t                   cb
            );

    void CopyEmptyProp(
            IN PCLUSPROP_VALUE          pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN CLUSTER_PROPERTY_FORMAT  propfmt
            );

}; //*** class CClusPropList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\common\chandleprovider.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CHandleProvider.h
//
//  Description:
//      HandleProvider implementation.
//
//  Maintained By:
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"

#include "CHandleProvider.h"

DEFINE_THISCLASS("CHandleProvider")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CHandleProvider ::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CHandleProvider::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CHandleProvider  * pcc = new CHandleProvider ;
    if ( pcc != NULL )
    {
        hr = THR( pcc->Init( ) );

        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pcc->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pcc->Release( );
    }
    else
    {
        hr = THR( E_OUTOFMEMORY );
    }

    HRETURN( hr );

} //*** CHandleProvider::S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CHandleProvider::CHandleProvider( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CHandleProvider::CHandleProvider ( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CHandleProvider::CHandleProvider ( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CHandleProvider ::~CHandleProvider( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CHandleProvider::~CHandleProvider( void )
{
    TraceFunc( "" );

    TraceSysFreeString( m_bstrClusterName );

    if( m_hCluster != NULL )
    {
        CloseCluster( m_hCluster );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CHandleProvider::~CHandleProvider ( )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CHandleProvider::Init( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CHandleProvider::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );    // Add one count

    // IClusterHandleProvider
    Assert( m_bstrClusterName == NULL );
    Assert( m_hCluster == NULL );

    HRETURN( hr );

} //*** CHandleProvider ::Init( )



// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CHandleProvider ::QueryInterface(
//      REFIID      riidIn,
//      LPVOID *    ppvOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CHandleProvider::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusterHandleProvider * >( this );
        hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusterHandleProvider ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusterHandleProvider, this, 0 );
        hr = S_OK;
    } // else if: IClusterHandleProvider

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CHandleProvider ::QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CHandleProvider ::AddRef( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CHandleProvider::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CHandleProvider ::AddRef( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CHandleProvider ::Release( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CHandleProvider::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} //*** CHandleProvider ::Release( )


// ************************************************************************
//
// IClusterHandleProvider
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CHandleProvider::OpenCluster(
//      bstrClusterName
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CHandleProvider::OpenCluster(
    BSTR bstrClusterName
    )
{
    TraceFunc( "[IClusterHandleProvider]" );
    Assert( bstrClusterName != NULL );

    HRESULT  hr = S_OK;
    DWORD    sc;
    HCLUSTER hCluster;
    
    hCluster = ::OpenCluster( bstrClusterName );
    
    if( hCluster == NULL )
    {
        sc = GetLastError();
        hr = HRESULT_FROM_WIN32( sc );
        goto Exit;
    }   

    m_hCluster = hCluster;

Exit:

    HRETURN( hr );

} //*** CHandleProvider::OpenCluster()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CHandleProvider ::GetClusterHandle(
//      void ** ppvClusterHandle
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CHandleProvider::GetClusterHandle( 
    HCLUSTER * pphClusterHandleOut
    )
{
    TraceFunc( "[IClusterHandleProvider]" );

    HRESULT hr = S_OK;

    if( pphClusterHandleOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Exit;
    }

    if( m_hCluster == NULL )
    {
        hr = THR( E_FAIL );
        goto Exit;
    }
    
    // Copy the handle.
    *pphClusterHandleOut = m_hCluster;

Exit:

    HRETURN( hr );

} //*** CHandleProvider::GetClusterHandle()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\common\clusterutils.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ClusterUtils.h
//
//  Description:
//      This file contains the implementations of the ClusterUtils
//      functions.
//
//
//  Documentation:
//
//  Maintained By:
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <clusrtl.h>
#include "CBaseInfo.h"
#include "CBasePropList.h"
#include "ClusterUtils.h"

#define STACK_ARRAY_SIZE 256


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSeparateDomainAndName()
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrSeparateDomainAndName(
    BSTR    bstrNameIn,
    BSTR *  pbstrDomainOut,
    BSTR *  pbstrNameOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    WCHAR * psz = NULL;

    if ( bstrNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Exit;
    } // if:

    psz = wcschr( bstrNameIn, L'.' );
    if ( psz == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Exit;
    } // if:

    if ( pbstrDomainOut != NULL )
    {
        psz++;  // skip the .
        *pbstrDomainOut = TraceSysAllocString( psz );
        if ( *pbstrDomainOut == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Exit;
        } // if:

        psz--;  // reset back to .
    } // if:

    if ( pbstrNameOut != NULL )
    {
        *pbstrNameOut = TraceSysAllocStringLen( NULL, (UINT)( psz - bstrNameIn ) );
        if ( *pbstrNameOut == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Exit;
        } // if:

        wcsncpy( *pbstrNameOut, bstrNameIn, ( psz - bstrNameIn) );
    } // if:

Exit:

    HRETURN ( hr );

} //*** HrSeparateDomainAndName()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrAppendDomainToName()
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//      S_OK    = TRUE
//      S_FALSE = FALSE
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrAppendDomainToName(
    BSTR    bstrNameIn,
    BSTR    bstrDomainIn,
    BSTR *  pbstrDomainNameOut
    )
{
    TraceFunc( "" );
    Assert( bstrNameIn != NULL );
    Assert( pbstrDomainNameOut != NULL );

    HRESULT hr = S_OK;
    size_t  cchName = 0;

    if ( pbstrDomainNameOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Exit;
    } // if:

    if ( bstrNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Exit;
    } // if:

    // Create a fully qualified node name
    if ( bstrDomainIn != NULL )
    {
        cchName = wcslen( bstrNameIn ) + wcslen( bstrDomainIn ) + 1;
        Assert( cchName <= MAXDWORD );

        *pbstrDomainNameOut = TraceSysAllocStringLen( NULL, (UINT) cchName );
        if ( *pbstrDomainNameOut == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Exit;
        } // if:

        wcscpy( *pbstrDomainNameOut, bstrNameIn );
        wcscat( *pbstrDomainNameOut, L"." );
        wcscat( *pbstrDomainNameOut, bstrDomainIn );
        hr = S_OK;
    } // if:
    else
    {
        *pbstrDomainNameOut = TraceSysAllocString( bstrNameIn );
        if ( *pbstrDomainNameOut == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Exit;
        } // if:

        hr = S_FALSE;
    } // else:

Exit:

    HRETURN( hr );

} //*** HrAppendDomainToName()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrIsCoreResource()
//
//  Description:
//      Determines whether the resource is a core resource.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK    = TRUE
//      S_FALSE = FALSE
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrIsCoreResource( HRESOURCE hResIn )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;
    DWORD   sc;
    DWORD   dwFlags = 0;
    DWORD   cb;

    sc = TW32( ClusterResourceControl( hResIn, NULL, CLUSCTL_RESOURCE_GET_FLAGS, NULL, 0, &dwFlags, sizeof( dwFlags ), &cb ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Exit;
    } // if:

    if ( dwFlags & CLUS_FLAG_CORE )
    {
        hr = S_OK;
    } // if:

Exit:

    HRETURN( hr );

} //*** HrIsCoreResource()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrIsResourceOfType()
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//      S_OK    = TRUE
//      S_FALSE = FALSE
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrIsResourceOfType(
    HRESOURCE       hResIn,
    const WCHAR *   pszResourceTypeIn
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    DWORD       sc;
    WCHAR *     psz = NULL;
    DWORD       cbpsz = 33;
    DWORD       cb;
    int         idx;

    psz = new WCHAR [ cbpsz * sizeof( WCHAR ) ];
    if ( psz == NULL )
    {
        goto OutOfMemory;
    } // if:

    for ( idx = 0; ; idx++ )
    {
        Assert( idx < 2 );

        sc = ClusterResourceControl( hResIn, NULL, CLUSCTL_RESOURCE_GET_RESOURCE_TYPE, NULL, 0, psz, cbpsz, &cb );
        if ( sc == ERROR_MORE_DATA )
        {
            delete [] psz;
            psz = NULL;

            cbpsz = cb + 1;

            psz = new WCHAR [ cbpsz * sizeof( WCHAR ) ];
            if ( psz == NULL )
            {
                goto OutOfMemory;
            } // if:

            continue;
        } // if:

        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( TW32( sc ) );
            goto CleanUp;
        } // if:

        break;
    } // for:

    if ( wcscmp( psz, pszResourceTypeIn ) == 0 )
    {
        hr = S_OK;
    } // if:
    else
    {
        hr = S_FALSE;
    } // else:

    goto CleanUp;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

CleanUp:

    delete [] psz;

    HRETURN( hr );

} //*** HrIsResourceOfType()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetIPAddressInfo()
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetIPAddressInfo( HRESOURCE hResIn, ULONG * pulIPAddress, ULONG * pulSubnetMask, BSTR * pbstrNetworkName )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    DWORD                       sc;
    CBasePropList               cpl;
    CBaseClusterResourceInfo    cbri;
    CLUSPROP_BUFFER_HELPER      cpbh;

    cbri.m_hResource = hResIn;
    sc = TW32( cpl.ScGetProperties( cbri, cbri.ToCode( CONTROL_GET_PRIVATE_PROPERTIES ) ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    sc = TW32( cpl.ScMoveToPropertyByName( L"Address" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cpl.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    sc = ClRtlTcpipStringToAddress( cpbh.pStringValue->sz, pulIPAddress );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    sc = TW32( cpl.ScMoveToPropertyByName( L"SubnetMask" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cpl.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    sc = ClRtlTcpipStringToAddress( cpbh.pStringValue->sz, pulSubnetMask );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    if( pbstrNetworkName )
    {
        sc = TW32( cpl.ScMoveToPropertyByName( L"Network" ) );
        if ( sc != ERROR_SUCCESS )
        {
            goto MakeHr;
        } // if:

        cpbh = cpl.CbhCurrentValue();
        Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

        *pbstrNetworkName = TraceSysAllocString( cpbh.pStringValue->sz );

        if( *pbstrNetworkName == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto CleanUp;
        }
    }

    goto CleanUp;

MakeHr:

    hr = HRESULT_FROM_WIN32( sc );

CleanUp:

    cbri.m_hResource = NULL;

    HRETURN( hr );

} //*** HrGetIPAddressInfo()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrLoadCredentials()
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrLoadCredentials( BSTR bstrMachine, IClusCfgSetCredentials * piCCSC )
{
    TraceFunc( "" );

    HRESULT                     hr = S_FALSE;
    SC_HANDLE                   schSCM = NULL;
    SC_HANDLE                   schClusSvc = NULL;
    DWORD                       sc;
    DWORD                       cbpqsc = 128;
    DWORD                       cbRequired;
    QUERY_SERVICE_CONFIG *      pqsc = NULL;

    schSCM = OpenSCManager( bstrMachine, NULL, GENERIC_READ );
    if ( schSCM == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( hr );
        goto CleanUp;
    } // if:

    schClusSvc = OpenService( schSCM, L"ClusSvc", GENERIC_READ );
    if ( schClusSvc == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( hr );
        goto CleanUp;
    } // if:

    for ( ; ; )
    {
        pqsc = (QUERY_SERVICE_CONFIG *) TraceAlloc( 0, cbpqsc );
        if ( pqsc == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto CleanUp;
        } // if:

        if ( !QueryServiceConfig( schClusSvc, pqsc, cbpqsc, &cbRequired ) )
        {
            sc = GetLastError();
            if ( sc == ERROR_INSUFFICIENT_BUFFER )
            {
                TraceFree( pqsc );
                pqsc = NULL;
                cbpqsc = cbRequired;
                continue;
            } // if:
            else
            {
                TW32( sc );
                hr = HRESULT_FROM_WIN32( sc );
                goto CleanUp;
            } // else:
        } // if:
        else
        {
            break;
        } // else:
    } // for:

    hr = THR( piCCSC->SetDomainCredentials( pqsc->lpServiceStartName ) );

CleanUp:

    if ( schClusSvc != NULL )
    {
        CloseServiceHandle( schClusSvc );
    } // if:

    if ( schSCM != NULL )
    {
        CloseServiceHandle( schSCM );
    } // if:

    if ( pqsc != NULL )
    {
        TraceFree( pqsc );
    } // if:

    HRETURN( hr );

} //*** HrLoadCredentials()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrGetNodeNameHostingResource(
//      HCLUSTER  hCluster,
//      HRESOURCE hRes,
//      BSTR * pbstrNameOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetNodeNameHostingResource(
    HCLUSTER    hClusterIn,
    HRESOURCE   hResIn,
    BSTR *      pbstrNameOut
    )
{
    TraceFunc( "" );

    WCHAR   pszNodeBuffer[STACK_ARRAY_SIZE];
    WCHAR   pszGroupBuffer[STACK_ARRAY_SIZE];

    DWORD sc;
    HRESULT hr = S_OK;

    BSTR bstrGroupName = NULL;
    BSTR bstrNodeName  = NULL;

    DWORD dwNodeNameLen;
    DWORD dwGroupNameLen;

    HGROUP hGroup = NULL;

    Assert( hClusterIn != NULL );

    // Get the name and the group of the cluster.
    dwNodeNameLen  = STACK_ARRAY_SIZE;
    dwGroupNameLen = STACK_ARRAY_SIZE;
    sc = GetClusterResourceState( hResIn, pszNodeBuffer, &dwNodeNameLen, pszGroupBuffer, &dwGroupNameLen );

    // Check to see if they were available and fit into the memory we allocated.
    if( dwNodeNameLen == 0 && dwGroupNameLen == 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if ( dwNodeNameLen != 0 && dwNodeNameLen < STACK_ARRAY_SIZE )
    {
        bstrNodeName = TraceSysAllocString( pszNodeBuffer );
        if( bstrNodeName == NULL)
            goto OutOfMemory;

        goto Success;
    }

    if ( dwGroupNameLen != 0 && dwGroupNameLen < STACK_ARRAY_SIZE )
    {
        bstrGroupName = TraceSysAllocString( pszGroupBuffer );
        if( bstrGroupName == NULL)
            goto OutOfMemory;
    }

    // Allocate memory and try again.
    if( bstrNodeName == NULL )
    {
        bstrNodeName  = TraceSysAllocStringByteLen( NULL, sizeof(WCHAR) * ( dwNodeNameLen + 2 ) );

        if( bstrNodeName == NULL)
            goto OutOfMemory;
    }

    if( bstrGroupName == NULL )
    {
        bstrGroupName = TraceSysAllocStringByteLen( NULL, sizeof(WCHAR) * ( dwGroupNameLen + 2 ) );

        if( bstrGroupName == NULL)
            goto OutOfMemory;
    }

    //
    // Retrieve a second time.
    //
    dwNodeNameLen  = SysStringLen( bstrNodeName );
    dwGroupNameLen = SysStringLen( bstrGroupName );
    sc = GetClusterResourceState( hResIn, pszNodeBuffer, &dwNodeNameLen, pszGroupBuffer, &dwGroupNameLen );

    if( dwNodeNameLen  != 0 )
        goto Success;

    if( dwGroupNameLen == 0 )
        goto Cleanup;


    //
    // If we don't have the name yet, we have to look up the
    // group name and figure out where it lives.
    //

    hGroup = OpenClusterGroup( hClusterIn, bstrGroupName );
    if( hGroup == NULL )
        goto Win32Error;

    dwNodeNameLen = STACK_ARRAY_SIZE;
    sc = GetClusterGroupState( hGroup, pszNodeBuffer, &dwNodeNameLen );
    if( dwNodeNameLen == 0 )
    {
        if( sc == ClusterGroupStateUnknown )
            goto Win32Error;

        hr = E_FAIL;
        goto Cleanup;
    }
    else if( dwNodeNameLen < STACK_ARRAY_SIZE )
    {
        bstrNodeName = TraceSysAllocString( pszNodeBuffer );

        if( bstrNodeName == NULL)
            goto OutOfMemory;
    }
    else
    {
        bstrNodeName  = TraceSysAllocStringByteLen( NULL, sizeof(WCHAR) * ( dwNodeNameLen + 2 ) );
        dwNodeNameLen  = SysStringLen( bstrNodeName );

        if( bstrNodeName == NULL)
            goto OutOfMemory;

        sc = GetClusterGroupState( hGroup, bstrNodeName, &dwNodeNameLen );

        if( dwNodeNameLen == 0 )
        {
            if( sc == ClusterGroupStateUnknown )
                goto Win32Error;

            hr = E_FAIL;
            goto Cleanup;
        }
    }


Success:
    hr = S_OK;

    *pbstrNameOut = bstrNodeName;
    bstrNodeName = NULL;

Cleanup:
    if( hGroup != NULL )
    {
        CloseClusterGroup( hGroup );
    }

    if( bstrGroupName )
    {
        TraceSysFreeString( bstrGroupName );
    }

    if( bstrNodeName )
    {
        TraceSysFreeString( bstrNodeName );
    }

    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

Win32Error:
    hr = HRESULT_FROM_WIN32( GetLastError() );
    goto Cleanup;

} //*** HrGetNodeNameHostingResource()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrGetDependentIPAddressInfo(
//      HCLUSTER hClusterIn,
//      ULONG * pulIPAddress,
//      ULONG * pulSubnetMask
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetDependentIPAddressInfo(
    HCLUSTER    hClusterIn,
    HRESOURCE   hResIn,
    ULONG     * pulIPAddress,
    ULONG     * pulSubnetMask,
    BSTR      * pbstrNetworkName
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_FALSE;
    DWORD       sc;
    HRESENUM    hEnum = NULL;
    DWORD       idx;
    WCHAR *     psz = NULL;
    DWORD       cchpsz = 33;
    DWORD       dwType;
    HRESOURCE   hRes = NULL;

    hEnum = ClusterResourceOpenEnum( hResIn, CLUSTER_RESOURCE_ENUM_DEPENDS );
    if ( hEnum == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto CleanUp;
    } // if:

    psz = new WCHAR [ cchpsz ];
    if ( psz == NULL )
    {
        goto OutOfMemory;
    } // if:

    for ( idx = 0; ; )
    {
        sc = TW32( ClusterResourceEnum( hEnum, idx, &dwType, psz, &cchpsz ) );
        if ( sc == ERROR_NO_MORE_ITEMS )
        {
            break;
        } // if:

        if ( sc == ERROR_MORE_DATA )
        {
            delete [] psz;
            psz = NULL;

            cchpsz++;

            psz = new WCHAR [ cchpsz ];
            if ( psz == NULL )
            {
                goto OutOfMemory;
            } // if:

            continue;
        } // if:

        if ( sc == ERROR_SUCCESS )
        {
            hRes = OpenClusterResource( hClusterIn, psz );
            if ( hRes == NULL )
            {
                sc = TW32( GetLastError() );
                hr = HRESULT_FROM_WIN32( sc );
                goto CleanUp;
            } // if:

            hr = THR( HrIsResourceOfType( hRes, L"IP Address" ) );
            if ( SUCCEEDED( hr ) )
            {
                hr = THR( HrGetIPAddressInfo( hRes, pulIPAddress, pulSubnetMask, pbstrNetworkName ) );             // not recursive!
                goto CleanUp;
            } // if:

            CloseClusterResource( hRes );
            hRes = NULL;

            idx++;
            continue;
        } // if:

        hr = THR( HRESULT_FROM_WIN32( sc ) );       // must be an error!
        goto CleanUp;
    } // for:

    goto CleanUp;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

CleanUp:

    delete [] psz;

    if ( hRes != NULL )
    {
        CloseClusterResource( hRes );
    } // if:

    if ( hEnum != NULL )
    {
        ClusterResourceCloseEnum( hEnum );
    } // if:

    HRETURN( hr );

} //*** HrGetDependentIPAddressInfo()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrGetIPAddressOfCluster(
//      HCLUSTER hClusterIn,
//      ULONG * pulIPAddress,
//      ULONG * pulSubnetMask
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetIPAddressOfCluster( HCLUSTER hClusterIn, ULONG * pulIPAddress, ULONG * pulSubnetMask, BSTR * pbstrNetworkName )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    DWORD       sc;
    HCLUSENUM   hEnum = NULL;
    DWORD       idx;
    DWORD       dwType;
    WCHAR *     psz = NULL;
    DWORD       cchpsz = 33;
    HRESOURCE   hRes = NULL;

    hEnum = ClusterOpenEnum( hClusterIn, CLUSTER_ENUM_RESOURCE );
    if ( hEnum == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto CleanUp;
    } // if:

    psz = new WCHAR [ cchpsz ];
    if ( psz == NULL )
    {
        goto OutOfMemory;
    } // if:

    for ( idx = 0; ; )
    {
        sc = ClusterEnum( hEnum, idx, &dwType, psz, &cchpsz );
        if ( sc == ERROR_MORE_DATA )
        {
            delete [] psz;
            psz = NULL;

            cchpsz++;

            psz = new WCHAR [ cchpsz ];
            if ( psz == NULL )
            {
                goto OutOfMemory;
            } // if:

            continue;
        } // if:

        if ( sc == ERROR_SUCCESS )
        {
            hRes = OpenClusterResource( hClusterIn, psz );
            if ( hRes == NULL )
            {
                sc = TW32( GetLastError() );
                hr = HRESULT_FROM_WIN32( sc );
                goto CleanUp;
            } // if:

            hr = STHR( HrIsResourceOfType( hRes, L"Network Name" ) );
            if ( FAILED( hr ) )
            {
                break;
            } // if:

            if ( hr == S_OK )
            {
                hr = STHR( HrIsCoreResource( hRes ) );
                if ( FAILED( hr ) )
                {
                    break;
                } // if:

                if ( hr == S_OK )
                {
                    hr = THR( HrGetDependentIPAddressInfo( hClusterIn, hRes, pulIPAddress, pulSubnetMask, pbstrNetworkName ) );
                    if ( FAILED( hr ) )
                    {
                        break;
                    } // if:
                } // if:
            } // if:

            CloseClusterResource( hRes );
            hRes = NULL;

            idx++;
            continue;
        } // if:

        if ( sc == ERROR_NO_MORE_ITEMS )
        {
            hr = S_OK;
            break;
        } // if:

        TW32( sc );
        hr = HRESULT_FROM_WIN32( sc );
        break;
    } // for:

    goto CleanUp;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

CleanUp:

    delete [] psz;

    if ( hRes != NULL )
    {
        CloseClusterResource( hRes );
    } // if:

    if ( hEnum != NULL )
    {
        ClusterCloseEnum( hEnum );
    } // if:

    HRETURN( hr );

} //*** HrGetIPAddressOfCluster()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetNodeNameHostingCluster()
//
//  Description:
//      Get the name of the node hosting the cluster service...
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetNodeNameHostingCluster( HCLUSTER hClusterIn, BSTR * pbstrNodeName )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    DWORD       sc;
    HCLUSENUM   hEnum = NULL;
    DWORD       idx;
    DWORD       dwType;
    WCHAR *     psz = NULL;
    DWORD       cchpsz = 33;
    HRESOURCE   hRes = NULL;

    hEnum = ClusterOpenEnum( hClusterIn, CLUSTER_ENUM_RESOURCE );
    if ( hEnum == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto CleanUp;
    } // if:

    psz = new WCHAR [ cchpsz ];
    if ( psz == NULL )
    {
        goto OutOfMemory;
    } // if:

    for ( idx = 0; ; )
    {
        sc = ClusterEnum( hEnum, idx, &dwType, psz, &cchpsz );
        if ( sc == ERROR_MORE_DATA )
        {
            delete [] psz;
            psz = NULL;

            cchpsz++;

            psz = new WCHAR [ cchpsz ];
            if ( psz == NULL )
            {
                goto OutOfMemory;
            } // if:

            continue;
        } // if:

        if ( sc == ERROR_SUCCESS )
        {
            hRes = OpenClusterResource( hClusterIn, psz );
            if ( hRes == NULL )
            {
                sc = TW32( GetLastError() );
                hr = HRESULT_FROM_WIN32( sc );
                goto CleanUp;
            } // if:

            hr = STHR( HrIsResourceOfType( hRes, L"Network Name" ) );
            if ( FAILED( hr ) )
            {
                break;
            } // if:

            if ( hr == S_OK )
            {
                hr = THR( HrIsCoreResource( hRes ) );
                if ( FAILED( hr ) )
                {
                    break;
                } // if:


                if ( hr == S_OK )
                {
                    hr = THR( HrGetNodeNameHostingResource( hClusterIn, hRes, pbstrNodeName ) );
                    if ( FAILED( hr ) )
                    {
                        break;
                    } // if:
                    else if( hr == S_OK )
                    {
                        goto CleanUp;
                    }
                } // if:

            } // if:

            CloseClusterResource( hRes );
            hRes = NULL;

            idx++;
            continue;
        } // if:

        if ( sc == ERROR_NO_MORE_ITEMS )
        {
            hr = S_OK;
            break;
        } // if:

        TW32( sc );
        hr = HRESULT_FROM_WIN32( sc );
        break;
    } // for:

    goto CleanUp;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

CleanUp:

    delete [] psz;

    if ( hRes != NULL )
    {
        CloseClusterResource( hRes );
    } // if:

    if ( hEnum != NULL )
    {
        ClusterCloseEnum( hEnum );
    } // if:

    HRETURN( hr );

} //*** HrGetNodeNameHostingCluster()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetSCSIInfo()
//
//  Description:
//      Get the name of the node hosting the cluster service...
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetSCSIInfo(
      HRESOURCE hResIn,
      CLUS_SCSI_ADDRESS  * pCSAOut,
      DWORD              * pdwSignatureOut,
      DWORD              * pdwDiskNumberOut
      )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    DWORD                       sc;
    CBasePropValueList          cpvl;
    CBaseClusterResourceInfo    cbri;

    CLUSPROP_BUFFER_HELPER      cpbh;

    cbri.m_hResource = hResIn;

    sc = TW32( cpvl.ScGetValueList( cbri, CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:


    // loop through all the properties.
    sc = cpvl.ScMoveToFirstValue();
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:


    do
    {
        if( sc != ERROR_SUCCESS )
            goto MakeHr;

        cpbh = cpvl;

        switch ( cpbh.pSyntax->dw )
        {
            case CLUSPROP_SYNTAX_PARTITION_INFO :
            {
                break;
            } // case: CLUSPROP_SYNTAX_PARTITION_INFO

            case CLUSPROP_SYNTAX_DISK_SIGNATURE :
            {
                *pdwSignatureOut = cpbh.pDiskSignatureValue->dw;
                break;
            } // case: CLUSPROP_SYNTAX_DISK_SIGNATURE

            case CLUSPROP_SYNTAX_SCSI_ADDRESS :
            {
                pCSAOut->dw = cpbh.pScsiAddressValue->dw;
                break;
            } // case: CLUSPROP_SYNTAX_SCSI_ADDRESS

            case CLUSPROP_SYNTAX_DISK_NUMBER :
            {
                *pdwDiskNumberOut = cpbh.pDiskNumberValue->dw;
                break;
            } // case:

        } // switch:

        // Move to the next item.
        sc = cpvl.ScCheckIfAtLastValue();
        if( sc == ERROR_NO_MORE_ITEMS )
           break;

        sc = cpvl.ScMoveToNextValue();

    } while( sc == ERROR_SUCCESS );


    hr = S_OK;

Cleanup:
    cbri.m_hResource = NULL;

    HRETURN( hr );

MakeHr:
    sc = GetLastError();
    hr = HRESULT_FROM_WIN32( sc );
    goto Cleanup;

} //*** HrGetSCSIInfo()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetClusterInformation()
//
//  Description:
//      Get the cluster information.  This includes the name and the version
//      info.
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetClusterInformation(
    HCLUSTER                hClusterIn,
    BSTR *                  pbstrClusterNameOut,
    CLUSTERVERSIONINFO *    pcviOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    DWORD               sc;
    WCHAR *             psz = NULL;
    DWORD               cch = 33;
    CLUSTERVERSIONINFO  cvi;

    if ( pbstrClusterNameOut == NULL )
    {
        goto Pointer;
    } // if:

    cvi.dwVersionInfoSize = sizeof( cvi );

    if ( pcviOut == NULL )
    {
        pcviOut = &cvi;
    } // if:

    psz = new WCHAR[ cch ];
    if ( psz == NULL )
    {
        goto OutOfMemory;
    } // if:

    sc = GetClusterInformation( hClusterIn, psz, &cch, pcviOut );
    if ( sc == ERROR_MORE_DATA )
    {
        delete [] psz;
        psz = NULL;

        psz = new WCHAR[ ++cch ];
        if ( psz == NULL )
        {
            goto OutOfMemory;
        } // if:

        sc = GetClusterInformation( hClusterIn, psz, &cch, pcviOut );
    } // if:

    if ( sc != ERROR_SUCCESS )
    {
        hr = THR( HRESULT_FROM_WIN32( sc ) );
        LogMsg( __FUNCTION__ ": GetClusterInformation() failed (hr = 0x%08x).", hr );
        goto Cleanup;
    } // if:

    *pbstrClusterNameOut = TraceSysAllocString( psz );
    if ( *pbstrClusterNameOut == NULL )
    {
        goto OutOfMemory;
    } // if:

    goto Cleanup;

Pointer:

    hr = THR( E_POINTER );
    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

Cleanup:

    delete [] psz;

    HRETURN( hr );

} //*** HrGetClusterInformation()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetClusterResourceState
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetClusterResourceState(
      HRESOURCE                 hResourceIn
    , BSTR *                    pbstrNodeNameOut
    , BSTR *                    pbstrGroupNameOut
    , CLUSTER_RESOURCE_STATE *  pcrsStateOut
    )
{
    TraceFunc( "" );
    Assert( hResourceIn != NULL );

    HRESULT                 hr = S_OK;
    CLUSTER_RESOURCE_STATE  crsState = ClusterResourceStateUnknown;
    WCHAR *                 pszNodeName = NULL;
    DWORD                   cchNodeName = 33;
    WCHAR *                 pszGroupName = NULL;
    DWORD                   cchGroupName = 33;

    pszNodeName = new WCHAR[ cchNodeName ];
    if ( pszNodeName == NULL )
    {
        goto OutOfMemory;
    } // if:

    pszGroupName = new WCHAR[ cchGroupName ];
    if ( pszGroupName == NULL )
    {
        goto OutOfMemory;
    } // if:

    crsState = GetClusterResourceState( hResourceIn, pszNodeName, &cchNodeName, pszGroupName, &cchGroupName );
    if ( GetLastError() == ERROR_MORE_DATA )
    {
        crsState = ClusterResourceStateUnknown;   // reset to error condition

        delete [] pszNodeName;
        pszNodeName = NULL;
        cchNodeName++;

        delete [] pszGroupName;
        pszGroupName = NULL;
        cchGroupName++;

        pszNodeName = new WCHAR[ cchNodeName ];
        if ( pszNodeName == NULL )
        {
            goto OutOfMemory;
        } // if:

        pszGroupName = new WCHAR[ cchGroupName ];
        if ( pszGroupName == NULL )
        {
            goto OutOfMemory;
        } // if:

        crsState = GetClusterResourceState( hResourceIn, pszNodeName, &cchNodeName, pszGroupName, &cchGroupName );
        if ( crsState == ClusterResourceStateUnknown )
        {
            DWORD   sc;

            sc = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // if:
    } // if: more data

    if ( pbstrNodeNameOut != NULL )
    {
        *pbstrNodeNameOut = TraceSysAllocString( pszNodeName );
        if ( *pbstrNodeNameOut == NULL )
        {
            goto OutOfMemory;
        } // if:
    } // if:

    if ( pbstrGroupNameOut != NULL )
    {
        *pbstrGroupNameOut = TraceSysAllocString( pszGroupName );
        if ( *pbstrGroupNameOut == NULL )
        {
            goto OutOfMemory;
        } // if:
    } // if:

    if ( pcrsStateOut != NULL )
    {
        *pcrsStateOut = crsState;
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

Cleanup:

    delete [] pszNodeName;
    delete [] pszGroupName;

    HRETURN( hr );

} //*** HrGetClusterResourceState


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetClusterQuorumResource()
//
//  Description:
//      Get the information about the quorum resource.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT error codes.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetClusterQuorumResource(
      HCLUSTER  hClusterIn
    , BSTR *    pbstrResourceNameOut
    , BSTR *    pbstrDeviceNameOut
    , DWORD *   pdwMaxQuorumLogSizeOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   sc;
    LPWSTR  pszResourceName = NULL;
    DWORD   cchResourceName = 128;
    DWORD   cchTempResourceName = cchResourceName;
    LPWSTR  pszDeviceName = NULL;
    DWORD   cchDeviceName = 128;
    DWORD   cchTempDeviceName = cchDeviceName;
    DWORD   dwMaxQuorumLogSize = 0;

    if ( hClusterIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    // Allocate the resource name buffer
    pszResourceName = new WCHAR[ cchResourceName ];
    if ( pszResourceName == NULL )
    {
        goto OutOfMemory;
    } // if:

    // Allocate the device name buffer
    pszDeviceName = new WCHAR[ cchDeviceName ];
    if ( pszDeviceName == NULL )
    {
        goto OutOfMemory;
    } // if:

    sc = GetClusterQuorumResource(
                              hClusterIn
                            , pszResourceName
                            , &cchTempResourceName
                            , pszDeviceName
                            , &cchTempDeviceName
                            , &dwMaxQuorumLogSize
                            );
    if ( sc == ERROR_MORE_DATA )
    {
        delete [] pszResourceName;
        pszResourceName = NULL;

        cchResourceName = ++cchTempResourceName;

        // Allocate the resource name buffer
        pszResourceName = new WCHAR[ cchResourceName ];
        if ( pszResourceName == NULL )
        {
            goto OutOfMemory;
        } // if:

        delete [] pszDeviceName;
        pszDeviceName = NULL;

        cchDeviceName = ++cchTempDeviceName;

        // Allocate the device name buffer
        pszDeviceName = new WCHAR[ cchDeviceName ];
        if ( pszDeviceName == NULL )
        {
            goto OutOfMemory;
        } // if:

        sc = GetClusterQuorumResource(
                                  hClusterIn
                                , pszResourceName
                                , &cchTempResourceName
                                , pszDeviceName
                                , &cchTempDeviceName
                                , &dwMaxQuorumLogSize
                                );
    } // if:

    if ( sc != ERROR_SUCCESS )
    {
        TW32( sc );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    if ( pbstrResourceNameOut != NULL )
    {
        *pbstrResourceNameOut = TraceSysAllocString( pszResourceName );
        if ( *pbstrResourceNameOut == NULL )
        {
            goto OutOfMemory;
        } // if:
    } // if:

    if ( pbstrDeviceNameOut != NULL )
    {
        *pbstrDeviceNameOut = TraceSysAllocString( pszDeviceName );
        if ( *pbstrDeviceNameOut == NULL )
        {
            goto OutOfMemory;
        } // if:
    } // if:

    if ( pdwMaxQuorumLogSizeOut != NULL )
    {
        *pdwMaxQuorumLogSizeOut = dwMaxQuorumLogSize;
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

Cleanup:

    delete [] pszResourceName;
    delete [] pszDeviceName;

    HRETURN( hr );

} //*** HrGetClusterQuorumResource()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\common\nameutil.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      NameUtil.cpp
//
//  Description:
//      Name resolution utility.
//
//  Maintained By:
//      Galen Barbee (GalenB) 28-NOV-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "nameutil.h"

#include <initguid.h>

// {6968D735-ADBB-4748-A36E-7CEE0FE21116}
DEFINE_GUID( TASKID_Minor_Multiple_DNS_Records_Found,
0x6968d735, 0xadbb, 0x4748, 0xa3, 0x6e, 0x7c, 0xee, 0xf, 0xe2, 0x11, 0x16);

// {D86FAAD9-2514-451e-B359-435AF35E6038}
DEFINE_GUID( TASKID_Minor_FQDN_DNS_Binding_Succeeded,
0xd86faad9, 0x2514, 0x451e, 0xb3, 0x59, 0x43, 0x5a, 0xf3, 0x5e, 0x60, 0x38);

// {B2359972-F6B8-433d-949B-DB1CEE009321}
DEFINE_GUID( TASKID_Minor_FQDN_DNS_Binding_Failed,
0xb2359972, 0xf6b8, 0x433d, 0x94, 0x9b, 0xdb, 0x1c, 0xee, 0x0, 0x93, 0x21);

// {2FF4B2F0-800C-44db-9131-F60B30F76CB4}
DEFINE_GUID( TASKID_Minor_NETBIOS_Binding_Failed,
0x2ff4b2f0, 0x800c, 0x44db, 0x91, 0x31, 0xf6, 0xb, 0x30, 0xf7, 0x6c, 0xb4);

// {D40532E1-9286-4dbd-A559-B62DCC218929}
DEFINE_GUID( TASKID_Minor_NETBIOS_Binding_Succeeded,
0xd40532e1, 0x9286, 0x4dbd, 0xa5, 0x59, 0xb6, 0x2d, 0xcc, 0x21, 0x89, 0x29);

// {D0AB3284-8F62-4f55-8938-DA6A583604E0}
DEFINE_GUID( TASKID_Minor_NETBIOS_Name_Conversion_Succeeded,
0xd0ab3284, 0x8f62, 0x4f55, 0x89, 0x38, 0xda, 0x6a, 0x58, 0x36, 0x4, 0xe0);

// {66F8E4AA-DF71-4973-A4A3-115EB6FE9986}
DEFINE_GUID( TASKID_Minor_NETBIOS_Name_Conversion_Failed,
0x66f8e4aa, 0xdf71, 0x4973, 0xa4, 0xa3, 0x11, 0x5e, 0xb6, 0xfe, 0x99, 0x86);

// {5F18ED71-07EC-46d3-ADB9-71F1C7794DB2}
DEFINE_GUID( TASKID_Minor_NETBIOS_Reset_Failed,
0x5f18ed71, 0x7ec, 0x46d3, 0xad, 0xb9, 0x71, 0xf1, 0xc7, 0x79, 0x4d, 0xb2);

// {A6DCB5E1-1FDF-4c94-ADBA-EE18F72B8197}
DEFINE_GUID( TASKID_Minor_NETBIOS_LanaEnum_Failed,
0xa6dcb5e1, 0x1fdf, 0x4c94, 0xad, 0xba, 0xee, 0x18, 0xf7, 0x2b, 0x81, 0x97);



//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  HrCreateBinding(
//      IClusCfgCallback *  pcccbIn,
//      CLSID * pclsidLogIn,
//      BSTR    bstrNameIn,
//      BSTR *  pbstrBindingOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrCreateBinding(
    IClusCfgCallback *  pcccbIn,
    const CLSID *       pclsidLogIn,
    BSTR                bstrNameIn,
    BSTR *              pbstrBindingOut
    )
{
    TraceFunc1( "bstrNameIn = '%ws'", bstrNameIn );

    DNS_STATUS  status;
    DWORD       cch;
    BOOL        bRet;
    bool        fMadeNetBIOSName = false;
    WCHAR       szNetBIOSName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    UCHAR       rgucNameBufer[ sizeof( FIND_NAME_HEADER ) + sizeof( FIND_NAME_BUFFER ) ];
    NCB         ncb;
    LANA_ENUM   leLanaEnum;
    UCHAR       idx;

    FIND_NAME_HEADER * pfnh = (FIND_NAME_HEADER *) &rgucNameBufer[ 0 ];
    FIND_NAME_BUFFER * pfnb = (FIND_NAME_BUFFER *) &rgucNameBufer[ sizeof( FIND_NAME_HEADER ) ];

    HRESULT hr = E_FAIL;

    PDNS_RECORD pResults = NULL;

    BSTR    bstrNotification = NULL;
    BSTR    bstrNetBiosName = NULL;

    Assert( bstrNameIn != NULL );
    Assert( pbstrBindingOut != NULL );
    Assert( *pbstrBindingOut == NULL );

    status = DnsQuery( bstrNameIn, DNS_TYPE_A, DNS_QUERY_STANDARD, NULL, &pResults, NULL );
    if ( status == ERROR_SUCCESS )
    {
        LPSTR pszIP;

        pszIP = inet_ntoa( * (struct in_addr *) &pResults->Data.A.IpAddress );

        *pbstrBindingOut = TraceSysAllocStringLen( NULL, (UINT) strlen( pszIP ) + 1 );
        if ( *pbstrBindingOut == NULL )
            goto OutOfMemory;

        mbstowcs( *pbstrBindingOut, pszIP, strlen( pszIP ) + 1 );

        if ( pResults->pNext != NULL )
        {
            if ( pcccbIn != NULL )
            {
                THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_MULTIPLE_DNS_RECORDS_FOUND, &bstrNotification, bstrNameIn ) );

                hr = THR( pcccbIn->SendStatusReport( bstrNameIn,
                                                     *pclsidLogIn,
                                                     TASKID_Minor_Multiple_DNS_Records_Found,
                                                     0,
                                                     1,
                                                     1,
                                                     S_FALSE,
                                                     bstrNotification,
                                                     NULL,
                                                     NULL
                                                     ) );
                //  ignore error
            }
        }

        if ( pcccbIn != NULL )
        {
            THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_FQDN_DNS_BINDING_SUCCEEDED, &bstrNotification, bstrNameIn, *pbstrBindingOut ) );

            hr = THR( pcccbIn->SendStatusReport( bstrNameIn,
                                                 *pclsidLogIn,
                                                 TASKID_Minor_FQDN_DNS_Binding_Succeeded,
                                                 0,
                                                 1,
                                                 1,
                                                 S_OK,
                                                 bstrNotification,
                                                 NULL,
                                                 NULL
                                                 ) );
        }
        else
        {
            hr = S_OK;
        }

        goto Cleanup;   // done!
    } // if: DnsQuery() succeeded
    else if ( status == DNS_ERROR_RCODE_NAME_ERROR )
    {
        if ( pcccbIn != NULL )
        {
            THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_FQDN_DNS_BINDING_FAILED, &bstrNotification, bstrNameIn ) );

            hr = THR( pcccbIn->SendStatusReport( bstrNameIn,
                                                 TASKID_Major_Client_And_Server_Log,
                                                 TASKID_Minor_FQDN_DNS_Binding_Failed,
                                                 0,
                                                 1,
                                                 1,
                                                 MAKE_HRESULT( 0, FACILITY_WIN32, status ),
                                                 bstrNotification,
                                                 NULL,
                                                 NULL
                                                 ) );
            if ( FAILED( hr ) )
                goto Cleanup;
        }

        cch = ARRAYSIZE( szNetBIOSName );
        Assert( cch == MAX_COMPUTERNAME_LENGTH + 1 );
        bRet = DnsHostnameToComputerName( bstrNameIn, szNetBIOSName, &cch );
        if ( !bRet )
        {
            hr = MAKE_HRESULT( 0, FACILITY_WIN32, TW32( GetLastError() ) );

            if ( pcccbIn != NULL )
            {
                THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_NETBIOS_NAME_CONVERSION_FAILED, &bstrNotification ) );

                hr = THR( pcccbIn->SendStatusReport( bstrNameIn,
                                                     *pclsidLogIn,
                                                     TASKID_Minor_NETBIOS_Name_Conversion_Failed,
                                                     0,
                                                     1,
                                                     1,
                                                     hr,
                                                     bstrNotification,
                                                     NULL,
                                                     NULL
                                                     ) );
                if ( FAILED( hr ) )
                    goto Cleanup;
            }

            goto SkipNetBios;
        }

        bstrNetBiosName = TraceSysAllocString( szNetBIOSName );
        if ( bstrNetBiosName == NULL )
            goto OutOfMemory;

        if ( pcccbIn != NULL )
        {
            THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_NETBIOS_NAME_CONVERSION_SUCCEEDED, &bstrNotification, bstrNameIn, bstrNetBiosName ) );

            hr = THR( pcccbIn->SendStatusReport( bstrNameIn,
                                                 TASKID_Major_Client_And_Server_Log,
                                                 TASKID_Minor_NETBIOS_Name_Conversion_Succeeded,
                                                 0,
                                                 1,
                                                 1,
                                                 S_OK,
                                                 bstrNotification,
                                                 NULL,
                                                 NULL
                                                 ) );
            if ( FAILED( hr ) )
                goto Cleanup;
        }

        //
        //  Try to find the name using NetBIOS.
        //

        ZeroMemory( &ncb, sizeof( ncb ) );

        //
        //  Enumerate the network adapters
        //
        ncb.ncb_command = NCBENUM;          // Enumerate LANA nums (wait)
        ncb.ncb_buffer = (PUCHAR) &leLanaEnum;
        ncb.ncb_length = sizeof( LANA_ENUM );

        Netbios( &ncb );
        if ( ncb.ncb_retcode != NRC_GOODRET )
        {
            hr = MAKE_HRESULT( 0, FACILITY_NULL, ncb.ncb_retcode );

            if ( pcccbIn != NULL )
            {
                THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_NETBIOS_LANAENUM_FAILED, &bstrNotification ) );

                hr = THR( pcccbIn->SendStatusReport( bstrNameIn,
                                                     TASKID_Major_Client_And_Server_Log,
                                                     TASKID_Minor_NETBIOS_LanaEnum_Failed,
                                                     0,
                                                     1,
                                                     1,
                                                     hr,
                                                     bstrNotification,
                                                     NULL,
                                                     NULL
                                                     ) );
                if ( FAILED( hr ) )
                    goto Cleanup;
            } // if:

            goto SkipNetBios;
        } // if:

        //
        //  Reset each adapter and try to find the name.
        //
        for ( idx = 0; idx < leLanaEnum.length; idx++ )
        {
            //
            //  Reset the adapter
            //
            ncb.ncb_command     = NCBRESET;
            ncb.ncb_lana_num    = leLanaEnum.lana[ idx ];

            Netbios( &ncb );
            if ( ncb.ncb_retcode != NRC_GOODRET )
            {
                hr = MAKE_HRESULT( 0, FACILITY_NULL, ncb.ncb_retcode );

                if ( pcccbIn != NULL )
                {
                    THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_NETBIOS_RESET_FAILED, &bstrNotification ) );

                    hr = THR( pcccbIn->SendStatusReport( bstrNameIn,
                                                         TASKID_Major_Client_And_Server_Log,
                                                         TASKID_Minor_NETBIOS_Reset_Failed,
                                                         0,
                                                         1,
                                                         1,
                                                         hr,
                                                         bstrNotification,
                                                         NULL,
                                                         NULL
                                                         ) );
                    if ( FAILED( hr ) )
                        goto Cleanup;
                }

                //
                //  Continue with the next adapter.
                //
                continue;
            }

            ncb.ncb_command = NCBFINDNAME;
            ncb.ncb_buffer = rgucNameBufer;
            ncb.ncb_length = sizeof( rgucNameBufer );

            pfnh->node_count = 1;

            //  Fill with spaces
            memset( ncb.ncb_callname, 32, sizeof( ncb.ncb_callname ) );

            wcstombs( (CHAR *) ncb.ncb_callname, szNetBIOSName, wcslen( szNetBIOSName ) );

            Netbios( &ncb );

            if ( ncb.ncb_retcode == NRC_GOODRET )
            {
                LPSTR           pszIP;
                struct in_addr  sin;

                sin.S_un.S_addr = *((u_long UNALIGNED *) &pfnb->source_addr[ 2 ]);

                pszIP = inet_ntoa( sin );

                *pbstrBindingOut = TraceSysAllocStringLen( NULL, (UINT) strlen( pszIP ) + 1 );
                if ( *pbstrBindingOut == NULL )
                    goto OutOfMemory;

                mbstowcs( *pbstrBindingOut, pszIP, strlen( pszIP ) + 1 );

                if ( pcccbIn != NULL )
                {
                    THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_NETBIOS_BINDING_SUCCEEDED, &bstrNotification, bstrNetBiosName, *pbstrBindingOut ) );

                    hr = THR( pcccbIn->SendStatusReport( bstrNameIn,
                                                         *pclsidLogIn,
                                                         TASKID_Minor_NETBIOS_Binding_Succeeded,
                                                         0,
                                                         1,
                                                         1,
                                                         S_OK,
                                                         bstrNotification,
                                                         NULL,
                                                         NULL
                                                         ) );
                }
                else
                {
                    hr = S_OK;
                }

                fMadeNetBIOSName = true;
                break;   // done!
            }

            hr = MAKE_HRESULT( 0, FACILITY_NULL, ncb.ncb_retcode );

            if ( pcccbIn != NULL )
            {
                THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_NETBIOS_BINDING_FAILED,  &bstrNotification, bstrNameIn ) );

                hr = THR( pcccbIn->SendStatusReport( bstrNameIn,
                                                     TASKID_Major_Client_And_Server_Log,
                                                     TASKID_Minor_NETBIOS_Binding_Failed,
                                                     0,
                                                     1,
                                                     1,
                                                     hr,
                                                     bstrNotification,
                                                     NULL,
                                                     NULL
                                                     ) );
                if ( FAILED( hr ) )
                    goto Cleanup;
            } // if:
        } // for:

        if ( fMadeNetBIOSName )
        {
            goto Cleanup;
        } // if:
    } // else if:
    else
    {
        TW32( status );
    } // else:

SkipNetBios:
    //
    //  If all else fails, use the name and attempt to bind to it.
    //

    *pbstrBindingOut = TraceSysAllocString( bstrNameIn );
    if ( *pbstrBindingOut == NULL )
        goto OutOfMemory;

    hr = S_FALSE;
    goto Cleanup;

Cleanup:
#ifdef DEBUG
    if ( FAILED( hr ) )
    {
        Assert( *pbstrBindingOut == NULL );
    }
#endif

    TraceSysFreeString( bstrNotification );
    TraceSysFreeString( bstrNetBiosName );

    if ( pResults != NULL )
    {
        DnsRecordListFree( pResults, DnsFreeRecordListDeep );
    }

    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** HrCreateBinding
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\dll\cfactory.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CFactory.cpp
//
//  Description:
//      Sucks in the CFactory code.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#pragma warning( push )
#pragma warning( disable : 4100 )
#include "CFactorySrc.cpp"
#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\common\statusreports.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      SendStatusReports.cpp
//
//  Description:
//      This file contains the definition of the SendStatusReports
//       functions.
//
//  Documentation:
//
//  Header File:
//      SendStatusReports.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 28-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include <LoadString.h>

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSendStatusReport()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrSendStatusReport(
    IClusCfgCallback *  picccIn,
    CLSID               clsidTaskMajorIn,
    CLSID               clsidTaskMinorIn,
    ULONG               ulMinIn,
    ULONG               ulMaxIn,
    ULONG               ulCurrentIn,
    HRESULT             hrStatusIn,
    const WCHAR *       pcszDescriptionIn
    )
{
    TraceFunc1( "pcszDescriptionIn = '%ls'", pcszDescriptionIn == NULL ? L"<null>" : pcszDescriptionIn );
    Assert( picccIn != NULL );

    HRESULT     hr = S_OK;
    BSTR        bstrDescription = NULL;
    FILETIME    ft;

    bstrDescription = TraceSysAllocString( pcszDescriptionIn );
    if ( bstrDescription == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto CleanUp;
    } // if:

    GetSystemTimeAsFileTime( &ft );

    if ( picccIn )
    {
        hr = THR( picccIn->SendStatusReport(
                                NULL,
                                clsidTaskMajorIn,
                                clsidTaskMinorIn,
                                ulMinIn,
                                ulMaxIn,
                                ulCurrentIn,
                                hrStatusIn,
                                bstrDescription,
                                &ft,
                                NULL
                                ) );
    }

CleanUp:

    TraceSysFreeString( bstrDescription );

    HRETURN( hr );

} //*** HrSendStatusReport()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSendStatusReport()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrSendStatusReport(
    IClusCfgCallback *  picccIn,
    CLSID               clsidTaskMajorIn,
    CLSID               clsidTaskMinorIn,
    ULONG               ulMinIn,
    ULONG               ulMaxIn,
    ULONG               ulCurrentIn,
    HRESULT             hrStatusIn,
    DWORD               dwDescriptionIn
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    BSTR        bstrDescription = NULL;
    FILETIME    ft;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, dwDescriptionIn, &bstrDescription ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    GetSystemTimeAsFileTime( &ft );

    if ( picccIn )
    {

        hr = THR( picccIn->SendStatusReport(
                            NULL,
                            clsidTaskMajorIn,
                            clsidTaskMinorIn,
                            ulMinIn,
                            ulMaxIn,
                            ulCurrentIn,
                            hrStatusIn,
                            bstrDescription,
                            &ft,
                            NULL
                            ) );
    }

CleanUp:

    TraceSysFreeString( bstrDescription );

    HRETURN( hr );

} //*** HrSendStatusReport()



//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSendStatusReport()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrSendStatusReport(
    IClusCfgCallback *  picccIn,
    const WCHAR *       pcszNodeNameIn,
    CLSID               clsidTaskMajorIn,
    CLSID               clsidTaskMinorIn,
    ULONG               ulMinIn,
    ULONG               ulMaxIn,
    ULONG               ulCurrentIn,
    HRESULT             hrStatusIn,
    DWORD               dwDescriptionIn
    )
{
    TraceFunc1( "pcszNodeNameIn = '%ls', dwDescriptionIn", pcszNodeNameIn == NULL ? L"<null>" : pcszNodeNameIn );

    HRESULT     hr = S_OK;
    BSTR        bstrDescription = NULL;
    BSTR        bstrNodeName    = NULL;
    FILETIME    ft;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, dwDescriptionIn, &bstrDescription ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    if ( pcszNodeNameIn != NULL )
    {
        bstrNodeName = TraceSysAllocString( pcszNodeNameIn );
        if ( bstrNodeName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto CleanUp;
        } // if:
    }

    GetSystemTimeAsFileTime( &ft );

    if ( picccIn != NULL )
    {
        hr = THR( picccIn->SendStatusReport(
                            bstrNodeName,
                            clsidTaskMajorIn,
                            clsidTaskMinorIn,
                            ulMinIn,
                            ulMaxIn,
                            ulCurrentIn,
                            hrStatusIn,
                            bstrDescription,
                            &ft,
                            NULL
                            ) );
    }

CleanUp:

    if ( bstrDescription != NULL )
    {
        TraceSysFreeString( bstrDescription );
    }
    if ( bstrNodeName != NULL )
    {
        TraceSysFreeString( bstrNodeName );
    }

    HRETURN( hr );

} //*** HrSendStatusReport()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSendStatusReport()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrSendStatusReport(
                IClusCfgCallback *  picccIn,
                const WCHAR *       pcszNodeName,
                CLSID               clsidTaskMajorIn,
                CLSID               clsidTaskMinorIn,
                ULONG               ulMinIn,
                ULONG               ulMaxIn,
                ULONG               ulCurrentIn,
                HRESULT             hrStatusIn,
                const WCHAR *       pcszDescriptionIn
                )
{
    TraceFunc2( "pcszNodeName = '%ls', pcszDescriptionIn = '%ls'",
                pcszNodeName == NULL ? L"<null>" : pcszNodeName,
                pcszDescriptionIn == NULL ? L"<null>" : pcszDescriptionIn
                );

    HRESULT     hr = S_OK;
    BSTR        bstrDescription = NULL;
    BSTR        bstrNodeName    = NULL;
    FILETIME    ft;

    bstrDescription = TraceSysAllocString( pcszDescriptionIn );
    if ( bstrDescription == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto CleanUp;
    } // if:

    bstrNodeName = TraceSysAllocString( pcszNodeName );
    if ( bstrNodeName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto CleanUp;
    } // if:

    GetSystemTimeAsFileTime( &ft );

    if ( picccIn )
    {
        hr = THR( picccIn->SendStatusReport(
                            bstrNodeName,
                            clsidTaskMajorIn,
                            clsidTaskMinorIn,
                            ulMinIn,
                            ulMaxIn,
                            ulCurrentIn,
                            hrStatusIn,
                            bstrDescription,
                            &ft,
                            NULL
                            ) );
    }

CleanUp:

    TraceSysFreeString( bstrDescription );
    TraceSysFreeString( bstrNodeName );

    HRETURN( hr );

} //*** HrSendStatusReport()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\common\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Galen Barbee (GalenB) 01-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
//
//  Define this to change Interface Tracking
//
//#define NO_TRACE_INTERFACES
//
//  Define this to pull in the SysAllocXXX functions. Requires linking to
//  OLEAUT32.DLL
//
#define USES_SYSALLOCSTRING
#endif // DBG==1 || _DEBUG

const   int     TIMEOUT = -1;
const   int     PUNKCHUNK = 10;


//////////////////////////////////////////////////////////////////////////////
//  Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////
#include <Pragmas.h>
#include <windows.h>
#include <objbase.h>
#include <wchar.h>
#include <ComCat.h>
#include <clusapi.h>
#include <windns.h>
#include <winsock2.h>
#include <nb30.h>

#include <Common.h>
#include <Debug.h>
#include <Log.h>
#include <CITracker.h>
#include <CFactory.h>
#include <Dll.h>
#include <guids.h>

#include <ObjectCookie.h>
#include <ClusCfgClient.h>
#include <ClusCfgGuids.h>
#include <ClusCfgServer.h>
#include <ClusCfgPrivate.h>
#include "IHandleProvider.h"

#include "CHandleProvider.h"
#include "CBasePropList.h"
#include "CBaseInfo.h"
#include "..\wizard\resource.h"
#include <LoadString.h>

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\common\ihandleprovider.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      PrivateInterfaces.h
//
//  Description:
//      This file contains the declaration of the private interfaces used in
//      the cluster configuration server.
//
//  Documentation:
//
//  Implementation Files:
//      None.
//
//  Maintained By:
//      Galen Barbee (GalenB) 29-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <ClusApi.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////

//****************************************************************************
//++
//
//  class IClusterHandleProvider 
//
//  Description:
//      This interface is used to pass around a cluster handle.
//
//--
//****************************************************************************
class IClusterHandleProvider : public IUnknown
{
public:
    //////////////////////////////////////////////////////////////////////////
    //
    //  STDMETHOD
    //  OpenCluster(
    //      [ in ] BSTR         bstrClusterName,
    //      )
    //
    //  Description:
    //      Opens the cluster and creates the cluster handle.
    //
    //  Parameters:
    //      bstrClusterName
    //          The cluster to open.
    //
    //  Return Values:
    //      S_OK
    //          The initialization succeeded.
    //
    //      other HRESULTs
    //          The call failed.
    //
    //////////////////////////////////////////////////////////////////////////
    STDMETHOD( OpenCluster )( BSTR bstrClusterNameIn ) PURE;

    //////////////////////////////////////////////////////////////////////////
    //
    //  STDMETHOD
    //  GetClusterHandle(
    //      [ out ] void **     ppvHandle
    //      )
    //
    //  Description:
    //      Returns a cluster handle.
    //
    //  Parameters:
    //      ppvHandle
    //          The handle to the cluster
    //
    //
    //  Return Values:
    //      S_OK
    //          The initialization succeeded.
    //
    //      other HRESULTs
    //          The call failed.
    //
    //////////////////////////////////////////////////////////////////////////
    STDMETHOD( GetClusterHandle )( HCLUSTER *  pphClusterHandleOut ) PURE;
}; //*** class IClusterHandleProvider


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgSetHandle
//
//  Description:
//      The interface IClusCfgSetHandle is the private interface
//      used by the cluster configuration server to set the ClusterHandleProvider
//      in its children.
//
//  Interfaces:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////


class IClusCfgSetHandle : public IUnknown
{
public:
    STDMETHOD( SetHandleProvider )( IClusterHandleProvider * pIHandleProvider ) PURE;

}; //*** Class IClusCfgSetHandle
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\dll\citracker.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CITracker.cpp
//
//  Description:
//      Sucks in the CITracker library.
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"

#pragma warning( push )
#pragma warning( disable : 4100 )
#include "CITrackerSrc.cpp"
#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\common\statusreports.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      SendStatusReports.h
//
//  Description:
//      This file contains the declaration of the SendStatusReport
//      functions.
//
//  Documentation:
//
//  Implementation Files:
//      SendStatusReports.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 28-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


HRESULT
HrSendStatusReport(
                IClusCfgCallback *  picccIn,
                CLSID               clsidTaskMajorIn,
                CLSID               clsidTaskMinorIn,
                ULONG               ulMinIn,
                ULONG               ulMaxIn,
                ULONG               ulCurrentIn,
                HRESULT             hrStatusIn,
                const WCHAR *       pcszDescriptionIn
                );

HRESULT
HrSendStatusReport(
                IClusCfgCallback *  picccIn,
                CLSID               clsidTaskMajorIn,
                CLSID               clsidTaskMinorIn,
                ULONG               ulMinIn,
                ULONG               ulMaxIn,
                ULONG               ulCurrentIn,
                HRESULT             hrStatusIn,
                DWORD               dwDescriptionIn
                );

HRESULT
HrSendStatusReport(
                IClusCfgCallback *  picccIn,
                const WCHAR *       pcszNodeName,
                CLSID               clsidTaskMajorIn,
                CLSID               clsidTaskMinorIn,
                ULONG               ulMinIn,
                ULONG               ulMaxIn,
                ULONG               ulCurrentIn,
                HRESULT             hrStatusIn,
                DWORD               dwDescriptionIn
                );

HRESULT
HrSendStatusReport(
                IClusCfgCallback *  picccIn,
                const WCHAR *       pcszNodeName,
                CLSID               clsidTaskMajorIn,
                CLSID               clsidTaskMinorIn,
                ULONG               ulMinIn,
                ULONG               ulMaxIn,
                ULONG               ulCurrentIn,
                HRESULT             hrStatusIn,
                const WCHAR *       pcszDescriptionIn
                );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\dll\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "DebugSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\dll\log.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the logging library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "LogSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\dll\interfacetable.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InterfaceTable.cpp
//
//  Description:
//      Sucks in the Interface Table.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "InterfaceTableSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\dll\dllresources.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      DllResources.h
//
//  Description:
//      Contains the definitions of the resource IDs used by this library.
//
//  Maintained By:
//      David Potter    (DavidP)    19-MAR-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

// The starting ID for these resources.
#define ID_DLL_START    0

#define IDR_MANIFEST    500

#define ID_DLL_END      599
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\dll\register.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "RegisterSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\dll\dll.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      Dll.cpp
//
//  Description:
//      DLL services/entry points.
//
//  Maintained By:
//      David Potter    (DavidP)    19-MAR-2001
//      Geoffrey Pease  (GPease)    09-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "Register.h"
#include "DllResources.h"

#include <InitGuid.h>
#include <Guids.h>

//
// Add object headers here
//

// Common
#include "..\Common\CClusCfgCredentials.h"

//  Server
#include "..\Server\CClusCfgServer.h"
#include "..\Server\CClusCfgNodeInfo.h"
#include "..\Server\CClusCfgClusterInfo.h"
#include "..\Server\CClusCfgCallback.h"
#include "..\Server\CEnumClusCfgManagedResources.h"
#include "..\Server\CPhysicalDisk.h"
#include "..\Server\CEnumPhysicalDisks.h"
#include "..\Server\CEnumClusterResources.h"
#include "..\Server\CClusterResource.h"
#include "..\Server\CEnumClusCfgNetworks.h"
#include "..\Server\CEnumClusCfgIPAddresses.h"
#include "..\Server\CClusCfgNetworkInfo.h"
#include "..\Server\CClusCfgIPAddressInfo.h"
#include "..\Server\CClusCfgCapabilities.h"
#include "..\Server\CLocalQuorum.h"
#include "..\Server\CEnumLocalQuorum.h"
#include "..\Server\CMajorityNodeSet.h"
#include "..\Server\CEnumMajorityNodeSet.h"
#include "..\Server\CUnknownQuorum.h"

// Middle Tier
#include "..\MiddleTier\TaskManager.h"
#include "..\MiddleTier\ConnectionManager.h"
#include "..\MiddleTier\ObjectManager.h"
#include "..\MiddleTier\NotificationManager.h"
#include "..\MiddleTier\ServiceManager.h"
#include "..\MiddleTier\LogManager.h"
#include "..\MiddleTier\ClusterConfiguration.h"
#include "..\MiddleTier\ManagedDevice.h"
#include "..\MiddleTier\ManagedNetwork.h"
#include "..\MiddleTier\NodeInformation.h"
#include "..\MiddleTier\TaskGatherNodeInfo.h"
#include "..\MiddleTier\ConfigConnection.h"
#include "..\MiddleTier\TaskAnalyzeCluster.h"
#include "..\MiddleTier\TaskCommitClusterChanges.h"
#include "..\MiddleTier\EnumNodeInformation.h"
#include "..\MiddleTier\TaskGatherInformation.h"
#include "..\MiddleTier\ManagedDevice.h"
#include "..\MiddleTier\TaskCompareAndPushInformation.h"
#include "..\MiddleTier\EnumManageableResources.h"
#include "..\MiddleTier\EnumManageableNetworks.h"
#include "..\MiddleTier\TaskGatherClusterInfo.h"
#include "..\MiddleTier\TaskKeepMTAAlive.h"
#include "..\MiddleTier\EnumCookies.h"
#include "..\MiddleTier\TaskLoginDomain.h"
#include "..\MiddleTier\TaskPollingCallback.h"
#include "..\MiddleTier\TaskVerifyIPAddress.h"
#include "..\MiddleTier\IPAddressInfo.h"
#include "..\MiddleTier\EnumIPAddresses.h"
#include "..\Inc\Logger.h"

// W2kProxy
#include "..\Common\IHandleProvider.h"
#include "..\W2kProxy\ConfigClusApi.h"

// Wizard
#include "..\Wizard\ClusCfg.h"
#include "..\MiddleTier\TaskGetDomains.h"

// BaseCluster
#include "..\BaseCluster\CBCAInterface.h"

// Post Config
#include "..\PostCfg\GroupHandle.h"
#include "..\PostCfg\ResourceEntry.h"
#include "..\PostCfg\IPostCfgManager.h"
#include "..\PostCfg\IPrivatePostCfgResource.h"
#include "..\PostCfg\PostCfgMgr.h"
#include "..\PostCfg\ResTypeGenScript.h"
#include "..\PostCfg\ResTypeMajorityNodeSet.h"
#include "..\PostCfg\ResTypeServices.h"

// EvictCleanup
#include "..\EvictCleanup\EvictCleanup.h"
#include "..\EvictCleanup\AsyncEvictCleanup.h"

// Startup
#include "..\Startup\StartupNotify.h"



//
// Define the debugging module name for this DLL.
//
DEFINE_MODULE( "ClusConfig" )

//
// Category IDs in this Component
//
// This table is used to register the Category IDs (CATIDs) used by this DLL.
//
BEGIN_CATIDTABLE
DEFINE_CATID( CATID_ClusCfgCapabilities,                    "Cluster Configuration Cluster Capabilities" )
DEFINE_CATID( CATID_EnumClusCfgManagedResources,            "Cluster Configuration Managed Resource Enumerators" )
DEFINE_CATID( CATID_ClusCfgResourceTypes,                   "Cluster Configuration Resource Types" )
DEFINE_CATID( CATID_ClusCfgMemberSetChangeListeners,        "Cluster Configuration Member Set Change Listeners" )
DEFINE_CATID( CATID_ClusCfgStartupListeners,                "Cluster Configuration Service Startup Listeners" )
END_CATIDTABLE

//
// Classes in this Component
//
// This table is used to create the objects supported in this DLL. It also is
// used to map a name with a particular CLSID. HrCoCreateInternalInstance() uses
// this table to shortcut COM.
//
BEGIN_CLASSTABLE            // S_HrCreateInstance                               CLSID                               User Friendly Name                                  Apartment Model     Extra registration goo....
DEFINE_CLASS_WITH_APPID(    CClusCfgServer::S_HrCreateInstance,                 CLSID_ClusCfgServer,                "ClusCfg Server",                                   "Apartment",        APPID_ClusCfgServer,        "" /*DllSurrogate*/ )
DEFINE_CLASS(               CClusCfgNodeInfo::S_HrCreateInstance,               CLSID_ClusCfgNodeInfo,              "ClusCfg Node Information",                         "Apartment" )
DEFINE_CLASS(               CClusCfgClusterInfo::S_HrCreateInstance,            CLSID_ClusCfgClusterInfo,           "ClusCfg Cluster Information",                      "Apartment" )
DEFINE_CLASS(               CEnumClusCfgManagedResources::S_HrCreateInstance,   CLSID_EnumClusCfgManagedResources,  "ClusCfg Manged Resources Enumeration",             "Apartment" )
DEFINE_CLASS(               CPhysicalDisk::S_HrCreateInstance,                  CLSID_PhysicalDisk,                 "ClusCfg Physical Disk Information",                "Apartment" )
DEFINE_CLASS(               CEnumClusCfgNetworks::S_HrCreateInstance,           CLSID_EnumClusCfgNetworks,          "ClusCfg Networks Enumeration",                     "Apartment" )
DEFINE_CLASS(               CClusCfgNetworkInfo::S_HrCreateInstance,            CLSID_ClusCfgNetworkInfo,           "ClusCfg Network Information",                      "Apartment" )
DEFINE_CLASS(               CEnumClusCfgIPAddresses::S_HrCreateInstance,        CLSID_EnumClusCfgIPAddresses,       "ClusCfg IP Address Enumeration",                   "Apartment" )
DEFINE_CLASS(               CClusCfgIPAddressInfo::S_HrCreateInstance,          CLSID_ClusCfgIPAddressInfo,         "ClusCfg IP Address Information",                   "Apartment" )
DEFINE_CLASS(               CTaskManager::S_HrCreateInstance,                   CLSID_TaskManager,                  "ClusCfg Task Manager",                             "Free" )
DEFINE_CLASS(               CConnectionManager::S_HrCreateInstance,             CLSID_ClusterConnectionManager,     "ClusCfg Connection Manager",                       "Apartment" )
DEFINE_CLASS(               CObjectManager::S_HrCreateInstance,                 CLSID_ObjectManager,                "ClusCfg ObjectManager",                            "Apartment" )
DEFINE_CLASS(               CLogManager::S_HrCreateInstance,                    CLSID_LogManager,                   "ClusCfg LogManager",                               "Apartment" )
DEFINE_CLASS(               CNotificationManager::S_HrCreateInstance,           CLSID_NotificationManager,          "ClusCfg Notification Manager",                     "Apartment" )
DEFINE_CLASS(               CServiceManager::S_HrCreateInstance,                CLSID_ServiceManager,               "ClusCfg Service Manager",                          "Free" )
DEFINE_CLASS(               CNodeInformation::S_HrCreateInstance,               DFGUID_NodeInformation,             "ClusCfg Node Information Data Format",             "Apartment" )
DEFINE_CLASS(               CTaskGatherNodeInfo::S_HrCreateInstance,            TASK_GatherNodeInfo,                "ClusCfg Task Gather Node Information",             "Both" )
DEFINE_CLASS(               CConfigurationConnection::S_HrCreateInstance,       CLSID_ConfigurationConnection,      "ClusCfg Configuration Connection",                 "Apartment" )
DEFINE_CLASS(               CTaskAnalyzeCluster::S_HrCreateInstance,            TASK_AnalyzeCluster,                "ClusCfg Task Analyze Cluster",                     "Both" )
DEFINE_CLASS(               CTaskCommitClusterChanges::S_HrCreateInstance,      TASK_CommitClusterChanges,          "ClusCfg Task Commit Cluster Changes",              "Both" )
DEFINE_CLASS(               CEnumNodeInformation::S_HrCreateInstance,           DFGUID_EnumNodes,                   "ClusCfg Enum Node Information Format",             "Apartment" )
DEFINE_CLASS(               CTaskGatherInformation::S_HrCreateInstance,         TASK_GatherInformation,             "ClusCfg Task Gather Information",                  "Both" )
DEFINE_CLASS(               CManagedDevice::S_HrCreateInstance,                 DFGUID_ManagedResource,             "ClusCfg Managed Resource Data Format",             "Apartment" )
DEFINE_CLASS(               CManagedNetwork::S_HrCreateInstance,                DFGUID_NetworkResource,             "ClusCfg Managed Network Data Format",              "Apartment" )
DEFINE_CLASS(               CTaskCompareAndPushInformation::S_HrCreateInstance, TASK_CompareAndPushInformation,     "ClusCfg Task Compare and Push Information",        "Both" )
DEFINE_CLASS(               CEnumManageableResources::S_HrCreateInstance,       DFGUID_EnumManageableResources,     "ClusCfg Enum Manageable Resources Data Format",    "Apartment" )
DEFINE_CLASS(               CEnumManageableNetworks::S_HrCreateInstance,        DFGUID_EnumManageableNetworks,      "ClusCfg Enum Manageable Networks Data Format",     "Apartment" )
DEFINE_CLASS_WITH_APPID(    CClusCfgWizard::S_HrCreateInstance,                 CLSID_ClusCfgWizard,                "ClusCfg Cluster Configuration Wizard",             "Apartment",        APPID_ClusCfgWizard,        "" /*DllSUrrogate*/ )
DEFINE_CLASS(               CTaskGetDomains::S_HrCreateInstance,                TASK_GetDomains,                    "ClusCfg Task Get Domains",                         "Both" )
DEFINE_CLASS(               CTaskPollingCallback::S_HrCreateInstance,           TASK_PollingCallback,               "ClusCfg Task Polling Callback",                    "Both" )
DEFINE_CLASS_WITH_APPID(    CBCAInterface::S_HrCreateInstance,                  CLSID_ClusCfgBaseCluster,           "ClusCfg Base Cluster",                             "Apartment",        APPID_ClusCfgBaseCluster,   "" /*DllSurrogate*/ )
DEFINE_CLASS(               CClusterConfiguration::S_HrCreateInstance,          DFGUID_ClusterConfigurationInfo,    "ClusCfg Cluster Configuration Data Format",        "Apartment" )
DEFINE_CLASS(               CTaskGatherClusterInfo::S_HrCreateInstance,         TASK_GatherClusterInfo,             "ClusCfg Task Gather Cluster Info",                 "Both" )
DEFINE_CLASS(               CTaskKeepMTAAlive::S_HrCreateInstance,              TASK_KeepMTAAlive,                  "ClusCfg Task Keep MTA Alive",                      "Both" )
DEFINE_CLASS_CATIDREG(      CEnumPhysicalDisks::S_HrCreateInstance,             CLSID_EnumPhysicalDisks,            "ClusCfg Physical Disk Enumeration",                "Apartment",        CEnumPhysicalDisks::S_RegisterCatIDSupport )
//DEFINE_CLASS_CATIDREG(      CEnumClusterResources::S_HrCreateInstance,          CLSID_EnumClusterResources,         "ClusCfg Cluster Resource Enumeration",             "Apartment",      CEnumClusterResources::S_RegisterCatIDSupport )
//DEFINE_CLASS(               CClusterResource::S_HrCreateInstance,               CLSID_ClusterResource,              "ClusCfg Cluster Resource Information",             "Apartment" )
DEFINE_CLASS(               CEnumCookies::S_HrCreateInstance,                   DFGUID_EnumCookies,                 "ClusCfg Enum Cookies",                             "Apartment" )
DEFINE_CLASS(               CTaskLoginDomain::S_HrCreateInstance,               TASK_LoginDomain,                   "ClusCfg Task Login Domain",                        "Both" )
DEFINE_CLASS(               CClusCfgCredentials::S_HrCreateInstance,            CLSID_ClusCfgCredentials,           "ClusCfg Credentials",                              "Apartment" )
DEFINE_CLASS(               CPostCfgManager::S_HrCreateInstance,                CLSID_ClusCfgPostConfigManager,     "ClusCfg Post Configuration Manager",               "Apartment" )
DEFINE_CLASS_CATIDREG(      CResTypeGenScript::S_HrCreateInstance,              CLSID_ClusCfgResTypeGenScript,      "ClusCfg Generic Script Resource Type Configuration","Apartment",       CResTypeGenScript::S_RegisterCatIDSupport )
DEFINE_CLASS_CATIDREG(      CResTypeMajorityNodeSet::S_HrCreateInstance,        CLSID_ClusCfgResTypeMajorityNodeSet,"ClusCfg Majority Node Set Resource Type Configuration",  "Apartment",        CResTypeMajorityNodeSet::S_RegisterCatIDSupport )
DEFINE_CLASS(               CTaskVerifyIPAddress::S_HrCreateInstance,           TASK_VerifyIPAddress,               "ClusCfg Task Verify IP Address",                   "Both" )
DEFINE_CLASS(               CConfigClusApi::S_HrCreateInstance,                 CLSID_ConfigClusApi,                "ClusCfg Configure Cluster API Proxy Server",       "Both" )

DEFINE_CLASS(               CIPAddressInfo::S_HrCreateInstance,                 DFGUID_IPAddressInfo,               "ClusCfg IP Address Info Data Format",              "Apartment" )
DEFINE_CLASS(               CEnumIPAddresses::S_HrCreateInstance,               DFGUID_EnumIPAddressInfo,           "ClusCfg Enum IP Address Info Data Format",         "Apartment" )
DEFINE_CLASS(               CResTypeServices::S_HrCreateInstance,               CLSID_ClusCfgResTypeServices,       "ClusCfg Resource Type Services",                   "Apartment" )
DEFINE_CLASS_WITH_APPID(    CEvictCleanup::S_HrCreateInstance,                  CLSID_ClusCfgEvictCleanup,          "ClusCfg Eviction Processing",                      "Free",             APPID_ClusCfgEvictCleanup,       "" /*DllSUrrogate*/ )
DEFINE_CLASS_WITH_APPID(    CAsyncEvictCleanup::S_HrCreateInstance,             CLSID_ClusCfgAsyncEvictCleanup,     "ClusCfg Asynchronous Eviction Processing",         "Apartment",        APPID_ClusCfgAsyncEvictCleanup,  "" /*DllSUrrogate*/ )
DEFINE_CLASS_WITH_APPID(    CStartupNotify::S_HrCreateInstance,                 CLSID_ClusCfgStartupNotify,         "ClusCfg Cluster Startup Notification",             "Free",             APPID_ClusCfgStartupNotify,      "" /*DllSUrrogate*/ )
DEFINE_CLASS_CATIDREG(      CClusCfgCapabilities::S_HrCreateInstance,           CLSID_ClusCfgCapabilities,          "ClusCfg Cluster Capabilities",                     "Apartment",        CClusCfgCapabilities::S_RegisterCatIDSupport )
DEFINE_CLASS_WITH_APPID(    CClCfgSrvLogger::S_HrCreateInstance,                CLSID_ClCfgSrvLogger,               "ClusCfg Logger",                                   "Apartment",        APPID_ClCfgSrvLogger,            "" /*DllSUrrogate*/ )
DEFINE_CLASS(               CLocalQuorum::S_HrCreateInstance,                   CLSID_LocalQuorum,                  "ClusCfg Local Quorum Information",                 "Apartment" )
DEFINE_CLASS_CATIDREG(      CEnumLocalQuorum::S_HrCreateInstance,               CLSID_EnumLocalQuorum,              "ClusCfg Local Quorum Enumeration",                 "Apartment",        CEnumLocalQuorum::S_RegisterCatIDSupport )
DEFINE_CLASS(               CMajorityNodeSet::S_HrCreateInstance,               CLSID_MajorityNodeSet,              "ClusCfg Majority Node Set Information",            "Apartment" )
DEFINE_CLASS_CATIDREG(      CEnumMajorityNodeSet::S_HrCreateInstance,           CLSID_EnumMajorityNodeSet,          "ClusCfg Majority Node Set Enumeration",            "Apartment",        CEnumMajorityNodeSet::S_RegisterCatIDSupport )
DEFINE_CLASS(               CUnknownQuorum::S_HrCreateInstance,                 CLSID_UnknownQuorum,                "ClusCfg Unknown Quorum",                           "Apartment" )
//DEFINE_CLASS_CATIDREG(      CEnumUnknownQuorum::S_HrCreateInstance,             CLSID_EnumUnknownQuorum,            "ClusCfg Unknown Quorum Enumeration",               "Apartment",        CEnumUnknownQuorum::S_RegisterCatIDSupport )
END_CLASSTABLE

//
//  RPC Proxy/Stub entry points
//

extern "C" {

HRESULT
STDAPICALLTYPE
ProxyStubDllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    void ** ppv
    );

HRESULT
STDAPICALLTYPE
ProxyStubDllCanUnloadNow( );

HRESULT
STDAPICALLTYPE
ProxyStubDllRegisterServer( );

HRESULT
STDAPICALLTYPE
ProxyStubDllUnregisterServer( );


} // extern "C"

//
// Indicate that we need to have Fusion initialized and uninitialized properly
// on process attach and detach.
//
#define USE_FUSION

#include "DllSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\dll\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      David Potter    (DavidP)    19-MAR-2001
//      Geoffrey Pease  (GPease)    15-OCT-1999
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE
#define _UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
//
//  Define this to change Interface Tracking
//
//#define NO_TRACE_INTERFACES
//
//  Define this to pull in the SysAllocXXX functions. Requires linking to
//  OLEAUT32.DLL
//
#define USES_SYSALLOCSTRING
#endif // DBG==1 || _DEBUG

#define COMPONENT_HAS_CATIDS

//////////////////////////////////////////////////////////////////////////////
//  Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <objbase.h>
#include <ocidl.h>
#include <shlwapi.h>
#include <ComCat.h>
#include <prsht.h>
#include <shfusion.h>

#include <Common.h>
#include <debug.h>
#include <log.h>
#include <CITracker.h>
#include <CFactory.h>
#include <Dll.h>
#include <guids.h>
#include <ObjectCookie.h>
#include <ClusCfgGuids.h>
#include <ClusCfgWizard.h>
#include <ClusCfgClient.h>
#include <ClusCfgServer.h>
#include <ClusCfgPrivate.h>

#include <WBemCli.h>
#include <clusapi.h> // TODO: This file may not be needed.

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\evictcleanup\asyncevictcleanup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      AsyncEvictCleanup.cpp
//
//  Description:
//      This file contains the implementation of the CAsyncEvictCleanup
//      class.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Header File:
//      AsyncEvictCleanup.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "pch.h"

// The header file for this class
#include "AsyncEvictCleanup.h"

// For IClusCfgEvictCleanup and related interfaces
#include "ClusCfgServer.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CAsyncEvictCleanup" );


//////////////////////////////////////////////////////////////////////////////
// Global Variable Definitions
//////////////////////////////////////////////////////////////////////////////

// Description of the parameters to the CleanupNode method
static PARAMDATA gs_rgpdCleanupNodeParamData[] =
{
    {
          L"bstrEvictedNodeNameIn"
        , VT_BSTR
    },
    {
          L"dwDelayIn"
        , VT_UI4
    },
    {
          L"dwTimeoutIn"
        , VT_UI4
    }
};

// Description of the CleanupNode method
static METHODDATA gs_rgmdAsyncCleanupMethodData[] =
{
    {   L"CleanupNode"
      , gs_rgpdCleanupNodeParamData
      , DISPID_VALUE
      , 3
      , CC_CDECL
      , sizeof( gs_rgpdCleanupNodeParamData ) / sizeof( gs_rgpdCleanupNodeParamData[ 0 ] )
      , DISPATCH_METHOD
      , VT_ERROR
    }
};

// Interface data table used by CreateStdDispatch()
static INTERFACEDATA gs_idAsycnCleanupIfaceData =
{
      gs_rgmdAsyncCleanupMethodData
    , sizeof ( gs_rgmdAsyncCleanupMethodData ) / sizeof( gs_rgmdAsyncCleanupMethodData[ 0 ] )
};


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAsyncEvictCleanup::CAsyncEvictCleanup()
//
//  Description:
//      Constructor of the CAsyncEvictCleanup class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CAsyncEvictCleanup::CAsyncEvictCleanup( void )
    : m_cRef( 1 )
    , m_punkStdDisp( NULL )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    TraceFlow1( "Component count = %d.", g_cObjects );

    TraceFuncExit();

} //*** CAsyncEvictCleanup::CAsyncEvictCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAsyncEvictCleanup::~CAsyncEvictCleanup()
//
//  Description:
//      Destructor of the CAsyncEvictCleanup class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CAsyncEvictCleanup::~CAsyncEvictCleanup( void )
{
    TraceFunc( "" );

    // If we had acquired a pointer to the standard dispatch interface, release it.
    if ( m_punkStdDisp != NULL )
    {
        m_punkStdDisp->Release();
    } // if: we had stored a pointer to the standard dispatch interface

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFlow1( "Component count = %d.", g_cObjects );

    TraceFuncExit();

} //*** CAsyncEvictCleanup::~CAsyncEvictCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CAsyncEvictCleanup::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//  Description:
//      Creates a CAsyncEvictCleanup instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CAsyncEvictCleanup::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr = E_INVALIDARG;
    CAsyncEvictCleanup *    pAsyncEvictCleanup = NULL;

    // Allocate memory for the new object.
    pAsyncEvictCleanup = new CAsyncEvictCleanup();
    if ( pAsyncEvictCleanup == NULL )
    {
        LogMsg( "AsyncEvictCleanup: Could not allocate memory for a evict cleanup object." );
        TraceFlow( "Could not allocate memory for a evict cleanup object." );
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: out of memory

    // Initialize the new object.
    hr = THR( pAsyncEvictCleanup->HrInit( ) );
    if ( FAILED( hr ) )
    {
        LogMsg( "AsyncEvictCleanup: Error %#08x occurred initializing a evict cleanup object.", hr );
        TraceFlow1( "Error %#08x occurred initializing a evict cleanup object.", hr );
        goto Cleanup;
    } // if: the object could not be initialized

    hr = THR( pAsyncEvictCleanup->QueryInterface( IID_IUnknown, reinterpret_cast< void ** >( ppunkOut ) ) );

    TraceFlow1( "*ppunkOut = %p.", *ppunkOut );

Cleanup:
    if ( pAsyncEvictCleanup != NULL )
    {
        pAsyncEvictCleanup->Release();
    } // if: the pointer to the resource type object is not NULL

    HRETURN( hr );

} //*** CAsyncEvictCleanup::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CAsyncEvictCleanup::AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CAsyncEvictCleanup::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    TraceFlow1( "m_cRef = %d", m_cRef );

    RETURN( m_cRef );

} //*** CAsyncEvictCleanup::AddRef()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CAsyncEvictCleanup::Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CAsyncEvictCleanup::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    InterlockedDecrement( &m_cRef );
    cRef = m_cRef;

    TraceFlow1( "m_cRef = %d", m_cRef );

    if ( m_cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count decremented to zero

    RETURN( cRef );

} //*** CAsyncEvictCleanup::Release()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CAsyncEvictCleanup::QueryInterface()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      IN  REFIID  riidIn
//          Id of interface requested.
//
//      OUT void ** ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CAsyncEvictCleanup::QueryInterface( REFIID  riidIn, void ** ppvOut )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    if ( ppvOut != NULL )
    {
        if ( IsEqualIID( riidIn, IID_IUnknown ) )
        {
            *ppvOut = static_cast< IClusCfgAsyncEvictCleanup * >( this );
        } // if: IUnknown
        else if ( IsEqualIID( riidIn, IID_IDispatch ) )
        {
            hr = m_punkStdDisp->QueryInterface( riidIn, ppvOut );
        } // else if: IDispatch
        else if ( IsEqualIID( riidIn, IID_IClusCfgAsyncEvictCleanup ) )
        {
            *ppvOut = TraceInterface( __THISCLASS__, IClusCfgAsyncEvictCleanup, this, 0 );
        } // else if: IClusCfgAsyncEvictCleanup
        else
        {
            hr = E_NOINTERFACE;
        } // else

        if ( SUCCEEDED( hr ) )
        {
            ((IUnknown *) *ppvOut)->AddRef( );
        } // if: success
        else
        {
            *ppvOut = NULL;
        } // else: something failed

    } // if: the output pointer was valid
    else
    {
        hr = E_INVALIDARG;  // TODO: DavidP 02-OCT-2000 Shouldn't this be E_NOINTERFACE?
    } // else: the output pointer is invalid


    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CAsyncEvictCleanup::QueryInterface()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAsyncEvictCleanup::HrInit()
//
//  Description:
//      Second phase of a two phase constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CAsyncEvictCleanup::HrInit( void )
{
    TraceFunc( "" );

    ITypeInfo * ptiTypeInfo = NULL;
    HRESULT     hr = S_OK;

    // Create simplified type information.
    hr = CreateDispTypeInfo( &gs_idAsycnCleanupIfaceData, LOCALE_SYSTEM_DEFAULT, &ptiTypeInfo );
    if ( FAILED( hr ) )
    {
       LogMsg( "AsyncEvictCleanup: Error %#x occurred trying to create type information for the IDispatch interface.", hr );
       TraceFlow1( "Error %#x occurred trying to create type information for the IDispatch interface.", hr );
       goto Cleanup;
    } // if: we could not create the type info for the IDispatch interface

    hr = THR(
        CreateStdDispatch(
              this
            , static_cast< IClusCfgAsyncEvictCleanup * >( this )
            , ptiTypeInfo
            , &m_punkStdDisp
            )
        );
    if ( FAILED( hr ) )
    {
       LogMsg( "AsyncEvictCleanup: Error %#x occurred trying to create a standard dispatch interface.", hr );
       TraceFlow1( "Error %#x occurred trying to create a standard dispatch interface.", hr );
       goto Cleanup;
    } // if: we could not create standard dispatch interface

Cleanup:
    //
    // Cleanup
    //

    if ( ptiTypeInfo != NULL )
    {
        ptiTypeInfo->Release();
    } // if: we had obtained type info

    HRETURN( hr );

} //*** CAsyncEvictCleanup::HrInit()


//////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CAsyncEvictCleanup::CleanupNode(
//        LPCWSTR   pcszEvictedNodeNameIn
//      , DWORD     dwDelayIn
//      , DWORD     dwTimeoutIn
//      )
//
//	Routine Description:
//		Cleanup a node that has been evicted.
//
//	Arguments:
//      BSTR  bstrEvictedNodeNameIn
//          Name of the node on which cleanup is to be initiated. If this is NULL
//          the local node is cleaned up.
//
//      DWORD dwDelayIn
//          Number of milliseconds that will elapse before cleanup is started
//          on the target node. If some other process cleans up the target node while
//          delay is in progress, the delay is terminated. If this value is zero,
//          the node is cleaned up immediately.
//
//      DWORD dwTimeoutIn
//          Number of milliseconds that this method will wait for cleanup to complete.
//          This timeout is independent of the delay above, so if dwDelayIn is greater
//          than dwTimeoutIn, this method will most probably timeout. Once initiated,
//          however, cleanup will run to completion - this method just may not wait for it
//          to complete.
//
//	Return Value:
//      S_OK
//          If the cleanup operations were successful
//
//      RPC_S_CALLPENDING
//          If cleanup is not complete in dwTimeoutIn milliseconds
//
//      Other HRESULTS
//          In case of error
//
//////////////////////////////////////////////////////////////////////////
HRESULT
CAsyncEvictCleanup::CleanupNode(
      LPCWSTR   pcszEvictedNodeNameIn
    , DWORD     dwDelayIn
    , DWORD     dwTimeoutIn
    )
{
    TraceFunc( "[IClusCfgAsyncEvictCleanup]" );

    HRESULT                         hr = S_OK;
    IClusCfgEvictCleanup *          pcceEvict = NULL;
    ICallFactory *                  pcfCallFactory = NULL;
    ISynchronize *                  psSync = NULL;
    AsyncIClusCfgEvictCleanup *     paicceAsyncEvict = NULL;

    MULTI_QI mqiInterfaces[] =
    {
        { &IID_IClusCfgEvictCleanup, NULL, S_OK },
    };

    COSERVERINFO    csiServerInfo;
    COSERVERINFO *  pcsiServerInfoPtr = &csiServerInfo;

#if 0
    bool                            fWaitForDebugger = true;

    while ( fWaitForDebugger )
    {
        Sleep( 3000 );
    } // while: waiting for the debugger to break in
#endif

    if ( ( pcszEvictedNodeNameIn == NULL ) || ( *pcszEvictedNodeNameIn == L'\0' ) )
    {
        TraceFlow( "The local node will be cleaned up." );
        LogMsg( "AsyncEvictCleanup: The local node will be cleaned up." );
        pcsiServerInfoPtr = NULL;
    } // if: we have to cleanup the local node
    else
    {
        LogMsg( "AsyncEvictCleanup: The remote node to be cleaned up is '%ws'.", pcszEvictedNodeNameIn );
        TraceFlow1( "The remote node to be cleaned up is '%ws'.", pcszEvictedNodeNameIn );

        csiServerInfo.dwReserved1 = 0;
        csiServerInfo.pwszName = const_cast< LPWSTR >( pcszEvictedNodeNameIn );
        csiServerInfo.pAuthInfo = NULL;
        csiServerInfo.dwReserved2 = 0;
    } // else: we have to clean up a remote node


    TraceFlow( "Creating the EvictCleanup component on the evicted node." );

    // Instantiate this component on the node being evicted.
    hr = THR(
        CoCreateInstanceEx(
              CLSID_ClusCfgEvictCleanup
            , NULL
            , CLSCTX_LOCAL_SERVER
            , pcsiServerInfoPtr
            , sizeof( mqiInterfaces ) / sizeof( mqiInterfaces[0] )
            , mqiInterfaces
            )
        );
    if ( FAILED( hr ) )
    {
        LogMsg( "AsyncEvictCleanup: Error %#08x occurred trying to instantiate the evict processing component on the evicted node.", hr );
        TraceFlow1( "Error %#08x occurred trying to instantiate the evict processing component on the evicted node.", hr );
        goto Cleanup;
    } // if: we could not instantiate the evict processing component


    // Get a pointer to the IClusCfgEvictCleanup interface.
    pcceEvict = reinterpret_cast< IClusCfgEvictCleanup * >( mqiInterfaces[0].pItf );

    TraceFlow( "Creating a call factory." );

    // Now, get a pointer to the ICallFactory interface.
    hr = THR( pcceEvict->QueryInterface< ICallFactory >( &pcfCallFactory ) );
    if ( FAILED( hr ) )
    {
        LogMsg( "AsyncEvictCleanup: Error %#08x occurred trying to get a pointer to the call factory.", hr );
        TraceFlow1( "Error %#08x occurred trying to get a pointer to the call factory.", hr );
        goto Cleanup;
    } // if: we could not get a pointer to the call factory interface


    TraceFlow( "Creating a call object to make an asynchronous call." );

    // Create a call factory so that we can make an asynchronous call to cleanup the evicted node.
    hr = THR(
        pcfCallFactory->CreateCall(
              __uuidof( paicceAsyncEvict )
            , NULL
            , __uuidof( paicceAsyncEvict )
            , reinterpret_cast< IUnknown ** >( &paicceAsyncEvict )
            )
        );
    if ( FAILED( hr ) )
    {
        LogMsg( "AsyncEvictCleanup: Error %#08x occurred trying to create a call object.", hr );
        TraceFlow1( "Error %#08x occurred trying to create a call object.", hr );
        goto Cleanup;
    } // if: we could not get a pointer to the asynchronous evict interface


    TraceFlow( "Trying to get the ISynchronize interface pointer." );

    // Get a pointer to the ISynchronize interface.
    hr = THR( paicceAsyncEvict->QueryInterface< ISynchronize >( &psSync ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get a pointer to the synchronization interface


    TraceFlow( "Initiating cleanup on evicted node." );

    // Initiate cleanup
    hr = THR( paicceAsyncEvict->Begin_CleanupLocalNode( dwDelayIn ) );
    if ( ( FAILED( hr ) ) && ( HRESULT_CODE( hr ) != ERROR_NONE_MAPPED ) )
    {
        LogMsg( "AsyncEvictCleanup: Error %#08x occurred trying to initiate cleanup on evicted node.", hr );
        TraceFlow1( "Error %#08x occurred trying to initiate cleanup on evicted node.", hr );
        goto Cleanup;
    } // if: we could not initiate cleanup


    TraceFlow1( "Waiting for cleanup to complete or timeout to occur (%d milliseconds).", dwTimeoutIn );

    // Wait for specified time.
    hr = psSync->Wait( 0, dwTimeoutIn );
    if ( FAILED( hr ) || ( hr == RPC_S_CALLPENDING ) )
    {
        LogMsg( "AsyncEvictCleanup: We could not wait till the cleanup completed (status code is %#08x).", hr );
        TraceFlow1( "We could not wait till the cleanup completed (status code is %#08x).", hr );
        goto Cleanup;
    } // if: we could not wait till cleanup completed


    TraceFlow( "Finishing cleanup." );

    // Finish cleanup
    hr = THR( paicceAsyncEvict->Finish_CleanupLocalNode() );
    if ( FAILED( hr ) )
    {
        LogMsg( "AsyncEvictCleanup: Error %#08x occurred trying to finish cleanup on evicted node.", hr );
        TraceFlow1( "Error %#08x occurred trying to finish cleanup on evicted node.", hr );
        goto Cleanup;
    } // if: we could not finish cleanup

Cleanup:
    //
    // Clean up
    //
    if ( pcceEvict != NULL )
    {
        pcceEvict->Release();
    } // if: we had got a pointer to the IClusCfgEvictCleanup interface

    if ( pcfCallFactory != NULL )
    {
        pcfCallFactory->Release();
    } // if: we had obtained a pointer to the call factory interface

    if ( psSync != NULL )
    {
        psSync->Release();
    } // if: we had obtained a pointer to the synchronization interface

    if ( paicceAsyncEvict != NULL )
    {
        paicceAsyncEvict->Release();
    } // if: we had obtained a pointer to the asynchronous evict interface

    HRETURN( hr );

} //*** CAsyncEvictCleanup::CleanupNode()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\evictcleanup\testevict\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file for the TestEvictCluster EXE.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Macro Definitions
//////////////////////////////////////////////////////////////////////////////

#if DBG==1 || defined( _DEBUG )
#define DEBUG
#endif

////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>
// For wprintf
#include <stdio.h>

// For smart classes
#include "SmartClasses.h"

// For IClusCfgEvict
#include "ClusCfgServer.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\evictcleanup\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file for the EvictCleanup library.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Macro Definitions
//////////////////////////////////////////////////////////////////////////////

#define _UNICODE
#define UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
#define USES_SYSALLOCSTRING
#endif


////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the windows API and types
#include <windows.h>

// For COM
#include <objbase.h>
#include <ComCat.h>

// Required to be a part of this DLL
#include <Common.h>
#include <Debug.h>
#include <Log.h>
#include <CITracker.h>
#include <CFactory.h>
#include <Dll.h>
#include <Guids.h>
#include <ClusCfgGuids.h>
#include <ClusCfgClient.h>
#include <ClusCfgServer.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\evictcleanup\testevict\testevict.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      TestEvictCleanup.h
//
//  Description:
//      Header file for TestEvictCleanup.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


#pragma once


////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>


////////////////////////////////////////////////////////////////////////////////
// Function declarations
//////////////////////////////////////////////////////////////////////////////

void ShowUsage();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\evictcleanup\evictcleanup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      EvictCleanup.cpp
//
//  Description:
//      This file contains the implementation of the CEvictCleanup
//      class.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Header File:
//      EvictCleanup.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "pch.h"

// For the GetNodeClusterState() API
#include <clusapi.h>

// The header file for this class
#include "EvictCleanup.h"

// For IClusCfgNodeInfo and related interfaces
#include <ClusCfgServer.h>

// For IClusCfgServer and related interfaces
#include <ClusCfgPrivate.h>

// For CClCfgSrvLogger
#include <Logger.h>

// For SUCCESSFUL_CLEANUP_EVENT_NAME
#include "EventName.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CEvictCleanup" );


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictCleanup::CEvictCleanup()
//
//  Description:
//      Constructor of the CEvictCleanup class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEvictCleanup::CEvictCleanup( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    TraceFlow1( "Component count = %d.", g_cObjects );

    TraceFuncExit();

} //*** CEvictCleanup::CEvictCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictCleanup::~CEvictCleanup()
//
//  Description:
//      Destructor of the CEvictCleanup class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEvictCleanup::~CEvictCleanup( void )
{
    TraceFunc( "" );

    if ( m_plLogger != NULL )
    {
        m_plLogger->Release();
    }
    TraceSysFreeString( m_bstrNodeName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFlow1( "Component count = %d.", g_cObjects );

    TraceFuncExit();

} //*** CEvictCleanup::~CEvictCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CEvictCleanup::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//  Description:
//      Creates a CEvictCleanup instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEvictCleanup::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr = E_INVALIDARG;
    CEvictCleanup *     pEvictCleanup = NULL;

    // Allocate memory for the new object.
    pEvictCleanup = new CEvictCleanup();
    if ( pEvictCleanup == NULL )
    {
        ::LogMsg( "EvictCleanup: Could not allocate memory for a evict cleanup object." );
        TraceFlow( "Could not allocate memory for a evict cleanup object." );
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: out of memory

    // Initialize the new object.
    hr = THR( pEvictCleanup->HrInit( ) );

    if ( FAILED( hr ) )
    {
        ::LogMsg( "EvictCleanup: Error %#08x occurred initializing a evict cleanup object.", hr );
        TraceFlow1( "Error %#08x occurred initializing a evict cleanup object.", hr );
        goto Cleanup;
    } // if: the object could not be initialized

    hr = THR( pEvictCleanup->QueryInterface( IID_IUnknown, reinterpret_cast< void ** >( ppunkOut ) ) );

    TraceFlow1( "*ppunkOut = %p.", *ppunkOut );

Cleanup:

    if ( pEvictCleanup != NULL )
    {
        pEvictCleanup->Release();
    } // if: the pointer to the resource type object is not NULL

    HRETURN( hr );

} //*** CEvictCleanup::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEvictCleanup::AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEvictCleanup::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    TraceFlow1( "m_cRef = %d", m_cRef );

    RETURN( m_cRef );

} //*** CEvictCleanup::AddRef()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEvictCleanup::Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEvictCleanup::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    InterlockedDecrement( &m_cRef );
    cRef = m_cRef;

    TraceFlow1( "m_cRef = %d", m_cRef );

    if ( m_cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count decremented to zero

    RETURN( cRef );

} //*** CEvictCleanup::Release()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CEvictCleanup::QueryInterface()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      IN  REFIID  riidIn
//          Id of interface requested.
//
//      OUT void ** ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEvictCleanup::QueryInterface( REFIID  riidIn, void ** ppvOut )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    if ( ppvOut != NULL )
    {
        if ( IsEqualIID( riidIn, IID_IUnknown ) )
        {
            *ppvOut = static_cast< IClusCfgEvictCleanup * >( this );
        } // if: IUnknown
        else if ( IsEqualIID( riidIn, IID_IClusCfgEvictCleanup ) )
        {
            *ppvOut = TraceInterface( __THISCLASS__, IClusCfgEvictCleanup, this, 0 );
        } // else if: IClusCfgEvictCleanup
        else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
        {
            *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
        } // else if: IClusCfgCallback
        else
        {
            hr = E_NOINTERFACE;
        } // else

        if ( SUCCEEDED( hr ) )
        {
            ((IUnknown *) *ppvOut)->AddRef( );
        } // if: success
        else
        {
            *ppvOut = NULL;
        } // else: something failed

    } // if: the output pointer was valid
    else
    {
        hr = E_INVALIDARG;  // TODO: DavidP 02-OCT-2000 Shouldn't this be E_NOINTERFACE?
    } // else: the output pointer is invalid


    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CEvictCleanup::QueryInterface()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictCleanup::HrInit()
//
//  Description:
//      Second phase of a two phase constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEvictCleanup::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //
    // Save off the local computer name.
    //
    hr = THR( HrGetComputerName( ComputerNameDnsFullyQualified, &m_bstrNodeName ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Get a ClCfgSrv ILogger instance.
    //
    hr = CClCfgSrvLogger::S_HrGetLogger( &m_plLogger );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    HRETURN( hr );

} //*** CEvictCleanup::HrInit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictCleanup::CleanupLocalNode()
//
//  Description:
//      This method performs the clean up actions on the local node after
//      it has been evicted from a cluster, so that the node can go back
//      to its "pre-clustered" state.
//
//  Arguments:
//      DWORD dwDelayIn
//          Number of milliseconds that this method will wait before starting
//          cleanup. If some other process cleans up this node while this thread
//          is waiting, the wait is terminated. If this value is zero, this method
//          will attempt to clean up this node immediately.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEvictCleanup::CleanupLocalNode( DWORD dwDelayIn )
{
    TraceFunc( "[IClusCfgEvictCleanup]" );

    HRESULT                 hr = S_OK;
    IClusCfgServer *        pccsClusCfgServer = NULL;
    IClusCfgNodeInfo *      pccniNodeInfo = NULL;
    IClusCfgInitialize *    pcciInitialize = NULL;
    IClusCfgClusterInfo *   pccciClusterInfo = NULL;
    IUnknown *              punkCallback = NULL;
    HANDLE                  heventCleanupComplete = NULL;
    DWORD                   dwClusterState;
    DWORD                   dwError;

#if 0
    bool                    fWaitForDebugger = true;

    while ( fWaitForDebugger )
    {
        Sleep( 3000 );
    } // while: waiting for the debugger to break in
#endif

    LogMsg( L"EvictCleanup: Trying to cleanup local node." );
    TraceFlow( "Trying to cleanup local node." );


    // If the caller has requested a delayed cleanup, wait.
    if ( dwDelayIn > 0 )
    {
        LogMsg( L"EvictCleanup: Delayed cleanup requested. Delaying for %1!d! milliseconds.", dwDelayIn );
        TraceFlow1( "Delayed cleanup requested. Delaying for %d milliseconds.", dwDelayIn );

        heventCleanupComplete = CreateEvent(
              NULL                              // security attributes
            , TRUE                              // manual reset event
            , FALSE                             // initial state is non-signaled
            , SUCCESSFUL_CLEANUP_EVENT_NAME     // event name
            );

        if ( heventCleanupComplete == NULL )
        {
            dwError = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( dwError );
            LogMsg( L"EvictCleanup: Error %1!#08x! occurred trying to create the cleanup completion event.", dwError );
            TraceFlow1( "Error %#08x occurred trying to create the cleanup completion event.", dwError );
            goto Cleanup;
        } // if: CreateEvent() failed

        // Wait for this event to get signaled or until dwDelayIn milliseconds are up.
        do
        {
            // Wait for any message sent or posted to this queue
            // or for our event to be signaled.
            dwError = MsgWaitForMultipleObjects(
                  1
                , &heventCleanupComplete
                , FALSE
                , dwDelayIn         // If no one has signaled this event in dwDelayIn milliseconds, abort.
                , QS_ALLINPUT
                );

            // The result tells us the type of event we have.
            if ( dwError == ( WAIT_OBJECT_0 + 1 ) )
            {
                MSG msg;

                // Read all of the messages in this next loop,
                // removing each message as we read it.
                while ( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 )
                {
                    // If it is a quit message, we are done pumping messages.
                    if ( msg.message == WM_QUIT)
                    {
                        TraceFlow( "Get a WM_QUIT message. Exit message pump loop." );
                        break;
                    } // if: we got a WM_QUIT message

                    // Otherwise, dispatch the message.
                    DispatchMessage( &msg );
                } // while: there are still messages in the window message queue

            } // if: we have a message in the window message queue
            else
            {
                if ( dwError == WAIT_OBJECT_0 )
                {
                    TraceFlow( "Some other process has cleaned up this node while we were waiting. Exiting wait loop." );
                    LogMsg( L"EvictCleanup: Some other process has cleaned up this node while we were waiting. Exiting wait loop." );
                } // if: our event is signaled
                else if ( dwError == WAIT_TIMEOUT )
                {
                    LogMsg( L"EvictCleanup: The wait of %1!d! milliseconds is over. Proceeding with cleanup.", dwDelayIn );
                    TraceFlow1( "The wait of %d milliseconds is over. Proceeding with cleanup.", dwDelayIn );
                } // else if: we timed out
                else if ( dwError == -1 )
                {
                    hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
                    LogMsg( L"EvictCleanup: Error %1!#08x! occurred trying to wait for an event to be signaled.", hr );
                    TraceFlow1( "Error %#08x occurred trying to wait for the cleanup completion event to be signaled.", hr );
                } // else if: MsgWaitForMultipleObjects() returned an error
                else
                {
                    hr = THR( HRESULT_FROM_WIN32( dwError ) );
                    LogMsg( L"EvictCleanup: An error occurred trying to wait for an event to be signaled. Status code is %1!#08x!.", dwError );
                    TraceFlow1( "An error occurred trying to wait for the cleanup completion event to be signaled. Status code is %#08x.", dwError );
                } // else: an unexpected value was returned by MsgWaitForMultipleObjects()

                break;
            } // else: MsgWaitForMultipleObjects() exited for a reason other than a waiting message
        }
        while( true ); // do-while: loop infinitely

        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if: something went wrong while waiting

        TraceFlow1( "Delay of %d milliseconds completed.", dwDelayIn );
    } // if: the caller has requested delayed cleanup

    TraceFlow( "Check node cluster state." );

    // Check the node cluster state
    dwError = TW32( GetNodeClusterState( NULL, &dwClusterState ) );
    if ( dwError != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwError );
        LogMsg( L"EvictCleanup: Error %1!#08x! occurred trying to get the state of the cluster service on this node.", hr );
        TraceFlow1( "Error %#08x occurred trying to get the state of the cluster service on this node.", hr );
        goto Cleanup;
    } // if: we could not get the node cluster state

    if ( ( dwClusterState != ClusterStateNotRunning ) && ( dwClusterState != ClusterStateRunning ) )
    {
        LogMsg( L"EvictCleanup: This node is not part of a cluster - no cleanup is necessary." );
        TraceFlow( "This node is not part of a cluster - no cleanup is necessary." );
        goto Cleanup;
    } // if: this node is not part of a cluster

    TraceFlow( "Stopping the cluster service." );
    //
    // NOTE: GetNodeClusterState() returns ClusterStateNotRunning if the cluster service is not in the
    // SERVICE_RUNNING state. However, this does not mean that the service is not running, since it could
    // be in the SERVICE_PAUSED, SERVICE_START_PENDING, etc. states.
    //
    // So, try and stop the service anyway. Query for the service state 300 times, once every 1000 ms.
    //
    dwError = TW32( DwStopService( L"ClusSvc", 1000, 300 ) );
    hr = HRESULT_FROM_WIN32( dwError );
    if ( FAILED( hr ) )
    {
        LogMsg( L"EvictCleanup: Error %1!#08x! occurred trying to stop the cluster service. Aborting cleanup.", dwError );
        TraceFlow1( "Error %#08x occurred trying to stop the cluster service. Aborting cleanup.", dwError );
        goto Cleanup;
    } // if: we could not stop the cluster service in the specified time

    //
    // If we are here, the cluster service is not running any more.
    // Create the ClusCfgServer component
    //
    hr = THR(
        CoCreateInstance(
              CLSID_ClusCfgServer
            , NULL
            , CLSCTX_INPROC_SERVER
            , __uuidof( pcciInitialize )
            , reinterpret_cast< void ** >( &pcciInitialize )
            )
        );
    if ( FAILED( hr ) )
    {
        LogMsg( L"EvictCleanup: Error %1!#08x! occurred trying to create the cluster configuration server.", hr );
        TraceFlow1( "Error %#08x occurred trying to create the cluster configuration server.", hr );
        goto Cleanup;
    } // if: we could not create the ClusCfgServer component

    hr = THR( TypeSafeQI( IUnknown, &punkCallback ) );
    if ( FAILED( hr ) )
    {
        LogMsg( L"EvictCleanup: Error %1!#08x! occurred trying to get an IUnknown interface pointer to the IClusCfgCallback interface.", hr );
        TraceFlow1( "Error %#08x occurred trying to get an IUnknown interface pointer to the IClusCfgCallback interface.", hr );
        goto Cleanup;
    } // if:

    hr = THR( pcciInitialize->Initialize( punkCallback, LOCALE_SYSTEM_DEFAULT ) );
    if ( FAILED( hr ) )
    {
        LogMsg( L"EvictCleanup: Error %1!#08x! occurred trying to initialize the cluster configuration server.", hr );
        TraceFlow1( "Error %#08x occurred trying to initialize the cluster configuration server.", hr );
        goto Cleanup;
    } // if: IClusCfgInitialize::Initialize() failed

    hr = THR( pcciInitialize->QueryInterface< IClusCfgServer >( &pccsClusCfgServer ) );
    if ( FAILED( hr ) )
    {
        LogMsg( L"EvictCleanup: Error %1!#08x! occurred trying to get a pointer to the cluster configuration server.", hr );
        TraceFlow1( "Error %#08x occurred trying to get a pointer to the cluster configuration server interface.", hr );
        goto Cleanup;
    } // if: we could not get a pointer to the IClusCfgServer interface

    hr = THR( pccsClusCfgServer->GetClusterNodeInfo( &pccniNodeInfo ) );
    if ( FAILED( hr ) )
    {
        LogMsg( L"EvictCleanup: Error %1!#08x! occurred trying to get the node information.", hr );
        TraceFlow1( "Error %#08x occurred trying to get a pointer to the IClusCfgNodeInfo interface.", hr );
        goto Cleanup;
    } // if: we could not get a pointer to the IClusCfgNodeInfo interface

    hr = THR( pccniNodeInfo->GetClusterConfigInfo( &pccciClusterInfo ) );
    if ( FAILED( hr ) )
    {
        LogMsg( L"EvictCleanup: Error %1!#08x! occurred trying to get the cluster information.", hr );
        TraceFlow1( "Error %#08x occurred trying to get a pointer to the IClusCfgClusterInfo interface.", hr );
        goto Cleanup;
    } // if: we could not get a pointer to the IClusCfgClusterInfo interface

    hr = THR( pccciClusterInfo->SetCommitMode( cmCLEANUP_NODE_AFTER_EVICT ) );
    if ( FAILED( hr ) )
    {
        LogMsg( L"EvictCleanup: Error %1!#08x! occurred trying to set the cluster commit mode.", hr );
        TraceFlow1( "Error %#08x occurred trying to call IClusCfgClusterInfo::SetCommitMode() interface.", hr );
        goto Cleanup;
    } // if: IClusCfgClusterInfo::SetEvictMode() failed

    TraceFlow( "Starting cleanup of this node." );

    // Do the cleanup
    hr = THR( pccsClusCfgServer->CommitChanges() );
    if ( FAILED( hr ) )
    {
        LogMsg( L"EvictCleanup: Error %1!#08x! occurred trying to clean up after evict.", hr );
        TraceFlow1( "Error %#08x occurred trying to clean up after evict.", hr );
        goto Cleanup;
    } // if: an error occurred trying to clean up after evict

    LogMsg( L"EvictCleanup: Local node cleaned up successfully." );
    TraceFlow( "Local node cleaned up successfully." );

Cleanup:
    //
    // Clean up
    //

    if ( punkCallback != NULL )
    {
        punkCallback->Release();
    } // if: we had queried for an IUnknown pointer on our IClusCfgCallback interface

    if ( pccsClusCfgServer != NULL )
    {
        pccsClusCfgServer->Release();
    } // if: we had created the ClusCfgServer component

    if ( pccniNodeInfo != NULL )
    {
        pccniNodeInfo->Release();
    } // if: we had acquired a pointer to the node info interface

    if ( pcciInitialize != NULL )
    {
        pcciInitialize->Release();
    } // if: we had acquired a pointer to the initialization interface

    if ( pccciClusterInfo != NULL )
    {
        pccciClusterInfo->Release();
    } // if: we had acquired a pointer to the cluster info interface

    if ( heventCleanupComplete == NULL )
    {
        CloseHandle( heventCleanupComplete );
    } // if: we had created the cleanup complete event

    HRETURN( hr );

} //*** CEvictCleanup::CleanupLocalNode()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictCleanup::CleanupRemoteNode()
//
//  Description:
//      This method performs the clean up actions on a remote node after
//      it has been evicted from a cluster, so that the node can go back
//      to its "pre-clustered" state.
//
//  Arguments:
//      const WCHAR * pcszEvictedNodeNameIn
//          Name of the node that has just been evicted. This can be the
//          NetBios name of the node, the fully qualified domain name or
//          the node IP address. If NULL, the local machine is cleaned up.
//
//      DWORD dwDelayIn
//          Number of milliseconds that this method will wait before starting
//          cleanup. If some other process cleans up this node while this thread
//          is waiting, the wait is terminated. If this value is zero, this method
//          will attempt to clean up this node immediately.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEvictCleanup::CleanupRemoteNode( const WCHAR * pcszEvictedNodeNameIn, DWORD dwDelayIn )
{
    TraceFunc( "[IClusCfgEvictCleanup]" );

    HRESULT                 hr = S_OK;
    IClusCfgEvictCleanup *  pcceEvict = NULL;

    MULTI_QI mqiInterfaces[] =
    {
        { &IID_IClusCfgEvictCleanup, NULL, S_OK },
    };

    COSERVERINFO    csiServerInfo;
    COSERVERINFO *  pcsiServerInfoPtr = &csiServerInfo;

    if ( pcszEvictedNodeNameIn == NULL )
    {
        LogMsg( L"EvictCleanup: The local node will be cleaned up." );
        TraceFlow( "The local node will be cleaned up." );
        pcsiServerInfoPtr = NULL;
    } // if: we have to cleanup the local node
    else
    {
        LogMsg( L"EvictCleanup: The remote node to be cleaned up is '%1!ws!'.", pcszEvictedNodeNameIn );
        TraceFlow1( "The remote node to be cleaned up is '%ws'.", pcszEvictedNodeNameIn );

        csiServerInfo.dwReserved1 = 0;
        csiServerInfo.pwszName = const_cast< LPWSTR >( pcszEvictedNodeNameIn );
        csiServerInfo.pAuthInfo = NULL;
        csiServerInfo.dwReserved2 = 0;
    } // else: we have to clean up a remote node

    // Instantiate this component remotely
    hr = THR(
        CoCreateInstanceEx(
              CLSID_ClusCfgEvictCleanup
            , NULL
            , CLSCTX_LOCAL_SERVER
            , pcsiServerInfoPtr
            , sizeof( mqiInterfaces ) / sizeof( mqiInterfaces[0] )
            , mqiInterfaces
            )
        );
    if ( FAILED( hr ) )
    {
        LogMsg( L"EvictCleanup: Error %1!#08x! occurred trying to instantiate the evict processing component. For example, the evicted node may be down right now or not accessible.", hr );
        TraceFlow1( "Error %#08x occurred trying to instantiate the evict processing component.", hr );
        goto Cleanup;
    } // if: we could not instantiate the evict processing component

    // Make the evict call.
    pcceEvict = reinterpret_cast< IClusCfgEvictCleanup * >( mqiInterfaces[0].pItf );
    hr = THR( pcceEvict->CleanupLocalNode( dwDelayIn ) );
    if ( FAILED( hr ) )
    {
        LogMsg( L"EvictCleanup: Error %1!#08x! occurred trying to initiate evict processing.", hr );
        TraceFlow1( "Error %#08x occurred trying to initiate evict processing.", hr );
        goto Cleanup;
    } // if: we could not initiate evict processing

Cleanup:
    //
    // Clean up
    //
    if ( pcceEvict != NULL )
    {
        pcceEvict->Release();
    } // if: we had got a pointer to the IClusCfgEvictCleanup interface

    HRETURN( hr );

} //*** CEvictCleanup::CleanupRemoteNode()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CEvictCleanup::DwStopService()
//
//  Description:
//      Instructs the SCM to stop a service. This function tests
//      cQueryCountIn times to see if the service has  stopped, checking
//      every ulQueryIntervalMilliSecIn milliseconds.
//
//  Arguments:
//      pcszServiceNameIn
//          Name of the service to stop
//
//      ulQueryIntervalMilliSecIn
//          Number of milliseconds between checking to see if the service
//          has stopped. The default value is 500 milliseconds.
//
//      cQueryCountIn
//          The number of times this function will query the service (not
//          including an initial query) to see if it has stopped. The default
//          value is 10 times.
//
//  Return Value:
//      ERROR_SUCCESS
//          Success.
//
//      Other Win32 error codes
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
CEvictCleanup::DwStopService(
      const WCHAR * pcszServiceNameIn
    , ULONG         ulQueryIntervalMilliSecIn
    , ULONG         cQueryCountIn
    )
{
    TraceFunc( "" );

    DWORD           dwError = ERROR_SUCCESS;
    SC_HANDLE       schSCMHandle = NULL;
    SC_HANDLE       schServiceHandle = NULL;

    SERVICE_STATUS  ssStatus;
    bool            fStopped = false;
    UINT            cNumberOfQueries = 0;

    LogMsg( L"EvictCleanup: Attempting to stop the '%1!ws!' service.", pcszServiceNameIn );
    TraceFlow1( "Attempting to stop the '%ws' service.", pcszServiceNameIn );

    // Open a handle to the service control manager.
    schSCMHandle = OpenSCManager( NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS );
    if ( schSCMHandle == NULL )
    {
        dwError = TW32( GetLastError() );
        LogMsg( L"EvictCleanup: Error %1!#08x! occurred trying to open a handle to the service control manager.", dwError );
        TraceFlow1( "Error %#08x occurred trying to open a handle to the service control manager.", dwError );
        goto Cleanup;
    } // if: we could not open a handle to the service control mananger

    // Open a handle to the service.
    schServiceHandle = OpenService(
          schSCMHandle
        , pcszServiceNameIn
        , SERVICE_STOP | SERVICE_QUERY_STATUS
        );

    // Check if we could open a handle to the service.
    if ( schServiceHandle == NULL )
    {
        // We could not get a handle to the service.
        dwError = GetLastError();

        // Check if the service exists.
        if ( dwError == ERROR_SERVICE_DOES_NOT_EXIST )
        {
            // Nothing needs to be done here.
            LogMsg( L"EvictCleanup: The '%1!ws!' service does not exist, so it is not running. Nothing needs to be done to stop it.", pcszServiceNameIn );
            TraceFlow1( "The '%ws' service does not exist, so it is not running. Nothing needs to be done to stop it.", pcszServiceNameIn );
            dwError = ERROR_SUCCESS;
        } // if: the service does not exist
        else
        {
            // Something else has gone wrong.
            TW32( dwError );
            LogMsg( L"EvictCleanup: Error %1!#08x! occurred trying to open the '%2!ws!' service.", dwError, pcszServiceNameIn );
            TraceFlow2( "Error %#08x occurred trying to open the '%ws' service.", dwError, pcszServiceNameIn );
        } // else: the service exists

        goto Cleanup;
    } // if: the handle to the service could not be opened.


    TraceFlow( "Querying the service for its initial state." );

    // Query the service for its initial state.
    ZeroMemory( &ssStatus, sizeof( ssStatus ) );
    if ( QueryServiceStatus( schServiceHandle, &ssStatus ) == 0 )
    {
        dwError = TW32( GetLastError() );
        LogMsg( L"EvictCleanup: Error %1!#08x! occurred while trying to query the initial state of the '%2!ws!' service.", dwError, pcszServiceNameIn );
        TraceFlow2( "Error %#08x occurred while trying to query the initial state of the '%ws' service.", dwError, pcszServiceNameIn );
        goto Cleanup;
    } // if: we could not query the service for its status.

    // If the service has stopped, we have nothing more to do.
    if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
    {
        // Nothing needs to be done here.
        LogMsg( L"EvictCleanup: The '%1!ws!' service is not running. Nothing needs to be done to stop it.", pcszServiceNameIn );
        TraceFlow1( "The '%ws' service is not running. Nothing needs to be done to stop it.", pcszServiceNameIn );
        goto Cleanup;
    } // if: the service has stopped.

    // If we are here, the service is running.
    TraceFlow( "The service is running." );

    //
    // Try and stop the service.
    //

    // If the service is stopping on its own, no need to send the stop control code.
    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
    {
        TraceFlow( "The service is stopping on its own. The stop control code will not be sent." );
    } // if: the service is stopping already
    else
    {
        TraceFlow( "The stop control code will be sent after 30 seconds." );

        ZeroMemory( &ssStatus, sizeof( ssStatus ) );
        if ( ControlService( schServiceHandle, SERVICE_CONTROL_STOP, &ssStatus ) == 0 )
        {
            dwError = GetLastError();
            if ( dwError == ERROR_SERVICE_NOT_ACTIVE )
            {
                LogMsg( L"EvictCleanup: The '%1!ws!' service is not running. Nothing more needs to be done here.", pcszServiceNameIn );
                TraceFlow1( "The '%ws' service is not running. Nothing more needs to be done here.", pcszServiceNameIn );

                // The service is not running. Change the error code to success.
                dwError = ERROR_SUCCESS;
            } // if: the service is already running.
            else
            {
                TW32( dwError );
                LogMsg( L"EvictCleanup: Error %1!#08x! occurred trying to stop the '%2!ws!' service.", dwError, pcszServiceNameIn );
                TraceFlow2( "Error %#08x occurred trying to stop the '%ws' service.", dwError, pcszServiceNameIn );
            }

            // There is nothing else to do.
            goto Cleanup;
        } // if: an error occurred trying to stop the service.
    } // else: the service has to be instructed to stop


    // Query the service for its state now and wait till the timeout expires
    cNumberOfQueries = 0;
    do
    {
        // Query the service for its status.
        ZeroMemory( &ssStatus, sizeof( ssStatus ) );
        if ( QueryServiceStatus( schServiceHandle, &ssStatus ) == 0 )
        {
            dwError = TW32( GetLastError() );
            LogMsg( L"EvictCleanup: Error %1!#08x! occurred while trying to query the state of the '%2!ws!' service.", dwError, pcszServiceNameIn );
            TraceFlow2( "Error %#08x occurred while trying to query the state of the '%ws' service.", dwError, pcszServiceNameIn );
            break;
        } // if: we could not query the service for its status.

        // If the service has stopped, we have nothing more to do.
        if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
        {
            // Nothing needs to be done here.
            TraceFlow( "The service has been stopped." );
            fStopped = true;
            dwError = ERROR_SUCCESS;
            break;
        } // if: the service has stopped.

        // Check if the timeout has expired
        if ( cNumberOfQueries >= cQueryCountIn )
        {
            TraceFlow( "The service stop wait timeout has expired." );
            break;
        } // if: number of queries has exceeded the maximum specified

        TraceFlow2(
              "Waiting for %d milliseconds before querying service status again. %d such queries remaining."
            , ulQueryIntervalMilliSecIn
            , cQueryCountIn - cNumberOfQueries
            );

        ++cNumberOfQueries;

         // Wait for the specified time.
        Sleep( ulQueryIntervalMilliSecIn );

    }
    while ( true ); // while: loop infinitely

    if ( dwError != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: something went wrong.

    if ( ! fStopped )
    {
        dwError = TW32( ERROR_SERVICE_REQUEST_TIMEOUT );
        LogMsg( L"EvictCleanup: The '%1!ws!' service has not stopped even after %2!d! queries.", pcszServiceNameIn, cQueryCountIn );
        TraceFlow2( "The '%ws' service has not stopped even after %d queries.", pcszServiceNameIn, cQueryCountIn );
        goto Cleanup;
    } // if: the maximum number of queries have been made and the service is not running.

    LogMsg( L"EvictCleanup: The '%1!ws!' service was successfully stopped.", pcszServiceNameIn );
    TraceFlow1( "The '%ws' service was successfully stopped.", pcszServiceNameIn );

Cleanup:
    if ( dwError != ERROR_SUCCESS )
    {
        LogMsg( L"EvictCleanup: Error %1!#08x! has occurred trying to stop the '%2!ws!' service.", dwError, pcszServiceNameIn );
        TraceFlow2( "Error %#08x has occurred trying to stop the '%ws' service.", dwError, pcszServiceNameIn );
    } // if: something has gone wrong


    //
    // Cleanup
    //

    if ( schSCMHandle != NULL )
    {
        CloseServiceHandle( schSCMHandle );
    } // if: we had opened a handle to the service control manager

    if ( schServiceHandle != NULL )
    {
        CloseServiceHandle( schServiceHandle );
    } // if: we had opened a handle to the service being stopped

    RETURN( dwError );

} //*** CEvictCleanup::DwStopService()


//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEvictCleanup::SendStatusReport(
//        LPCWSTR       pcszNodeNameIn
//      , CLSID         clsidTaskMajorIn
//      , CLSID         clsidTaskMinorIn
//      , ULONG         ulMinIn
//      , ULONG         ulMaxIn
//      , ULONG         ulCurrentIn
//      , HRESULT       hrStatusIn
//      , LPCWSTR       pcszDescriptionIn
//      , FILETIME *    pftTimeIn
//      , LPCWSTR       pcszReferenceIn
//      )
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEvictCleanup::SendStatusReport(
      LPCWSTR       pcszNodeNameIn
    , CLSID         clsidTaskMajorIn
    , CLSID         clsidTaskMinorIn
    , ULONG         ulMinIn
    , ULONG         ulMaxIn
    , ULONG         ulCurrentIn
    , HRESULT       hrStatusIn
    , LPCWSTR       pcszDescriptionIn
    , FILETIME *    pftTimeIn
    , LPCWSTR       pcszReferenceIn
    )
{
    TraceFunc1( "[IClusCfgCallback] pcszDescriptionIn = '%s'", pcszDescriptionIn == NULL ? TEXT("<null>") : pcszDescriptionIn );

    HRESULT hr = S_OK;

    if ( pcszNodeNameIn == NULL )
    {
        pcszNodeNameIn = m_bstrNodeName;
    } // if:

    TraceMsg( mtfFUNC, L"pcszNodeNameIn = %s", pcszNodeNameIn );
    TraceMsgGUID( mtfFUNC, "clsidTaskMajorIn ", clsidTaskMajorIn );
    TraceMsgGUID( mtfFUNC, "clsidTaskMinorIn ", clsidTaskMinorIn );
    TraceMsg( mtfFUNC, L"ulMinIn = %u", ulMinIn );
    TraceMsg( mtfFUNC, L"ulMaxIn = %u", ulMaxIn );
    TraceMsg( mtfFUNC, L"ulCurrentIn = %u", ulCurrentIn );
    TraceMsg( mtfFUNC, L"hrStatusIn = %#x", hrStatusIn );
    TraceMsg( mtfFUNC, L"pcszDescriptionIn = '%ws'", ( pcszDescriptionIn ? pcszDescriptionIn : L"<null>" ) );
    //
    //  TODO:   21 NOV 2000 GalenB
    //
    //  How do we log pftTimeIn?
    //
    TraceMsg( mtfFUNC, L"pcszReferenceIn = '%ws'", ( pcszReferenceIn ? pcszReferenceIn : L"<null>" ) );

    hr = THR( CClCfgSrvLogger::S_HrLogStatusReport(
                      m_plLogger
                    , pcszNodeNameIn
                    , clsidTaskMajorIn
                    , clsidTaskMinorIn
                    , ulMinIn
                    , ulMaxIn
                    , ulCurrentIn
                    , hrStatusIn
                    , pcszDescriptionIn
                    , pftTimeIn
                    , pcszReferenceIn
                    ) );

    HRETURN( hr );

} //*** CEvictCleanup::SendStatusReport()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CEvictCleanup::LogMsg(
//        LPCWSTR pszLogMsgIn
//      , ...
//      )
//
//  Description:
//      Wraps call to LogMsg on the logger object.
//
//  Arguments:
//      pszLogMsgIn     - Format string.
//      ...             - Arguments.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEvictCleanup::LogMsg(
      LPCWSTR pszLogMsgIn
    , ...
    )
{
    TraceFunc( "" );

    Assert( pszLogMsgIn != NULL );
    Assert( m_plLogger != NULL );

    HRESULT hr          = S_OK;
    BSTR    bstrLogMsg  = NULL;
    LPWSTR  pszLogMsg   = NULL;
    DWORD   cch;
    va_list valist;

    va_start( valist, pszLogMsgIn );

    cch = FormatMessage(
                  FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_STRING
                , pszLogMsgIn
                , 0
                , 0
                , (LPWSTR) &pszLogMsg
                , 0
                , &valist
                );

    va_end( valist );

    if ( cch == 0 )
        goto Win32Error;

    bstrLogMsg = TraceSysAllocStringLen( pszLogMsg, cch );
    if ( bstrLogMsg == NULL )
        goto OutOfMemory;

    m_plLogger->LogMsg( bstrLogMsg );

Cleanup:
    LocalFree( pszLogMsg );
    TraceSysFreeString( bstrLogMsg );
    TraceFuncExit();

Win32Error:
    hr = HRESULT_FROM_WIN32( TW32( GetLastError( ) ) );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CEvictCleanup::LogMsg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\exe\interfacetable.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InterfaceTable.cpp
//
//  Description:
//      Sucks in the Interface Table.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "InterfaceTableSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\exe\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "DebugSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\exe\citracker.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CITracker.cpp
//
//  Description:
//      Sucks in the CITracker library.
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "CITrackerSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\evictcleanup\asyncevictcleanup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      AsyncEvictCleanup.h
//
//  Description:
//      This file contains the declaration of the CAsyncEvictCleanup
//      class. This class handles is used to clean up a node after it has been
//      evicted from a cluster.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Implementation Files:
//      AsyncEvictCleanup.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 04-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For IUnknown
#include <unknwn.h>

// For IClusCfgAsyncEvictCleanup
#include "ClusCfgClient.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CAsyncEvictCleanup
//
//  Description:
//      This class handles is used to clean up a node after it has been
//      evicted from a cluster.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CAsyncEvictCleanup
    : public IClusCfgAsyncEvictCleanup
{
public:
    //////////////////////////////////////////////////////////////////////////
    // IUnknown methods
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgAsyncEvictCleanup methods
    //////////////////////////////////////////////////////////////////////////

    // Performs the clean up actions on a node after it has been evicted from
    // a cluster
    STDMETHOD( CleanupNode )(
          LPCWSTR   pcszEvictedNodeNameIn
        , DWORD     dwDelayIn
        , DWORD     dwTimeoutIn
        );


    //////////////////////////////////////////////////////////////////////////
    //  Other public methods
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );


private:
    //////////////////////////////////////////////////////////////////////////
    //  Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Second phase of a two phase constructor.
    HRESULT HrInit( void );

    //
    // Private constructors, destructor and assignment operator.
    // All of these methods are private for two reasons:
    // 1. Lifetimes of objects of this class are controlled by S_HrCreateInstance and Release.
    // 2. Copying of an object of this class is prohibited.
    //

    // Default constructor.
    CAsyncEvictCleanup( void );

    // Destructor.
    ~CAsyncEvictCleanup( void );

    // Copy constructor.
    CAsyncEvictCleanup( const CAsyncEvictCleanup & );

    // Assignment operator.
    CAsyncEvictCleanup & operator =( const CAsyncEvictCleanup & );


    //////////////////////////////////////////////////////////////////////////
    // Private member data
    //////////////////////////////////////////////////////////////////////////

    // Reference count for this object.
    LONG            m_cRef;

    // Pointer to the IDispatchInterface punk.
    IUnknown *      m_punkStdDisp;

}; //*** class CAsyncEvictCleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\evictcleanup\evictcleanup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      EvictCleanup.h
//
//  Description:
//      This file contains the declaration of the CEvictCleanup
//      class. This class handles is used to clean up a node after it has been
//      evicted from a cluster.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Implementation Files:
//      EvictCleanup.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 04-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For IUnknown
#include <unknwn.h>

// For IClusCfgEvictCleanup
#include <ClusCfgServer.h>

// For ILogger
#include <ClusCfgClient.h>

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEvictCleanup
//
//  Description:
//      This class handles is used to clean up a node after it has been
//      evicted from a cluster.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEvictCleanup
    : public IClusCfgEvictCleanup
    , public IClusCfgCallback
{
private:
    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // IUnknown
    LONG                m_cRef;                 // Reference counter.

    // IClusCfgCallback
    BSTR                m_bstrNodeName;         // Name of the local node.
    ILogger *           m_plLogger;             // ILogger for doing logging.

    //////////////////////////////////////////////////////////////////////////
    //  Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Second phase of a two phase constructor.
    HRESULT
        HrInit( void );

    // Instruct the SCM to stop a service
    DWORD
        DwStopService(
          const WCHAR * pcszServiceNameIn
        , ULONG         ulQueryIntervalMilliSecIn = 500
        , ULONG         cQueryCountIn = 10
        );

    // Wrap logging to the logger object.
    void
        LogMsg( LPCWSTR pszLogMsgIn, ... );

    //
    // Private constructors, destructor and assignment operator.
    // All of these methods are private for two reasons:
    // 1. Lifetimes of objects of this class are controlled by S_HrCreateInstance and Release.
    // 2. Copying of an object of this class is prohibited.
    //

    // Default constructor.
    CEvictCleanup( void );

    // Destructor.
    ~CEvictCleanup( void );

    // Copy constructor.
    CEvictCleanup( const CEvictCleanup & );

    // Assignment operator.
    CEvictCleanup & operator =( const CEvictCleanup & );

public:
    //////////////////////////////////////////////////////////////////////////
    // IUnknown methods
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgEvictCleanup methods
    //////////////////////////////////////////////////////////////////////////

    // Performs the clean up actions on the local node after it has been
    // evicted from a cluster
    STDMETHOD( CleanupLocalNode )( DWORD dwDelayIn );

    // Performs the clean up actions on a remote node after it has been
    // evicted from a cluster
    STDMETHOD( CleanupRemoteNode )( const WCHAR * pcszEvictedNodeNameIn, DWORD dwDelayIn );

    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgCallback methods
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD( SendStatusReport )(
                      LPCWSTR       pcszNodeNameIn
                    , CLSID         clsidTaskMajorIn
                    , CLSID         clsidTaskMinorIn
                    , ULONG         ulMinIn
                    , ULONG         ulMaxIn
                    , ULONG         ulCurrentIn
                    , HRESULT       hrStatusIn
                    , LPCWSTR       pcszDescriptionIn
                    , FILETIME *    pftTimeIn
                    , LPCWSTR       pcszReference
                    );

    //////////////////////////////////////////////////////////////////////////
    //  Other public methods
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );


}; //*** class CEvictCleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\evictcleanup\testevict\testevict.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      TestEvict.cpp
//
//  Description:
//      Main file for the test harness executable.
//      Initializes tracing, parses command line and actually call the 
//      IClusCfgEvictCleanup functions.
//
//  Documentation:
//      No documention for the test harness.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 04-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <stdio.h>
#include <objbase.h>
#include <limits.h>

#include <ClusCfgGuids.h>


// Show help for this executable.
void ShowUsage()
{
    wprintf( L"The syntax of this command is:\n" );
    wprintf( L"\nTestEvict.exe [computer-name]\n" );
}


// The main function for this program.
int __cdecl wmain( int argc, WCHAR *argv[] )
{
    HRESULT             hr = S_OK;

    // Initialize COM
    CoInitializeEx( 0, COINIT_MULTITHREADED );

    wprintf( L"\nInitiates evict processing on a computer.\n" );
    wprintf( L"Note: This computer must have Whistler (and the cluster binaries) for this command to work.\n" );

    do
    {
        CSmartIfacePtr< IClusCfgEvictCleanup > spEvict;

        if ( ( argc < 1 ) || ( argc > 2 ) ) 
        {
            ShowUsage();
            break;
        }

        {
            IClusCfgEvictCleanup *     cceTemp = NULL;

            hr = CoCreateInstance(
                      CLSID_ClusCfgEvictCleanup
                    , NULL
                    , CLSCTX_LOCAL_SERVER 
                    , __uuidof( IClusCfgEvictCleanup )
                    , reinterpret_cast< void ** >( &cceTemp )
                    );
            if ( FAILED( hr ) )
            {
                wprintf( L"Error %#x occurred trying to create the ClusCfgEvict component on the local machine.\n", hr );
                break;
            }

            // Store the retrieved pointer in a smart pointer for safe release.
            spEvict.Attach( cceTemp );
        }

        // Check if a computer name is specified.
        if ( argc == 2 )
        {
            CSmartIfacePtr< ICallFactory > spCallFactory;
            CSmartIfacePtr< AsyncIClusCfgEvictCleanup > spAsyncEvict;

            wprintf( L"Attempting to asynchronously initiate evict cleanup on computer '%s'.\n", argv[1] );

            hr = spCallFactory.HrQueryAndAssign( spEvict.PUnk() );
            if ( FAILED( hr ) )
            {
                wprintf( L"Error %#x occurred trying to create a call factory.\n", hr );
                break;
            }

            {
                AsyncIClusCfgEvictCleanup *    paicceAsyncEvict = NULL;

                hr = spCallFactory->CreateCall(
                      __uuidof( paicceAsyncEvict )
                    , NULL
                    , __uuidof( paicceAsyncEvict )
                    , reinterpret_cast< IUnknown ** >( &paicceAsyncEvict )
                    );

                if ( FAILED( hr ) )
                {
                    wprintf( L"Error %#x occurred trying to get a pointer to the asynchronous evict interface.\n", hr );
                    break;
                }

                spAsyncEvict.Attach( paicceAsyncEvict );
            }

            hr = spAsyncEvict->Begin_CleanupRemote( argv[ 1 ] );
            if ( FAILED( hr ) )
            {
                wprintf( L"Error %#x occurred trying to initiate asynchronous cleanup on remote computer.\n", hr );
                break;
            }
        }
        else
        {
            wprintf( L"Attempting evict cleanup on this computer.\n" );
            hr = spEvict->CleanupLocal( FALSE );
        }

        if ( FAILED( hr ) )
        {
            wprintf( L"Error %#x occurred trying to initiate evict processing.\n", hr );
            break;
        }

        wprintf( L"Evict processing successfully initiated.\n", hr );
    }
    while( false ); // dummy do-while loop to avoid gotos.

    CoUninitialize();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\inc\cluscfgconstants.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      ClusCfgContants.h
//
//  Description:
//      This file contains constants needed by more than one ClusCfg Wizard
//      component.
//
//  Maintained By:
//      Galen Barbee (GalenB)   23-FEB-2001
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Constants
//////////////////////////////////////////////////////////////////////////////

#define HR_S_RPC_S_SERVER_UNAVAILABLE  MAKE_HRESULT( 0, FACILITY_WIN32, RPC_S_SERVER_UNAVAILABLE )
#define HR_S_RPC_S_CLUSTER_NODE_DOWN    MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_CLUSTER_NODE_DOWN )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\exe\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Geoffrey Pease (GPease)     22-JAN-2000
//      Vijay Vasu (VVasu)          22-JAN-2000
//      Galen Barbee (GalenB)       22-JAN-2000
//      Cristian Scutaru (CScutaru) 22-JAN-2000
//      David Potter (DavidP)       22-JAN-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
// Define these to change Interface Tracking
//#define NO_TRACE_INTERFACES
//#define NOISY_TRACE_INTERFACES
//#define USES_SYSALLOCSTRING
#endif // DBG==1

//////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <objbase.h>
#include <ocidl.h>
#include <shlwapi.h>

#include <common.h>
#include <debug.h>
#include <citracker.h>
#include <guids.h>

//////////////////////////////////////////////////////////////////////////////
// Type Definitions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Global Definitions
//////////////////////////////////////////////////////////////////////////////
extern HINSTANCE g_hInstance;
extern LONG g_cObjects;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\exe\main.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      main.cpp
//
//  Description:
//      The entry point for the application that launches unattended 
//      installation of the cluster. This application parses input parameters,
//      CoCreates the Configuration Wizard Component, passes the parsed 
//      parameters and invokes the Wizard. The Wizard may or may not show any
//      UI depending on swithes and the (in)availability of information.
//
//  Maintained By:
//      Geoffrey Pease (GPease)     22-JAN-2000
//      Vijay Vasu (VVasu)          22-JAN-2000
//      Galen Barbee (GalenB)       22-JAN-2000
//      Cristian Scutaru (CScutaru) 22-JAN-2000
//      David Potter (DavidP)       22-JAN-2000
//
//////////////////////////////////////////////////////////////////////////////


#include "pch.h"
#include <initguid.h>
#include <guids.h>

DEFINE_MODULE( "CLUSCFG" )

HINSTANCE g_hInstance;
LONG      g_cObjects;

//////////////////////////////////////////////////////////////////////////////
//
//  int
//  _cdecl
//  main( void )
//
//  Description:
//      Program entrance.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK (0)        - Success.
//      other HRESULTs  - Error.
//
//////////////////////////////////////////////////////////////////////////////
int 
_cdecl
main( void )
{
    HRESULT hr;

    TraceInitializeProcess( NULL, 0 );

    hr = THR( CoInitialize( NULL ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    CoUninitialize( );

    TraceTerminateProcess( NULL, 0 );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\inc\cluscfgguids.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ClusCfgGuids.h
//
//  Description:
//      This file contains external GUID definitions.
//
//////////////////////////////////////////////////////////////////////////////

//
//  CATIDs
//

// {4653EEC4-2788-4ebd-A831-7E0D9F82D6E7}
DEFINE_GUID( CATID_ClusCfgCapabilities,
0x4653eec4, 0x2788, 0x4ebd, 0xa8, 0x31, 0x7e, 0xd, 0x9f, 0x82, 0xd6, 0xe7 );

// {02A34F88-D31A-4688-BDDD-38A739E4F89B}
DEFINE_GUID( CATID_EnumClusCfgManagedResources,
0x2a34f88, 0xd31a, 0x4688, 0xbd, 0xdd, 0x38, 0xa7, 0x39, 0xe4, 0xf8, 0x9b );

// {7C4CAE52-CAC9-499d-82C6-BC6A2177E556}
DEFINE_GUID( CATID_ClusCfgResourceTypes,
0x7c4cae52, 0xcac9, 0x499d, 0x82, 0xc6, 0xbc, 0x6a, 0x21, 0x77, 0xe5, 0x56 );

// {8A43EAD4-10F1-440d-8DAA-1FE38D1698CD}
DEFINE_GUID( CATID_ClusCfgMemberSetChangeListeners,
0x8a43ead4, 0x10f1, 0x440d, 0x8d, 0xaa, 0x1f, 0xe3, 0x8d, 0x16, 0x98, 0xcd );

// {DF406DB4-7872-4a99-BB3C-14A9C33933D1}
DEFINE_GUID( CATID_ClusCfgStartupListeners,
0xdf406db4, 0x7872, 0x4a99, 0xbb, 0x3c, 0x14, 0xa9, 0xc3, 0x39, 0x33, 0xd1 );


//
// CLSIDs
//

// {ABD0388A-DEC1-44f3-98E1-8D5CC80B97EB}
DEFINE_GUID( CLSID_ServiceManager,
0xabd0388a, 0xdec1, 0x44f3, 0x98, 0xe1, 0x8d, 0x5c, 0xc8, 0x0b, 0x97, 0xeb );

// {955661BD-CCA2-4eac-91D0-A0396A28AEFD}
DEFINE_GUID( CLSID_ObjectManager,
0x955661bd, 0xcca2, 0x4eac, 0x91, 0xd0, 0xa0, 0x39, 0x6a, 0x28, 0xae, 0xfd );

// {E1813DD0-AADA-4738-B5FF-96B4189C5019}
DEFINE_GUID( CLSID_NotificationManager,
0xe1813dd0, 0xaada, 0x4738, 0xb5, 0xff, 0x96, 0xb4, 0x18, 0x9c, 0x50, 0x19 );

// {C0F615A7-F874-4521-8791-ED3B84017EF7}
DEFINE_GUID( CLSID_TaskManager,
0xc0f615a7, 0xf874, 0x4521, 0x87, 0x91, 0xed, 0x3b, 0x84, 0x01, 0x7e, 0xf7 );

// {8FDA8FA4-8763-479f-B9B1-2202B280D293}
DEFINE_GUID( CLSID_LogManager,
0x8fda8fa4, 0x8763, 0x479f, 0xb9, 0xb1, 0x22, 0x2, 0xb2, 0x80, 0xd2, 0x93);

// {BF3768C2-E0E5-448f-952B-25D4332DEFA3}
DEFINE_GUID( CLSID_ClusterConfigurationType,
0xbf3768c2, 0xe0e5, 0x448f, 0x95, 0x2b, 0x25, 0xd4, 0x33, 0x2d, 0xef, 0xa3 );

// {32152BE9-DE8C-4d0f-81B0-BCE5D11ECB00}
DEFINE_GUID( CLSID_ClusCfgEvictCleanup,
0x32152be9, 0xde8c, 0x4d0f, 0x81, 0xb0, 0xbc, 0xe5, 0xd1, 0x1e, 0xcb, 0x0 );

// {08F35A72-D7C4-42f4-BC81-5188E19DFA39}
DEFINE_GUID( CLSID_ClusCfgAsyncEvictCleanup,
0x8f35a72, 0xd7c4, 0x42f4, 0xbc, 0x81, 0x51, 0x88, 0xe1, 0x9d, 0xfa, 0x39);

// {105EEEB6-32FD-4ea9-8912-843A7FF3CA2D}
DEFINE_GUID( CLSID_ClusCfgStartupNotify,
0x105eeeb6, 0x32fd, 0x4ea9, 0x89, 0x12, 0x84, 0x3a, 0x7f, 0xf3, 0xca, 0x2d);

// {D513C4F4-1D34-44a3-83D4-812651DB8918}
DEFINE_GUID( CLSID_ClusCfgResTypeGenScript,
0xd513c4f4, 0x1d34, 0x44a3, 0x83, 0xd4, 0x81, 0x26, 0x51, 0xdb, 0x89, 0x18);

// {B6870B44-0BDF-4b46-AC1F-6C691B622EDF}
DEFINE_GUID( CLSID_ClusCfgResTypeMajorityNodeSet,
0xb6870b44, 0xbdf, 0x4b46, 0xac, 0x1f, 0x6c, 0x69, 0x1b, 0x62, 0x2e, 0xdf);

// {6A370489-BB52-4727-B740-08F494163478}
DEFINE_GUID( CLSID_ClusCfgResTypeServices,
0x6a370489, 0xbb52, 0x4727, 0xb7, 0x40, 0x8, 0xf4, 0x94, 0x16, 0x34, 0x78);


//
//  Object Types
//

// {1AAA3D11-4792-44e4-9D49-78FED3691A14}
DEFINE_GUID( CLSID_NodeType,
0x1aaa3d11, 0x4792, 0x44e4, 0x9d, 0x49, 0x78, 0xfe, 0xd3, 0x69, 0x1a, 0x14 );

// {D4F3D51B-1755-4953-9C8B-2495ABE5E07E}
DEFINE_GUID( CLSID_NetworkType,
0xd4f3d51b, 0x1755, 0x4953, 0x9c, 0x8b, 0x24, 0x95, 0xab, 0xe5, 0xe0, 0x7e );

//
// Data Format GUIDs
//

#define DFGUID_ClusterConfigurationInfo IID_IClusCfgClusterInfo

#define DFGUID_NodeInformation IID_IClusCfgNodeInfo

#define DFGUID_EnumManageableNetworks IID_IEnumClusCfgNetworks

#define DFGUID_StandardInfo IID_IStandardInfo


//
//  Tasks
//

// {3140B5A6-9AFA-4588-8CA0-9BE8F8B61506}
DEFINE_GUID( TASK_AnalyzeCluster,
0x3140b5a6, 0x9afa, 0x4588, 0x8c, 0xa0, 0x9b, 0xe8, 0xf8, 0xb6, 0x15, 0x6 );

// {2D03030B-F084-4807-BBAC-94269E50B56F}
DEFINE_GUID( TASK_CommitClusterChanges,
0x2d03030b, 0xf084, 0x4807, 0xbb, 0xac, 0x94, 0x26, 0x9e, 0x50, 0xb5, 0x6f );


//
//  TASKIDs Major for categorizing callback notifications from server components.
//

// {B8453B8F-92FD-4350-A6D9-551FD018B791}
DEFINE_GUID( TASKID_Major_Checking_For_Existing_Cluster,
0xb8453b8f, 0x92fd, 0x4350, 0xa6, 0xd9, 0x55, 0x1f, 0xd0, 0x18, 0xb7, 0x91 );

// {93C32F99-39CA-4d38-9D7F-2707CA0EAF46}
DEFINE_GUID( TASKID_Major_Establish_Connection,
0x93c32f99, 0x39ca, 0x4d38, 0x9d, 0x7f, 0x27, 0x7, 0xca, 0xe, 0xaf, 0x46 );

// {CC5E57B1-4520-4672-B4BA-A288EC42946E}
DEFINE_GUID( TASKID_Major_Check_Node_Feasibility,
0xcc5e57b1, 0x4520, 0x4672, 0xb4, 0xba, 0xa2, 0x88, 0xec, 0x42, 0x94, 0x6e);

// {036BF567-2377-4bb3-8AE1-E4104E2EB3C5}
DEFINE_GUID( TASKID_Major_Find_Devices,
0x36bf567, 0x2377, 0x4bb3, 0x8a, 0xe1, 0xe4, 0x10, 0x4e, 0x2e, 0xb3, 0xc5 );

// {EBC8AEFF-10C3-4d5b-AC17-FC0F4C3871B7}
DEFINE_GUID( TASKID_Major_Check_Cluster_Feasibility,
0xebc8aeff, 0x10c3, 0x4d5b, 0xac, 0x17, 0xfc, 0xf, 0x4c, 0x38, 0x71, 0xb7 );

// {E25968DA-9C7B-42db-ADA9-BC4E34F17E6E}
DEFINE_GUID( TASKID_Major_Reanalyze,
0xe25968da, 0x9c7b, 0x42db, 0xad, 0xa9, 0xbc, 0x4e, 0x34, 0xf1, 0x7e, 0x6e );

// {6D47AF1F-7F17-4b80-8FAB-3A2D19B1233D}
DEFINE_GUID( TASKID_Major_Configure_Resource_Types,
0x6d47af1f, 0x7f17, 0x4b80, 0x8f, 0xab, 0x3a, 0x2d, 0x19, 0xb1, 0x23, 0x3d );

// {7C5F0774-1611-42b5-AF3C-6E124AC4D36B}
DEFINE_GUID( TASKID_Major_Configure_Cluster_Services, 
0x7c5f0774, 0x1611, 0x42b5, 0xaf, 0x3c, 0x6e, 0x12, 0x4a, 0xc4, 0xd3, 0x6b);

// {411BCDEC-69D3-4485-8D5D-E19EE77A6DD4}
DEFINE_GUID( TASKID_Major_Configure_Resources,
0x411bcdec, 0x69d3, 0x4485, 0x8d, 0x5d, 0xe1, 0x9e, 0xe7, 0x7a, 0x6d, 0xd4 );

// {64ECA0EA-9CB6-4324-9702-DF15C696C30A}
DEFINE_GUID( TASKID_Major_Client_Log,
0x64eca0ea, 0x9cb6, 0x4324, 0x97, 0x2, 0xdf, 0x15, 0xc6, 0x96, 0xc3, 0xa );

// {05AA0768-5F49-49cd-AFDC-96F9D51802D4}
DEFINE_GUID( TASKID_Major_Server_Log,
0x5aa0768, 0x5f49, 0x49cd, 0xaf, 0xdc, 0x96, 0xf9, 0xd5, 0x18, 0x2, 0xd4 );

// {CD36919C-9F31-46b4-A29D-AC87F4E6CC93}
DEFINE_GUID( TASKID_Major_Client_And_Server_Log,
0xcd36919c, 0x9f31, 0x46b4, 0xa2, 0x9d, 0xac, 0x87, 0xf4, 0xe6, 0xcc, 0x93 );

//
// Common Minor Task IDs.
//

// {2362D3DA-A6A4-4551-B846-7BB3A1365F56}
DEFINE_GUID( TASKID_Minor_Update_Progress,
0x2362d3da, 0xa6a4, 0x4551, 0xb8, 0x46, 0x7b, 0xb3, 0xa1, 0x36, 0x5f, 0x56 );


//
//  Resource Types
//

// {CC558763-3386-42ef-B150-BE793344D45F}
DEFINE_GUID( RESTYPE_PhysicalDisk,
0xcc558763, 0x3386, 0x42ef, 0xb1, 0x50, 0xbe, 0x79, 0x33, 0x44, 0xd4, 0x5f );

// {D9DDFB80-0BDC-40d4-B396-1AFD77DDD19C}
DEFINE_GUID( RESTYPE_ClusterQuorumDisk,
0xd9ddfb80, 0xbdc, 0x40d4, 0xb3, 0x96, 0x1a, 0xfd, 0x77, 0xdd, 0xd1, 0x9c );

// {E50DF832-477C-440c-B7A3-3823A6EF6CCB}
DEFINE_GUID( RESTYPE_ClusterIPAddress,
0xe50df832, 0x477c, 0x440c, 0xb7, 0xa3, 0x38, 0x23, 0xa6, 0xef, 0x6c, 0xcb );

// {B2897CCF-8D2C-4bc1-B496-6E2BC7A0BB38}
DEFINE_GUID( RESTYPE_ClusterNetName,
0xb2897ccf, 0x8d2c, 0x4bc1, 0xb4, 0x96, 0x6e, 0x2b, 0xc7, 0xa0, 0xbb, 0x38 );

// {E61ADE71-C79A-4fda-B1DB-A9B8D20C8B14}
DEFINE_GUID( RESTYPE_IPAddress,
0xe61ade71, 0xc79a, 0x4fda, 0xb1, 0xdb, 0xa9, 0xb8, 0xd2, 0xc, 0x8b, 0x14 );

// {C1D2FE1E-D332-445f-8DA1-12E5E2D37CBF}
DEFINE_GUID( RESTYPE_NetworkName,
0xc1d2fe1e, 0xd332, 0x445f, 0x8d, 0xa1, 0x12, 0xe5, 0xe2, 0xd3, 0x7c, 0xbf );

// {F004656D-5B48-4580-A1F4-C3EC14983D1E}
DEFINE_GUID( RESTYPE_LocalQuorum,
0xf004656d, 0x5b48, 0x4580, 0xa1, 0xf4, 0xc3, 0xec, 0x14, 0x98, 0x3d, 0x1e );

// {F372184D-DFDB-4370-A005-E1EF301B23A4}
DEFINE_GUID( RESTYPE_GenericScript,
0xf372184d, 0xdfdb, 0x4370, 0xa0, 0x5, 0xe1, 0xef, 0x30, 0x1b, 0x23, 0xa4 );

// {56BFAE11-D2F7-4f4f-9952-55AF19BAC3E9}
DEFINE_GUID( RESTYPE_MajorityNodeSet, 
0x56bfae11, 0xd2f7, 0x4f4f, 0x99, 0x52, 0x55, 0xaf, 0x19, 0xba, 0xc3, 0xe9);


//
//  Resource Class Types
//

// {12453A47-8C5E-4837-BAC6-B254B8F264CC}
DEFINE_GUID( RESCLASSTYPE_StorageDevice,
0x12453a47, 0x8c5e, 0x4837, 0xba, 0xc6, 0xb2, 0x54, 0xb8, 0xf2, 0x64, 0xcc );

// {57A80E0F-6F18-458b-A72A-D1170C479390}
DEFINE_GUID( RESCLASSTYPE_IPAddress,
0x57a80e0f, 0x6f18, 0x458b, 0xa7, 0x2a, 0xd1, 0x17, 0xc, 0x47, 0x93, 0x90 );

// {BBA69EB9-F5D0-487b-92AE-1BA10F392158}
DEFINE_GUID( RESCLASSTYPE_NetworkName,
0xbba69eb9, 0xf5d0, 0x487b, 0x92, 0xae, 0x1b, 0xa1, 0xf, 0x39, 0x21, 0x58 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\inc\nameutil.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      NameUtil.h
//
//  Description:
//      Name resolution utility.
//
//  Maintained By:
//      Galen Barbee (GalenB) 28-NOV-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

HRESULT
HrCreateBinding(
    IClusCfgCallback *  pcccbIn,
    const CLSID *       pclsidLogIn,
    BSTR                bstrNameIn,
    BSTR *              pbstrBindingOut
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\inc\logger.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      LoggerStream.h
//
//  Description:
//      ClCfgSrv Logger definition.
//
//  Maintained By:
//      David Potter (DavidP)   11-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Forward Class Definitions
//////////////////////////////////////////////////////////////////////////////

class CClCfgSrvLogger;

//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClCfgSrvLogger
//
//  Description:
//      Manages a logging stream to a file.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClCfgSrvLogger
    : public ILogger
{
private:
    // IUnknown
    LONG                            m_cRef;             // Reference counter.

    // ILogger
    static IGlobalInterfaceTable *  sm_pgit;            // Global Interface Table.
    static CRITICAL_SECTION *       sm_pcritsec;        // Critical section for Release.
    static bool                     sm_fRevokingFromGIT;// Currently revoking interface from GIT.
    static DWORD                    sm_cookieGITLogger; // Cookie for this logger interface.

private: // Methods
    //
    // Constructors, destructors, and initializers
    //

    CClCfgSrvLogger( void );
    ~CClCfgSrvLogger( void );
    STDMETHOD( HrInit )( void );

    // Private copy constructor to prevent copying.
    CClCfgSrvLogger( const CClCfgSrvLogger & rccslSrcIn );

    // Private assignment operator to prevent copying.
    const CClCfgSrvLogger & operator=( const CClCfgSrvLogger & rccslSrcIn );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown Interfaces
    STDMETHOD( QueryInterface )( REFIID riidIn, void ** ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // ILogger
    STDMETHOD( LogMsg )( LPCWSTR pcszMsgIn );

    static HRESULT
        S_HrGetLogger( ILogger ** pplLoggerOut );

    static HRESULT
        S_HrLogStatusReport(
          ILogger *     plLogger
        , LPCWSTR       pcszNodeNameIn
        , CLSID         clsidTaskMajorIn
        , CLSID         clsidTaskMinorIn
        , ULONG         ulMinIn
        , ULONG         ulMaxIn
        , ULONG         ulCurrentIn
        , HRESULT       hrStatusIn
        , LPCWSTR       pcszDescriptionIn
        , FILETIME *    pftTimeIn
        , LPCWSTR       pcszReferenceIn
        );

}; //*** class CClCfgSrvLogger

//////////////////////////////////////////////////////////////////////////////
//  Global Function Prototypes
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\inc\eventname.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      EventName.h
//
//  Description:
//      Header file containing the name of an event that is used to synchronize
//      post configuration with startup notification.
//
//  Maintained By:
//      Vij Vasu (VVasu) 27-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#define POSTCONFIG_COMPLETE_EVENT_NAME      L"Global\\Microsoft Cluster Configuration Post Configuration Completion Event"
#define SUCCESSFUL_CLEANUP_EVENT_NAME       L"Global\\Microsoft Cluster Configuration Successful Cleanup Completion Event"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\inc\objectcookie.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ObjectCookie.h
//
//  Description:
//      OBJECTCOOKIE definition
//
//  Maintained By:
//      Geoffrey Pease (GPease) 21-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

typedef DWORD OBJECTCOOKIE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\clusterconfiguration.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ClusterConfiguration.h
//
//  Description:
//      CClusterConfiguration implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CClusterConfiguration
class
CClusterConfiguration:
    public IExtendObjectManager,
    public IClusCfgClusterInfo,
    public IGatherData  // private
{
private:
    // IUnknown
    LONG                        m_cRef;

    // Async/IClusCfgClusterInfo
    ECommitMode             m_ecmCommitChangesMode;
    BSTR                    m_bstrClusterName;          // Cluster Name
    BSTR                    m_bstrClusterBindingString; // Cluster binding string.
    BOOL                    m_fHasNameChanged:1;        // If the cluster name has changed...
    ULONG                   m_ulIPAddress;              // Cluster IP Address
    ULONG                   m_ulSubnetMask;             // Cluster Subnet Mask
    IClusCfgCredentials *   m_picccServiceAccount;      // Cluster service account credentials
    IClusCfgNetworkInfo *   m_punkNetwork;              // Cluster network that the IP/subnet should be hosted.

    // IExtendObjectManager

private: // Methods
    CClusterConfiguration( void );
    ~CClusterConfiguration( void );
    STDMETHOD( Init )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgClusterInfo
    STDMETHOD( SetCommitMode )( ECommitMode ecmNewModeIn );
    STDMETHOD( GetCommitMode )( ECommitMode * pecmCurrentModeOut );
    STDMETHOD( GetName )( BSTR * pbstrNameOut );
    STDMETHOD( SetName )( LPCWSTR pcszNameIn );
    STDMETHOD( GetIPAddress )( ULONG * pulDottedQuadOut );
    STDMETHOD( SetIPAddress )( ULONG ulDottedQuadIn );
    STDMETHOD( GetSubnetMask )( ULONG * pulDottedQuadOut );
    STDMETHOD( SetSubnetMask )( ULONG ulDottedQuadIn );
    STDMETHOD( GetNetworkInfo )( IClusCfgNetworkInfo ** ppiccniOut );
    STDMETHOD( SetNetworkInfo )( IClusCfgNetworkInfo * piccniIn );
    STDMETHOD( GetClusterServiceAccountCredentials )( IClusCfgCredentials ** ppicccCredentialsOut );
    STDMETHOD( GetBindingString )( BSTR * pbstrBindingStringOut );
    STDMETHOD( SetBindingString )( LPCWSTR pcszBindingStringIn );

    // IGatherData
    STDMETHOD( Gather )( OBJECTCOOKIE cookieParentIn, IUnknown * punkIn );

    // IExtendObjectManager
    STDMETHOD( FindObject )(
                      OBJECTCOOKIE cookieIn
                    , REFCLSID     rclsidTypeIn
                    , LPCWSTR      pcszName
                    , LPUNKNOWN *  ppunkOut
                    );

}; // class CClusterConfiguration
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\clusterconfiguration.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ClusterConfiguration.cpp
//
//  Description:
//      CClusterConfiguration implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "ClusterConfiguration.h"
#include "ManagedNetwork.h"

DEFINE_THISCLASS("CClusterConfiguration")


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CClusterConfiguration::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterConfiguration::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CClusterConfiguration * pcc = new CClusterConfiguration;
    if ( pcc != NULL )
    {
        hr = THR( pcc->Init() );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pcc->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pcc->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} //*** CClusterConfiguration::S_HrCreateInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfiguration::CClusterConfiguration( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterConfiguration::CClusterConfiguration( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusterConfiguration::CClusterConfiguration()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::Init( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef();    // Add one count

    // IClusCfgClusterInfo
    Assert( m_bstrClusterName == NULL );
    Assert( m_ulIPAddress == 0 );
    Assert( m_ulSubnetMask == 0 );
    Assert( m_picccServiceAccount == NULL );
    Assert( m_punkNetwork == NULL );
    Assert( m_ecmCommitChangesMode == cmUNKNOWN );
    Assert( m_bstrClusterBindingString == NULL );

    // IExtendObjectManager

    HRETURN( hr );

} //*** CClusterConfiguration::Init()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfiguration::~CClusterConfiguration( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterConfiguration::~CClusterConfiguration( void )
{
    TraceFunc( "" );

    TraceSysFreeString( m_bstrClusterName );
    TraceSysFreeString( m_bstrClusterBindingString );

    if ( m_picccServiceAccount != NULL )
    {
        m_picccServiceAccount->Release();
    }

    if ( m_punkNetwork != NULL )
    {
        m_punkNetwork->Release();
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusterConfiguration::~CClusterConfiguration()

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::QueryInterface(
//      REFIID      riidIn,
//      LPVOID *    ppvOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgClusterInfo * >( this );
        hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgClusterInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgClusterInfo, this, 0 );
        hr = S_OK;
    } // else if: IClusCfgClusterInfo
    else if ( IsEqualIID( riidIn, IID_IGatherData ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IGatherData, this, 0 );
        hr = S_OK;
    } // else if: IGatherData
    else if ( IsEqualIID( riidIn, IID_IExtendObjectManager ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IExtendObjectManager, this, 0 );
        hr = S_OK;
    } // else if: IObjectManager

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CClusterConfiguration::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusterConfiguration::AddRef( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusterConfiguration::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CClusterConfiguration::AddRef()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusterConfiguration::Release( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusterConfiguration::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} //*** CClusterConfiguration::Release()


// ************************************************************************
//
//  IClusCfgClusterInfo
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::GetCommitMode( ECommitMode * pecmCurrentModeOut )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::GetCommitMode( ECommitMode * pecmCurrentModeOut )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pecmCurrentModeOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    *pecmCurrentModeOut = m_ecmCommitChangesMode;

Cleanup:

    HRETURN( hr );

} //*** CClusterConfiguration::GetCommitMode()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::SetCommitMode( ECommitMode ecmCurrentModeIn )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::SetCommitMode( ECommitMode ecmCurrentModeIn )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    m_ecmCommitChangesMode = ecmCurrentModeIn;

    HRETURN( hr );

} //*** CClusterConfiguration::SetCommitMode()

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::GetName(
//      BSTR * pbstrNameOut
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
        goto InvalidPointer;

    if ( m_bstrClusterName == NULL )
        goto UnexpectedError;

    *pbstrNameOut = SysAllocString( m_bstrClusterName );
    if ( *pbstrNameOut == NULL )
        goto OutOfMemory;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

UnexpectedError:
    hr = THR( E_UNEXPECTED );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CClusterConfiguration::GetName()

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::SetName(
//      LPCWSTR pcszNameIn
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::SetName(
    LPCWSTR pcszNameIn
    )
{
    TraceFunc1( "[IClusCfgClusterInfo] pcszNameIn = '%ws'", ( pcszNameIn == NULL ? L"<null>" : pcszNameIn ) );

    HRESULT hr = S_OK;
    BSTR    bstrNewName;

    if ( pcszNameIn == NULL )
        goto InvalidArg;

    bstrNewName = TraceSysAllocString( pcszNameIn );
    if ( bstrNewName == NULL )
        goto OutOfMemory;

    TraceSysFreeString( m_bstrClusterName );
    m_bstrClusterName = bstrNewName;
    m_fHasNameChanged = TRUE;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CClusterConfiguration::SetName()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::GetIPAddress(
//      ULONG * pulDottedQuadOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::GetIPAddress(
    ULONG * pulDottedQuadOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr;

    if ( pulDottedQuadOut == NULL )
        goto InvalidPointer;

    *pulDottedQuadOut = m_ulIPAddress;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} //*** CClusterConfiguration::GetIPAddress()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::SetIPAddress(
//      ULONG ulDottedQuadIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::SetIPAddress(
    ULONG ulDottedQuadIn
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    m_ulIPAddress = ulDottedQuadIn;

    HRETURN( hr );

} //*** CClusterConfiguration::SetIPAddress()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::GetSubnetMask(
//      ULONG * pulDottedQuadOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::GetSubnetMask(
    ULONG * pulDottedQuadOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr;

    if ( pulDottedQuadOut == NULL )
        goto InvalidPointer;

    *pulDottedQuadOut = m_ulSubnetMask;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} //*** CClusterConfiguration::GetSubnetMask()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::SetSubnetMask(
//      ULONG ulDottedQuadIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::SetSubnetMask(
    ULONG ulDottedQuadIn
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    m_ulSubnetMask = ulDottedQuadIn;

    HRETURN( hr );

} //*** CClusterConfiguration::SetSubnetMask()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::GetNetworkInfo(
//      IClusCfgNetworkInfo ** ppiccniOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::GetNetworkInfo(
    IClusCfgNetworkInfo ** ppiccniOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( ppiccniOut == NULL )
        goto InvalidPointer;

    if ( m_punkNetwork == NULL )
        goto InvalidData;

    *ppiccniOut = TraceInterface( L"CClusterConfiguration!GetNetworkInfo", IClusCfgNetworkInfo, m_punkNetwork, 0 );
    (*ppiccniOut)->AddRef();

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

InvalidData:
    hr = HRESULT_FROM_WIN32( TW32( ERROR_INVALID_DATA ) );
    goto Cleanup;

} //*** CClusterConfiguration::GetNetworkInfo()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfiguration::SetNetworkInfo(
//      IClusCfgNetworkInfo * piccniIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::SetNetworkInfo(
    IClusCfgNetworkInfo * piccniIn
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    IClusCfgNetworkInfo * punkNew;

    if ( piccniIn == NULL )
        goto InvalidArg;

    hr = THR( piccniIn->TypeSafeQI( IClusCfgNetworkInfo, &punkNew ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( m_punkNetwork != NULL )
    {
        m_punkNetwork->Release();
    }

    m_punkNetwork = punkNew;    // no addref!

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} //*** CClusterConfiguration::SetNetworkInfo()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::GetClusterServiceAccountCredentials(
//      IClusCfgCredentials ** ppicccCredentialsOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::GetClusterServiceAccountCredentials(
    IClusCfgCredentials ** ppicccCredentialsOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT     hr = S_OK;

    if ( m_picccServiceAccount == NULL )
    {
        hr = THR( HrCoCreateInternalInstance( CLSID_ClusCfgCredentials,
                                              NULL,
                                              CLSCTX_INPROC_HANDLER,
                                              IID_IClusCfgCredentials,
                                              reinterpret_cast< void ** >( &m_picccServiceAccount )
                                              ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    if ( ppicccCredentialsOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    *ppicccCredentialsOut = TraceInterface( L"ClusCfgCredentials!ClusterConfig", IClusCfgCredentials, m_picccServiceAccount, 0 );
    (*ppicccCredentialsOut)->AddRef();

Cleanup:
    HRETURN( hr );

} //*** CClusterConfiguration::GetClusterServiceAccountCredentials()


///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::GetBindingString(
//      BSTR * pbstrBindingStringOut
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::GetBindingString(
    BSTR * pbstrBindingStringOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrBindingStringOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( m_bstrClusterBindingString == NULL )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    *pbstrBindingStringOut = SysAllocString( m_bstrClusterBindingString );
    if ( *pbstrBindingStringOut == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CClusterConfiguration::GetBindingString()

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::SetBindingString(
//      LPCWSTR bstrBindingStringIn
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::SetBindingString(
    LPCWSTR pcszBindingStringIn
    )
{
    TraceFunc1( "[IClusCfgClusterInfo] pcszBindingStringIn = '%ws'", ( pcszBindingStringIn == NULL ? L"<null>" : pcszBindingStringIn ) );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    if ( pcszBindingStringIn == NULL )
        goto InvalidArg;

    bstr = TraceSysAllocString( pcszBindingStringIn );
    if ( bstr == NULL )
        goto OutOfMemory;

    TraceSysFreeString( m_bstrClusterBindingString  );
    m_bstrClusterBindingString = bstr;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CClusterConfiguration::SetBindingString()


//****************************************************************************
//
//  IGatherData
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusterConfiguration::Gather(
//      OBJECTCOOKIE    cookieParentIn,
//      IUnknown *      punkIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::Gather(
    OBJECTCOOKIE    cookieParentIn,
    IUnknown *      punkIn
    )
{
    TraceFunc( "[IGatherData]" );

    HRESULT hr;

    OBJECTCOOKIE    cookie;
    OBJECTCOOKIE    cookieDummy;

    BSTR    bstrUsername = NULL;
    BSTR    bstrDomain = NULL;
    BSTR    bstrPassword = NULL;

    IServiceProvider *    psp;

    IObjectManager *      pom   = NULL;
    IClusCfgClusterInfo * pcci  = NULL;
    IClusCfgCredentials * piccc = NULL;
    IClusCfgNetworkInfo * pccni = NULL;
    IUnknown *            punk  = NULL;
    IGatherData *         pgd   = NULL;

    if ( punkIn == NULL )
        goto InvalidPointer;

    //
    //  Grab the object manager.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                               IObjectManager,
                               &pom
                               ) );
    psp->Release();        // release promptly
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Make sure this is what we think it is.
    //

    hr = THR( punkIn->TypeSafeQI( IClusCfgClusterInfo, &pcci ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Gather Cluster Name
    //

    hr = THR( pcci->GetName( &m_bstrClusterName ) );
    if ( FAILED( hr ) )
        goto Error;

    TraceMemoryAddBSTR( m_bstrClusterName );

    //
    //  Gather Cluster binding string
    //

    hr = STHR( pcci->GetBindingString( &m_bstrClusterBindingString ) );
    if ( FAILED( hr ) )
        goto Error;

    TraceMemoryAddBSTR( m_bstrClusterBindingString );

    //
    //  Gather IP Address
    //

    hr = STHR( pcci->GetIPAddress( &m_ulIPAddress ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Gather Subnet Mask
    //

    hr = STHR( pcci->GetSubnetMask( &m_ulSubnetMask ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Find out our cookie.
    //

    hr = THR( pom->FindObject( CLSID_ClusterConfigurationType,
                               cookieParentIn,
                               m_bstrClusterName,
                               IID_NULL,
                               &cookie,
                               NULL
                               ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Gather the network.
    //

    hr = STHR( pcci->GetNetworkInfo( &pccni ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( CManagedNetwork::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( punk->TypeSafeQI( IGatherData, &pgd ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Gather the info, but since this object isn't going to be
    //  reflected in the cookie tree, pass it a parent of ZERO
    //  so it won't gather the secondary IP addresses.
    //
    hr = THR( pgd->Gather( 0, pccni ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( punk->TypeSafeQI( IClusCfgNetworkInfo, &m_punkNetwork ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Gather Account Name and Domain. We can't get the password.
    //

    hr = THR( pcci->GetClusterServiceAccountCredentials( &piccc  ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( HrCoCreateInternalInstance( CLSID_ClusCfgCredentials,
                                          NULL,
                                          CLSCTX_INPROC_HANDLER,
                                          IID_IClusCfgCredentials,
                                          reinterpret_cast< void ** >( &m_picccServiceAccount )
                                          ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( piccc->GetCredentials( &bstrUsername, &bstrDomain, &bstrPassword ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( m_picccServiceAccount->SetCredentials( bstrUsername, bstrDomain, bstrPassword ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Anything else to gather??
    //

Cleanup:
    TraceSysFreeString( bstrUsername );
    TraceSysFreeString( bstrDomain );
    TraceSysFreeString( bstrPassword );

    if ( piccc != NULL )
    {
        piccc->Release();
    }
    if ( pcci != NULL )
    {
        pcci->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pgd != NULL )
    {
        pgd->Release();
    }
    HRETURN( hr );

Error:
    //
    //  On error, invalidate all data.
    //
    TraceSysFreeString( m_bstrClusterName );
    m_bstrClusterName = NULL;

    m_fHasNameChanged = FALSE;
    m_ulIPAddress = 0;
    m_ulSubnetMask = 0;
    if ( m_picccServiceAccount != NULL )
    {
        m_picccServiceAccount->Release();
        m_picccServiceAccount = NULL;
    }
    if ( m_punkNetwork != NULL )
    {
        m_punkNetwork->Release();
        m_punkNetwork = NULL;
    }
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Error;

} //*** CClusterConfiguration::Gather()


// ************************************************************************
//
//  IExtendObjectManager
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
// STDMETHODIMP
// CClusterConfiguration::FindObject(
//      OBJECTCOOKIE        cookieIn,
//      REFCLSID            rclsidTypeIn,
//      LPCWSTR             pcszNameIn,
//      LPUNKNOWN *         punkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterConfiguration::FindObject(
    OBJECTCOOKIE        cookieIn,
    REFCLSID            rclsidTypeIn,
    LPCWSTR             pcszNameIn,
    LPUNKNOWN *         ppunkOut
    )
{
    TraceFunc( "[IExtendObjectManager]" );

    HRESULT hr = E_UNEXPECTED;

    //
    //  Check parameters.
    //

    //  We need to represent a ClusterType.
    if ( !IsEqualIID( rclsidTypeIn, CLSID_ClusterConfigurationType ) )
        goto InvalidArg;

    //  Gotta have a cookie
    if ( cookieIn == NULL )
        goto InvalidArg;

    //  We need to have a name.
    if ( pcszNameIn == NULL )
        goto InvalidArg;

    //
    //  Try to save the name. We don't care if this fails as it will be
    //  over-ridden when the information is retrieved from the node.
    //
    m_bstrClusterName = TraceSysAllocString( pcszNameIn );

    //
    //  Get the pointer.
    //
    if ( ppunkOut != NULL )
    {
        hr = THR( QueryInterface( DFGUID_ClusterConfigurationInfo,
                                  reinterpret_cast< void ** > ( ppunkOut )
                                  ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    } // if: ppunkOut

    //
    //  Tell caller that the data is pending.
    //
    hr = E_PENDING;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} //*** CClusterConfiguration::FindObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\configconnection.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ConfigurationConnection.h
//
//  Description:
//      CConfigurationConnection implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CConfigurationConnection
class
CConfigurationConnection
    : public IConfigurationConnection
    , public IClusCfgServer
    , public IClusCfgCallback
    , public IClusCfgCapabilities
    , public IClusCfgVerify
{
private:
    // IUnknown
    LONG                m_cRef;

    // IConfigurationConnection
    IGlobalInterfaceTable * m_pgit;                     // Global Interface Table
    DWORD                   m_cookieGITServer;          // Goblal Interface Table cookie -- Server interface
    DWORD                   m_cookieGITVerify;          // Goblal Interface Table cookie -- Server interface
    DWORD                   m_cookieGITCallbackTask;    // Goblal Interface Table cookie -- polling callback task interface
    IClusCfgCallback *      m_pcccb;                    // Marshalled callback interface
    BSTR                    m_bstrLocalComputerName;    // Local computer name FQDN
    BSTR                    m_bstrLocalHostname;        // Local computer hostname
    HRESULT                 m_hrLastStatus;             // Last status of connection.
    BSTR                    m_bstrBindingString;              // String used to bind to the server.

private: // Methods
    CConfigurationConnection( void );
    ~CConfigurationConnection( void );
    STDMETHOD( Init )( void );

    HRESULT HrRetrieveServerInterface( IClusCfgServer ** ppccsOut );
    HRESULT HrStartPolling( void );
    HRESULT HrStopPolling( void );
    HRESULT HrSetSecurityBlanket( IClusCfgServer * pccsIn );
    HRESULT HrIsLocalComputer( LPCWSTR pcszNameIn );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IConfigurationConnection
    STDMETHOD( ConnectTo )( OBJECTCOOKIE cookieIn );
    STDMETHOD( ConnectToObject )( OBJECTCOOKIE cookieIn, REFIID riidIn, LPUNKNOWN * ppunkOut );

    // IClusCfgServer
    STDMETHOD( GetClusterNodeInfo )( IClusCfgNodeInfo ** ppClusterNodeInfoOut );
    STDMETHOD( GetManagedResourcesEnum )( IEnumClusCfgManagedResources ** ppEnumManagedResourcesOut );
    STDMETHOD( GetNetworksEnum )( IEnumClusCfgNetworks ** ppEnumNetworksOut );
    STDMETHOD( CommitChanges )( void );
    STDMETHOD( SetBindingString )( LPCWSTR pcszBindingStringIn );
    STDMETHOD( GetBindingString )( BSTR * pbstrBindingStringOut );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                  LPCWSTR       pcszNodeNameIn
                , CLSID         clsidTaskMajorIn
                , CLSID         clsidTaskMinorIn
                , ULONG         ulMinIn
                , ULONG         ulMaxIn
                , ULONG         ulCurrentIn
                , HRESULT       hrStatusIn
                , LPCWSTR       pcszDescriptionIn
                , FILETIME *    pftTimeIn
                , LPCWSTR       pcszReferenceIn
                );

    // IClusCfgCapabilities
    STDMETHOD( CanNodeBeClustered )( void );

    // IClusCfgVerify
    STDMETHOD( VerifyCredentials )( LPCWSTR pcszUserIn, LPCWSTR pcszDomainIn, LPCWSTR pcszPasswordIn );
    STDMETHOD( VerifyConnectionToCluster )( LPCWSTR pcszClusterNameIn );
    STDMETHOD( VerifyConnectionToNode )( LPCWSTR pcszNodeNameIn );

}; // class CConfigurationConnection
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\inc\guids.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      Guids.h
//
//  Description:
//      This file contains both internal and external GUID definitions.
//
//  TODO:   gpease  21-FEB-2000
//          Make this file generate a public and private header.
//
//  Maintained By:
//      Galen Barbee (GalenB)   18-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

//
//  APPIDs
//

// {E68C923B-EC62-4eb2-9201-C48F0ADB7963}
DEFINE_GUID( APPID_ClusCfgWizard,
0xe68c923b, 0xec62, 0x4eb2, 0x92, 0x1, 0xc4, 0x8f, 0xa, 0xdb, 0x79, 0x63 );

// {800A4EE1-1664-4bd5-ADF2-4DF2ECC09B40}
DEFINE_GUID( APPID_ClusCfgServer,
0x800a4ee1, 0x1664, 0x4bd5, 0xad, 0xf2, 0x4d, 0xf2, 0xec, 0xc0, 0x9b, 0x40 );

// {F72C956D-CBD2-4acd-9749-78329B69035A}
DEFINE_GUID( APPID_ClusCfgBaseCluster,
0xf72c956d, 0xcbd2, 0x4acd, 0x97, 0x49, 0x78, 0x32, 0x9b, 0x69, 0x3, 0x5a );

// {3FF0DA8E-E7B2-4c97-B470-056F8A4A53C0}
DEFINE_GUID( APPID_ClusCfgEvictCleanup,
0x3ff0da8e, 0xe7b2, 0x4c97, 0xb4, 0x70, 0x5, 0x6f, 0x8a, 0x4a, 0x53, 0xc0 );

// {F45FBDD5-A533-4d9d-A06A-5AEDA9692BE4}
DEFINE_GUID( APPID_ClusCfgAsyncEvictCleanup,
0xf45fbdd5, 0xa533, 0x4d9d, 0xa0, 0x6a, 0x5a, 0xed, 0xa9, 0x69, 0x2b, 0xe4 );

// {50503499-D11E-401a-82AE-33065AC0B9AE}
DEFINE_GUID( APPID_ClusCfgStartupNotify,
0x50503499, 0xd11e, 0x401a, 0x82, 0xae, 0x33, 0x6, 0x5a, 0xc0, 0xb9, 0xae );

// {DFF002C3-9775-4c37-89D0-23600BC97B9F}
DEFINE_GUID( APPID_ClCfgSrvLogger,
0xdff002c3, 0x9775, 0x4c37, 0x89, 0xd0, 0x23, 0x60, 0xb, 0xc9, 0x7b, 0x9f );


//
//  Component CLSIDs
//

// {8AEC052B-066A-4dee-8B20-FA8046ADD999}
DEFINE_GUID( CLSID_ClusCfgServer,
0x8aec052b, 0x66a, 0x4dee, 0x8b, 0x20, 0xfa, 0x80, 0x46, 0xad, 0xd9, 0x99 );

// {9be7f4a7-918b-47e3-be74-a13d6a453571}
DEFINE_GUID( CLSID_ClusCfgNodeInfo,
0x9be7f4a7, 0x918b, 0x47e3, 0xb3, 0x74, 0xa1, 0x3d, 0x6a, 0x45, 0x35, 0x71 );

// {f77f10a7-7c64-4ff6-b7e6-af2f7ba1df81}
DEFINE_GUID( CLSID_ClusCfgClusterInfo,
0xf77f10a7, 0x7c64, 0x4ff6, 0xb7, 0xe6, 0xaf, 0x2f, 0x7b, 0xa1, 0xdf, 0x81 );

// {C337213E-5B74-45e7-84BA-3EDAD49F01F6}
DEFINE_GUID( CLSID_EnumClusCfgManagedResources,
0xc337213e, 0x5b74, 0x45e7, 0x84, 0xba, 0x3e, 0xda, 0xd4, 0x9f, 0x1, 0xf6 );

// {57720043-DC9E-4796-B252-8F5B87F8C1C9}
DEFINE_GUID( CLSID_PhysicalDisk,
0x57720043, 0xdc9e, 0x4796, 0xb2, 0x52, 0x8f, 0x5b, 0x87, 0xf8, 0xc1, 0xc9 );

// {7F64E62A-61EE-43c4-B3E5-F7C69A6B304C}
DEFINE_GUID( CLSID_EnumClusCfgNetworks,
0x7f64e62a, 0x61ee, 0x43c4, 0xb3, 0xe5, 0xf7, 0xc6, 0x9a, 0x6b, 0x30, 0x4c );

// {77F09965-4D3A-4f82-864D-4479B6218330}
DEFINE_GUID( CLSID_ClusCfgNetworkInfo,
0x77f09965, 0x4d3a, 0x4f82, 0x86, 0x4d, 0x44, 0x79, 0xb6, 0x21, 0x83, 0x30 );

// {A0B9696E-FA22-4fda-B253-70116062A952}
DEFINE_GUID( CLSID_ClusCfgCallback,
0xa0b9696e, 0xfa22, 0x4fda, 0xb2, 0x53, 0x70, 0x11, 0x60, 0x62, 0xa9, 0x52 );

// {0F200768-212B-4b80-BA31-2F0933BE8583}
DEFINE_GUID( CLSID_ClusterConnectionManager,
0x0f200768, 0x212b, 0x4b80, 0xba, 0x31, 0x2f, 0x09, 0x33, 0xbe, 0x85, 0x83 );

// {215A6C84-64BD-42cf-9B67-6E2D0CEF4EA4}
DEFINE_GUID( CLSID_ConfigurationConnection,
0x215a6c84, 0x64bd, 0x42cf, 0x9b, 0x67, 0x6e, 0x2d, 0xc, 0xef, 0x4e, 0xa4 );

// {6CD35DF9-AB7D-428a-AD87-72EDB35A2D0D}
DEFINE_GUID( CLSID_EnumClusCfgIPAddresses,
0x6cd35df9, 0xab7d, 0x428a, 0xad, 0x87, 0x72, 0xed, 0xb3, 0x5a, 0x2d, 0xd );

// {3E6296AA-936B-4ca2-B67F-6DF55D7F0081}
DEFINE_GUID( CLSID_ClusCfgIPAddressInfo,
0x3e6296aa, 0x936b, 0x4ca2, 0xb6, 0x7f, 0x6d, 0xf5, 0x5d, 0x7f, 0x0, 0x81 );

// {613FE7AB-C4E5-4570-B40F-B7466D40BAAE}
DEFINE_GUID( CLSID_ResultsCallback,
0x613FE7AB, 0xC4E5, 0x4570, 0xB4, 0x0F, 0xB7, 0x46, 0x6D, 0x40, 0xBA, 0xAE );

// {7D1CEAA2-F8FF-4e94-8FF5-CA716B3EFED4}
DEFINE_GUID( CLSID_ClusCfgBaseCluster,
0x7d1ceaa2, 0xf8ff, 0x4e94, 0x8f, 0xf5, 0xca, 0x71, 0x6b, 0x3e, 0xfe, 0xd4 );

// {71D13B29-4667-41fb-B4E3-F26418895CDA}
DEFINE_GUID( CLSID_EnumPhysicalDisks,
0x71d13b29, 0x4667, 0x41fb, 0xb4, 0xe3, 0xf2, 0x64, 0x18, 0x89, 0x5c, 0xda );

// {C662DFBA-C57A-4098-9D66-3E106E4EB83E}
DEFINE_GUID( CLSID_ClusCfgCredentials,
0xc662dfba, 0xc57a, 0x4098, 0x9d, 0x66, 0x3e, 0x10, 0x6e, 0x4e, 0xb8, 0x3e );

// {B7CCC7D2-C122-4e14-B830-F3FB3D4954AA}
DEFINE_GUID( CLSID_ClusCfgPostConfigManager,
0xb7ccc7d2, 0xc122, 0x4e14, 0xb8, 0x30, 0xf3, 0xfb, 0x3d, 0x49, 0x54, 0xaa );

// {6C606741-3766-4402-9958-3D2DFD8D5477}
DEFINE_GUID( CLSID_EnumClusterResources,
0x6c606741, 0x3766, 0x4402, 0x99, 0x58, 0x3d, 0x2d, 0xfd, 0x8d, 0x54, 0x77 );

// {7FD17DAF-BB15-41ac-AB75-8D874A8B7C5F}
DEFINE_GUID( CLSID_ClusterResource,
0x7fd17daf, 0xbb15, 0x41ac, 0xab, 0x75, 0x8d, 0x87, 0x4a, 0x8b, 0x7c, 0x5f );

// {DD18F356-E387-496f-A8FF-65822CBF2970}
DEFINE_GUID( CLSID_ConfigClusApi,
0xdd18f356, 0xe387, 0x496f, 0xa8, 0xff, 0x65, 0x82, 0x2c, 0xbf, 0x29, 0x70 );

// {0BE8BAD9-3E6B-47c0-BC0B-86EBBA1C36C5}
DEFINE_GUID( CLSID_ClusCfgCapabilities,
0xbe8bad9, 0x3e6b, 0x47c0, 0xbc, 0xb, 0x86, 0xeb, 0xba, 0x1c, 0x36, 0xc5 );

// {49C45D6A-AD9D-4ed5-8520-1F8628463350}
DEFINE_GUID( CLSID_ClCfgSrvLogger,
0x49c45d6a, 0xad9d, 0x4ed5, 0x85, 0x20, 0x1f, 0x86, 0x28, 0x46, 0x33, 0x50 );

// {C6348E14-53B9-4fae-866F-50FEF691D70E}
DEFINE_GUID( CLSID_LocalQuorum,
0xc6348e14, 0x53b9, 0x4fae, 0x86, 0x6f, 0x50, 0xfe, 0xf6, 0x91, 0xd7, 0xe );

// {0CAD2D20-218D-4dbb-B067-24464090C2DD}
DEFINE_GUID( CLSID_EnumLocalQuorum,
0xcad2d20, 0x218d, 0x4dbb, 0xb0, 0x67, 0x24, 0x46, 0x40, 0x90, 0xc2, 0xdd );

// {FD507CFA-3515-494a-A0B9-C9FB917A384C}
DEFINE_GUID( CLSID_MajorityNodeSet,
0xfd507cfa, 0x3515, 0x494a, 0xa0, 0xb9, 0xc9, 0xfb, 0x91, 0x7a, 0x38, 0x4c );

// {75C0791D-7670-44bb-B273-2D405C26DF28}
DEFINE_GUID( CLSID_EnumMajorityNodeSet,
0x75c0791d, 0x7670, 0x44bb, 0xb2, 0x73, 0x2d, 0x40, 0x5c, 0x26, 0xdf, 0x28 );

// {6A4CF650-88DD-489a-9A1E-A24A142440E0}
DEFINE_GUID( CLSID_UnknownQuorum,
0x6a4cf650, 0x88dd, 0x489a, 0x9a, 0x1e, 0xa2, 0x4a, 0x14, 0x24, 0x40, 0xe0 );

// {7BDB4AEB-3631-4d4d-8B7A-816C73056489}
DEFINE_GUID( CLSID_EnumUnknownQuorum,
0x7bdb4aeb, 0x3631, 0x4d4d, 0x8b, 0x7a, 0x81, 0x6c, 0x73, 0x5, 0x64, 0x89 );

//
//  Server Interfaces
//

// {C72DB1FD-51A2-43e6-B708-D9DB7DA79630}
DEFINE_GUID( IID_IClusCfgPollingCallback,
0xc72db1fd, 0x51a2, 0x43e6, 0xb7, 0x8, 0xd9, 0xdb, 0x7d, 0xa7, 0x96, 0x30 );

// {C72DB1FD-51A2-43e6-B708-D9DB7DA79631}
DEFINE_GUID( IID_AsyncIClusCfgPollingCallback,
0xc72db1fd, 0x51a2, 0x43e6, 0xb7, 0x8, 0xd9, 0xdb, 0x7d, 0xa7, 0x96, 0x31 );

// {2AF55DA7-CB6F-40de-BB11-6673464B2C54}
DEFINE_GUID( IID_IClusCfgPollingCallbackInfo,
0x2af55da7, 0xcb6f, 0x40de, 0xbb, 0x11, 0x66, 0x73, 0x46, 0x4b, 0x2c, 0x54 );

// {2AF55DA7-CB6F-40de-BB11-6673464B2C55}
DEFINE_GUID( IID_AsyncIClusCfgPollingCallbackInfo,
0x2af55da7, 0xcb6f, 0x40de, 0xbb, 0x11, 0x66, 0x73, 0x46, 0x4b, 0x2c, 0x55 );

// {6E109698-DFC4-4471-ACE1-0414931B3BB3}
DEFINE_GUID( IID_IClusCfgResTypeServicesInitialize,
0x6e109698, 0xdfc4, 0x4471, 0xac, 0xe1, 0x4, 0x14, 0x93, 0x1b, 0x3b, 0xb3 );

//
// Client Interfaces
//

// {CB9724AB-14B9-4385-970D-4D715CC25E60}
DEFINE_GUID( IID_IClusCfgWbemServices,
0xcb9724ab, 0x14b9, 0x4385, 0x97, 0x0d, 0x4d, 0x71, 0x5c, 0xc2, 0x5e, 0x60 );

// {97F95C65-E484-4098-861A-842D7A0C59DF}
DEFINE_GUID( IID_IClusCfgSetWbemObject,
0x97f95c65, 0xe484, 0x4098, 0x86, 0x1a, 0x84, 0x2d, 0x7a, 0xc, 0x59, 0xdf );

// {1C7856BF-C62A-4236-80E8-1EC99FC86920}
DEFINE_GUID( IID_IClusCfgSession,
0x1c7856bf, 0xc62a, 0x4236, 0x80, 0xe8, 0x1e, 0xc9, 0x9f, 0xc8, 0x69, 0x20 );

// {58624046-DD8A-43ce-BCDE-B3037BE348CA}
DEFINE_GUID( IID_IClusCfgSetClusterNodeInfo,
0x58624046, 0xdd8a, 0x43ce, 0xbc, 0xde, 0xb3, 0x3, 0x7b, 0xe3, 0x48, 0xca );

// {9CD0BEF4-A8FE-47b8-B0D0-20A4B9D71D7D}
DEFINE_GUID( IID_IClusCfgSetClusterHandles,
0x9cd0bef4, 0xa8fe, 0x47b8, 0xb0, 0xd0, 0x20, 0xa4, 0xb9, 0xd7, 0x1d, 0x7d );

// {1738F344-509C-489f-B8D7-217A711EDF60}
DEFINE_GUID( IID_IClusCfgPhysicalDiskProperties,
0x1738f344, 0x509c, 0x489f, 0xb8, 0xd7, 0x21, 0x7a, 0x71, 0x1e, 0xdf, 0x60 );

// {7B382C01-BB6E-4175-AE23-979574B5707B}
DEFINE_GUID( IID_IClusCfgPartitionProperties,
0x7b382c01, 0xbb6e, 0x4175, 0xae, 0x23, 0x97, 0x95, 0x74, 0xb5, 0x70, 0x7b );

// {5AC459D4-7B78-41f6-8E9A-F17AACDC29D6}
DEFINE_GUID( IID_IClusCfgLoadResource,
0x5ac459d4, 0x7b78, 0x41f6, 0x8e, 0x9a, 0xf1, 0x7a, 0xac, 0xdc, 0x29, 0xd6 );

// {FDA69D69-23FD-4880-969A-D505DA177F70}
DEFINE_GUID( IID_IClusCfgSetPollingCallback,
0xfda69d69, 0x23fd, 0x4880, 0x96, 0x9a, 0xd5, 0x5, 0xda, 0x17, 0x7f, 0x70 );

// {B27A7584-FCB4-4242-8684-89990B27AED0}
DEFINE_GUID( IID_IPostCfgManager,
0xb27a7584, 0xfcb4, 0x4242, 0x86, 0x84, 0x89, 0x99, 0xb, 0x27, 0xae, 0xd0 );

// ca7bb0b9-700c-4dc5-991e-75f9e65ee975
DEFINE_GUID( IID_IExtendObjectManager,
0xca7bb0b9, 0x700c, 0x4dc5, 0x99, 0x1e, 0x75, 0xf9, 0xe6, 0x5e, 0xe9, 0x75 );

// {2F36ED9B-86E0-45a1-A8F2-3F598E660AE0}
DEFINE_GUID( IID_IClusCfgClusterNetworkInfo,
0x2f36ed9b, 0x86e0, 0x45a1, 0xa8, 0xf2, 0x3f, 0x59, 0x8e, 0x66, 0xa, 0xe0 );


//
//  Post Configuration Interfaces
//

// {2DC2EC9D-451C-431a-B1B3-77B15B4D1C19}
DEFINE_GUID( IID_IPrivatePostCfgResource,
0x2dc2ec9d, 0x451c, 0x431a, 0xb1, 0xb3, 0x77, 0xb1, 0x5b, 0x4d, 0x1c, 0x19 );

// {6FE3E361-D373-4C5F-A0AF-1DFE8493C655}
DEFINE_GUID( IID_IClusCfgEvict,
0x6fe3e361, 0xd373, 0x4c5f, 0xa0, 0xaf, 0x1d, 0xfe, 0x84, 0x93, 0xc6, 0x55 );

// {6FE3E362-D373-4C5F-A0AF-1DFE8493C655}
DEFINE_GUID( IID_AsyncIClusCfgEvict,
0x6fe3e362, 0xd373, 0x4c5f, 0xa0, 0xaf, 0x1d, 0xfe, 0x84, 0x93, 0xc6, 0x55 );

// {D282CAEF-2EDE-4ab9-A5D5-F7BDE3D23F0F}
DEFINE_GUID( IID_ClusCfgStartupListener,
0xd282caef, 0x2ede, 0x4ab9, 0xa5, 0xd5, 0xf7, 0xbd, 0xe3, 0xd2, 0x3f, 0x0f );

// {D282CAEF-2EDE-4ab9-A5D5-F7BDE3D23F10}
DEFINE_GUID( IID_AsyncClusCfgStartupListener,
0xd282caef, 0x2ede, 0x4ab9, 0xa5, 0xd5, 0xf7, 0xbd, 0xe3, 0xd2, 0x3f, 0x10 );


//
// Object Type Guids
//

// {1143DCB3-2C27-4cec-A442-392903065F7F}
DEFINE_GUID( CLSID_ClusterType,
0x1143dcb3, 0x2c27, 0x4cec, 0xa4, 0x42, 0x39, 0x29, 0x3, 0x6, 0x5f, 0x7f );

// {09EBC765-9730-4a89-8B26-8F72DF534226}
DEFINE_GUID( CLSID_ManagedResourceType,
0x9ebc765, 0x9730, 0x4a89, 0x8b, 0x26, 0x8f, 0x72, 0xdf, 0x53, 0x42, 0x26 );

// {FC07A1A2-2E49-41bb-8C39-CB524F8BCEA9}
DEFINE_GUID( CLSID_IPAddressType,
0xfc07a1a2, 0x2e49, 0x41bb, 0x8c, 0x39, 0xcb, 0x52, 0x4f, 0x8b, 0xce, 0xa9 );

// {1FF64B28-ABCC-4141-87F7-73D495FC36BA}
DEFINE_GUID( CLSID_TaskVerifyIPAddressCompletionCookieType,
0x1ff64b28, 0xabcc, 0x4141, 0x87, 0xf7, 0x73, 0xd4, 0x95, 0xfc, 0x36, 0xba );



//
// Data Format Guids (DFGUIDs)
//

// {F0BA96DE-8AEF-4018-8053-A7D290859806}
DEFINE_GUID( DFGUID_ClusterConfiguration,
0xf0ba96de, 0x8aef, 0x4018, 0x80, 0x53, 0xa7, 0xd2, 0x90, 0x85, 0x98, 0x6 );

#define DFGUID_EnumManageableResources IID_IEnumClusCfgManagedResources

#define DFGUID_EnumNodes IID_IEnumNodes

#define DFGUID_ConnectionInfoFormat IID_IConnectionInfo

#define DFGUID_ManagedResource IID_IClusCfgManagedResourceInfo

#define DFGUID_NetworkResource IID_IClusCfgNetworkInfo

#define DFGUID_EnumCookies IID_IEnumCookies

#define DFGUID_IPAddressInfo IID_IClusCfgIPAddressInfo

#define DFGUID_EnumIPAddressInfo IID_IEnumClusCfgIPAddresses



//
//  Tasks
//

#define TASK_GatherNodeInfo IID_ITaskGatherNodeInfo

#define TASK_GatherInformation IID_ITaskGatherInformation

#define TASK_CompareAndPushInformation IID_ITaskCompareAndPushInformation

// {9B42E854-762C-4bf2-9AC4-DC0ADB4DE5A1}
DEFINE_GUID( TASK_CheckClusterFeasibility,
0x9b42e854, 0x762c, 0x4bf2, 0x9a, 0xc4, 0xdc, 0xa, 0xdb, 0x4d, 0xe5, 0xa1 );

// {E64C6934-C780-48b5-894E-776964666963}
DEFINE_GUID( TASK_GetDomains,
0xE64C6934, 0xC780, 0x48b5, 0x89, 0x4E, 0x77, 0x69, 0x64, 0x66, 0x69, 0x63 );

#define TASK_GatherClusterInfo IID_ITaskGatherClusterInfo

// {AB2255D0-CC4D-4731-BB49-29B18F350FDA}
DEFINE_GUID( TASK_KeepMTAAlive,
0xab2255d0, 0xcc4d, 0x4731, 0xbb, 0x49, 0x29, 0xb1, 0x8f, 0x35, 0xf, 0xda );

// {34B7ED7B-8EB3-4909-802A-C0DE076A238F}
DEFINE_GUID( TASK_LoginDomain,
0x34b7ed7b, 0x8eb3, 0x4909, 0x80, 0x2a, 0xc0, 0xde, 0x7, 0x6a, 0x23, 0x8f );

// {DED79AFF-D087-47bb-A82A-6DEB53EB277D}
DEFINE_GUID( TASK_PollingCallback,
0xded79aff, 0xd087, 0x47bb, 0xa8, 0x2a, 0x6d, 0xeb, 0x53, 0xeb, 0x27, 0x7d );

#define TASK_VerifyIPAddress IID_ITaskVerifyIPAddress


//
//  TASKIDs Minor (not to be confused with Task Objects!)
//

// {D2D0909F-9883-434e-AC7E-6A3FC283FE6E}
DEFINE_GUID( TASKID_Gathering_Node_Info,
0xd2d0909f, 0x9883, 0x434e, 0xac, 0x7e, 0x6a, 0x3f, 0xc2, 0x83, 0xfe, 0x6e );

// {947570A7-38EF-4a9d-882C-12BC0A411C15}
DEFINE_GUID( TASKID_Gathering_Network_Info,
0x947570a7, 0x38ef, 0x4a9d, 0x88, 0x2c, 0x12, 0xbc, 0xa, 0x41, 0x1c, 0x15 );



// {01297D4D-0C7C-44b1-AECE-604C710A65CC}
DEFINE_GUID( TASKID_Minor_Gathering_Managed_Devices,
0x1297d4d, 0xc7c, 0x44b1, 0xae, 0xce, 0x60, 0x4c, 0x71, 0xa, 0x65, 0xcc );

// {2F2A800D-A704-474b-A870-5CAAAF399093}
DEFINE_GUID( TASKID_Minor_Checking_Node_Cluster_Feasibility,
0x2f2a800d, 0xa704, 0x474b, 0xa8, 0x70, 0x5c, 0xaa, 0xaf, 0x39, 0x90, 0x93);

// {E88B08DD-2460-4df1-B5C2-28587DD164EA}
DEFINE_GUID( TASKID_Minor_Connecting,
0xe88b08dd, 0x2460, 0x4df1, 0xb5, 0xc2, 0x28, 0x58, 0x7d, 0xd1, 0x64, 0xea );

// {A7030E11-2C68-469e-8E0C-863128FB021F}
DEFINE_GUID( TASKID_Minor_Forming_Node,
0xa7030e11, 0x2c68, 0x469e, 0x8e, 0xc, 0x86, 0x31, 0x28, 0xfb, 0x2, 0x1f );

// {3222E708-EEF3-4667-8CCE-BB0C9223130E}
DEFINE_GUID( TASKID_Minor_Joining_Node,
0x3222e708, 0xeef3, 0x4667, 0x8c, 0xce, 0xbb, 0xc, 0x92, 0x23, 0x13, 0xe );

// {9983564B-A8B8-444c-B82D-DC7E3BD84D47}
DEFINE_GUID( TASKID_Minor_No_Quorum_Capable_Device_Found,
0x9983564b, 0xa8b8, 0x444c, 0xb8, 0x2d, 0xdc, 0x7e, 0x3b, 0xd8, 0x4d, 0x47 );

// {A976DC09-0108-410a-AF57-68C05F9A42F7}
DEFINE_GUID( TASKID_Minor_Node_Cannot_Access_Quorum,
0xa976dc09, 0x108, 0x410a, 0xaf, 0x57, 0x68, 0xc0, 0x5f, 0x9a, 0x42, 0xf7);

// {0B5C1D35-1CA5-4597-B1A7-DCD4D64F55C6}
DEFINE_GUID( TASKID_Minor_Cluster_Name_Mismatch,
0xb5c1d35, 0x1ca5, 0x4597, 0xb1, 0xa7, 0xdc, 0xd4, 0xd6, 0x4f, 0x55, 0xc6 );

// {C3691397-F13F-419b-8CEA-7F86D3E7DA0E}
DEFINE_GUID( TASKID_Minor_Inconsistant_MiddleTier_Database,
0xc3691397, 0xf13f, 0x419b, 0x8c, 0xea, 0x7f, 0x86, 0xd3, 0xe7, 0xda, 0xe );

// {1799EE20-885C-40ab-99DD-69EB1FE62DB2}
DEFINE_GUID( TASKID_Minor_Cluster_Not_Found,
0x1799ee20, 0x885c, 0x40ab, 0x99, 0xdd, 0x69, 0xeb, 0x1f, 0xe6, 0x2d, 0xb2 );

// {C0171B7C-B419-488f-B05F-8A6E0279B56A}
DEFINE_GUID( TASKID_Minor_Existing_Cluster_Found,
0xc0171b7c, 0xb419, 0x488f, 0xb0, 0x5f, 0x8a, 0x6e, 0x2, 0x79, 0xb5, 0x6a );

// {2E305DD0-9DCA-47fe-8CF6-4306CA72C4A2}
DEFINE_GUID( TASKID_Minor_Error_Contacting_Cluster,
0x2e305dd0, 0x9dca, 0x47fe, 0x8c, 0xf6, 0x43, 0x6, 0xca, 0x72, 0xc4, 0xa2 );

// {46C8CF52-233D-48a7-B7B9-FE3929A40875}
DEFINE_GUID( TASKID_Minor_Cluster_Membership_Verified,
0x46c8cf52, 0x233d, 0x48a7, 0xb7, 0xb9, 0xfe, 0x39, 0x29, 0xa4, 0x8, 0x75 );

// {3ABE1492-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Configuring_Cluster_Node,
0x3abe1492, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE1494-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Rolling_Back_Cluster_Configuration,
0x3abe1494, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE14A0-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Cleaning_Up_Cluster_Database,
0x3abe14A0, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE14A4-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Form_Creating_Cluster_Database,
0x3abe14A4, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE14A8-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Form_Customizing_Cluster_Database,
0x3abe14A8, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE14B0-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Creating_ClusNet_Service,
0x3abe14B0, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE14B4-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Starting_ClusNet_Service,
0x3abe14B4, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE14C0-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Configuring_ClusDisk_Service,
0x3abe14C0, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE14C4-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Starting_ClusDisk_Service,
0x3abe14C4, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE14D0-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Configuring_Cluster_Service_Account,
0x3abe14D0, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {4AA76355-C2B3-4f5b-87D6-5A11957E4280}
DEFINE_GUID( TASKID_Minor_Make_Cluster_Service_Account_Admin,
0x4aa76355, 0xc2b3, 0x4f5b, 0x87, 0xd6, 0x5a, 0x11, 0x95, 0x7e, 0x42, 0x80);

// {3ABE14E0-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Creating_Cluster_Service,
0x3abe14E0, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE14E4-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Starting_Cluster_Service,
0x3abe14E4, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE1500-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Initializing_Cluster_Join,
0x3abe1500, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {1D905EE7-3118-4c2c-BD61-2E4B9C109F71}
DEFINE_GUID( TASKID_Minor_Initializing_Cluster_Form,
0x1d905ee7, 0x3118, 0x4c2c, 0xbd, 0x61, 0x2e, 0x4b, 0x9c, 0x10, 0x9f, 0x71);

// {3ABE1518-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Join_Sync_Cluster_Database,
0x3abe1518, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {B8C4066E-0246-4358-9DE5-25603EDD0CA0}
DEFINE_GUID( TASKID_Minor_Finding_Common_Quorum_Device,
0xb8c4066e, 0x246, 0x4358, 0x9d, 0xe5, 0x25, 0x60, 0x3e, 0xdd, 0xc, 0xa0 );

// {8FA3B29F-74DC-4eef-81C0-918F6CF80B5B}
DEFINE_GUID( TASKID_Minor_Resource_Capabilities_Dont_Match,
0x8fa3b29f, 0x74dc, 0x4eef, 0x81, 0xc0, 0x91, 0x8f, 0x6c, 0xf8, 0xb, 0x5b );

// {0895415B-62A8-43d0-8949-B617F9ADC915}
DEFINE_GUID( TASKID_Minor_Selected_Quorum_Resource,
0x895415b, 0x62a8, 0x43d0, 0x89, 0x49, 0xb6, 0x17, 0xf9, 0xad, 0xc9, 0x15 );

// {F892123F-01A7-4751-84C5-9E2454C2DF67}
DEFINE_GUID( TASKID_Minor_Can_Node_Be_Clustered_Failed,
0xf892123f, 0x1a7, 0x4751, 0x84, 0xc5, 0x9e, 0x24, 0x54, 0xc2, 0xdf, 0x67 );

// {61C76E24-5CC3-4f91-BD91-ADAE1AA1AC8C}
DEFINE_GUID( TASKID_Minor_No_Managed_Resources_Found,
0x61c76e24, 0x5cc3, 0x4f91, 0xbd, 0x91, 0xad, 0xae, 0x1a, 0xa1, 0xac, 0x8c );

// {1080E6D1-CA8D-467e-A5F6-F7B554D650C9}
DEFINE_GUID( TASKID_Minor_Configuring_Generic_Script_Resource_Type,
0x1080e6d1, 0xca8d, 0x467e, 0xa5, 0xf6, 0xf7, 0xb5, 0x54, 0xd6, 0x50, 0xc9 );

// {64157205-3ECC-4880-B1A4-1BA9EB82BDD7}
DEFINE_GUID( TASKID_Minor_Configuring_Majority_Node_Set_Resource_Type,
0x64157205, 0x3ecc, 0x4880, 0xb1, 0xa4, 0x1b, 0xa9, 0xeb, 0x82, 0xbd, 0xd7);

// {F818E5AC-FDE9-4587-9C20-D97EC0185C31}
DEFINE_GUID( TASKID_Minor_W2KProxy_Initialized,
0xf818e5ac, 0xfde9, 0x4587, 0x9c, 0x20, 0xd9, 0x7e, 0xc0, 0x18, 0x5c, 0x31 );

// {9E6B30F7-CD47-417d-B59A-6A0C0CC3302B}
DEFINE_GUID( TASKID_Minor_No_Managed_Networks_Found,
0x9e6b30f7, 0xcd47, 0x417d, 0xb5, 0x9a, 0x6a, 0xc, 0xc, 0xc3, 0x30, 0x2b );

// {2B6B66C2-DD8C-46db-8613-DEFAE7CE1A33}
DEFINE_GUID( TASKID_Minor_Only_One_Network,
0x2b6b66c2, 0xdd8c, 0x46db, 0x86, 0x13, 0xde, 0xfa, 0xe7, 0xce, 0x1a, 0x33);

// {4F6BD1A1-9440-4d4c-A9E0-9943E7B34D30}
DEFINE_GUID( TASKID_Minor_Creating_Resource,
0x4f6bd1a1, 0x9440, 0x4d4c, 0xa9, 0xe0, 0x99, 0x43, 0xe7, 0xb3, 0x4d, 0x30 );

// {1E981583-8F20-4c94-82B8-AD10043293CA}
DEFINE_GUID( TASKID_Minor_Locate_Existing_Quorum_Device,
0x1e981583, 0x8f20, 0x4c94, 0x82, 0xb8, 0xad, 0x10, 0x4, 0x32, 0x93, 0xca );

// {16C4CB07-F3A0-4b16-8064-167810D876D0}
DEFINE_GUID( TASKID_Minor_Delete_LocalQuorum,
0x16c4cb07, 0xf3a0, 0x4b16, 0x80, 0x64, 0x16, 0x78, 0x10, 0xd8, 0x76, 0xd0 );

// {A0293F49-7721-4a0e-B59D-F7BCA0DB790A}
DEFINE_GUID( TASKID_Minor_Set_Quorum_Device,
0xa0293f49, 0x7721, 0x4a0e, 0xb5, 0x9d, 0xf7, 0xbc, 0xa0, 0xdb, 0x79, 0xa );

// {58C977AB-7B70-4d9e-988C-F521DA5F3829}
DEFINE_GUID( TASKID_Minor_Starting_Resources,
0x58c977ab, 0x7b70, 0x4d9e, 0x98, 0x8c, 0xf5, 0x21, 0xda, 0x5f, 0x38, 0x29 );

// {0C08485E-D16A-4a20-9E2C-B5D608F085C0}
DEFINE_GUID( TASKID_Minor_Resource_Failed_PostCreate,
0xc08485e, 0xd16a, 0x4a20, 0x9e, 0x2c, 0xb5, 0xd6, 0x8, 0xf0, 0x85, 0xc0 );

// {FBF36AFB-D025-4552-BA42-F3B462B66F77}
DEFINE_GUID( TASKID_Minor_Resource_Failed_PreCreate,
0xfbf36afb, 0xd025, 0x4552, 0xba, 0x42, 0xf3, 0xb4, 0x62, 0xb6, 0x6f, 0x77 );

// {17FDA98A-D919-4455-96D7-40EB4414ABDC}
DEFINE_GUID( TASKID_Minor_Resource_Failed_Create,
0x17fda98a, 0xd919, 0x4455, 0x96, 0xd7, 0x40, 0xeb, 0x44, 0x14, 0xab, 0xdc );

// {C4F4E13D-55BB-4c43-A0FD-7BFF6E620F52}
DEFINE_GUID( TASKID_Minor_Querying_For_Resource_Dependencies,
0xc4f4e13d, 0x55bb, 0x4c43, 0xa0, 0xfd, 0x7b, 0xff, 0x6e, 0x62, 0xf, 0x52 );

// {AEAC8221-A028-4a09-A372-8624F2A6BF75}
DEFINE_GUID( TASKID_Minor_Polling_Connection_Failure,
0xaeac8221, 0xa028, 0x4a09, 0xa3, 0x72, 0x86, 0x24, 0xf2, 0xa6, 0xbf, 0x75 );

// {2985247E-2CEB-4b1e-AAFE-EED45298EDA6}
DEFINE_GUID( TASKID_Minor_Found_Quorum_Capable_Resource,
0x2985247e, 0x2ceb, 0x4b1e, 0xaa, 0xfe, 0xee, 0xd4, 0x52, 0x98, 0xed, 0xa6 );

// {58902BD5-3F45-4626-A667-8433A5D7A6DC}
DEFINE_GUID( TASKID_Minor_Bad_Credentials,
0x58902bd5, 0x3f45, 0x4626, 0xa6, 0x67, 0x84, 0x33, 0xa5, 0xd7, 0xa6, 0xdc );

// {C921E972-9F5F-43ae-971C-B4CABA1265D5}
DEFINE_GUID( TASKID_Minor_Duplicate_Networks_Found,
0xc921e972, 0x9f5f, 0x43ae, 0x97, 0x1c, 0xb4, 0xca, 0xba, 0x12, 0x65, 0xd5 );

// {C4AFD9DC-3D2F-4c81-96C7-C9F18D9FFD7B}
DEFINE_GUID( TASKID_Minor_Phys_Disks_Query_Info,
0xc4afd9dc, 0x3d2f, 0x4c81, 0x96, 0xc7, 0xc9, 0xf1, 0x8d, 0x9f, 0xfd, 0x7b );


//
//  These need to be moved to there correct sections
//

// {DF41469F-0611-4d65-ABB5-2ACDC4D37000}
DEFINE_GUID( IID_IClusterHandleProvider ,
0xdf41469f, 0x611, 0x4d65, 0xab, 0xb5, 0x2a, 0xcd, 0xc4, 0xd3, 0x70, 0x0 );

// {DF41469F-0611-4d65-ABB5-2ACDC4D37001}
DEFINE_GUID( IID_IClusCfgSetHandle,
0xdf41469f, 0x611, 0x4d65, 0xab, 0xb5, 0x2a, 0xcd, 0xc4, 0xd3, 0x70, 0x1 );

// {3B797481-1494-4241-98A9-CE6BA7A59D1A}
//DEFINE_GUID( IID_IClusCfgSetCredentials,
//0x3b797481, 0x1494, 0x4241, 0x98, 0xa9, 0xce, 0x6b, 0xa7, 0xa5, 0x9d, 0x1a );

// {58E6E5B9-4788-4d9a-8255-1E274E5DCCB0}
DEFINE_GUID( IID_IClusCfgSetCredentials,
0x58e6e5b9, 0x4788, 0x4d9a, 0x82, 0x55, 0x1e, 0x27, 0x4e, 0x5d, 0xcc, 0xb0 );

// {58E6E5B9-4788-4d9a-8255-1E274E5DCCB1}
DEFINE_GUID( IID_AsyncIClusCfgSetCredentials,
0x58e6e5b9, 0x4788, 0x4d9a, 0x82, 0x55, 0x1e, 0x27, 0x4e, 0x5d, 0xcc, 0xb1 );

// {D47BBEEC-2286-4514-AA90-7E88BD0FE543}
DEFINE_GUID( IID_IClusCfgVerify,
0xD47BBEEC, 0x2286, 0x4514, 0xAA, 0x90, 0x7E, 0x88, 0xBD, 0x0F, 0xE5, 0x43 );

// {CE6EF90C-3602-41e7-95BD-AAFD37A676DF}
DEFINE_GUID( IID_IClusCfgClusterConnection,
0xce6ef90c, 0x3602, 0x41e7, 0x95, 0xbd, 0xaa, 0xfd, 0x37, 0xa6, 0x76, 0xdf );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\connectioninfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ConnectionInfo.h
//
//  Description:
//      CConnectionInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CConnectionInfo
class
CConnectionInfo:
    public IConnectionInfo
{
private:
    // IUnknown
    LONG                m_cRef;

    // IConnectionInfo
    IConfigurationConnection *  m_pcc;
    OBJECTCOOKIE                m_cookieParent;

private: // Methods
    CConnectionInfo( );
    ~CConnectionInfo();
    STDMETHOD( Init )( OBJECTCOOKIE pcookieParentIn );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut,
                            OBJECTCOOKIE pcookieParentIn
                            );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IConnectionInfo
    STDMETHOD( GetConnection )( IConfigurationConnection ** pccOut );
    STDMETHOD( SetConnection )( IConfigurationConnection * pccIn );
    STDMETHOD( GetParent )( OBJECTCOOKIE * pcookieOut );

}; // class CConnectionInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\connectioninfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ConnectionInfo.cpp
//
//  Description:
//      CConnectionInfo implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 02-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "ConnectionInfo.h"

DEFINE_THISCLASS("CConnectionInfo")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CConnectionInfo::S_HrCreateInstance(
//      OBJECTCOOKIE cookieParentIn    
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConnectionInfo::S_HrCreateInstance(
    IUnknown **  ppunkOut,
    OBJECTCOOKIE cookieParentIn    
    )
{
    TraceFunc1( "ppunkOut, cookieParentIn = %u", cookieParentIn );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CConnectionInfo * pci = new CConnectionInfo;
    if ( pci != NULL )
    {
        hr = THR( pci->Init( cookieParentIn ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR(  pci->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pci->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//
//  CConnectionInfo::CConnectionInfo( void )
//
//////////////////////////////////////////////////////////////////////////////
CConnectionInfo::CConnectionInfo( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CConnectionInfo( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CConnectionInfo::Init( 
//      OBJECTCOOKIE cookieParentIn 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionInfo::Init( 
    OBJECTCOOKIE cookieParentIn 
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );    // Add one count

    // IConnectionInfo
    Assert( m_pcc == NULL );
    m_cookieParent = cookieParentIn;

    HRETURN( hr );

} // Init( )

//////////////////////////////////////////////////////////////////////////////
//
//  CConnectionInfo::~CConnectionInfo( )
//
//////////////////////////////////////////////////////////////////////////////
CConnectionInfo::~CConnectionInfo( )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CConnectionInfo( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CConnectionInfo::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionInfo::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IConnectionInfo * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IConnectionInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IConnectionInfo, this, 0 );
        hr   = S_OK;
    } // else if: IConnectionInfo

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} // QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CConnectionInfo::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CConnectionInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CConnectionInfo::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CConnectionInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release( )


//****************************************************************************
//
//  IConnectionInfo
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CConnectionInfo::GetConnection(
//      IConfigurationConnection ** pccOut 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionInfo::GetConnection(
    IConfigurationConnection ** pccOut
    )
{
    TraceFunc( "[IConnectionInfo]" );

    HRESULT hr = S_OK;

    if ( pccOut == NULL )
        goto InvalidPointer;

    *pccOut = m_pcc;

    if ( m_pcc == NULL )
    {
        hr = S_FALSE;
    }
    else
    {
        (*pccOut)->AddRef( );
    }

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} // GetConnection( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CConnectionInfo::SetConnection(
//      IConfigurationConnection * pccIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionInfo::SetConnection(
    IConfigurationConnection * pccIn
    )
{
    TraceFunc( "[IConnectionInfo]" );

    HRESULT hr = S_OK;

    if ( m_pcc != NULL )
    {
        m_pcc->Release( );
    }

    m_pcc = pccIn;

    if ( m_pcc != NULL )
    {
        m_pcc->AddRef( );
    }

    HRETURN( hr );

} // SetConnection( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CConnectionInfo::GetParent(
//      OBJECTCOOKIE * pcookieOut 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionInfo::GetParent(
    OBJECTCOOKIE * pcookieOut 
    )
{
    TraceFunc( "[IConnectionInfo]" );

    HRESULT hr = S_OK;

    if ( pcookieOut == NULL )
        goto InvalidPointer;

    Assert( m_cookieParent != NULL );

    *pcookieOut = m_cookieParent;

    if ( m_cookieParent == NULL )
    {
        hr = S_FALSE;
    }

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} // GetParent( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\connectionmanager.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ConnectionMgr.h
//
//  Description:
//      Connection Manager implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CConnectionManager
class
CConnectionManager:
    public IConnectionManager
{
private:
    // IUnknown
    LONG        m_cRef;

private: // Methods
    CConnectionManager( void );
    ~CConnectionManager( void );
    STDMETHOD(Init)( void );


    HRESULT
        HrGetNodeConnection(
            OBJECTCOOKIE                cookieIn,
            IConfigurationConnection ** ppccOut
            );
    HRESULT
        HrGetClusterConnection(
            OBJECTCOOKIE                cookieIn,
            IConfigurationConnection ** ppccOut
            );
    HRESULT
        HrStoreConnection(
            IConnectionInfo *           pciIn,
            IConfigurationConnection *  pccIn,
            IUnknown **                 ppunkOut
            );

    HRESULT
        HrGetConfigurationConnection(
            OBJECTCOOKIE        cookieIn,
            IConnectionInfo *   pciIn,
            IUnknown **         ppunkOut
            );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID * ppv );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IConnectionManager
    STDMETHOD(GetConnectionToObject)( OBJECTCOOKIE  cookieIn,
                                      IUnknown **   ppunkOut
                                      );

}; // class CConnectionManager
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\connectionmanager.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ConnectionManager.cpp
//
//  Description:
//      Connection Manager implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "ConnectionManager.h"

DEFINE_THISCLASS("CConnectionManager")
#define THISCLASS CConnectionManager

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CConnectionManager::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConnectionManager::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CConnectionManager * pcm = new CConnectionManager();
    if ( pcm != NULL )
    {
        hr = THR( pcm->Init() );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pcm->TypeSafeQI( IUnknown, ppunkOut ) );
        } // if: success

        pcm->Release();

    } // if: got object
    else
    {
        hr = E_OUTOFMEMORY;

    } // else: out of memory

    HRETURN( hr );

} //*** CConnectionManager::S_HrCreateInstance();

//////////////////////////////////////////////////////////////////////////////
//
//  CConnectionManager::CConnectionManager( void )
//
//////////////////////////////////////////////////////////////////////////////
CConnectionManager::CConnectionManager( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CConnectionManager::CConnectionManager()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CConnectionManager::Init( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionManager::Init( void )
{
    TraceFunc( "" );

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef();

    HRETURN( S_OK );

} //*** CConnectionManager::Init()

//////////////////////////////////////////////////////////////////////////////
//
//  CConnectionManager::~CConnectionManager()
//
//////////////////////////////////////////////////////////////////////////////
CConnectionManager::~CConnectionManager()
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CConnectionManager::~CConnectionManager()


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CConnectionManager::QueryInterface(
//      REFIID      riid,
//      LPVOID *    ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionManager::QueryInterface(
    REFIID      riid,
    LPVOID *    ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IConnectionManager * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IConnectionManager ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IConnectionManager, this, 0 );
        hr   = S_OK;
    } // else if: IConnectionManager

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CConnectionManager::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CConnectionManager::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CConnectionManager::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CConnectionManager::AddRef()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CConnectionManager::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CConnectionManager::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN( 0 );

} //*** CConnectionManager::Release()

// ************************************************************************
//
// IConnectionManager
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CConnectionManager::GetConnectionToObject(
//      OBJECTCOOKIE    cookieIn,
//      IUnknown **     ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionManager::GetConnectionToObject(
    OBJECTCOOKIE    cookieIn,
    IUnknown **     ppunkOut
    )
{
    TraceFunc1( "[IConnectionManager] cookieIn = %#x", cookieIn );

    HRESULT hr;
    CLSID   clsid;

    OBJECTCOOKIE        cookieParent;

    IServiceProvider *  psp;

    BSTR                       bstrName  = NULL;
    IUnknown *                 punk      = NULL;
    IObjectManager *           pom       = NULL;
    IConnectionInfo *          pci       = NULL;
    IConnectionInfo *          pciParent = NULL;
    IStandardInfo *            psi       = NULL;
    IConfigurationConnection * pcc       = NULL;

    //
    //  Validate parameters
    //
    if ( cookieIn == NULL )
        goto InvalidArg;

    if ( ppunkOut == NULL )
        goto InvalidPointer;

    //
    //  Collect the managers needed to complete this method.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                               IObjectManager,
                               &pom
                               ) );
    psp->Release();
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Check to see if we already have a connection cached.
    //

    //
    //  Get the connection info for this cookie.
    //

    hr = THR( pom->GetObject( DFGUID_ConnectionInfoFormat,
                              cookieIn,
                              &punk
                              ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( punk->TypeSafeQI( IConnectionInfo, &pci ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    pci = TraceInterface( L"ConnectionManager!IConnectionInfo", IConnectionInfo, pci, 1 );

    punk->Release();
    punk = NULL;

    //
    //  See if there is a current connection.
    //

    hr = STHR( pci->GetConnection( &pcc ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( hr == S_FALSE )
    {
        //
        //  Check to see if the parent has a connection.
        //

        //
        //  Get the standard info for this cookie.
        //

        hr = THR( pom->GetObject( DFGUID_StandardInfo,
                                  cookieIn,
                                  &punk
                                  ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        psi = TraceInterface( L"ConnectionManager!IStandardInfo", IStandardInfo, psi, 1 );

        punk->Release();
        punk = NULL;

        hr = STHR( psi->GetType( &clsid ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( !IsEqualIID( clsid, CLSID_NodeType )
          && !IsEqualIID( clsid, CLSID_ClusterConfigurationType )
           )
        {
            hr = STHR( psi->GetParent( &cookieParent ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            //  Release it.
            psi->Release();
            psi = NULL;

            //
            //  If there is a parent, follow it.
            //

            if ( hr == S_OK )
            {
                //
                //  Get the connection info for this cookie.
                //

                hr = THR( pom->GetObject( DFGUID_ConnectionInfoFormat,
                                          cookieParent,
                                          &punk
                                          ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

                hr = THR( punk->TypeSafeQI( IConnectionInfo, &pciParent ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

                pciParent = TraceInterface( L"ConnectionManager!IConnectionInfo", IConnectionInfo, pciParent, 1 );

                punk->Release();
                punk = NULL;

                //
                //  See if there is a current connection.
                //

                hr = STHR( pciParent->GetConnection( &pcc ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

                //
                // TODO:    gpease  08-MAR-2000
                //          Find a better error code.
                //
                //if ( hr == S_FALSE )
                //    goto InvalidArg;

            } // if: parent found
        } // if: not a node or cluster
        else
        {
            psi->Release();
            psi = NULL;
        }

    } // if: no established connection

    //
    //  Did we have to contact the parent to get to the child?
    //

    if ( pcc != NULL )
    {
        //
        //  Reuse the existing connection.
        //
        hr = THR( pcc->QueryInterface( IID_IUnknown, reinterpret_cast< void ** >( ppunkOut ) ) );
        goto Cleanup;
    }

    //
    //  Need to build a connection to the object because the object doesn't
    //  have a parent and it doesn't currently have a connection.
    //

    //
    //  Find out what type of object it is.
    //

    hr = THR( pom->GetObject( DFGUID_StandardInfo,
                              cookieIn,
                              &punk
                              ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    psi = TraceInterface( L"ConnectionManager!IStandardInfo", IStandardInfo, psi, 1 );

    punk->Release();
    punk = NULL;

    hr = THR( psi->GetType( &clsid ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Create the appropriate connection for that type of object.
    //

    if ( IsEqualIID( clsid, CLSID_NodeType ) )
    {
        hr = THRE( HrGetConfigurationConnection( cookieIn, pci, ppunkOut ), HR_S_RPC_S_CLUSTER_NODE_DOWN );
    } // if: node
    else if ( IsEqualIID( clsid, CLSID_ClusterConfigurationType ) )
    {
        hr = THRE( HrGetConfigurationConnection( cookieIn, pci, ppunkOut ), HR_S_RPC_S_SERVER_UNAVAILABLE );
    } // if: cluster
    else
    {
        //
        //  TODO:   gpease  07-MAR-2000
        //          Find a better error code.
        //
        hr = THR( E_FAIL );
        goto Cleanup;

    } // else: no connection support

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }

    TraceSysFreeString( bstrName );

    if ( pci != NULL )
    {
        pci->Release();
    } // if: pci

    if ( pom != NULL )
    {
        pom->Release();
    } // if: pom

    if ( psi != NULL )
    {
        psi->Release();
    } // if: psi

    if ( pciParent != NULL )
    {
        pciParent->Release();
    } // if: pciParent

    if ( pcc != NULL )
    {
        pcc->Release();
    } // if: pcc

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} //*** CConnectionManager::GetConnectionToObject()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CConnectionManager::HrGetConfigurationConnection(
//      OBJECTCOOKIE        cookieIn,
//      IConnectionInfo *   pciIn,
//      IUnknown **         ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConnectionManager::HrGetConfigurationConnection(
    OBJECTCOOKIE        cookieIn,
    IConnectionInfo *   pciIn,
    IUnknown **         ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    IConfigurationConnection * pccNode      = NULL;
    IConfigurationConnection * pccCluster   = NULL;
    IConfigurationConnection * pcc          = NULL;

    // Try and connect to the node using the new server.
    hr = HrGetNodeConnection( cookieIn, &pccNode );
    if ( hr == HR_S_RPC_S_CLUSTER_NODE_DOWN )
    {
        Assert( *ppunkOut == NULL );
        goto Cleanup;
    } // if:

    // Try and connect to the node using the W2K object.
    if ( hr == HRESULT_FROM_WIN32( REGDB_E_CLASSNOTREG ) )
    {
        HRESULT hrCluster = THR( HrGetClusterConnection( cookieIn, &pccCluster ) );

        if ( hrCluster == S_OK )
        {
            Assert( pccCluster != NULL );
            Assert( pcc == NULL );

            pcc = pccCluster;
            pccCluster = NULL;

            hr = hrCluster;
        } // if:
    } // if: failed to get a node connection

    if ( FAILED( hr ) )
    {
        THR( hr );
        goto Cleanup;
    }

    if ( pcc == NULL )
    {
        Assert( pccNode != NULL );
        pcc = pccNode;
        pccNode = NULL;
    }

    //
    //  VERY IMPORTANT: Store the connection and retrieve the IUnknown pointer
    //  only if the result is S_OK.
    //

    if ( hr == S_OK )
    {
        THR( HrStoreConnection( pciIn, pcc, ppunkOut ) );
    }

Cleanup:

    if ( pcc )
    {
        pcc->Release();
    }

    if ( pccNode != NULL )
    {
        pccNode->Release();
    }

    if ( pccCluster != NULL )
    {
        pccCluster->Release();
    }

    HRETURN( hr );

} //*** CConnectionManager::HrGetConfigurationConnection()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CConnectionManager::HrGetNodeConnection(
//      OBJECTCOOKIE                cookieIn,
//      IConfigurationConnection ** ppccOut
//      )
//
//  This connection may be valid even if the ConnectTo call fails.
//  -That means that there is no cluster installed on the target node.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConnectionManager::HrGetNodeConnection(
    OBJECTCOOKIE                cookieIn,
    IConfigurationConnection ** ppccOut
    )
{
    TraceFunc( "" );

    HRESULT                     hr;
    IConfigurationConnection *  pcc = NULL;

    // Check the pointers in.
    Assert( ppccOut != NULL );
    Assert( *ppccOut == NULL );

    hr = CoCreateInstance( CLSID_ConfigurationConnection,
                           NULL,
                           CLSCTX_SERVER,
                           TypeSafeParams( IConfigurationConnection, &pcc )
                           );
    if ( FAILED( hr ) )
    {
        THR( hr );
        goto Cleanup;
    }

    // Don't wrap - we want to handle some of the failures.
    hr = pcc->ConnectTo( cookieIn );

    switch( hr )
    {
    // Known valid return codes.
    case HR_S_RPC_S_SERVER_UNAVAILABLE:
        break;

    // Known error codes.
    case HRESULT_FROM_WIN32( REGDB_E_CLASSNOTREG ):
        // This means the ClusCfg server is not available.
        goto Cleanup;

    case HR_S_RPC_S_CLUSTER_NODE_DOWN:
        // This means the service is not running on that node.
        Assert( *ppccOut == NULL );
        goto Cleanup;

    default:
        if( FAILED( hr ) )
        {
            THR( hr );
            goto Cleanup;
        }
    } // switch:

    // Return the connection.
    *ppccOut = pcc;
    pcc = NULL;

Cleanup:

    if ( pcc )
    {
        pcc->Release();
    }

    HRETURN( hr );

} //*** CConnectionManager::HrGetNodeConnection()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CConnectionManager::HrGetClusterConnection(
//      OBJECTCOOKIE                cookieIn,
//      IConfigurationConnection ** ppccOut
//      )
//
//
//  This connection must succeede completely to return a valid object.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConnectionManager::HrGetClusterConnection(
    OBJECTCOOKIE                cookieIn,
    IConfigurationConnection ** ppccOut
    )
{
    TraceFunc( "" );

    HRESULT                     hr;
    IConfigurationConnection *  pcc = NULL;

    // Check the pointers in.
    Assert( ppccOut != NULL );
    Assert( *ppccOut == NULL );

    //
    // Should be a downlevel cluster.
    //
    hr = THR( CoCreateInstance( CLSID_ConfigClusApi,
                                NULL,
                                CLSCTX_SERVER,
                                TypeSafeParams( IConfigurationConnection, &pcc )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Don't wrap - we want to handle some of the failures.
    hr = pcc->ConnectTo( cookieIn );
    if ( hr == HR_S_RPC_S_CLUSTER_NODE_DOWN )
    {
        goto Cleanup;
    } // if:

    // Handle the expected error messages.

    // If the cluster service is not running, then the endpoint
    // is unavailable and we cannot connect to it.
    if ( hr == HRESULT_FROM_WIN32( EPT_S_NOT_REGISTERED ) )
        goto Cleanup;

    if ( FAILED( hr ) )
    {
        THR( hr );
        goto Cleanup;
    } // if:

    // Return the connection.
    *ppccOut = pcc;
    pcc = NULL;

Cleanup:

    if ( pcc )
    {
        pcc->Release();
    }

    HRETURN( hr );

} //*** CConnectionManager::HrGetClusterConnection()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CConnectionManager::HrStoreConnection(
//      IConnectionInfo *           pciIn,
//      IConfigurationConnection *  pccIn,
//      IUnknown **                 ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConnectionManager::HrStoreConnection(
    IConnectionInfo *           pciIn,
    IConfigurationConnection *  pccIn,
    IUnknown **                 ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    //
    //  Save it away to be used next time.
    //
    //  TODO:   gpease  08-MAR-2000
    //          If we failed to save away the connection, does
    //          the caller need to know this? I don't think so.
    //
    THR( pciIn->SetConnection( pccIn ) );

    hr = THR( pccIn->QueryInterface( IID_IUnknown,
                                   reinterpret_cast< void ** >( ppunkOut )
                                   ) );

    HRETURN( hr );

} //*** CConnectionManager::HrStoreConnection()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\connpointenum.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ConnPointEnum.h
//
//  Description:
//      Connection Point Enumerator implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 04-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CNotificationManager;

//  Link list of connection points
typedef struct _SCPEntry {
    struct _SCPEntry *  pNext;  //  Next item in list
    CLSID               iid;    //  Interface ID
    IUnknown *          punk;   //  Punk to object
} SCPEntry;

// ConnPointEnum
class 
CConnPointEnum:
    public IEnumConnectionPoints
{
friend class CNotificationManager;
private:
    // IUnknown
    LONG            m_cRef;

    // IEnumConnectionPoints
    SCPEntry *      m_pCPList;      //  List of connection points
    SCPEntry *      m_pIter;        //  Iter - don't free

private: // Methods
    CConnPointEnum( );
    ~CConnPointEnum();
    STDMETHOD(Init)( );

    HRESULT
        HrCopy( CConnPointEnum * pECPIn );
    HRESULT
        HrAddConnection( REFIID riidIn, IUnknown * punkIn );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IEnumConnectionPoints
    STDMETHOD( Next )( ULONG cConnections, LPCONNECTIONPOINT *ppCP, ULONG *pcFetched );
    STDMETHOD( Skip )( ULONG cConnections );
    STDMETHOD( Reset )( void );
    STDMETHOD( Clone )( IEnumConnectionPoints **ppEnum );

}; // class CConnPointEnum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\connpointenum.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ConnPointEnum.cpp
//
//  Description:
//      Connection Point Enumerator implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 04-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "ConnPointEnum.h"

DEFINE_THISCLASS("CConnPointEnum")


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CConnPointEnum::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConnPointEnum::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr = E_OUTOFMEMORY;

    CConnPointEnum * lpcc = new CConnPointEnum( );
    if ( lpcc != NULL )
    {
        hr = THR( lpcc->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( lpcc->TypeSafeQI( IUnknown, ppunkOut ) );
        } // if: success

        lpcc->Release( );

    } // if: got object

    HRETURN( hr );

} //*** CConnPointEnum::S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConnPointEnum::CConnPointEnum( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CConnPointEnum::CConnPointEnum( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CConnPointEnum::CConnPointEnum( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConnPointEnum::Init( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnPointEnum::Init( void )
{
    TraceFunc( "" );

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );  // Add one count

    // IConnectionPoint
    Assert( m_pCPList == NULL );

    HRETURN(S_OK);

} //*** CConnPointEnum::Init( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConnPointEnum::~CConnPointEnum( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CConnPointEnum::~CConnPointEnum( void )
{
    TraceFunc( "" );

    while ( m_pCPList != NULL )
    {
        SCPEntry * pentry;

        pentry = m_pCPList;
        m_pCPList = m_pCPList->pNext;

        if ( pentry->punk != NULL )
        {
            pentry->punk->Release( );
        }

        TraceFree( pentry );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CConnPointEnum::~CConnPointEnum( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConnPointEnum::QueryInterface( 
//      REFIID      riidIn, 
//      LPVOID *    ppvOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnPointEnum::QueryInterface( 
    REFIID      riidIn, 
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IEnumConnectionPoints * >( this );
        hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IEnumConnectionPoints ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumConnectionPoints, this, 0 );
        hr = S_OK;
    } // else if: IEnumConnectionPoints

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CConnPointEnum::QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CConnPointEnum::AddRef( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CConnPointEnum::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CConnPointEnum::AddRef( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CConnPointEnum::Release( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CConnPointEnum::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} //*** CConnPointEnum::Release( )


//****************************************************************************
//
//  IEnumConnectionPoints
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP 
//  CConnPointEnum::Next( 
//      ULONG               cConnectionsIn, 
//      LPCONNECTIONPOINT * ppCPOut, 
//      ULONG *             pcFetchedOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CConnPointEnum::Next( 
    ULONG               cConnectionsIn, 
    LPCONNECTIONPOINT * ppCPOut, 
    ULONG *             pcFetchedOut
    )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    HRESULT hr = E_UNEXPECTED;
    ULONG   celt;

    if ( pcFetchedOut != NULL )
    {
        *pcFetchedOut = 0;
    }

    if ( m_pIter != NULL )
    {
        for( celt = 0; celt < cConnectionsIn; )
        {
            hr = THR( m_pIter->punk->TypeSafeQI( IConnectionPoint, &ppCPOut[ celt ] ) );
            if ( FAILED( hr ) )
                goto Error;

            ppCPOut[ celt ] = TraceInterface( L"ConnPointEnum!IConnectionPoint", IConnectionPoint, ppCPOut[ celt ], 1 );

            celt ++;
            m_pIter = m_pIter->pNext;
            if( m_pIter == NULL )
                break;
        }
    }
    else
    {
        celt = 0;
    }

    if ( celt != cConnectionsIn )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    if ( pcFetchedOut != NULL )
    {
        *pcFetchedOut = celt;
    }

Cleanup:
    HRETURN( hr );

Error:
    while ( celt > 0 )
    {
        celt --;
        ppCPOut[ celt ]->Release( );
    }
    goto Cleanup;

} //*** CConnPointEnum::Next( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP 
//  CConnPointEnum::Skip( 
//      ULONG cConnectionsIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CConnPointEnum::Skip( 
    ULONG cConnectionsIn 
    )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    HRESULT hr = E_UNEXPECTED;
    ULONG   celt;

    if ( m_pIter != NULL )
    {
        for ( celt = 0; celt < cConnectionsIn; celt ++ )
        {
            m_pIter = m_pIter->pNext;

            if ( m_pIter == NULL )
                break;
        }
    }

    if ( m_pIter == NULL )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    HRETURN( hr );

} //*** CConnPointEnum::Skip( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP 
//  CConnPointEnum::Reset( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CConnPointEnum::Reset( void )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    HRESULT hr = S_OK;

    m_pIter = m_pCPList;

    HRETURN( hr );

} //*** CConnPointEnum::Reset( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP 
//  CConnPointEnum::Clone( 
//      IEnumConnectionPoints ** ppEnum 
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CConnPointEnum::Clone( 
    IEnumConnectionPoints ** ppEnum 
    )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    HRESULT hr;

    CConnPointEnum * pcpenum = new CConnPointEnum( );
    if ( pcpenum == NULL )
        goto OutOfMemory;

    hr = THR( pcpenum->Init( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pcpenum->HrCopy( this ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pcpenum->TypeSafeQI( IEnumConnectionPoints, ppEnum ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    *ppEnum = TraceInterface( L"ConnPointEnum!IEnumConnectionPoints", IEnumConnectionPoints, *ppEnum, 1 );

    //
    //  Release our ref and make sure we don't free it on the way out.
    //

    pcpenum->Release( );
    pcpenum = NULL;

Cleanup:
    if ( pcpenum != NULL )
    {
        delete pcpenum;
    }

    HRETURN( hr );
    
OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CConnPointEnum::Clone( )


//****************************************************************************
//
//  Private
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CConnPointEnum::HrCopy( 
//      CConnPointEnum * pECPIn 
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConnPointEnum::HrCopy( 
    CConnPointEnum * pECPIn 
    )
{
    TraceFunc1( "pECPIn = %p", pECPIn );

    HRESULT hr = S_OK;

    SCPEntry * pentry;

    Assert( m_pCPList == NULL );

    for( pentry = pECPIn->m_pCPList; pentry != NULL; pentry = pentry->pNext )
    {
        SCPEntry * pentryNew = (SCPEntry *) TraceAlloc( 0, sizeof(SCPEntry) );
        if ( pentryNew == NULL )
            goto OutOfMemory;

        pentryNew->iid = pentry->iid;
        hr = THR( pentry->punk->TypeSafeQI( IUnknown, &pentryNew->punk ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        pentryNew->punk = TraceInterface( L"ConnPointEnum!IUnknown", IUnknown, pentryNew->punk, 1 );

        pentryNew->pNext = m_pCPList;
        m_pCPList = pentryNew;        
    }

    m_pIter = m_pCPList;

Cleanup:
    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CConnPointEnum::CConnPointEnum( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CConnPointEnum::HrAddConnection( 
//      REFIID riidIn, 
//      IUnknown * punkIn 
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConnPointEnum::HrAddConnection(
    REFIID riidIn, 
    IUnknown * punkIn 
    )
{
    TraceFunc( "" );

    HRESULT hr = E_UNEXPECTED;

    SCPEntry * pentry;

    //
    //  Check to see if the interface is already registered.
    //

    for ( pentry = m_pCPList; pentry != NULL; pentry = pentry->pNext )
    {
        if ( pentry->iid == riidIn )
            goto AlreadyRegistered;
    } // for: pentry

    //
    //  Not registered; add it.
    //

    pentry = (SCPEntry *) TraceAlloc( 0, sizeof( SCPEntry ) );
    if ( pentry == NULL )
        goto OutOfMemory;

    hr = THR( punkIn->TypeSafeQI( IUnknown, &pentry->punk ) );
    if ( FAILED( hr ) )
    {
        TraceFree( pentry );
        goto Cleanup;
    }

    pentry->punk = TraceInterface( L"ConnPointEnum!IUnknown", IUnknown, pentry->punk, 1 );

    pentry->iid   = riidIn;
    pentry->pNext = m_pCPList;
    m_pCPList     = pentry;
    m_pIter       = m_pCPList;

Cleanup:
    HRETURN( hr );

AlreadyRegistered:
    hr = THR( CO_E_OBJISREG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CConnPointEnum::HrAddConnection( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\cpicluscfgcallback.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CPIClusCfgCallback.cpp
//
//  Description:
//      IClusCfgCallback Connection Point implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 10-NOV-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "CPIClusCfgCallback.h"
#include "EnumCPICCCB.h"

DEFINE_THISCLASS("CCPIClusCfgCallback")


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CCPIClusCfgCallback::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCPIClusCfgCallback::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CCPIClusCfgCallback * lpcc = new CCPIClusCfgCallback( );
    if ( lpcc != NULL )
    {
        hr = THR( lpcc->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( lpcc->TypeSafeQI( IUnknown, ppunkOut ) );
        } // if: success

        lpcc->Release( );

    } // if: got object
    else
    {
        hr = E_OUTOFMEMORY;
    } // else: out of memory

    HRETURN( hr );

} // S_HrCreateInstance( )

//
// Constructor
//
CCPIClusCfgCallback::CCPIClusCfgCallback( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CCPIClusCfgCallback( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCPIClusCfgCallback::Init( )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPIClusCfgCallback::Init( )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );  // Add one count

    // IConnectionPoint
    Assert( m_penum == NULL );

    m_penum = new CEnumCPICCCB( );
    if ( m_penum == NULL )
        goto OutOfMemory;

    hr = THR( m_penum->Init( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // IClusCfgCallback

Cleanup:
    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // Init( )

//////////////////////////////////////////////////////////////////////////////
//
//  CCPIClusCfgCallback::~CCPIClusCfgCallback( )
//
//////////////////////////////////////////////////////////////////////////////
CCPIClusCfgCallback::~CCPIClusCfgCallback( )
{
    TraceFunc( "" );

    if ( m_penum != NULL )
    {
        m_penum->Release( );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CCPIClusCfgCallback( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCPIClusCfgCallback::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPIClusCfgCallback::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IConnectionPoint * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IConnectionPoint ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IConnectionPoint, this, 0 );
        hr   = S_OK;
    } // else if: IConnectionPoint
    else if ( IsEqualIID( riid, IID_IClusCfgCallback ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
        hr   = S_OK;
    } // else if: IClusCfgCallback

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} // QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CCPIClusCfgCallback::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CCPIClusCfgCallback::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CCPIClusCfgCallback::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CCPIClusCfgCallback::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release( )


// ************************************************************************
//
// IConnectionPoint
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CCPIClusCfgCallback::GetConnectionInterface(
//      IID * pIIDOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPIClusCfgCallback::GetConnectionInterface(
    IID * pIIDOut
    )
{
    TraceFunc( "[IConnectionPoint] pIIDOut" );

    HRESULT hr = S_OK;

    if ( pIIDOut == NULL )
        goto InvalidPointer;

    *pIIDOut = IID_IClusCfgCallback;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} // GetConnectionInterface( )

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CCPIClusCfgCallback::GetConnectionPointContainer(
//      IConnectionPointContainer * * ppcpcOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPIClusCfgCallback::GetConnectionPointContainer(
    IConnectionPointContainer * * ppcpcOut
    )
{
    TraceFunc( "[IConnectionPoint] ppcpcOut" );

    HRESULT hr;

    IServiceProvider * psp = NULL;

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager,
                               IConnectionPointContainer,
                               ppcpcOut
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( psp != NULL )
    {
        psp->Release( );
    }

    HRETURN( hr );

} // GetConnectionPointContainer( )

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CCPIClusCfgCallback::Advise(
//      IUnknown * pUnkSinkIn,
//      DWORD * pdwCookieOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPIClusCfgCallback::Advise(
    IUnknown * pUnkSinkIn,
    DWORD * pdwCookieOut
    )
{
    TraceFunc( "[IConnectionPoint]" );

    HRESULT hr;

    if ( pdwCookieOut == NULL )
        goto InvalidPointer;

    if ( pUnkSinkIn == NULL )
        goto InvalidArg;

    Assert( m_penum != NULL );

    hr = THR( m_penum->HrAddConnection( pUnkSinkIn, pdwCookieOut ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} // Advise( )

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CCPIClusCfgCallback::Unadvise(
//      DWORD dwCookieIn
//      )
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPIClusCfgCallback::Unadvise(
    DWORD dwCookieIn
    )
{
    TraceFunc1( "[IConncetionPoint] dwCookieIn = %#x", dwCookieIn );

    HRESULT hr;

    Assert( m_penum != NULL );

    hr = THR( m_penum->HrRemoveConnection( dwCookieIn ) );

    HRETURN( hr );

} // Unadvise( )

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CCPIClusCfgCallback::EnumConnections(
//  IEnumConnections * * ppEnumOut
//  )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPIClusCfgCallback::EnumConnections(
    IEnumConnections * * ppEnumOut
    )
{
    TraceFunc( "[IConnectionPoint] ppEnumOut" );

    HRESULT hr;

    if ( ppEnumOut == NULL )
        goto InvalidPointer;

    hr = THR( m_penum->Clone( ppEnumOut ) );

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} // EnumConnections( )


//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCPIClusCfgCallback::SendStatusReport(
//        LPCWSTR     pcszNodeNameIn
//      , CLSID       clsidTaskMajorIn
//      , CLSID       clsidTaskMinorIn
//      , ULONG       ulMinIn
//      , ULONG       ulMaxIn
//      , ULONG       ulCurrentIn
//      , HRESULT     hrStatusIn
//      , LPCWSTR     pcszDescriptionIn
//      , FILETIME *  pftTimeIn
//      , LPCWSTR     pcszReferenceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPIClusCfgCallback::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    CONNECTDATA cd = { NULL };

    HRESULT             hr;
    HRESULT             hrResult = S_OK;
    IClusCfgCallback *  pcccb;
    FILETIME            ft;

    hr = THR( m_penum->Reset( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    for ( ;; )
    {
        if ( cd.pUnk != NULL )
        {
            cd.pUnk->Release( );
            cd.pUnk = NULL;
        }

        hr = STHR( m_penum->Next( 1, &cd, NULL ) );
        if ( FAILED( hr ) )
            break;

        if ( hr == S_FALSE )
        {
            hr = S_OK;
            break; // exit condition
        }

        hr = THR( cd.pUnk->TypeSafeQI( IClusCfgCallback, &pcccb ) );
        if ( FAILED( hr ) )
            continue;   // ingore the error and continue

        if ( pftTimeIn == NULL )
        {
            GetSystemTimeAsFileTime( &ft );
            pftTimeIn = &ft;
        } // if:

        hr = THR( pcccb->SendStatusReport(
                 pcszNodeNameIn
               , clsidTaskMajorIn
               , clsidTaskMinorIn
               , ulMinIn
               , ulMaxIn
               , ulCurrentIn
               , hrStatusIn
               , pcszDescriptionIn
               , pftTimeIn
               , pcszReferenceIn
               ) );
        if ( hr != S_OK )
        {
            hrResult = hr;
        }

        pcccb->Release( );
    }

Cleanup:
    if ( cd.pUnk != NULL )
    {
        cd.pUnk->Release( );
    }

    HRETURN( hrResult );

} // SendStatusReport( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\cpicluscfgcallback.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CPIClusCfgCallback.h
//
//  Description:
//      INotifyUI Connection Point implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 10-NOV-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CEnumCPICCCB;

// CCPIClusCfgCallback
class
CCPIClusCfgCallback:
    public IConnectionPoint,
    public IClusCfgCallback
{
private:
    // IUnknown
    LONG                m_cRef;     //  Reference count

    // IConnectionPoint
    CEnumCPICCCB *      m_penum;    //  Connection enumerator

    // INotifyUI

private: // Methods
    CCPIClusCfgCallback( );
    ~CCPIClusCfgCallback();
    STDMETHOD(Init)( );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )(void);
    STDMETHOD_( ULONG, Release )(void);

    // IConnectionPoint
    STDMETHOD( GetConnectionInterface )( IID * pIIDOut );
    STDMETHOD( GetConnectionPointContainer )( IConnectionPointContainer * * ppcpcOut );
    STDMETHOD( Advise )( IUnknown * pUnkSinkIn, DWORD * pdwCookieOut );
    STDMETHOD( Unadvise )( DWORD dwCookieIn );
    STDMETHOD( EnumConnections )( IEnumConnections * * ppEnumOut );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )(
          LPCWSTR    pcszNodeNameIn
        , CLSID      clsidTaskMajorIn
        , CLSID      clsidTaskMinorIn
        , ULONG      ulMinIn
        , ULONG      ulMaxIn
        , ULONG      ulCurrentIn
        , HRESULT    hrStatusIn
        , LPCWSTR    pcszDescriptionIn
        , FILETIME * pftTimeIn
        , LPCWSTR    pcszReferenceIn
        );

}; // class CCPIClusCfgCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\configconnection.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ConfigurationConnection.cpp
//
//  Description:
//      CConfigurationConnection implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "TaskPollingCallback.h"
#include "ConfigConnection.h"
#include <ClusCfgPrivate.h>
#include <nameutil.h>

DEFINE_THISCLASS("CConfigurationConnection")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CConfigurationConnection::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConfigurationConnection::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CConfigurationConnection * pcc = new CConfigurationConnection;
    if ( pcc != NULL )
    {
        hr = THR( pcc->Init() );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pcc->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pcc->Release();
    }
    else
    {
        hr = THR( E_OUTOFMEMORY );
    }

    HRETURN( hr );

} //*** CConfigurationConnection::S_HrCreateInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigurationConnection::CConfigurationConnection( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CConfigurationConnection::CConfigurationConnection( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CConfigurationConnection::CConfigurationConnection()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::Init( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef();    // Add one count

    //  IConfigurationConnection
    Assert( m_cookieGITServer == 0 );
    Assert( m_cookieGITVerify == 0 );
    Assert( m_cookieGITCallbackTask == 0 );
    Assert( m_pcccb == NULL );
    Assert( m_bstrLocalComputerName == NULL );
    Assert( m_bstrLocalHostname == NULL );
    Assert( m_hrLastStatus == S_OK );
    Assert( m_bstrBindingString == NULL );

    //
    //  Figure out the local computer name.
    //
    hr = THR( HrGetComputerName( ComputerNameDnsFullyQualified, &m_bstrLocalComputerName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrGetComputerName( ComputerNameDnsHostname, &m_bstrLocalHostname ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CConfigurationConnection::Init()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigurationConnection::~CConfigurationConnection( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CConfigurationConnection::~CConfigurationConnection( void )
{
    TraceFunc( "" );

    TraceSysFreeString( m_bstrLocalComputerName );

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    }

    if ( m_pgit != NULL )
    {
        if ( m_cookieGITServer != 0 )
        {
            THR( m_pgit->RevokeInterfaceFromGlobal( m_cookieGITServer ) );
        }

        if ( m_cookieGITVerify != 0 )
        {
            THR( m_pgit->RevokeInterfaceFromGlobal( m_cookieGITVerify ) );
        }

        if ( m_cookieGITCallbackTask != 0 )
        {
            THR( HrStopPolling() );
        } // if:

        m_pgit->Release();
    }

    TraceSysFreeString( m_bstrBindingString );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CConfigurationConnection::~CConfigurationConnection()


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::QueryInterface(
//      REFIID      riidIn,
//      LPVOID *    ppvOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IConfigurationConnection * >( this );
        hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IConfigurationConnection ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IConfigurationConnection, this, 0 );
        hr = S_OK;
    } // else if: IConfigurationConnection
    else if ( IsEqualIID( riidIn, IID_IClusCfgServer ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgServer, this, 0 );
        hr = S_OK;
    } // else if: IClusCfgServer
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
        hr = S_OK;
    } // else if: IClusCfgCallback
    else if ( IsEqualIID( riidIn, IID_IClusCfgCapabilities ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCapabilities, this, 0 );
        hr = S_OK;
    } // else if: IClusCfgCapabilities
    else if ( IsEqualIID( riidIn, IID_IClusCfgVerify ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgVerify, this, 0 );
        hr = S_OK;
    } // else if: IClusCfgVerify

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CConfigurationConnection::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CConfigurationConnection::AddRef( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CConfigurationConnection::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CConfigurationConnection::AddRef()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CConfigurationConnection::Release( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CConfigurationConnection::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    RETURN( cRef );

} //*** CConfigurationConnection::Release()


//****************************************************************************
//
//  IConfigurationConnection
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::ConnectTo(
//      OBJECTCOOKIE    cookieIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::ConnectTo(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc( "[IConfigurationConnection]" );

    //
    //  VARIABLES
    //

    HRESULT hr;

    LCID    lcid;
    bool    fConnectingToNode;

    COSERVERINFO serverinfo;
    MULTI_QI     mqi;

    CLSID           clsidType;
    CLSID           clsidMinorId;
    const CLSID *   pclsidMajor;
    const CLSID *   pclsidMinor;

    IServiceProvider *  psp;
    IClusCfgCallback *  pcccb;  // don't free!
    ITaskManager *      ptm   = NULL;

    BSTR    bstrName = NULL;
    BSTR    bstrDescription = NULL;

    IUnknown *                          punk = NULL;
    IObjectManager *                    pom = NULL;
    IStandardInfo *                     psi = NULL;
    IClusCfgInitialize *                pcci = NULL;
    IClusCfgServer *                    pccs = NULL;
    IClusCfgPollingCallbackInfo *       pccpcbi = NULL;
    IClusCfgVerify *                    pccv = NULL;

    //
    //  Retrieve the managers needs for the task ahead.
    //

    hr = THR( CoCreateInstance( CLSID_StdGlobalInterfaceTable,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IGlobalInterfaceTable,
                                reinterpret_cast< void ** >( &m_pgit )
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_TaskManager, ITaskManager, &ptm ) );
    if ( FAILED( hr ) )
    {
        psp->Release();        //   release promptly
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager, IObjectManager, &pom ) );
    psp->Release();        // release promptly
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Figure out our locale.
    //
    lcid = GetUserDefaultLCID();
    Assert( lcid != 0 );    // What do we do if it is zero?

    //
    //  Get the name of the node to contact.
    //

    hr = THR( pom->GetObject( DFGUID_StandardInfo, cookieIn, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    psi = TraceInterface( L"ConfigConnection!IStandardInfo", IStandardInfo, psi, 1 );

    hr = THR( psi->GetName( &bstrName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    LogMsg( L"[MT] The name to connect to is '%ws'.", bstrName );

    TraceMemoryAddBSTR( bstrName );

    hr = THR( psi->GetType( &clsidType ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Figure out where to logging information in the UI.
    //

    if ( IsEqualIID( clsidType, CLSID_NodeType ) )
    {
        fConnectingToNode = true;
        pclsidMajor = &TASKID_Major_Establish_Connection;
    }
    else if ( IsEqualIID( clsidType, CLSID_ClusterConfigurationType ) )
    {
        fConnectingToNode = false;
        pclsidMajor = &TASKID_Major_Checking_For_Existing_Cluster;
    }
    else
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //
    //  If the connection is to the local machine, then invoke the server INPROC
    //

    hr = STHR( HrIsLocalComputer( bstrName ) );
    if ( hr == S_OK )
    {
        LogMsg( L"[MT] Requesting a local connection to '%ws'.", bstrName );

        //
        //  Requesting connection to local computer.
        //

        hr = THR( CoCreateInstance( CLSID_ClusCfgServer,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IClusCfgServer,
                                    reinterpret_cast< void ** >( &pccs )
                                    ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        //  Store the connection. Don't ref again... but we'll track it with a
        //  ref count of one.
        //
        pccs = TraceInterface( L"ClusCfgServer!Proxy", IClusCfgServer, pccs, 1 );

        //
        //  Save it away to be used next time. Do this using the GlobalInterfaceTable.
        //

        hr = THR( m_pgit->RegisterInterfaceInGlobal( pccs,
                                                     IID_IClusCfgServer,
                                                     &m_cookieGITServer
                                                     ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( pccs->TypeSafeQI( IClusCfgVerify, &pccv ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        pccv = TraceInterface( L"ClusCfgServer!Proxy", IClusCfgVerify, pccv, 1 );

        //
        //  Save it away to be used next time. Do this using the GlobalInterfaceTable.
        //

        hr = THR( m_pgit->RegisterInterfaceInGlobal( pccv,
                                                     IID_IClusCfgVerify,
                                                     &m_cookieGITVerify
                                                     ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //  Track our IClusCfgCallback interface separately - this is a NOP in retail.
        pcccb = TraceInterface( L"CConfigurationConnection!Server", IClusCfgCallback, this, 0 );

        TraceSysFreeString( m_bstrBindingString );
        m_bstrBindingString = NULL;

    }
    else
    {
        LogMsg( L"[MT] Requesting a remote connection to '%ws'.", bstrName );

        //
        //  Create a binding context for the remote server.
        //

        TraceSysFreeString( m_bstrBindingString );
        m_bstrBindingString = NULL;

        hr = STHR( HrCreateBinding( this, pclsidMajor, bstrName, &m_bstrBindingString ) );
        if ( FAILED( hr ) )
        {
            hr = HR_S_RPC_S_SERVER_UNAVAILABLE;
            goto Cleanup;
        }

        //
        //  Report this connection request.
        //
        
        if ( fConnectingToNode )
        {
            //
            //  Add in the major task in case it hasn't been added yet.
            //

            hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_REMOTE_CONNECTION_REQUESTS, &bstrDescription ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            hr = THR( SendStatusReport(
                          m_bstrLocalHostname
                        , TASKID_Major_Establish_Connection
                        , TASKID_Minor_Remote_Node_Connection_Requests
                        , 0
                        , 1
                        , 1
                        , S_OK
                        , bstrDescription
                        , NULL
                        , NULL
                        ) );

            //
            //  Add the specific minor task instance.
            //  Generate a new GUID for this report so that it won't wipe out
            //  any other reports like this.
            //

            hr = THR( CoCreateGuid( &clsidMinorId ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            pclsidMajor = &TASKID_Minor_Remote_Node_Connection_Requests;
            pclsidMinor = &clsidMinorId;

        } // if: connecting to a node
        else
        {
            pclsidMajor = &TASKID_Major_Checking_For_Existing_Cluster;
            pclsidMinor = &TASKID_Minor_Requesting_Remote_Connection;

        } // else: connecting to a cluster

        hr = THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_REQUESTING_REMOTE_CONNECTION, &bstrDescription, bstrName, m_bstrBindingString ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( SendStatusReport(
                      m_bstrLocalHostname
                    , *pclsidMajor
                    , *pclsidMinor
                    , 0
                    , 1
                    , 1
                    , S_OK
                    , bstrDescription
                    , NULL
                    , NULL
                    ) );

        //
        // KB: 08-DEC-2000 DavidP
        //      Workaround for IP address caching bug in COM.
        //

        {
            DWORD   sc;
            DWORD   dwClusterState;

            sc = GetNodeClusterState( m_bstrBindingString, &dwClusterState );
            if (    ( sc == RPC_S_SERVER_UNAVAILABLE )
                ||  ( sc == ERROR_BAD_NETPATH )
                ||  ( sc == RPC_S_INVALID_NET_ADDR ) )
            {
                //
                // Make the error into a success and update the status.
                // Translate both codes to the same success code so that
                // we don't have to propogate handling of several errors
                // to all parts of the code.
                //
                hr = HR_S_RPC_S_SERVER_UNAVAILABLE;
                goto Cleanup;
            }
            else if ( sc != ERROR_SUCCESS )
            {
                hr = HRESULT_FROM_WIN32( TW32( sc ) );
                goto Cleanup;
            }

            //
            //  BUGBUG: GalenB  20-FEB-2001
            //
            //  If we know the node is down why should we try to connect to it?
            //
        }

        //
        //  Create the connection to the node.
        //

        ZeroMemory( &serverinfo, sizeof( serverinfo ) );
        ZeroMemory( &mqi, sizeof( mqi ) );

        serverinfo.pwszName = m_bstrBindingString;

        mqi.pIID = &IID_IClusCfgVerify;

        //  don't wrap - this can fail.
        hr = CoCreateInstanceEx( CLSID_ClusCfgServer,
                                 NULL,
                                 CLSCTX_REMOTE_SERVER,
                                 &serverinfo,
                                 1,
                                 &mqi
                                 );
        if ( hr == HRESULT_FROM_WIN32( RPC_S_SERVER_UNAVAILABLE ) )
        {
            LogMsg( L"[MT] Connection to '%ws' with binding string '%ws' failed because the RPC is not available.", bstrName, m_bstrBindingString );
            //
            //  Make the error into a success and update the status.
            //
            hr = HR_S_RPC_S_SERVER_UNAVAILABLE;
            goto Cleanup;
        }
        else if( hr == HRESULT_FROM_WIN32( REGDB_E_CLASSNOTREG ) )
        {
            LogMsg( L"[MT] Connection to '%ws' with binding string '%ws' failed because one or more classes are not registered.", bstrName, m_bstrBindingString );
            // Known error.  It must be a downlevel node.
            goto Cleanup;
        }
        else if ( FAILED( hr ) )
        {
            LogMsg( L"[MT] Connection to '%ws' with binding string '%ws' failed. (hr=%#08x)", bstrName, m_bstrBindingString, hr );
            THR( hr );
            goto Cleanup;
        }

        if ( FAILED( mqi.hr ) )
        {
            hr = THR( mqi.hr );
            goto Cleanup;
        } // if: qi failed

        //
        //  Store the connection. Don't ref again... but we'll track it with a
        //  ref count of one.
        //
        pccv = TraceInterface( L"ClusCfgServer!Proxy", IClusCfgVerify, reinterpret_cast< IClusCfgVerify * >( mqi.pItf ), 1 );

        //
        //  Save it away to be used next time. Do this using the GlobalInterfaceTable.
        //

        hr = THR( m_pgit->RegisterInterfaceInGlobal( pccv,
                                                     IID_IClusCfgVerify,
                                                     &m_cookieGITVerify
                                                     ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        //  Verify our connection.
        //

        if ( fConnectingToNode )
        {
            hr = THR( pccv->VerifyConnectionToNode( bstrName ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        }
        else
        {
            hr = THR( pccv->VerifyConnectionToCluster( bstrName ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        }

        if ( hr == S_FALSE )
        {
            hr = THR( HRESULT_FROM_WIN32( ERROR_CONNECTION_REFUSED ) );
            goto Cleanup;
        }

        hr = THR( pccv->TypeSafeQI( IClusCfgServer, &pccs ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        //  Store the connection. Don't ref again... but we'll track it with a
        //  ref count of one.
        //
        pccs = TraceInterface( L"ClusCfgServer!Proxy", IClusCfgServer, pccs, 1 );

// commented out by GalenB since this is investigative code.
//        hr = THR( HrSetSecurityBlanket( pccs ) );
//        if ( FAILED( hr ) )
//            goto Cleanup;

        hr = THR( pccs->SetBindingString( m_bstrBindingString ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        //  Save it away to be used next time. Do this using the GlobalInterfaceTable.
        //

        hr = THR( m_pgit->RegisterInterfaceInGlobal( pccs,
                                                     IID_IClusCfgServer,
                                                     &m_cookieGITServer
                                                     ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        pcccb = NULL;   // we're polling.

        hr = THR( pccs->TypeSafeQI( IClusCfgPollingCallbackInfo, &pccpcbi ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( pccpcbi->SetPollingMode( true ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( HrStartPolling() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

    } // else: run server remotely

    //
    //  Initialize the server.
    //
    hr = THR( pccs->TypeSafeQI( IClusCfgInitialize, &pcci ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = pcci->Initialize( pcccb, lcid );
    if ( FAILED( hr ) )
    {
        THR( hr );
        goto Cleanup;
    }
    else if ( hr == HR_S_RPC_S_CLUSTER_NODE_DOWN )
    {
        LogMsg( L"[MT] The cluster service on node '%ws' is down.", bstrName );
    } // else if:
    else
    {
        THR( hr );
    } // else:

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pccpcbi != NULL )
    {
        pccpcbi->Release();
    } // if: pccpcbi
    if ( pom != NULL )
    {
        pom->Release();
    } // if: pom
    if ( ptm != NULL )
    {
        ptm->Release();
    } //if: ptm
    if ( psi != NULL )
    {
        psi->Release();
    } // if: psi
    if ( pcci != NULL )
    {
        pcci->Release();
    } // if: pcci

    TraceSysFreeString( bstrName );
    TraceSysFreeString( bstrDescription );

    if ( pccs != NULL )
    {
        pccs->Release();
    }
    if ( pccv != NULL )
    {
        pccv->Release();
    }

    m_hrLastStatus = hr;

    HRETURN( hr );

} //*** CConfigurationConnection::ConnectTo()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::ConnectToObject(
//      OBJECTCOOKIE    cookieIn,
//      REFIID          riidIn,
//      LPUNKNOWN *     ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::ConnectToObject(
    OBJECTCOOKIE    cookieIn,
    REFIID          riidIn,
    LPUNKNOWN *     ppunkOut
    )
{
    TraceFunc( "[IConfigurationConnection]" );

    HRESULT hr;
    CLSID   clsid;

    IServiceProvider *  psp;

    IUnknown *       punk = NULL;
    IObjectManager * pom  = NULL;
    IStandardInfo *  psi  = NULL;

    //
    //  Retrieve the managers needs for the task ahead.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( psp->QueryService( CLSID_ObjectManager,
                                 TypeSafeParams( IObjectManager, &pom )
                                 ) );
    psp->Release();    // release promptly
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Retrieve the type of the object.
    //

    hr = THR( pom->GetObject( DFGUID_StandardInfo,
                              cookieIn,
                              &punk
                              ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    psi = TraceInterface( L"ConfigConnection!IStandardInfo", IStandardInfo, psi, 1 );

    hr = THR( psi->GetType( &clsid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( !IsEqualIID( clsid, CLSID_NodeType ) )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //
    //  Return the requested interface.
    //

    hr = THR( QueryInterface( riidIn, reinterpret_cast< void ** > ( ppunkOut ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pom != NULL )
    {
        pom->Release();
    } // if: pom

    if ( psi != NULL )
    {
        psi->Release();
    } // if: psi

    HRETURN( hr );

} //*** CConfigurationConnection::ConnectToObject()


//****************************************************************************
//
//  IClusCfgServer
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::GetClusterNodeInfo(
//      IClusCfgNodeInfo ** ppClusterNodeInfoOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::GetClusterNodeInfo(
    IClusCfgNodeInfo ** ppClusterNodeInfoOut
    )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr;

    IClusCfgServer *        pccs = NULL;

    if ( m_pgit == NULL )
    {
        hr = THR( m_hrLastStatus );
        goto Cleanup;
    }

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieGITServer, TypeSafeParams( IClusCfgServer, &pccs ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccs->GetClusterNodeInfo( ppClusterNodeInfoOut ) );

Cleanup:

    if ( pccs != NULL )
    {
        pccs->Release();
    }

    HRETURN( hr );

} //*** CConfigurationConnection::GetClusterNodeInfo()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::GetManagedResourcesEnum(
//      IEnumClusCfgManagedResources ** ppEnumManagedResourcesOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::GetManagedResourcesEnum(
    IEnumClusCfgManagedResources ** ppEnumManagedResourcesOut
    )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr;

    IClusCfgServer *        pccs = NULL;

    if ( m_pgit == NULL )
    {
        hr = THR( m_hrLastStatus );
        goto Cleanup;
    }

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieGITServer, TypeSafeParams( IClusCfgServer, &pccs ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccs->GetManagedResourcesEnum( ppEnumManagedResourcesOut ) );

Cleanup:

    if ( pccs != NULL )
    {
        pccs->Release();
    }

    HRETURN( hr );

} //*** CConfigurationConnection::GetManagedResourcesEnum()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::GetNetworksEnum(
//      IEnumClusCfgNetworks ** ppEnumNetworksOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::GetNetworksEnum(
    IEnumClusCfgNetworks ** ppEnumNetworksOut
    )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr;

    IClusCfgServer *    pccs = NULL;

    if ( m_pgit == NULL )
    {
        hr = THR( m_hrLastStatus );
        goto Cleanup;
    }

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieGITServer, TypeSafeParams( IClusCfgServer, &pccs ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccs->GetNetworksEnum( ppEnumNetworksOut ) );

Cleanup:

    if ( pccs != NULL )
    {
        pccs->Release();
    }

    HRETURN( hr );

} //*** CConfigurationConnection::GetNetworksEnum()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::CommitChanges( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::CommitChanges( void )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr;

    IClusCfgServer *    pccs = NULL;

    if ( m_pgit == NULL )
    {
        hr = THR( m_hrLastStatus );
        goto Cleanup;
    }

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieGITServer, TypeSafeParams( IClusCfgServer, &pccs ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccs->CommitChanges(  ) );

Cleanup:

    if ( pccs != NULL )
    {
        pccs->Release();
    }

    HRETURN( hr );

} //*** CConfigurationConnection::CommitChanges()


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CConfigurationConnection::GetBindingString(
//      BSTR * pbstrBindingOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::GetBindingString(
    BSTR * pbstrBindingStringOut
    )
{
    TraceFunc1( "[IClusCfgServer] pbstrBindingStringOut = %p", pbstrBindingStringOut );

    HRESULT hr = S_FALSE;

    if ( pbstrBindingStringOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //  If local server, then there isn't a binding context.
    if ( m_bstrBindingString == NULL )
    {
        Assert( hr == S_FALSE );
        goto Cleanup;
    }

    *pbstrBindingStringOut = SysAllocString( m_bstrBindingString );
    if ( *pbstrBindingStringOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    HRETURN( hr );

} // CConfigurationConnection::GetBinding()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::SetBindingString(
//      LPCWSTR pcszBindingStringIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::SetBindingString(
    LPCWSTR pcszBindingStringIn
    )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    if ( pcszBindingStringIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pcszBindingStringIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrBindingString );
    m_bstrBindingString = bstr;

Cleanup:

    HRETURN( hr );

} //*** CConfigurationConnection::SetBindingString()


//****************************************************************************
//
//  IClusCfgVerify
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::VerifyCredentials(
//      LPCWSTR pcszUserIn,
//      LPCWSTR pcszDomainIn,
//      LPCWSTR pcszPasswordIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::VerifyCredentials(
    LPCWSTR pcszUserIn,
    LPCWSTR pcszDomainIn,
    LPCWSTR pcszPasswordIn
    )
{
    TraceFunc( "[IClusCfgVerify]" );

    HRESULT             hr;
    IClusCfgVerify *    pccv = NULL;

    if ( m_pgit == NULL )
    {
        hr = THR( m_hrLastStatus );
        goto Cleanup;
    }

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieGITVerify, TypeSafeParams( IClusCfgVerify, &pccv ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccv->VerifyCredentials( pcszUserIn, pcszDomainIn, pcszPasswordIn ) );

Cleanup:

    if ( pccv != NULL )
    {
        pccv->Release();
    }

    HRETURN( hr );

} //*** CConfigurationConnection::VerifyCredentials()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::VerifyConnectionToCluster(
//      LPCWSTR pcszClusterNameIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::VerifyConnectionToCluster(
    LPCWSTR pcszClusterNameIn
    )
{
    TraceFunc1( "[IClusCfgVerify] pcszClusterNameIn = '%ws'", pcszClusterNameIn );

    HRESULT             hr;
    IClusCfgVerify *    pccv = NULL;

    if ( m_pgit == NULL )
    {
        hr = THR( m_hrLastStatus );
        goto Cleanup;
    }

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieGITVerify, TypeSafeParams( IClusCfgVerify, &pccv ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccv->VerifyConnectionToCluster( pcszClusterNameIn ) );

Cleanup:

    if ( pccv != NULL )
    {
        pccv->Release();
    }

    HRETURN( hr );

} //*** CConfigurationConnection::VerifyConnection()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::VerifyConnectionToNode(
//      LPCWSTR pcszNodeNameIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::VerifyConnectionToNode(
    LPCWSTR pcszNodeNameIn
    )
{
    TraceFunc1( "[IClusCfgVerify] pcszNodeNameIn = '%ws'", pcszNodeNameIn );

    HRESULT             hr;
    IClusCfgVerify *    pccv = NULL;

    if ( m_pgit == NULL )
    {
        hr = THR( m_hrLastStatus );
        goto Cleanup;
    }

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieGITVerify, TypeSafeParams( IClusCfgVerify, &pccv ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccv->VerifyConnectionToNode( pcszNodeNameIn ) );

Cleanup:

    if ( pccv != NULL )
    {
        pccv->Release();
    }

    HRETURN( hr );

} //*** CConfigurationConnection::VerifyConnection()


//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::SendStatusReport(
//        LPCWSTR     pcszNodeNameIn
//      , CLSID       clsidTaskMajorIn
//      , CLSID       clsidTaskMinorIn
//      , ULONG       ulMinIn
//      , ULONG       ulMaxIn
//      , ULONG       ulCurrentIn
//      , HRESULT     hrStatusIn
//      , LPCWSTR     ocszDescriptionIn
//      , FILETIME *  pftTimeIn
//      , LPCWSTR     pcszReferenceIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::SendStatusReport(
      LPCWSTR     pcszNodeNameIn
    , CLSID       clsidTaskMajorIn
    , CLSID       clsidTaskMinorIn
    , ULONG       ulMinIn
    , ULONG       ulMaxIn
    , ULONG       ulCurrentIn
    , HRESULT     hrStatusIn
    , LPCWSTR     ocszDescriptionIn
    , FILETIME *  pftTimeIn
    , LPCWSTR     pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT hr = S_OK;

    IServiceProvider *          psp   = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    FILETIME                    ft;

    if ( m_pcccb == NULL )
    {
        //
        //  Collect the manager we need to complete this task.
        //

        hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    TypeSafeParams( IServiceProvider, &psp )
                                    ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( psp->TypeSafeQS( CLSID_NotificationManager,
                                   IConnectionPointContainer,
                                   &pcpc
                                   ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        pcp = TraceInterface( L"CConfigurationConnection!IConnectionPoint", IConnectionPoint, pcp, 1 );

        hr = THR( pcp->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        m_pcccb = TraceInterface( L"CConfigurationConnection!IClusCfgCallback", IClusCfgCallback, m_pcccb, 1 );

        psp->Release();
        psp = NULL;
    }

    if ( pftTimeIn == NULL )
    {
        GetSystemTimeAsFileTime( &ft );
        pftTimeIn = &ft;
    } // if:

    //
    //  Send the message!
    //

    hr = THR( m_pcccb->SendStatusReport( pcszNodeNameIn,
                                         clsidTaskMajorIn,
                                         clsidTaskMinorIn,
                                         ulMinIn,
                                         ulMaxIn,
                                         ulCurrentIn,
                                         hrStatusIn,
                                         ocszDescriptionIn,
                                         pftTimeIn,
                                         pcszReferenceIn
                                         ) );

Cleanup:

    if ( psp != NULL )
    {
        psp->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }

    HRETURN( hr );

}  //*** CConfigurationConnection::SendStatusReport()


//****************************************************************************
//
//  IClusCfgCapabilities
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CConfigurationConnection::CanNodeBeClustered( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigurationConnection::CanNodeBeClustered( void )
{
    TraceFunc( "[IClusCfgCapabilities]" );

    HRESULT hr;

    IClusCfgServer *        pccs = NULL;
    IClusCfgCapabilities *  pccc = NULL;

    if ( m_pgit == NULL )
    {
        hr = THR( m_hrLastStatus );
        goto Cleanup;
    }

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieGITServer, TypeSafeParams( IClusCfgServer, &pccs ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccs->TypeSafeQI( IClusCfgCapabilities, &pccc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = STHR( pccc->CanNodeBeClustered(  ) );

Cleanup:

    if ( pccc != NULL )
    {
        pccc->Release();
    }

    if ( pccs != NULL )
    {
        pccs->Release();
    }

    HRETURN( hr );

} //*** CConfigurationConnection::CanNodeBeClustered()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CConfigurationConnection::HrStartPolling( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConfigurationConnection::HrStartPolling( void )
{
    TraceFunc( "" );

    HRESULT                 hr;
    IServiceProvider *      psp   = NULL;
    IUnknown *              punk  = NULL;
    ITaskManager *          ptm   = NULL;
    ITaskPollingCallback *  ptpcb = NULL;

    hr = THR( CoCreateInstance( CLSID_ServiceManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( IServiceProvider, &psp ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_TaskManager, ITaskManager, &ptm ) );
    if ( FAILED( hr ) )
    {
        psp->Release();        //   release promptly
        goto Cleanup;
    }

    //
    //  Create the task object.
    //

    hr = THR( ptm->CreateTask( TASK_PollingCallback, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( ITaskPollingCallback, &ptpcb ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Save it away to be used next time. Do this using the GlobalInterfaceTable.
    //

    hr = THR( m_pgit->RegisterInterfaceInGlobal( ptpcb, IID_ITaskPollingCallback, &m_cookieGITCallbackTask ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ptpcb->SetServerGITCookie( m_cookieGITServer ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ptm->SubmitTask( ptpcb ) );

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    }

    if ( psp != NULL )
    {
        psp->Release();
    } // if:

    if ( ptm != NULL )
    {
        ptm->Release();
    } // if:

    if ( ptpcb != NULL )
    {
        ptpcb->Release();
    } // if:

    HRETURN( hr );

} //*** CConfigurationConnection::HrStartPolling()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CConfigurationConnection::HrStopPolling( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConfigurationConnection::HrStopPolling( void )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    ITaskPollingCallback *  ptpcb = NULL;

    hr = THR( m_pgit->GetInterfaceFromGlobal( m_cookieGITCallbackTask, TypeSafeParams( ITaskPollingCallback, &ptpcb ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ptpcb->StopTask() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pgit->RevokeInterfaceFromGlobal( m_cookieGITCallbackTask ) );

Cleanup:

    if ( ptpcb != NULL )
    {
        ptpcb->Release();
    } // if:

    HRETURN( hr );

} //*** CConfigurationConnection::HrStopPolling()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CConfigurationConnection::HrSetSecurityBlanket( IClusCfgServer * pccsIn )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConfigurationConnection::HrSetSecurityBlanket( IClusCfgServer * pccsIn )
{
    TraceFunc( "" );
    Assert( pccsIn != NULL );

    HRESULT             hr = S_FALSE;
    IClientSecurity *   pCliSec;

    hr = THR( pccsIn->TypeSafeQI( IClientSecurity, &pCliSec ) );
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( pCliSec->SetBlanket(
                        pccsIn,
                        RPC_C_AUTHN_WINNT,
                        RPC_C_AUTHZ_NONE,
                        NULL,
                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                        RPC_C_IMP_LEVEL_IMPERSONATE,
                        NULL,
                        EOAC_NONE
                        ) );

        pCliSec->Release();

        if ( FAILED( hr ) )
        {
            LogMsg( L"[MT] Failed to set the security blanket on the server object. (hr = %#08x)", hr );
        } // if:
    } // if:

    HRETURN( hr );

} //*** CConfigurationConnection::HrSetSecurityBlanket()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CConfigurationConnection::HrIsLocalComputer(
//      LPCWSTR    pcszNameIn
//      )
//
//  Parameters:
//      pcszNameIn
//          FQDN or Hostname name to match against local computer name.
//
//  Return Values:
//      S_OK
//          Succeeded. Name matches local computer name.
//
//      S_FALSE
//          Succeeded. Name does not match local computer name.
//
//      E_INVALIDARG
//          pcszNameIn was NULL.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConfigurationConnection::HrIsLocalComputer(
    LPCWSTR    pcszNameIn
    )
{
    TraceFunc1( "pcszNameIn = '%s'", pcszNameIn );

    HRESULT hr = S_OK;  // assume success!

    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    if ( m_bstrLocalComputerName != NULL )
    {
        if ( _wcsicmp( pcszNameIn, m_bstrLocalComputerName ) == 0 )
        {
            // Found a match.
            goto Cleanup;
        }
    }

    if ( m_bstrLocalHostname != NULL )
    {
        if ( _wcsicmp( pcszNameIn, m_bstrLocalHostname ) == 0 )
        {
            // Found a match
            goto Cleanup;
        }
    }

    if ( _wcsicmp( pcszNameIn, L"." ) == 0 )
    {
        goto Cleanup;
    }

    hr = S_FALSE;   //  didn't match

Cleanup:

    HRETURN( hr );

} //*** CConfigurationConnection::HrIsLocalComputer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\cpinotifyui.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CPINotifyUI.cpp
//
//  Description:
//      INotifyUI Connection Point implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 04-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "CPINotifyUI.h"
#include "EnumCPINotifyUI.h"

DEFINE_THISCLASS("CCPINotifyUI")


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CCPINotifyUI::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCPINotifyUI::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CCPINotifyUI * lpcc = new CCPINotifyUI( );
    if ( lpcc != NULL )
    {
        hr = THR( lpcc->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( lpcc->TypeSafeQI( IUnknown, ppunkOut ) );
        } // if: success

        lpcc->Release( );

    } // if: got object
    else
    {
        hr = E_OUTOFMEMORY;
    } // else: out of memory

    HRETURN( hr );

} // S_HrCreateInstance( )

//
// Constructor
//
CCPINotifyUI::CCPINotifyUI( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CCPINotifyUI( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCPINotifyUI::Init( )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPINotifyUI::Init( )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );  // Add one count

    // IConnectionPoint
    Assert( m_penum == NULL );

    m_penum = new CEnumCPINotifyUI( );
    if ( m_penum == NULL )
        goto OutOfMemory;

    hr = THR( m_penum->Init( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // INotifyUI

Cleanup:
    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // Init( )

//////////////////////////////////////////////////////////////////////////////
//
//  CCPINotifyUI::~CCPINotifyUI( )
//
//////////////////////////////////////////////////////////////////////////////
CCPINotifyUI::~CCPINotifyUI( )
{
    TraceFunc( "" );

    if ( m_penum != NULL )
    {
        m_penum->Release( );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CCPINotifyUI( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCPINotifyUI::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPINotifyUI::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IConnectionPoint * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IConnectionPoint ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IConnectionPoint, this, 0 );
        hr   = S_OK;
    } // else if: IConnectionPoint
    else if ( IsEqualIID( riid, IID_INotifyUI ) )
    {
        *ppv = TraceInterface( __THISCLASS__, INotifyUI, this, 0 );
        hr   = S_OK;
    } // else if: INotifyUI

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} // QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CCPINotifyUI::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CCPINotifyUI::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CCPINotifyUI::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CCPINotifyUI::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release( )


// ************************************************************************
//
// IConnectionPoint
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CCPINotifyUI::GetConnectionInterface(
//      IID * pIIDOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPINotifyUI::GetConnectionInterface(
    IID * pIIDOut
    )
{
    TraceFunc( "[IConnectionPoint] pIIDOut" );

    HRESULT hr = S_OK;

    if ( pIIDOut == NULL )
        goto InvalidPointer;

    *pIIDOut = IID_INotifyUI;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} // GetConnectionInterface( )

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CCPINotifyUI::GetConnectionPointContainer(
//      IConnectionPointContainer * * ppcpcOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPINotifyUI::GetConnectionPointContainer(
    IConnectionPointContainer * * ppcpcOut
    )
{
    TraceFunc( "[IConnectionPoint] ppcpcOut" );

    HRESULT hr;

    IServiceProvider * psp = NULL;

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager,
                               IConnectionPointContainer,
                               ppcpcOut
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( psp != NULL )
    {
        psp->Release( );
    }

    HRETURN( hr );

} // GetConnectionPointContainer( )

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CCPINotifyUI::Advise(
//      IUnknown * pUnkSinkIn,
//      DWORD * pdwCookieOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPINotifyUI::Advise(
    IUnknown * pUnkSinkIn,
    DWORD * pdwCookieOut
    )
{
    TraceFunc( "[IConnectionPoint]" );

    HRESULT hr;

    if ( pdwCookieOut == NULL )
        goto InvalidPointer;

    if ( pUnkSinkIn == NULL )
        goto InvalidArg;

    Assert( m_penum != NULL );

    hr = THR( m_penum->HrAddConnection( pUnkSinkIn, pdwCookieOut ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} // Advise( )

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CCPINotifyUI::Unadvise(
//      DWORD dwCookieIn
//      )
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPINotifyUI::Unadvise(
    DWORD dwCookieIn
    )
{
    TraceFunc1( "[IConncetionPoint] dwCookieIn = %#x", dwCookieIn );

    HRESULT hr;

    Assert( m_penum != NULL );

    hr = THR( m_penum->HrRemoveConnection( dwCookieIn ) );

    HRETURN( hr );

} // Unadvise( )

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CCPINotifyUI::EnumConnections(
//  IEnumConnections * * ppEnumOut
//  )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPINotifyUI::EnumConnections(
    IEnumConnections * * ppEnumOut
    )
{
    TraceFunc( "[IConnectionPoint] ppEnumOut" );

    HRESULT hr;

    if ( ppEnumOut == NULL )
        goto InvalidPointer;

    hr = THR( m_penum->Clone( ppEnumOut ) );

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} // EnumConnections( )


//****************************************************************************
//
//  INotifyUI
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCPINotifyUI::ObjectChanged(
//      OBJECTCOOKIE    cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCPINotifyUI::ObjectChanged(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc1( "[INotifyUI] cookieIn = %#x", cookieIn );

    CONNECTDATA cd = { NULL };

    HRESULT hr;

    INotifyUI * pnui;

    hr = THR( m_penum->Reset( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    for ( ;; )
    {
        if ( cd.pUnk != NULL )
        {
            cd.pUnk->Release( );
            cd.pUnk = NULL;
        }

        hr = STHR( m_penum->Next( 1, &cd, NULL ) );
        if ( FAILED( hr ) )
            break;

        if ( hr == S_FALSE )
        {
            hr = S_OK;
            break; // exit condition
        }

        hr = THR( cd.pUnk->TypeSafeQI( INotifyUI, &pnui ) );
        if ( FAILED( hr ) )
            continue;   // ingore the error and continue

        hr = THR( pnui->ObjectChanged( cookieIn ) );
        //  don't care about the error.

        pnui->Release( );
    }

    hr = S_OK;

Cleanup:
    if ( cd.pUnk != NULL )
    {
        cd.pUnk->Release( );
    }

    HRETURN( hr );

} // ObjectChanged( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\enumcookies.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      EnumCookies.cpp
//
//  Description:
//      CEnumCookies implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 08-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "EnumCookies.h"
#include "ObjectManager.h"

DEFINE_THISCLASS("CEnumCookies")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumCookies::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCookies::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CEnumCookies * pemn = new CEnumCookies;
    if ( pemn != NULL )
    {
        hr = THR( pemn->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pemn->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pemn->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumCookies::CEnumCookies( void )
//
//////////////////////////////////////////////////////////////////////////////
CEnumCookies::CEnumCookies( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CEnumCookies( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumCookies::Init( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCookies::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );    // Add one count

    // IEnumCookies
    Assert( m_cIter == 0 );
    Assert( m_pList == NULL );
    Assert( m_cCookies == 0 );

    HRETURN( hr );

} // Init( )

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumCookies::~CEnumCookies( )
//
//////////////////////////////////////////////////////////////////////////////
CEnumCookies::~CEnumCookies( )
{
    TraceFunc( "" );

    if ( m_pList != NULL )
    {
        TraceFree( m_pList );

    } // if: m_pList

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CEnumCookies( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumCookies::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCookies::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IEnumCookies * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IEnumCookies ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumCookies, this, 0 );
        hr   = S_OK;
    } // else if: IEnumCookies

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} // QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumCookies::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumCookies::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumCookies::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumCookies::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release( )


//****************************************************************************
//
//  IEnumCookies
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CEnumCookies::Next( 
//      ULONG celt, 
//      IClusCfgNetworkInfo * rgNetworksOut[],
//      ULONG * pceltFetchedOut 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CEnumCookies::Next( 
    ULONG celt, 
    OBJECTCOOKIE rgcookieOut[], 
    ULONG * pceltFetchedOut 
    )
{
    TraceFunc( "[IEnumCookies]" );

    HRESULT hr = S_OK;
    ULONG   cIter;

    //
    //  Check parameters
    //
    if ( rgcookieOut == NULL )
        goto InvalidPointer;

    //
    //  Loop and coping/addreffing the pccni.
    //
    for( cIter = 0 ; m_cIter < m_cAlloced && cIter < celt ; cIter ++ )
    {
        rgcookieOut[ cIter ] = m_pList[ m_cIter ];

        //  Increment the class iter.
        m_cIter++;

    } // for: m_cIter && cIter

    Assert( hr == S_OK );

    if ( cIter != celt )
    {
        hr = S_FALSE;
    }

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = cIter;
    }

Cleanup:    
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} // Next( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CEnumCookies::Skip( 
//      ULONG celt 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CEnumCookies::Skip( 
    ULONG celt 
    )
{
    TraceFunc( "[IEnumCookies]" );

    HRESULT hr = S_OK;

    m_cIter += celt;

    if ( m_cIter >= m_cAlloced )
    {
        m_cIter = m_cAlloced;
        hr = S_FALSE;
    }

    HRETURN( hr );

} // Skip( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CEnumCookies::Reset( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CEnumCookies::Reset( void )
{
    TraceFunc( "[IEnumCookies]" );

    HRESULT hr = S_OK;

    m_cIter = 0;

    HRETURN( hr );

} // Reset( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CEnumCookies::Clone( 
//      IEnumCookies ** ppenumOut 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CEnumCookies::Clone( 
    IEnumCookies ** ppenumOut 
    )
{
    TraceFunc( "[IEnumCookies]" );

    //
    //  KB: not going to implement this method.
    //
    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} // Clone( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumCookies::Count(
//      DWORD * pnCountOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCookies::Count(
    DWORD * pnCountOut
    )
{
    TraceFunc( "[IEnumCookies]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pnCountOut = m_cCookies;

Cleanup:
    HRETURN( hr );
}// Count( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\cpinotifyui.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CPINotifyUI.h
//
//  Description:
//      INotifyUI Connection Point implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 04-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CEnumCPINotifyUI;

// CCPINotifyUI
class 
CCPINotifyUI:
    public IConnectionPoint,
    public INotifyUI
{
private:
    // IUnknown
    LONG                m_cRef;     //  Reference count

    // IConnectionPoint
    CEnumCPINotifyUI *  m_penum;    //  Connection enumerator

    // INotifyUI

private: // Methods
    CCPINotifyUI( );
    ~CCPINotifyUI();
    STDMETHOD(Init)( );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )(void);
    STDMETHOD_( ULONG, Release )(void);

    // IConnectionPoint
    STDMETHOD( GetConnectionInterface )( IID * pIIDOut );        
    STDMETHOD( GetConnectionPointContainer )( IConnectionPointContainer * * ppcpcOut );        
    STDMETHOD( Advise )( IUnknown * pUnkSinkIn, DWORD * pdwCookieOut );        
    STDMETHOD( Unadvise )( DWORD dwCookieIn );        
    STDMETHOD( EnumConnections )( IEnumConnections * * ppEnumOut );

    // INotifyUI
    STDMETHOD( ObjectChanged )( OBJECTCOOKIE cookieIn );

}; // class CCPINotifyUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\enumcpicccb.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      EnumCPICCCB.h
//
//  Description:
//      IClusCfgCallback Connection Point Enumerator implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 10-NOV-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CCPINotifyUI;

// CEnumCPICCCB
class 
CEnumCPICCCB:
    public IEnumConnections
{
friend class CCPIClusCfgCallback;
private:
    // IUnknown
    LONG                m_cRef;         //  Reference counter

    // IEnumConnections
    ULONG               m_cAlloced;     //  Alloced number of entries
    ULONG               m_cCurrent;     //  Number of entries currently used
    ULONG               m_cIter;        //  The Iter
    IUnknown * *        m_pList;        //  List of sinks (IUnknown)

    // INotifyUI

private: // Methods
    CEnumCPICCCB( );
    ~CEnumCPICCCB();
    STDMETHOD(Init)( );

    HRESULT
        HrCopy( CEnumCPICCCB * pecpIn );
    HRESULT
        HrAddConnection( IUnknown * punkIn, DWORD * pdwCookieOut );
    HRESULT
        HrRemoveConnection( DWORD dwCookieIn );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )(void);
    STDMETHOD_( ULONG, Release )(void);

    // IEnumConnections
    STDMETHOD( Next )( ULONG cConnectionsIn,
                       LPCONNECTDATA rgcd,
                       ULONG *pcFetchedOut ); 
    STDMETHOD( Skip )( ULONG cConnectionsIn );
    STDMETHOD( Reset )( void );
    STDMETHOD( Clone )( IEnumConnections **ppEnumOut );
        
}; // class CEnumCPICCCB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\enumcpicccb.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      EnumCPICCCB.cpp
//
//  Description:
//      IClusCfgCallback Connection Point Enumerator implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 10-NOV-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "EnumCPICCCB.h"

DEFINE_THISCLASS("CEnumCPICCCB")

#define PUNK_BUFFER_GROW_SIZE   10

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumCPICCCB::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCPICCCB::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CEnumCPICCCB * lpcc = new CEnumCPICCCB( );
    if ( lpcc != NULL )
    {
        hr = THR( lpcc->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( lpcc->TypeSafeQI( IUnknown, ppunkOut ) );
        } // if: success

        lpcc->Release( );

    } // if: got object
    else
    {
        hr = E_OUTOFMEMORY;
    } // else: out of memory

    HRETURN( hr );

} // S_HrCreateInstance( )

//
// Constructor
//
CEnumCPICCCB::CEnumCPICCCB( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CEnumCPICCCB( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumCPICCCB::Init( )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPICCCB::Init( )
{
    TraceFunc( "" );

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );  // Add one count

    // IEnumConnectionPoints
    Assert( m_cAlloced == 0 );
    Assert( m_cCurrent == 0 );
    Assert( m_cIter == 0 );
    Assert( m_pList == NULL );

    // INotifyUI

    HRETURN( S_OK );

} // Init( )

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumCPICCCB::~CEnumCPICCCB( )
//
//////////////////////////////////////////////////////////////////////////////
CEnumCPICCCB::~CEnumCPICCCB( )
{
    TraceFunc( "" );

    if ( m_pList != NULL )
    {
        while( m_cAlloced != 0 )
        {
            IUnknown * punk;

            m_cAlloced --;

            punk = m_pList[ m_cAlloced ];

            AssertMsg( punk == NULL, "Someone didn't Unadvise before releasing the last Ref" );
            if ( punk != NULL )
            {
                punk->Release( );
            }

        } // while: m_cAlloced

        TraceFree( m_pList );
    }

	InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CEnumCPICCCB( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumCPICCCB::QueryInterface( 
//      REFIID riid, 
//      LPVOID *ppv 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPICCCB::QueryInterface( 
    REFIID riid, 
    LPVOID *ppv 
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IEnumConnections * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IEnumConnections ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumConnections, this, 0 );
        hr   = S_OK;
    } // else if: IEnumConnections

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} // QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumCPICCCB::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumCPICCCB::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumCPICCCB::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumCPICCCB::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release( )


// ************************************************************************
//
// IEnumConnectionPoints
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CEnumCPICCCB::Next( 
//      ULONG cConnectionsIn,
//      LPCONNECTIONPOINT *ppCPOut,
//      ULONG *pcFetchedOut 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPICCCB::Next(
    ULONG cConnectionsIn,
    LPCONNECTDATA rgcd,
    ULONG *pcFetchedOut
    )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    ULONG   cIter;

    HRESULT hr = E_UNEXPECTED;

    if ( pcFetchedOut != NULL )
    {
        *pcFetchedOut = 0;
    }

    for( cIter = 0
       ; ( cIter < cConnectionsIn ) && ( m_cIter < m_cCurrent )
       ; m_cIter ++
       )
    {
        IUnknown * punk = m_pList[ m_cIter ];
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IUnknown, &rgcd[ cIter ].pUnk ) );
            if ( FAILED( hr ) )
                goto Error;

            rgcd[ cIter ].pUnk = TraceInterface( L"EnumCPICCCB!IUnknown", IUnknown, rgcd[ cIter ].pUnk, 1 );

            rgcd[ cIter ].dwCookie = m_cIter + 1;

            cIter ++;
        }

    } // for: cIter

    if ( cIter != cConnectionsIn )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    if ( pcFetchedOut != NULL )
    {
        *pcFetchedOut = cIter;
    }

Cleanup:
    HRETURN( hr );

Error:
    while( cIter != 0 )
    {
        cIter --;
        rgcd[ cIter ].pUnk->Release( );
    }
    goto Cleanup;

} // Next( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CEnumCPICCCB::Skip( 
//      ULONG cConnectionsIn 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPICCCB::Skip(
    ULONG cConnectionsIn
    )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    HRESULT hr = S_OK;

    m_cIter += cConnectionsIn;
    if ( m_cIter >= m_cCurrent )
    {
        m_cIter = m_cCurrent;
        hr = S_FALSE;
    }

    HRETURN( hr );

} // Skip( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CEnumCPICCCB::Reset( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPICCCB::Reset( void )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    HRESULT hr = S_OK;

    m_cIter = 0;

    HRETURN( hr );

} // Reset( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CEnumCPICCCB::Clone( 
//      IEnumConnectionPoints **ppEnumOut 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPICCCB::Clone( 
    IEnumConnections **ppEnumOut
    )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    HRESULT hr;

    CEnumCPICCCB * pecp = new CEnumCPICCCB( );
    if ( pecp == NULL )
        goto OutOfMemory;

    hr = THR( pecp->Init( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pecp->HrCopy( this ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pecp->TypeSafeQI( IEnumConnections, ppEnumOut ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    *ppEnumOut = TraceInterface( L"EnumCPICCCB!IEnumConnections", IEnumConnections, *ppEnumOut, 1 );

    pecp->Release( );
    pecp = NULL;

Cleanup:
    if ( pecp != NULL )
    {
        delete pecp;
    }

    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // Clone( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumCPICCCB::HrCopy( 
//      CEnumCPICCCB * pecpIn 
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCPICCCB::HrCopy( 
    CEnumCPICCCB * pecpIn 
    )
{
    TraceFunc( "" );

    HRESULT hr = E_UNEXPECTED;

    ULONG cIter;

    Assert( m_cAlloced == 0 );
    Assert( m_cCurrent == 0 );
    Assert( m_pList == 0 );

    m_pList = (IUnknown**) TraceAlloc( HEAP_ZERO_MEMORY, pecpIn->m_cCurrent * sizeof( IUnknown * ) );
    if ( m_pList == NULL )
        goto OutOfMemory;

    m_cCurrent = m_cAlloced = pecpIn->m_cCurrent;
    m_cIter = 0;

    for( cIter = 0; cIter < pecpIn->m_cCurrent; cIter ++ )
    {
        hr = THR( pecpIn->m_pList[ cIter ]->TypeSafeQI( IUnknown, &m_pList[ cIter ] ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        m_pList[ cIter ] = TraceInterface( L"EnumCPICCCB!IUnknown", IUnknown, m_pList[ cIter ], 1 );
    }

    hr = S_OK;

Cleanup:
    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // HrCopy( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumCPICCCB::HrAddConnection( 
//      INotifyUI * punkIn, 
//      DWORD * pdwCookieOut 
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCPICCCB::HrAddConnection( 
    IUnknown * punkIn, 
    DWORD * pdwCookieOut 
    )
{
    TraceFunc( "" );

    HRESULT hr = E_UNEXPECTED;

    ULONG cIter;

    if ( pdwCookieOut == NULL )
        goto InvalidPointer;

    //
    //  See if there is an openning in the currently allocated list.
    //

    for ( cIter = 0; cIter < m_cCurrent; cIter ++ )
    {
        if ( m_pList[ cIter ] == NULL )
        {
            //
            //  Found an openning... try to use it.
            //

            hr = THR( punkIn->TypeSafeQI( IUnknown, &m_pList[ cIter ] ) );

            m_pList[ cIter ] = TraceInterface( L"CEnumCPICCCB!IUnknown", IUnknown, m_pList[ cIter ], 1 );

            *pdwCookieOut = cIter + 1;

            //  Doesn't matter if it succeeded or fail, exit.
            goto Cleanup;
        }
    }

    if ( m_cCurrent == m_cAlloced )
    {
        IUnknown ** pNewList;

        //
        //  Try making some more space.
        //

        pNewList = (IUnknown **) TraceAlloc( HEAP_ZERO_MEMORY, ( m_cAlloced + PUNK_BUFFER_GROW_SIZE ) * sizeof( IUnknown * ) );
        if ( pNewList == NULL )
            goto OutOfMemory;

        CopyMemory( pNewList, m_pList, m_cCurrent * sizeof( IUnknown * ) );
        TraceFree( m_pList );

        m_pList = pNewList;
        m_cAlloced += PUNK_BUFFER_GROW_SIZE;
    }

    //
    //  Add it to the list.
    //

    hr = THR( punkIn->TypeSafeQI( IUnknown, &m_pList[ m_cCurrent ] ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    m_pList[ m_cCurrent ] = TraceInterface( L"CEnumCPICCCB!IUnknown", IUnknown, m_pList[ m_cCurrent ], 1 );

    m_cCurrent ++;
    *pdwCookieOut = m_cCurrent; // starts at ONE, not ZERO

Cleanup:
    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} // HrAddConnection( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumCPICCCB::HrRemoveConnection( 
//      DWORD dwCookieIn 
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCPICCCB::HrRemoveConnection( 
    DWORD dwCookieIn 
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( dwCookieIn == 0 || dwCookieIn > m_cCurrent )
        goto InvalidArg;

    if ( m_pList[ dwCookieIn - 1 ] == NULL )
        goto InvalidArg;

    m_pList[ dwCookieIn - 1 ]->Release( );
    m_pList[ dwCookieIn - 1 ] = NULL;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} // HrRemoveConnection( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\enumcookies.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      EnumCookies.h
//
//  Description:
//      CEnumCookies implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 08-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CObjectManager;

// CEnumCookies
class
CEnumCookies:
    public IEnumCookies
{
friend class CObjectManager;
private:
    // IUnknown
    LONG                m_cRef;

    // IEnumCookies
    ULONG               m_cAlloced; // Size of the array.
    ULONG               m_cIter;    // Our iter counter.
    OBJECTCOOKIE *      m_pList;    // Array of cookies.
    DWORD               m_cCookies; // Number of array items in use

private: // Methods
    CEnumCookies( );
    ~CEnumCookies();
    STDMETHOD( Init )( void );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IEnumCookies
    STDMETHOD( Next )( ULONG celt, OBJECTCOOKIE rgcookieOut[], ULONG * pceltFetchedOut );
    STDMETHOD( Skip )( ULONG celt );
    STDMETHOD( Reset )( void );
    STDMETHOD( Clone )( IEnumCookies ** ppenumOut );
    STDMETHOD( Count )( DWORD * pnCountOut );

}; // class CEnumCookies
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\enumipaddresses.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      EnumIPAddresses.cpp
//
//  Description:
//      CEnumIPAddress implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 24-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "IPAddressInfo.h"
#include "EnumIPAddresses.h"

DEFINE_THISCLASS("CEnumIPAddresses")


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumIPAddresses::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumIPAddresses::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CEnumIPAddresses * pemn = new CEnumIPAddresses;
    if ( pemn != NULL )
    {
        hr = THR( pemn->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pemn->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pemn->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumIPAddresses::CEnumIPAddresses( void )
//
//////////////////////////////////////////////////////////////////////////////
CEnumIPAddresses::CEnumIPAddresses( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CEnumIPAddresses( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumIPAddresses::Init( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumIPAddresses::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );    // Add one count

    // IEnumClusCfgIPAddresses

    HRETURN( hr );

} // Init( )

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumIPAddresses::~CEnumIPAddresses( )
//
//////////////////////////////////////////////////////////////////////////////
CEnumIPAddresses::~CEnumIPAddresses( )
{
    TraceFunc( "" );

    if ( m_pList != NULL )
    {
        while ( m_cAlloced != 0 )
        {
            m_cAlloced --;
            (m_pList[ m_cAlloced ])->Release( );
        }
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CEnumIPAddresses( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumIPAddresses::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumIPAddresses::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IEnumClusCfgIPAddresses * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IEnumClusCfgIPAddresses ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumClusCfgIPAddresses, this, 0 );
        hr   = S_OK;
    } // else if: IEnumClusCfgIPAddresses
    else if ( IsEqualIID( riid, IID_IExtendObjectManager ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IExtendObjectManager, this, 0 );
        hr   = S_OK;
    } // else if: IExtendObjectManager

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} // QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumIPAddresses::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumIPAddresses::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumIPAddresses::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumIPAddresses::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release( )


// ************************************************************************
//
//  IExtendObjectManager
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CEnumIPAddresses::FindObject(
//        OBJECTCOOKIE    cookieIn
//      , REFCLSID        rclsidTypeIn
//      , LPCWSTR         pcszNameIn
//      , LPUNKNOWN *     punkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumIPAddresses::FindObject(
      OBJECTCOOKIE  cookieIn
    , REFCLSID      rclsidTypeIn
    , LPCWSTR       pcszNameIn
    , LPUNKNOWN *   ppunkOut
    )
{
    TraceFunc( "[IExtendObjectManager]" );

    OBJECTCOOKIE    cookie;
    OBJECTCOOKIE    cookieParent;

    IServiceProvider * psp;

    HRESULT hr = E_UNEXPECTED;

    IObjectManager * pom  = NULL;
    IStandardInfo *  psi  = NULL;
    IEnumCookies *   pec  = NULL;

    DWORD   cookieCount = 0;

    //
    //  Check arguments
    //

    if ( cookieIn == 0 )
        goto InvalidArg;

    if ( rclsidTypeIn != CLSID_IPAddressType )
        goto InvalidType;

    if ( ppunkOut == NULL )
        goto InvalidPointer;

    AssertMsg( pcszNameIn == NULL, "Enums shouldn't have names." );

    //
    //  Grab the object manager.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                               IObjectManager,
                               &pom
                               ) );
    psp->Release( );    // release promptly
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Ask the Object Manager for information about our cookie so we can
    //  get to the "parent" cookie.
    //

    hr = THR( pom->GetObject( DFGUID_StandardInfo,
                              cookieIn,
                              reinterpret_cast< IUnknown ** >( &psi )
                              ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = STHR( psi->GetParent( &cookieParent ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Now ask the Object Manager for a cookie enumerator.
    //

    hr = THR( pom->FindObject( CLSID_IPAddressType,
                               cookieParent,
                               NULL,
                               DFGUID_EnumCookies,
                               NULL,
                               reinterpret_cast< IUnknown ** >( &pec )
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    pec = TraceInterface( L"CEnumIPAddresses!IEnumCookies", IEnumCookies, pec, 1 );

    //
    //  Ask the enumerator how many cookies it has.
    //

    hr = THR( pec->Count( &cookieCount ) );

    if ( FAILED( hr ) )
        goto Cleanup;

    m_cAlloced = cookieCount;

    if ( m_cAlloced == 0 )
        goto ErrorNotFound;

    //
    //  Allocate a buffer to store the punks.
    //

    m_pList = (IClusCfgIPAddressInfo **) TraceAlloc( HEAP_ZERO_MEMORY, m_cAlloced * sizeof(IClusCfgIPAddressInfo *) );
    if ( m_pList == NULL )
        goto OutOfMemory;

    //
    //  Reset the enumerator.
    //

    hr = THR( pec->Reset( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Now loop thru to collect the interfaces.
    //

    m_cIter = 0;
    while ( hr == S_OK && m_cIter < m_cAlloced )
    {
        hr = STHR( pec->Next( 1, &cookie, NULL ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( hr == S_FALSE )
            break;  // exit condition

        hr = THR( pom->GetObject( DFGUID_IPAddressInfo,
                                  cookie,
                                  reinterpret_cast< IUnknown ** >( &m_pList[ m_cIter ] )
                                  ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        m_cIter++;

    } // while: S_OK

    //
    //  Reset the iter.
    //

    m_cIter = 0;

    //
    //  Grab the interface.
    //

    hr = THR( QueryInterface( DFGUID_EnumIPAddressInfo,
                              reinterpret_cast< void ** >( ppunkOut )
                              ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( pom != NULL )
    {
        pom->Release( );
    }
    if ( psi != NULL )
    {
        psi->Release( );
    }
    if ( pec != NULL )
    {
        pec->Release( );
    }

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

InvalidType:
    //
    //  TODO:   gpease  07-APR-2000
    //          Come up with a better error code.
    //
    hr = THR( E_FAIL );
    goto Cleanup;

ErrorNotFound:
    // The error text is better than the coding value.
    hr = THR( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // FindObject( )


//****************************************************************************
//
//  IEnumClusCfgIPAddresses
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumIPAddresses::Next(
//      ULONG celt,
//      IClusCfgNode ** rgOut,
//      ULONG * pceltFetchedOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumIPAddresses::Next(
    ULONG celt,
    IClusCfgIPAddressInfo * rgOut[],
    ULONG * pceltFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    ULONG   celtFetched;

    HRESULT hr = E_UNEXPECTED;

    //
    //  Check parameters
    //

    if ( rgOut == NULL || celt == 0 )
        goto InvalidPointer;

    //
    //  Zero the return count.
    //

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = 0;
    }

    //
    //  Clear the buffer
    //

    ZeroMemory( rgOut, celt * sizeof(rgOut[0]) );

    //
    //  Loop thru copying the interfaces.
    //

    for( celtFetched = 0
       ; celtFetched + m_cIter < m_cAlloced && celtFetched < celt
       ; celtFetched ++
       )
    {
        hr = THR( m_pList[ m_cIter + celtFetched ]->TypeSafeQI( IClusCfgIPAddressInfo, &rgOut[ celtFetched ] ) );
        if ( FAILED( hr ) )
            goto CleanupList;

        rgOut[ celtFetched ] = TraceInterface( L"EnumIPAddresses!IClusCfgIPAddressInfo", IClusCfgIPAddressInfo, rgOut[ celtFetched ], 1 );

    } // for: celtFetched

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = celtFetched;
    }

    m_cIter += celtFetched;

    if ( celtFetched != celt )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    HRETURN( hr );

CleanupList:
    for ( ; celtFetched != 0 ; )
    {
        celtFetched --;
        rgOut[ celtFetched ]->Release( );
        rgOut[ celtFetched ] = NULL;
    }
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} // Next( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumIPAddresses::Skip(
//      ULONG celt
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumIPAddresses::Skip(
    ULONG celt
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_OK;

    m_cIter += celt;

    if ( m_cIter > m_cAlloced )
    {
        m_cIter = m_cAlloced;
        hr = S_FALSE;
    }

    HRETURN( hr );

} // Skip( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumIPAddresses::Reset( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumIPAddresses::Reset( void )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_OK;

    m_cIter = 0;

    HRETURN( hr );

} // Reset( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumIPAddresses::Clone(
//      IEnumClusCfgIPAddresses ** ppenumOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumIPAddresses::Clone(
    IEnumClusCfgIPAddresses ** ppenumOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    //
    //  KB: not going to implement this method.
    //
    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} // Clone( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumIPAddresses::Count(
//      DWORD * pnCountOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumIPAddresses::Count(
    DWORD * pnCountOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pnCountOut = m_cAlloced;

Cleanup:
    HRETURN( hr );
}// Count( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\enumcpinotifyui.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      EnumCPINotifyUI.cpp
//
//  Description:
//      INotifyUI Connection Point Enumerator implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 04-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "EnumCPINotifyUI.h"

DEFINE_THISCLASS("CEnumCPINotifyUI")

#define PUNK_BUFFER_GROW_SIZE   10

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumCPINotifyUI::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCPINotifyUI::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CEnumCPINotifyUI * lpcc = new CEnumCPINotifyUI( );
    if ( lpcc != NULL )
    {
        hr = THR( lpcc->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( lpcc->TypeSafeQI( IUnknown, ppunkOut ) );
        } // if: success

        lpcc->Release( );

    } // if: got object
    else
    {
        hr = E_OUTOFMEMORY;
    } // else: out of memory

    HRETURN( hr );

} // S_HrCreateInstance( )

//
// Constructor
//
CEnumCPINotifyUI::CEnumCPINotifyUI( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CEnumCPINotifyUI( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumCPINotifyUI::Init( )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPINotifyUI::Init( )
{
    TraceFunc( "" );

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );  // Add one count

    // IEnumConnectionPoints
    Assert( m_cAlloced == 0 );
    Assert( m_cCurrent == 0 );
    Assert( m_cIter == 0 );
    Assert( m_pList == NULL );

    // INotifyUI

    HRETURN( S_OK );

} // Init( )

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumCPINotifyUI::~CEnumCPINotifyUI( )
//
//////////////////////////////////////////////////////////////////////////////
CEnumCPINotifyUI::~CEnumCPINotifyUI( )
{
    TraceFunc( "" );

    if ( m_pList != NULL )
    {
        while( m_cAlloced != 0 )
        {
            IUnknown * punk;

            m_cAlloced --;

            punk = m_pList[ m_cAlloced ];

            AssertMsg( punk == NULL, "Someone didn't Unadvise before releasing the last Ref" );
            if ( punk != NULL )
            {
                punk->Release( );
            }

        } // while: m_cAlloced

        TraceFree( m_pList );
    }

	InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CEnumCPINotifyUI( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumCPINotifyUI::QueryInterface( 
//      REFIID riid, 
//      LPVOID *ppv 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPINotifyUI::QueryInterface( 
    REFIID riid, 
    LPVOID *ppv 
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IEnumConnections * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IEnumConnections ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumConnections, this, 0 );
        hr   = S_OK;
    } // else if: IEnumConnections

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} // QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumCPINotifyUI::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumCPINotifyUI::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumCPINotifyUI::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumCPINotifyUI::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release( )


// ************************************************************************
//
// IEnumConnectionPoints
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CEnumCPINotifyUI::Next( 
//      ULONG cConnectionsIn,
//      LPCONNECTIONPOINT *ppCPOut,
//      ULONG *pcFetchedOut 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPINotifyUI::Next(
    ULONG cConnectionsIn,
    LPCONNECTDATA rgcd,
    ULONG *pcFetchedOut
    )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    ULONG   cIter;

    HRESULT hr = E_UNEXPECTED;

    if ( pcFetchedOut != NULL )
    {
        *pcFetchedOut = 0;
    }

    for( cIter = 0
       ; ( cIter < cConnectionsIn ) && ( m_cIter < m_cCurrent )
       ; m_cIter ++
       )
    {
        IUnknown * punk = m_pList[ m_cIter ];
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IUnknown, &rgcd[ cIter ].pUnk ) );
            if ( FAILED( hr ) )
                goto Error;

            rgcd[ cIter ].pUnk = TraceInterface( L"EnumCPINotifyUI!IUnknown", IUnknown, rgcd[ cIter ].pUnk, 1 );

            rgcd[ cIter ].dwCookie = m_cIter + 1;

            cIter ++;
        }

    } // for: cIter

    if ( cIter != cConnectionsIn )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    if ( pcFetchedOut != NULL )
    {
        *pcFetchedOut = cIter;
    }

Cleanup:
    HRETURN( hr );

Error:
    while( cIter != 0 )
    {
        cIter --;
        rgcd[ cIter ].pUnk->Release( );
    }
    goto Cleanup;

} // Next( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CEnumCPINotifyUI::Skip( 
//      ULONG cConnectionsIn 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPINotifyUI::Skip(
    ULONG cConnectionsIn
    )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    HRESULT hr = S_OK;

    m_cIter += cConnectionsIn;
    if ( m_cIter >= m_cCurrent )
    {
        m_cIter = m_cCurrent;
        hr = S_FALSE;
    }

    HRETURN( hr );

} // Skip( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CEnumCPINotifyUI::Reset( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPINotifyUI::Reset( void )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    HRESULT hr = S_OK;

    m_cIter = 0;

    HRETURN( hr );

} // Reset( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CEnumCPINotifyUI::Clone( 
//      IEnumConnectionPoints **ppEnumOut 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCPINotifyUI::Clone( 
    IEnumConnections **ppEnumOut
    )
{
    TraceFunc( "[IEnumConnectionPoints]" );

    HRESULT hr;

    CEnumCPINotifyUI * pecp = new CEnumCPINotifyUI( );
    if ( pecp == NULL )
        goto OutOfMemory;

    hr = THR( pecp->Init( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pecp->HrCopy( this ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pecp->TypeSafeQI( IEnumConnections, ppEnumOut ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    *ppEnumOut = TraceInterface( L"EnumCPINotifyUI!IEnumConnections", IEnumConnections, *ppEnumOut, 1 );

    pecp->Release( );
    pecp = NULL;

Cleanup:
    if ( pecp != NULL )
    {
        delete pecp;
    }

    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // Clone( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumCPINotifyUI::HrCopy( 
//      CEnumCPINotifyUI * pecpIn 
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCPINotifyUI::HrCopy( 
    CEnumCPINotifyUI * pecpIn 
    )
{
    TraceFunc( "" );

    HRESULT hr = E_UNEXPECTED;

    ULONG cIter;

    Assert( m_cAlloced == 0 );
    Assert( m_cCurrent == 0 );
    Assert( m_pList == 0 );

    m_pList = (IUnknown**) TraceAlloc( HEAP_ZERO_MEMORY, pecpIn->m_cCurrent * sizeof( IUnknown * ) );
    if ( m_pList == NULL )
        goto OutOfMemory;

    m_cCurrent = m_cAlloced = pecpIn->m_cCurrent;
    m_cIter = 0;

    for( cIter = 0; cIter < pecpIn->m_cCurrent; cIter ++ )
    {
        hr = THR( pecpIn->m_pList[ cIter ]->TypeSafeQI( IUnknown, &m_pList[ cIter ] ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        m_pList[ cIter ] = TraceInterface( L"EnumCPINotifyUI!IUnknown", IUnknown, m_pList[ cIter ], 1 );
    }

    hr = S_OK;

Cleanup:
    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // HrCopy( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumCPINotifyUI::HrAddConnection( 
//      INotifyUI * punkIn, 
//      DWORD * pdwCookieOut 
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCPINotifyUI::HrAddConnection( 
    IUnknown * punkIn, 
    DWORD * pdwCookieOut 
    )
{
    TraceFunc( "" );

    HRESULT hr = E_UNEXPECTED;

    ULONG cIter;

    if ( pdwCookieOut == NULL )
        goto InvalidPointer;

    //
    //  See if there is an openning in the currently allocated list.
    //

    for ( cIter = 0; cIter < m_cCurrent; cIter ++ )
    {
        if ( m_pList[ cIter ] == NULL )
        {
            //
            //  Found an openning... try to use it.
            //

            hr = THR( punkIn->TypeSafeQI( IUnknown, &m_pList[ cIter ] ) );

            m_pList[ cIter ] = TraceInterface( L"CEnumCPINotifyUI!IUnknown", IUnknown, m_pList[ cIter ], 1 );

            *pdwCookieOut = cIter + 1;

            //  Doesn't matter if it succeeded or fail, exit.
            goto Cleanup;
        }
    }

    if ( m_cCurrent == m_cAlloced )
    {
        IUnknown ** pNewList;

        //
        //  Try making some more space.
        //

        pNewList = (IUnknown **) TraceAlloc( HEAP_ZERO_MEMORY, ( m_cAlloced + PUNK_BUFFER_GROW_SIZE ) * sizeof( IUnknown * ) );
        if ( pNewList == NULL )
            goto OutOfMemory;

        CopyMemory( pNewList, m_pList, m_cCurrent * sizeof( IUnknown * ) );
        TraceFree( m_pList );

        m_pList = pNewList;
        m_cAlloced += PUNK_BUFFER_GROW_SIZE;
    }

    //
    //  Add it to the list.
    //

    hr = THR( punkIn->TypeSafeQI( IUnknown, &m_pList[ m_cCurrent ] ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    m_pList[ m_cCurrent ] = TraceInterface( L"CEnumCPINotifyUI!IUnknown", IUnknown, m_pList[ m_cCurrent ], 1 );

    m_cCurrent ++;
    *pdwCookieOut = m_cCurrent; // starts at ONE, not ZERO

Cleanup:
    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} // HrAddConnection( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumCPINotifyUI::HrRemoveConnection( 
//      DWORD dwCookieIn 
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCPINotifyUI::HrRemoveConnection( 
    DWORD dwCookieIn 
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( dwCookieIn == 0 || dwCookieIn > m_cCurrent )
        goto InvalidArg;

    if ( m_pList[ dwCookieIn - 1 ] == NULL )
        goto InvalidArg;

    m_pList[ dwCookieIn - 1 ]->Release( );
    m_pList[ dwCookieIn - 1 ] = NULL;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} // HrRemoveConnection( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\enumcpinotifyui.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CEnumCPINotifyUI.h
//
//  Description:
//      INotifyUI Connection Point Enumerator implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 04-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CCPINotifyUI;

// CEnumCPINotifyUI
class 
CEnumCPINotifyUI:
    public IEnumConnections
{
friend class CCPINotifyUI;
private:
    // IUnknown
    LONG                m_cRef;         //  Reference counter

    // IEnumConnections
    ULONG               m_cAlloced;     //  Alloced number of entries
    ULONG               m_cCurrent;     //  Number of entries currently used
    ULONG               m_cIter;        //  The Iter
    IUnknown * *        m_pList;        //  List of sinks (IUnknown)

    // INotifyUI

private: // Methods
    CEnumCPINotifyUI( );
    ~CEnumCPINotifyUI();
    STDMETHOD(Init)( );

    HRESULT
        HrCopy( CEnumCPINotifyUI * pecpIn );
    HRESULT
        HrAddConnection( IUnknown * punkIn, DWORD * pdwCookieOut );
    HRESULT
        HrRemoveConnection( DWORD dwCookieIn );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )(void);
    STDMETHOD_( ULONG, Release )(void);

    // IEnumConnections
    STDMETHOD( Next )( ULONG cConnectionsIn,
                       LPCONNECTDATA rgcd,
                       ULONG *pcFetchedOut ); 
    STDMETHOD( Skip )( ULONG cConnectionsIn );
    STDMETHOD( Reset )( void );
    STDMETHOD( Clone )( IEnumConnections **ppEnumOut );
        
}; // class CEnumCPINotifyUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\enumipaddresses.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      EnumIPAddresses.h
//
//  Description:
//      CEnumIPAddresses implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 24-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CEnumIPAddresses
class
CEnumIPAddresses:
    public IExtendObjectManager,
    public IEnumClusCfgIPAddresses
{
private:
    // IUnknown
    LONG                        m_cRef;     //  Reference counter

    // IEnumClusCfgNetworks
    ULONG                       m_cAlloced; //  Allocation size of the list
    ULONG                       m_cIter;    //  Out iter
    IClusCfgIPAddressInfo **    m_pList;    //  List of interfaces

private: // Methods
    CEnumIPAddresses( );
    ~CEnumIPAddresses();
    STDMETHOD( Init )( void );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IEnumClusCfgNetworks
    STDMETHOD( Next )( ULONG celt, IClusCfgIPAddressInfo * rgNetworksOut[], ULONG * pceltFetchedOut );
    STDMETHOD( Skip )( ULONG celt );
    STDMETHOD( Reset )( void );
    STDMETHOD( Clone )( IEnumClusCfgIPAddresses ** ppenumOut );
    STDMETHOD( Count )( DWORD * pnCountOut );

    // IExtendObjectManager
    STDMETHOD( FindObject )(
                      OBJECTCOOKIE  cookieParent
                    , REFCLSID      rclsidTypeIn
                    , LPCWSTR       pcszNameIn
                    , LPUNKNOWN *   ppunkOut
                    );

}; // class CEnumIPAddresses
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\enummanageablenetworks.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      EnumManageableNetworks.h
//
//  Description:
//      CEnumManageableNetworks implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CEnumManageableNetworks
class
CEnumManageableNetworks:
    public IExtendObjectManager,
    public IEnumClusCfgNetworks
{
private:
    // IUnknown
    LONG                            m_cRef;     //  Reference counter

    // IEnumClusCfgNetworks
    ULONG                           m_cAlloced; //  Current allocation size of list
    ULONG                           m_cIter;    //  Our iter counter
    IClusCfgNetworkInfo **          m_pList;    //  Our copy of the list of networks.

private: // Methods
    CEnumManageableNetworks( );
    ~CEnumManageableNetworks();
    STDMETHOD( Init )( void );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IEnumClusCfgNetworks
    STDMETHOD( Next )( ULONG celt, IClusCfgNetworkInfo * rgNetworksOut[], ULONG * pceltFetchedOut );
    STDMETHOD( Skip )( ULONG celt );
    STDMETHOD( Reset )( void );
    STDMETHOD( Clone )( IEnumClusCfgNetworks ** ppenumOut );
    STDMETHOD( Count )( DWORD * pnCountOut );

    // IExtendObjectManager
    STDMETHOD( FindObject )(
                  OBJECTCOOKIE  cookieIn
                , REFCLSID      rclsidTypeIn
                , LPCWSTR       pcszNameIn
                , LPUNKNOWN *   ppunkOut
                );

}; // class CEnumManageableNetworks
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\enummanageablenetworks.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      EnumManageableNetworks.cpp
//
//  Description:
//      CEnumManageableNetworks implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "ManagedNetwork.h"
#include "EnumManageableNetworks.h"

DEFINE_THISCLASS("CEnumManageableNetworks")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumManageableNetworks::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumManageableNetworks::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CEnumManageableNetworks * pemn = new CEnumManageableNetworks;
    if ( pemn != NULL )
    {
        hr = THR( pemn->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pemn->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pemn->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumManageableNetworks::CEnumManageableNetworks( void )
//
//////////////////////////////////////////////////////////////////////////////
CEnumManageableNetworks::CEnumManageableNetworks( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CEnumManageableNetworks( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableNetworks::Init( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableNetworks::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );    // Add one count

    // IEnumClusCfgNetworks
    Assert( m_cAlloced == 0 );
    Assert( m_cIter == 0 );
    Assert( m_pList == NULL );

    HRETURN( hr );

} // Init( )

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumManageableNetworks::~CEnumManageableNetworks( )
//
//////////////////////////////////////////////////////////////////////////////
CEnumManageableNetworks::~CEnumManageableNetworks( )
{
    TraceFunc( "" );

    if ( m_pList != NULL )
    {
        while ( m_cAlloced != 0 )
        {
            m_cAlloced --;
            AssertMsg( m_pList[ m_cAlloced ], "This shouldn't happen." );
            if ( m_pList[ m_cAlloced ] != NULL )
            {
                (m_pList[ m_cAlloced ])->Release( );
            }
        }

        TraceFree( m_pList );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CEnumManageableNetworks( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableNetworks::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableNetworks::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IEnumClusCfgNetworks * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IEnumClusCfgNetworks ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumClusCfgNetworks, this, 0 );
        hr   = S_OK;
    } // else if: IEnumClusCfgNetworks
    else if ( IsEqualIID( riid, IID_IExtendObjectManager ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IExtendObjectManager, this, 0 );
        hr   = S_OK;
    } // else if: IExtendObjectManager

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} // QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumManageableNetworks::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumManageableNetworks::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumManageableNetworks::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumManageableNetworks::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release( )


// ************************************************************************
//
//  IExtendObjectManager
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CEnumManageableNetworks::FindObject(
//        OBJECTCOOKIE  cookieIn
//      , REFCLSID      rclsidTypeIn
//      , LPCWSTR       pcszNameIn
//      , LPUNKNOWN *   punkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableNetworks::FindObject(
      OBJECTCOOKIE  cookieIn
    , REFCLSID      rclsidTypeIn
    , LPCWSTR       pcszNameIn
    , LPUNKNOWN *   ppunkOut
    )
{
    TraceFunc( "[IExtendObjectManager]" );

    OBJECTCOOKIE    cookie;
    OBJECTCOOKIE    cookieParent;

    IServiceProvider * psp;

    HRESULT hr = E_UNEXPECTED;

    IObjectManager * pom  = NULL;
    IStandardInfo *  psi  = NULL;
    IEnumCookies *   pec  = NULL;

    DWORD   cookieCount = 0;

    //
    //  Check arguments
    //

    if ( cookieIn == 0 )
        goto InvalidArg;

    if ( rclsidTypeIn != CLSID_NetworkType )
        goto InvalidType;

    if ( ppunkOut == NULL )
        goto InvalidPointer;

    AssertMsg( pcszNameIn == NULL, "Enums shouldn't have names." );

    //
    //  Grab the object manager.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                               IObjectManager,
                               &pom
                               ) );
    psp->Release( );    // release promptly
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Ask the Object Manager for information about our cookie so we can
    //  get to the "parent" cookie.
    //

    hr = THR( pom->GetObject( DFGUID_StandardInfo,
                              cookieIn,
                              reinterpret_cast< IUnknown ** >( &psi )
                              ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = STHR( psi->GetParent( &cookieParent ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Now ask the Object Manager for a cookie enumerator.
    //

    hr = THR( pom->FindObject( CLSID_NetworkType,
                               cookieParent,
                               NULL,
                               DFGUID_EnumCookies,
                               NULL,
                               reinterpret_cast< IUnknown ** >( &pec )
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    pec = TraceInterface( L"CEnumManageableNetworks!IEnumCookies", IEnumCookies, pec, 1 );

    //
    //  Ask the enumerator how many cookies it has.
    //

    hr = THR( pec->Count( &cookieCount ) );

    if ( FAILED( hr ) )
        goto Cleanup;

    m_cAlloced = cookieCount;

    if ( m_cAlloced == 0 )
        goto ErrorNotFound;

    //
    //  Allocate a buffer to store the punks.
    //

    m_pList = (IClusCfgNetworkInfo **) TraceAlloc( HEAP_ZERO_MEMORY, m_cAlloced * sizeof(IClusCfgNetworkInfo *) );
    if ( m_pList == NULL )
        goto OutOfMemory;

    //
    //  Reset the enumerator.
    //

    hr = THR( pec->Reset( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Now loop thru to collect the interfaces.
    //

    m_cIter = 0;
    while ( hr == S_OK && m_cIter < m_cAlloced )
    {
        hr = STHR( pec->Next( 1, &cookie, NULL ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( hr == S_FALSE )
            break;  // exit condition

        hr = THR( pom->GetObject( DFGUID_NetworkResource,
                                  cookie,
                                  reinterpret_cast< IUnknown ** >( &m_pList[ m_cIter ] )
                                  ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        m_cIter++;

    } // while: S_OK

    //
    //  Reset the iter.
    //

    m_cIter = 0;

    //
    //  Grab the interface.
    //

    hr = THR( QueryInterface( DFGUID_EnumManageableNetworks,
                              reinterpret_cast< void ** >( ppunkOut )
                              ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( pom != NULL )
    {
        pom->Release( );
    }
    if ( psi != NULL )
    {
        psi->Release( );
    }
    if ( pec != NULL )
    {
        pec->Release( );
    }

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

InvalidType:
    //
    //  TODO:   gpease  07-APR-2000
    //          Come up with a better error code.
    //
    hr = THR( E_FAIL );
    goto Cleanup;

ErrorNotFound:
    // The error text is better than the coding value.
    hr = THR( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // FindObject( )


//****************************************************************************
//
//  IEnumClusCfgNetworks
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableNetworks::Next(
//      ULONG celt,
//      IClusCfgNetworkInfo ** rgOut,
//      ULONG * pceltFetchedOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableNetworks::Next(
    ULONG celt,
    IClusCfgNetworkInfo * rgOut[],
    ULONG * pceltFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    ULONG   celtFetched;

    HRESULT hr = E_UNEXPECTED;

    //
    //  Check parameters
    //

    if ( rgOut == NULL || celt == 0 )
        goto InvalidPointer;

    //
    //  Zero the return count.
    //

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = 0;
    }

    //
    //  Clear the buffer
    //

    ZeroMemory( rgOut, celt * sizeof(rgOut[0]) );

    //
    //  Loop thru copying the interfaces.
    //

    for( celtFetched = 0
       ; celtFetched + m_cIter < m_cAlloced && celtFetched < celt
       ; celtFetched ++
       )
    {
        hr = THR( m_pList[ m_cIter + celtFetched ]->TypeSafeQI( IClusCfgNetworkInfo, &rgOut[ celtFetched ] ) );
        if ( FAILED( hr ) )
            goto CleanupList;

        rgOut[ celtFetched ] = TraceInterface( L"CEnumManageableNetworks!IClusCfgNetworkInfo", IClusCfgNetworkInfo, rgOut[ celtFetched ], 1 );

    } // for: celtFetched

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = celtFetched;
    }

    m_cIter += celtFetched;

    if ( celtFetched != celt )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    HRETURN( hr );

CleanupList:
    for ( ; celtFetched != 0 ; )
    {
        celtFetched --;
        rgOut[ celtFetched ]->Release( );
        rgOut[ celtFetched ] = NULL;
    }
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} // Next( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableNetworks::Skip(
//      ULONG celt
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableNetworks::Skip(
    ULONG celt
    )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    HRESULT hr = S_OK;

    m_cIter += celt;

    if ( m_cIter > m_cAlloced )
    {
        m_cIter = m_cAlloced;
        hr = S_FALSE;
    }

    HRETURN( hr );

} // Skip( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableNetworks::Reset( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableNetworks::Reset( void )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    HRESULT hr = S_OK;

    m_cIter = 0;

    HRETURN( hr );

} // Reset( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableNetworks::Clone(
//      IEnumClusCfgNetworks ** ppenumOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableNetworks::Clone(
    IEnumClusCfgNetworks ** ppenumOut
    )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    //
    //  KB: not going to implement this method.
    //
    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} // Clone( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableNetworks::Count(
//      DWORD * pnCountOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableNetworks::Count(
    DWORD * pnCountOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pnCountOut = m_cAlloced;

Cleanup:
    HRETURN( hr );
}// Count( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\enumnodeinformation.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      EnumNodeInformation.h
//
//  Description:
//      CEnumNodeInformation implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CEnumNodeInformation
class
CEnumNodeInformation:
    public IExtendObjectManager,
    public IEnumNodes
{
private:
    // IUnknown
    LONG                    m_cRef;

    // IEnumNodes
    ULONG                   m_cAlloced; //  Number in list
    ULONG                   m_cIter;    //  Iter current value.
    IClusCfgNodeInfo **     m_pList;    //  List of IClusCfgNodeInfo-s

    // IObjectManager

private: // Methods
    CEnumNodeInformation( );
    ~CEnumNodeInformation();
    STDMETHOD( Init )( void );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IEnumNodes
    STDMETHOD( Next )( ULONG celt, IClusCfgNodeInfo * rgNodesOut[], ULONG * pceltFetchedOut );
    STDMETHOD( Skip )( ULONG celt );
    STDMETHOD( Reset )( void );
    STDMETHOD( Clone )( IEnumNodes ** ppenumOut );
    STDMETHOD( Count )( DWORD * pnCountOut );

    // IExtendObjectManager
    STDMETHOD( FindObject )(
                  OBJECTCOOKIE  cookieIn
                , REFCLSID      rclsidTypeIn
                , LPCWSTR       pcszNameIn
                , LPUNKNOWN *   ppunkOut
                );

}; // class CEnumNodeInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\enummanageableresources.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      EnumManageableResources.cpp
//
//  Description:
//      CEnumManageableResources implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "ManagedDevice.h"
#include "EnumManageableResources.h"

DEFINE_THISCLASS("CEnumManageableResources")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumManageableResources::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumManageableResources::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CEnumManageableResources * pemr = new CEnumManageableResources;
    if ( pemr != NULL )
    {
        hr = THR( pemr->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pemr->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pemr->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumManageableResources::CEnumManageableResources( void )
//
//////////////////////////////////////////////////////////////////////////////
CEnumManageableResources::CEnumManageableResources( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CEnumManageableResources( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableResources::Init( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableResources::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );    // Add one count

    // IEnumClusCfgManagedResources
    Assert( m_cAlloced == 0 );
    Assert( m_cIter == 0 );
    Assert( m_pList == NULL );

    HRETURN( hr );

} // Init( )

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumManageableResources::~CEnumManageableResources( )
//
//////////////////////////////////////////////////////////////////////////////
CEnumManageableResources::~CEnumManageableResources( )
{
    TraceFunc( "" );

    if ( m_pList != NULL )
    {
        while ( m_cAlloced != 0 )
        {
            m_cAlloced --;
            AssertMsg( m_pList[ m_cAlloced ], "This shouldn't happen" );
            if ( m_pList[ m_cAlloced ] != NULL )
            {
                (m_pList[ m_cAlloced ])->Release( );
            }
        }

        TraceFree( m_pList );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CEnumManageableResources( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableResources::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableResources::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IEnumClusCfgManagedResources * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IEnumClusCfgManagedResources ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumClusCfgManagedResources, this, 0 );
        hr   = S_OK;
    } // else if: IEnumClusCfgManagedResources
    else if ( IsEqualIID( riid, IID_IExtendObjectManager ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IExtendObjectManager, this, 0 );
        hr   = S_OK;
    } // else if: IExtendObjectManager

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} // QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumManageableResources::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumManageableResources::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumManageableResources::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumManageableResources::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release( )


// ************************************************************************
//
//  IExtendObjectManager
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CEnumManageableResources::FindObject(
//        OBJECTCOOKIE  cookieIn
//      , REFCLSID      rclsidTypeIn
//      , LPCWSTR       pcszNameIn
//      , LPUNKNOWN *   punkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableResources::FindObject(
      OBJECTCOOKIE  cookieIn
    , REFCLSID      rclsidTypeIn
    , LPCWSTR       pcszNameIn
    , LPUNKNOWN *   ppunkOut
    )
{
    TraceFunc( "[IExtendObjectManager]" );

    OBJECTCOOKIE    cookie;
    OBJECTCOOKIE    cookieParent;

    IServiceProvider * psp;

    HRESULT hr = E_UNEXPECTED;

    IObjectManager * pom  = NULL;
    IStandardInfo *  psi  = NULL;
    IEnumCookies *   pec  = NULL;

    DWORD objectCount = 0;

    //
    //  Check arguments
    //

    if ( cookieIn == 0 )
        goto InvalidArg;

    if ( rclsidTypeIn != CLSID_ManagedResourceType )
        goto InvalidType;

    if ( ppunkOut == NULL )
        goto InvalidPointer;

    AssertMsg( pcszNameIn == NULL, "Enums shouldn't have names." );

    //
    //  Grab the object manager.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                               IObjectManager,
                               &pom
                               ) );
    psp->Release( );    // release promptly
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Ask the Object Manager for information about our cookie so we can
    //  get to the "parent" cookie.
    //

    hr = THR( pom->GetObject( DFGUID_StandardInfo,
                              cookieIn,
                              reinterpret_cast< IUnknown ** >( &psi )
                              ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = STHR( psi->GetParent( &cookieParent ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Now ask the Object Manager for a cookie enumerator.
    //

    hr = THR( pom->FindObject( CLSID_ManagedResourceType,
                               cookieParent,
                               NULL,
                               DFGUID_EnumCookies,
                               NULL,
                               reinterpret_cast< IUnknown ** >( &pec )
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    pec = TraceInterface( L"CEnumClusCfgManagedResources!IEnumCookies", IEnumCookies, pec, 1 );


    hr = pec->Count( &objectCount );
    if ( FAILED( hr ) )
        goto Cleanup;

    m_cAlloced = objectCount;

    if ( m_cAlloced == 0 )
        goto ErrorNotFound;

    //
    //  Allocate a buffer to store the punks.
    //

    m_pList = (IClusCfgManagedResourceInfo **) TraceAlloc( HEAP_ZERO_MEMORY, m_cAlloced * sizeof(IClusCfgManagedResourceInfo *) );
    if ( m_pList == NULL )
        goto OutOfMemory;

    //
    //  Reset the enumerator.
    //

    hr = THR( pec->Reset( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Now loop thru to collect the interfaces.
    //

    m_cIter = 0;
    while ( hr == S_OK && m_cIter < m_cAlloced )
    {
        hr = STHR( pec->Next( 1, &cookie, NULL ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( hr == S_FALSE )
            break;  // exit condition

        hr = THR( pom->GetObject( DFGUID_ManagedResource,
                                  cookie,
                                  reinterpret_cast< IUnknown ** >( &m_pList[ m_cIter ] )
                                  ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        m_cIter++;

    } // while: S_OK

    //
    //  Reset the iter.
    //

    m_cIter = 0;

    //
    //  Grab the interface.
    //

    hr = THR( QueryInterface( DFGUID_EnumManageableResources,
                              reinterpret_cast< void ** >( ppunkOut )
                              ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( pom != NULL )
    {
        pom->Release( );
    }
    if ( psi != NULL )
    {
        psi->Release( );
    }
    if ( pec != NULL )
    {
        pec->Release( );
    }

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

InvalidType:
    //
    //  TODO:   gpease  07-APR-2000
    //          Come up with a better error code.
    //
    hr = THR( E_FAIL );
    goto Cleanup;

ErrorNotFound:
    // The error text is better than the coding value.
    hr = THR( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // FindObject( )


//****************************************************************************
//
//  IEnumClusCfgManagedResources
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableResources::Next(
//      ULONG celt,
//      IClusCfgNetworkInfo ** rgOut,
//      ULONG * pceltFetchedOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableResources::Next(
    ULONG celt,
    IClusCfgManagedResourceInfo * rgOut[],
    ULONG * pceltFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    ULONG   celtFetched;

    HRESULT hr = E_UNEXPECTED;

    //
    //  Check parameters
    //

    if ( rgOut == NULL || celt == 0 )
        goto InvalidPointer;

    //
    //  Zero the return count.
    //

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = 0;
    }

    //
    //  Clear the buffer
    //

    ZeroMemory( rgOut, celt * sizeof(rgOut[0]) );

    //
    //  Loop thru copying the interfaces.
    //

    for( celtFetched = 0
       ; celtFetched + m_cIter < m_cAlloced && celtFetched < celt
       ; celtFetched ++
       )
    {
        hr = THR( m_pList[ m_cIter + celtFetched ]->TypeSafeQI( IClusCfgManagedResourceInfo, &rgOut[ celtFetched ] ) );
        if ( FAILED( hr ) )
            goto CleanupList;

        rgOut[ celtFetched ] = TraceInterface( L"CEnumManageableResources!IClusCfgManagedResourceInfo", IClusCfgManagedResourceInfo, rgOut[ celtFetched ], 1  );

    } // for: celtFetched

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = celtFetched;
    }

    m_cIter += celtFetched;

    if ( celtFetched != celt )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    HRETURN( hr );

CleanupList:
    for ( ; celtFetched != 0 ; )
    {
        celtFetched --;
        rgOut[ celtFetched ]->Release( );
        rgOut[ celtFetched ] = NULL;
    }
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} // Next( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableResources::Skip(
//      ULONG celt
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableResources::Skip(
    ULONG celt
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    m_cIter += celt;

    if ( m_cIter > m_cAlloced )
    {
        m_cIter = m_cAlloced;
        hr = S_FALSE;
    }

    HRETURN( hr );

} // Skip( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableResources::Reset( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableResources::Reset( void )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    m_cIter = 0;

    HRETURN( hr );

} // Reset( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableResources::Clone(
//      IEnumClusCfgManagedResources ** ppenumOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableResources::Clone(
    IEnumClusCfgManagedResources ** ppenumOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    //
    //  KB: not going to implement this method.
    //
    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} // Clone( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumManageableResources::Count(
//      DWORD * pnCountOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumManageableResources::Count(
    DWORD * pnCountOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pnCountOut = m_cAlloced;

Cleanup:
    HRETURN( hr );
}// Count( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\enummanageableresources.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      EnumManageableResources.h
//
//  Description:
//      CEnumManageableResources implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 17-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CEnumManageableResources
class
CEnumManageableResources:
    public IExtendObjectManager,
    public IEnumClusCfgManagedResources
{
private:
    // IUnknown
    LONG                            m_cRef;         //  Ref count

    // IEnumClusCfgManagedResources
    ULONG                           m_cAlloced;     //  Current allocated size of the list.
    ULONG                           m_cIter;        //  Our iter counter
    IClusCfgManagedResourceInfo **  m_pList;        //  List of interfaces

private: // Methods
    CEnumManageableResources( );
    ~CEnumManageableResources();
    STDMETHOD( Init )( void );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IEnumClusCfgManagedResources
    STDMETHOD( Next )( ULONG celt, IClusCfgManagedResourceInfo * rgResourcesOut[], ULONG * pceltFetchedOut );
    STDMETHOD( Skip )( ULONG celt );
    STDMETHOD( Reset )( void );
    STDMETHOD( Clone )( IEnumClusCfgManagedResources ** ppenumOut );
    STDMETHOD( Count )( DWORD* pnCountOut );

    // IExtendObjectManager
    STDMETHOD( FindObject )(
                  OBJECTCOOKIE  cookieIn
                , REFCLSID      rclsidTypeIn
                , LPCWSTR       pcszNameIn
                , LPUNKNOWN *   ppunkOut
                );

}; // class CEnumManageableResources
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\ipaddressinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CIPAddressInfo.cpp
//
//  Description:
//      This file contains the definition of the CIPAddressInfo
//       class.
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "IPAddressInfo.h"
#include <ClusRtl.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CIPAddressInfo" );

/////////////////////////////////////////////////////////////////////////////
// CIPAddressInfo class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::S_HrCreateInstance()
//
//  Description:
//      Create a CIPAddressInfo instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CIPAddressInfo instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CIPAddressInfo::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr;
    CIPAddressInfo * lpccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Exit;
    } // if:

    lpccs = new CIPAddressInfo();
    if ( lpccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Exit;
    } // if: error allocating object

    hr = THR( lpccs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Exit;
    } // if: HrInit() failed

    hr = THR( lpccs->TypeSafeQI( IUnknown, ppunkOut ) );

Exit:

    if ( lpccs != NULL )
    {
        lpccs->Release();
    } // if:

    HRETURN( hr );

} //*** CIPAddressInfo::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::CIPAddressInfo()
//
//  Description:
//      Constructor of the CIPAddressInfo class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CIPAddressInfo::CIPAddressInfo( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_ulIPAddress == 0 );
    Assert( m_ulIPSubnet == 0 );
    Assert( m_bstrUID == NULL );
    Assert( m_bstrName == NULL );

    TraceFuncExit();

} //*** CIPAddressInfo::CIPAddressInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::~CIPAddressInfo()
//
//  Description:
//      Desstructor of the CIPAddressInfo class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CIPAddressInfo::~CIPAddressInfo( void )
{
    TraceFunc( "" );

    if ( m_bstrUID != NULL )
    {
        TraceSysFreeString( m_bstrUID );
    }

    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CIPAddressInfo::~CIPAddressInfo


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CIPAddressInfo -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CIPAddressInfo:: [IUNKNOWN] AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CIPAddressInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CIPAddressInfo::AddRef()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CIPAddressInfo:: [IUNKNOWN] Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CIPAddressInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef > 0 )
    {
        RETURN( m_cRef );
    } // if: reference count greater than zero

   TraceDo( delete this );

   RETURN( 0 );

} //*** CIPAddressInfo::Release()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo:: [IUNKNOWN] QueryInterface()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressInfo::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IClusCfgIPAddressInfo * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgIPAddressInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgIPAddressInfo, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IGatherData ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IGatherData, this, 0 );
        hr = S_OK;
    } // else if: IGatherData

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CIPAddressInfo::QueryInterface()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CIPAddressInfo class -- IObjectManager interface
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::FindObject()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressInfo::FindObject(
      OBJECTCOOKIE        cookieIn
    , REFCLSID            rclsidTypeIn
    , LPCWSTR             pcszNameIn
    , LPUNKNOWN *         ppunkOut
    )
{
    TraceFunc( "[IExtendObjectManager]" );

    HRESULT hr = E_UNEXPECTED;

    //
    //  Check parameters.
    //

    //  We need a cookie.
    if ( cookieIn == NULL )
        goto InvalidArg;

    //  We need to be representing a IPAddressType
    if ( !IsEqualIID( rclsidTypeIn, CLSID_IPAddressType ) )
        goto InvalidArg;

    //  We need to have a name.
    if ( pcszNameIn == NULL )
        goto InvalidArg;

    //
    //  Not found, nor do we know how to make a task to find it!
    //
    hr = THR( E_FAIL );

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} //*** CIPAddressInfo::FindObject()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CIPAddressInfo class -- IGatherData interface
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::Gather()
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressInfo::Gather(
    OBJECTCOOKIE    cookieParentIn,
    IUnknown *      punkIn
    )
{
    TraceFunc( "[IGatherData]" );

    HRESULT                         hr;
    IClusCfgIPAddressInfo *         pccipai = NULL;

    //
    //  Check parameters.
    //

    if ( punkIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    //
    //  Grab the right interface.
    //

    hr = THR( punkIn->TypeSafeQI( IClusCfgIPAddressInfo, &pccipai ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Transfer the information.
    //

    //
    //  Transfer the IP Address
    //

    hr = THR( pccipai->GetIPAddress( &m_ulIPAddress ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Transfer the Subnet mask
    //

    hr = THR( pccipai->GetSubnetMask( &m_ulIPSubnet ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Transfer the UID
    //

    hr = THR( pccipai->GetUID( &m_bstrUID ) );
    if ( FAILED( hr ) )
        goto Error;

    TraceMemoryAddBSTR( m_bstrUID );

    //
    //  Compute our name
    //

    hr = THR( LoadName() );
    if ( FAILED( hr ) )
        goto Error;

Cleanup:
    if ( pccipai != NULL )
    {
        pccipai->Release( );
    } // if:

    HRETURN( hr );

Error:
    if ( m_bstrUID != NULL )
    {
        TraceSysFreeString( m_bstrUID );
    } // if:

    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
    } // if:
    m_ulIPAddress = 0;
    m_ulIPSubnet = 0;
    goto Cleanup;

} //*** CIPAddressInfo::Gather()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CIPAddressInfo class -- IClusCfgIPAddressInfo interface
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::GetUID()
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressInfo::GetUID( BSTR * pbstrUIDOut )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Exit;
    } // if:

    *pbstrUIDOut = SysAllocString( m_bstrUID );
    if ( *pbstrUIDOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
    } // if:

Exit:

    HRETURN( hr );

} //*** CIPAddressInfo::GetUID()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::GetUIDGetIPAddress()
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressInfo::GetIPAddress( ULONG * pulDottedQuadOut )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr;

    if ( pulDottedQuadOut != NULL )
    {
        *pulDottedQuadOut = m_ulIPAddress;
        hr = S_OK;
    } // if:
    else
    {
        hr = THR( E_POINTER );
    } // else:

    HRETURN( hr );

} //*** CIPAddressInfo::GetNetworkGetIPAddress()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::SetIPAddress()
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressInfo::SetIPAddress( ULONG ulDottedQuad )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CIPAddressInfo::SetIPAddress()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::GetSubnetMask()
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressInfo::GetSubnetMask( ULONG * pulDottedQuadOut )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr;

    if ( pulDottedQuadOut != NULL )
    {
        *pulDottedQuadOut = m_ulIPSubnet;
        hr = S_OK;
    } // if:
    else
    {
        hr = THR( E_POINTER );
    } // else:

    HRETURN( hr );

} //*** CIPAddressInfo::GetSubnetMask()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::SetSubnetMask()
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressInfo::SetSubnetMask( ULONG ulDottedQuad )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CIPAddressInfo::SetSubnetMask()

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CIPAddressInfo class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::HrInit()
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressInfo::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CIPAddressInfo::HrInit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressInfo::LoadName()
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressInfo::LoadName( void )
{
    TraceFunc( "" );
    Assert( m_ulIPAddress != 0 );
    Assert( m_ulIPSubnet != 0 );

    HRESULT                 hr = E_FAIL;
    LPWSTR                  pszIPAddress = NULL;
    LPWSTR                  pszIPSubnet = NULL;
    DWORD                   sc;
    WCHAR                   sz[ 256 ];

    sc = TW32( ClRtlTcpipAddressToString( m_ulIPAddress, &pszIPAddress ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto CleanUp;
    } // if:

    sc = TW32( ClRtlTcpipAddressToString( m_ulIPSubnet, &pszIPSubnet ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto CleanUp;
    } // if:

    wnsprintf( sz, sizeof( sz ) / sizeof( sz[ 0 ] ), L"%s:%s", pszIPAddress, pszIPSubnet );

    m_bstrName = TraceSysAllocString( sz );
    if ( m_bstrName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto CleanUp;
    } // if:

    hr = S_OK;

CleanUp:

    if ( pszIPAddress != NULL )
    {
        LocalFree( pszIPAddress );
    } // if:

    if ( pszIPSubnet != NULL )
    {
        LocalFree( pszIPSubnet );
    } // if:

    HRETURN( hr );

} //*** CIPAddressInfo::LoadName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\enumnodeinformation.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      EnumNodeInformation.cpp
//
//  Description:
//      Node Information object implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "NodeInformation.h"
#include "EnumNodeInformation.h"

DEFINE_THISCLASS("CEnumNodeInformation")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumNodeInformation::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumNodeInformation::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CEnumNodeInformation * peni = new CEnumNodeInformation;
    if ( peni != NULL )
    {
        hr = THR( peni->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( peni->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        peni->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumNodeInformation::CEnumNodeInformation( void )
//
//////////////////////////////////////////////////////////////////////////////
CEnumNodeInformation::CEnumNodeInformation( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CEnumNodeInformation( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumNodeInformation::Init( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumNodeInformation::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );    // Add one count

    // IEnumNodes
    //Assert( m_pList == NULL );
    //Assert( m_cIter == 0 );

    HRETURN( hr );

} // Init( )

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumNodeInformation::~CEnumNodeInformation( )
//
//////////////////////////////////////////////////////////////////////////////
CEnumNodeInformation::~CEnumNodeInformation( )
{
    TraceFunc( "" );

    if ( m_pList != NULL )
    {
        while ( m_cAlloced != 0 )
        {
            m_cAlloced --;

            if( m_pList[m_cAlloced] )
            {
                (m_pList[m_cAlloced])->Release( );
            }
        }

        TraceFree( m_pList );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CEnumNodeInformation( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumNodeInformation::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumNodeInformation::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IEnumNodes * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IEnumNodes ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumNodes, this, 0 );
        hr   = S_OK;
    } // else if: IEnumNodes
    else if ( IsEqualIID( riid, IID_IExtendObjectManager ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IExtendObjectManager, this, 0 );
        hr = S_OK;
    } // else if: IExtendObjectManager

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} // QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumNodeInformation::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumNodeInformation::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumNodeInformation::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumNodeInformation::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release( )


// ************************************************************************
//
//  IExtendObjectManager
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CEnumNodeInformation::FindObject(
//        OBJECTCOOKIE  cookieIn
//      , REFCLSID      rclsidTypeIn
//      , LPCWSTR       pcszNameIn
//      , LPUNKNOWN *   punkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumNodeInformation::FindObject(
      OBJECTCOOKIE  cookieIn
    , REFCLSID      rclsidTypeIn
    , LPCWSTR       pcszNameIn
    , LPUNKNOWN *   ppunkOut
    )
{
    TraceFunc( "[IExtendObjectManager]" );

    OBJECTCOOKIE    cookie;
    OBJECTCOOKIE    cookieParent;

    IServiceProvider * psp;

    HRESULT hr = E_UNEXPECTED;

    IObjectManager * pom  = NULL;
    IStandardInfo *  psi  = NULL;
    IEnumCookies *   pec  = NULL;

    DWORD   cookieCount = 0;

    //
    //  Check arguments
    //

    if ( cookieIn == 0 )
        goto InvalidArg;

    if ( rclsidTypeIn != CLSID_NodeType )
        goto InvalidType;

    if ( ppunkOut == NULL )
        goto InvalidPointer;

    AssertMsg( pcszNameIn == NULL, "Enums shouldn't have names." );

    //
    //  Grab the object manager.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                               IObjectManager,
                               &pom
                               ) );
    psp->Release( );    // release promptly
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Ask the Object Manager for information about our cookie so we can
    //  get to the "parent" cookie.
    //

    hr = THR( pom->GetObject( DFGUID_StandardInfo,
                              cookieIn,
                              reinterpret_cast< IUnknown ** >( &psi )
                              ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = STHR( psi->GetParent( &cookieParent ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Now ask the Object Manager for a cookie enumerator.
    //

    hr = THR( pom->FindObject( CLSID_NodeType,
                               cookieParent,
                               NULL,
                               DFGUID_EnumCookies,
                               NULL,
                               reinterpret_cast< IUnknown ** >( &pec )
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    pec = TraceInterface( L"CEnumNodeInformation!IEnumCookies", IEnumCookies, pec, 1 );

    //
    //  Ask the enumerator how many cookies it has.
    //

    hr = pec->Count( &cookieCount );

    if ( FAILED( hr ) )
        goto Cleanup;

    m_cAlloced = cookieCount;

    if ( m_cAlloced == 0 )
        goto ErrorNotFound;

    //
    //  Allocate a buffer to store the punks.
    //

    m_pList = (IClusCfgNodeInfo **) TraceAlloc( HEAP_ZERO_MEMORY, m_cAlloced * sizeof(IClusCfgNodeInfo *) );
    if ( m_pList == NULL )
        goto OutOfMemory;

    //
    //  Now loop thru to collect the interfaces.
    //

    m_cIter = 0;
    while ( hr == S_OK && m_cIter < m_cAlloced )
    {
        hr = STHR( pec->Next( 1, &cookie, NULL ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( hr == S_FALSE )
            break;  // exit condition

        hr = THR( pom->GetObject( DFGUID_NodeInformation,
                                  cookie,
                                  reinterpret_cast< IUnknown ** >( &m_pList[ m_cIter ] )
                                  ) );
        if ( FAILED( hr ) )
        {
            Assert( m_pList[ m_cIter ] == NULL );
            goto Cleanup;
        }

        Assert( m_pList[ m_cIter ] != NULL );
        m_cIter++;

    } // while: S_OK

    //
    //  Reset the iter.
    //

    m_cIter = 0;

    //
    //  Grab the interface.
    //

    hr = THR( QueryInterface( DFGUID_EnumNodes,
                              reinterpret_cast< void ** >( ppunkOut )
                              ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( pom != NULL )
    {
        pom->Release( );
    }
    if ( psi != NULL )
    {
        psi->Release( );
    }
    if ( pec != NULL )
    {
        pec->Release( );
    }

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

InvalidType:
    //
    //  TODO:   gpease  07-APR-2000
    //          Come up with a better error code.
    //
    hr = THR( E_FAIL );
    goto Cleanup;

ErrorNotFound:
    // The error text is better than the coding value.
    hr = THR( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // FindObject( )


//****************************************************************************
//
//  IEnumNodes
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumNodeInformation::Next(
//      ULONG celt,
//      IClusCfgNode ** rgNodesOut,
//      ULONG * pceltFetchedOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumNodeInformation::Next(
    ULONG celt,
    IClusCfgNodeInfo * rgNodesOut[],
    ULONG * pceltFetchedOut
    )
{
    TraceFunc( "[IEnumNodes]" );

    ULONG   celtFetched;

    HRESULT hr = E_UNEXPECTED;

    //
    //  Check parameters
    //

    if ( rgNodesOut == NULL || celt == 0 )
        goto InvalidPointer;

    //
    //  Zero the return count.
    //

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = 0;
    }

    //
    //  Clear the buffer
    //

    ZeroMemory( rgNodesOut, celt * sizeof(rgNodesOut[0]) );

    //
    //  Loop thru copying the interfaces.
    //

    for( celtFetched = 0
       ; celtFetched + m_cIter < m_cAlloced && celtFetched < celt
       ; celtFetched ++
       )
    {
        hr = THR( m_pList[ m_cIter + celtFetched ]->TypeSafeQI( IClusCfgNodeInfo, &rgNodesOut[ celtFetched ] ) );
        if ( FAILED( hr ) )
            goto CleanupList;

        rgNodesOut[ celtFetched ] = TraceInterface( L"CEnumNodeInformation!IClusCfgNodeInfo", IClusCfgNodeInfo, rgNodesOut[ celtFetched ], 1 );

    } // for: celtFetched

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = celtFetched;
    }

    m_cIter += celtFetched;

    if ( celtFetched != celt )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    HRETURN( hr );

CleanupList:
    for ( ; celtFetched != 0 ; )
    {
        celtFetched --;
        rgNodesOut[ celtFetched ]->Release( );
        rgNodesOut[ celtFetched ] = NULL;
    }
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} // Next( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumNodeInformation::Skip(
//      ULONG celt
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumNodeInformation::Skip(
    ULONG celt
    )
{
    TraceFunc( "[IEnumNodes]" );

    HRESULT hr = S_OK;

    m_cIter += celt;

    if ( m_cIter > m_cAlloced )
    {
        m_cIter = m_cAlloced;
        hr = S_FALSE;
    }

    HRETURN( hr );

} // Skip( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumNodeInformation::Reset( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumNodeInformation::Reset( void )
{
    TraceFunc( "[IEnumNodes]" );

    HRESULT hr = S_OK;

    m_cIter = 0;

    HRETURN( hr );

} // Reset( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumNodeInformation::Clone(
//      IEnumNodes ** ppenumOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumNodeInformation::Clone(
    IEnumNodes ** ppenumOut
    )
{
    TraceFunc( "[IEnumNodes]" );

    //
    //  KB: not going to implement this method.
    //
    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} // Clone( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumNodeInformation::Count(
//      DWORD * pnCountOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumNodeInformation::Count(
    DWORD * pnCountOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pnCountOut = m_cAlloced;

Cleanup:
    HRETURN( hr );
}// Count( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\logger.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      Logger.cpp
//
//  Description:
//      ClCfgSrv Logger implementation.
//
//  Maintained By:
//      David Potter (DavidP)   11-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "Logger.h"

DEFINE_THISCLASS("C